SELECT (cooling_capacity_btu * usage_duration_hours / energy_efficiency_ratio) AS required_energy_btu FROM air_conditioner_info JOIN usage_records ON air_conditioner_info.ac_id = usage_records.ac_id WHERE air_conditioner_info.model = 'AC-1234' AND usage_records.mode = '制冷' AND usage_records.indoor_temperature_celsius = 30 AND usage_records.temperature_setting_celsius = 25;	air_conditioner	1
SELECT (cooling_capacity_btu * usage_duration_hours / energy_efficiency_ratio) AS required_energy_btu FROM air_conditioner_info JOIN usage_records ON air_conditioner_info.ac_id = usage_records.ac_id WHERE air_conditioner_info.model = 'AC-1234' AND usage_records.mode = 'cooling' AND usage_records.indoor_temperature_celsius = 30 AND usage_records.temperature_setting_celsius = 25;	air_conditioner	2
SELECT energy_efficiency_ratio * (1 - 0.1) AS energy_efficiency_ratio_high_humidity FROM air_conditioner_info WHERE ac_id = 'AC-5678';	air_conditioner	3
SELECT (100000 * 100 / 20 * 1.5) AS extreme_energy_consumption_kwh;	air_conditioner	4
SELECT (50 * 1.225 * 1005 * (35 - 20)) / (12000 * 1055.06 / 3600) AS required_time_hours;	air_conditioner	1
SELECT ((90 * 12 * 1800) + (90 * 6 * 1200) + (185 * 4 * 800)) / 1000 AS total_energy_consumption_kwh;	air_conditioner	2
SELECT heating_capacity_btu * (1 - 0.4) AS heating_capacity_low_temp FROM air_conditioner_info WHERE ac_id = '某空调ID';	air_conditioner	3
SELECT (50000 * 200 / (15 * 0.3)) * 1055.06 / 1000 AS extreme_energy_consumption_kwh;	air_conditioner	4
SELECT (aci.power_consumption_watts * 8 / 4.0) / 1000 * (1 + 0.05 * (ec.humidity_percent / 10)) AS energy_consumption_kwh FROM air_conditioner_info aci JOIN energy_consumption ec ON aci.ac_id = ec.ac_id WHERE aci.ac_id = 'AC-5678' AND ec.mode = '制冷';	air_conditioner	1
SELECT ((90 * 12 * 2500 * (1 + 0.05 * (70 / 10))) + (90 * 10 * 2000 * (1 + 0.05 * (40 / 10))) + (185 * 8 * 1500 * (1 + 0.05 * (50 / 10)))) / 1000 AS total_energy_consumption_kwh;	air_conditioner	2
SELECT ec.energy_consumption_kwh * (1 + 0.05 * (hr.indoor_humidity_percent / 10)) * (1 + CASE WHEN ec.fan_speed = '高' THEN 0.10 WHEN ec.fan_speed = '中' THEN 0.05 ELSE 0 END) AS energy_consumption_high_humidity FROM air_conditioner_info aci JOIN energy_consumption ec ON aci.ac_id = ec.ac_id JOIN humidity_records hr ON aci.ac_id = hr.ac_id WHERE aci.ac_id = 'AC-5678' AND ec.mode = '制冷';	air_conditioner	3
SELECT (6000 * 150 / (2.5 * 0.15)) / 1000 * (1 + 0.05 * (90 / 10)) AS extreme_energy_consumption_kwh;	air_conditioner	4
SELECT (60 * 1.225 * 1005 * (35 - 25)) / (15000 * 1055.06 / 3600 * (1 - 0.1 * (tr.outdoor_temperature_celsius - 25) / 5)) AS required_time_hours FROM air_conditioner_info aci JOIN temperature_records tr ON aci.ac_id = tr.ac_id WHERE aci.ac_id = 'AC-5678' AND tr.mode = '制冷';	air_conditioner	1
SELECT ((90 * 14 * 3000 * (1 + 0.1 * (35 - 25) / 5)) + (90 * 12 * 2500 * (1 + 0.1 * (5 - 25) / 5)) + (185 * 10 * 2000 * (1 + 0.1 * (20 - 25) / 5))) / 1000 AS total_energy_consumption_kwh;	air_conditioner	2
SELECT aci.heating_capacity_btu * (1 - 0.5) * (1 + CASE WHEN ec.fan_speed = '高' THEN 0.10 WHEN ec.fan_speed = '中' THEN 0.05 ELSE 0 END) AS heating_capacity_low_temp FROM air_conditioner_info aci JOIN energy_consumption ec ON aci.ac_id = ec.ac_id WHERE aci.ac_id = 'AC-5678' AND ec.mode = '制热';	air_conditioner	3
SELECT (60000 * 200 / (2.0 * 0.1)) * 1055.06 / 1000 * (1 + 0.05 * (95 / 10)) AS Extreme_energy_consumption_kwh;	air_conditioner	4
SELECT SUM((1000 * 0.001 * (hr1.indoor_humidity_percent - hr2.indoor_humidity_percent) * (101325 / (287 * (tr.indoor_temperature_celsius + 273.15))))) AS removed_water_mass FROM humidity_records hr1 JOIN humidity_records hr2 ON hr1.ac_id = hr2.ac_id AND hr1.record_date = hr2.record_date JOIN temperature_records tr ON hr1.ac_id = tr.ac_id AND hr1.record_date = tr.record_date WHERE hr1.mode = 'cooling' AND hr1.indoor_humidity_percent = 60 AND hr2.indoor_humidity_percent = 40 AND tr.indoor_temperature_celsius = 25 AND tr.mode = 'cooling' GROUP BY hr1.ac_id;	air_conditioner	1
SELECT SUM(power_consumption_watts * usage_duration_hours / 1000) AS total_energy_consumption_kwh FROM usage_records WHERE power_consumption_watts IN (800, 1200, 1500) AND usage_duration_hours IN (4, 3, 5);	air_conditioner	2
SELECT SUM(power_consumption_watts * usage_duration_hours / 1000) AS total_energy_consumption_kwh FROM usage_records WHERE mode = 'cooling' AND temperature_setting_celsius < outdoor_temperature_celsius GROUP BY temperature_setting_celsius ORDER BY temperature_setting_celsius;	air_conditioner	3
SELECT cooling_capacity_btu * ((60 - (-10)) / 20) * 1 AS theoretical_energy_consumption_btu FROM air_conditioner_info WHERE cooling_capacity_btu = 10000;	air_conditioner	4
SELECT power_consumption_watts * usage_duration_hours * 3600 AS heat_transfer_joules FROM usage_records WHERE mode = 'heating' AND power_consumption_watts = 1500 AND indoor_temperature_celsius = 10 AND temperature_setting_celsius = 20;	air_conditioner	1
SELECT SUM(power_consumption_watts * usage_duration_hours) / SUM(usage_duration_hours) AS average_power_consumption_watts FROM usage_records WHERE power_consumption_watts IN (1000, 1200, 800) AND usage_duration_hours IN (2, 3, 4);	air_conditioner	2
SELECT SUM(power_consumption_watts * usage_duration_hours / 1000.0) AS total_energy_consumption_kwh FROM usage_records WHERE mode = 'heating' AND temperature_setting_celsius > outdoor_temperature_celsius GROUP BY temperature_setting_celsius ORDER BY temperature_setting_celsius;	air_conditioner	3
SELECT heating_capacity_btu * ((40 - (-30)) / 20) * 1 AS theoretical_energy_consumption_btu FROM air_conditioner_info WHERE heating_capacity_btu = 12000;	air_conditioner	4
SELECT model, manufacturer, cooling_capacity_btu, power_consumption_watts, (cooling_capacity_btu * 1.0 / power_consumption_watts) AS cooling_efficiency FROM air_conditioner_info ORDER BY cooling_efficiency DESC LIMIT 10;	air_conditioner	1
SELECT model, manufacturer, production_year, energy_efficiency_ratio, (energy_efficiency_ratio * 1.0 / production_year) AS efficiency_year_ratio  FROM air_conditioner_info  ORDER BY efficiency_year_ratio DESC  LIMIT 5;	air_conditioner	2
SELECT model, manufacturer, noise_level_db, weight_kg, (noise_level_db * 1.0 / weight_kg) AS noise_weight_ratio FROM air_conditioner_info WHERE weight_kg > 0 ORDER BY noise_weight_ratio ASC LIMIT 5;	air_conditioner	3
SELECT model, manufacturer, cooling_capacity_btu, power_consumption_watts, (cooling_capacity_btu * 1.0 / power_consumption_watts) AS cooling_power_ratio FROM air_conditioner_info WHERE cooling_capacity_btu > 20000 AND power_consumption_watts < 1000 ORDER BY cooling_power_ratio DESC LIMIT 5;	air_conditioner	4
SELECT ur.usage_id, ai.model, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption FROM usage_records ur JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id ORDER BY total_energy_consumption DESC LIMIT 10;	air_conditioner	1
SELECT ur.usage_id, ai.model, ur.usage_date, ur.temperature_setting_celsius, ur.indoor_temperature_celsius, (ur.temperature_setting_celsius - ur.indoor_temperature_celsius) AS temperature_difference FROM usage_records ur JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id ORDER BY temperature_difference DESC LIMIT 5;	air_conditioner	2
SELECT ur.usage_id, ai.model, ur.usage_date, ur.humidity_percent, ur.mode  FROM usage_records ur  JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id  WHERE ur.mode = '除湿'  ORDER BY ur.humidity_percent ASC  LIMIT 5;	air_conditioner	3
SELECT ur.usage_id, ai.model, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption FROM usage_records ur JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id WHERE ur.outdoor_temperature_celsius = 60 AND ur.indoor_temperature_celsius = 10 ORDER BY total_energy_consumption DESC LIMIT 5;	air_conditioner	4
SELECT tr.temperature_id, ai.model, tr.record_date, tr.outdoor_temperature_celsius, tr.indoor_temperature_celsius, (tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS temperature_difference FROM temperature_records tr JOIN air_conditioner_info ai ON tr.ac_id = ai.ac_id ORDER BY temperature_difference DESC LIMIT 10;	air_conditioner	1
SELECT tr.temperature_id, ai.model, tr.record_date, tr.temperature_setting_celsius, tr.indoor_temperature_celsius, ABS(tr.indoor_temperature_celsius - tr.temperature_setting_celsius) AS temperature_deviation FROM temperature_records tr JOIN air_conditioner_info ai ON tr.ac_id = ai.ac_id ORDER BY temperature_deviation DESC LIMIT 5;	air_conditioner	2
SELECT tr.temperature_id, ai.model, tr.record_date, tr.mode, tr.indoor_temperature_celsius  FROM temperature_records tr  JOIN air_conditioner_info ai ON tr.ac_id = ai.ac_id  WHERE tr.mode = '制冷'  ORDER BY tr.indoor_temperature_celsius ASC  LIMIT 5;	air_conditioner	3
WITH TemperatureDifference AS (     SELECT          tr.ac_id,          tr.record_date,          tr.indoor_temperature_celsius,          tr.outdoor_temperature_celsius,          (tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS temperature_difference,          aci.model,          aci.heating_capacity_btu      FROM temperature_records tr      JOIN air_conditioner_info aci ON tr.ac_id = aci.ac_id      WHERE tr.outdoor_temperature_celsius = -30 AND tr.indoor_temperature_celsius = 40 )  SELECT      td.ac_id,      td.record_date,      td.indoor_temperature_celsius,      td.outdoor_temperature_celsius,      td.temperature_difference,      td.model,      (td.heating_capacity_btu * (td.temperature_difference / 10) * ur.usage_duration_hours) AS estimated_energy_consumption  FROM TemperatureDifference td  JOIN usage_records ur ON td.ac_id = ur.ac_id AND td.record_date = ur.usage_date  ORDER BY td.temperature_difference DESC  LIMIT 5;	air_conditioner	4
WITH HumidityDifference AS (     SELECT          hr.ac_id,          hr.record_date,          hr.indoor_humidity_percent,          hr.outdoor_humidity_percent,          (hr.outdoor_humidity_percent - hr.indoor_humidity_percent) AS humidity_difference,          aci.model      FROM humidity_records hr      JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id )  SELECT      hd.ac_id,      hd.record_date,      hd.indoor_humidity_percent,      hd.outdoor_humidity_percent,      hd.humidity_difference,      hd.model  FROM HumidityDifference hd  ORDER BY hd.humidity_difference DESC  LIMIT 10;	air_conditioner	1
WITH HumidityDeviation AS (   SELECT hr.ac_id, hr.record_date, hr.temperature_setting_celsius, hr.indoor_humidity_percent,           (hr.indoor_humidity_percent - 50) AS humidity_deviation, aci.model    FROM humidity_records hr    JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id ) SELECT hd.ac_id, hd.record_date, hd.temperature_setting_celsius, hd.indoor_humidity_percent,         hd.humidity_deviation, hd.model  FROM HumidityDeviation hd  ORDER BY ABS(hd.humidity_deviation) DESC  LIMIT 5;	air_conditioner	2
SELECT hr.ac_id, hr.record_date, hr.mode, hr.indoor_humidity_percent, aci.model  FROM humidity_records hr  JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id  WHERE hr.mode = '除湿'  ORDER BY hr.indoor_humidity_percent ASC  LIMIT 5;	air_conditioner	3
WITH HumidityDifference AS (   SELECT      hr.ac_id,      hr.record_date,      hr.indoor_humidity_percent,      hr.outdoor_humidity_percent,      (hr.outdoor_humidity_percent - hr.indoor_humidity_percent) AS humidity_difference,      aci.model,      aci.power_consumption_watts    FROM humidity_records hr    JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id    WHERE hr.outdoor_humidity_percent = 100 AND hr.indoor_humidity_percent = 0 )  SELECT    hd.ac_id,    hd.record_date,    hd.indoor_humidity_percent,    hd.outdoor_humidity_percent,    hd.humidity_difference,    hd.model,    (hd.power_consumption_watts * (hd.humidity_difference / 50) * ur.usage_duration_hours) AS estimated_energy_consumption  FROM HumidityDifference hd  JOIN usage_records ur ON hd.ac_id = ur.ac_id AND hd.record_date = ur.usage_date  ORDER BY hd.humidity_difference DESC  LIMIT 5;	air_conditioner	4
WITH TotalEnergyConsumption AS (   SELECT ur.ac_id, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours,           (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption,           aci.model    FROM usage_records ur    JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id )  SELECT tec.ac_id, tec.usage_date, tec.power_consumption_watts, tec.usage_duration_hours,         tec.total_energy_consumption, tec.model  FROM TotalEnergyConsumption tec  ORDER BY tec.total_energy_consumption DESC  LIMIT 10;	air_conditioner	1
WITH TemperatureDeviation AS (     SELECT          ur.ac_id,          ur.usage_date,          ur.temperature_setting_celsius,          ur.indoor_temperature_celsius,          (ur.indoor_temperature_celsius - ur.temperature_setting_celsius) AS temperature_deviation,          aci.model      FROM usage_records ur      JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id )  SELECT      td.ac_id,      td.usage_date,      td.temperature_setting_celsius,      td.indoor_temperature_celsius,      td.temperature_deviation,      td.model  FROM TemperatureDeviation td  ORDER BY ABS(td.temperature_deviation) DESC  LIMIT 5;	air_conditioner	2
SELECT ur.ac_id, ur.usage_date, ur.mode, ur.usage_duration_hours, aci.model  FROM usage_records ur  JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id  WHERE ur.mode = '制冷'  ORDER BY ur.usage_duration_hours DESC  LIMIT 5;	air_conditioner	3
WITH TotalEnergyConsumption AS (     SELECT ur.ac_id, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours,             (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption,             aci.model, aci.cooling_capacity_btu      FROM usage_records ur      JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id      WHERE ur.outdoor_temperature_celsius = 60 AND ur.indoor_temperature_celsius = 10 ) SELECT tec.ac_id, tec.usage_date, tec.power_consumption_watts, tec.usage_duration_hours,         tec.total_energy_consumption, tec.model,         (tec.cooling_capacity_btu * ((60 - 10) / 10) * tec.usage_duration_hours) AS estimated_energy_consumption  FROM TotalEnergyConsumption tec  ORDER BY tec.total_energy_consumption DESC  LIMIT 5;	air_conditioner	4
WITH CoolingEfficiency AS (     SELECT manufacturer,             (cooling_capacity_btu * 1.0 / power_consumption_watts) AS cooling_efficiency      FROM air_conditioner_info  ) SELECT manufacturer,         AVG(cooling_efficiency) AS average_cooling_efficiency  FROM CoolingEfficiency  GROUP BY manufacturer  ORDER BY average_cooling_efficiency DESC  LIMIT 5;	air_conditioner	1
SELECT production_year, AVG(energy_efficiency_ratio) AS average_energy_efficiency_ratio FROM air_conditioner_info GROUP BY production_year ORDER BY average_energy_efficiency_ratio DESC LIMIT 3;	air_conditioner	2
WITH ManufacturerStats AS (   SELECT      manufacturer,      AVG(noise_level_db) AS average_noise_level,      AVG(weight_kg) AS average_weight    FROM air_conditioner_info    GROUP BY manufacturer )  SELECT    manufacturer,    average_noise_level,    average_weight  FROM ManufacturerStats  ORDER BY average_noise_level ASC, average_weight ASC  LIMIT 3;	air_conditioner	3
WITH RefrigerantStats AS (   SELECT      refrigerant_type,     AVG(cooling_capacity_btu) AS average_cooling_capacity,     AVG(power_consumption_watts) AS average_power_consumption   FROM air_conditioner_info   WHERE cooling_capacity_btu > 20000 AND power_consumption_watts < 1000   GROUP BY refrigerant_type ) SELECT    refrigerant_type,   average_cooling_capacity,   average_power_consumption FROM RefrigerantStats ORDER BY average_cooling_capacity DESC, average_power_consumption ASC LIMIT 2;	air_conditioner	4
WITH TotalEnergyConsumption AS (     SELECT          aci.model,         (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption     FROM          usage_records ur     JOIN          air_conditioner_info aci ON ur.ac_id = aci.ac_id ) SELECT      model,     AVG(total_energy_consumption) AS average_total_energy_consumption FROM      TotalEnergyConsumption GROUP BY      model ORDER BY      average_total_energy_consumption DESC LIMIT 5;	air_conditioner	1
WITH TemperatureDeviation AS (   SELECT usage_date, (indoor_temperature_celsius - temperature_setting_celsius) AS temperature_deviation    FROM usage_records  )  SELECT usage_date, AVG(temperature_deviation) AS average_temperature_deviation  FROM TemperatureDeviation  GROUP BY usage_date  ORDER BY average_temperature_deviation DESC  LIMIT 3;	air_conditioner	2
SELECT mode, AVG(energy_consumption_kwh) AS average_energy_consumption FROM energy_consumption GROUP BY mode ORDER BY average_energy_consumption DESC LIMIT 1;	air_conditioner	3
WITH TotalEnergyConsumption AS (   SELECT      aci.model,      (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption,     aci.cooling_capacity_btu,     ur.usage_duration_hours   FROM usage_records ur   JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id   WHERE ur.outdoor_temperature_celsius = 60 AND ur.indoor_temperature_celsius = 10 ) SELECT    model,    AVG(total_energy_consumption) AS average_total_energy_consumption,   AVG(cooling_capacity_btu * ((60 - 10) / 10) * usage_duration_hours) AS estimated_energy_consumption FROM TotalEnergyConsumption GROUP BY model ORDER BY average_total_energy_consumption DESC LIMIT 3;	air_conditioner	4
SELECT aci.model, AVG(tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS avg_temperature_difference FROM temperature_records tr JOIN air_conditioner_info aci ON tr.ac_id = aci.ac_id GROUP BY aci.model ORDER BY avg_temperature_difference DESC LIMIT 5;	air_conditioner	1
SELECT tr.record_date, AVG(tr.indoor_temperature_celsius - tr.temperature_setting_celsius) AS avg_temperature_deviation FROM temperature_records tr GROUP BY tr.record_date ORDER BY avg_temperature_deviation DESC LIMIT 3;	air_conditioner	2
SELECT tr.mode, AVG(tr.indoor_temperature_celsius) AS avg_indoor_temperature FROM temperature_records tr GROUP BY tr.mode ORDER BY avg_indoor_temperature ASC LIMIT 1;	air_conditioner	3
WITH ExtremeCondition AS (     SELECT 'extreme' AS condition_type, -30 AS outdoor_temp, 40 AS indoor_temp ), AverageTempDifference AS (     SELECT          aci.model,          AVG(tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS avg_temperature_difference      FROM temperature_records tr      JOIN air_conditioner_info aci ON tr.ac_id = aci.ac_id      GROUP BY aci.model ) SELECT      atd.model,      atd.avg_temperature_difference,      (aci.heating_capacity_btu * (70 / 10) * 1) AS estimated_energy_consumption  FROM AverageTempDifference atd  JOIN air_conditioner_info aci ON atd.model = aci.model  CROSS JOIN ExtremeCondition ec  ORDER BY atd.avg_temperature_difference DESC  LIMIT 3;	air_conditioner	4
SELECT CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, SUM(ec.energy_consumption_kwh) AS total_energy_consumption FROM humidity_records hr JOIN energy_consumption ec ON hr.ac_id = ec.ac_id AND hr.record_date = ec.record_date WHERE hr.mode = '除湿' GROUP BY humidity_range;	air_conditioner	1
SELECT CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, ec.temperature_setting_celsius, SUM(ec.energy_consumption_kwh) AS total_energy_consumption FROM humidity_records hr JOIN energy_consumption ec ON hr.ac_id = ec.ac_id AND hr.record_date = ec.record_date WHERE ec.mode = '制冷' GROUP BY humidity_range, ec.temperature_setting_celsius;	air_conditioner	2
WITH NormalEnvironment AS (     SELECT          CASE              WHEN tr.humidity_percent BETWEEN 0 AND 30 THEN '0-30%'             WHEN tr.humidity_percent BETWEEN 30 AND 60 THEN '30-60%'             ELSE '60-100%'         END AS humidity_range,         tr.mode,         AVG(ec.energy_consumption_kwh) AS normal_energy_consumption     FROM temperature_records tr     JOIN energy_consumption ec ON tr.ac_id = ec.ac_id AND tr.record_date = ec.record_date     WHERE tr.indoor_temperature_celsius <= 30 AND tr.humidity_percent <= 60     GROUP BY humidity_range, tr.mode ), HighTempHighHumidity AS (     SELECT          CASE              WHEN tr.humidity_percent BETWEEN 0 AND 30 THEN '0-30%'             WHEN tr.humidity_percent BETWEEN 30 AND 60 THEN '30-60%'             ELSE '60-100%'         END AS humidity_range,         tr.mode,         AVG(ec.energy_consumption_kwh) AS high_energy_consumption     FROM temperature_records tr     JOIN energy_consumption ec ON tr.ac_id = ec.ac_id AND tr.record_date = ec.record_date     WHERE tr.indoor_temperature_celsius > 30 AND tr.humidity_percent > 60     GROUP BY humidity_range, tr.mode ) SELECT      ne.humidity_range,     ne.mode,     ne.normal_energy_consumption,     hthh.high_energy_consumption,     ((hthh.high_energy_consumption - ne.normal_energy_consumption) / ne.normal_energy_consumption) * 100 AS energy_increase_percentage FROM NormalEnvironment ne JOIN HighTempHighHumidity hthh ON ne.humidity_range = hthh.humidity_range AND ne.mode = hthh.mode;	air_conditioner	3
SELECT CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, ec.fan_speed, SUM(ec.energy_consumption_kwh * 2.0) AS estimated_energy_consumption FROM humidity_records hr JOIN energy_consumption ec ON hr.ac_id = ec.ac_id AND hr.record_date = ec.record_date WHERE hr.indoor_humidity_percent = 200 GROUP BY humidity_range, ec.fan_speed;	air_conditioner	4
SELECT ec.temperature_setting_celsius, ec.mode, SUM(ec.energy_consumption_kwh) AS total_energy_consumption FROM energy_consumption ec GROUP BY ec.temperature_setting_celsius, ec.mode ORDER BY ec.temperature_setting_celsius, ec.mode;	air_conditioner	1
SELECT ur.fan_speed, CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, SUM(ur.usage_duration_hours) AS total_usage_duration FROM usage_records ur JOIN humidity_records hr ON ur.ac_id = hr.ac_id AND ur.usage_date = hr.record_date GROUP BY ur.fan_speed, humidity_range ORDER BY ur.fan_speed, humidity_range;	air_conditioner	2
SELECT CASE WHEN tr.outdoor_temperature_celsius < 10 THEN '<10°C' WHEN tr.outdoor_temperature_celsius BETWEEN 10 AND 25 THEN '10-25°C' ELSE '>25°C' END AS outdoor_temperature_range, ur.mode, SUM(ur.usage_duration_hours) AS total_usage_duration FROM usage_records ur JOIN temperature_records tr ON ur.ac_id = tr.ac_id AND ur.usage_date = tr.record_date GROUP BY outdoor_temperature_range, ur.mode ORDER BY outdoor_temperature_range, ur.mode;	air_conditioner	3
SELECT ur.fan_speed, CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, SUM(ur.usage_duration_hours) AS total_usage_duration FROM usage_records ur JOIN humidity_records hr ON ur.ac_id = hr.ac_id AND ur.usage_date = hr.record_date JOIN temperature_records tr ON ur.ac_id = tr.ac_id AND ur.usage_date = tr.record_date WHERE tr.outdoor_temperature_celsius = 60 GROUP BY ur.fan_speed, humidity_range ORDER BY ur.fan_speed, humidity_range;	air_conditioner	4
SELECT model FROM air_conditioner_info WHERE cooling_capacity_btu > 10000 AND energy_efficiency_ratio < 10 AND production_year >= 2010;	air_conditioner	1
SELECT model FROM air_conditioner_info WHERE heating_capacity_btu > 12000 AND noise_level_db < 50 AND model NOT IN (SELECT model FROM air_conditioner_info WHERE warranty_period_months < 24);	air_conditioner	2
SELECT model FROM air_conditioner_info WHERE weight_kg > 50 AND power_consumption_watts < 1000 AND model NOT IN (SELECT model FROM air_conditioner_info WHERE manufacturer = 'Unknown');	air_conditioner	3
SELECT model FROM air_conditioner_info WHERE refrigerant_type = 'R410A' AND production_year > 2020 AND model NOT IN (SELECT model FROM air_conditioner_info WHERE cooling_capacity_btu < 5000);	air_conditioner	4
SELECT * FROM energy_consumption WHERE mode = '制冷' AND energy_consumption_kwh > (SELECT AVG(energy_consumption_kwh) FROM energy_consumption WHERE mode = '制冷') AND power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷');	air_conditioner	1
SELECT * FROM energy_consumption WHERE mode = '制热' AND ABS(temperature_setting_celsius - indoor_temperature_celsius) > 10 AND energy_consumption_kwh < (SELECT AVG(energy_consumption_kwh) FROM energy_consumption WHERE mode = '制热');	air_conditioner	2
SELECT * FROM energy_consumption WHERE mode = '除湿' AND humidity_percent > 70 AND energy_consumption_kwh < (SELECT AVG(energy_consumption_kwh) FROM energy_consumption WHERE mode = '除湿');	air_conditioner	3
SELECT * FROM energy_consumption WHERE mode = '送风' AND fan_speed = 10 AND power_consumption_watts = 0;	air_conditioner	4
SELECT * FROM energy_consumption WHERE mode = '制冷' AND indoor_temperature_celsius > temperature_setting_celsius AND power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷') AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE outdoor_temperature_celsius > 40);	air_conditioner	1
SELECT * FROM energy_consumption WHERE mode = '制热' AND indoor_temperature_celsius < temperature_setting_celsius AND power_consumption_watts > (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制热') AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE humidity_percent < 30);	air_conditioner	2
SELECT * FROM energy_consumption WHERE mode = '送风' AND fan_speed = '高档' AND ABS(indoor_temperature_celsius - temperature_setting_celsius) > 5 AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE outdoor_temperature_celsius < 10);	air_conditioner	3
SELECT * FROM energy_consumption WHERE mode = '极端制冷' AND indoor_temperature_celsius < -10 AND power_consumption_watts > 10000 AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE outdoor_temperature_celsius < -50);	air_conditioner	4
SELECT ec.* FROM energy_consumption ec JOIN humidity_records hr ON ec.ac_id = hr.ac_id AND ec.record_date = hr.record_date WHERE ec.mode = '制冷' AND ec.humidity_percent > 70 AND ec.power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷') AND hr.outdoor_humidity_percent >= 20;	air_conditioner	1
SELECT * FROM energy_consumption WHERE mode = '除湿' AND humidity_percent > 60 AND power_consumption_watts > (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '除湿') AND temperature_setting_celsius <= 30;	air_conditioner	2
SELECT ec.* FROM energy_consumption ec  JOIN humidity_records hr ON ec.ac_id = hr.ac_id AND ec.record_date = hr.record_date  WHERE ec.mode = '送风' AND ec.fan_speed = '低档'  AND ABS(ec.humidity_percent - hr.outdoor_humidity_percent) > 30  AND hr.outdoor_humidity_percent >= 10;	air_conditioner	3
SELECT ec.* FROM energy_consumption ec JOIN humidity_records hr ON ec.ac_id = hr.ac_id AND ec.record_date = hr.record_date WHERE ec.mode = '极端除湿' AND ec.humidity_percent < 10 AND ec.power_consumption_watts > 5000 AND hr.outdoor_humidity_percent <= 90;	air_conditioner	4
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '制冷' AND ur.usage_duration_hours > 5 AND ec.power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷') AND ec.outdoor_temperature_celsius >= 10;	air_conditioner	1
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '制热' AND ur.usage_duration_hours > 3 AND ec.power_consumption_watts > (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制热') AND ec.indoor_temperature_celsius <= 25;	air_conditioner	2
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '送风' AND ur.fan_speed = '高档' AND ur.usage_duration_hours < 1 AND ec.outdoor_temperature_celsius <= 35;	air_conditioner	3
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '极端制热' AND ur.usage_duration_hours > 24 AND ur.power_consumption_watts > 10000 AND ec.outdoor_temperature_celsius <= 50;	air_conditioner	4
SELECT a.model, (a.cooling_capacity_btu / (a.power_consumption_watts * 3.412)) * (1 + (r.phase_change_heat_kj_per_kg * r.refrigerant_flow_rate_kg_per_s) / (c.air_heat_capacity_kj_per_kg_k * c.air_flow_rate_kg_per_s * 40)) AS theoretical_cop FROM air_conditioner_info a JOIN refrigerant_properties r ON a.refrigerant_type = r.refrigerant_type JOIN air_properties c ON c.temperature_celsius = 50 AND c.humidity_percent = 90 WHERE a.model = '特定型号';	air_conditioner	1
WITH monthly_energy AS (   SELECT      a.manufacturer,      a.model,      strftime('%Y-%m', e.record_date) AS month,      AVG(e.energy_consumption_kwh) AS avg_energy_consumption_kwh    FROM energy_consumption e    JOIN air_conditioner_info a ON e.ac_id = a.ac_id    JOIN temperature_records t ON e.ac_id = t.ac_id AND e.record_date = t.record_date    JOIN humidity_records h ON e.ac_id = h.ac_id AND e.record_date = h.record_date    WHERE strftime('%Y', e.record_date) = '2023'    GROUP BY a.manufacturer, a.model, strftime('%Y-%m', e.record_date) ),  energy_fluctuation AS (   SELECT      manufacturer,      model,      MAX(avg_energy_consumption_kwh) - MIN(avg_energy_consumption_kwh) AS energy_fluctuation_kwh    FROM monthly_energy    GROUP BY manufacturer, model )  SELECT    manufacturer,    model,    energy_fluctuation_kwh  FROM energy_fluctuation  ORDER BY energy_fluctuation_kwh DESC  LIMIT 1;	air_conditioner	2
WITH low_temp_low_humidity_usage AS (     SELECT          u.ac_id,          u.mode,          SUM(u.usage_duration_hours) AS total_usage_hours,          SUM(u.power_consumption_watts * u.usage_duration_hours) / 1000 AS total_energy_consumption_kwh      FROM usage_records u      JOIN temperature_records t ON u.ac_id = t.ac_id AND u.usage_date = t.record_date      WHERE t.indoor_temperature_celsius < 10 AND t.humidity_percent < 30      GROUP BY u.ac_id, u.mode ),  shortest_usage_model AS (     SELECT          a.model,          SUM(l.total_usage_hours) AS total_usage_hours      FROM low_temp_low_humidity_usage l      JOIN air_conditioner_info a ON l.ac_id = a.ac_id      GROUP BY a.model      ORDER BY total_usage_hours ASC      LIMIT 1 )  SELECT      s.model,      l.mode,      l.total_usage_hours,      l.total_energy_consumption_kwh  FROM low_temp_low_humidity_usage l  JOIN air_conditioner_info a ON l.ac_id = a.ac_id  JOIN shortest_usage_model s ON a.model = s.model;	air_conditioner	3
WITH theoretical_energy AS (         SELECT (1000000 / 100) * 24 * 365 * 10 * POWER(1.05, 10) / 1000 AS total_energy_consumption_kwh     ),     high_energy_models AS (         SELECT              a.model,             (a.cooling_capacity_btu / a.energy_efficiency_ratio) * 24 * 365 * 10 * POWER(1.05, 10) / 1000 AS total_energy_consumption_kwh         FROM air_conditioner_info a         WHERE a.cooling_capacity_btu = 1000000              AND a.energy_efficiency_ratio = 100              AND EXISTS (                 SELECT 1                  FROM temperature_records t                  WHERE t.ac_id = a.ac_id                      AND t.indoor_temperature_celsius - t.outdoor_temperature_celsius = 100             )     )     SELECT model, total_energy_consumption_kwh      FROM high_energy_models      WHERE total_energy_consumption_kwh > 1000000;	air_conditioner	4
WITH power_consumption_variation AS (     SELECT          u.temperature_setting_celsius,          (MAX(u.power_consumption_watts) - MIN(u.power_consumption_watts)) * 100.0 / AVG(u.power_consumption_watts) AS power_variation_rate      FROM usage_records u      JOIN air_conditioner_info a ON u.ac_id = a.ac_id      WHERE a.model = '特定型号'      GROUP BY u.temperature_setting_celsius )  SELECT temperature_setting_celsius, power_variation_rate  FROM power_consumption_variation  ORDER BY power_variation_rate DESC  LIMIT 1;	air_conditioner	1
WITH monthly_data AS (   SELECT      strftime('%m', u.usage_date) AS month,     u.usage_duration_hours,     e.energy_consumption_kwh   FROM usage_records u   JOIN energy_consumption e ON u.ac_id = e.ac_id AND u.usage_date = e.record_date   WHERE strftime('%Y', u.usage_date) = '2023' ), correlation_coefficients AS (   SELECT      month,     (AVG(usage_duration_hours * energy_consumption_kwh) - AVG(usage_duration_hours) * AVG(energy_consumption_kwh)) /     (sqrt(AVG(usage_duration_hours * usage_duration_hours) - AVG(usage_duration_hours) * AVG(usage_duration_hours)) *      sqrt(AVG(energy_consumption_kwh * energy_consumption_kwh) - AVG(energy_consumption_kwh) * AVG(energy_consumption_kwh)))     AS correlation_coefficient   FROM monthly_data   GROUP BY month ) SELECT month, correlation_coefficient FROM correlation_coefficients ORDER BY correlation_coefficient DESC LIMIT 1;	air_conditioner	2
WITH low_temp_low_humidity_usage AS (     SELECT a.model, u.mode, SUM(u.usage_duration_hours) AS total_usage_hours      FROM usage_records u      JOIN air_conditioner_info a ON u.ac_id = a.ac_id      WHERE u.indoor_temperature_celsius < 10 AND u.humidity_percent < 30      GROUP BY a.model, u.mode ),  shortest_usage_model AS (     SELECT model, SUM(total_usage_hours) AS total_usage_hours      FROM low_temp_low_humidity_usage      GROUP BY model      ORDER BY total_usage_hours ASC      LIMIT 1 )  SELECT s.model, l.mode, l.total_usage_hours  FROM low_temp_low_humidity_usage l  JOIN shortest_usage_model s ON l.model = s.model;	air_conditioner	3
WITH extreme_usage AS (         SELECT a.model,                 24 * 365 * 1000 * POWER(1.02, 1000) AS total_usage_hours,                 (a.power_consumption_watts * 24 * 365 * 1000 * POWER(1.10, 1000)) / 1000 AS total_energy_consumption_kwh          FROM air_conditioner_info a          WHERE EXISTS (             SELECT 1              FROM temperature_records t              WHERE t.ac_id = a.ac_id              AND t.indoor_temperature_celsius = 100              AND t.outdoor_temperature_celsius = -50         )     )      SELECT model, total_usage_hours, total_energy_consumption_kwh      FROM extreme_usage      WHERE total_usage_hours > 10000000      AND total_energy_consumption_kwh > 100000000;	air_conditioner	4
WITH eer_by_mode AS (     SELECT e.mode, AVG(a.cooling_capacity_btu * 1.0 / e.power_consumption_watts) AS eer      FROM energy_consumption e      JOIN air_conditioner_info a ON e.ac_id = a.ac_id      WHERE a.model = 'Model-X'      GROUP BY e.mode )  SELECT mode, eer  FROM eer_by_mode  ORDER BY eer ASC  LIMIT 1;	air_conditioner	1
WITH MonthlyData AS (   SELECT      CAST(strftime('%m', ec.record_date) AS INTEGER) AS month,      ec.energy_consumption_kwh,      ec.outdoor_temperature_celsius    FROM energy_consumption ec    WHERE CAST(strftime('%Y', ec.record_date) AS INTEGER) = 2023 ),  CorrelationCoefficients AS (   SELECT      month,      (AVG(energy_consumption_kwh * outdoor_temperature_celsius) - AVG(energy_consumption_kwh) * AVG(outdoor_temperature_celsius)) /      (SQRT(AVG(energy_consumption_kwh * energy_consumption_kwh) - AVG(energy_consumption_kwh) * AVG(energy_consumption_kwh)) *       SQRT(AVG(outdoor_temperature_celsius * outdoor_temperature_celsius) - AVG(outdoor_temperature_celsius) * AVG(outdoor_temperature_celsius)))      AS correlation_coefficient    FROM MonthlyData    GROUP BY month )  SELECT month, correlation_coefficient  FROM CorrelationCoefficients  ORDER BY correlation_coefficient DESC  LIMIT 1;	air_conditioner	2
WITH HighTempHighHumidity AS (   SELECT ec.ac_id, ec.mode, ec.energy_consumption_kwh, aci.model    FROM energy_consumption ec    JOIN air_conditioner_info aci ON ec.ac_id = aci.ac_id    WHERE ec.outdoor_temperature_celsius > 35 AND ec.humidity_percent > 80 ),  ModelModeEnergy AS (   SELECT model, mode, SUM(energy_consumption_kwh) AS total_energy_kwh    FROM HighTempHighHumidity    GROUP BY model, mode ),  MaxEnergyModel AS (   SELECT model, SUM(total_energy_kwh) AS total_energy_kwh    FROM ModelModeEnergy    GROUP BY model    ORDER BY total_energy_kwh DESC    LIMIT 1 )  SELECT mme.model, mme.mode, mme.total_energy_kwh  FROM ModelModeEnergy mme  JOIN MaxEnergyModel mem ON mme.model = mem.model  ORDER BY mme.model, mme.mode;	air_conditioner	3
WITH ExtremeEnergy AS (         SELECT aci.model, aci.power_consumption_watts, POWER(1.20, 1000) AS aging_factor          FROM air_conditioner_info aci     ),      TotalEnergy AS (         SELECT model, (power_consumption_watts * 24 * 365 * 1000 * aging_factor) / 1000 AS total_energy_kwh          FROM ExtremeEnergy     )      SELECT model, total_energy_kwh      FROM TotalEnergy      WHERE total_energy_kwh > 1000000000;	air_conditioner	4
SELECT cooling_capacity_btu / (power_consumption_watts * 3.412) AS COP, cooling_capacity_btu / (1.0 * (45 - 5)) AS mass_flow_rate_kg_s FROM air_conditioner_info WHERE refrigerant_type = 'R-410A' AND cooling_capacity_btu = 18000 AND power_consumption_watts = 2000;	air_conditioner	1
SELECT air_conditioner_info.power_consumption_watts * 8 / 1000 AS total_energy_kWh, (22 - 15) * 1.005 * 1.225 * 50 / 8 * 3.412 AS heating_efficiency_BTU_h, (22 - 15) * 1.005 * 1.225 * 50 AS total_heat_change_kJ FROM usage_records JOIN air_conditioner_info ON usage_records.ac_id = air_conditioner_info.ac_id WHERE usage_records.mode = 'heating' AND usage_records.usage_duration_hours = 8 AND air_conditioner_info.power_consumption_watts = 1800;	air_conditioner	2
SELECT noise_level_db <= 55 AS is_noise_compliant,         (CAST(SUBSTR(dimensions, 1, INSTR(dimensions, 'x') - 1) AS REAL) *          CAST(SUBSTR(SUBSTR(dimensions, INSTR(dimensions, 'x') + 1), 1, INSTR(SUBSTR(dimensions, INSTR(dimensions, 'x') + 1), 'x') - 1) AS REAL) *          CAST(SUBSTR(dimensions, INSTR(dimensions, 'x', -1) + 1) AS REAL)) * 1.5 <= (20 * 3 * 10000) AS is_space_sufficient  FROM air_conditioner_info  WHERE noise_level_db = 50 AND weight_kg = 30 AND dimensions = '80x20x50';	air_conditioner	3
SELECT cooling_capacity_btu / power_consumption_watts AS EER, cooling_capacity_btu / (1.5 * (10000 - (-273))) AS mass_flow_rate_kg_s, power_consumption_watts * 1 / 1000 AS total_energy_kWh FROM air_conditioner_info WHERE cooling_capacity_btu = 1000000 AND power_consumption_watts = 1000000;	air_conditioner	4
SELECT 0.5 * 1.225 * POWER(50, 2) * (Height_meters * Base_Width) * 1.2 AS Wind_Load FROM tower WHERE Name = 'Eiffel Tower';	architect	1
SELECT (Weight * 9.81) / (Base_Width * Base_Width) AS Pressure FROM tower WHERE Name = 'Eiffel Tower';	architect	2
SELECT CASE WHEN Cost_Usd = (SELECT AVG(Cost_Usd) FROM tower WHERE Height_meters = 300 AND Material = '钢') THEN '成正比' ELSE '不成正比' END AS Cost_Proportionality FROM tower WHERE Name = 'Eiffel Tower';	architect	3
SELECT CASE WHEN Vibration_Frequency = (1000.0 / (2 * Height_meters)) THEN '可能导致失效' ELSE '不会导致失效' END AS Failure_Risk FROM tower WHERE Name = 'Eiffel Tower';	architect	4
SELECT 0.5 * POWER(2 * PI() * Vibration_Frequency, 2) * Weight * POWER(0.1, 2) AS Energy_Consumption FROM tower WHERE Name = 'Tokyo Tower';	architect	1
SELECT Weight * 9.81 * (300 - 100) AS Potential_Energy_Change FROM tower WHERE Name = 'Tokyo Tower';	architect	2
SELECT CASE WHEN Maintenance_Cost = (SELECT AVG(Maintenance_Cost) FROM tower WHERE Height_meters = 300 AND Material = '钢') THEN '成正比' ELSE '不成正比' END AS Maintenance_Proportionality FROM tower WHERE Name = 'Tokyo Tower';	architect	3
SELECT CASE WHEN POWER(500, 2) > POWER(Wind_Resistance, 2) THEN '不足' ELSE '足够' END AS Wind_Resistance_Check FROM tower WHERE Name = 'Tokyo Tower';	architect	4
SELECT (POWER(PI(), 2) * 200e9 * (POWER(Base_Width, 4)/12)) / POWER(2 * Height_meters, 2) AS Critical_Buckling_Load FROM tower WHERE Name = 'CN Tower';	architect	1
SELECT (100000 * 2400 / 1000 * 50) AS Concrete_Cost, (100000 * 7850 / 1000 * 800) AS Steel_Cost, (100000 * 7850 / 1000 * 800) - (100000 * 2400 / 1000 * 50) AS Cost_Difference FROM tower WHERE Name = 'CN Tower';	architect	2
SELECT CASE WHEN Wind_Resistance > 40 THEN '不合理' ELSE '合理' END AS Wind_Resistance_Check FROM tower WHERE Name = 'CN Tower';	architect	3
SELECT (Weight * 9.81) / (Base_Width * Base_Width) AS Ground_Pressure FROM tower WHERE Name = 'CN Tower';	architect	4
SELECT 12e-6 * Height_meters * 50 AS Thermal_Expansion FROM tower WHERE Name = 'Burj Khalifa';	architect	1
SELECT 200e9 * 12e-6 * 40 AS Steel_Thermal_Stress, 30e9 * 10e-6 * 40 AS Concrete_Thermal_Stress FROM tower WHERE Name = 'Burj Khalifa';	architect	2
SELECT CASE WHEN (5000000 / 1200000) > 3 THEN '异常' ELSE '正常' END AS Maintenance_Status FROM tower WHERE Name = 'Burj Khalifa';	architect	3
SELECT (1e18 * 9.81) / (5515 * 9.81) AS Penetration_Depth FROM tower WHERE Name = 'Burj Khalifa';	architect	4
SELECT 0.5 * Weight * 9.81 * Base_Width AS Resist_Moment, 0.5 * 1.225 * POWER(60, 2) * (height_meters * Base_Width) * (height_meters / 2) AS Wind_Moment FROM tower WHERE Name = 'Shanghai Tower';	architect	1
SELECT (1e7 * 300) / (200e9 * 5) AS Steel_Deformation, (1e7 * 300) / (10e9 * 20) AS Wood_Deformation FROM tower WHERE Name = 'Shanghai Tower';	architect	2
SELECT CASE WHEN Height_meters > 150 AND construction_year < 1880 THEN '不合理' ELSE '合理' END AS Construction_Validity FROM tower WHERE Name = 'Shanghai Tower';	architect	3
SELECT 1e25 * POWER(6.4e6 + Height_meters, 2) AS Delta_I, (8e37 / (8e37 + 1e25 * POWER(6.4e6 + Height_meters, 2))) * 7.2921159e-5 AS New_Angular_Velocity FROM tower WHERE Name = 'Shanghai Tower';	architect	4
SELECT 0.5 * 1.225 * POWER(100 * POWER(Height_meters / 10, 0.3), 2) * 0.7 AS Wind_Pressure FROM tower WHERE Name = 'CN Tower';	architect	1
SELECT Name, Height_meters, Cost_Usd, (Cost_Usd / (Height_meters * Height_meters * Height_meters)) AS Cost_Ratio FROM tower WHERE Name = 'CN Tower';	architect	2
SELECT Name, Height_meters, Material, Maintenance_Cost FROM tower WHERE Height_meters = 200 AND Material IN ('钢', '混凝土');	architect	3
SELECT Name, Vibration_Frequency, Maintenance_Cost, (1000 * POWER(Vibration_Frequency / 10, 3)) AS Calculated_Maintenance_Cost FROM tower WHERE Name = 'CN Tower';	architect	4
SELECT Name, Height_meters, Material, Vibration_Frequency, (1 / (2 * 3.14159)) * SQRT((200e9 * 5) / (7850 * (Base_Width * Base_Width) * POWER(Height_meters, 4))) AS Calculated_Frequency FROM tower WHERE Name = 'CN Tower';	architect	1
SELECT cpu_base_frequency_ghz + (cpu_max_frequency_ghz - cpu_base_frequency_ghz) * (cpu_usage_percent / 100) AS actual_frequency_ghz FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.cpu_base_frequency_ghz = 3.5 AND computer_info.cpu_max_frequency_ghz = 4.2 AND usage_records.cpu_usage_percent = 80;	computer	1
SELECT (ram_size_gb * ram_usage_percent / 100) / 25.6 AS actual_bandwidth_utilization FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.ram_size_gb = 16 AND computer_info.ram_type = 'DDR4' AND usage_records.ram_usage_percent = 75;	computer	2
SELECT (computer_info.battery_capacity_wh * battery_usage.battery_health_percent / 100) / battery_usage.power_consumption_watts AS runtime_hours FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE computer_info.battery_capacity_wh = 60 AND battery_usage.power_consumption_watts = 45 AND battery_usage.battery_health_percent = 90;	computer	3
SELECT cpu_cores * cpu_threads * (cpu_base_frequency_ghz + (cpu_max_frequency_ghz - cpu_base_frequency_ghz) * (cpu_usage_percent / 100)) AS total_computation_power FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.cpu_cores = 128 AND computer_info.cpu_threads = 256 AND computer_info.cpu_base_frequency_ghz = 1 AND computer_info.cpu_max_frequency_ghz = 10 AND usage_records.cpu_usage_percent = 200;	computer	4
SELECT gpu_vram_gb * (gpu_usage_percent / 100.0) * 448 AS data_transfer_volume_gb  FROM computer_info  JOIN usage_records ON computer_info.computer_id = usage_records.computer_id  WHERE computer_info.gpu_vram_gb = 8 AND usage_records.gpu_usage_percent = 90;	computer	1
SELECT (storage_size_gb * 1024 * storage_usage_percent / 100) / 500 AS actual_bandwidth_s FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.storage_size_gb = 1024 AND computer_info.storage_type = 'SSD' AND usage_records.storage_usage_percent = 60;	computer	2
SELECT (screen_size_inches * (CAST(substr(screen_resolution, 1, instr(screen_resolution, 'x') - 1) AS INTEGER) * CAST(substr(screen_resolution, instr(screen_resolution, 'x') + 1) AS INTEGER))) / (POWER(SQRT(POWER(CAST(substr(screen_resolution, 1, instr(screen_resolution, 'x') - 1) AS INTEGER), 2) + POWER(CAST(substr(screen_resolution, instr(screen_resolution, 'x') + 1) AS INTEGER), 2)) / screen_size_inches, 2)) AS actual_display_area FROM computer_info WHERE computer_info.screen_size_inches = 15.6 AND computer_info.screen_resolution = '1920x1080';	computer	3
SELECT (computer_info.battery_capacity_wh * battery_usage.battery_health_percent / 100) / battery_usage.power_consumption_watts AS runtime_hours FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE computer_info.battery_capacity_wh = 1000 AND battery_usage.power_consumption_watts = 500 AND battery_usage.battery_health_percent = 200;	computer	4
SELECT 25 + (75 * 4 * 3600 * (1 - 0.8)) / 500 AS internal_temperature_celsius FROM usage_records WHERE usage_records.power_consumption_watts = 75 AND usage_records.usage_duration_hours = 4;	computer	1
SELECT 100 * (cpu_usage_percent / 100.0) AS cpu_actual_performance_gflops, 200 * (gpu_usage_percent / 100.0) AS gpu_actual_performance_gflops, 50 * (ram_usage_percent / 100.0) AS ram_actual_performance_gb_s, 500 * (storage_usage_percent / 100.0) AS storage_actual_performance_mb_s FROM usage_records WHERE cpu_usage_percent = 80 AND gpu_usage_percent = 60 AND ram_usage_percent = 50 AND storage_usage_percent = 30;	computer	2
SELECT (60 * 90 / 100) - (50 * 3) AS remaining_battery_capacity_wh, CASE WHEN (60 * 90 / 100) - (50 * 3) <= 0 THEN '需要充电' ELSE '无需充电' END AS charging_status FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 60 AND usage_records.power_consumption_watts = 50 AND usage_records.usage_duration_hours = 3;	computer	3
SELECT 100 + (1000 * 24 * 3600 * (1 - 0.5)) / 500 AS internal_temperature_celsius, CASE WHEN 100 + (1000 * 24 * 3600 * (1 - 0.5)) / 500 > 1000 THEN '不可能实现' ELSE '可能实现' END AS feasibility_analysis FROM usage_records WHERE usage_records.cpu_usage_percent = 1000 AND usage_records.gpu_usage_percent = 800 AND usage_records.power_consumption_watts = 1000 AND usage_records.usage_duration_hours = 24;	computer	4
SELECT (30 * 1.5) / 0.9 AS actual_discharge_wh FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 60 AND usage_records.power_consumption_watts = 30 AND usage_records.usage_duration_hours = 1.5;	computer	1
SELECT (50 * 80 / 100) - (20 * 2) AS remaining_battery_capacity_wh, (50 - ((50 * 80 / 100) - (20 * 2))) / 0.85 AS required_charging_wh FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 50 AND usage_records.power_consumption_watts = 20 AND usage_records.usage_duration_hours = 2;	computer	2
SELECT 95 - ((18 * 4) / 80 * 0.1) AS remaining_battery_health_percent, CASE WHEN 95 - ((18 * 4) / 80 * 0.1) < 80 THEN '需要更换' ELSE '无需更换' END AS replacement_status FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 80 AND usage_records.power_consumption_watts = 18 AND usage_records.usage_duration_hours = 4;	computer	3
SELECT 500 - ((100 * 24) / 200 * CEIL((100 * 24) / 200) * 1) AS remaining_battery_health_percent,  CASE WHEN 500 - ((100 * 24) / 200 * CEIL((100 * 24) / 200) * 1) <= 0 THEN '不可能实现' ELSE '可能实现' END AS feasibility_analysis  FROM computer_info  JOIN usage_records ON computer_info.computer_id = usage_records.computer_id  WHERE computer_info.battery_capacity_wh = 200  AND usage_records.power_consumption_watts = 100  AND usage_records.usage_duration_hours = 24;	computer	4
SELECT (65 + 85) * 1 * 3600 * 0.75 AS total_heat_dissipation_joules FROM performance_tests WHERE performance_tests.cpu_score = 1200 AND performance_tests.gpu_score = 800 AND performance_tests.overall_score = 950;	computer	1
SELECT cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1 AS calculated_overall_score, CASE WHEN cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1 != overall_score THEN '存在性能瓶颈' ELSE '无性能瓶颈' END AS performance_bottleneck_analysis FROM performance_tests WHERE cpu_score = 1500 AND gpu_score = 1000 AND ram_score = 800 AND storage_score = 600 AND overall_score = 1200;	computer	2
SELECT temperature_celsius,         CASE WHEN temperature_celsius <= 85 THEN '安全范围内' ELSE '超出安全范围' END AS temperature_safety_status,         CASE WHEN temperature_celsius >= 85 THEN '需要改进散热系统' ELSE '无需改进散热系统' END AS cooling_system_analysis  FROM performance_tests  WHERE cpu_score = 1000    AND gpu_score = 700    AND ram_score = 500    AND storage_score = 400    AND overall_score = 800    AND temperature_celsius = 80    AND power_consumption_watts = 150;	computer	3
SELECT 20000 * 1 * 3600 AS total_energy_consumption_joules, CASE WHEN 20000 * 1 * 3600 > 1e12 THEN '不可能实现可持续运行' ELSE '可能实现可持续运行' END AS sustainability_analysis FROM performance_tests WHERE cpu_score = 100000 AND gpu_score = 80000 AND ram_score = 60000 AND storage_score = 40000 AND overall_score = 90000 AND temperature_celsius = 500 AND power_consumption_watts = 20000;	computer	4
SELECT ci.computer_id, ci.manufacturer, ci.model, ci.battery_capacity_wh, pt.power_consumption_watts, (ci.battery_capacity_wh / pt.power_consumption_watts) AS theoretical_runtime_hours FROM computer_info ci JOIN performance_tests pt ON ci.computer_id = pt.computer_id ORDER BY theoretical_runtime_hours DESC LIMIT 5;	computer	1
SELECT computer_id, manufacturer, model, cpu_cores, cpu_threads, (cpu_threads * 1.0 / cpu_cores) AS core_thread_ratio, ABS((cpu_threads * 1.0 / cpu_cores) - 2) AS ratio_difference FROM computer_info ORDER BY ratio_difference ASC LIMIT 3;	computer	2
SELECT computer_id, manufacturer, model, screen_size_inches, screen_resolution,         ROUND(SQRT(POWER(CAST(SUBSTR(screen_resolution, 1, INSTR(screen_resolution, 'x') - 1) AS REAL), 2) +                    POWER(CAST(SUBSTR(screen_resolution, INSTR(screen_resolution, 'x') + 1) AS REAL), 2)) / screen_size_inches, 2) AS ppi  FROM computer_info  ORDER BY ppi DESC  LIMIT 10;	computer	3
SELECT computer_id, manufacturer, model, cpu_base_frequency_ghz, (100.0 / cpu_base_frequency_ghz) AS performance_increase_factor FROM computer_info ORDER BY performance_increase_factor DESC LIMIT 5;	computer	4
SELECT computer_id, manufacturer, model, cpu_base_frequency_ghz, cpu_max_frequency_ghz, ROUND(((cpu_max_frequency_ghz - cpu_base_frequency_ghz) / cpu_base_frequency_ghz) * 100, 2) AS frequency_increase_percentage FROM computer_info ORDER BY frequency_increase_percentage DESC LIMIT 5;	computer	1
SELECT computer_id, manufacturer, model, ram_size_gb, storage_size_gb, (ram_size_gb * 1.0 / storage_size_gb) AS ram_storage_ratio, ABS((ram_size_gb * 1.0 / storage_size_gb) - 0.1) AS ratio_difference FROM computer_info ORDER BY ratio_difference ASC LIMIT 3;	computer	2
SELECT computer_id, manufacturer, model, weight_kg, battery_capacity_wh, (battery_capacity_wh * 1.0 / weight_kg) AS battery_capacity_per_kg FROM computer_info ORDER BY battery_capacity_per_kg DESC LIMIT 10;	computer	3
SELECT computer_id, manufacturer, model, gpu_vram_gb, (1024.0 / gpu_vram_gb) AS vram_increase_factor FROM computer_info ORDER BY vram_increase_factor DESC LIMIT 5;	computer	4
SELECT computer_id, SUM(power_consumption_watts * usage_duration_hours) AS total_energy_consumption_wh FROM usage_records GROUP BY computer_id ORDER BY total_energy_consumption_wh DESC LIMIT 5;	computer	1
SELECT computer_id, AVG(cpu_usage_percent) AS avg_cpu_usage, AVG(gpu_usage_percent) AS avg_gpu_usage, (AVG(cpu_usage_percent) - AVG(gpu_usage_percent)) AS usage_difference FROM usage_records GROUP BY computer_id ORDER BY usage_difference DESC LIMIT 3;	computer	2
SELECT computer_id, SUM(temperature_celsius * usage_duration_hours) / SUM(usage_duration_hours) AS avg_temperature FROM usage_records GROUP BY computer_id ORDER BY avg_temperature DESC LIMIT 10;	computer	3
SELECT computer_id, SUM(power_consumption_watts * 1000) AS total_energy_consumption_wh FROM usage_records GROUP BY computer_id ORDER BY total_energy_consumption_wh DESC LIMIT 5;	computer	4
SELECT computer_id, battery_capacity_wh, power_consumption_watts, (battery_capacity_wh / power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage ORDER BY theoretical_runtime_hours DESC LIMIT 5;	computer	1
SELECT computer_id, (battery_health_percent / usage_duration_hours) AS health_usage_ratio FROM battery_usage ORDER BY health_usage_ratio ASC LIMIT 3;	computer	2
SELECT computer_id, SUM(temperature_celsius * usage_duration_hours) / SUM(usage_duration_hours) AS avg_temperature FROM battery_usage GROUP BY computer_id ORDER BY avg_temperature DESC LIMIT 10;	computer	3
SELECT computer_id, (10000 / power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage ORDER BY theoretical_runtime_hours DESC LIMIT 5;	computer	4
SELECT computer_id, SUM(power_consumption_watts) AS total_energy_consumption_wh, SUM(power_consumption_watts) / COUNT(*) * (1 - (25.0 / AVG(temperature_celsius))) AS avg_cooling_power_w FROM performance_tests GROUP BY computer_id ORDER BY (total_energy_consumption_wh / avg_cooling_power_w) DESC LIMIT 5;	computer	1
SELECT computer_id, (cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1) AS weighted_score FROM performance_tests ORDER BY weighted_score DESC LIMIT 3;	computer	2
SELECT computer_id, power_consumption_watts / (temperature_celsius - 25) AS cooling_efficiency_w_per_c FROM performance_tests ORDER BY cooling_efficiency_w_per_c ASC LIMIT 10;	computer	3
SELECT computer_id, (100000 * 0.4 + 100000 * 0.3 + 100000 * 0.2 + 100000 * 0.1) / (cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1) AS performance_increase_factor FROM performance_tests ORDER BY performance_increase_factor DESC LIMIT 5;	computer	4
SELECT manufacturer, AVG(cpu_base_frequency_ghz) AS avg_base_frequency, AVG(cpu_max_frequency_ghz) AS avg_max_frequency, (AVG(cpu_max_frequency_ghz) - AVG(cpu_base_frequency_ghz)) / AVG(cpu_base_frequency_ghz) * 100 AS frequency_increase_percentage FROM computer_info GROUP BY manufacturer ORDER BY frequency_increase_percentage DESC;	computer	1
SELECT ram_type, AVG(ram_size_gb) / AVG(storage_size_gb) AS ram_storage_ratio FROM computer_info GROUP BY ram_type ORDER BY ram_storage_ratio DESC;	computer	2
SELECT screen_size_inches, AVG(battery_capacity_wh) AS avg_battery_capacity, AVG(weight_kg) AS avg_weight, AVG(battery_capacity_wh) / AVG(weight_kg) AS battery_capacity_per_kg FROM computer_info GROUP BY screen_size_inches ORDER BY battery_capacity_per_kg DESC;	computer	3
SELECT production_year, 100.0 / AVG(cpu_cores) AS core_increase_factor FROM computer_info GROUP BY production_year ORDER BY core_increase_factor DESC;	computer	4
SELECT usage_type, AVG(power_consumption_watts) AS avg_power_consumption, AVG(usage_duration_hours) AS avg_usage_duration, AVG(power_consumption_watts) * AVG(usage_duration_hours) AS total_energy_consumption_wh FROM usage_records GROUP BY usage_type ORDER BY total_energy_consumption_wh DESC;	computer	1
SELECT strftime('%m', usage_date) AS usage_month, AVG(cpu_usage_percent) AS avg_cpu_usage, AVG(gpu_usage_percent) AS avg_gpu_usage, AVG(ram_usage_percent) AS avg_ram_usage, (AVG(cpu_usage_percent) - AVG(gpu_usage_percent)) AS usage_difference FROM usage_records GROUP BY usage_month ORDER BY usage_difference DESC;	computer	2
SELECT usage_type, AVG(temperature_celsius) AS avg_temperature, AVG(usage_duration_hours) AS avg_usage_duration, AVG(temperature_celsius) / AVG(usage_duration_hours) AS temperature_increase_per_hour FROM usage_records GROUP BY usage_type ORDER BY temperature_increase_per_hour DESC;	computer	3
SELECT usage_type, 10000 * AVG(usage_duration_hours) AS total_energy_consumption_wh FROM usage_records GROUP BY usage_type ORDER BY total_energy_consumption_wh DESC;	computer	4
SELECT strftime('%Y', usage_date) AS usage_year,         AVG(battery_health_percent) AS avg_battery_health,         AVG(usage_duration_hours) AS avg_usage_duration,         AVG(battery_health_percent) / AVG(usage_duration_hours) AS battery_health_decay_rate  FROM battery_usage  GROUP BY usage_year  ORDER BY battery_health_decay_rate DESC;	computer	1
SELECT CASE WHEN battery_capacity_wh <= 50 THEN '0-50Wh' WHEN battery_capacity_wh > 50 AND battery_capacity_wh <= 100 THEN '50-100Wh' ELSE '100Wh以上' END AS capacity_range, AVG(battery_capacity_wh) AS avg_battery_capacity, AVG(power_consumption_watts) AS avg_power_consumption, AVG(usage_duration_hours) AS avg_usage_duration, AVG(battery_capacity_wh) / AVG(power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage GROUP BY capacity_range ORDER BY theoretical_runtime_hours DESC;	computer	2
SELECT strftime('%m', usage_date) AS usage_month, AVG(temperature_celsius) AS avg_temperature, AVG(battery_health_percent) AS avg_battery_health FROM battery_usage GROUP BY usage_month ORDER BY avg_temperature DESC;	computer	3
SELECT CASE WHEN battery_health_percent <= 50 THEN '0-50%' WHEN battery_health_percent > 50 AND battery_health_percent <= 80 THEN '50-80%' ELSE '80-100%' END AS health_range, 10000.0 / AVG(power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage GROUP BY health_range ORDER BY theoretical_runtime_hours DESC;	computer	4
SELECT test_type, AVG(power_consumption_watts) AS avg_power_consumption, 1 AS avg_test_duration, AVG(power_consumption_watts) * 1 AS total_energy_consumption_wh FROM performance_tests GROUP BY test_type ORDER BY total_energy_consumption_wh DESC;	computer	1
SELECT strftime('%Y', test_date) AS test_year, AVG(cpu_score) AS avg_cpu_score, AVG(gpu_score) AS avg_gpu_score, AVG(overall_score) AS avg_overall_score, ABS((AVG(cpu_score) / AVG(gpu_score)) - 1) AS cpu_gpu_score_ratio_difference FROM performance_tests GROUP BY test_year ORDER BY cpu_gpu_score_ratio_difference ASC;	computer	2
SELECT test_type, AVG(temperature_celsius) AS avg_temperature, 1 AS avg_test_duration, AVG(temperature_celsius) / 1 AS temperature_increase_per_hour FROM performance_tests GROUP BY test_type ORDER BY temperature_increase_per_hour DESC;	computer	3
SELECT test_type, (100000 * 0.4 + 100000 * 0.3 + 100000 * 0.2 + 100000 * 0.1) / (AVG(cpu_score) * 0.4 + AVG(gpu_score) * 0.3 + AVG(ram_score) * 0.2 + AVG(storage_score) * 0.1) AS performance_increase_factor FROM performance_tests GROUP BY test_type ORDER BY performance_increase_factor DESC;	computer	4
SELECT manufacturer, model, cpu_base_frequency_ghz, cpu_max_frequency_ghz FROM computer_info WHERE cpu_base_frequency_ghz > 3.0 AND cpu_max_frequency_ghz < 4.0;	computer	1
SELECT manufacturer, model, ram_size_gb, storage_size_gb FROM computer_info WHERE ram_size_gb > 16 AND storage_size_gb < 512;	computer	2
SELECT manufacturer, model, screen_size_inches, weight_kg FROM computer_info WHERE screen_size_inches > 15 AND weight_kg <= 2.5;	computer	3
SELECT manufacturer, model, 200 AS battery_capacity_wh, cpu_cores FROM computer_info WHERE cpu_cores < 8;	computer	4
SELECT computer_id, power_consumption_watts, usage_duration_hours, (power_consumption_watts * usage_duration_hours) AS total_energy_consumption_wh  FROM usage_records  WHERE power_consumption_watts > 100  AND usage_duration_hours > 2  AND (power_consumption_watts * usage_duration_hours) < 500;	computer	1
SELECT computer_id, cpu_usage_percent, gpu_usage_percent, ABS(cpu_usage_percent - gpu_usage_percent) AS usage_difference FROM usage_records WHERE cpu_usage_percent > 80 AND gpu_usage_percent > 60 AND ABS(cpu_usage_percent - gpu_usage_percent) <= 20;	computer	2
SELECT computer_id, temperature_celsius, usage_duration_hours, (temperature_celsius / usage_duration_hours) AS temperature_increase_per_hour FROM usage_records WHERE temperature_celsius > 70 AND usage_duration_hours > 1 AND (temperature_celsius / usage_duration_hours) < 10;	computer	3
SELECT computer_id, 1000 AS assumed_power_consumption, usage_duration_hours, (1000 * usage_duration_hours) AS total_energy_consumption_wh, temperature_celsius FROM usage_records WHERE (1000 * usage_duration_hours) > 5000 AND temperature_celsius >= 50;	computer	4
SELECT computer_id, battery_health_percent, power_consumption_watts, usage_duration_hours, (power_consumption_watts / usage_duration_hours) AS energy_consumption_per_hour FROM battery_usage WHERE battery_health_percent > 80 AND (power_consumption_watts / usage_duration_hours) <= 50;	computer	1
SELECT computer_id, battery_capacity_wh, battery_health_percent, usage_duration_hours, ((100 - battery_health_percent) / usage_duration_hours) AS health_decay_rate_per_hour FROM battery_usage WHERE battery_capacity_wh > 60 AND ((100 - battery_health_percent) / usage_duration_hours) <= 2;	computer	2
SELECT computer_id, temperature_celsius, usage_duration_hours FROM battery_usage WHERE temperature_celsius > 40 AND usage_duration_hours >= 0.5;	computer	3
SELECT computer_id, 500 AS assumed_battery_capacity, power_consumption_watts, usage_duration_hours, (power_consumption_watts / usage_duration_hours) AS energy_consumption_per_hour, battery_health_percent FROM battery_usage WHERE (power_consumption_watts / usage_duration_hours) > 100 AND battery_health_percent >= 90;	computer	4
SELECT computer_id, power_consumption_watts, 1 AS test_duration_hours, (power_consumption_watts * 1) AS total_energy_consumption_wh FROM performance_tests WHERE power_consumption_watts > 200 AND 1 > 1 AND (power_consumption_watts * 1) < 1000;	computer	1
SELECT computer_id, cpu_score, gpu_score, ram_score, storage_score, (0.4 * cpu_score + 0.3 * gpu_score + 0.2 * ram_score + 0.1 * storage_score) AS overall_score FROM performance_tests WHERE cpu_score > 8000 AND gpu_score > 9000 AND (0.4 * cpu_score + 0.3 * gpu_score + 0.2 * ram_score + 0.1 * storage_score) < 8500;	computer	2
SELECT computer_id, temperature_celsius, 1 AS test_duration_hours, (temperature_celsius / 1) AS temperature_increase_per_hour FROM performance_tests WHERE temperature_celsius > 75 AND 1 > 1 AND (temperature_celsius / 1) < 10;	computer	3
SELECT computer_id, 1000 AS assumed_power_consumption, 1 AS test_duration_hours, (1000 * 1) AS total_energy_consumption_wh, temperature_celsius, (1000 / (temperature_celsius - 25)) AS cooling_efficiency_w_per_c FROM performance_tests WHERE (1000 * 1) > 5000 AND (1000 / (temperature_celsius - 25)) < 20;	computer	4
SELECT ci.computer_id, ci.cpu_base_frequency_ghz, ci.cpu_max_frequency_ghz, ur.cpu_usage_percent, ur.power_consumption_watts, ci.cpu_base_frequency_ghz + (ci.cpu_max_frequency_ghz - ci.cpu_base_frequency_ghz) * (ur.cpu_usage_percent / 100.0) AS actual_frequency_ghz, ur.power_consumption_watts / (ci.cpu_base_frequency_ghz + (ci.cpu_max_frequency_ghz - ci.cpu_base_frequency_ghz) * (ur.cpu_usage_percent / 100.0)) AS power_frequency_ratio FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.cpu_usage_percent = 80 AND ur.power_consumption_watts = 95;	computer	1
SELECT computer_info.computer_id, ram_size_gb, ram_usage_percent, ram_type, ram_size_gb * (ram_usage_percent / 100) * 25.6 AS current_memory_bandwidth_gbs, ram_size_gb * 25.6 AS max_memory_bandwidth_gbs, (ram_size_gb * (ram_usage_percent / 100) * 25.6) / (ram_size_gb * 25.6) AS memory_bandwidth_usage_ratio FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE ram_size_gb = 16 AND ram_usage_percent = 75 AND ram_type = 'DDR4';	computer	2
SELECT computer_info.computer_id, computer_info.battery_capacity_wh, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / computer_info.battery_capacity_wh * 100 AS battery_health_percent, CASE WHEN (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / computer_info.battery_capacity_wh * 100 >= 80 THEN '正常' ELSE '不正常' END AS battery_health_status FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE computer_info.battery_capacity_wh = 56 AND battery_usage.usage_duration_hours = 4 AND battery_usage.power_consumption_watts = 14;	computer	3
SELECT computer_info.computer_id, computer_info.cpu_cores, computer_info.cpu_threads, computer_info.cpu_base_frequency_ghz, computer_info.cpu_max_frequency_ghz, usage_records.cpu_usage_percent, computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100.0) AS actual_frequency_ghz, usage_records.power_consumption_watts, usage_records.power_consumption_watts / (computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100.0)) AS power_frequency_ratio FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.cpu_cores = 128 AND computer_info.cpu_threads = 256 AND computer_info.cpu_base_frequency_ghz = 1.0 AND computer_info.cpu_max_frequency_ghz = 10.0 AND usage_records.cpu_usage_percent = 200;	computer	4
SELECT computer_info.computer_id, computer_info.cpu_base_frequency_ghz, computer_info.cpu_max_frequency_ghz, usage_records.cpu_usage_percent, usage_records.power_consumption_watts, computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100) AS actual_frequency_ghz, SQRT(usage_records.power_consumption_watts / (1.25e-8 * (computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100)))) AS estimated_voltage FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.cpu_usage_percent = 90 AND usage_records.power_consumption_watts = 120 AND computer_info.cpu_base_frequency_ghz = 2.0 AND computer_info.cpu_max_frequency_ghz = 4.5;	computer	1
SELECT computer_info.computer_id, computer_info.ram_size_gb, usage_records.ram_usage_percent, usage_records.power_consumption_watts, computer_info.ram_size_gb * (usage_records.ram_usage_percent / 100.0) * 25.6 AS current_memory_bandwidth_gbs, (computer_info.ram_size_gb * (usage_records.ram_usage_percent / 100.0) * 25.6) / usage_records.power_consumption_watts AS memory_bandwidth_power_ratio FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.ram_usage_percent = 80 AND usage_records.power_consumption_watts = 85 AND computer_info.ram_size_gb = 32 AND computer_info.ram_type = 'DDR4';	computer	2
SELECT computer_info.computer_id, computer_info.battery_capacity_wh, usage_records.usage_duration_hours, usage_records.power_consumption_watts, (usage_records.usage_duration_hours * usage_records.power_consumption_watts) / computer_info.battery_capacity_wh * 100 AS battery_health_percent, CASE WHEN (usage_records.usage_duration_hours * usage_records.power_consumption_watts) / computer_info.battery_capacity_wh * 100 >= 80 THEN '正常' ELSE '不正常' END AS battery_health_status FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.usage_duration_hours = 8 AND usage_records.power_consumption_watts = 60 AND computer_info.battery_capacity_wh = 70;	computer	3
SELECT computer_info.computer_id, computer_info.cpu_base_frequency_ghz, computer_info.cpu_max_frequency_ghz, usage_records.cpu_usage_percent, usage_records.power_consumption_watts, computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100) AS actual_frequency_ghz, SQRT(usage_records.power_consumption_watts / (1.25e-8 * (computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100)))) AS estimated_voltage FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.cpu_usage_percent = 500 AND usage_records.power_consumption_watts = 1000 AND computer_info.cpu_base_frequency_ghz = 0.5 AND computer_info.cpu_max_frequency_ghz = 20.0;	computer	4
SELECT computer_info.computer_id, computer_info.battery_capacity_wh, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / computer_info.battery_capacity_wh * 100 AS battery_health_percent, (battery_usage.usage_duration_hours / (computer_info.battery_capacity_wh / battery_usage.power_consumption_watts)) * 100 AS discharge_efficiency_percent FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.usage_duration_hours = 10 AND battery_usage.power_consumption_watts = 50 AND computer_info.battery_capacity_wh = 60;	computer	1
SELECT computer_info.computer_id, battery_usage.battery_health_percent, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / (battery_usage.battery_health_percent / 100.0) AS actual_battery_capacity_wh FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.battery_health_percent = 85 AND battery_usage.usage_duration_hours = 8 AND battery_usage.power_consumption_watts = 45;	computer	2
SELECT computer_info.computer_id, battery_usage.battery_health_percent, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, computer_info.battery_capacity_wh, CASE WHEN battery_usage.battery_health_percent < 80 THEN '需要更换' ELSE '无需更换' END AS battery_replacement_status FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.battery_health_percent = 75 AND battery_usage.usage_duration_hours = 6 AND battery_usage.power_consumption_watts = 40;	computer	3
SELECT computer_info.computer_id, battery_usage.battery_health_percent, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, computer_info.battery_capacity_wh, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / (battery_usage.battery_health_percent / 100) AS actual_battery_capacity_wh, CASE WHEN battery_usage.battery_health_percent > 100 THEN '电池可能膨胀或过热' ELSE '电池状态正常' END AS battery_physical_status FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.battery_health_percent = 200 AND battery_usage.usage_duration_hours = 24 AND battery_usage.power_consumption_watts = 200 AND computer_info.battery_capacity_wh = 100;	computer	4
SELECT computer_info.computer_id, performance_tests.cpu_score, performance_tests.gpu_score, performance_tests.power_consumption_watts, performance_tests.temperature_celsius, (performance_tests.cpu_score + performance_tests.gpu_score) / performance_tests.power_consumption_watts AS performance_per_watt, (performance_tests.cpu_score + performance_tests.gpu_score) / (performance_tests.power_consumption_watts * (1 + 0.02 * (performance_tests.temperature_celsius - 25))) AS performance_per_watt_with_temperature  FROM computer_info  JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id  WHERE performance_tests.cpu_score = 1200 AND performance_tests.gpu_score = 1500 AND performance_tests.power_consumption_watts = 200 AND performance_tests.temperature_celsius = 75;	computer	1
SELECT computer_info.computer_id, performance_tests.cpu_score, performance_tests.gpu_score, performance_tests.ram_score, performance_tests.storage_score, performance_tests.overall_score, (performance_tests.cpu_score * 100.0 / performance_tests.overall_score) AS cpu_contribution_percent, (performance_tests.gpu_score * 100.0 / performance_tests.overall_score) AS gpu_contribution_percent, (performance_tests.ram_score * 100.0 / performance_tests.overall_score) AS ram_contribution_percent, (performance_tests.storage_score * 100.0 / performance_tests.overall_score) AS storage_contribution_percent FROM computer_info JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id WHERE performance_tests.cpu_score = 1000 AND performance_tests.gpu_score = 1200 AND performance_tests.ram_score = 800 AND performance_tests.storage_score = 600 AND performance_tests.overall_score = 3600;	computer	2
SELECT computer_info.computer_id, performance_tests.overall_score, performance_tests.temperature_celsius, performance_tests.power_consumption_watts, (performance_tests.power_consumption_watts * 1.0 / performance_tests.temperature_celsius) * 100 AS cooling_efficiency, performance_tests.overall_score * (1 - 0.01 * (performance_tests.temperature_celsius - 25)) AS adjusted_performance_score FROM computer_info JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id WHERE performance_tests.overall_score = 3000 AND performance_tests.temperature_celsius = 80 AND performance_tests.power_consumption_watts = 180;	computer	3
SELECT computer_info.computer_id, performance_tests.cpu_score, performance_tests.gpu_score, performance_tests.overall_score, performance_tests.power_consumption_watts, performance_tests.temperature_celsius, (performance_tests.cpu_score + performance_tests.gpu_score) / performance_tests.power_consumption_watts AS performance_per_watt, CASE WHEN performance_tests.temperature_celsius > 150 THEN '硬件可能熔毁或爆炸' ELSE '硬件状态正常' END AS hardware_status FROM computer_info JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id WHERE performance_tests.cpu_score = 10000 AND performance_tests.gpu_score = 15000 AND performance_tests.overall_score = 25000 AND performance_tests.power_consumption_watts = 5000 AND performance_tests.temperature_celsius = 200;	computer	4
WITH TotalPowerConsumption AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          SUM(ur.power_consumption_watts) AS total_power_consumption      FROM computer_info ci      JOIN usage_records ur ON ci.computer_id = ur.computer_id      WHERE ur.cpu_usage_percent = 100          AND ur.gpu_usage_percent = 100          AND ur.ram_usage_percent = 100          AND ur.storage_usage_percent = 100      GROUP BY ci.computer_id, ci.manufacturer, ci.model )  SELECT computer_id, manufacturer, model, total_power_consumption  FROM TotalPowerConsumption  ORDER BY total_power_consumption DESC  LIMIT 5;	computer	1
WITH YearlyEnergyConsumption AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          SUM(ur.power_consumption_watts * ur.usage_duration_hours / 1000) AS total_energy_kwh      FROM computer_info ci      JOIN usage_records ur ON ci.computer_id = ur.computer_id      WHERE ur.usage_date >= date('now', '-1 year')     GROUP BY ci.computer_id, ci.manufacturer, ci.model ) SELECT computer_id, manufacturer, model, total_energy_kwh  FROM YearlyEnergyConsumption  ORDER BY total_energy_kwh DESC  LIMIT 10;	computer	2
WITH LowBatteryHealthComputers AS (     SELECT bu.computer_id, ci.manufacturer, ci.model, bu.battery_health_percent, ci.battery_capacity_wh, bu.usage_duration_hours      FROM battery_usage bu      JOIN computer_info ci ON bu.computer_id = ci.computer_id      WHERE bu.battery_health_percent < 80 ),  AggregatedData AS (     SELECT computer_id, manufacturer, model, battery_health_percent,             AVG(battery_capacity_wh) OVER () AS avg_battery_capacity,             AVG(usage_duration_hours) OVER () AS avg_usage_duration      FROM LowBatteryHealthComputers )  SELECT DISTINCT computer_id, manufacturer, model, battery_health_percent, avg_battery_capacity, avg_usage_duration  FROM AggregatedData  ORDER BY battery_health_percent ASC;	computer	3
WITH ExtremeUsagePower AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          (1000.0 * ci.cpu_base_frequency_ghz / 100) AS cpu_power,          (500.0 * ci.gpu_vram_gb / 100) AS gpu_power,          (200.0 * ci.ram_size_gb / 100) AS ram_power,          (150.0 * ci.storage_size_gb / 100) AS storage_power,          (1000.0 * ci.cpu_base_frequency_ghz / 100 + 500.0 * ci.gpu_vram_gb / 100 + 200.0 * ci.ram_size_gb / 100 + 150.0 * ci.storage_size_gb / 100) AS total_power      FROM computer_info ci )  SELECT computer_id, manufacturer, model, total_power  FROM ExtremeUsagePower  WHERE total_power > 10000  ORDER BY total_power DESC;	computer	4
WITH HeatGeneration AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          SUM(ur.power_consumption_watts * ur.usage_duration_hours * 3600) AS total_heat_joules      FROM          computer_info ci      JOIN          usage_records ur ON ci.computer_id = ur.computer_id      WHERE          ur.cpu_usage_percent = 100          AND ur.gpu_usage_percent = 100          AND ur.ram_usage_percent = 100          AND ur.storage_usage_percent = 100      GROUP BY          ci.computer_id, ci.manufacturer, ci.model )  SELECT      computer_id,      manufacturer,      model,      total_heat_joules  FROM      HeatGeneration  ORDER BY      total_heat_joules DESC  LIMIT 5;	computer	1
WITH YearlyEnergyConsumption AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          SUM(ur.power_consumption_watts * ur.usage_duration_hours / 1000) AS total_energy_kwh      FROM          computer_info ci      JOIN          usage_records ur ON ci.computer_id = ur.computer_id      WHERE          ur.usage_date >= date('now', '-1 year')     GROUP BY          ci.computer_id, ci.manufacturer, ci.model ) SELECT      computer_id,      manufacturer,      model,      total_energy_kwh / 365 AS avg_daily_energy_kwh  FROM      YearlyEnergyConsumption  ORDER BY      avg_daily_energy_kwh DESC  LIMIT 10;	computer	2
WITH OldLowBatteryComputers AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          ci.production_year,          ci.battery_capacity_wh,          bu.usage_duration_hours      FROM computer_info ci      JOIN battery_usage bu ON ci.computer_id = bu.computer_id      WHERE ci.production_year < 2018      AND bu.battery_health_percent < 70 ),  AggregatedData AS (     SELECT          computer_id,          manufacturer,          model,          production_year,          (SELECT AVG(battery_capacity_wh) FROM OldLowBatteryComputers) AS avg_battery_capacity,          (SELECT AVG(usage_duration_hours) FROM OldLowBatteryComputers) AS avg_usage_duration      FROM OldLowBatteryComputers )  SELECT DISTINCT      computer_id,      manufacturer,      model,      production_year,      avg_battery_capacity,      avg_usage_duration  FROM AggregatedData  ORDER BY production_year ASC;	computer	3
WITH TheoreticalMaxPower AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          (200 * ci.cpu_base_frequency_ghz) AS cpu_max_power,          (ci.gpu_vram_gb * 10) AS gpu_power,          (ci.ram_size_gb * 5) AS ram_power,          (ci.storage_size_gb * 2) AS storage_power,          (200 * ci.cpu_base_frequency_ghz + ci.gpu_vram_gb * 10 + ci.ram_size_gb * 5 + ci.storage_size_gb * 2) AS total_max_power      FROM computer_info ci )  SELECT      computer_id,      manufacturer,      model,      total_max_power  FROM TheoreticalMaxPower  WHERE total_max_power > 50000  ORDER BY total_max_power DESC;	computer	4
WITH DischargeRate AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          SUM(ur.power_consumption_watts * ur.usage_duration_hours) AS discharge_rate_wh      FROM          computer_info ci      JOIN          usage_records ur ON ci.computer_id = ur.computer_id      WHERE          ur.cpu_usage_percent = 100          AND ur.gpu_usage_percent = 100          AND ur.ram_usage_percent = 100          AND ur.storage_usage_percent = 100      GROUP BY          ci.computer_id, ci.manufacturer, ci.model )  SELECT      computer_id,      manufacturer,      model,      discharge_rate_wh  FROM      DischargeRate  ORDER BY      discharge_rate_wh DESC  LIMIT 5;	computer	1
WITH YearlyUsage AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          SUM(ur.usage_duration_hours) AS total_usage_hours      FROM computer_info ci      JOIN usage_records ur ON ci.computer_id = ur.computer_id      WHERE ur.usage_date >= date('now', '-1 year')      GROUP BY ci.computer_id, ci.manufacturer, ci.model )  SELECT      computer_id,      manufacturer,      model,      total_usage_hours  FROM YearlyUsage  ORDER BY total_usage_hours DESC  LIMIT 10;	computer	2
WITH OldLowBatteryComputers AS (     SELECT ci.computer_id, ci.manufacturer, ci.model, ci.production_year, ci.battery_capacity_wh, bu.usage_duration_hours      FROM computer_info ci      JOIN battery_usage bu ON ci.computer_id = bu.computer_id      WHERE ci.production_year < 2018 AND bu.battery_health_percent < 70 ),  AggregatedData AS (     SELECT computer_id, manufacturer, model, production_year,             AVG(battery_capacity_wh) OVER () AS avg_battery_capacity,             AVG(usage_duration_hours) OVER () AS avg_usage_duration      FROM OldLowBatteryComputers )  SELECT DISTINCT computer_id, manufacturer, model, production_year, avg_battery_capacity, avg_usage_duration  FROM AggregatedData  ORDER BY production_year ASC;	computer	3
WITH TheoreticalRuntime AS (     SELECT          ci.computer_id,          ci.manufacturer,          ci.model,          ci.battery_capacity_wh,          ur.power_consumption_watts,          (ci.battery_capacity_wh * 1.0 / ur.power_consumption_watts) AS theoretical_runtime_hours      FROM computer_info ci      JOIN usage_records ur ON ci.computer_id = ur.computer_id      WHERE ur.cpu_usage_percent = 100          AND ur.gpu_usage_percent = 100          AND ur.ram_usage_percent = 100          AND ur.storage_usage_percent = 100 )  SELECT      computer_id,      manufacturer,      model,      theoretical_runtime_hours  FROM TheoreticalRuntime  WHERE theoretical_runtime_hours > 1000  ORDER BY theoretical_runtime_hours DESC;	computer	4
SELECT ((1013 - DataValue) / 1013.0) * 100 AS PressureChangePercentage FROM DataCollectionRecord WHERE DataType = '压力' AND CollectorId IN (SELECT Id FROM DataCollector WHERE ElevationMeters = 5000);	DataCollector	1
SELECT (COUNT(CASE WHEN DataValue BETWEEN 20 AND 30 THEN 1 END) * 100.0 / COUNT(*)) AS Probability FROM DataCollectionRecord WHERE DataType = '温度' AND DATE(CollectionTime) = DATE('now');	DataCollector	2
SELECT Id, CollectorModel, InstallationLocation, ManufactureDate, InstallationDate, Manufacturer, Status, Notes FROM DataCollector WHERE Status = '维修' AND InstallationLocation = '工厂A';	DataCollector	3
SELECT CollectorId, COUNT(*) AS TotalCollections, SUM(LENGTH(DataValue)) / 1024.0 AS TotalDataSizeKB, (SUM(LENGTH(DataValue)) / 1024.0 / 1024.0 / 1024.0) AS TotalDataSizeGB, CASE WHEN COUNT(*) > 1000000 THEN '不可行：数据量过大' ELSE '可行：数据量在可接受范围内' END AS Feasibility FROM DataCollectionRecord WHERE date(CollectionTime) BETWEEN date('now','-1 year') AND date('now') AND CollectorId IN (SELECT Id FROM DataCollector WHERE CollectorModel = '高频采集器') GROUP BY CollectorId;	DataCollector	4
SELECT DataCollector.Id, DataCollector.InstallationLocation, DataCollector.ElevationMeters, DataCollectionRecord.DataValue AS Temperature, 1013 * POWER(1 - (0.0065 * DataCollector.ElevationMeters) / 288.15, (9.80665 * 0.0289644) / (8.3144598 * 0.0065)) AS Pressure_hPa FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.Status = '停机' AND DataCollector.ElevationMeters = 3000 AND DataCollectionRecord.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DataCollector.Id);	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 10 * 0.5 * 60 * 24 * 30 AS TotalDataSizeKB, (10 * 0.5 * 60 * 24 * 30) / 1024.0 AS TotalDataSizeMB FROM DataCollector WHERE Status = '运行';	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.ManufactureDate, DataCollector.InstallationDate, DataCollector.Manufacturer, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE Status = '维修' AND InstallationLocation = '化工厂';	DataCollector	3
SELECT Id, CollectorModel, InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024.0 / 1024.0 AS TotalDataSizeTB FROM DataCollector WHERE Status = '运行';	DataCollector	4
SELECT DataCollector.Id, DataCollector.Latitude, DataCollectionRecord.DataValue AS Temperature, (7.2921 * POWER(10, -5)) * 6371000 * COS(RADIANS(DataCollector.Latitude)) AS LinearVelocity_mps FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.Latitude = 60 AND DataCollectionRecord.DataType = '温度' AND DataCollectionRecord.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DataCollector.Id);	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 5 * 0.2 * 60 * 24 * 365 AS TotalDataSizeKB, (5 * 0.2 * 60 * 24 * 365) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Latitude = 45;	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Latitude, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE DataCollector.Latitude = 30 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 1 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 1 * 60 * 60 * 24 * 365) / 1024.0 / 1024.0 / 1024.0 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Latitude = 90;	DataCollector	4
SELECT DataCollector.Id, DataCollector.Latitude, DataCollectionRecord.DataValue AS Temperature, DEGREES(ASIN(SIN(RADIANS(DataCollector.Latitude)) * SIN(RADIANS(23.44)) + COS(RADIANS(DataCollector.Latitude)) * COS(RADIANS(23.44)) * COS(RADIANS(0)))) AS SolarElevationAngle FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.Longitude = 0 AND DataCollectionRecord.DataType = '温度' AND DATE(DataCollectionRecord.CollectionTime) = DATE('now') ORDER BY DataCollectionRecord.CollectionTime DESC LIMIT 1;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 10 * 0.5 * 60 * 24 * 30 AS TotalDataSizeKB, (10 * 0.5 * 60 * 24 * 30) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Longitude = 120;	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Longitude, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE DataCollector.Longitude = -90 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024.0 / 1024.0 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Longitude = 180;	DataCollector	4
SELECT DataCollector.Id, DataCollector.ElevationMeters, DataCollectionRecord.DataValue AS Pressure_hPa, ((1013.0 - DataCollectionRecord.DataValue) / 1013.0) * 100.0 AS PressureChangePercentage FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.ElevationMeters = 5000 AND DataCollectionRecord.DataType = '压力' ORDER BY DataCollectionRecord.CollectionTime DESC LIMIT 1;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 5 * 0.2 * 60 * 24 * 365 AS TotalDataSizeKB, (5 * 0.2 * 60 * 24 * 365) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.ElevationMeters = 3000;	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.ElevationMeters, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE DataCollector.ElevationMeters = 1000 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024.0 / 1024.0 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.ElevationMeters = 8848;	DataCollector	4
SELECT DataCollector.Id, DataCollectionRecord.DataValue AS Temperature_Celsius, (DataCollectionRecord.DataValue * 9 / 5 + 32) AS Temperature_Fahrenheit  FROM DataCollector  JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId  WHERE DataCollectionRecord.DataType = '温度'  AND DataCollectionRecord.DataUnit = '摄氏度'  AND DataCollectionRecord.DataValue = 25;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 5 * 0.2 * 60 * 24 * 365 AS TotalDataSizeKB, (5 * 0.2 * 60 * 24 * 365) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '温度' AND DataValue = 30);	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Latitude, DataCollector.Longitude, DataCollector.ElevationMeters, DataCollector.Status, DataCollector.Notes FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollectionRecord.DataType = '温度' AND DataCollectionRecord.DataValue = -10 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024.0 / 1024.0 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '温度' AND DataValue = 1000);	DataCollector	4
SELECT DataCollector.Id, DataCollectionRecord.DataValue AS RelativeHumidity, (DataCollectionRecord.DataValue / 100.0 * 3.169 * 1000.0) / (461.5 * 298.15) AS AbsoluteHumidity_gpm3 FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollectionRecord.DataType = '湿度' AND DataCollectionRecord.DataUnit = '百分比' AND DataCollectionRecord.DataValue = 80;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 10 * 0.5 * 60 * 24 * 30 AS TotalDataSizeKB, (10 * 0.5 * 60 * 24 * 30) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '湿度' AND DataValue = 60);	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Latitude, DataCollector.Longitude, DataCollector.ElevationMeters, DataCollector.Status, DataCollector.Notes FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollectionRecord.DataType = '湿度' AND DataCollectionRecord.DataValue = 95 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024.0 / 1024.0 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '湿度' AND DataValue = 200);	DataCollector	4
SELECT dcr.Id AS RecordId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (dcr.DataValue / 1013.25) AS PressureInAtm, CASE WHEN (dcr.DataValue / 1013.25) > 1 THEN '高压环境，可能影响设备密封性和结构强度' WHEN (dcr.DataValue / 1013.25) < 1 THEN '低压环境，可能影响设备性能' ELSE '标准大气压，设备运行正常' END AS PressureImpact FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa';	DataCollector	1
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, COUNT(dcr.Id) AS TotalCollections, COUNT(dcr.Id) * 0.2 AS TotalDataKB, COUNT(dcr.Id) * 0.2 / 1024 AS TotalDataMB, COUNT(dcr.Id) * 0.2 / 1024 / 1024 AS TotalDataGB, CASE WHEN COUNT(dcr.Id) * 0.2 / 1024 / 1024 > 1000 THEN '需要大容量存储设备（如TB级硬盘）' WHEN COUNT(dcr.Id) * 0.2 / 1024 / 1024 > 100 THEN '需要中等容量存储设备（如数百GB硬盘）' ELSE '常规存储设备即可满足需求' END AS StorageRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 500 AND dcr.DataUnit = 'hPa' AND dcr.CollectionTime BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY dc.Id, dc.CollectorModel, dc.InstallationLocation, dc.Status;	DataCollector	2
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dc.ElevationMeters, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = 2000 AND dc.Status = '运行' THEN '高压环境（如深海或高压工业设备），可能导致设备密封失效或结构变形' ELSE '环境条件正常' END AS EnvironmentCondition, CASE WHEN dcr.DataValue = 2000 AND dc.Status = '运行' THEN '建议定期检查设备密封性和结构强度，确保设备正常运行' ELSE '无需特殊维护' END AS MaintenanceRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 2000 AND dcr.DataUnit = 'hPa' AND dc.Status = '运行';	DataCollector	3
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (100 * 10 * 60 * 60 * 24 * 365) AS TotalDataKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 AS TotalDataMB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 AS TotalDataGB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataTB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 AS TotalDataPB, CASE WHEN (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 > 1 THEN '数据量过大，存储和处理不可行' ELSE '数据量在可接受范围内' END AS FeasibilityAnalysis FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 100000 AND dcr.DataUnit = 'hPa';	DataCollector	4
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = -273.15 AND dcr.DataUnit = '°C' THEN '绝对零度，分子和原子热运动停止' ELSE '非绝对零度' END AS PhysicalMeaning, CASE WHEN dcr.DataValue = -273.15 AND dcr.DataUnit = '°C' THEN '极端低温可能导致设备材料脆化或电子元件失效' ELSE '温度在正常范围内，设备运行正常' END AS ImpactOnDevice FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '温度' AND dcr.DataValue = -273.15 AND dcr.DataUnit = '°C';	DataCollector	1
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, COUNT(dcr.Id) AS TotalCollections, COUNT(dcr.Id) * 0.5 AS TotalDataKB, COUNT(dcr.Id) * 0.5 / 1024 AS TotalDataMB, CASE WHEN COUNT(dcr.Id) * 0.5 / 1024 > 100 THEN '需要中等容量存储设备（如数百GB硬盘）' ELSE '常规存储设备即可满足需求' END AS StorageRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '湿度' AND dcr.DataValue = 0 AND dcr.DataUnit = '%' AND dcr.CollectionTime BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY dc.Id, dc.CollectorModel, dc.InstallationLocation, dc.Status;	DataCollector	2
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = 0 AND dcr.DataUnit = 'hPa' THEN '真空环境（如太空或实验室真空室）' ELSE '非真空环境' END AS EnvironmentCondition, CASE WHEN dcr.DataValue = 0 AND dcr.DataUnit = 'hPa' THEN '真空环境可能导致设备散热不良或材料挥发' ELSE '环境条件正常，设备运行正常' END AS ImpactOnDevice FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 0 AND dcr.DataUnit = 'hPa' AND dc.Status = '运行';	DataCollector	3
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (100 * 10 * 60 * 60 * 24 * 365) AS TotalDataKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 AS TotalDataMB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 AS TotalDataGB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataTB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 AS TotalDataPB, CASE WHEN (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 > 1 THEN '数据量过大，存储和处理不可行' ELSE '数据量在可接受范围内' END AS FeasibilityAnalysis FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '温度' AND dcr.DataValue = -1000 AND dcr.DataUnit = '°C';	DataCollector	4
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (dcr.DataValue + 273.15) AS TemperatureInKelvin, CASE WHEN dcr.DataValue = 1000 THEN '高温可能导致设备内部材料膨胀、电子元件失效或散热系统超负荷运行' ELSE '温度在正常范围内，设备运行正常' END AS ImpactOnDevice FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '温度' AND dcr.DataValue = 1000 AND dcr.DataUnit = '°C';	DataCollector	1
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, COUNT(dcr.Id) AS TotalCollections, COUNT(dcr.Id) * 0.5 AS TotalDataKB, COUNT(dcr.Id) * 0.5 / 1024 AS TotalDataMB, CASE WHEN COUNT(dcr.Id) * 0.5 / 1024 > 100 THEN '需要中等容量存储设备（如数百GB硬盘）' ELSE '常规存储设备即可满足需求' END AS StorageRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '湿度' AND dcr.DataValue = 100 AND dcr.DataUnit = '%' AND dcr.CollectionTime BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY dc.Id, dc.CollectorModel, dc.InstallationLocation, dc.Status;	DataCollector	2
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa' THEN '海平面环境，可能受到季节性气候变化的影响' ELSE '非海平面环境' END AS EnvironmentCondition, CASE WHEN dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa' THEN '建议定期检查设备防护措施，确保设备在极端天气下正常运行' ELSE '环境条件稳定，无需特殊维护' END AS MaintenanceRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa' AND dc.Status = '运行';	DataCollector	3
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit,  (100 * 10 * 60 * 60 * 24 * 365) AS TotalDataKB,  (100 * 10 * 60 * 60 * 24 * 365) / 1024 AS TotalDataMB,  (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024 AS TotalDataGB,  (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024 / 1024 AS TotalDataTB,  (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024 / 1024 / 1024 AS TotalDataPB,  CASE WHEN (100 * 10 * 60 * 60 * 24 * 365) / 1024.0 / 1024 / 1024 / 1024 > 1 THEN '数据量过大，存储和处理不可行' ELSE '数据量在可接受范围内' END AS FeasibilityAnalysis  FROM DataCollectionRecord dcr  JOIN DataCollector dc ON dcr.CollectorId = dc.Id  WHERE dcr.DataType = '温度' AND dcr.DataValue = 1000000 AND dcr.DataUnit = '°C';	DataCollector	4
SELECT ((T1.AverageValue - T2.AverageValue) / (DC1.ElevationMeters - DC2.ElevationMeters)) AS TemperatureLapseRate  FROM DataCollector DC1  JOIN DataCollectionRecord T1 ON DC1.Id = T1.CollectorId  JOIN DataCollector DC2 ON DC2.ElevationMeters = DC1.ElevationMeters - 100  JOIN DataCollectionRecord T2 ON DC2.Id = T2.CollectorId  WHERE DC1.ElevationMeters = 3000  AND T1.DataType = '温度'  AND T2.DataType = '温度'  AND T1.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DC1.Id AND DataType = '温度')  AND T2.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DC2.Id AND DataType = '温度');	DataCollector	1
SELECT SUM(DataValue) AS TotalSum, AVG(POWER(DataValue - (SELECT AVG(DataValue) FROM DataCollectionRecord WHERE DataType = '温度' AND CollectorId = DC.Id AND CollectionTime >= datetime('now', '-24 hours')), 2)) AS Variance FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '温度' AND DCR.CollectionTime >= datetime('now', '-24 hours') GROUP BY DC.Id;	DataCollector	2
SELECT DC.InstallationLocation, AVG(DCR.DataValue) AS AverageTemperature, (SELECT AVG(DCR2.DataValue) FROM DataCollectionRecord DCR2 JOIN DataCollector DC2 ON DCR2.CollectorId = DC2.Id WHERE DC2.InstallationLocation LIKE '%郊区%' AND DCR2.DataType = '温度') AS SuburbAverageTemperature FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DC.InstallationLocation LIKE '%市中心%' AND DCR.DataType = '温度' GROUP BY DC.InstallationLocation;	DataCollector	3
SELECT SUM(DCR.DataValue) AS TotalSum, CASE WHEN MAX(DCR.DataValue) >= 1500 THEN '采集器可能损坏' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '温度' AND DCR.CollectionTime BETWEEN datetime('now','-1 year') AND datetime('now') GROUP BY DC.Id;	DataCollector	4
SELECT AVG(DCR.DataValue) AS AverageValue, AVG(DCR.DataValue) - (1.96 * (1.0 / SQRT(COUNT(DCR.DataValue)))) AS LowerBound, AVG(DCR.DataValue) + (1.96 * (1.0 / SQRT(COUNT(DCR.DataValue)))) AS UpperBound FROM DataCollectionRecord DCR WHERE DCR.DataType = '温度' AND DCR.DataAccuracy = 95 GROUP BY DCR.CollectorId;	DataCollector	1
SELECT SUM(DCR.DataValue) AS TotalSum,         STDEV(DCR.DataValue) / SQRT(COUNT(DCR.DataValue)) AS StandardError  FROM DataCollectionRecord DCR  WHERE DCR.DataType = '湿度'    AND DCR.DataAccuracy = 98    AND DCR.CollectionTime BETWEEN datetime('now', '-24 hours') AND datetime('now')  GROUP BY DCR.CollectorId;	DataCollector	2
SELECT DCR.AverageValue, DC.ElevationMeters, DCR.DataAccuracy FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '压力' AND DCR.DataAccuracy = 99 AND DC.ElevationMeters = 0;	DataCollector	3
SELECT SUM(DCR.DataValue) AS TotalSum,         CASE WHEN MAX(DCR.DataAccuracy) > 100 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status  FROM DataCollectionRecord DCR  WHERE DCR.DataType = '湿度'    AND DCR.CollectionTime BETWEEN datetime('now','-1 year') AND datetime('now')  GROUP BY DCR.CollectorId;	DataCollector	4
SELECT (1.0 - (SELECT COUNT(*) FROM DataCollectionRecord WHERE DataValue <= 100 AND DataType = '温度') / CAST((SELECT COUNT(*) FROM DataCollectionRecord WHERE DataType = '温度') AS REAL)) AS ExceedProbability FROM DataCollectionRule DCR WHERE DCR.DataType = '温度' AND DCR.ThresholdValue = 100;	DataCollector	1
SELECT SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, (DCRec.DataValue - 75) / 3 AS ZScore  FROM DataCollectionRecord DCRec  JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType  WHERE DCRec.DataType = '湿度'  AND DCR.ThresholdValue = 80  AND DCRec.CollectionTime BETWEEN datetime('now', '-24 hours') AND datetime('now')  GROUP BY DCRec.DataValue;	DataCollector	2
SELECT DCRec.AverageValue, DC.ElevationMeters  FROM DataCollectionRecord DCRec  JOIN DataCollector DC ON DCRec.CollectorId = DC.Id  JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType  WHERE DCRec.DataType = '压力'  AND DCR.ThresholdValue = 110  AND DC.ElevationMeters = 500;	DataCollector	3
SELECT SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount,         CASE WHEN SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) > 0              THEN '采集器可能失效'              ELSE '采集器正常工作' END AS Status  FROM DataCollectionRecord DCRec  JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType  WHERE DCRec.DataType = '温度'    AND DCR.ThresholdValue = 1000    AND DCRec.CollectionTime BETWEEN datetime('now', '-1 year') AND datetime('now');	DataCollector	4
SELECT (1.0 - (SELECT COUNT(*) FROM DataCollectionRecord WHERE DataValue > 30 AND DataType = '温度') * 1.0 / (SELECT COUNT(*) FROM DataCollectionRecord WHERE DataType = '温度')) AS ExceedProbability FROM DataCollectionRule WHERE DataType = '温度' AND ThresholdValue = 30 AND ConditionOperator = '>';	DataCollector	1
SELECT SUM(CASE WHEN DCRec.DataValue < 60 THEN 1 ELSE 0 END) AS BelowCount, (DCRec.DataValue - 65) / 3 AS ZScore FROM DataCollectionRecord DCRec JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '湿度' AND DCR.ThresholdValue = 60 AND DCR.ConditionOperator = '<' AND DCRec.CollectionTime BETWEEN datetime('now', '-24 hours') AND datetime('now') GROUP BY DCRec.DataValue;	DataCollector	2
SELECT DCRec.AverageValue, DC.ElevationMeters  FROM DataCollectionRecord DCRec  JOIN DataCollector DC ON DCRec.CollectorId = DC.Id  JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType  WHERE DCRec.DataType = '压力'  AND DCR.ThresholdValue = 101.3  AND DCR.ConditionOperator = '='  AND DC.ElevationMeters = 0;	DataCollector	3
SELECT SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, CASE WHEN SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) > 0 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCRec JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '温度' AND DCR.ThresholdValue = 1000 AND DCR.ConditionOperator = '>' AND DCRec.CollectionTime BETWEEN datetime('now', '-1 year') AND datetime('now');	DataCollector	4
SELECT COUNT(*) AS TotalCount, 2.0 / SQRT(COUNT(*)) AS StandardError  FROM DataCollectionRecord DCR  JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType  WHERE DCR.DataType = '温度'  AND DCRule.CollectionFrequency = '每分钟'  AND DCR.CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	DataCollector	1
SELECT SUM(DCR.DataValue) AS TotalSum, AVG(POWER(DCR.DataValue - 60, 2)) AS Variance  FROM DataCollectionRecord DCR  JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType  WHERE DCR.DataType = '湿度'  AND DCRule.CollectionFrequency = '每小时'  AND DCR.CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now');	DataCollector	2
SELECT DCRule.CollectionFrequency, AVG(DCR.DataValue) AS AveragePressure, STDEV(DCR.DataValue) AS StandardDeviation  FROM DataCollectionRecord DCR  JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType  JOIN DataCollector DC ON DCR.CollectorId = DC.Id  WHERE DCR.DataType = '压力'  AND DCRule.CollectionFrequency = '每分钟'  AND DC.ElevationMeters = 0;	DataCollector	3
SELECT SUM(DCR.DataValue) AS TotalSum,         CASE             WHEN DCRule.CollectionFrequency = '每秒' AND COUNT(*) > 31536000             THEN '采集器可能失效'             ELSE '采集器正常工作'         END AS Status  FROM DataCollectionRecord DCR  JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType  WHERE DCR.DataType = '温度'    AND DCR.CollectionTime BETWEEN datetime('now', '-1 year') AND datetime('now') GROUP BY DCRule.CollectionFrequency;	DataCollector	4
SELECT AVG(DCR.DataValue) AS AverageValue, AVG(DCR.DataValue) - (1.96 * (2.0 / SQRT(COUNT(*)))) AS LowerBound, AVG(DCR.DataValue) + (1.96 * (2.0 / SQRT(COUNT(*)))) AS UpperBound, CASE WHEN MAX(DCR.DataValue) > DCRule.ThresholdValue THEN '需要发送通知' ELSE '无需发送通知' END AS NotificationStatus FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '温度' AND DCRule.ActionType = '通知' GROUP BY DCRule.ThresholdValue;	DataCollector	1
SELECT SUM(CASE WHEN DCR.DataValue > DCRule.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount,         (DCR.DataValue - 70) / 3 AS ZScore  FROM DataCollectionRecord DCR  JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType  WHERE DCR.DataType = '湿度'    AND DCRule.ActionType = '处理'    AND DCR.CollectionTime BETWEEN datetime('now', '-24 hours') AND datetime('now') GROUP BY DCR.DataValue;	DataCollector	2
SELECT AVG(DCR.DataValue) AS AveragePressure, DCRule.ThresholdValue, CASE WHEN AVG(DCR.DataValue) BETWEEN 101.3 - 0.5 AND 101.3 + 0.5 THEN '无需发送通知' ELSE '需要发送通知' END AS NotificationStatus FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '压力' AND DCRule.ActionType = '通知' AND DC.ElevationMeters = 0 GROUP BY DCRule.ThresholdValue;	DataCollector	3
SELECT SUM(CASE WHEN DCR.DataValue > DCRule.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, CASE WHEN SUM(CASE WHEN DCR.DataValue > DCRule.ThresholdValue THEN 1 ELSE 0 END) > 0 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '温度' AND DCRule.ActionType = '处理' AND DCR.CollectionTime BETWEEN datetime('now', '-1 year') AND datetime('now');	DataCollector	4
SELECT 1.225 * 50 AS Mass, 1.225 * 50 * 1.005 * (30 - 25) AS HeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '公众' AND DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '政府' AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%' AND DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '企业' AND DCNR.NotificationContent LIKE '%压力数据超出阈值110kPa%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost, CASE WHEN DCNR.RecipientCount * 10000 > 1000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '公众' AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%' AND DCNR.NotificationMethod = '广播';	DataCollector	4
SELECT DCNR.RecipientCount * (1.225 * 50 * 1.005 * (30 - 25)) AS TotalHeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '农业生产者' AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost, CASE WHEN DCNR.RecipientCount * 10000 > 1000000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '广播' AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT 1.225 * 10000 * 1.005 * (30 - 25) AS HeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '广播' AND DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '邮件' AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost,         CASE WHEN DCNR.RecipientCount * 10000 > 1000000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus  FROM DataCollectionNotificationRecord DCNR  WHERE DCNR.NotificationMethod = '广播'    AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT 1.225 * 10000 * 1.005 * (30 - 25) AS HeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationStatus = '成功' AND DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationStatus = '失败' AND DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType  FROM DataCollectionNotificationRecord DCNR  WHERE DCNR.NotificationStatus = '成功'  AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost, CASE WHEN DCNR.RecipientCount * 10000 > 1000000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationStatus = '失败' AND DCNR.NotificationMethod = '广播' AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT (strftime('%s', AcknowledgedTime) - strftime('%s', NotificationTime)) AS TimeDifferenceInSeconds, (1.225 * 10000) * 1.005 * (30 - 25) AS HeatRequiredInKJ FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT RecipientCount * 0.01 AS TotalCost, RecipientCount * 0.95 AS SuccessfullySentCount FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	2
SELECT NotificationContent, AcknowledgedTime FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%压力数据超出阈值110kPa%';	DataCollector	3
SELECT RecipientCount * 10000 AS TotalCost, CASE WHEN RecipientCount * 10000 > 1000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '9999-12-31 23:59:59' AND NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT (strftime('%s', dcn.NotificationTime) - strftime('%s', dc.CollectionTime)) AS TimeDifferenceInSeconds, (1.225 * 10000) * 1.005 * (30 - 25) AS HeatRequiredInKJ FROM DataCollectionNotificationRecord dcn JOIN DataCollectionRecord dc ON dcn.TriggerId = dc.Id WHERE dcn.NotificationTime = '2023-10-01 12:00:00' AND dcn.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT RecipientCount * 0.01 AS TotalCost, RecipientCount * 0.95 AS SuccessfullySentCount  FROM DataCollectionNotificationRecord  WHERE NotificationTime = '2023-10-01 12:00:00'  AND NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	2
SELECT NotificationContent, NotificationTime FROM DataCollectionNotificationRecord WHERE NotificationTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%压力数据超出阈值110kPa%';	DataCollector	3
SELECT RecipientCount * 10000 AS TotalCost, CASE WHEN RecipientCount * 10000 > 1000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord WHERE NotificationTime = '9999-12-31 23:59:59' AND NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT Headphone_Id, Sound_Pressure_Level_Db, Sensitivity_Db, (Sound_Pressure_Level_Db * Sensitivity_Db) AS Product FROM audio_data ORDER BY Product ASC;	earphone	1
SELECT Headphone_Id, Total_Harmonic_Distortion_Percent, Impedance_Ohms, (Total_Harmonic_Distortion_Percent / Impedance_Ohms) AS Distortion_Impedance_Ratio FROM audio_data ORDER BY Distortion_Impedance_Ratio DESC LIMIT 10;	earphone	2
SELECT Headphone_Id, Battery_Life_Hours, Weight_Grams, (Battery_Life_Hours / Weight_Grams) AS Battery_Weight_Ratio FROM headphones WHERE Is_Wireless = 1 ORDER BY Battery_Weight_Ratio ASC;	earphone	3
SELECT Headphone_Id, Sound_Pressure_Level_Db, 100000 AS Max_Input_Power_Mw, (Sound_Pressure_Level_Db / 100000.0) AS Sound_Power_Ratio  FROM audio_data  ORDER BY Sound_Power_Ratio DESC  LIMIT 5;	earphone	4
SELECT Headphone_Id, Sensitivity_Db, Impedance_Ohms, (Sensitivity_Db / Impedance_Ohms) AS Sensitivity_Impedance_Ratio  FROM audio_data  ORDER BY Sensitivity_Impedance_Ratio DESC  LIMIT 10;	earphone	1
SELECT Headphone_Id, Weight_Grams, Battery_Life_Hours, (Weight_Grams * Battery_Life_Hours) AS Weight_Battery_Product FROM headphones ORDER BY Weight_Battery_Product ASC LIMIT 5;	earphone	2
SELECT Headphone_Id, Model, Price_Usd FROM headphones WHERE Noise_Cancellation = 1 AND Microphone = 1 ORDER BY Price_Usd ASC LIMIT 5;	earphone	3
SELECT Headphone_Id, Battery_Life_Hours, 10000 AS Weight_Grams, (Battery_Life_Hours / 10000.0) AS Battery_Weight_Ratio FROM headphones ORDER BY Battery_Weight_Ratio DESC LIMIT 5;	earphone	4
SELECT Manufacturer_Id, Manufacturer_Name, (Revenue_Usd / Employees) AS Revenue_Per_Employee  FROM manufacturers  ORDER BY Revenue_Per_Employee DESC  LIMIT 5;	earphone	1
SELECT Manufacturer_Id, Manufacturer_Name, (Profit_Usd * Market_Share_Percent) AS Profit_Market_Index FROM manufacturers ORDER BY Profit_Market_Index DESC LIMIT 10;	earphone	2
SELECT Manufacturer_Id, Manufacturer_Name, Founded_Year FROM manufacturers ORDER BY Founded_Year ASC LIMIT 3;	earphone	3
SELECT Manufacturer_Id, Manufacturer_Name, (Revenue_Usd / 1000000.0) AS Extreme_Revenue_Per_Employee  FROM manufacturers  ORDER BY Extreme_Revenue_Per_Employee DESC  LIMIT 5;	earphone	4
SELECT Record_Id, Headphone_Id, User_Id, (Battery_Consumed_Percent / Usage_Duration_Minutes) AS Battery_Consumption_Rate FROM usage_records ORDER BY Battery_Consumption_Rate DESC LIMIT 10;	earphone	1
SELECT Record_Id, Headphone_Id, User_Id, (POWER(Volume_Level_Percent, 2) * Usage_Duration_Minutes) AS Volume_Energy_Index FROM usage_records ORDER BY Volume_Energy_Index DESC LIMIT 5;	earphone	2
SELECT Record_Id, Headphone_Id, User_Id, Usage_Duration_Minutes, Battery_Consumed_Percent, Noise_Cancellation_Used FROM usage_records WHERE Noise_Cancellation_Used = 1 AND Battery_Consumed_Percent > 50 ORDER BY Usage_Duration_Minutes ASC LIMIT 3;	earphone	3
SELECT Record_Id, Headphone_Id, User_Id, (SUM(Battery_Consumed_Percent) * 1000000 / Usage_Duration_Minutes) AS Total_Battery_Consumption FROM usage_records GROUP BY Record_Id, Headphone_Id, User_Id ORDER BY Total_Battery_Consumption DESC;	earphone	4
SELECT Headphone_Id, AVG(Battery_Consumed_Percent / (Usage_Duration_Minutes / 60.0)) AS Average_Power_Consumption  FROM usage_records  GROUP BY Headphone_Id  ORDER BY Average_Power_Consumption DESC;	earphone	1
SELECT User_Id, AVG(2.0 / (1.0 / Audio_Quality_Rating + 1.0 / Comfort_Rating)) AS Harmonic_Mean  FROM usage_records  WHERE Audio_Quality_Rating > 0 AND Comfort_Rating > 0  GROUP BY User_Id  ORDER BY Harmonic_Mean DESC  LIMIT 5;	earphone	2
SELECT Headphone_Id, Noise_Cancellation_Used, AVG(Battery_Consumed_Percent) AS Avg_Battery_Consumed_Percent FROM usage_records GROUP BY Headphone_Id, Noise_Cancellation_Used ORDER BY Avg_Battery_Consumed_Percent ASC;	earphone	3
SELECT User_Id, SUM(Battery_Consumed_Percent * POWER(1000.0 / 100, 3)) AS Theoretical_Power_Consumption FROM usage_records GROUP BY User_Id ORDER BY Theoretical_Power_Consumption DESC;	earphone	4
SELECT Country, SUM(Profit_Usd) / (SUM(Employees) * 1000.0) AS Profit_Density FROM manufacturers GROUP BY Country ORDER BY Profit_Density DESC;	earphone	1
SELECT Founded_Year, SQRT(SUM(Profit_Usd * Market_Share_Percent)) AS Profit_Market_Index FROM manufacturers GROUP BY Founded_Year ORDER BY Profit_Market_Index DESC LIMIT 10;	earphone	2
SELECT Country, COUNT(*) AS Manufacturer_Count FROM manufacturers WHERE (2023 - Founded_Year) > 50 GROUP BY Country ORDER BY Manufacturer_Count DESC;	earphone	3
SELECT Country, SUM(Revenue_Usd) / 1000000000 AS Theoretical_Per_Capita_Output FROM manufacturers GROUP BY Country ORDER BY Theoretical_Per_Capita_Output ASC;	earphone	4
SELECT Driver_Type, AVG(Impedance_Ohms / Sensitivity_Db) AS Impedance_Sensitivity_Ratio FROM headphones GROUP BY Driver_Type ORDER BY Impedance_Sensitivity_Ratio ASC;	earphone	1
SELECT (h.Price_Usd / 100) AS price_range, SQRT(AVG(a.Sound_Pressure_Level_Db * a.Total_Harmonic_Distortion_Percent)) AS geometric_mean FROM headphones h JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id GROUP BY price_range ORDER BY geometric_mean DESC;	earphone	2
SELECT Is_Wireless, AVG(Weight_Grams / Battery_Life_Hours) AS weight_to_battery_ratio FROM headphones GROUP BY Is_Wireless ORDER BY weight_to_battery_ratio ASC;	earphone	3
SELECT Water_Resistance, AVG(1000000.0 / Weight_Grams) AS price_per_gram FROM headphones GROUP BY Water_Resistance ORDER BY price_per_gram DESC;	earphone	4
SELECT Driver_Type, AVG(Sensitivity_Db + 10 * LOG10(Max_Input_Power_Mw)) AS max_sound_pressure_level FROM audio_data GROUP BY Driver_Type ORDER BY max_sound_pressure_level DESC;	earphone	1
SELECT Bluetooth_Version, (LOG10(AVG(CAST(SUBSTR(Frequency_Response_Hz, INSTR(Frequency_Response_Hz, '-') + 1) AS REAL) / CAST(SUBSTR(Frequency_Response_Hz, 1, INSTR(Frequency_Response_Hz, '-') - 1) AS REAL))) * AVG(Total_Harmonic_Distortion_Percent)) AS quality_metric FROM audio_data GROUP BY Bluetooth_Version ORDER BY quality_metric ASC;	earphone	2
SELECT Audio_Codec, AVG(Audio_Quality_Rating) AS avg_audio_quality FROM usage_records JOIN audio_data ON usage_records.Headphone_Id = audio_data.Headphone_Id GROUP BY Audio_Codec ORDER BY avg_audio_quality DESC;	earphone	3
SELECT Driver_Type, AVG(Total_Harmonic_Distortion_Percent / 0.0000001) AS improvement_factor FROM audio_data GROUP BY Driver_Type ORDER BY improvement_factor DESC;	earphone	4
SELECT Headphone_Id, Model FROM headphones WHERE Headphone_Id IN (     SELECT Headphone_Id     FROM audio_data     WHERE Sensitivity_Db + 10 * LOG10(Max_Input_Power_Mw) > 120 ) AND Headphone_Id NOT IN (     SELECT Headphone_Id     FROM audio_data     WHERE Sound_Pressure_Level_Db >= 120 );	earphone	1
SELECT Headphone_Id, Model  FROM headphones  WHERE Headphone_Id IN (     SELECT Headphone_Id      FROM audio_data      WHERE LOG10(CAST(SUBSTR(Frequency_Response_Hz, INSTR(Frequency_Response_Hz, '-') + 1) AS REAL) / CAST(SUBSTR(Frequency_Response_Hz, 1, INSTR(Frequency_Response_Hz, '-') - 1) AS REAL)) * Total_Harmonic_Distortion_Percent > 5 )  AND Headphone_Id NOT IN (     SELECT Headphone_Id      FROM usage_records      WHERE Audio_Quality_Rating >= 4 );	earphone	2
SELECT Headphone_Id, Model FROM headphones WHERE Headphone_Id IN (SELECT Headphone_Id FROM audio_data WHERE CAST(SUBSTR(Bluetooth_Version, 1, INSTR(Bluetooth_Version || '.', '.') - 1) AS INTEGER) * 10 + CAST(SUBSTR(Bluetooth_Version, INSTR(Bluetooth_Version, '.') + 1) AS INTEGER) >= 50) AND Headphone_Id NOT IN (SELECT Headphone_Id FROM audio_data WHERE Audio_Codec = 'LDAC');	earphone	3
SELECT Headphone_Id, Model FROM headphones WHERE Headphone_Id IN (SELECT Headphone_Id FROM audio_data WHERE Total_Harmonic_Distortion_Percent / 0.0000001 > 100000000) AND Headphone_Id NOT IN (SELECT Headphone_Id FROM headphones WHERE Price_Usd >= 100);	earphone	4
SELECT Headphone_Id, Model FROM headphones WHERE Headphone_Id IN (SELECT Headphone_Id FROM audio_data WHERE Max_Input_Power_Mw >= POWER(10, (Sound_Pressure_Level_Db - Sensitivity_Db) / 10)) AND Headphone_Id NOT IN (SELECT Headphone_Id FROM audio_data WHERE Impedance_Ohms BETWEEN 16 AND 64);	earphone	1
SELECT Headphone_Id, Model FROM headphones WHERE Headphone_Id IN (SELECT Headphone_Id FROM audio_data WHERE CAST(SUBSTR(Frequency_Response_Hz, 1, INSTR(Frequency_Response_Hz, '-') - 1) AS REAL) <= 20 AND CAST(SUBSTR(Frequency_Response_Hz, INSTR(Frequency_Response_Hz, '-') + 1) AS REAL) >= 20000) AND Headphone_Id NOT IN (SELECT Headphone_Id FROM audio_data WHERE Total_Harmonic_Distortion_Percent >= 1 / (SELECT AVG(Audio_Quality_Rating) FROM usage_records WHERE usage_records.Headphone_Id = audio_data.Headphone_Id));	earphone	2
SELECT Headphone_Id, Model FROM headphones WHERE Is_Wireless = 1 AND Headphone_Id NOT IN (SELECT Headphone_Id FROM headphones WHERE Battery_Life_Hours >= Weight_Grams / 100);	earphone	3
SELECT Headphone_Id, Model FROM headphones WHERE Water_Resistance = 'IPX7' AND Headphone_Id NOT IN (SELECT Headphone_Id FROM headphones WHERE Price_Usd >= 1000000);	earphone	4
SELECT Manufacturer_Id, Manufacturer_Name FROM manufacturers WHERE (Profit_Usd / Employees) >= 50000 AND Manufacturer_Id NOT IN (SELECT Manufacturer_Id FROM manufacturers WHERE (Profit_Usd / Revenue_Usd) * 100 >= 15);	earphone	1
SELECT Manufacturer_Id, Manufacturer_Name FROM manufacturers WHERE (POWER(Founded_Year, 2) * Market_Share_Percent) > 1000000 AND Manufacturer_Id NOT IN (SELECT Manufacturer_Id FROM manufacturers WHERE Employees >= 1000);	earphone	2
SELECT Manufacturer_Id, Manufacturer_Name FROM manufacturers WHERE (2023 - Founded_Year) > 30 AND Manufacturer_Id NOT IN (SELECT Manufacturer_Id FROM manufacturers WHERE Market_Share_Percent >= 5);	earphone	3
SELECT Manufacturer_Id, Manufacturer_Name  FROM manufacturers  WHERE Employees > 1000000 AND (1000000000000.0 / Employees) < 10;	earphone	4
SELECT Record_Id, Headphone_Id FROM usage_records  WHERE Battery_Consumed_Percent = Usage_Duration_Minutes * 0.8  AND Record_Id NOT IN (SELECT Record_Id FROM usage_records WHERE Usage_Duration_Minutes BETWEEN 30 AND 600);	earphone	1
SELECT Record_Id, Headphone_Id, User_Id  FROM usage_records  WHERE (Volume_Level_Percent * Volume_Level_Percent) * Usage_Duration_Minutes > 100000  AND Audio_Quality_Rating < 3;	earphone	2
SELECT Record_Id, Headphone_Id, User_Id FROM usage_records WHERE Noise_Cancellation_Used = 1 AND Battery_Consumed_Percent <= Usage_Duration_Minutes * 0.5;	earphone	3
SELECT Record_Id, Headphone_Id, User_Id FROM usage_records WHERE Battery_Consumed_Percent * POWER(1000.0/NULLIF(Volume_Level_Percent,0), 3) > 1000 AND Battery_Consumed_Percent < 1000;	earphone	4
SELECT a.Headphone_Id, h.Model, a.Sensitivity_Db + 10 * LOG10(a.Max_Input_Power_Mw) AS Max_SPL_Db  FROM audio_data a  JOIN headphones h ON a.Headphone_Id = h.Headphone_Id  ORDER BY Max_SPL_Db DESC  LIMIT 10;	earphone	1
SELECT Audio_Id, Headphone_Id,         LOG10(CAST(SUBSTR(Frequency_Response_Hz, INSTR(Frequency_Response_Hz, '-') + 1) AS REAL) /               CAST(SUBSTR(Frequency_Response_Hz, 1, INSTR(Frequency_Response_Hz, '-') - 1) AS REAL)) *         Total_Harmonic_Distortion_Percent AS Metric  FROM audio_data  ORDER BY Metric ASC  LIMIT 5;	earphone	2
SELECT Bluetooth_Version, AVG(Audio_Quality_Rating) AS Avg_Audio_Quality_Rating FROM audio_data JOIN usage_records ON audio_data.Headphone_Id = usage_records.Headphone_Id WHERE Audio_Codec = 'LDAC' GROUP BY Bluetooth_Version ORDER BY Avg_Audio_Quality_Rating DESC;	earphone	3
SELECT audio_data.Headphone_Id, headphones.Model, audio_data.Sensitivity_Db + 10 * LOG10(audio_data.Max_Input_Power_Mw) AS Max_SPL_Db FROM audio_data JOIN headphones ON audio_data.Headphone_Id = headphones.Headphone_Id ORDER BY Max_SPL_Db DESC LIMIT 10;	earphone	4
SELECT Headphone_Id, Model, Sensitivity_Db / SQRT(Impedance_Ohms) AS Efficiency_Ratio FROM headphones ORDER BY Efficiency_Ratio DESC LIMIT 5;	earphone	1
SELECT Audio_Id, Headphone_Id,         (CAST(SUBSTR(Frequency_Response_Hz, INSTR(Frequency_Response_Hz, '-') + 1) AS REAL) -          CAST(SUBSTR(Frequency_Response_Hz, 1, INSTR(Frequency_Response_Hz, '-') - 1) AS REAL)) *          Total_Harmonic_Distortion_Percent AS Metric  FROM audio_data  ORDER BY Metric DESC  LIMIT 10;	earphone	2
SELECT Headphone_Id, Model, Battery_Life_Hours / Weight_Grams AS Battery_Density FROM headphones WHERE Is_Wireless = 1 ORDER BY Battery_Density ASC LIMIT 5;	earphone	3
SELECT Headphone_Id, Model, 1000000 / NULLIF(Weight_Grams, 0) AS Price_Per_Gram FROM headphones ORDER BY Price_Per_Gram DESC LIMIT 3;	earphone	4
SELECT Manufacturer_Id, Manufacturer_Name, Revenue_Usd / (Employees * 1000) AS Revenue_Density FROM manufacturers ORDER BY Revenue_Density DESC LIMIT 5;	earphone	1
SELECT Manufacturer_Id, Manufacturer_Name, SQRT(Profit_Usd * Market_Share_Percent) AS Geometric_Mean FROM manufacturers ORDER BY Geometric_Mean DESC LIMIT 10;	earphone	2
SELECT Manufacturer_Id, Manufacturer_Name, Founded_Year, Market_Share_Percent FROM manufacturers WHERE Founded_Year < 1973 AND Market_Share_Percent < 5 ORDER BY Founded_Year ASC;	earphone	3
SELECT Manufacturer_Id, Manufacturer_Name, 1000000000000 / NULLIF(Employees, 0) AS Per_Capita_Revenue FROM manufacturers WHERE Employees > 100000000 ORDER BY Per_Capita_Revenue ASC;	earphone	4
SELECT Audio_Id, Headphone_Id, Sound_Pressure_Level_Db * Sensitivity_Db AS Product FROM audio_data ORDER BY Product ASC;	earphone	1
SELECT Record_Id, Headphone_Id, (2.0 / (1.0 / Audio_Quality_Rating + 1.0 / Comfort_Rating)) * Usage_Duration_Minutes AS Experience_Index FROM usage_records ORDER BY Experience_Index DESC;	earphone	2
SELECT Record_Id, Headphone_Id, Usage_Duration_Minutes, Volume_Level_Percent, Battery_Consumed_Percent FROM usage_records WHERE Volume_Level_Percent > 80 AND Battery_Consumed_Percent < Usage_Duration_Minutes * 1 ORDER BY Usage_Duration_Minutes ASC LIMIT 5;	earphone	3
SELECT Headphone_Id, (Battery_Consumed_Percent * 1000000 / NULLIF(Usage_Duration_Minutes, 0)) AS Theoretical_Power_Consumption FROM usage_records ORDER BY Theoretical_Power_Consumption DESC LIMIT 3;	earphone	4
SELECT User_Id, AVG(Battery_Consumed_Percent / NULLIF(Usage_Duration_Minutes, 0)) AS Energy_Consumption_Rate FROM usage_records GROUP BY User_Id ORDER BY Energy_Consumption_Rate DESC;	earphone	1
SELECT Headphone_Id, (2.0 / (1.0 / AVG(Audio_Quality_Rating) + 1.0 / AVG(Comfort_Rating))) * COUNT(*) AS Composite_Index  FROM usage_records  GROUP BY Headphone_Id  ORDER BY Composite_Index DESC;	earphone	2
SELECT Headphone_Id,         CAST(SUM(CASE WHEN Noise_Cancellation_Used = 1 AND Volume_Level_Percent > 85 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS Noise_Cancellation_Ratio  FROM usage_records  GROUP BY Headphone_Id  ORDER BY Noise_Cancellation_Ratio ASC;	earphone	3
SELECT User_Id, SUM(Battery_Consumed_Percent) * 100000000 / NULLIF(SUM(Usage_Duration_Minutes), 0) AS Lifetime_Power_Consumption FROM usage_records GROUP BY User_Id ORDER BY Lifetime_Power_Consumption DESC;	earphone	4
SELECT Country, SUM(Revenue_Usd) / (SUM(Employees) * 1000) AS Energy_Density FROM manufacturers GROUP BY Country ORDER BY Energy_Density DESC;	earphone	1
SELECT (Founded_Year / 10) * 10 AS Decade, AVG(SQRT(Profit_Usd * Market_Share_Percent)) AS Geometric_Mean FROM manufacturers WHERE Profit_Usd > 0 AND Market_Share_Percent > 0 GROUP BY Decade ORDER BY Geometric_Mean DESC;	earphone	2
SELECT Country, COUNT(*) AS Manufacturer_Count FROM manufacturers WHERE (2023 - Founded_Year) > 30 AND (Profit_Usd / Revenue_Usd) < 0.1 GROUP BY Country ORDER BY Manufacturer_Count ASC;	earphone	3
SELECT Country, (1000000000000.0 / NULLIF(SUM(Employees), 0)) AS Theoretical_Per_Capita_Output FROM manufacturers WHERE Employees > 100000000 GROUP BY Country ORDER BY Theoretical_Per_Capita_Output ASC;	earphone	4
SELECT Driver_Type, AVG(Sensitivity_Db / SQRT(Impedance_Ohms)) AS Efficiency_Indicator  FROM headphones  WHERE Impedance_Ohms > 0  GROUP BY Driver_Type  ORDER BY Efficiency_Indicator DESC;	earphone	1
SELECT Manufacturer_Id, AVG(Price_Usd) * (AVG(CAST(substr(Frequency_Response_Hz, instr(Frequency_Response_Hz, '-') + 1) AS REAL)) - AVG(CAST(substr(Frequency_Response_Hz, 1, instr(Frequency_Response_Hz, '-') - 1) AS REAL))) AS Composite_Indicator FROM headphones GROUP BY Manufacturer_Id ORDER BY Composite_Indicator DESC;	earphone	2
SELECT Is_Wireless, AVG(Battery_Life_Hours) / AVG(Weight_Grams) AS Battery_Efficiency  FROM headphones  GROUP BY Is_Wireless  ORDER BY Battery_Efficiency ASC;	earphone	3
SELECT Water_Resistance, 1000000.0 / NULLIF(AVG(Weight_Grams), 0) AS Price_Per_Gram FROM headphones GROUP BY Water_Resistance ORDER BY Price_Per_Gram DESC;	earphone	4
SELECT Driver_Type, POWER(10, AVG(Sensitivity_Db) / 10.0) * POWER(10, AVG(Sensitivity_Db) / 10.0) / AVG(Impedance_Ohms) AS Power FROM headphones WHERE Impedance_Ohms > 0 GROUP BY Driver_Type ORDER BY Power DESC;	earphone	1
SELECT Bluetooth_Version, SQRT(AVG(LOG10(CAST(substr(Frequency_Response_Hz, instr(Frequency_Response_Hz, '-') + 1) AS REAL) / CAST(substr(Frequency_Response_Hz, 1, instr(Frequency_Response_Hz, '-') - 1) AS REAL))) * AVG(Total_Harmonic_Distortion_Percent)) AS Metric FROM audio_data WHERE Frequency_Response_Hz LIKE '%-%' AND Total_Harmonic_Distortion_Percent > 0 GROUP BY Bluetooth_Version ORDER BY Metric DESC;	earphone	2
SELECT Audio_Jack_Type, SUM(CASE WHEN Audio_Codec IN ('LDAC', 'AAC') THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS High_Quality_Codec_Ratio FROM audio_data GROUP BY Audio_Jack_Type ORDER BY High_Quality_Codec_Ratio DESC;	earphone	3
SELECT h.Manufacturer_Id, AVG(a.Total_Harmonic_Distortion_Percent) / 0.0000000001 AS Improvement_Factor  FROM audio_data a  JOIN headphones h ON a.Headphone_Id = h.Headphone_Id  GROUP BY h.Manufacturer_Id  ORDER BY Improvement_Factor DESC  LIMIT 5;	earphone	4
SELECT h.Headphone_Id, h.Model FROM headphones h JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id WHERE a.Sensitivity_Db + 10 * LOG(10, a.Max_Input_Power_Mw) > 120 AND h.Headphone_Id NOT IN (SELECT Headphone_Id FROM audio_data WHERE Sound_Pressure_Level_Db >= 120);	earphone	1
SELECT h.Headphone_Id, h.Model  FROM headphones h  JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id  WHERE (LOG10(CAST(SUBSTR(a.Frequency_Response_Hz, INSTR(a.Frequency_Response_Hz, '-') + 1) AS REAL) / CAST(SUBSTR(a.Frequency_Response_Hz, 1, INSTR(a.Frequency_Response_Hz, '-') - 1) AS REAL)) * a.Total_Harmonic_Distortion_Percent) > 5  AND h.Headphone_Id NOT IN (SELECT Headphone_Id FROM usage_records WHERE Audio_Quality_Rating >= 4);	earphone	2
SELECT h.Headphone_Id, h.Model  FROM headphones h  JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id  WHERE (CAST(SUBSTR(a.Bluetooth_Version, 1, INSTR(a.Bluetooth_Version, '.')-1) AS INTEGER) * 10 + CAST(SUBSTR(a.Bluetooth_Version, INSTR(a.Bluetooth_Version, '.')+1) AS INTEGER)) >= 50  AND h.Headphone_Id NOT IN (SELECT Headphone_Id FROM audio_data WHERE Audio_Codec IN ('LDAC', 'AAC'));	earphone	3
SELECT h.Headphone_Id, h.Model  FROM audio_data a  JOIN headphones h ON a.Headphone_Id = h.Headphone_Id  WHERE a.Total_Harmonic_Distortion_Percent / 0.0000000001 > 10000000000  AND h.Price_Usd < 1000;	earphone	4
SELECT h.Headphone_Id, h.Model  FROM headphones h  JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id  WHERE a.Max_Input_Power_Mw >= POWER(10, (a.Sound_Pressure_Level_Db - a.Sensitivity_Db) / 10)  AND h.Headphone_Id NOT IN (SELECT h2.Headphone_Id FROM headphones h2 WHERE h2.Impedance_Ohms BETWEEN 16 AND 64);	earphone	1
SELECT h.Headphone_Id, h.Model FROM headphones h JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id WHERE CAST(substr(a.Frequency_Response_Hz, 1, instr(a.Frequency_Response_Hz, '-') - 1) AS REAL) <= 20   AND CAST(substr(a.Frequency_Response_Hz, instr(a.Frequency_Response_Hz, '-') + 1) AS REAL) >= 20000   AND h.Headphone_Id NOT IN (     SELECT Headphone_Id      FROM usage_records      WHERE Total_Harmonic_Distortion_Percent < 1.0 / Audio_Quality_Rating   );	earphone	2
SELECT Headphone_Id, Model, Price_Usd FROM headphones WHERE Water_Resistance = 'IPX7' AND Price_Usd < 100;	earphone	3
SELECT Headphone_Id, Model, Battery_Life_Hours, (Battery_Life_Hours / 100000) AS extreme_ratio FROM headphones WHERE (Battery_Life_Hours / 100000) > 0.1 ORDER BY extreme_ratio DESC;	earphone	4
SELECT h.Headphone_Id, h.Model, a.Sound_Pressure_Level_Db AS actual_spl, (a.Sensitivity_Db + 10 * LOG10(a.Max_Input_Power_Mw)) AS theoretical_spl  FROM headphones h  JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id  WHERE ABS((a.Sensitivity_Db + 10 * LOG10(a.Max_Input_Power_Mw)) - a.Sound_Pressure_Level_Db) > 10;	earphone	1
SELECT h.Headphone_Id, h.Model, SQRT(LOG10(CAST(substr(a.Frequency_Response_Hz, instr(a.Frequency_Response_Hz, '-') + 1) AS REAL) / CAST(substr(a.Frequency_Response_Hz, 1, instr(a.Frequency_Response_Hz, '-') - 1) AS REAL)) * a.Total_Harmonic_Distortion_Percent) AS G_mean FROM headphones h JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id ORDER BY G_mean DESC LIMIT 5;	earphone	2
SELECT h.Headphone_Id, h.Model, h.Battery_Life_Hours, h.Weight_Grams, (h.Battery_Life_Hours * 1.0 / h.Weight_Grams) AS battery_weight_ratio  FROM headphones h  JOIN audio_data a ON h.Headphone_Id = a.Headphone_Id  WHERE h.Noise_Cancellation = 1  AND h.Is_Wireless = 1  AND a.Audio_Codec = 'SBC'  AND (h.Battery_Life_Hours * 1.0 / h.Weight_Grams) < 0.5;	earphone	3
SELECT h.Headphone_Id, h.Model, (h.Sensitivity_Db + 10 * LOG10(100000000)) AS theoretical_spl FROM headphones h ORDER BY theoretical_spl DESC LIMIT 3;	earphone	4
SELECT m.Manufacturer_Id, m.Manufacturer_Name,         SUM(CASE WHEN h.Price_Usd > 500 THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS high_end_ratio,         CAST(m.Profit_Usd AS REAL) / m.Employees AS profit_per_employee  FROM manufacturers m  JOIN headphones h ON m.Manufacturer_Id = h.Manufacturer_Id  GROUP BY m.Manufacturer_Id, m.Manufacturer_Name, m.Profit_Usd, m.Employees;	earphone	1
SELECT m.Manufacturer_Id, m.Manufacturer_Name, SQRT(m.Market_Share_Percent * AVG(h.Price_Usd)) AS composite_index  FROM manufacturers m  JOIN headphones h ON m.Manufacturer_Id = h.Manufacturer_Id  GROUP BY m.Manufacturer_Id, m.Manufacturer_Name, m.Market_Share_Percent  ORDER BY composite_index DESC;	earphone	2
SELECT m.Manufacturer_Id, m.Manufacturer_Name, m.Founded_Year, m.Market_Share_Percent, AVG(h.Price_Usd) AS avg_price FROM manufacturers m JOIN headphones h ON m.Manufacturer_Id = h.Manufacturer_Id WHERE m.Founded_Year < 1993 GROUP BY m.Manufacturer_Id, m.Manufacturer_Name, m.Founded_Year, m.Market_Share_Percent HAVING m.Market_Share_Percent < (AVG(h.Price_Usd) / 100);	earphone	3
SELECT m.Manufacturer_Id, m.Manufacturer_Name, m.Employees, (1000000000000.0 / NULLIF(m.Employees, 0)) AS theoretical_output_per_employee FROM manufacturers m WHERE m.Employees > 100000000 ORDER BY theoretical_output_per_employee ASC;	earphone	4
SELECT h.Model, AVG(ABS((u.Usage_Duration_Minutes / 60.0 / h.Battery_Life_Hours) * 100 - u.Battery_Consumed_Percent)) AS deviation FROM usage_records u JOIN headphones h ON u.Headphone_Id = h.Headphone_Id GROUP BY h.Model;	earphone	1
SELECT u.User_Id, (POWER(u.Volume_Level_Percent, 2) * u.Usage_Duration_Minutes) / h.Impedance_Ohms AS energy_index  FROM usage_records u  JOIN headphones h ON u.Headphone_Id = h.Headphone_Id  ORDER BY energy_index DESC  LIMIT 10;	earphone	2
SELECT h.Headphone_Id, h.Model, h.Battery_Life_Hours, (h.Battery_Life_Hours / (AVG(u.Battery_Consumed_Percent) / 100)) AS actual_efficiency  FROM headphones h  JOIN usage_records u ON h.Headphone_Id = u.Headphone_Id  WHERE h.Is_Wireless = 1  GROUP BY h.Headphone_Id, h.Model, h.Battery_Life_Hours  HAVING actual_efficiency < 0.8 * h.Battery_Life_Hours;	earphone	3
SELECT u.Record_Id, u.Headphone_Id, u.Volume_Level_Percent, u.Battery_Consumed_Percent, (u.Battery_Consumed_Percent * POWER(10000.0 / NULLIF(u.Volume_Level_Percent, 0), 3)) AS theoretical_consumption FROM usage_records u ORDER BY theoretical_consumption DESC;	earphone	4
SELECT (Sales * 1000000000 / 1) * 2.5 AS Total_Carbon_Emission FROM company WHERE Sales = 100 AND Net_Profit_Margin = 10;	gas	1
SELECT (5000 - (3000 / (1 + 1))) AS New_Equity_Needed;	gas	2
WITH CurrentData AS (         SELECT Sales, Number_Employees, Revenue_Growth_Rate          FROM company          WHERE Revenue_Growth_Rate = 5 AND Net_Profit_Margin = 8 AND Number_Employees = 100000     )     SELECT ((Sales * POWER(1 + 0.10, 5) - Sales) / 1000000) - Number_Employees AS Additional_Employees_Needed      FROM CurrentData;	gas	3
WITH CompanyData AS (         SELECT Sales, Net_Profit_Margin          FROM company          WHERE Sales = 1000 AND Net_Profit_Margin = 50     )      SELECT ((Sales * Net_Profit_Margin / 100) / 100) / ((1000000000000 * 2.5 / 1000000) / 100) AS Years_Offset      FROM CompanyData;	gas	4
WITH GasData AS (SELECT Stock_Liters, Carbon_Emission FROM gas WHERE Stock_Liters = 1000000000 AND Carbon_Emission = 2.5) SELECT (Stock_Liters * Carbon_Emission * 44 / 12) / 1000000 AS Total_CO2_Tons FROM GasData;	gas	1
WITH CurrentData AS (     SELECT Sales, Number_Employees, Revenue_Growth_Rate, Net_Profit_Margin      FROM company      WHERE Revenue_Growth_Rate = 8 AND Net_Profit_Margin = 12 AND Number_Employees = 50000 )  SELECT ((Sales * POWER(1 + Revenue_Growth_Rate / 100, 3) * (15 / 100)) / Number_Employees) - 800000 AS Required_Sales_Increase_Per_Employee  FROM CurrentData;	gas	2
WITH GasData AS (         SELECT Minimum_Stock_Liters, Capacity_Liters          FROM gas_station, gas          WHERE Minimum_Stock_Liters = 1000000 AND Capacity_Liters = 5000000     )      SELECT CASE          WHEN (100000 * 30) > Capacity_Liters          THEN (100000 * 30) - Capacity_Liters          ELSE 0      END AS Additional_Capacity_Needed      FROM GasData;	gas	3
WITH CompanyData AS (     SELECT Market_Value, Net_Profit_Margin      FROM company      WHERE Market_Value = 10000 AND Net_Profit_Margin = 20 )  SELECT ((Market_Value * Net_Profit_Margin / 100) / 2000) * 31.1035 / 19.32 / 1000000 / 2500 AS Olympic_Pools_Filled  FROM CompanyData;	gas	4
WITH GasData AS (SELECT Stock_Liters FROM gas WHERE Stock_Liters = 500000000) SELECT (Stock_Liters * 35) / 1000000 AS Total_Energy_Petajoules FROM GasData;	gas	1
WITH CurrentData AS (     SELECT Sales, Number_Employees, Net_Profit_Margin      FROM company      WHERE Sales = 800 AND Net_Profit_Margin = 15 AND Number_Employees = 200000 )  SELECT ((1200 * 1000000000 * 0.18) / Number_Employees) - 400000 AS Required_Sales_Increase_Per_Employee  FROM CurrentData;	gas	2
WITH GasData AS (     SELECT Minimum_Stock_Liters, Capacity_Liters      FROM gas_station, gas      WHERE Minimum_Stock_Liters = 2000000 AND Capacity_Liters = 10000000 )  SELECT CASE      WHEN (150000 * 60) > Capacity_Liters      THEN (150000 * 60) - Capacity_Liters      ELSE 0      END AS Additional_Capacity_Needed  FROM GasData;	gas	3
WITH CompanyData AS (     SELECT Market_Value, Net_Profit_Margin      FROM company      WHERE Market_Value = 50000 AND Net_Profit_Margin = 25 )  SELECT ((Market_Value * Net_Profit_Margin / 100) / 5000) * 0.2 / 3.52 / 1000000 / (7140 * 1) AS Football_Fields_Filled  FROM CompanyData;	gas	4
WITH CompanyData AS (SELECT Sales FROM company WHERE Sales = 500) SELECT (Sales * 1000000000 / 1) * 2.5 / 1000000 AS Total_Carbon_Emission_Tons FROM CompanyData;	gas	1
SELECT (Net_Profit_Margin / 100.0) * Sales AS Net_Profit, ((Net_Profit_Margin / 100.0) * Sales) / Number_Employees AS Net_Profit_Per_Employee FROM company WHERE Sales = 50 AND Net_Profit_Margin = 15 AND Number_Employees = 100000;	gas	2
SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales, (Sales * (1 + Revenue_Growth_Rate / 100)) * (Net_Profit_Margin / 100) AS Projected_Net_Profit FROM company WHERE Sales = 30 AND Revenue_Growth_Rate = 5 AND Net_Profit_Margin = 10;	gas	3
SELECT Sales / Number_Employees AS Average_Sales_Per_Employee, Profits / Number_Employees AS Average_Profit_Per_Employee, Sales / Number_Branches AS Average_Sales_Per_Branch, Profits / Number_Branches AS Average_Profit_Per_Branch FROM company WHERE Sales = 1000 AND Profits = 500 AND Number_Employees = 10000000 AND Number_Branches = 100000;	gas	4
SELECT (10000000 * 1000000) / Carbon_Emission AS Total_Fuel_Sold_Liters FROM gas WHERE Carbon_Emission = 2.5;	gas	1
WITH Current_Data AS (         SELECT Sales, (Net_Profit_Margin / 100) * Sales AS Current_Net_Profit, Debt_Equity_Ratio          FROM company          WHERE Sales = 80 AND Net_Profit_Margin = 12 AND Debt_Equity_Ratio = 0.8     ),      Target_Net_Profit AS (         SELECT Current_Net_Profit * 1.2 AS Target_Net_Profit          FROM Current_Data     )      SELECT (Target_Net_Profit / (Net_Profit_Margin / 100)) - Sales AS Required_Sales_Increase      FROM company, Target_Net_Profit      WHERE Sales = 80 AND Net_Profit_Margin = 12;	gas	2
SELECT 'Current Revenue Growth Rate: 8%' AS Current_Growth_Rate, 'Required Annual Growth Rate: ~26%' AS Required_Growth_Rate FROM company WHERE Sales = 40 AND Revenue_Growth_Rate = 8;	gas	3
SELECT Sales / Number_Employees AS Average_Sales_Per_Employee, Profits / Number_Employees AS Average_Profit_Per_Employee, Sales / Number_Branches AS Average_Sales_Per_Branch, Profits / Number_Branches AS Average_Profit_Per_Branch FROM company WHERE Sales = 10000 AND Profits = 5000 AND Number_Employees = 100000000 AND Number_Branches = 1000000;	gas	4
SELECT (Stock_Liters * Carbon_Emission * 0.20) / Carbon_Emission AS Required_Reduction_Liters FROM gas WHERE Stock_Liters = 5000000 AND Carbon_Emission = 2.8;	gas	1
SELECT ((Market_Value * 2 * (Profits / Market_Value)) / Profits) * Number_Employees - Number_Employees AS Required_Employee_Increase FROM company WHERE Market_Value = 300 AND Profits = 45 AND Number_Employees = 150000;	gas	2
SELECT 'Current Revenue Growth Rate: 6%' AS Current_Growth_Rate, 'Required Annual Growth Rate: ~22.47%' AS Required_Growth_Rate FROM company WHERE Sales = 60 AND Revenue_Growth_Rate = 6;	gas	3
SELECT Sales / Number_Employees AS Average_Sales_Per_Employee, Profits / Number_Employees AS Average_Profit_Per_Employee, Sales / Number_Branches AS Average_Sales_Per_Branch, Profits / Number_Branches AS Average_Profit_Per_Branch FROM company WHERE Sales = 1000000 AND Profits = 500000 AND Number_Employees = 1000000000 AND Number_Branches = 100000000;	gas	4
SELECT Stock_Liters * (Sulfur_Content - 30) * 1e-6 AS Required_Sulfur_Reduction FROM gas WHERE Stock_Liters = 10000000 AND Sulfur_Content = 50;	gas	1
WITH Current_Equity AS (     SELECT Assets / (1 + Debt_Equity_Ratio) AS Current_Equity      FROM company      WHERE Assets = 2000 AND Debt_Equity_Ratio = 1.5 ),  Target_Assets AS (     SELECT Assets * 1.5 AS Target_Assets      FROM company      WHERE Assets = 2000 ),  Target_Equity AS (     SELECT Target_Assets / (1 + 1.2) AS Target_Equity      FROM Target_Assets )  SELECT Target_Equity - Current_Equity AS Required_Equity_Increase  FROM Current_Equity, Target_Equity;	gas	2
SELECT 'Current Revenue Growth Rate: 4%' AS Current_Growth_Rate, 'Required Annual Growth Rate: ~9.86%' AS Required_Growth_Rate FROM company WHERE Sales = 50 AND Revenue_Growth_Rate = 4;	gas	3
SELECT Sales / Number_Employees AS Average_Sales_Per_Employee, Profits / Number_Employees AS Average_Profit_Per_Employee, Sales / Number_Branches AS Average_Sales_Per_Branch, Profits / Number_Branches AS Average_Profit_Per_Branch FROM company WHERE Sales = 100000000 AND Profits = 50000000 AND Number_Employees = 10000000000 AND Number_Branches = 1000000000;	gas	4
SELECT (Stock_Liters * Carbon_Emission * 0.15) / Carbon_Emission AS Required_Reduction_Liters FROM gas WHERE Stock_Liters = 8000000 AND Carbon_Emission = 3.2;	gas	1
SELECT ((Market_Value * 2 * (Profits / Market_Value)) / Profits) * Number_Employees - Number_Employees AS Required_Employee_Increase FROM company WHERE Market_Value = 2500 AND Profits = 400 AND Number_Employees = 120000;	gas	2
SELECT 'Current Revenue Growth Rate: 5%' AS Current_Growth_Rate, 'Required Annual Growth Rate: ~12.66%' AS Required_Growth_Rate FROM company WHERE Sales = 70 AND Revenue_Growth_Rate = 5;	gas	3
SELECT Sales / Number_Employees AS Average_Sales_Per_Employee, Profits / Number_Employees AS Average_Profit_Per_Employee, Sales / Number_Branches AS Average_Sales_Per_Branch, Profits / Number_Branches AS Average_Profit_Per_Branch FROM company WHERE Sales = 10000000000 AND Profits = 5000000000 AND Number_Employees = 100000000000 AND Number_Branches = 10000000000;	gas	4
SELECT (Stock_Liters * Carbon_Emission * 0.25) / Carbon_Emission AS Required_Reduction_Liters FROM gas WHERE Stock_Liters = 12000000 AND Carbon_Emission = 2.7;	gas	1
WITH Current_Equity AS (     SELECT Assets / (1 + Debt_Equity_Ratio) AS Current_Equity      FROM company      WHERE Assets = 3000 AND Debt_Equity_Ratio = 1.8 ),  Target_Assets AS (     SELECT 4500 AS Target_Assets ),  Target_Equity AS (     SELECT Target_Assets / (1 + 1.5) AS Target_Equity      FROM Target_Assets )  SELECT Target_Equity - Current_Equity AS Required_Equity_Increase  FROM Current_Equity, Target_Equity;	gas	2
SELECT 'Current Revenue Growth Rate: 7%' AS Current_Growth_Rate, 'Required Annual Growth Rate: ~7.46%' AS Required_Growth_Rate FROM company WHERE Sales = 90 AND Revenue_Growth_Rate = 7;	gas	3
SELECT Sales / Number_Employees AS Average_Sales_Per_Employee,         Profits / Number_Employees AS Average_Profit_Per_Employee,         Sales / Number_Branches AS Average_Sales_Per_Branch,         Profits / Number_Branches AS Average_Profit_Per_Branch  FROM company  WHERE Sales = 100000000000 AND Profits = 50000000000 AND Number_Employees = 1000000000000 AND Number_Branches = 100000000000;	gas	4
SELECT CEIL((Stock_Liters * Density) / (Vehicle_Capacity - (Distance / 100 * Fuel_Consumption * Density))) AS Required_Vehicles FROM (SELECT 30000000 AS Stock_Liters, 0.85 AS Density, 1000 AS Distance, 30 AS Fuel_Consumption, 20000 AS Vehicle_Capacity) AS data;	gas	1
SELECT (Target_Profits / (Profits / Sales)) AS Target_Sales FROM (SELECT 1200 AS Sales, 180 AS Profits, 360 AS Target_Profits) AS data;	gas	2
SELECT 'Current Revenue Growth Rate: 4%' AS Current_Growth_Rate, 'Required Annual Growth Rate: ~12.66%' AS Required_Growth_Rate FROM company WHERE Sales = 70 AND Revenue_Growth_Rate = 4;	gas	3
SELECT Number_Employees * 1000000 AS Total_Severance_Cost, (Market_Value / 0.05) * 5000 AS Total_Carbon_Emission FROM company WHERE Market_Value = 100000000000000 AND Number_Employees = 10000000;	gas	4
SELECT Daily_Sales * Energy_Per_Liter AS Total_Energy_Release FROM (SELECT 50000 AS Daily_Sales, 35 AS Energy_Per_Liter) AS data;	gas	1
SELECT Sales * (Net_Profit_Margin / 100.0) AS Net_Profit, (Sales * (Net_Profit_Margin / 100.0)) * 0.25 AS Reinvestment_Amount FROM company WHERE Sales = 75 AND Net_Profit_Margin = 8;	gas	2
SELECT 'Current Revenue Growth Rate: 5%' AS Current_Growth_Rate, 'Required Annual Growth Rate: ~6.67%' AS Required_Growth_Rate FROM company WHERE Revenue_Growth_Rate = 5;	gas	3
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission, Stock_Liters * Carbon_Emission * 100 AS Global_Carbon_Emission FROM gas WHERE Stock_Liters = 1000000000 AND Carbon_Emission = 100;	gas	4
SELECT Annual_Carbon_Emission * Years * Trees_Per_Ton AS Total_Trees_Needed FROM (SELECT 10000000 AS Annual_Carbon_Emission, 5 AS Years, 100 AS Trees_Per_Ton);	gas	1
WITH Future_Sales AS (     SELECT Sales * 1.20 AS Future_Sales      FROM company      WHERE Sales = 5000 ),  Future_Profits AS (     SELECT Future_Sales * 0.15 AS Future_Profits      FROM Future_Sales ),  Current_Equity AS (     SELECT Assets / (1 + Debt_Equity_Ratio) AS Current_Equity      FROM company      WHERE Assets = 20000 AND Debt_Equity_Ratio = 1.2 ),  Future_Equity AS (     SELECT Current_Equity + Future_Profits AS Future_Equity      FROM Current_Equity, Future_Profits )  SELECT Future_Equity, 2 * Future_Equity AS Future_Assets  FROM Future_Equity;	gas	2
SELECT Number_Branches * 10 AS Additional_Employees FROM company WHERE Number_Employees = 100000 AND Number_Branches = 500;	gas	3
SELECT (Market_Value * (Net_Profit_Margin / 100)) / Competitor_Market_Value AS Competitors_Acquired FROM (SELECT 10000000000000 AS Market_Value, 50 AS Net_Profit_Margin, 500000000000 AS Competitor_Market_Value) AS data;	gas	4
SELECT (50000 * 85) / 1000 AS Total_CO2_Kilograms FROM gas WHERE Carbon_Emission = 85;	gas	1
SELECT (100000 * (1.5 + 0.3)) * (1 - 0.15) AS Net_Profit FROM gas WHERE Stock_Liters = 100000;	gas	2
SELECT CASE WHEN (15000 - 10000) / 2000 < 5 THEN '会触发预警' ELSE '不会触发预警' END AS Inventory_Warning FROM gas WHERE Stock_Liters = 15000 AND Minimum_Stock_Liters = 10000;	gas	3
SELECT (10000000 * 1000) / 1000 AS CO2_Emission_Kilograms, (10000000 * 1000) / 1000 * (SELECT COUNT(*) FROM gas) AS Global_CO2_Emission_Kilograms FROM gas WHERE Stock_Liters = 10000000 AND Carbon_Emission = 1000;	gas	4
SELECT (20000 * 50 * 64.07 / 32.06 / 1000000) AS SO2_Mass_Kilograms FROM gas WHERE Stock_Liters = 20000 AND Sulfur_Content = 50;	gas	1
SELECT (80000 * (2.0 + 0.5)) * (1 - 0.12) AS Net_Profit, (80000 * (2.0 + 0.5)) * (1 - 0.12) * 0.3 AS Environmental_Investment FROM gas WHERE Stock_Liters = 80000;	gas	2
SELECT CASE WHEN (8000 - 5000) / 1500 < 3 THEN '会触发预警，提前' || (3 - (8000 - 5000) / 1500) || '天' ELSE '不会触发预警' END AS Inventory_Warning FROM gas WHERE Stock_Liters = 8000 AND Minimum_Stock_Liters = 5000;	gas	3
SELECT (100000000 * 500) / 1000 AS CO2_Emission_Kilograms, (1000000000000 * 500) / 1000 AS Global_CO2_Emission_Kilograms FROM gas WHERE Stock_Liters = 100000000 AND Carbon_Emission = 500;	gas	4
SELECT SUM(Stock_Liters * 34.2) AS Total_Energy_MJ FROM gas WHERE Brand = 'Shell';	gas	1
SELECT SUM(Stock_Liters * 0.5) AS Total_Tax_Revenue FROM gas WHERE Brand = 'BP' AND Fuel_Type = '柴油';	gas	2
SELECT CASE WHEN Stock_Liters < Minimum_Stock_Liters THEN '需要紧急补货' ELSE '无需补货' END AS Replenishment_Status FROM gas WHERE Supplier = 'ExxonMobil';	gas	3
SELECT SUM(1000000 * 2.5) AS Total_Carbon_Emission FROM gas WHERE Supplier = 'Chevron';	gas	4
SELECT SUM((Stock_Liters * 24 * 0.2778) / 0.2) AS Total_Distance_km FROM gas WHERE Brand = 'Total' AND Fuel_Type = '液化天然气';	gas	1
SELECT SUM(Stock_Liters * 0.5 * 0.3) AS Environmental_Fund FROM gas WHERE Brand = 'BP' AND Fuel_Type = '柴油';	gas	2
SELECT CASE WHEN Stock_Liters < Minimum_Stock_Liters THEN '需要紧急补货' ELSE '无需补货' END AS Replenishment_Status, (7 * 500) + (Minimum_Stock_Liters - Stock_Liters) AS Replenishment_Volume FROM gas WHERE Supplier = 'ExxonMobil';	gas	3
SELECT (5000000 * 3) / 1000000000.0 AS Total_Carbon_Emission_Tonnes FROM gas WHERE Supplier = 'BP';	gas	4
SELECT SUM(g.Stock_Liters) * 2.68 AS Total_Carbon_Emission_kg  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'Shell' AND g.Fuel_Type = '柴油';	gas	1
SELECT gs.Station_ID, gs.Location, g.Stock_Liters / gs.Capacity_Liters AS Stock_Capacity_Ratio  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'ExxonMobil' AND g.Stock_Liters > gs.Capacity_Liters;	gas	2
SELECT gs.Station_ID, gs.Location FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID WHERE sc.Company_ID = '指定公司ID' AND g.Stock_Liters < g.Minimum_Stock_Liters;	gas	3
SELECT COUNT(*) * 10000000 * 0.85 AS Total_Weight_kg, CASE WHEN COUNT(*) * 10000000 * 0.85 > COUNT(*) * 10000000 * 1 THEN '超过承重能力' ELSE '未超过承重能力' END AS Weight_Status FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters * g.Sulfur_Content) / 1000000 AS Total_Sulfur_Content_kg  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  WHERE g.Brand = 'Shell' AND g.Quality_Grade = '高级';	gas	1
SELECT AVG(g.Price_Liter) AS Avg_Price_Per_Liter, AVG(g.Price_Liter) - 1.5 AS Price_Difference  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'BP';	gas	2
SELECT gs.Station_ID, gs.Location, g.Last_Delivery_Date, g.Next_Delivery_Date  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'ExxonMobil' AND g.Next_Delivery_Date < g.Last_Delivery_Date;	gas	3
SELECT SUM(g.Stock_Liters - 1) * 2.31 AS Carbon_Emission_Reduction_kg FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters) * 35.8 AS Total_Energy_Density_MJ FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID WHERE g.Brand = 'Shell' AND g.Fuel_Type = '柴油';	gas	1
SELECT SUM(g.Stock_Liters) / (SUM(g.Stock_Liters) * 1.2) AS Stock_Sales_Ratio FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'BP';	gas	2
SELECT g.Supplier, SUM(g.Stock_Liters) / (SELECT SUM(g2.Stock_Liters) FROM gas g2 JOIN gas_station gs2 ON g2.Station_ID = gs2.Station_ID JOIN station_company sc2 ON gs2.Station_ID = sc2.Station_ID JOIN company c2 ON sc2.Company_ID = c2.Company_ID WHERE c2.Company = 'ExxonMobil') * 100 AS Stock_Percentage FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'ExxonMobil' GROUP BY g.Supplier;	gas	3
SELECT SUM(g.Stock_Liters - 0.1) * 2.31 AS Carbon_Emission_Reduction_kg FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters) * 0.8 AS Total_VOC_Emission_g  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  WHERE g.Brand = 'Shell' AND g.Fuel_Type = '汽油';	gas	1
SELECT SUM(g.Stock_Liters) / (SUM(g.Stock_Liters) * 0.3) AS Stock_Profit_Ratio FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'ExxonMobil';	gas	2
SELECT COUNT(*) AS High_Frequency_Stations FROM (     SELECT gs.Station_ID     FROM gas g     JOIN gas_station gs ON g.Station_ID = gs.Station_ID     JOIN station_company sc ON gs.Station_ID = sc.Station_ID     JOIN company c ON sc.Company_ID = c.Company_ID     WHERE c.Company = 'BP'     GROUP BY gs.Station_ID     HAVING COUNT(g.Last_Delivery_Date) / (CAST(strftime('%Y', MAX(g.Last_Delivery_Date)) AS INTEGER) - CAST(strftime('%Y', MIN(g.Last_Delivery_Date)) AS INTEGER) + 1) > 12 );	gas	3
SELECT COUNT(*) * 1000000000 * 0.85 AS Total_Weight_Increase_kg FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters) * 0.25 * 0.45 AS Total_Cooling_Energy_MJ  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  WHERE g.Brand = 'Shell' AND g.Fuel_Type = '液化天然气';	gas	1
SELECT SUM(g.Stock_Liters) / (SUM(g.Stock_Liters) * 1.8) AS Stock_Market_Value_Ratio FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'BP';	gas	2
SELECT COUNT(*) AS Low_Frequency_Stations FROM (     SELECT gs.Station_ID     FROM gas g     JOIN gas_station gs ON g.Station_ID = gs.Station_ID     JOIN station_company sc ON gs.Station_ID = sc.Station_ID     JOIN company c ON sc.Company_ID = c.Company_ID     WHERE c.Company = 'ExxonMobil'     GROUP BY gs.Station_ID     HAVING COUNT(g.Last_Delivery_Date) / (CAST(strftime('%Y', MAX(g.Last_Delivery_Date)) AS INTEGER) - CAST(strftime('%Y', MIN(g.Last_Delivery_Date)) AS INTEGER) + 1) < 6 );	gas	3
SELECT SUM(g.Stock_Liters - 0.01) * 2.31 AS Carbon_Emission_Reduction_kg FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters * g.Sulfur_Content) * 2 / 1000000 AS Total_SOx_Emission_g FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID WHERE g.Brand = 'Shell' AND g.Fuel_Type = '柴油';	gas	1
SELECT SUM(g.Stock_Liters) / (SUM(g.Stock_Liters) * 0.7) AS Stock_Asset_Ratio  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'ExxonMobil';	gas	2
SELECT COUNT(DISTINCT gs.Station_ID) AS Weekend_Delivery_Stations  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'BP'  AND (strftime('%w', g.Last_Delivery_Date) = '0' OR strftime('%w', g.Last_Delivery_Date) = '6');	gas	3
SELECT COUNT(*) * 10000000000 * 0.85 AS Total_Weight_Increase_kg FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters) * 0.05 AS Total_NOx_Emission_g  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  WHERE g.Brand = 'Shell' AND g.Fuel_Type = '汽油';	gas	1
SELECT SUM(g.Stock_Liters) / (SUM(g.Stock_Liters) * 0.001) AS Stock_Employee_Ratio FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'BP';	gas	2
SELECT COUNT(DISTINCT gs.Station_ID) AS Holiday_Delivery_Stations  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'ExxonMobil'  AND g.Last_Delivery_Date IN ('2023-01-01', '2023-07-04', '2023-12-25');	gas	3
SELECT SUM(g.Stock_Liters - 0.001) * 2.31 AS Carbon_Emission_Reduction_kg FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters) * 0.25 * 0.45 * 5 / 100 AS Total_Cooling_Loss_MJ FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID WHERE g.Brand = 'Shell' AND g.Fuel_Type = '液化天然气';	gas	1
SELECT SUM(g.Stock_Liters) / (SUM(g.Stock_Liters) * 0.0001) AS Stock_Branch_Ratio FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'ExxonMobil';	gas	2
SELECT COUNT(DISTINCT gs.Station_ID) AS Weekday_Delivery_Stations FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'BP' AND strftime('%w', g.Last_Delivery_Date) BETWEEN '1' AND '5';	gas	3
SELECT COUNT(*) * 100000000000 * 0.85 AS Total_Weight_Increase_kg  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'Chevron';	gas	4
SELECT SUM(g.Stock_Liters) * 0.02 AS Total_PM_Emission_g FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID WHERE g.Brand = 'Shell' AND g.Fuel_Type = '柴油';	gas	1
SELECT SUM(g.Stock_Liters) / (SUM(g.Stock_Liters) * 0.005) AS Stock_Revenue_Growth_Ratio FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'BP';	gas	2
SELECT COUNT(DISTINCT gs.Station_ID) AS Quarter_End_Delivery_Stations  FROM gas g  JOIN gas_station gs ON g.Station_ID = gs.Station_ID  JOIN station_company sc ON gs.Station_ID = sc.Station_ID  JOIN company c ON sc.Company_ID = c.Company_ID  WHERE c.Company = 'ExxonMobil'  AND strftime('%m', g.Last_Delivery_Date) IN ('03', '06', '09', '12');	gas	3
SELECT SUM(g.Stock_Liters - 0.0001) * 2.31 AS Carbon_Emission_Reduction_kg FROM gas g JOIN gas_station gs ON g.Station_ID = gs.Station_ID JOIN station_company sc ON gs.Station_ID = sc.Station_ID JOIN company c ON sc.Company_ID = c.Company_ID WHERE c.Company = 'Chevron';	gas	4
SELECT g.GeneratorID, g.GeneratorName, g.RatedPower, s.SensorID, s.SensorType, sd.DataValue AS StartTemp, sd2.DataValue AS EndTemp, (sd2.DataValue - sd.DataValue) AS DeltaT FROM generators g JOIN sensors s ON g.GeneratorID = s.GeneratorID JOIN sensordata sd ON s.SensorID = sd.SensorID JOIN sensordata sd2 ON s.SensorID = sd2.SensorID WHERE s.SensorType = '温度传感器' AND g.RatedPower = 500 AND sd.DataValue = 20 AND sd2.DataValue = 80;	generators	1
SELECT g.GeneratorID, g.GeneratorName, g.RatedPower, ps.TotalCapacity, (g.RatedPower / ps.TotalCapacity) * 100 AS LoadRate, CASE WHEN (SELECT SUM(g2.RatedPower) FROM generators g2 JOIN generatorstationassociation gsa2 ON g2.GeneratorID = gsa2.GeneratorID WHERE gsa2.StationID = ps.StationID) <= ps.TotalCapacity THEN '足够' ELSE '不足' END AS CapacityStatus FROM generators g JOIN generatorstationassociation gsa ON g.GeneratorID = gsa.GeneratorID JOIN powerstations ps ON gsa.StationID = ps.StationID WHERE ps.TotalCapacity = 1000 AND g.RatedPower IN (200, 300, 150, 250, 100);	generators	2
SELECT g.GeneratorID, g.GeneratorName, g.RatedPower, g.ContinualTime, (g.RatedPower * g.ContinualTime) AS TotalEnergy FROM generators g WHERE g.ContinualTime = 100 AND g.RatedPower = 500;	generators	3
SELECT g.GeneratorID, g.GeneratorName, g.RatedPower, s.SensorID, s.SensorType, sd.DataValue AS StartTemp, sd2.DataValue AS EndTemp, (sd2.DataValue - sd.DataValue) AS DeltaT, '极端温度变化可能导致材料失效' AS MaterialImpactWarning  FROM generators g  JOIN sensors s ON g.GeneratorID = s.GeneratorID  JOIN sensordata sd ON s.SensorID = sd.SensorID  JOIN sensordata sd2 ON s.SensorID = sd2.SensorID  WHERE s.SensorType = '温度传感器'  AND g.RatedPower = 10000  AND sd.DataValue = -273.15  AND sd2.DataValue = 1000;	generators	4
SELECT g.GeneratorID, g.GeneratorName, g.RatedPower, s.SensorID, s.SensorType, sd.DataValue AS FlowRate, (1000 * 9.81 * sd.DataValue * g.Flux) AS HydraulicPower, ((1000 * 9.81 * sd.DataValue * g.Flux) / g.RatedPower) * 100 AS Efficiency  FROM generators g  JOIN sensors s ON g.GeneratorID = s.GeneratorID  JOIN sensordata sd ON s.SensorID = sd.SensorID  WHERE s.SensorType = '流量传感器' AND sd.DataValue = 50 AND g.RatedPower = 500;	generators	1
SELECT RatedPower / RatedVoltage AS RatedCurrent FROM generators WHERE RatedPower = 500 AND RatedVoltage = 10;	generators	1
SELECT SUM(RatedPower) * 1 AS TotalPowerGenerated FROM generators WHERE GeneratorID IN (SELECT GeneratorID FROM generatorstationassociation WHERE StationID = (SELECT StationID FROM powerstations WHERE TotalCapacity = 1000));	generators	2
SELECT CASE WHEN Status = 2 THEN '不能正常发电' ELSE '能正常发电' END AS GeneratorStatus FROM generators WHERE Status = 2;	generators	3
SELECT Maxpower * (100000 / RatedRotationSpeed) * (1000000 / Flux) AS NewMaxPower FROM generators WHERE Maxpower = 1000 AND RatedRotationSpeed = 3000 AND Flux = 1000;	generators	4
SELECT TotalCapacity * 0.9 * 1 AS ActualOutputEnergy FROM powerstations WHERE StationName = '西江';	generators	1
SELECT SUM(PowerGenerated) AS TotalPowerGenerated FROM operationrecords WHERE GeneratorID IN (SELECT GeneratorID FROM generatorstationassociation WHERE StationID = (SELECT StationID FROM powerstations WHERE StationName = '西江')) AND StartTime >= '2023-10-01 00:00:00' AND EndTime <= '2023-10-01 23:59:59';	generators	2
SELECT CASE WHEN DataValue > 100 THEN '异常' ELSE '正常' END AS Status FROM sensordata WHERE SensorID IN (SELECT SensorID FROM sensors WHERE SensorType = '温度传感器' AND GeneratorID = (SELECT GeneratorID FROM generators WHERE GeneratorName = '某发电机名称')) AND DataValue = 200;	generators	3
SELECT SUM(Maxpower) AS TotalOutputPower FROM generators WHERE GeneratorID IN (SELECT GeneratorID FROM generatorstationassociation WHERE StationID = (SELECT StationID FROM powerstations WHERE StationName = '西江'));	generators	4
SELECT (ps.TotalCapacity * 0.85) / AVG(g.RatedVoltage) AS TotalCurrent FROM powerstations ps JOIN generatorstationassociation gsa ON ps.StationID = gsa.StationID JOIN generators g ON gsa.GeneratorID = g.GeneratorID WHERE ps.StationID = 1;	generators	1
SELECT SUM(RatedPower) AS TotalRunningPower FROM generators WHERE Status = 1;	generators	2
SELECT CASE WHEN sd.DataValue > 10 THEN '异常' ELSE '正常' END AS Status FROM sensordata sd JOIN sensors s ON sd.SensorID = s.SensorID WHERE s.SensorType = '压力传感器' AND sd.DataValue = 50;	generators	3
SELECT SUM(Maxpower) AS TotalOutputPower FROM generators WHERE GeneratorID IN (SELECT GeneratorID FROM generatorstationassociation WHERE StationID = 1);	generators	4
SELECT 0.5 * 10 * POWER((RatedRotationSpeed * 2 * PI() / 60), 2) AS KineticEnergy FROM generators WHERE GeneratorID = 1;	generators	1
SELECT RatedPower * ContinualTime * 0.95 AS TotalPowerGenerated FROM generators WHERE GeneratorID = 1;	generators	2
SELECT CASE WHEN (strftime('%Y', 'now') - strftime('%Y', ManufactureDate)) > 30 THEN '超过设计寿命' ELSE '未超过设计寿命' END AS DesignLifeStatus FROM generators WHERE GeneratorID = 1;	generators	3
SELECT Maxpower * POWER(100000.0 / RatedRotationSpeed, 3) * (1000000.0 / Flux) AS HypotheticalMaxPower FROM generators WHERE GeneratorID = 1;	generators	4
SELECT DataValue - (DataValue * 0.02) AS MinTemperature, DataValue + (DataValue * 0.02) AS MaxTemperature FROM sensordata WHERE SensorID = (SELECT SensorID FROM sensors WHERE SensorType = '温度传感器' AND DataValue = 150);	generators	1
SELECT DataValue * 0.01 AS MeasurementError FROM sensordata WHERE SensorID = (SELECT SensorID FROM sensors WHERE SensorType = '压力传感器' AND DataValue = 50);	generators	2
SELECT CASE WHEN DataValue > 100 THEN '异常' ELSE '正常' END AS Status FROM sensordata WHERE SensorID = (SELECT SensorID FROM sensors WHERE SensorType = '震动传感器' AND DataValue = 200);	generators	3
SELECT DataValue * 0.005 AS MeasurementError FROM sensordata WHERE SensorID = (SELECT SensorID FROM sensors WHERE SensorType = '流量传感器' AND DataValue = 1000000);	generators	4
SELECT (RatedPower / (Flux * 10 * 9.81 * 1000)) * 100 AS Efficiency FROM generators WHERE RatedPower = 500 AND RatedVoltage = 10 AND RatedRotationSpeed = 1500 AND Flux = 50;	generators	1
SELECT Maxpower * ContinualTime AS TotalEnergy FROM generators WHERE Maxpower = 1000 AND ContinualTime = 200;	generators	2
SELECT GeneratorID, GeneratorName, Status FROM generators WHERE Status = 2;	generators	3
SELECT SensorType, DataValue FROM sensordata JOIN sensors ON sensordata.SensorID = sensors.SensorID WHERE sensors.SensorType = '温度传感器' AND DataValue > 1000;	generators	4
SELECT Profit / PriceTurbo AS SalesQuantity FROM manufacturers WHERE Profit = 5000 AND PriceTurbo = 200;	generators	2
SELECT Id, ModelName, WeightGrams, (WeightGrams / 1000.0) * 9.8 * 1 AS Potential_Energy FROM TabletBasicInfo;	ipad	1
SELECT      tbi.Id,      tbi.ModelName,      tbi.WeightGrams,      strftime('%Y', tbi.ReleaseDate) AS Year,      SUM((tbi.WeightGrams / 1000.0) * 9.8 * 1) AS Total_Potential_Energy_Change  FROM TabletBasicInfo tbi  GROUP BY tbi.Id, tbi.ModelName, tbi.WeightGrams, strftime('%Y', tbi.ReleaseDate)  ORDER BY tbi.WeightGrams, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tbi.ModelName, tbi.WeightGrams, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.WeightGrams < (SELECT AVG(WeightGrams) FROM TabletBasicInfo) GROUP BY tbi.Id, tbi.ModelName, tbi.WeightGrams ORDER BY tbi.WeightGrams;	ipad	3
SELECT tbi.Id, tbi.ModelName, tbi.WeightGrams, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.WeightGrams = 100000 GROUP BY tbi.Id, tbi.ModelName, tbi.WeightGrams;	ipad	4
SELECT Id, ModelName, ScreenSizeInches, (ScreenSizeInches * ScreenSizeInches * 16 * 9) / (16 * 16 + 9 * 9) AS Screen_Area FROM TabletBasicInfo;	ipad	1
SELECT      tbi.Id,      tbi.ModelName,      tbi.ScreenSizeInches,      strftime('%Y', tbi.ReleaseDate) AS Year,      SUM((POWER(tbi.ScreenSizeInches, 2) * 16 * 9) / (POWER(16, 2) + POWER(9, 2))) AS Total_Screen_Area_Change  FROM TabletBasicInfo tbi  GROUP BY tbi.Id, tbi.ModelName, tbi.ScreenSizeInches, strftime('%Y', tbi.ReleaseDate)  ORDER BY tbi.ScreenSizeInches, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tbi.ModelName, tbi.ScreenSizeInches, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ScreenSizeInches > (SELECT AVG(ScreenSizeInches) FROM TabletBasicInfo) GROUP BY tbi.Id, tbi.ModelName, tbi.ScreenSizeInches ORDER BY tbi.ScreenSizeInches;	ipad	3
SELECT tbi.Id, tbi.ModelName, tbi.ScreenSizeInches, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ScreenSizeInches = 1000 GROUP BY tbi.Id, tbi.ModelName, tbi.ScreenSizeInches;	ipad	4
SELECT Id, ModelName, Dimensions,         substr(Dimensions, 1, instr(Dimensions, 'x') - 1) *         substr(Dimensions, instr(Dimensions, 'x') + 1, instr(substr(Dimensions, instr(Dimensions, 'x') + 1), 'x') - 1) *         substr(Dimensions, instr(Dimensions, 'x', -1) + 1) AS Volume  FROM TabletBasicInfo;	ipad	1
SELECT tbi.Id, tbi.ModelName, tbi.Dimensions, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(CAST(substr(tbi.Dimensions, 1, instr(tbi.Dimensions, 'x') - 1) AS REAL) * CAST(substr(substr(tbi.Dimensions, instr(tbi.Dimensions, 'x') + 1), 1, instr(substr(tbi.Dimensions, instr(tbi.Dimensions, 'x') + 1), 'x') - 1) AS REAL) * CAST(substr(tbi.Dimensions, instr(tbi.Dimensions, 'x', -1) + 1) AS REAL)) AS Total_Volume_Change FROM TabletBasicInfo tbi GROUP BY tbi.Id, tbi.ModelName, tbi.Dimensions, strftime('%Y', tbi.ReleaseDate) ORDER BY tbi.Dimensions, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tbi.ModelName, tbi.Dimensions, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE CAST(SUBSTR(tbi.Dimensions, 1, INSTR(tbi.Dimensions, 'x')-1) AS REAL) * CAST(SUBSTR(tbi.Dimensions, INSTR(tbi.Dimensions, 'x')+1, INSTR(SUBSTR(tbi.Dimensions, INSTR(tbi.Dimensions, 'x')+1), 'x')-1) AS REAL) * CAST(SUBSTR(tbi.Dimensions, INSTR(tbi.Dimensions, 'x', -1)+1) AS REAL) > (SELECT AVG(CAST(SUBSTR(Dimensions, 1, INSTR(Dimensions, 'x')-1) AS REAL) * CAST(SUBSTR(Dimensions, INSTR(Dimensions, 'x')+1, INSTR(SUBSTR(Dimensions, INSTR(Dimensions, 'x')+1), 'x')-1) AS REAL) * CAST(SUBSTR(Dimensions, INSTR(Dimensions, 'x', -1)+1) AS REAL)) FROM TabletBasicInfo) GROUP BY tbi.Id, tbi.ModelName, tbi.Dimensions ORDER BY tbi.Dimensions;	ipad	3
SELECT tbi.Id, tbi.ModelName, tbi.Dimensions, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.Dimensions = '10000x10000x10000' GROUP BY tbi.Id, tbi.ModelName, tbi.Dimensions;	ipad	4
SELECT Id, ModelName, ResolutionWidth, ResolutionHeight, ScreenSizeInches, SQRT(ResolutionWidth * ResolutionWidth + ResolutionHeight * ResolutionHeight) / ScreenSizeInches AS PPI FROM TabletBasicInfo;	ipad	1
SELECT tbi.Id, tbi.ModelName, tbi.ResolutionWidth, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(SQRT(POWER(tbi.ResolutionWidth, 2) + POWER(tbi.ResolutionHeight, 2)) / tbi.ScreenSizeInches) AS Total_PPI_Change FROM TabletBasicInfo tbi GROUP BY tbi.Id, tbi.ModelName, tbi.ResolutionWidth, strftime('%Y', tbi.ReleaseDate) ORDER BY tbi.ResolutionWidth, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tbi.ModelName, tbi.ResolutionWidth, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ResolutionWidth > (SELECT AVG(ResolutionWidth) FROM TabletBasicInfo) GROUP BY tbi.Id, tbi.ModelName, tbi.ResolutionWidth ORDER BY tbi.ResolutionWidth;	ipad	3
SELECT tbi.Id, tbi.ModelName, tbi.ResolutionWidth, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ResolutionWidth = 100000 GROUP BY tbi.Id, tbi.ModelName, tbi.ResolutionWidth;	ipad	4
SELECT Id, ModelName, ResolutionWidth, ResolutionHeight, ScreenSizeInches, SQRT(ResolutionWidth * ResolutionWidth + ResolutionHeight * ResolutionHeight) / ScreenSizeInches AS PPI FROM TabletBasicInfo;	ipad	1
SELECT tbi.Id, tbi.ModelName, tbi.ResolutionHeight, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(SQRT(tbi.ResolutionWidth * tbi.ResolutionWidth + tbi.ResolutionHeight * tbi.ResolutionHeight) / tbi.ScreenSizeInches) AS Total_PPI_Change FROM TabletBasicInfo tbi GROUP BY tbi.Id, tbi.ModelName, tbi.ResolutionHeight, strftime('%Y', tbi.ReleaseDate) ORDER BY tbi.ResolutionHeight, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tbi.ModelName, tbi.ResolutionHeight, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ResolutionHeight > (SELECT AVG(ResolutionHeight) FROM TabletBasicInfo) GROUP BY tbi.Id, tbi.ModelName, tbi.ResolutionHeight ORDER BY tbi.ResolutionHeight;	ipad	3
SELECT tbi.Id, tbi.ModelName, tbi.ResolutionHeight, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tbi.ResolutionHeight = 100000 GROUP BY tbi.Id, tbi.ModelName, tbi.ResolutionHeight;	ipad	4
SELECT Id, ModelName, BatteryCapacityMAh, BatteryCapacityMAh / (SELECT AVG(DischargeRateMA) FROM TabletBatteryPerformance) AS Theoretical_Life_Hours FROM TabletBasicInfo;	ipad	1
SELECT tbi.Id, tbi.ModelName, tbi.BatteryCapacityMAh, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(tbi.BatteryCapacityMAh / (SELECT AVG(DischargeRateMA) FROM TabletBatteryPerformance)) AS Total_Theoretical_Life_Change FROM TabletBasicInfo tbi GROUP BY tbi.Id, tbi.ModelName, tbi.BatteryCapacityMAh, strftime('%Y', tbi.ReleaseDate) ORDER BY tbi.BatteryCapacityMAh, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tbi.ModelName, tbi.BatteryCapacityMAh, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.BatteryCapacityMAh > (SELECT AVG(BatteryCapacityMAh) FROM TabletBasicInfo) GROUP BY tbi.Id, tbi.ModelName, tbi.BatteryCapacityMAh ORDER BY tbi.BatteryCapacityMAh;	ipad	3
SELECT tbi.Id, tbi.ModelName, tbi.BatteryCapacityMAh, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tbi.BatteryCapacityMAh = 1000000 GROUP BY tbi.Id, tbi.ModelName, tbi.BatteryCapacityMAh;	ipad	4
SELECT Id, CPUCores, CPUSpeedGHz, CPUCores * CPUSpeedGHz AS Theoretical_Max_Power_GHz FROM TabletPerformanceData;	ipad	1
SELECT tbi.Id, tpd.CPUCores, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(tpd.CPUCores * tpd.CPUSpeedGHz) AS Total_Theoretical_Power_Change FROM TabletBasicInfo tbi JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId GROUP BY tbi.Id, tpd.CPUCores, strftime('%Y', tbi.ReleaseDate) ORDER BY tpd.CPUCores, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tpd.CPUCores, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tpd.CPUCores > (SELECT AVG(CPUCores) FROM TabletPerformanceData) GROUP BY tbi.Id, tpd.CPUCores ORDER BY tpd.CPUCores;	ipad	3
SELECT tbi.Id, tpd.CPUCores, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tpd.CPUCores = 1000 GROUP BY tbi.Id, tpd.CPUCores;	ipad	4
SELECT Id, CPUSpeedGHz, CPUCores, CPUSpeedGHz * CPUCores AS Theoretical_Max_Power_GHz FROM TabletPerformanceData;	ipad	1
SELECT tbi.Id, tpd.CPUSpeedGHz, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(tpd.CPUSpeedGHz * tpd.CPUCores) AS Total_Theoretical_Power_Change FROM TabletBasicInfo tbi JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId GROUP BY tbi.Id, tpd.CPUSpeedGHz, strftime('%Y', tbi.ReleaseDate) ORDER BY tpd.CPUSpeedGHz, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tpd.CPUSpeedGHz, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tpd.CPUSpeedGHz > (SELECT AVG(CPUSpeedGHz) FROM TabletPerformanceData) GROUP BY tbi.Id, tpd.CPUSpeedGHz ORDER BY tpd.CPUSpeedGHz;	ipad	3
SELECT tbi.Id, tpd.CPUSpeedGHz, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance  FROM TabletBasicInfo tbi  LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId  LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId  LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  WHERE tpd.CPUSpeedGHz = 1000  GROUP BY tbi.Id, tpd.CPUSpeedGHz;	ipad	4
SELECT Id, RAMGB, RAMGB * (SELECT AVG(RAMGB) FROM TabletPerformanceData) / (SELECT AVG(RAMGB) FROM TabletPerformanceData) AS Theoretical_Max_Throughput_GBs FROM TabletPerformanceData;	ipad	1
SELECT tbi.Id, tpd.RAMGB, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(tpd.RAMGB * (SELECT AVG(RAMGB) FROM TabletPerformanceData) / (SELECT AVG(RAMGB) FROM TabletPerformanceData)) AS Total_Theoretical_Throughput_Change FROM TabletBasicInfo tbi JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId GROUP BY tbi.Id, tpd.RAMGB, strftime('%Y', tbi.ReleaseDate) ORDER BY tpd.RAMGB, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tpd.RAMGB, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tpd.RAMGB > (SELECT AVG(RAMGB) FROM TabletPerformanceData) GROUP BY tbi.Id, tpd.RAMGB ORDER BY tpd.RAMGB;	ipad	3
SELECT tbi.Id, tpd.RAMGB, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tpd.RAMGB = 1000 GROUP BY tbi.Id, tpd.RAMGB;	ipad	4
SELECT Id, AntutuScore, CPUCores, CAST(AntutuScore AS REAL) / CPUCores AS Theoretical_Max_Power_Per_Core FROM TabletPerformanceData;	ipad	1
SELECT tbi.Id, tpd.AntutuScore, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(tpd.AntutuScore / tpd.CPUCores) AS Total_Theoretical_Power_Change FROM TabletBasicInfo tbi JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId GROUP BY tbi.Id, tpd.AntutuScore, strftime('%Y', tbi.ReleaseDate) ORDER BY tpd.AntutuScore, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tpd.AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life  FROM TabletBasicInfo tbi  LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId  LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId  WHERE tpd.AntutuScore > (SELECT AVG(AntutuScore) FROM TabletPerformanceData)  GROUP BY tbi.Id, tpd.AntutuScore  ORDER BY tpd.AntutuScore;	ipad	3
SELECT tbi.Id, tpd.AntutuScore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tpd.AntutuScore = 1000000 GROUP BY tbi.Id, tpd.AntutuScore;	ipad	4
SELECT Id, GeekbenchSingleCore, CPUSpeedGHz, CAST(GeekbenchSingleCore AS REAL) / CPUSpeedGHz AS Theoretical_Single_Core_Power_Per_GHz FROM TabletPerformanceData;	ipad	1
SELECT tbi.Id, tpd.GeekbenchSingleCore, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(tpd.GeekbenchSingleCore / tpd.CPUSpeedGHz) AS Total_Theoretical_Power_Change FROM TabletBasicInfo tbi JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId GROUP BY tbi.Id, tpd.GeekbenchSingleCore, strftime('%Y', tbi.ReleaseDate) ORDER BY tpd.GeekbenchSingleCore, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tpd.GeekbenchSingleCore, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tpd.GeekbenchSingleCore > (SELECT AVG(GeekbenchSingleCore) FROM TabletPerformanceData) GROUP BY tbi.Id, tpd.GeekbenchSingleCore ORDER BY tpd.GeekbenchSingleCore;	ipad	3
SELECT tbi.Id, tpd.GeekbenchSingleCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance  FROM TabletBasicInfo tbi  LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId  LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId  LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  WHERE tpd.GeekbenchSingleCore = 100000  GROUP BY tbi.Id, tpd.GeekbenchSingleCore;	ipad	4
SELECT Id, CPUSpeedGHz, ThermalThrottlingPercent, CPUSpeedGHz * (ThermalThrottlingPercent / 100.0) AS Theoretical_Max_Performance_Loss_GHz FROM TabletPerformanceData;	ipad	1
SELECT tbi.Id, tpd.ThermalThrottlingPercent, strftime('%Y', tbi.ReleaseDate) AS Year, SUM(tpd.CPUSpeedGHz * (tpd.ThermalThrottlingPercent / 100.0)) AS Total_Theoretical_Loss_Change FROM TabletBasicInfo tbi JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId GROUP BY tbi.Id, tpd.ThermalThrottlingPercent, strftime('%Y', tbi.ReleaseDate) ORDER BY tpd.ThermalThrottlingPercent, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tpd.ThermalThrottlingPercent, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tpd.ThermalThrottlingPercent > (SELECT AVG(ThermalThrottlingPercent) FROM TabletPerformanceData) GROUP BY tbi.Id, tpd.ThermalThrottlingPercent ORDER BY tpd.ThermalThrottlingPercent;	ipad	3
SELECT tbi.Id, tpd.ThermalThrottlingPercent, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.BatteryLifeHours) AS Total_Battery_Life, AVG(tpd.CPUSpeedGHz * (tpd.ThermalThrottlingPercent / 100.0)) AS Avg_Performance_Loss, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tpd.ThermalThrottlingPercent = 1000 GROUP BY tbi.Id, tpd.ThermalThrottlingPercent;	ipad	4
SELECT tbi.Id, tbi.BatteryCapacityMAh, tbp.BatteryLifeHours, (tbi.BatteryCapacityMAh * 3.7) / tbp.BatteryLifeHours AS Theoretical_Max_Energy_Consumption_Wh FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.Id, tbp.BatteryLifeHours, strftime('%Y', tbi.ReleaseDate) AS Year, SUM((tbi.BatteryCapacityMAh * 3.7) / tbp.BatteryLifeHours) AS Total_Theoretical_Energy_Consumption_Change FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId GROUP BY tbi.Id, tbp.BatteryLifeHours, strftime('%Y', tbi.ReleaseDate) ORDER BY tbp.BatteryLifeHours, strftime('%Y', tbi.ReleaseDate);	ipad	2
SELECT tbi.Id, tbp.BatteryLifeHours, AVG(tpd.AntutuScore) AS Avg_AntutuScore, AVG(tpd.GeekbenchSingleCore) AS Avg_GeekbenchSingleCore, AVG(tpd.GeekbenchMultiCore) AS Avg_GeekbenchMultiCore, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.ChargingTimeMinutes) AS Total_Charging_Time FROM TabletBasicInfo tbi LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.BatteryLifeHours < (SELECT AVG(BatteryLifeHours) FROM TabletBatteryPerformance) GROUP BY tbi.Id, tbp.BatteryLifeHours ORDER BY tbp.BatteryLifeHours;	ipad	3
SELECT tbi.Id, tbp.BatteryLifeHours, COUNT(tbp.Id) AS Battery_Performance_Count, SUM(tbp.ChargingTimeMinutes) AS Total_Charging_Time, AVG(tpd.ThermalThrottlingPercent) AS Avg_Thermal_Throttling, AVG(tcp.LowLightPerformanceDB) AS Avg_LowLight_Performance  FROM TabletBasicInfo tbi  LEFT JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId  LEFT JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId  LEFT JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  WHERE tbp.BatteryLifeHours = 1000  GROUP BY tbi.Id, tbp.BatteryLifeHours;	ipad	4
SELECT tbi.ModelName, tbp.ChargingTimeMinutes, tbi.BatteryCapacityMAh, (tbi.BatteryCapacityMAh * 3.7) / (tbp.ChargingTimeMinutes * 60) AS TheoreticalChargingPowerWatt FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM((tbi.BatteryCapacityMAh * 3.7) / (tbp.ChargingTimeMinutes * 60)) AS TotalTheoreticalChargingPowerChange, AVG(tbp.ChargingTimeMinutes) AS AvgChargingTimeMinutes FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now','-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tbp.ChargingTimeMinutes, tbp.BatteryHealthPercent, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore, tpd.ThermalThrottlingPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tbp.ChargingTimeMinutes <= 60 ORDER BY tbp.ChargingTimeMinutes;	ipad	3
SELECT tbi.ModelName, tbp.ChargingTimeMinutes, tbp.BatteryHealthPercent, tbp.TemperatureCelsius, tbp.DischargeRateMA, tbp.FastChargingWattage, (tbp.FastChargingWattage * 10000 / 60) AS TotalEnergyConsumedWh FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.ChargingTimeMinutes = 10000;	ipad	4
SELECT tbi.ModelName, tbp.StandbyTimeHours, tbi.BatteryCapacityMAh, (tbi.BatteryCapacityMAh * 3.7) / tbp.StandbyTimeHours AS TheoreticalStandbyEnergyConsumptionWh FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM((tbi.BatteryCapacityMAh * 3.7) / tbp.StandbyTimeHours) AS TotalTheoreticalStandbyEnergyConsumptionChange, AVG(tbp.StandbyTimeHours) AS AvgStandbyTimeHours FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now', '-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tbp.StandbyTimeHours, tbp.BatteryHealthPercent, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore, tpd.ThermalThrottlingPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tbp.StandbyTimeHours >= 300 ORDER BY tbp.StandbyTimeHours DESC;	ipad	3
SELECT tbi.ModelName, tbp.StandbyTimeHours, tbp.BatteryHealthPercent, tbp.TemperatureCelsius, tbp.DischargeRateMA, (tbi.BatteryCapacityMAh * 3.7) / tbp.StandbyTimeHours AS TheoreticalStandbyEnergyConsumptionWh FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.StandbyTimeHours = 10000;	ipad	4
SELECT tbi.ModelName, tbp.FastChargingWattage, tbi.BatteryCapacityMAh, (tbi.BatteryCapacityMAh * 3.7) / (tbp.FastChargingWattage * 60) AS TheoreticalChargingTimeMinutes FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM((tbi.BatteryCapacityMAh * 3.7) / (tbp.FastChargingWattage * 60)) AS TotalTheoreticalChargingTimeChange, AVG(tbp.FastChargingWattage) AS AvgFastChargingWattage FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now', '-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tbp.FastChargingWattage, tbp.BatteryHealthPercent, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore, tpd.ThermalThrottlingPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tbp.FastChargingWattage >= 30 ORDER BY tbp.FastChargingWattage DESC;	ipad	3
SELECT tbi.ModelName, tbp.FastChargingWattage, tbp.BatteryHealthPercent, tbp.TemperatureCelsius, tbp.DischargeRateMA, (tbi.BatteryCapacityMAh * 3.7) / (tbp.FastChargingWattage * 60) AS TheoreticalChargingTimeMinutes FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.FastChargingWattage = 10000;	ipad	4
SELECT tbi.ModelName, tbp.BatteryHealthPercent, tbi.BatteryCapacityMAh, tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100.0) AS TheoreticalMaxBatteryCapacityMAh FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM(tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100.0)) AS TotalTheoreticalMaxCapacityChange, AVG(tbp.BatteryHealthPercent) AS AvgBatteryHealthPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now', '-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tbp.BatteryHealthPercent, tbp.BatteryLifeHours, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore, tpd.ThermalThrottlingPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tbp.BatteryHealthPercent <= 50 ORDER BY tbp.BatteryHealthPercent ASC;	ipad	3
SELECT tbi.ModelName, tbp.BatteryHealthPercent, tbp.BatteryLifeHours, tbp.TemperatureCelsius, tbp.DischargeRateMA, tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100.0) AS TheoreticalMaxBatteryCapacityMAh FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.BatteryHealthPercent = 1000;	ipad	4
SELECT tbi.ModelName, tbp.ChargeCycles, tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100.0) AS TheoreticalMaxBatteryCapacityMAh, (tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100.0)) / (tbi.BatteryCapacityMAh * tbp.ChargeCycles) AS TheoreticalBatteryLifeYears FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM((tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100)) / (tbi.BatteryCapacityMAh * tbp.ChargeCycles)) AS TotalTheoreticalBatteryLifeChange, AVG(tbp.ChargeCycles) AS AvgChargeCycles FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now', '-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tbp.ChargeCycles, tbp.BatteryHealthPercent, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore, tpd.ThermalThrottlingPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tbp.ChargeCycles >= 500 ORDER BY tbp.ChargeCycles DESC;	ipad	3
sqlite3 SELECT tbi.ModelName, tbp.ChargeCycles, tbp.BatteryHealthPercent, tbp.TemperatureCelsius, tbp.DischargeRateMA, (tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100.0)) / (tbi.BatteryCapacityMAh * tbp.ChargeCycles) AS TheoreticalBatteryLifeYears FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.ChargeCycles = 100000;	ipad	4
SELECT tbi.ModelName, tbp.DischargeRateMA, tbi.BatteryCapacityMAh, tbi.BatteryCapacityMAh / tbp.DischargeRateMA AS TheoreticalDischargeTimeHours FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM(tbi.BatteryCapacityMAh / tbp.DischargeRateMA) AS TotalTheoreticalDischargeTimeChange, AVG(tbp.DischargeRateMA) AS AvgDischargeRateMA FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now', '-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tbp.DischargeRateMA, tbp.BatteryHealthPercent, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore, tpd.ThermalThrottlingPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tbp.DischargeRateMA >= 500 ORDER BY tbp.DischargeRateMA DESC;	ipad	3
SELECT tbi.ModelName, tbp.DischargeRateMA, tbp.BatteryHealthPercent, tbp.TemperatureCelsius, tbi.BatteryCapacityMAh / tbp.DischargeRateMA AS TheoreticalDischargeTimeHours FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.DischargeRateMA = 100000;	ipad	4
SELECT tbi.ModelName, tbp.TemperatureCelsius, tbi.BatteryCapacityMAh, tbi.BatteryCapacityMAh * (tbp.TemperatureCelsius / 100) AS TheoreticalMaxChargingPowerWatt FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM(tbi.BatteryCapacityMAh * (tbp.TemperatureCelsius / 100)) AS TotalTheoreticalMaxChargingPowerChange, AVG(tbp.TemperatureCelsius) AS AvgTemperatureCelsius FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now','-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tbp.TemperatureCelsius, tbp.BatteryHealthPercent, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore, tpd.ThermalThrottlingPercent FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tbp.TemperatureCelsius >= 40 ORDER BY tbp.TemperatureCelsius DESC;	ipad	3
SELECT tbi.ModelName, tbp.TemperatureCelsius, tbp.BatteryHealthPercent, tbi.BatteryCapacityMAh * (tbp.TemperatureCelsius / 100) AS TheoreticalMaxChargingPowerWatt FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbp.TemperatureCelsius = 1000;	ipad	4
SELECT tbi.ModelName, tcp.RearCameraMP, tcp.RearCameraMP * (10.0 / 15.0) AS TheoreticalMaxResolutionPixels FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM(tcp.RearCameraMP * (10.0 / 15.0)) AS TotalTheoreticalMaxResolutionChange, AVG(tcp.RearCameraMP) AS AvgRearCameraMP FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tbi.ReleaseDate BETWEEN date('now','-1 year') AND date('now') GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tcp.RearCameraMP, tbi.StorageOptionsGB, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId WHERE tcp.RearCameraMP >= 12 ORDER BY tcp.RearCameraMP DESC;	ipad	3
SELECT tbi.ModelName, tcp.RearCameraMP, tcp.RearCameraMP * (10.0 / 15.0) AS TheoreticalMaxResolutionPixels FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.RearCameraMP = 1000;	ipad	4
SELECT tbi.ModelName, tcp.FrontCameraMP, SQRT(POWER(4000, 2) + POWER(3000, 2)) / 10 AS PixelDensityPPI FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.FrontCameraMP = 12;	ipad	1
SELECT tbi.ModelName, tcp.FrontCameraMP, 5 * (1 + 0.25 * 2) AS EstimatedStorageMB FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.FrontCameraMP = 8;	ipad	2
SELECT tbi.ModelName, tcp.FrontCameraMP, tbi.StorageOptionsGB, tbi.StorageOptionsGB * 1024 / 3 AS MaxPhotos FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.FrontCameraMP = 5 AND tbi.StorageOptionsGB = 32;	ipad	3
SELECT tbi.ModelName, tcp.FrontCameraMP, tbi.StorageOptionsGB, tbi.BatteryCapacityMAh, tbp.DischargeRateMA, tbi.StorageOptionsGB * 1024 / 100 AS MaxPhotos, tbi.BatteryCapacityMAh / tbp.DischargeRateMA AS BatteryLifeHours FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tcp.FrontCameraMP = 100 AND tbi.StorageOptionsGB = 128 AND tbi.BatteryCapacityMAh = 10000 AND tbp.DischargeRateMA = 1000;	ipad	4
SELECT tbi.ModelName, tcp.ApertureRear, POWER(10.0 / tcp.ApertureRear, 2) AS TheoreticalMaxLightIntakeLumens  FROM TabletBasicInfo tbi  JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId;	ipad	1
SELECT tbi.ModelName, SUM(POWER(10 / tcp.ApertureRear, 2)) AS TotalTheoreticalMaxLightIntakeChange, AVG(tcp.ApertureRear) AS AvgApertureRear  FROM TabletBasicInfo tbi  JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  WHERE tbi.ReleaseDate BETWEEN date('now', '-1 year') AND date('now')  GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tcp.ApertureRear, tcp.LowLightPerformanceDB, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore  FROM TabletBasicInfo tbi  JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId  WHERE tcp.ApertureRear >= 2.8  ORDER BY tcp.ApertureRear DESC;	ipad	3
SELECT tbi.ModelName, tcp.ApertureRear, POWER(10.0 / tcp.ApertureRear, 2) AS TheoreticalMaxLightIntakeLumens FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.ApertureRear = 0.1;	ipad	4
SELECT tbi.ModelName, tcp.ApertureFront, tcp.ApertureRear, POWER(tcp.ApertureFront / tcp.ApertureRear, 2) AS LightIntakeRatio FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.ApertureFront = 2.0 AND tcp.ApertureRear = 1.8;	ipad	1
SELECT tbi.ModelName, tcp.ApertureFront, tcp.ApertureRear, 100 * (1 / POWER(tcp.ApertureFront, 2)) AS FrontEquivalentBrightness, 100 * (1 / POWER(tcp.ApertureRear, 2)) AS RearEquivalentBrightness FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.ApertureFront = 2.4 AND tcp.ApertureRear = 1.6;	ipad	2
SELECT tbi.ModelName, tcp.ApertureFront, tbi.StorageOptionsGB, tbi.StorageOptionsGB * 1024 / 4 AS MaxPhotos FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.ApertureFront = 2.2 AND tbi.StorageOptionsGB = 64;	ipad	3
SELECT tbi.ModelName, tcp.ApertureFront, tcp.ApertureRear, tbi.ResolutionWidth, tbi.ResolutionHeight, 100 * (1 / POWER(tcp.ApertureFront, 2)) AS FrontEquivalentBrightness, 100 * (1 / POWER(tcp.ApertureRear, 2)) AS RearEquivalentBrightness, CASE WHEN (100 * (1 / POWER(tcp.ApertureFront, 2))) <= tbi.ResolutionWidth AND (100 * (1 / POWER(tcp.ApertureRear, 2))) <= tbi.ResolutionHeight THEN 'Yes' ELSE 'No' END AS CanDisplayFullImage FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.ApertureFront = 0.5 AND tcp.ApertureRear = 0.3 AND tbi.ResolutionWidth = 2560 AND tbi.ResolutionHeight = 1600;	ipad	4
SELECT tbi.ModelName, tcp.VideoResolution, tcp.FrameRateFPS, (CAST(SUBSTR(tcp.VideoResolution, 1, INSTR(tcp.VideoResolution, 'x') - 1) AS INTEGER) * CAST(SUBSTR(tcp.VideoResolution, INSTR(tcp.VideoResolution, 'x') + 1) AS INTEGER) * tcp.FrameRateFPS * 24) / (1024 * 1024) AS TheoreticalMaxVideoDataMBps FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId;	ipad	1
SELECT tbi.ModelName,         SUM((CAST(SUBSTR(tcp.VideoResolution, 1, INSTR(tcp.VideoResolution, 'x') - 1) AS INTEGER) *              CAST(SUBSTR(tcp.VideoResolution, INSTR(tcp.VideoResolution, 'x') + 1) AS INTEGER) *              tcp.FrameRateFPS * 24) / (1024 * 1024)) AS TotalTheoreticalMaxVideoDataChange,         AVG(CAST(SUBSTR(tcp.VideoResolution, 1, INSTR(tcp.VideoResolution, 'x') - 1) AS INTEGER) *             CAST(SUBSTR(tcp.VideoResolution, INSTR(tcp.VideoResolution, 'x') + 1) AS INTEGER)) AS AvgVideoResolution  FROM TabletBasicInfo tbi  JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  WHERE tbi.ReleaseDate BETWEEN date('now', '-1 year') AND date('now')  GROUP BY tbi.ModelName;	ipad	2
SELECT tbi.ModelName, tcp.VideoResolution, tbi.StorageOptionsGB, tpd.AntutuScore, tpd.GeekbenchSingleCore, tpd.GeekbenchMultiCore  FROM TabletBasicInfo tbi  JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  JOIN TabletPerformanceData tpd ON tbi.Id = tpd.TabletId  WHERE CAST(SUBSTR(tcp.VideoResolution, 1, INSTR(tcp.VideoResolution, 'x')-1) AS INTEGER) * CAST(SUBSTR(tcp.VideoResolution, INSTR(tcp.VideoResolution, 'x')+1) AS INTEGER) >= 3840 * 2160  ORDER BY CAST(SUBSTR(tcp.VideoResolution, 1, INSTR(tcp.VideoResolution, 'x')-1) AS INTEGER) * CAST(SUBSTR(tcp.VideoResolution, INSTR(tcp.VideoResolution, 'x')+1) AS INTEGER) DESC;	ipad	3
SELECT tbi.ModelName, tcp.VideoResolution, (CAST(SUBSTR(tcp.VideoResolution, 1, INSTR(tcp.VideoResolution, 'x') - 1) AS REAL) * CAST(SUBSTR(tcp.VideoResolution, INSTR(tcp.VideoResolution, 'x') + 1) AS REAL) * tcp.FrameRateFPS * 24) / (1024 * 1024) AS TheoreticalMaxVideoDataMBps FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.VideoResolution = '100000x100000';	ipad	4
SELECT tbi.ModelName, tbi.BatteryCapacityMAh, tbp.DischargeRateMA, tbi.BatteryCapacityMAh / tbp.DischargeRateMA AS TheoreticalBatteryLifeHours  FROM TabletBasicInfo tbi  JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId  WHERE tbi.BatteryCapacityMAh = 10000 AND tbp.DischargeRateMA = 2000;	ipad	1
SELECT tbi.ModelName, tbi.ResolutionWidth, tbi.ResolutionHeight, tbi.ScreenSizeInches, SQRT(tbi.ResolutionWidth * tbi.ResolutionWidth + tbi.ResolutionHeight * tbi.ResolutionHeight) / tbi.ScreenSizeInches AS PixelDensityPPI FROM TabletBasicInfo tbi WHERE tbi.ResolutionWidth = 2560 AND tbi.ResolutionHeight = 1600 AND tbi.ScreenSizeInches = 10.5;	ipad	2
SELECT tbi.ModelName, tbi.BatteryCapacityMAh, tbp.BatteryHealthPercent, tbi.BatteryCapacityMAh * (tbp.BatteryHealthPercent / 100.0) AS ActualBatteryCapacityMAh FROM TabletBasicInfo tbi JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tbi.BatteryCapacityMAh = 8000 AND tbp.BatteryHealthPercent = 85;	ipad	3
SELECT tbi.ModelName, tbi.BatteryCapacityMAh, tbp.DischargeRateMA, tbi.BatteryCapacityMAh / tbp.DischargeRateMA AS TheoreticalBatteryLifeHours  FROM TabletBasicInfo tbi  JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId  WHERE tbi.BatteryCapacityMAh = 50000 AND tbp.DischargeRateMA = 5000;	ipad	4
SELECT tbi.ModelName, tcp.ApertureRear, tcp.ApertureFront, POWER(tcp.ApertureFront / tcp.ApertureRear, 2) AS LightIntakeRatio FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.ApertureRear = 2.0 AND tcp.ApertureFront = 2.4;	ipad	1
SELECT tbi.ModelName, tcp.OpticalZoomX, tcp.DigitalZoomX, 10.0 / tcp.OpticalZoomX AS OpticalZoomEquivalentDistance, 10.0 / tcp.DigitalZoomX AS DigitalZoomEquivalentDistance FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.OpticalZoomX = 5 AND tcp.DigitalZoomX = 10;	ipad	2
SELECT tbi.ModelName, tcp.RearCameraMP, tcp.FrontCameraMP, tcp.RearCameraMP * 0.3 AS RearCameraStorageMB, tcp.FrontCameraMP * 0.3 AS FrontCameraStorageMB FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.RearCameraMP = 12 AND tcp.FrontCameraMP = 8;	ipad	3
SELECT tbi.ModelName, tcp.OpticalZoomX, tcp.DigitalZoomX, tbi.ResolutionWidth, tbi.ResolutionHeight, 1000.0 / tcp.OpticalZoomX AS OpticalZoomEquivalentDistance, 1000.0 / tcp.DigitalZoomX AS DigitalZoomEquivalentDistance, CASE WHEN (1000.0 / tcp.OpticalZoomX) <= tbi.ResolutionWidth AND (1000.0 / tcp.DigitalZoomX) <= tbi.ResolutionHeight THEN 'Yes' ELSE 'No' END AS CanDisplayFullImage FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.OpticalZoomX = 100 AND tcp.DigitalZoomX = 200 AND tbi.ResolutionWidth = 2560 AND tbi.ResolutionHeight = 1600;	ipad	4
SELECT tbi.ModelName, tcp.DigitalZoomX, tbi.ResolutionHeight, tbi.ScreenSizeInches, 2 * tcp.DigitalZoomX * (tbi.ResolutionHeight / tbi.ScreenSizeInches) AS EquivalentHeightPixels FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.DigitalZoomX = 10 AND tbi.ScreenSizeInches = 10 AND tbi.ResolutionHeight = 1600;	ipad	1
SELECT tbi.ModelName, tcp.DigitalZoomX, tbi.ResolutionWidth, 50.0 / tcp.DigitalZoomX AS EquivalentDistanceMeters, (tbi.ResolutionWidth / (50.0 / tcp.DigitalZoomX)) * 50 AS PixelWidth FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.DigitalZoomX = 20 AND tbi.ResolutionWidth = 2560;	ipad	2
SELECT tbi.ModelName, tcp.DigitalZoomX, 10 * (1 + 0.2 * tcp.DigitalZoomX) AS EstimatedStorageMB FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.DigitalZoomX = 5;	ipad	3
SELECT tbi.ModelName, tcp.DigitalZoomX, tbi.ResolutionWidth, tbi.ResolutionHeight, 1000 / tcp.DigitalZoomX AS EquivalentDistanceMeters, CASE WHEN (1000 / tcp.DigitalZoomX) <= tbi.ResolutionWidth AND (1000 / tcp.DigitalZoomX) <= tbi.ResolutionHeight THEN 'Yes' ELSE 'No' END AS CanDisplayFullImage FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.DigitalZoomX = 1000 AND tbi.ResolutionWidth = 2560 AND tbi.ResolutionHeight = 1600;	ipad	4
SELECT tbi.ModelName, tcp.LowLightPerformanceDB, 1.0 * POWER(10, tcp.LowLightPerformanceDB / 10.0) AS MinLightIntensityLux  FROM TabletBasicInfo tbi  JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId  WHERE tcp.LowLightPerformanceDB = -10;	ipad	1
SELECT tbi.ModelName, tcp.LowLightPerformanceDB, tbi.ResolutionWidth, tbi.ResolutionHeight, 0.1 * POWER(10, tcp.LowLightPerformanceDB / 10) AS MinLightIntensityLux, 10 * LOG(0.1 * POWER(10, tcp.LowLightPerformanceDB / 10) * tbi.ResolutionWidth * tbi.ResolutionHeight) / LOG(10) AS SNR FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.LowLightPerformanceDB = -15 AND tbi.ResolutionWidth = 2560 AND tbi.ResolutionHeight = 1600;	ipad	2
SELECT tbi.ModelName, tcp.LowLightPerformanceDB, tbi.BatteryCapacityMAh, tbp.DischargeRateMA, 0.5 * POWER(10, tcp.LowLightPerformanceDB / 10) AS MinLightIntensityLux, tbi.BatteryCapacityMAh / tbp.DischargeRateMA AS BatteryLifeHours FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId JOIN TabletBatteryPerformance tbp ON tbi.Id = tbp.TabletId WHERE tcp.LowLightPerformanceDB = -12 AND tbi.BatteryCapacityMAh = 8000 AND tbp.DischargeRateMA = 500;	ipad	3
SELECT tbi.ModelName, tcp.LowLightPerformanceDB, tbi.ResolutionWidth, tbi.ResolutionHeight, 0.0001 * POWER(10, tcp.LowLightPerformanceDB / 10) AS MinLightIntensityLux, 10 * LOG10(0.0001 * POWER(10, tcp.LowLightPerformanceDB / 10) * tbi.ResolutionWidth * tbi.ResolutionHeight) AS SNR FROM TabletBasicInfo tbi JOIN TabletCameraPerformance tcp ON tbi.Id = tcp.TabletId WHERE tcp.LowLightPerformanceDB = -100 AND tbi.ResolutionWidth = 2560 AND tbi.ResolutionHeight = 1600;	ipad	4
SELECT c.Customer_ID, c.First_Name, c.Last_Name, c.Gender, c.Date_Of_Birth, c.Email, c.Phone_Number, c.Address, c.City, c.Province, c.Country, c.Postal_Code, c.Membership_Level, SUM(od.Quantity * p.Weight) AS Total_Weight  FROM Customer c  JOIN Orders o ON c.Customer_ID = o.Customer_ID  JOIN Order_Detail od ON o.Order_ID = od.Order_ID  JOIN Phone p ON od.Phone_ID = p.Phone_ID  GROUP BY c.Customer_ID  ORDER BY Total_Weight DESC  LIMIT 10;	phone_market	1
SELECT c.Customer_ID, c.First_Name, c.Last_Name, c.Gender, c.Date_Of_Birth, c.Email, c.Phone_Number, c.Address, c.City, c.Province, c.Country, c.Postal_Code, c.Membership_Level, c.Created_At, c.Updated_At, AVG(o.Total_Amount) AS Avg_Order_Amount  FROM Customer c  JOIN Orders o ON c.Customer_ID = o.Customer_ID  GROUP BY c.Customer_ID, c.First_Name, c.Last_Name, c.Gender, c.Date_Of_Birth, c.Email, c.Phone_Number, c.Address, c.City, c.Province, c.Country, c.Postal_Code, c.Membership_Level, c.Created_At, c.Updated_At  ORDER BY Avg_Order_Amount ASC;	phone_market	2
SELECT DISTINCT c.Customer_ID, c.First_Name, c.Last_Name, c.Gender, c.Date_Of_Birth, c.Email, c.Phone_Number, c.Address, c.City, c.Province, c.Country, c.Postal_Code, c.Membership_Level  FROM Customer c  JOIN Orders o ON c.Customer_ID = o.Customer_ID  JOIN Order_Detail od ON o.Order_ID = od.Order_ID  JOIN Phone p ON od.Phone_ID = p.Phone_ID  WHERE p.Screen_Size > 6 AND p.Battery_Capacity > 4000  ORDER BY c.Membership_Level DESC;	phone_market	3
SELECT c.Customer_ID, c.First_Name, c.Last_Name, c.Gender, c.Date_Of_Birth, c.Email, c.Phone_Number, c.Address, c.City, c.Province, c.Country, c.Postal_Code, c.Membership_Level, SUM(od.Unit_Price * od.Quantity * 1000) AS Total_Order_Amount  FROM Customer c  JOIN Orders o ON c.Customer_ID = o.Customer_ID  JOIN Order_Detail od ON o.Order_ID = od.Order_ID  GROUP BY c.Customer_ID  ORDER BY Total_Order_Amount DESC  LIMIT 5;	phone_market	4
SELECT Email, Phone_Number, Date_Of_Birth,         (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) -         (strftime('%m-%d', 'now') < strftime('%m-%d', Date_Of_Birth)) AS Age  FROM Customer  ORDER BY Age DESC  LIMIT 10;	phone_market	1
WITH OrderIntervals AS (     SELECT          Customer_ID,          Order_Date,          JULIANDAY(LEAD(Order_Date) OVER (PARTITION BY Customer_ID ORDER BY Order_Date)) - JULIANDAY(Order_Date) AS Days_Between_Orders      FROM Orders ) SELECT      c.Phone_Number,      c.Email,      AVG(oi.Days_Between_Orders) AS Avg_Order_Interval  FROM Customer c  LEFT JOIN OrderIntervals oi ON c.Customer_ID = oi.Customer_ID  GROUP BY c.Customer_ID, c.Phone_Number, c.Email  HAVING AVG(oi.Days_Between_Orders) IS NOT NULL  ORDER BY Avg_Order_Interval ASC;	phone_market	2
SELECT Email, Phone_Number, Membership_Level  FROM Customer  WHERE (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) > 60  AND Membership_Level = '钻石'  ORDER BY Date_Of_Birth ASC;	phone_market	3
SELECT Phone_Number, (     CAST(SUBSTR(Phone_Number, 1, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 2, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 3, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 4, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 5, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 6, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 7, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 8, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 9, 1) AS INTEGER) +      CAST(SUBSTR(Phone_Number, 10, 1) AS INTEGER) ) AS Total_Sum  FROM Customer  ORDER BY Total_Sum DESC  LIMIT 5;	phone_market	4
SELECT City, AVG(strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth) - (strftime('%m-%d', 'now') < strftime('%m-%d', Date_Of_Birth))) AS Avg_Age FROM Customer GROUP BY City ORDER BY Avg_Age DESC LIMIT 5;	phone_market	1
SELECT c.Province, AVG((o.Total_Amount - sub.Avg_Amount) * (o.Total_Amount - sub.Avg_Amount)) AS Variance_Total_Amount FROM Customer c JOIN Orders o ON c.Customer_ID = o.Customer_ID JOIN (SELECT c.Province, AVG(o.Total_Amount) AS Avg_Amount FROM Customer c JOIN Orders o ON c.Customer_ID = o.Customer_ID GROUP BY c.Province) sub ON c.Province = sub.Province GROUP BY c.Province ORDER BY Variance_Total_Amount DESC;	phone_market	2
SELECT Email, Phone_Number, Membership_Level FROM Customer WHERE Province IN ('沿海省份1', '沿海省份2') AND Membership_Level IN ('黄金', '钻石') ORDER BY City ASC;	phone_market	3
SELECT City, (COUNT(Customer_ID) * 100) / 1000 AS Customer_Density  FROM Customer  GROUP BY City  ORDER BY Customer_Density DESC  LIMIT 3;	phone_market	4
SELECT First_Name || ' ' || Last_Name AS Full_Name, (LENGTH(First_Name) + LENGTH(Last_Name)) AS Name_Length FROM Customer ORDER BY Name_Length DESC LIMIT 10;	phone_market	1
SELECT First_Name || ' ' || Last_Name AS Full_Name, CAST(LENGTH(First_Name) AS REAL) / NULLIF(LENGTH(Last_Name), 0) AS Name_Ratio FROM Customer ORDER BY Name_Ratio ASC;	phone_market	2
SELECT Email, Phone_Number, First_Name || ' ' || Last_Name AS Full_Name FROM Customer WHERE First_Name LIKE 'A%' AND Last_Name LIKE '%Z' ORDER BY Full_Name ASC;	phone_market	3
SELECT First_Name || ' ' || Last_Name AS Full_Name, (LENGTH(First_Name) + LENGTH(Last_Name)) * 1000 AS Full_Name_Length FROM Customer ORDER BY Full_Name_Length DESC LIMIT 5;	phone_market	4
SELECT Gender, AVG(strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth) - (strftime('%m-%d', 'now') < strftime('%m-%d', Date_Of_Birth))) AS Avg_Age FROM Customer GROUP BY Gender ORDER BY Avg_Age DESC;	phone_market	1
SELECT Gender, SQRT(AVG((Age - Avg_Age) * (Age - Avg_Age))) AS Age_StdDev  FROM (     SELECT Gender,             (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth) -              (CASE WHEN strftime('%m-%d', 'now') < strftime('%m-%d', Date_Of_Birth) THEN 1 ELSE 0 END)) AS Age,            AVG(strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth) -                 (CASE WHEN strftime('%m-%d', 'now') < strftime('%m-%d', Date_Of_Birth) THEN 1 ELSE 0 END))                 OVER (PARTITION BY Gender) AS Avg_Age      FROM Customer ) AS Age_Data  GROUP BY Gender  ORDER BY Age_StdDev DESC;	phone_market	2
SELECT First_Name, Last_Name, Email, Phone_Number FROM Customer WHERE (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) > 50 AND Gender = 'Female' ORDER BY Date_Of_Birth ASC;	phone_market	3
SELECT Gender, AVG((strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth) - (CASE WHEN (strftime('%m-%d', 'now') < strftime('%m-%d', Date_Of_Birth)) THEN 1 ELSE 0 END)) + 100) AS Avg_Age FROM Customer GROUP BY Gender ORDER BY Avg_Age DESC;	phone_market	4
SELECT Email, LENGTH(SUBSTR(Email, INSTR(Email, '@') + 1)) AS Domain_Length FROM Customer ORDER BY Domain_Length DESC LIMIT 10;	phone_market	1
SELECT Phone_Number,         (CAST(SUBSTR(Phone_Number, 1, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 2, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 3, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 4, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 5, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 6, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 7, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 8, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 9, 1) AS INTEGER) +          CAST(SUBSTR(Phone_Number, 10, 1) AS INTEGER)) AS Digit_Sum  FROM Customer  ORDER BY Digit_Sum DESC;	phone_market	2
SELECT First_Name, Last_Name, Email, Phone_Number FROM Customer WHERE Email LIKE '%@gmail.com' AND Phone_Number LIKE '138%' ORDER BY Email ASC;	phone_market	3
SELECT Email, (LENGTH(Email) - LENGTH(SUBSTR(Email, 1, INSTR(Email, '@') - 1)) - 1) * 1000 AS Domain_Length FROM Customer ORDER BY Domain_Length DESC LIMIT 5;	phone_market	4
SELECT Membership_Level, AVG(JULIANDAY('now') - JULIANDAY(Created_At)) AS Avg_Days  FROM Customer  GROUP BY Membership_Level  ORDER BY Avg_Days DESC  LIMIT 5;	phone_market	1
SELECT Membership_Level, AVG((Days_Since_Created - Avg_Days) * (Days_Since_Created - Avg_Days)) AS Created_At_Variance FROM (SELECT Membership_Level, (julianday('now') - julianday(Created_At)) AS Days_Since_Created, AVG(julianday('now') - julianday(Created_At)) OVER (PARTITION BY Membership_Level) AS Avg_Days FROM Customer) AS Days_Data GROUP BY Membership_Level ORDER BY Created_At_Variance DESC;	phone_market	2
SELECT First_Name, Last_Name, Email, Phone_Number  FROM Customer  WHERE Membership_Level = '钻石' AND Created_At >= date('now', '-1 year')  ORDER BY Created_At ASC;	phone_market	3
SELECT Membership_Level, AVG(JULIANDAY('now') - JULIANDAY(DATE(Created_At, '-100 years'))) AS Avg_Days FROM Customer GROUP BY Membership_Level ORDER BY Avg_Days DESC LIMIT 3;	phone_market	4
SELECT od.Order_ID, (od.Quantity * p.Weight) AS Total_Weight FROM Order_Detail od JOIN Phone p ON od.Phone_ID = p.Phone_ID ORDER BY Total_Weight DESC LIMIT 10;	phone_market	1
SELECT od.Order_Detail_ID, od.Total_Price / (od.Quantity * (SELECT Weight FROM Phone WHERE Phone_ID = od.Phone_ID)) AS Price_Weight_Ratio FROM Order_Detail od ORDER BY Price_Weight_Ratio ASC;	phone_market	2
SELECT od.Order_ID, od.Total_Price  FROM Order_Detail od  JOIN Phone p ON od.Phone_ID = p.Phone_ID  WHERE od.Quantity > 10 AND p.Weight < 200  ORDER BY od.Total_Price DESC;	phone_market	3
SELECT od.Order_Detail_ID, (od.Quantity * 1000) * (SELECT Weight FROM Phone WHERE Phone_ID = od.Phone_ID) AS Total_Weight FROM Order_Detail od ORDER BY Total_Weight DESC LIMIT 5;	phone_market	4
SELECT Order_ID, (Quantity * Unit_Price) AS Total_Price FROM Order_Detail ORDER BY Total_Price DESC LIMIT 10;	phone_market	1
SELECT Order_Detail_ID, Total_Price / Quantity AS Price_Quantity_Ratio FROM Order_Detail WHERE Quantity > 0 ORDER BY Price_Quantity_Ratio ASC;	phone_market	2
SELECT Order_ID, Total_Price FROM Order_Detail WHERE Quantity > 5 AND Unit_Price < 1000 ORDER BY Total_Price DESC;	phone_market	3
SELECT Order_Detail_ID, (Quantity * 1000) * Unit_Price AS Total_Price FROM Order_Detail WHERE Quantity > 0 AND Unit_Price > 0 ORDER BY Total_Price DESC LIMIT 5;	phone_market	4
SELECT Order_ID, (Total_Price - Discount + Tax) AS Net_Price FROM Order_Detail ORDER BY Net_Price DESC LIMIT 10;	phone_market	1
SELECT Order_Detail_ID, (Total_Price - Discount + Tax) / Total_Price AS Net_Price_Ratio FROM Order_Detail WHERE Total_Price > 0 ORDER BY Net_Price_Ratio ASC;	phone_market	2
SELECT Order_ID, (Total_Price - Discount + Tax) AS Net_Price FROM Order_Detail WHERE (Total_Price - Discount + Tax) > 1000 AND Tax < 50 ORDER BY Net_Price DESC;	phone_market	3
SELECT Order_Detail_ID, (Total_Price * 10000) - Discount + Tax AS Net_Price FROM Order_Detail ORDER BY Net_Price DESC LIMIT 5;	phone_market	4
SELECT Order_ID, datetime(Updated_At, '+' || Warranty_Period || ' months') AS Warranty_End_Date  FROM Order_Detail  ORDER BY Warranty_End_Date DESC  LIMIT 10;	phone_market	1
SELECT Order_Detail_ID,         (JULIANDAY(DATETIME(Updated_At, '+' || Warranty_Period || ' months')) - JULIANDAY('now')) AS Days_Remaining  FROM Order_Detail  ORDER BY Days_Remaining ASC;	phone_market	2
SELECT Order_ID, datetime(Updated_At, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM Order_Detail WHERE Warranty_Period > 12 AND Updated_At >= date('now', '-1 year') ORDER BY Warranty_End_Date ASC;	phone_market	3
SELECT Order_Detail_ID,             datetime(Updated_At, '+' || (Warranty_Period + 1000) || ' months') AS Warranty_End_Date      FROM Order_Detail      ORDER BY Warranty_End_Date DESC      LIMIT 5;	phone_market	4
SELECT Order_ID, julianday('now') - julianday(Order_Date) AS Days_Since_Order FROM Orders ORDER BY Days_Since_Order DESC LIMIT 10;	phone_market	1
SELECT o.Customer_ID,         COUNT(o.Order_ID) * 1.0 / (JULIANDAY('now') - JULIANDAY(MIN(o.Order_Date))) AS Order_Frequency_Ratio  FROM Orders o  GROUP BY o.Customer_ID  ORDER BY Order_Frequency_Ratio ASC;	phone_market	2
SELECT Order_ID, Order_Date FROM Orders WHERE Order_Date >= date('now','-1 year') AND Order_Status = 'Delivered' ORDER BY Order_Date ASC;	phone_market	3
SELECT Order_ID, JULIANDAY(DATE(Order_Date, '+100 years')) - JULIANDAY('now') AS Days_Since_Order FROM Orders ORDER BY Days_Since_Order DESC LIMIT 5;	phone_market	4
SELECT Payment_Method, AVG(Total_Amount) AS Avg_Total_Amount FROM Orders GROUP BY Payment_Method ORDER BY Avg_Total_Amount DESC;	phone_market	1
SELECT Payment_Method, STDEV(Total_Amount) AS Standard_Deviation FROM Orders GROUP BY Payment_Method ORDER BY Standard_Deviation DESC;	phone_market	2
SELECT Order_ID, Total_Amount FROM Orders WHERE Total_Amount > 1000 AND Payment_Method = '支付宝' ORDER BY Total_Amount DESC;	phone_market	3
SELECT Payment_Method, AVG(Total_Amount * 10000) AS Average_Amount FROM Orders GROUP BY Payment_Method ORDER BY Average_Amount DESC LIMIT 3;	phone_market	4
SELECT Shipping_Address, COUNT(Order_ID) AS Order_Count FROM Orders GROUP BY Shipping_Address ORDER BY Order_Count DESC LIMIT 10;	phone_market	1
SELECT Shipping_Method, AVG(Total_Amount) AS Average_Amount FROM Orders GROUP BY Shipping_Method ORDER BY Average_Amount ASC;	phone_market	2
SELECT Order_ID, Order_Date FROM Orders WHERE Payment_Status = 'Paid' AND Shipping_Method = '快递' ORDER BY Order_Date ASC;	phone_market	3
SELECT Shipping_Address, COUNT(Order_ID) * 1000 AS Order_Count FROM Orders GROUP BY Shipping_Address ORDER BY Order_Count DESC LIMIT 5;	phone_market	4
SELECT Order_ID, (Discount / Tax) AS Discount_Tax_Ratio FROM Orders WHERE Tax > 0 ORDER BY Discount_Tax_Ratio DESC LIMIT 10;	phone_market	1
SELECT Order_ID, (SUM((Discount - avg_discount) * (Tax - avg_tax)) / (SQRT(SUM((Discount - avg_discount) * (Discount - avg_discount)) * SUM((Tax - avg_tax) * (Tax - avg_tax))))) AS Correlation_Coefficient FROM Orders, (SELECT AVG(Discount) AS avg_discount, AVG(Tax) AS avg_tax FROM Orders) AS avg_table GROUP BY Order_ID ORDER BY Correlation_Coefficient DESC;	phone_market	2
SELECT Order_ID, Discount FROM Orders WHERE Discount > 100 AND Tax < 50 ORDER BY Discount DESC;	phone_market	3
SELECT Order_ID, (Discount * 10000.0) / Tax AS Ratio FROM Orders ORDER BY Ratio DESC LIMIT 5;	phone_market	4
SELECT Brand, AVG(LENGTH(Phone_Name)) AS Avg_Name_Length FROM Phone GROUP BY Brand ORDER BY Avg_Name_Length DESC;	phone_market	1
SELECT Brand, STDEV(LENGTH(Phone_Name)) AS Name_Length_StdDev FROM Phone GROUP BY Brand ORDER BY Name_Length_StdDev DESC;	phone_market	2
SELECT Phone_ID, Phone_Name FROM Phone WHERE Brand = 'Apple' AND LENGTH(Phone_Name) > 10 ORDER BY Phone_Name ASC;	phone_market	3
SELECT Brand, AVG(LENGTH(Phone_Name)) * 1000 AS Avg_Name_Length FROM Phone GROUP BY Brand ORDER BY Avg_Name_Length DESC LIMIT 3;	phone_market	4
SELECT (Battery_Capacity * 3.7) / ((Screen_Size * 2.54 * Screen_Size * 2.54) * (substr(Screen_Resolution, 1, instr(Screen_Resolution, 'x') - 1) * substr(Screen_Resolution, instr(Screen_Resolution, 'x') + 1)) * 0.00001 + 5) AS Battery_Life_Hours FROM Phone WHERE Model = '某手机型号';	phone_market	1
WITH Price_Calculation AS (     SELECT          Phone_ID,          Price AS Initial_Price,          Price * POWER(1 - 0.20, 5) AS Price_After_5_Years,          Price * POWER(1 - 0.20, 3) AS Price_After_3_Years      FROM Phone      WHERE Model = '某手机型号' )  SELECT      pc.Phone_ID,      pc.Initial_Price,      pc.Price_After_5_Years,      pc.Price_After_3_Years,      pc.Price_After_3_Years * (1 - 0.15) AS Discounted_Price_For_Gold_Member  FROM Price_Calculation pc;	phone_market	2
SELECT date(Order_Date, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM Orders JOIN Order_Detail ON Orders.Order_ID = Order_Detail.Order_ID JOIN Phone ON Order_Detail.Phone_ID = Phone.Phone_ID WHERE Phone.Model = '某手机型号' AND Orders.Order_Date = '2021-06-01';	phone_market	3
WITH Phone_Power_Calculation AS (     SELECT Phone_ID, Battery_Capacity, Screen_Size, Screen_Resolution, Processor, Weight      FROM Phone      WHERE Model = '某手机型号' ), Screen_Power_Calculation AS (     SELECT Phone_ID,             (Screen_Size * 2.54 * Screen_Size * 2.54) AS Screen_Area,             (Screen_Resolution / 1000) * (Screen_Resolution / 1000) * 0.00001 AS Screen_Power      FROM Phone_Power_Calculation ), Total_Power_Calculation AS (     SELECT ppc.Phone_ID,             ppc.Battery_Capacity,             ppc.Processor,             ppc.Weight,             spc.Screen_Power,             (spc.Screen_Power + ppc.Processor) AS Total_Power      FROM Phone_Power_Calculation ppc      JOIN Screen_Power_Calculation spc ON ppc.Phone_ID = spc.Phone_ID ) SELECT tpc.Phone_ID,         (tpc.Battery_Capacity * 3.7 / tpc.Total_Power) AS Battery_Life_Hours,         ((tpc.Battery_Capacity * 3.7 / 1000) / tpc.Weight) AS Energy_Density_Wh_Kg  FROM Total_Power_Calculation tpc;	phone_market	4
SELECT (Screen_Size * 2.54 * Screen_Size * 2.54) * (substr(Screen_Resolution, 1, instr(Screen_Resolution, 'x') - 1) * substr(Screen_Resolution, instr(Screen_Resolution, 'x') + 1)) * 500 * 0.00001 AS Screen_Power_Consumption FROM Phone WHERE Model = '某手机型号';	phone_market	1
WITH Pixel_Density_Calculation AS (     SELECT          Phone_ID,          Screen_Size,          Screen_Resolution,          SQRT(POWER(SUBSTR(Screen_Resolution, 1, INSTR(Screen_Resolution, 'x') - 1), 2) +               POWER(SUBSTR(Screen_Resolution, INSTR(Screen_Resolution, 'x') + 1), 2)) / Screen_Size AS PPI      FROM Phone      WHERE Model = '某手机型号' )  SELECT      pdc.Phone_ID,      pdc.Screen_Size,      pdc.Screen_Resolution,      pdc.PPI AS Original_PPI,      SQRT(POWER(SUBSTR(pdc.Screen_Resolution, 1, INSTR(pdc.Screen_Resolution, 'x') - 1), 2) +           POWER(SUBSTR(pdc.Screen_Resolution, INSTR(pdc.Screen_Resolution, 'x') + 1), 2)) / 7.5 AS New_PPI  FROM Pixel_Density_Calculation pdc;	phone_market	2
SELECT Model, Screen_Size, CASE WHEN Screen_Size <= 6.5 THEN '适合单手操作' ELSE '不适合单手操作' END AS Single_Hand_Usability FROM Phone WHERE Model = '某手机型号' UNION ALL SELECT Model, 7.5 AS Screen_Size, CASE WHEN 7.5 <= 6.5 THEN '适合单手操作' ELSE '不适合单手操作' END AS Single_Hand_Usability FROM Phone WHERE Model = '某手机型号';	phone_market	3
WITH Screen_Power_Calculation AS (     SELECT          Phone_ID,          Screen_Size,          Screen_Resolution,          Battery_Capacity      FROM Phone      WHERE Model = '某手机型号' ),  Power_Usage AS (     SELECT          spc.Phone_ID,          (spc.Screen_Size * 2.54 * spc.Screen_Size * 2.54) AS Screen_Area,         (CAST(SUBSTR(spc.Screen_Resolution, 1, INSTR(spc.Screen_Resolution, 'x') - 1) AS REAL) *           CAST(SUBSTR(spc.Screen_Resolution, INSTR(spc.Screen_Resolution, 'x') + 1) AS REAL)) AS Total_Pixels,         (spc.Screen_Size * 2.54 * spc.Screen_Size * 2.54) *          (CAST(SUBSTR(spc.Screen_Resolution, 1, INSTR(spc.Screen_Resolution, 'x') - 1) AS REAL) *           CAST(SUBSTR(spc.Screen_Resolution, INSTR(spc.Screen_Resolution, 'x') + 1) AS REAL)) * 1000 * 0.00001 AS Screen_Power      FROM Screen_Power_Calculation spc )  SELECT      pu.Phone_ID,      pu.Screen_Power,      (spc.Battery_Capacity * 3.7 / pu.Screen_Power) AS Battery_Life_Hours  FROM Power_Usage pu  JOIN Screen_Power_Calculation spc ON pu.Phone_ID = spc.Phone_ID;	phone_market	4
SELECT (Screen_Size * 2.54 * Screen_Size * 2.54) * (SUBSTR(Screen_Resolution, 1, INSTR(Screen_Resolution, 'x') - 1) * SUBSTR(Screen_Resolution, INSTR(Screen_Resolution, 'x') + 1)) * 500 * 0.00001 AS Screen_Power_Consumption FROM Phone WHERE Model = '某手机型号';	phone_market	1
WITH Pixel_Density_Calculation AS (     SELECT          Phone_ID,          Screen_Size,          Screen_Resolution,          SQRT(POWER(SUBSTR(Screen_Resolution, 1, INSTR(Screen_Resolution, 'x') - 1), 2) + POWER(SUBSTR(Screen_Resolution, INSTR(Screen_Resolution, 'x') + 1), 2)) / Screen_Size AS PPI      FROM Phone      WHERE Model = '某手机型号' )  SELECT      pdc.Phone_ID,      pdc.Screen_Size,      pdc.Screen_Resolution,      pdc.PPI AS Original_PPI,      SQRT(POWER(SUBSTR(pdc.Screen_Resolution, 1, INSTR(pdc.Screen_Resolution, 'x') - 1), 2) + POWER(SUBSTR(pdc.Screen_Resolution, INSTR(pdc.Screen_Resolution, 'x') + 1), 2)) / 7.5 AS New_PPI  FROM Pixel_Density_Calculation pdc;	phone_market	2
SELECT Model, Screen_Size, Screen_Resolution, CASE WHEN (SQRT(POWER(substr(Screen_Resolution, 1, instr(Screen_Resolution, 'x')-1), 2) + POWER(substr(Screen_Resolution, instr(Screen_Resolution, 'x')+1), 2)) / Screen_Size) >= 300 THEN '适合日常使用' ELSE '不适合日常使用' END AS Clarity_Suitability FROM Phone WHERE Model = 'SM-S9010' UNION ALL SELECT Model, 7.5 AS Screen_Size, Screen_Resolution, CASE WHEN (SQRT(POWER(substr(Screen_Resolution, 1, instr(Screen_Resolution, 'x')-1), 2) + POWER(substr(Screen_Resolution, instr(Screen_Resolution, 'x')+1), 2)) / 7.5) >= 300 THEN '适合日常使用' ELSE '不适合日常使用' END AS Clarity_Suitability FROM Phone WHERE Model = 'SM-S9010';	phone_market	3
WITH Screen_Power_Calculation AS (         SELECT Phone_ID, Screen_Size, Screen_Resolution, Battery_Capacity          FROM Phone          WHERE Model = 'A2884'     ),      Power_Usage AS (         SELECT              spc.Phone_ID,              (spc.Screen_Size * 2.54 * spc.Screen_Size * 2.54) AS Screen_Area,              (CAST(substr(spc.Screen_Resolution, 1, instr(spc.Screen_Resolution, 'x') - 1) AS REAL) *               CAST(substr(spc.Screen_Resolution, instr(spc.Screen_Resolution, 'x') + 1) AS REAL)) AS Total_Pixels,              (spc.Screen_Size * 2.54 * spc.Screen_Size * 2.54) *              (CAST(substr(spc.Screen_Resolution, 1, instr(spc.Screen_Resolution, 'x') - 1) AS REAL) *               CAST(substr(spc.Screen_Resolution, instr(spc.Screen_Resolution, 'x') + 1) AS REAL)) * 1000 * 0.00001 AS Screen_Power          FROM Screen_Power_Calculation spc     )      SELECT          pu.Phone_ID,          pu.Screen_Power,          (spc.Battery_Capacity * 3.7 / pu.Screen_Power) AS Battery_Life_Hours      FROM Power_Usage pu      JOIN Screen_Power_Calculation spc ON pu.Phone_ID = spc.Phone_ID;	phone_market	4
SELECT Model, Storage_Capacity, RAM_Capacity, (400 / 500) * 100 AS Storage_Bandwidth_Utilization, (15 / 20) * 100 AS RAM_Bandwidth_Utilization FROM Phone WHERE Model = '2201123C';	phone_market	1
WITH Storage_Calculation AS (     SELECT          Phone_ID,          Storage_Capacity,          RAM_Capacity,          20 AS OS_Storage,          2 AS OS_RAM,          10 * 5 AS App_Storage,          10 * 0.5 AS App_RAM      FROM Phone      WHERE Model = 'NOH-AN00' )  SELECT      sc.Phone_ID,      (sc.Storage_Capacity - sc.OS_Storage - sc.App_Storage) AS Remaining_Storage,      (sc.RAM_Capacity - sc.OS_RAM - sc.App_RAM) AS Remaining_RAM  FROM Storage_Calculation sc;	phone_market	2
SELECT Model, Storage_Capacity, RAM_Capacity, (Storage_Capacity - 20 - (1000 * 5 + 500 * 10) / 1024) AS Remaining_Storage_Space FROM Phone WHERE Model = '某手机型号';	phone_market	3
WITH Storage_Calculation AS (     SELECT          Phone_ID,          Storage_Capacity,          RAM_Capacity,          50 AS OS_Storage,          8 AS OS_RAM,          100 * 10 AS App_Storage,          100 * 2 AS App_RAM      FROM Phone      WHERE Model = '某手机型号' ),  Bandwidth_Utilization AS (     SELECT          Phone_ID,          150 AS Actual_Speed,          200 AS Max_Bandwidth      FROM Phone      WHERE Model = '某手机型号' )  SELECT      sc.Phone_ID,      (sc.Storage_Capacity - sc.OS_Storage - sc.App_Storage) AS Remaining_Storage,      (sc.RAM_Capacity - sc.OS_RAM - sc.App_RAM) AS Remaining_RAM,      (bu.Actual_Speed * 1.0 / bu.Max_Bandwidth) AS Bandwidth_Utilization  FROM Storage_Calculation sc  JOIN Bandwidth_Utilization bu ON sc.Phone_ID = bu.Phone_ID;	phone_market	4
SELECT Model, Battery_Capacity, (Battery_Capacity * 3.7) / (2 + 3) AS Battery_Life_Hours FROM Phone WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210');	phone_market	1
WITH Charging_Time_Calculation AS (     SELECT          Phone_ID,          Battery_Capacity,          18 AS Charging_Power,          0.9 AS Charging_Efficiency,          3.7 AS Voltage      FROM Phone      WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210') ) SELECT      ctc.Phone_ID,      (ctc.Battery_Capacity * ctc.Voltage) / (ctc.Charging_Power * ctc.Charging_Efficiency) AS Charging_Time_Hours,      (ctc.Battery_Capacity * ctc.Voltage) / (30 * ctc.Charging_Efficiency) AS Charging_Time_Hours_With_Higher_Power  FROM Charging_Time_Calculation ctc;	phone_market	2
SELECT Model, Battery_Capacity, (Battery_Capacity * 3.7) / 1.5 AS Battery_Life_Hours FROM Phone WHERE Model = '某手机型号';	phone_market	3
WITH Power_Calculation AS (     SELECT          Phone_ID,          Battery_Capacity,          Weight,          200 AS Screen_Power,          300 AS Processor_Power,          3.7 AS Voltage      FROM Phone      WHERE Model = '某手机型号' )  SELECT      pc.Phone_ID,      (pc.Battery_Capacity * pc.Voltage) / (pc.Screen_Power + pc.Processor_Power) AS Battery_Life_Hours,      ((pc.Battery_Capacity * pc.Voltage) / 1000) / pc.Weight AS Energy_Density_Wh_Kg  FROM Power_Calculation pc;	phone_market	4
SELECT Model, Camera_Resolution, (Camera_Resolution * 1000000 * 1.4) AS Total_Sensor_Area, (1 / POWER(1.8, 2)) AS Light_Intake FROM Phone WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210');	phone_market	1
WITH Storage_Calculation AS (         SELECT              Phone_ID,              Storage_Capacity,              10 AS OS_Storage,              5 * 100 AS Photo_Storage          FROM Phone          WHERE Operating_System = 'iOS' AND Camera_Resolution = '12MP'     )      SELECT          sc.Phone_ID,          sc.Photo_Storage AS Total_Photo_Storage,          (sc.Storage_Capacity - sc.OS_Storage - sc.Photo_Storage / 1024) AS Remaining_Storage      FROM Storage_Calculation sc;	phone_market	2
SELECT Model, Camera_Resolution, (3840 * 2160) AS "4K_Pixel_Count", (3840 * 2160 * 100.0 / Camera_Resolution) AS "Used_Pixel_Percentage" FROM Phone WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210');	phone_market	3
WITH Storage_Calculation AS (     SELECT          Phone_ID,          Storage_Capacity,          100 AS OS_Storage,          50 * 1000 AS Photo_Storage      FROM Phone      WHERE Operating_System = 'Android' AND Camera_Resolution = '200MP' ),  Camera_Calculation AS (     SELECT          Phone_ID,          200000000 * 0.8 AS Total_Sensor_Area,          1 / (0.95 * 0.95) AS Light_Intake      FROM Phone      WHERE Operating_System = 'Android' AND Camera_Resolution = '200MP' )  SELECT      sc.Phone_ID,      sc.Photo_Storage / 1024 AS Total_Photo_Storage_GB,      (sc.Storage_Capacity - sc.OS_Storage - sc.Photo_Storage / 1024) AS Remaining_Storage,      cc.Total_Sensor_Area,      cc.Light_Intake  FROM Storage_Calculation sc  JOIN Camera_Calculation cc ON sc.Phone_ID = cc.Phone_ID;	phone_market	4
SELECT Model, Color, 348 AS Shell_Temperature_K FROM Phone WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210') AND Color = 'Black';	phone_market	1
WITH Price_Calculation AS (     SELECT Phone_ID, Color, Price, Processor      FROM Phone      WHERE Color = '黑色' AND Processor = 100000 ),  Silver_Price AS (     SELECT pc.Phone_ID, pc.Price * 1.1 AS Silver_Price      FROM Price_Calculation pc      WHERE pc.Color = '黑色' ),  Performance_Price AS (     SELECT sp.Phone_ID, sp.Silver_Price * POWER(1.05, (120000 - 100000) / 10000) AS Final_Price      FROM Silver_Price sp )  SELECT pp.Phone_ID, pp.Final_Price  FROM Performance_Price pp;	phone_market	2
SELECT Model, Color, Processor, Price, Price * 1.15 AS Golden_Price, Price * 1.15 * 0.8 AS Low_End_Golden_Price FROM Phone WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210') AND Color = 'Black' AND Processor = (SELECT Processor FROM Phone WHERE Processor = '高端型号');	phone_market	3
WITH Temperature_Calculation AS (     SELECT Phone_ID, Color, 100 AS Processor_Power, 0.95 AS Emissivity, 25 AS Ambient_Temperature      FROM Phone      WHERE Color = '彩虹色' ),  Price_Calculation AS (     SELECT Phone_ID, Color, Price      FROM Phone      WHERE Color = '黑色' AND Processor = 1000000 )  SELECT      tc.Phone_ID,      POWER((tc.Processor_Power / (tc.Emissivity * 5.67e-8 * 0.01)) + POWER(tc.Ambient_Temperature + 273, 4), 0.25) - 273 AS Surface_Temperature,      pc.Price * 1.5 AS Rainbow_Price  FROM Temperature_Calculation tc  JOIN Price_Calculation pc ON tc.Phone_ID = pc.Phone_ID;	phone_market	4
SELECT Model, Weight, (Weight + (1000 * 0.5)) * Stock_Quantity AS Total_Packaging_Weight FROM Phone WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210');	phone_market	1
WITH Weight_Adjustment AS (     SELECT          Phone_ID,          Weight,          Price,          Stock_Quantity,          (250 - Weight) * 10 AS Price_Increase_250,          (150 - Weight) * 10 AS Price_Decrease_150      FROM Phone      WHERE Model = '某手机型号' )  SELECT      wa.Phone_ID,      wa.Price + wa.Price_Increase_250 AS New_Price_250,      (wa.Price + wa.Price_Increase_250) * wa.Stock_Quantity AS Total_Value_250,      wa.Price + wa.Price_Decrease_150 AS New_Price_150,      (wa.Price + wa.Price_Decrease_150) * wa.Stock_Quantity AS Total_Value_150  FROM Weight_Adjustment wa;	phone_market	2
SELECT Model, Price, Stock_Quantity, Stock_Quantity + ((6000 - Price) / 100 * 10) AS Stock_At_6000, Stock_Quantity + ((4000 - Price) / 100 * 10) AS Stock_At_4000 FROM Phone WHERE Model IN ('A2884', 'SM-S9010', '2201123C', 'NOH-AN00', 'NE2210');	phone_market	3
WITH Weight_Adjustment AS (     SELECT          Phone_ID,          Weight,          Price,          Stock_Quantity,          (2000 - Weight) * 100 AS Price_Increase_2000,          (500 - Weight) * 100 AS Price_Decrease_500      FROM Phone      WHERE Model = '某手机型号' ),  Stock_Adjustment AS (     SELECT          wa.Phone_ID,          wa.Price + wa.Price_Increase_2000 AS New_Price_2000,          wa.Stock_Quantity + ((wa.Price + wa.Price_Increase_2000 - wa.Price) / 100 * -100) AS New_Stock_2000,          wa.Price + wa.Price_Decrease_500 AS New_Price_500,          wa.Stock_Quantity + ((wa.Price + wa.Price_Decrease_500 - wa.Price) / 100 * -100) AS New_Stock_500      FROM Weight_Adjustment wa )  SELECT      sa.Phone_ID,      sa.New_Price_2000,      sa.New_Stock_2000,      sa.New_Price_500,      sa.New_Stock_500  FROM Stock_Adjustment sa;	phone_market	4
SELECT Orders.Order_ID, SUM(Order_Detail.Quantity * Phone.Weight / 1000) AS Total_Weight, SUM(Order_Detail.Quantity * Phone.Weight / 1000) * 10 AS Total_Shipping_Cost FROM Orders JOIN Order_Detail ON Orders.Order_ID = Order_Detail.Order_ID JOIN Phone ON Order_Detail.Phone_ID = Phone.Phone_ID WHERE Orders.Shipping_Method = '快递' GROUP BY Orders.Order_ID;	phone_market	1
WITH Order_Calculation AS (     SELECT          o.Order_ID,          o.Customer_ID,          SUM(od.Quantity * od.Unit_Price) AS Total_Amount,          c.Membership_Level      FROM Orders o      JOIN Order_Detail od ON o.Order_ID = od.Order_ID      JOIN Customer c ON o.Customer_ID = c.Customer_ID      WHERE c.Membership_Level = '黄金'      GROUP BY o.Order_ID )  SELECT      oc.Order_ID,      oc.Total_Amount,      oc.Total_Amount * 0.1 AS Discount,      (oc.Total_Amount - oc.Total_Amount * 0.1) * 0.05 AS Tax,      oc.Total_Amount - (oc.Total_Amount * 0.1) + ((oc.Total_Amount - oc.Total_Amount * 0.1) * 0.05) AS Final_Amount  FROM Order_Calculation oc;	phone_market	2
SELECT Order_ID, datetime(Created_at, '+2 days') AS Earliest_Delivery_Date FROM Orders WHERE Order_Status = 'Shipped' AND Shipping_Method = '快递' AND Shipping_Address LIKE '%北京市%' AND Created_at = '2023-10-01';	phone_market	3
WITH Shipping_Calculation AS (     SELECT          o.Order_ID,          o.Customer_ID,          o.Order_Date,          o.Total_Amount,          o.Shipping_Method,          o.Shipping_Address,          c.Membership_Level,          SUM(p.Weight * od.Quantity) / 1000 AS Total_Weight      FROM Orders o      JOIN Order_Detail od ON o.Order_ID = od.Order_ID      JOIN Phone p ON od.Phone_ID = p.Phone_ID      JOIN Customer c ON o.Customer_ID = c.Customer_ID      WHERE c.Membership_Level = '钻石'      GROUP BY o.Order_ID )  SELECT      sc.Order_ID,      sc.Total_Weight * 10 AS Total_Shipping_Cost,      sc.Total_Amount - (sc.Total_Amount * 0.2) + ((sc.Total_Amount - sc.Total_Amount * 0.2) * 0.05) AS Final_Amount,      date(sc.Order_Date, '+10 days') AS Earliest_Delivery_Date  FROM Shipping_Calculation sc;	phone_market	4
SELECT Train_ID, Train_Name, Passenger_Capacity_Open, Design_Speed, 0.5 * 1.225 * POWER(Design_Speed, 2) * 0.8 * Passenger_Capacity_Open AS Air_Resistance FROM ConventionalTrains WHERE Passenger_Capacity_Open IN (100, 200) AND Design_Speed = 120;	railway	1
SELECT Train_ID, Train_Name, (Passenger_Capacity_Open + Passenger_Capacity_Closed) * 70.0 / (Weight * 1000) AS Passenger_Weight_Ratio FROM ConventionalTrains;	railway	2
SELECT Train_ID, Train_Name, Passenger_Capacity_Open + Passenger_Capacity_Closed AS Total_Passenger_Capacity FROM ConventionalTrains WHERE Passenger_Capacity_Open = 100 AND Passenger_Capacity_Closed = 150;	railway	3
SELECT Train_ID, Train_Name, Passenger_Capacity_Open, Passenger_Capacity_Closed, Weight, ((Passenger_Capacity_Open + Passenger_Capacity_Closed) * 70.0 / 1000.0) / Weight AS Passenger_Weight_Ratio FROM ConventionalTrains WHERE Passenger_Capacity_Open = 1000 AND Passenger_Capacity_Closed = 1500 AND Weight = 80;	railway	4
SELECT Train_ID, Train_Name, Track_Gauge, Weight, (Track_Gauge / 1000.0) * (Weight / 10.0) AS Stability_Coefficient FROM ConventionalTrains WHERE (Track_Gauge = 1435 AND Weight = 80) OR (Track_Gauge = 1435 AND Weight = 100) OR (Track_Gauge = 1520 AND Weight = 80) OR (Track_Gauge = 1520 AND Weight = 100);	railway	1
SELECT Train_ID, Train_Name,         Weight / (Track_Gauge / 1000.0) AS Pressure_1435_80,         Weight / (Track_Gauge / 1000.0) AS Pressure_1435_100,         Weight / (Track_Gauge / 1000.0) AS Pressure_1520_80,         Weight / (Track_Gauge / 1000.0) AS Pressure_1520_100  FROM ConventionalTrains;	railway	2
SELECT Train_ID, Train_Name, (Track_Gauge / 1000.0) * (Weight / 10.0) AS Stability_Score FROM ConventionalTrains WHERE Track_Gauge = 1435 AND Weight = 80;	railway	3
UPDATE ConventionalTrains  SET Track_Gauge = 2500  WHERE Track_Gauge = 2000 AND Weight = 200  RETURNING Train_ID, Train_Name, Track_Gauge, Weight, (Track_Gauge / 1000.0) * (Weight / 10.0) AS Stability_Coefficient;	railway	4
SELECT Train_ID, Train_Name, Design_Speed, (POWER(Design_Speed * 1000.0 / 3600.0, 2) / (2.0 * 1.5)) AS Braking_Distance FROM ConventionalTrains WHERE Design_Speed = 300;	railway	1
SELECT Weight + (Passenger_Capacity_Open + Passenger_Capacity_Closed) * 70 / 1000 AS Total_Weight, (Weight + (Passenger_Capacity_Open + Passenger_Capacity_Closed) * 70 / 1000) / (50 * 0.06) AS Pressure FROM ConventionalTrains WHERE Weight = 600;	railway	2
SELECT Floor_Material, COUNT(*) AS UsageCount, AVG(CASE WHEN Floor_Fire_Resistance = 'high' THEN 3 WHEN Floor_Fire_Resistance = 'medium' THEN 2 ELSE 1 END) AS FireScore, AVG(CASE WHEN Floor_Slip_Resistance = 'high' THEN 3 WHEN Floor_Slip_Resistance = 'medium' THEN 2 ELSE 1 END) AS SlipScore FROM DoorsAndCompartments WHERE Train_ID IN (SELECT Train_ID FROM HighSpeed_Trains) GROUP BY Floor_Material ORDER BY FireScore DESC, SlipScore DESC LIMIT 1;	railway	3
SELECT Train_ID, Train_Name, Design_Speed, Floor_Material, Weight, ((Weight + 300) * 9.81 * 1000) / 150 AS Stress FROM ConventionalTrains WHERE Design_Speed = 1500 AND Floor_Material = '普通木材' AND Weight = 1500;	railway	4
SELECT Train_ID, Train_Name, Door_Width, Door_Height, (0.5 * 1.225 * POWER(200 * 1000 / 3600, 2) * 0.8 * (Door_Width / 1000.0 * Door_Height / 1000.0)) AS Air_Resistance_Force FROM ConventionalTrains WHERE Door_Width = 1200 AND Door_Height = 2200;	railway	1
SELECT (Door_Width/1000.0 * Door_Height/1000.0) AS Door_Area, ((Door_Width/1000.0 * Door_Height/1000.0)/0.2) * (30/2) AS Passenger_Flow FROM ConventionalTrains WHERE Door_Width = 1000 AND Door_Height = 2000;	railway	2
SELECT Door_Width, Door_Height, (Door_Width * Door_Height) AS DoorArea, COUNT(*) AS DesignCount FROM ConventionalTrains GROUP BY Door_Width, Door_Height ORDER BY DoorArea DESC, DesignCount DESC LIMIT 1;	railway	3
SELECT Train_ID, Train_Name, Door_Width, Door_Height, 0.5 * 1.225 * POWER(500/3.6, 2) * 0.8 AS Wind_Pressure FROM ConventionalTrains WHERE Door_Width = 3000 AND Door_Height = 3000;	railway	4
SELECT Train_ID, Train_Name, Max_Speed, Total_Power, (Total_Power * 1000) / (Max_Speed * 1000 / 3600 * 0.9) AS Traction_Force FROM DieselMultipleUnits WHERE Max_Speed = 160 AND Total_Power = 3000;	railway	1
SELECT Passenger_Capacity / 18 AS Avg_Passenger_Per_Compartment FROM DieselMultipleUnits WHERE Formation = '18k-22' AND Passenger_Capacity = 500;	railway	2
SELECT Formation, COUNT(*) AS FormationCount, AVG(Total_Power) AS AvgPower, AVG(Max_Speed) AS AvgSpeed FROM DieselMultipleUnits GROUP BY Formation ORDER BY AvgPower DESC, AvgSpeed DESC;	railway	3
SELECT Train_ID, Train_Name, Formation, Passenger_Capacity, (Passenger_Capacity / 30) AS Average_Passenger_Per_Compartment FROM DieselMultipleUnits WHERE Formation = '30k-60' AND Passenger_Capacity = 8000;	railway	4
SELECT Train_ID, Train_Name, Passenger_Capacity, (Passenger_Capacity * 70) AS Total_Weight_Increase FROM DieselMultipleUnits WHERE Passenger_Capacity = 800;	railway	1
SELECT Fuel_Efficiency * 1000 AS Total_Fuel_Consumption FROM DieselMultipleUnits WHERE Total_Power = 5000 AND Fuel_Type = 'diesel' AND Fuel_Efficiency = 2.5;	railway	2
SELECT Passenger_Capacity, AVG(Door_Width) AS AvgDoorWidth, COUNT(DISTINCT Compartment_ID) AS DoorCount FROM DieselMultipleUnits JOIN DoorsAndCompartments ON DieselMultipleUnits.Train_ID = DoorsAndCompartments.Train_ID GROUP BY Passenger_Capacity ORDER BY Passenger_Capacity DESC;	railway	3
SELECT Train_ID, Train_Name, Formation, Passenger_Capacity, (Passenger_Capacity / 50) AS Average_Passenger_Per_Compartment FROM DieselMultipleUnits WHERE Formation = '50k-100' AND Passenger_Capacity = 5000;	railway	4
SELECT Engine_Type, AVG(Fuel_Efficiency) AS Avg_Fuel_Efficiency, MIN(Emission_Level) AS Min_Emission_Level FROM DieselMultipleUnits GROUP BY Engine_Type ORDER BY Avg_Fuel_Efficiency ASC, Min_Emission_Level ASC LIMIT 1;	railway	1
SELECT Fuel_Type, MAX(Total_Power / Fuel_Efficiency) AS Max_Ratio FROM DieselMultipleUnits WHERE Fuel_Type IN ('diesel', 'biclue') GROUP BY Fuel_Type ORDER BY Max_Ratio DESC LIMIT 1;	railway	2
SELECT Engine_Type, AVG(Fuel_Efficiency) AS AvgFuelEfficiency, COUNT(*) AS EngineCount FROM DieselMultipleUnits WHERE Emission_Level = 'low' GROUP BY Engine_Type ORDER BY AvgFuelEfficiency DESC LIMIT 1;	railway	3
SELECT Train_ID, Train_Name, Total_Power, Fuel_Efficiency, (Total_Power / Fuel_Efficiency) AS Power_Efficiency_Ratio, Emission_Level FROM DieselMultipleUnits WHERE Fuel_Efficiency = 1000;	railway	4
SELECT 'ConventionalTrains' AS Train_Type, 0.5 * 800 * (Design_Speed * 1000 / 3600) * (Design_Speed * 1000 / 3600) AS Kinetic_Energy FROM ConventionalTrains UNION ALL SELECT 'DieselMultipleUnits' AS Train_Type, 0.5 * 1000 * (Max_Speed * 1000 / 3600) * (Max_Speed * 1000 / 3600) AS Kinetic_Energy FROM DieselMultipleUnits;	railway	1
WITH ParamCount AS (     SELECT 'ConventionalTrains' AS Train_Type,             LENGTH(Description) - LENGTH(REPLACE(Description, ';', '')) + 1 AS Param_Count      FROM ConventionalTrains      UNION ALL      SELECT 'DieselMultipleUnits' AS Train_Type,             LENGTH(Description) - LENGTH(REPLACE(Description, ';', '')) + 1 AS Param_Count      FROM DieselMultipleUnits )  SELECT Train_Type, MAX(Param_Count) AS Max_Param_Count  FROM ParamCount  GROUP BY Train_Type  ORDER BY Max_Param_Count DESC  LIMIT 1;	railway	2
SELECT 'ConventionalTrains' AS TrainType, AVG(Passenger_Capacity_Open + Passenger_Capacity_Closed) AS AvgPassengerCapacity, AVG(Design_Speed) AS AvgMaxSpeed FROM ConventionalTrains UNION ALL SELECT 'DieselMultipleUnits' AS TrainType, AVG(Passenger_Capacity) AS AvgPassengerCapacity, AVG(Max_Speed) AS AvgMaxSpeed FROM DieselMultipleUnits ORDER BY AvgPassengerCapacity DESC, AvgMaxSpeed DESC LIMIT 1;	railway	3
SELECT Train_ID, Train_Name, Weight, Design_Speed, 0.5 * Weight * POWER(Design_Speed / 3.6, 2) AS Kinetic_Energy FROM ConventionalTrains WHERE Design_Speed = 1000;	railway	4
SELECT Compartment_ID, Train_ID, Door_Width, Door_Height, (Door_Width * Door_Height) AS Door_Area FROM DoorsAndCompartments ORDER BY Door_Area DESC LIMIT 1;	railway	1
WITH High_Slip_Resistance AS (     SELECT COUNT(*) AS High_Slip_Count      FROM DoorsAndCompartments      WHERE Floor_Slip_Resistance = 'high' ),  High_Slip_And_Safety AS (     SELECT COUNT(*) AS High_Slip_And_Safety_Count      FROM DoorsAndCompartments      WHERE Floor_Slip_Resistance = 'high' AND Window_Safety_Level = 'high' )  SELECT High_Slip_Count, High_Slip_And_Safety_Count,         (High_Slip_And_Safety_Count * 1.0 / High_Slip_Count) AS Safety_Ratio  FROM High_Slip_Resistance, High_Slip_And_Safety;	railway	2
SELECT Floor_Material, COUNT(*) AS MaterialCount FROM DoorsAndCompartments WHERE Floor_Water_Resistance = 1 GROUP BY Floor_Material ORDER BY MaterialCount DESC LIMIT 1;	railway	3
SELECT Compartment_ID, Train_ID, Door_Width, Door_Height, (Door_Width * Door_Height) AS Door_Area FROM DoorsAndCompartments WHERE Door_Width = 10000;	railway	4
SELECT Compartment_ID, Train_ID, Window_Material, Window_Safety_Level, (0.5 * 1000 * POWER(300 * 1000 / 3600, 2) / (Door_Width * Door_Height)) AS Impact_Force FROM DoorsAndCompartments WHERE Window_Material = '钢化玻璃';	railway	1
WITH High_Safety AS (   SELECT COUNT(*) AS High_Safety_Count    FROM DoorsAndCompartments    WHERE Window_Safety_Level = 'high' ),  High_Safety_And_Tempered AS (   SELECT COUNT(*) AS High_Safety_And_Tempered_Count    FROM DoorsAndCompartments    WHERE Window_Safety_Level = 'high' AND Window_Material = '钢化玻璃' )  SELECT    High_Safety_Count,    High_Safety_And_Tempered_Count,    (High_Safety_And_Tempered_Count * 1.0 / High_Safety_Count) AS Tempered_Ratio  FROM High_Safety, High_Safety_And_Tempered;	railway	2
SELECT Window_Material, COUNT(*) AS MaterialCount FROM DoorsAndCompartments WHERE Window_Safety_Level = 'high' GROUP BY Window_Material ORDER BY MaterialCount DESC LIMIT 1;	railway	3
SELECT COUNT(CASE WHEN Window_Material = '钢化玻璃' THEN 1 END) * 1.0 / COUNT(*) AS Proportion FROM DoorsAndCompartments WHERE Window_Safety_Level = 'high';	railway	4
SELECT Compartment_ID, Train_ID, Floor_Material, Floor_Slip_Resistance, CASE WHEN Floor_Slip_Resistance = 'high' THEN 3 * 0.5 WHEN Floor_Slip_Resistance = 'medium' THEN 2 * 0.5 WHEN Floor_Slip_Resistance = 'low' THEN 1 * 0.5 END AS Friction_Coefficient FROM DoorsAndCompartments WHERE Floor_Material = '橡胶';	railway	1
WITH High_Slip_Resistance AS (     SELECT COUNT(*) AS High_Slip_Count      FROM DoorsAndCompartments      WHERE Floor_Slip_Resistance = 'high' ),  High_Slip_And_Rubber AS (     SELECT COUNT(*) AS High_Slip_And_Rubber_Count      FROM DoorsAndCompartments      WHERE Floor_Slip_Resistance = 'high' AND Floor_Material = '橡胶' )  SELECT High_Slip_Count, High_Slip_And_Rubber_Count,         (High_Slip_And_Rubber_Count * 1.0 / High_Slip_Count) AS Rubber_Ratio  FROM High_Slip_Resistance, High_Slip_And_Rubber;	railway	2
SELECT Floor_Material, COUNT(*) AS MaterialCount FROM DoorsAndCompartments WHERE Floor_Slip_Resistance = 'high' GROUP BY Floor_Material ORDER BY MaterialCount DESC LIMIT 1;	railway	3
SELECT COUNT(CASE WHEN Floor_Material = '橡胶' THEN 1 END) * 1.0 / COUNT(*) AS Proportion FROM DoorsAndCompartments WHERE Floor_Slip_Resistance = 'high';	railway	4
SELECT Train_ID, Train_Name, Max_Speed, Air_Resistance, (0.5 * 1.225 * POWER(Max_Speed * 1000 / 3600, 2) * (Air_Resistance / 100) * 10) AS Air_Resistance_Force FROM HighSpeed_Trains;	railway	1
SELECT hs.Train_Name, hs.Blocking_Ratio * ts.Tunnel_Cross_Section AS Blocking_Product  FROM HighSpeed_Trains hs  JOIN TrackSystems ts ON hs.Train_ID = ts.Track_ID  ORDER BY Blocking_Product DESC  LIMIT 3;	railway	2
SELECT AVG(Operating_Speed) AS Avg_Operating_Speed FROM HighSpeed_Trains WHERE Sealing_Requirement = 'high';	railway	3
SELECT Train_ID, Train_Name, 0.5 * (3 * Static_Load_Capacity) * POWER(1000 * 1000.0 / 3600, 2) AS Kinetic_Energy FROM HighSpeed_Trains ORDER BY Kinetic_Energy DESC LIMIT 5;	railway	4
SELECT Train_ID, Train_Name, Max_Speed, (0.5 * 1.225 * POWER(Max_Speed * 1000.0 / 3600.0, 3) * 0.8 * 12) AS Air_Resistance_Power FROM HighSpeed_Trains;	railway	1
SELECT Train_Name, Max_Speed / Operating_Speed AS Speed_Ratio FROM HighSpeed_Trains ORDER BY Speed_Ratio ASC LIMIT 3;	railway	2
SELECT AVG(Dynamic_Load_Capacity) AS Avg_Dynamic_Load_Capacity FROM HighSpeed_Trains WHERE Max_Speed < 200;	railway	3
SELECT Train_ID, Train_Name, (10 - 1) * 1.225 * 287 * 293 / 5000 AS Pressure_Change FROM HighSpeed_Trains;	railway	4
SELECT Train_ID, Train_Name, Operating_Speed, (0.5 * 1.225 * POWER(Operating_Speed * 1000.0 / 3600.0, 3) * 0.8 * 12) AS Air_Resistance_Power FROM HighSpeed_Trains;	railway	1
SELECT Train_Name, Operating_Speed * (Air_Resistance / 100.0) AS Speed_AirResistance_Product FROM HighSpeed_Trains ORDER BY Speed_AirResistance_Product ASC LIMIT 5;	railway	2
SELECT AVG(Static_Load_Capacity) AS Avg_Static_Load_Capacity FROM HighSpeed_Trains WHERE Operating_Speed > 300;	railway	3
SELECT Train_ID, Train_Name, 0.5 * (5 * Static_Load_Capacity) * POWER((1000 * 1000) / 3600.0, 2) AS Kinetic_Energy FROM HighSpeed_Trains ORDER BY Kinetic_Energy DESC LIMIT 5;	railway	4
SELECT Train_ID, Train_Name, Operating_Speed, Air_Resistance, (0.5 * 1.225 * POWER(Operating_Speed * 1000.0 / 3600.0, 2) * (Air_Resistance / 100.0) * 10) AS Air_Resistance_Force FROM HighSpeed_Trains;	railway	1
SELECT Train_Name, (Air_Resistance / 100.0) * Head_Length AS AirResistance_HeadLength_Product FROM HighSpeed_Trains ORDER BY AirResistance_HeadLength_Product DESC LIMIT 5;	railway	2
SELECT AVG(Air_Resistance) AS Avg_Air_Resistance FROM HighSpeed_Trains WHERE Body_Structure_Material = '铝合金';	railway	3
SELECT Train_ID, Train_Name, SQRT(2 * (10 * Static_Load_Capacity * 1000 * 0.1) / (1.225 * 1 * 10)) AS Operating_Speed FROM HighSpeed_Trains ORDER BY Operating_Speed DESC LIMIT 5;	railway	4
SELECT Train_ID, Train_Name, Operating_Speed, Air_Resistance, CASE WHEN Sealing_Requirement = 'high' THEN Air_Resistance * 0.9 ELSE Air_Resistance END AS Adjusted_Air_Resistance FROM HighSpeed_Trains;	railway	1
SELECT Train_Name, CASE WHEN Sealing_Requirement = 'high' THEN 1 WHEN Sealing_Requirement = 'medium' THEN 2 ELSE 3 END / Air_Resistance AS Sealing_AirResistance_Ratio FROM HighSpeed_Trains ORDER BY Sealing_AirResistance_Ratio ASC LIMIT 5;	railway	2
SELECT AVG(Operating_Speed) AS Avg_Operating_Speed FROM HighSpeed_Trains WHERE Sealing_Requirement = 'high';	railway	3
SELECT Train_ID, Train_Name, Air_Resistance * 0.5 AS Adjusted_Air_Resistance FROM HighSpeed_Trains WHERE Sealing_Requirement = 'ultra_high' ORDER BY Adjusted_Air_Resistance ASC LIMIT 5;	railway	4
SELECT Train_ID, Train_Name, Operating_Speed, Air_Resistance, CASE WHEN Pressure_Wave_Optimization = '是' THEN Air_Resistance * 0.95 ELSE Air_Resistance END AS Adjusted_Air_Resistance FROM HighSpeed_Trains;	railway	1
SELECT Pressure_Wave_Optimization, AVG(Air_Resistance) AS Avg_Air_Resistance, AVG(CASE WHEN Pressure_Wave_Optimization = '是' THEN 1.0 ELSE 2.0 END / Air_Resistance) AS Avg_PressureWave_AirResistance_Ratio FROM HighSpeed_Trains GROUP BY Pressure_Wave_Optimization;	railway	2
SELECT AVG(Operating_Speed) AS Avg_Operating_Speed FROM HighSpeed_Trains WHERE Pressure_Wave_Optimization = '是';	railway	3
SELECT Train_ID, Train_Name, Air_Resistance * 0.8 AS Adjusted_Air_Resistance  FROM HighSpeed_Trains  WHERE Pressure_Wave_Optimization = '极佳'  ORDER BY Adjusted_Air_Resistance ASC  LIMIT 5;	railway	4
SELECT H.Train_ID AS HighSpeed_Train_ID, H.Train_Name AS HighSpeed_Train_Name, H.Operating_Speed, H.Air_Resistance, (0.5 * 1.225 * POWER(H.Operating_Speed * 1000.0 / 3600.0, 2) * (H.Air_Resistance / 100.0) * 10) AS HighSpeed_Air_Resistance, C.Train_ID AS Conventional_Train_ID, C.Train_Name AS Conventional_Train_Name, C.Design_Speed, (0.5 * 1.225 * POWER(C.Design_Speed * 1000.0 / 3600.0, 2) * 0.8 * 10) AS Conventional_Air_Resistance, ABS((0.5 * 1.225 * POWER(H.Operating_Speed * 1000.0 / 3600.0, 2) * (H.Air_Resistance / 100.0) * 10) - (0.5 * 1.225 * POWER(C.Design_Speed * 1000.0 / 3600.0, 2) * 0.8 * 10)) AS Air_Resistance_Difference FROM HighSpeed_Trains H, ConventionalTrains C;	railway	1
SELECT 'HighSpeed' AS Train_Type, AVG(d.Door_Width * d.Door_Height) AS Avg_Door_Product FROM HighSpeed_Trains hs JOIN DoorsAndCompartments d ON hs.Train_ID = d.Train_ID GROUP BY Train_Type UNION ALL SELECT 'Conventional' AS Train_Type, AVG(d.Door_Width * d.Door_Height) AS Avg_Door_Product FROM ConventionalTrains ct JOIN DoorsAndCompartments d ON ct.Train_ID = d.Train_ID GROUP BY Train_Type;	railway	2
SELECT AVG(hs.Operating_Speed) AS Avg_Operating_Speed FROM HighSpeed_Trains hs JOIN DoorsAndCompartments dc ON hs.Train_ID = dc.Train_ID WHERE dc.Floor_Material = '铝合金' UNION ALL SELECT AVG(ct.Design_Speed) AS Avg_Operating_Speed FROM ConventionalTrains ct JOIN DoorsAndCompartments dc ON ct.Train_ID = dc.Train_ID WHERE dc.Floor_Material = '铝合金';	railway	3
SELECT t.Train_ID, t.Train_Name, d.Door_Width * d.Door_Height AS Door_Area, 'HighSpeed_Trains' AS Train_Type FROM HighSpeed_Trains t JOIN DoorsAndCompartments d ON t.Train_ID = d.Train_ID WHERE d.Door_Width = 10000 AND d.Door_Height = 10000 UNION ALL SELECT t.Train_ID, t.Train_Name, d.Door_Width * d.Door_Height AS Door_Area, 'ConventionalTrains' AS Train_Type FROM ConventionalTrains t JOIN DoorsAndCompartments d ON t.Train_ID = d.Train_ID WHERE d.Door_Width = 10000 AND d.Door_Height = 10000 UNION ALL SELECT t.Train_ID, t.Train_Name, d.Door_Width * d.Door_Height AS Door_Area, 'DieselMultipleUnits' AS Train_Type FROM DieselMultipleUnits t JOIN DoorsAndCompartments d ON t.Train_ID = d.Train_ID WHERE d.Door_Width = 10000 AND d.Door_Height = 10000 UNION ALL SELECT t.Train_ID, t.Train_Name, d.Door_Width * d.Door_Height AS Door_Area, 'UrbanRail_Trains' AS Train_Type FROM UrbanRail_Trains t JOIN DoorsAndCompartments d ON t.Train_ID = d.Train_ID WHERE d.Door_Width = 10000 AND d.Door_Height = 10000 ORDER BY Door_Area DESC LIMIT 5;	railway	4
SELECT Train_ID, Train_Name, Operating_Speed, Static_Load_Capacity, (2 * Static_Load_Capacity * 1000 * 0.1 * Operating_Speed * 1000 / 3600) / 0.9 AS Traction_Power FROM HighSpeed_Trains;	railway	1
SELECT tp.Parameter_Name, AVG(dmu.Total_Power / hs.Operating_Speed) AS Avg_Power_Speed_Ratio FROM HighSpeed_Trains hs JOIN DieselMultipleUnits dmu ON hs.Train_ID = dmu.Train_ID JOIN TechnicalParameters tp ON hs.Train_ID = tp.Train_ID GROUP BY tp.Parameter_Name;	railway	2
SELECT AVG(hs.Operating_Speed) AS Avg_Operating_Speed FROM HighSpeed_Trains hs JOIN TechnicalParameters tp ON hs.Train_ID = tp.Train_ID WHERE tp.Parameter_Name = 'Total_Power' AND CAST(tp.Parameter_Value AS REAL) > 10000;	railway	3
SELECT t.Train_ID, t.Train_Name, (1000000 * 0.9) / (2 * COALESCE(t.Static_Load_Capacity, 100) * 1000 * 0.1) AS Operating_Speed, p.Parameter_Name FROM HighSpeed_Trains t JOIN TechnicalParameters p ON t.Train_ID = p.Train_ID WHERE p.Parameter_Name = '牵引功率' UNION ALL SELECT t.Train_ID, t.Train_Name, (1000000 * 0.9) / (2 * 100 * 1000 * 0.1) AS Operating_Speed, p.Parameter_Name FROM ConventionalTrains t JOIN TechnicalParameters p ON t.Train_ID = p.Train_ID WHERE p.Parameter_Name = '牵引功率' UNION ALL SELECT t.Train_ID, t.Train_Name, (1000000 * 0.9) / (2 * 100 * 1000 * 0.1) AS Operating_Speed, p.Parameter_Name FROM DieselMultipleUnits t JOIN TechnicalParameters p ON t.Train_ID = p.Train_ID WHERE p.Parameter_Name = '牵引功率' UNION ALL SELECT t.Train_ID, t.Train_Name, (1000000 * 0.9) / (2 * 100 * 1000 * 0.1) AS Operating_Speed, p.Parameter_Name FROM UrbanRail_Trains t JOIN TechnicalParameters p ON t.Train_ID = p.Train_ID WHERE p.Parameter_Name = '牵引功率' ORDER BY Operating_Speed DESC LIMIT 5;	railway	4
SELECT Track_Type, Max_Speed, Tunnel_Cross_Section, 0.5 * (100 * Tunnel_Cross_Section) * POWER(Max_Speed, 2) AS Kinetic_Energy FROM TrackSystems;	railway	1
SELECT Track_Type, AVG(Maintenance_Interval / Tunnel_Cross_Section) AS Maintenance_Ratio FROM TrackSystems GROUP BY Track_Type;	railway	2
SELECT Track_Type FROM TrackSystems WHERE Track_Type = 'high_speed' AND Track_Gauge >= 1435;	railway	3
SELECT Track_ID, Track_Type, 0.9 * POWER(Max_Speed, 2) AS Air_Resistance FROM TrackSystems WHERE Max_Speed = 10000;	railway	4
SELECT Track_Material, Maintenance_Interval, (1.0 / (Maintenance_Interval * CASE WHEN Track_Material = 'steel' THEN 10 WHEN Track_Material = 'concrete' THEN 5 ELSE 1 END)) AS Wear_Rate FROM TrackSystems;	railway	1
SELECT Track_Type, Track_Material, AVG(Maintenance_Interval) AS Avg_Maintenance_Interval FROM TrackSystems GROUP BY Track_Type, Track_Material;	railway	2
SELECT Track_Material FROM TrackSystems WHERE Maintenance_Interval <= 30 AND Track_Material IN ('钢轨', '混凝土轨');	railway	3
SELECT Track_ID, Track_Type, '无穷大' AS Wear_Rate FROM TrackSystems WHERE Maintenance_Interval = 0;	railway	4
SELECT Train_ID, Train_Name, Body_Strength_Rating, Max_Speed, 0.5 * 100000 * (Max_Speed * Max_Speed) AS Kinetic_Energy FROM UrbanRail_Trains;	railway	1
SELECT Body_Strength_Rating, AVG(Max_Speed) AS Avg_Max_Speed FROM UrbanRail_Trains GROUP BY Body_Strength_Rating;	railway	2
SELECT Body_Strength_Rating FROM UrbanRail_Trains WHERE Max_Speed >= 100 AND Body_Strength_Rating = 'high';	railway	3
SELECT Train_ID, Train_Name, 0.5 * 1000000 * POWER(Max_Speed, 2) AS Kinetic_Energy FROM UrbanRail_Trains WHERE Max_Speed = 10000;	railway	4
SELECT U.Window_Material, U.Body_Strength_Rating, (1 * TP.Parameter_Value) AS Calculated_Body_Strength_RATING FROM UrbanRail_Trains U JOIN TechnicalParameters TP ON U.Train_ID = TP.Train_ID WHERE TP.Parameter_Name = 'Window_Strength';	railway	1
SELECT Window_Material, AVG(Body_Strength_Rating) AS Avg_Body_Strength_Rating FROM UrbanRail_Trains GROUP BY Window_Material;	railway	2
SELECT Window_Material FROM UrbanRail_Trains WHERE Body_Strength_Rating = 'high' AND Window_Material IN ('钢化玻璃', '复合材料');	railway	3
SELECT Train_ID, Train_Name, 0.01 * 100000 AS Body_Strength_Rating FROM UrbanRail_Trains WHERE Window_Material = '100000 MPa';	railway	4
SELECT Train_ID, Train_Name, Brake_System_Type, Max_Speed, (Max_Speed * Max_Speed) / (2 * 100) AS Deceleration FROM UrbanRail_Trains;	railway	1
SELECT Brake_System_Type, Door_Emergency_Unlock, COUNT(*) * 1.0 / (SELECT COUNT(*) FROM UrbanRail_Trains) AS Proportion FROM UrbanRail_Trains GROUP BY Brake_System_Type, Door_Emergency_Unlock;	railway	2
SELECT Brake_System_Type FROM UrbanRail_Trains WHERE Door_Emergency_Unlock = '是' AND Brake_System_Type IN ('electric', 'combined');	railway	3
SELECT Train_ID, Train_Name, (Max_Speed * Max_Speed) / (2 * 1) AS Deceleration FROM UrbanRail_Trains WHERE Max_Speed = 10000;	railway	4
SELECT Train_ID, Train_Name, Insulation_Performance, Sealing_Pressure, (2 * (Sealing_Pressure / Insulation_Performance)) AS Thermal_Conductivity FROM UrbanRail_Trains;	railway	1
SELECT Insulation_Performance, AVG(Sealing_Pressure) AS Avg_Sealing_Pressure FROM UrbanRail_Trains GROUP BY Insulation_Performance;	railway	2
SELECT Noise_Reduction_Level FROM UrbanRail_Trains WHERE Sealing_Pressure >= 50 AND Noise_Reduction_Level = 'high';	railway	3
SELECT Train_ID, Train_Name, 0.01 * (100000 / CASE WHEN Insulation_Performance = 'low' THEN 1 END) AS Thermal_Conductivity FROM UrbanRail_Trains WHERE Sealing_Pressure = 100000;	railway	4
WITH Kinetic_Energy AS (SELECT 0.5 * 500000 * POWER((300 * 1000.0 / 3600), 2) AS Energy_Joules) SELECT p.Passenger_ID, p.First_Name FROM Passenger p JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID JOIN Train tr ON t.Train_ID = tr.Train_ID CROSS JOIN Kinetic_Energy ORDER BY Energy_Joules ASC LIMIT 10;	railway_station	1
WITH Total_Revenue AS (     SELECT 500 * 500 AS Total_Income ), Payment_Distribution AS (     SELECT Total_Income * 0.6 AS Online_Income,            Total_Income * 0.4 AS Cash_Income     FROM Total_Revenue ) SELECT p.Passenger_ID, p.First_Name FROM Passenger p JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID WHERE t.Train_ID = (     SELECT Train_ID      FROM Train      WHERE Total_Seats = 500      LIMIT 1 ) AND DATE(t.Booking_Time) = DATE('now') ORDER BY t.Ticket_Price DESC LIMIT 5;	railway_station	2
SELECT p.Passenger_ID, p.First_Name  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID  JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  WHERE s1.Station_Name = '北京南站'  AND s2.Station_Name = '上海虹桥站'  AND t.Departure_Time = '2023-10-10 10:00:00'  AND tr.Train_Type = '高铁'  ORDER BY datetime(t.Departure_Time, '+4 hours', '+30 minutes') ASC  LIMIT 3;	railway_station	3
SELECT p.Passenger_ID, p.First_Name, SUM(t.Ticket_Price * 1000) AS Total_Revenue FROM Passenger p JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID WHERE t.Train_ID = (SELECT Train_ID FROM Train WHERE Total_Seats = 500) GROUP BY p.Passenger_ID, p.First_Name ORDER BY Total_Revenue DESC LIMIT 1;	railway_station	4
WITH Kinetic_Energy AS (     SELECT 0.5 * 500000 * POWER((300 * 1000.0 / 3600), 2) AS Energy_Joules ) SELECT p.Last_Name, p.Gender  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  CROSS JOIN Kinetic_Energy  ORDER BY Energy_Joules ASC  LIMIT 10;	railway_station	1
WITH Total_Revenue AS (     SELECT 500 * 500 AS Total_Income ),  Payment_Distribution AS (     SELECT Total_Income * 0.6 AS Online_Income,             Total_Income * 0.4 AS Cash_Income      FROM Total_Revenue )  SELECT p.Last_Name, p.Gender  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  WHERE t.Train_ID = (     SELECT Train_ID      FROM Train      WHERE Total_Seats = 500      LIMIT 1 )  AND DATE(t.Booking_Time) = DATE('now')  GROUP BY p.Last_Name, p.Gender  ORDER BY SUM(t.Ticket_Price) DESC  LIMIT 5;	railway_station	2
SELECT p.Last_Name, p.Gender  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID  JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  WHERE s1.Station_Name = '北京南站'  AND s2.Station_Name = '上海虹桥站'  AND t.Departure_Time = '2023-10-10 10:00:00'  AND tr.Train_Type = '高铁'  ORDER BY datetime(t.Departure_Time, '+4 hours', '+30 minutes') ASC  LIMIT 3;	railway_station	3
SELECT p.Last_Name, p.Gender, SUM(t.Ticket_Price * 1000) AS Total_Revenue  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  WHERE t.Train_ID = (SELECT Train_ID FROM Train WHERE Total_Seats = 500)  GROUP BY p.Last_Name, p.Gender  ORDER BY Total_Revenue DESC  LIMIT 1;	railway_station	4
WITH Kinetic_Energy AS (   SELECT 0.5 * 500000 * POWER((300 * 1000 / 3600), 2) AS Energy_Joules )  SELECT p.Date_Of_Birth  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  CROSS JOIN Kinetic_Energy  ORDER BY Energy_Joules ASC  LIMIT 10;	railway_station	1
WITH Total_Revenue AS (     SELECT 500 * 500 AS Total_Income ),  Payment_Distribution AS (     SELECT Total_Income * 0.6 AS Online_Income,             Total_Income * 0.4 AS Cash_Income      FROM Total_Revenue )  SELECT p.Date_Of_Birth  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  WHERE t.Train_ID = (     SELECT Train_ID      FROM Train      WHERE Total_Seats = 500      LIMIT 1 )  AND DATE(t.Booking_Time) = DATE('now')  GROUP BY p.Date_Of_Birth  ORDER BY SUM(t.Ticket_Price) DESC  LIMIT 5;	railway_station	2
SELECT p.Date_Of_Birth  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID  JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  WHERE s1.Station_Name = '北京南站'  AND s2.Station_Name = '上海虹桥站'  AND t.Departure_Time = '2023-10-10 10:00:00'  AND tr.Train_Type = '高铁'  ORDER BY datetime(t.Departure_Time, '+4 hours', '+30 minutes') ASC  LIMIT 3;	railway_station	3
SELECT p.Date_Of_Birth, SUM(t.Ticket_Price * 1000) AS Total_Revenue FROM Passenger p JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID WHERE t.Train_ID = (SELECT Train_ID FROM Train WHERE Total_Seats = 500) GROUP BY p.Date_Of_Birth ORDER BY Total_Revenue DESC LIMIT 1;	railway_station	4
WITH Kinetic_Energy AS (   SELECT 0.5 * 500000 * POWER((300 * 1000 / 3600), 2) AS Energy_Joules )  SELECT p.Nationality, p.Passport_Number  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  CROSS JOIN Kinetic_Energy  ORDER BY Energy_Joules ASC  LIMIT 10;	railway_station	1
WITH Total_Revenue AS (     SELECT 500 * 500 AS Total_Income ), Payment_Distribution AS (     SELECT Total_Income * 0.6 AS Online_Income,            Total_Income * 0.4 AS Cash_Income     FROM Total_Revenue ) SELECT p.Nationality, p.Passport_Number FROM Passenger p JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID WHERE t.Train_ID = (     SELECT Train_ID     FROM Train     WHERE Total_Seats = 500     LIMIT 1 ) AND DATE(t.Booking_Time) = DATE('now') GROUP BY p.Nationality, p.Passport_Number ORDER BY SUM(t.Ticket_Price) DESC LIMIT 5;	railway_station	2
SELECT p.Nationality, p.Passport_Number  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID  JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  WHERE s1.Station_Name = '北京南站'  AND s2.Station_Name = '上海虹桥站'  AND t.Departure_Time = '2023-10-10 10:00:00'  AND tr.Train_Type = '高铁'  ORDER BY datetime(t.Departure_Time, '+4 hours', '+30 minutes') ASC  LIMIT 3;	railway_station	3
SELECT p.Nationality, p.Passport_Number, SUM(t.Ticket_Price * 1000) AS Total_Revenue  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  WHERE t.Train_ID = (SELECT Train_ID FROM Train WHERE Total_Seats = 500)  GROUP BY p.Nationality, p.Passport_Number  ORDER BY Total_Revenue DESC  LIMIT 1;	railway_station	4
WITH Passenger_Age AS (     SELECT          Passenger_ID,          First_Name,          Last_Name,          Date_Of_Birth,         (strftime('%Y', '2023-10-01') - strftime('%Y', Date_Of_Birth) -           (CASE WHEN strftime('%m-%d', '2023-10-01') < strftime('%m-%d', Date_Of_Birth) THEN 1 ELSE 0 END)) AS Age      FROM Passenger ) SELECT      Passenger_ID,      First_Name,      Last_Name,      Age  FROM Passenger_Age  ORDER BY Age DESC  LIMIT 5;	railway_station	1
WITH RECURSIVE digits(n) AS (     SELECT 1     UNION ALL     SELECT n+1 FROM digits WHERE n < 18 ), DigitSum AS (     SELECT          Passenger_ID,          ID_Card_Number,          Contact_Number,         (SELECT SUM(CAST(SUBSTR(ID_Card_Number, n, 1) AS INTEGER))           FROM digits           WHERE n <= LENGTH(ID_Card_Number)) +         (SELECT SUM(CAST(SUBSTR(Contact_Number, n, 1) AS INTEGER))           FROM digits           WHERE n <= LENGTH(Contact_Number)) AS Total_Digit_Sum     FROM Passenger ) SELECT p.Passenger_ID, p.First_Name, p.Last_Name, ds.Total_Digit_Sum FROM Passenger p JOIN DigitSum ds ON p.Passenger_ID = ds.Passenger_ID ORDER BY ds.Total_Digit_Sum DESC LIMIT 10;	railway_station	2
SELECT Last_Name, First_Name, ID_Card_Number, Contact_Number FROM Passenger WHERE SUBSTR(ID_Card_Number, 1, 6) = SUBSTR(Contact_Number, 1, 3) ORDER BY Last_Name ASC;	railway_station	3
SELECT Passenger_ID, First_Name, Last_Name, (LENGTH(ID_Card_Number) + LENGTH(Contact_Number)) * 1 AS Storage_Space FROM Passenger ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Email_Storage AS (     SELECT Passenger_ID, First_Name, Last_Name, Email, LENGTH(Email) AS Byte_Size      FROM Passenger )  SELECT Passenger_ID, First_Name, Last_Name, Byte_Size  FROM Email_Storage  ORDER BY Byte_Size DESC  LIMIT 5;	railway_station	1
WITH AtSymbolCount AS (     SELECT Passenger_ID, Email,             LENGTH(Email) - LENGTH(REPLACE(Email, '@', '')) AS At_Count      FROM Passenger ) SELECT p.Passenger_ID, p.First_Name, p.Last_Name, atc.At_Count  FROM Passenger p  JOIN AtSymbolCount atc ON p.Passenger_ID = atc.Passenger_ID  ORDER BY atc.At_Count DESC  LIMIT 10;	railway_station	2
SELECT Last_Name, First_Name, Email FROM Passenger WHERE Email LIKE '%.com' ORDER BY Last_Name ASC;	railway_station	3
SELECT Passenger_ID, First_Name, Last_Name, LENGTH(Email) * 1 AS Storage_Space FROM Passenger ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Passenger_Geo AS (     SELECT          p.Passenger_ID,          p.First_Name,          p.Last_Name,          p.Address,          s.Station_ID,          s.Station_Name,          s.Latitude AS Station_Latitude,          s.Longitude AS Station_Longitude,          RADIANS(s.Latitude) AS Station_Lat_Rad,          RADIANS(s.Longitude) AS Station_Lon_Rad,          RADIANS(CAST(SUBSTR(p.Address, 1, INSTR(p.Address, ',') - 1) AS REAL)) AS Passenger_Lat_Rad,          RADIANS(CAST(SUBSTR(p.Address, INSTR(p.Address, ',') + 1) AS REAL)) AS Passenger_Lon_Rad      FROM Passenger p      CROSS JOIN Station s ),  Distance_Calculation AS (     SELECT          Passenger_ID,          First_Name,          Last_Name,          Address,          Station_ID,          Station_Name,          6371 * ACOS(SIN(Passenger_Lat_Rad) * SIN(Station_Lat_Rad) + COS(Passenger_Lat_Rad) * COS(Station_Lat_Rad) * COS(Station_Lon_Rad - Passenger_Lon_Rad)) AS Distance_KM      FROM Passenger_Geo )  SELECT      Passenger_ID,      First_Name,      Last_Name,      Address,      Station_ID,      Station_Name,      Distance_KM  FROM Distance_Calculation  ORDER BY Distance_KM DESC  LIMIT 5;	railway_station	1
WITH WordCount AS (   SELECT      Passenger_ID,      Address,      LENGTH(Address) - LENGTH(REPLACE(Address, ' ', '')) + 1 AS Word_Count    FROM Passenger )  SELECT    p.Passenger_ID,    p.First_Name,    p.Last_Name,    wc.Word_Count  FROM Passenger p  JOIN WordCount wc ON p.Passenger_ID = wc.Passenger_ID  ORDER BY wc.Word_Count DESC  LIMIT 10;	railway_station	2
SELECT Last_Name, First_Name, Nationality, Address FROM Passenger WHERE Nationality != TRIM(SUBSTR(Address, INSTR(Address, ',') + 1)) ORDER BY Last_Name ASC;	railway_station	3
SELECT Passenger_ID, First_Name, Last_Name, LENGTH(Address) * 1000 AS Storage_Space FROM Passenger ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Station_Distance AS (   SELECT Station_ID, Station_Name, Latitude,           ABS(Latitude) * (2 * PI() * 6371) / 360 AS Distance_From_Equator    FROM Station )  SELECT Station_ID, Station_Name, Latitude, Distance_From_Equator  FROM Station_Distance  ORDER BY Distance_From_Equator DESC  LIMIT 5;	railway_station	1
WITH StationCodeSum AS (     SELECT          Station_ID,          Station_Code,          Platform_count,          (             SELECT SUM(CAST(SUBSTR(Station_Code, n, 1) AS INTEGER))             FROM (                 SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5                  UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10             ) AS digits             WHERE n <= LENGTH(Station_Code)         ) AS Code_Sum      FROM Station ) SELECT      s.Station_ID,      s.Station_Name,      s.Platform_count,      scs.Code_Sum,      s.Platform_count * scs.Code_Sum AS Product  FROM Station s  JOIN StationCodeSum scs ON s.Station_ID = scs.Station_ID  ORDER BY Product DESC  LIMIT 10;	railway_station	2
SELECT Station_Name, Platform_count FROM Station WHERE LENGTH(Station_Name) > 10 AND Platform_count > 5 ORDER BY Station_Name ASC;	railway_station	3
SELECT Station_ID, Station_Name, Platform_count * 1 AS Storage_Space FROM Station ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Station_Pairs AS (     SELECT          s1.Province,          s1.Station_ID AS Station1_ID,          s1.Latitude AS Lat1,          s1.Longitude AS Lon1,          s2.Station_ID AS Station2_ID,          s2.Latitude AS Lat2,          s2.Longitude AS Lon2      FROM Station s1      JOIN Station s2 ON s1.Province = s2.Province AND s1.Station_ID < s2.Station_ID ),  Distance_Calculation AS (     SELECT          Province,          Station1_ID,          Station2_ID,          6371 * ACOS(SIN(Lat1 * PI() / 180) * SIN(Lat2 * PI() / 180) + COS(Lat1 * PI() / 180) * COS(Lat2 * PI() / 180) * COS(Lon2 * PI() / 180 - Lon1 * PI() / 180)) AS Distance_KM      FROM Station_Pairs ),  Province_Average_Distance AS (     SELECT          Province,          AVG(Distance_KM) AS Avg_Distance_KM      FROM Distance_Calculation      GROUP BY Province )  SELECT Province, Avg_Distance_KM  FROM Province_Average_Distance  ORDER BY Avg_Distance_KM DESC  LIMIT 5;	railway_station	1
SELECT City, Province, LENGTH(City) + LENGTH(Province) AS Total_Length FROM Station GROUP BY City, Province ORDER BY Total_Length DESC LIMIT 10;	railway_station	2
SELECT Station_Name, City, Province FROM Station WHERE City != Province ORDER BY Station_Name ASC;	railway_station	3
SELECT Station_ID, Station_Name, (LENGTH(City) + LENGTH(Province)) * 1 AS Storage_Space FROM Station ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Station_Distance AS (     SELECT Country, Station_ID, ABS(Latitude) * (2 * 3.141592653589793 * 6371) / 360 AS Distance_From_Equator      FROM Station ),  Country_Average_Distance AS (     SELECT Country, AVG(Distance_From_Equator) AS Avg_Distance_From_Equator      FROM Station_Distance      GROUP BY Country )  SELECT Country, Avg_Distance_From_Equator  FROM Country_Average_Distance  ORDER BY Avg_Distance_From_Equator DESC  LIMIT 5;	railway_station	1
SELECT Station_ID, Station_Name, ABS(Latitude) + ABS(Longitude) AS Absolute_Sum FROM Station ORDER BY Absolute_Sum DESC LIMIT 10;	railway_station	2
SELECT Station_Name, Country, Latitude FROM Station WHERE Country = '中国' AND Latitude > 30 ORDER BY Station_Name ASC;	railway_station	3
SELECT Station_ID, Station_Name, (Latitude + Longitude) * 1 AS Storage_Space FROM Station ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Station_Address_Length AS (SELECT Station_ID, Station_Name, Address, LENGTH(Address) AS Address_Length FROM Station) SELECT Station_ID, Station_Name, Address, Address_Length FROM Station_Address_Length ORDER BY Address_Length DESC LIMIT 5;	railway_station	1
WITH EightCount AS (   SELECT      Station_ID,      Contact_Number,      LENGTH(Contact_Number) - LENGTH(REPLACE(Contact_Number, '8', '')) AS Eight_Count    FROM Station )  SELECT s.Station_ID, s.Station_Name, ec.Eight_Count  FROM Station s  JOIN EightCount ec ON s.Station_ID = ec.Station_ID  ORDER BY ec.Eight_Count DESC  LIMIT 10;	railway_station	2
SELECT Station_Name, Address, Contact_Number FROM Station WHERE Address LIKE '%中央%' AND Contact_Number LIKE '138%' ORDER BY Station_Name ASC;	railway_station	3
SELECT Station_ID, Station_Name, (LENGTH(Address) + LENGTH(Contact_Number)) * 1 AS Storage_Space FROM Station ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Station_Platform_Area AS (     SELECT Station_ID, Station_Name, Platform_count, Platform_count * 500 AS Total_Platform_Area      FROM Station      WHERE Station_Status = '运营中' )  SELECT Station_ID, Station_Name, Platform_count, Total_Platform_Area  FROM Station_Platform_Area  ORDER BY Total_Platform_Area DESC  LIMIT 5;	railway_station	1
WITH StationCodeSum AS (     SELECT          Station_ID,          Station_Code,          Platform_count,          (             SELECT SUM(CAST(SUBSTR(Station_Code, n, 1) AS INTEGER))              FROM (                 SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5                  UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10             ) AS digits              WHERE n <= LENGTH(Station_Code)         ) AS Code_Sum      FROM Station ) SELECT      s.Station_ID,      s.Station_Name,      s.Platform_count,      scs.Code_Sum,      s.Platform_count * scs.Code_Sum AS Product  FROM Station s  JOIN StationCodeSum scs ON s.Station_ID = scs.Station_ID  ORDER BY Product DESC  LIMIT 10;	railway_station	2
SELECT Station_Name, Platform_count, Station_Status FROM Station WHERE Platform_count > 10 AND Station_Status = '运营中' ORDER BY Platform_count DESC;	railway_station	3
SELECT Station_ID, Station_Name, Platform_count * 1 AS Storage_Space FROM Station ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Passenger_Age AS (     SELECT          Passenger_ID,          First_Name,          Last_Name,          Date_Of_Birth,         CAST(strftime('%Y', '2023-10-01') AS INTEGER) - CAST(strftime('%Y', Date_Of_Birth) AS INTEGER) -          (CASE WHEN strftime('%m-%d', '2023-10-01') < strftime('%m-%d', Date_Of_Birth) THEN 1 ELSE 0 END) AS Passenger_Age      FROM Passenger ), Station_Age AS (     SELECT          Station_ID,          Station_Name,          Created_At,         CAST(strftime('%Y', '2023-10-01') AS INTEGER) - CAST(strftime('%Y', Created_At) AS INTEGER) -          (CASE WHEN strftime('%m-%d', '2023-10-01') < strftime('%m-%d', Created_At) THEN 1 ELSE 0 END) AS Station_Age      FROM Station ), Passenger_Station_Difference AS (     SELECT          p.Passenger_ID,          p.First_Name,          p.Last_Name,          s.Station_ID,          s.Station_Name,          ABS(p.Passenger_Age - s.Station_Age) AS Age_Difference      FROM Passenger_Age p      JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID      JOIN Station_Age s ON t.Departure_Station_ID = s.Station_ID ) SELECT      Passenger_ID,      First_Name,      Last_Name,      Station_ID,      Station_Name,      Age_Difference  FROM Passenger_Station_Difference  ORDER BY Age_Difference DESC  LIMIT 5;	railway_station	1
WITH DigitSum AS (     SELECT          p.Passenger_ID,          p.ID_Card_Number,          s.Station_Code,          (SELECT SUM(CAST(SUBSTR(p.ID_Card_Number, n, 1) AS INTEGER))           FROM (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10 UNION SELECT 11 UNION SELECT 12 UNION SELECT 13 UNION SELECT 14 UNION SELECT 15 UNION SELECT 16 UNION SELECT 17 UNION SELECT 18) AS digits           WHERE n <= LENGTH(p.ID_Card_Number)) +          (SELECT SUM(CAST(SUBSTR(s.Station_Code, n, 1) AS INTEGER))           FROM (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10) AS digits           WHERE n <= LENGTH(s.Station_Code)) AS Total_Digit_Sum      FROM Passenger p      JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID      JOIN Station s ON t.Departure_Station_ID = s.Station_ID ) SELECT      p.Passenger_ID,      p.First_Name,      p.Last_Name,      s.Station_Name,      ds.Total_Digit_Sum  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Station s ON t.Departure_Station_ID = s.Station_ID  JOIN DigitSum ds ON p.Passenger_ID = ds.Passenger_ID  ORDER BY ds.Total_Digit_Sum DESC  LIMIT 10;	railway_station	2
SELECT p.Last_Name, p.First_Name, p.Nationality, s.Station_Name, s.Country  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  JOIN Station s ON t.Departure_Station_ID = s.Station_ID  WHERE p.Nationality != s.Country  ORDER BY p.Last_Name ASC;	railway_station	3
SELECT p.Passenger_ID, p.First_Name, p.Last_Name, s.Station_Name, (LENGTH(p.ID_Card_Number) + LENGTH(s.Station_Code)) * 1 AS Storage_Space FROM Passenger p JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID JOIN Station s ON t.Departure_Station_ID = s.Station_ID ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
WITH Ticket_Travel_Time AS (     SELECT          Ticket_ID,          Train_ID,          Departure_Time,          Arrival_Time,          (JULIANDAY(Arrival_Time) - JULIANDAY(Departure_Time)) * 24 AS Travel_Time_Hours      FROM Ticket )  SELECT      t.Ticket_ID,      t.Train_ID,      tr.Train_Name,      t.Departure_Time,      t.Arrival_Time,      t.Travel_Time_Hours  FROM Ticket_Travel_Time t  JOIN Train tr ON t.Train_ID = tr.Train_ID  ORDER BY t.Travel_Time_Hours DESC  LIMIT 5;	railway_station	1
WITH SeatDigitSum AS (   SELECT      Ticket_ID,      Ticket_Price,      Seat_Number,      (       SELECT SUM(CAST(SUBSTR(Seat_Number, n, 1) AS INTEGER))        FROM (         SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5          UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10       ) AS digits        WHERE n <= LENGTH(Seat_Number)     ) AS Seat_Digit_Sum    FROM Ticket ) SELECT    t.Ticket_ID,    t.Train_ID,    tr.Train_Name,    t.Ticket_Price,    sds.Seat_Digit_Sum,    (t.Ticket_Price * sds.Seat_Digit_Sum) AS Product  FROM Ticket t  JOIN SeatDigitSum sds ON t.Ticket_ID = sds.Ticket_ID  JOIN Train tr ON t.Train_ID = tr.Train_ID  ORDER BY Product DESC  LIMIT 10;	railway_station	2
SELECT t.Ticket_ID, t.Train_ID, t.Passenger_ID, t.Departure_Station_ID, t.Arrival_Station_ID, t.Seat_Number, t.Ticket_Price, t.Ticket_Status, t.Booking_Time, t.Departure_Time, t.Arrival_Time, t.Payment_Method, t.Payment_Status, t.Created_at, t.Updated_at FROM Ticket t JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID WHERE s1.City = s2.City ORDER BY t.Ticket_Price ASC;	railway_station	3
SELECT t.Ticket_ID, tr.Train_Name, (t.Ticket_Price + LENGTH(t.Seat_Number)) * 1 AS Storage_Space FROM Ticket t JOIN Train tr ON t.Train_ID = tr.Train_ID ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
SELECT p.Passenger_ID, p.First_Name, p.Last_Name, p.Date_Of_Birth, t.Ticket_ID, t.Booking_Time,      (strftime('%Y', t.Booking_Time) - strftime('%Y', p.Date_Of_Birth) -          CASE WHEN strftime('%m-%d', p.Date_Of_Birth) > strftime('%m-%d', t.Booking_Time) THEN 1 ELSE 0 END) AS Age_At_Booking  FROM Passenger p  JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID  ORDER BY Age_At_Booking ASC  LIMIT 5;	railway_station	1
WITH IDDigitSum AS (     SELECT          p.Passenger_ID,          p.ID_Card_Number,          (SELECT SUM(CAST(SUBSTR(p.ID_Card_Number, n, 1) AS INTEGER))           FROM (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10 UNION SELECT 11 UNION SELECT 12 UNION SELECT 13 UNION SELECT 14 UNION SELECT 15 UNION SELECT 16 UNION SELECT 17 UNION SELECT 18) AS digits           WHERE n <= LENGTH(p.ID_Card_Number)) AS ID_Digit_Sum      FROM Passenger p )  SELECT      t.Ticket_ID,      t.Passenger_ID,      p.First_Name,      p.Last_Name,      t.Ticket_Price,      ids.ID_Digit_Sum,      (t.Ticket_Price * ids.ID_Digit_Sum) AS Product  FROM Ticket t  JOIN IDDigitSum ids ON t.Passenger_ID = ids.Passenger_ID  JOIN Passenger p ON t.Passenger_ID = p.Passenger_ID  ORDER BY Product DESC  LIMIT 10;	railway_station	2
SELECT t.Ticket_ID, t.Train_ID, t.Passenger_ID, t.Departure_Station_ID, t.Arrival_Station_ID, t.Seat_Number, t.Ticket_Price, t.Ticket_Status, t.Booking_Time, t.Departure_Time, t.Arrival_Time, t.Payment_Method, t.Payment_Status, t.Created_at, t.Updated_at FROM Ticket t JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID WHERE s1.Province = s2.Province ORDER BY t.Ticket_Price ASC;	railway_station	3
SELECT t.Ticket_ID, p.First_Name, p.Last_Name, (1000000 + 1000) * 1 AS Storage_Space FROM Ticket t JOIN Passenger p ON t.Passenger_ID = p.Passenger_ID ORDER BY Storage_Space DESC LIMIT 5;	railway_station	4
SELECT t.Train_ID, t.Train_Name, s1.Latitude AS Departure_Latitude, s1.Longitude AS Departure_Longitude, s2.Latitude AS Arrival_Latitude, s2.Longitude AS Arrival_Longitude, t.Departure_Time, t.Arrival_Time, (6371 * acos(sin(radians(s1.Latitude)) * sin(radians(s2.Latitude)) + cos(radians(s1.Latitude)) * cos(radians(s2.Latitude)) * cos(radians(s2.Longitude - s1.Longitude)))) AS Distance, (strftime('%s', t.Arrival_Time) - strftime('%s', t.Departure_Time)) / 3600.0 AS Time_Diff, (6371 * acos(sin(radians(s1.Latitude)) * sin(radians(s2.Latitude)) + cos(radians(s1.Latitude)) * cos(radians(s2.Latitude)) * cos(radians(s2.Longitude - s1.Longitude)))) / ((strftime('%s', t.Arrival_Time) - strftime('%s', t.Departure_Time)) / 3600.0) AS Average_Speed FROM Train t JOIN Station s1 ON t.Departure_Station = s1.Station_ID JOIN Station s2 ON t.Arrival_Station = s2.Station_ID;	railway_station	1
WITH PassengerAge AS (     SELECT p.Passenger_ID, p.First_Name, p.Last_Name, p.Date_Of_Birth,             (strftime('%Y', 'now') - strftime('%Y', p.Date_Of_Birth)) AS Age     FROM Passenger p     JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID     WHERE t.Train_ID = '指定列车ID' ), OrderedAges AS (     SELECT Age,             ROW_NUMBER() OVER (ORDER BY Age) AS RowAsc,             ROW_NUMBER() OVER (ORDER BY Age DESC) AS RowDesc     FROM PassengerAge ) SELECT AVG(Age) AS MedianAge FROM OrderedAges WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1;	railway_station	2
SELECT p.Nationality, COUNT(p.Nationality) AS Nationality_Count FROM Passenger p JOIN Ticket t ON p.Passenger_ID = t.Passenger_ID WHERE t.Train_ID = '指定列车的Train_ID' GROUP BY p.Nationality ORDER BY Nationality_Count DESC;	railway_station	3
SELECT Seat_Number, COUNT(Seat_Number) / 1000000.0 AS Occupancy_Rate FROM Ticket WHERE Train_ID = '指定列车ID' GROUP BY Seat_Number ORDER BY Seat_Number ASC;	railway_station	4
SELECT SUM(Ticket_Price) * 100 AS Total_Energy_Consumption FROM Ticket WHERE Train_ID = '指定的列车ID' AND Ticket_Status = 'Used';	railway_station	1
WITH AvgPrice AS (         SELECT AVG(Ticket_Price) AS Avg_Ticket_Price          FROM Ticket          WHERE Train_ID = '指定列车ID' AND Ticket_Status = 'Booked'     ),     PriceVariance AS (         SELECT              Ticket_ID,              Ticket_Price,              POWER(Ticket_Price - (SELECT Avg_Ticket_Price FROM AvgPrice), 2) AS Squared_Diff          FROM Ticket          WHERE Train_ID = '指定列车ID' AND Ticket_Status = 'Booked'     )     SELECT SQRT(SUM(Squared_Diff) / COUNT(Ticket_ID)) AS Ticket_Price_StdDev      FROM PriceVariance;	railway_station	2
SELECT t.Seat_Number FROM Ticket t WHERE t.Train_ID = '指定列车的Train_ID' AND t.Ticket_Status = 'Canceled' ORDER BY t.Seat_Number DESC;	railway_station	3
SELECT Seat_Number, COUNT(Seat_Number) / 1000000.0 AS Occupancy_Rate FROM Ticket WHERE Train_ID = '指定列车ID' AND Ticket_Status = 'Used' GROUP BY Seat_Number ORDER BY Seat_Number ASC;	railway_station	4
SELECT SQRT(SUM((time_diff - avg_interval) * (time_diff - avg_interval)) / COUNT(*)) AS StdDevInterval FROM (     SELECT          (strftime('%s', t1.Booking_Time) - strftime('%s', (             SELECT MAX(t2.Booking_Time)              FROM Ticket t2              WHERE t2.Train_ID = t1.Train_ID              AND t2.Ticket_Status = 'Booked'              AND t2.Booking_Time < t1.Booking_Time         ))) AS time_diff     FROM Ticket t1      WHERE t1.Train_ID = '指定的列车ID'      AND t1.Ticket_Status = 'Booked' ) AS TimeIntervals, (     SELECT AVG(         strftime('%s', t1.Booking_Time) - strftime('%s', (             SELECT MAX(t3.Booking_Time)              FROM Ticket t3              WHERE t3.Train_ID = t1.Train_ID              AND t3.Ticket_Status = 'Booked'              AND t3.Booking_Time < t1.Booking_Time         ))     ) AS avg_interval     FROM Ticket t1      WHERE t1.Train_ID = '指定的列车ID'      AND t1.Ticket_Status = 'Booked' ) AS AvgInterval;	railway_station	1
WITH Data AS (     SELECT          Seat_Number,          CAST(strftime('%s', Booking_Time) AS INTEGER) AS Booking_Time_Unix      FROM Ticket      WHERE Train_ID = '指定列车ID' AND Ticket_Status = 'Used' ),  Stats AS (     SELECT          AVG(Seat_Number) AS Avg_Seat,          AVG(Booking_Time_Unix) AS Avg_Time,          STDEV(Seat_Number) AS StdDev_Seat,          STDEV(Booking_Time_Unix) AS StdDev_Time      FROM Data )  SELECT      (SUM((Seat_Number - (SELECT Avg_Seat FROM Stats)) * (Booking_Time_Unix - (SELECT Avg_Time FROM Stats))) /      (COUNT(*) * (SELECT StdDev_Seat FROM Stats) * (SELECT StdDev_Time FROM Stats))) AS Correlation_Coefficient  FROM Data;	railway_station	2
SELECT t.Booking_Time FROM Ticket t WHERE t.Train_ID = '指定列车的Train_ID' AND t.Ticket_Status = 'Canceled' ORDER BY t.Booking_Time ASC;	railway_station	3
WITH Booking_Intervals AS (       SELECT            Seat_Number,            CAST(Booking_Time AS REAL) - CAST(LAG(Booking_Time) OVER (PARTITION BY Seat_Number ORDER BY Booking_Time) AS REAL) AS Booking_Interval        FROM Ticket        WHERE Train_ID = '指定列车ID' AND Ticket_Status = 'Booked'     )      SELECT          Seat_Number,          AVG(Booking_Interval) AS Avg_Booking_Interval      FROM Booking_Intervals      GROUP BY Seat_Number      ORDER BY Seat_Number ASC;	railway_station	4
WITH UsedTickets AS (     SELECT t.Ticket_ID, t.Departure_Station_ID, t.Arrival_Station_ID, t.Departure_Time, t.Arrival_Time      FROM Ticket t      WHERE t.Ticket_Status = 'Used' AND t.Train_ID = '指定列车的Train_ID' ),  StationDistances AS (     SELECT ut.Ticket_ID,             s1.Latitude AS Departure_Latitude,             s1.Longitude AS Departure_Longitude,             s2.Latitude AS Arrival_Latitude,             s2.Longitude AS Arrival_Longitude      FROM UsedTickets ut      JOIN Station s1 ON ut.Departure_Station_ID = s1.Station_ID      JOIN Station s2 ON ut.Arrival_Station_ID = s2.Station_ID ),  CalculatedDistances AS (     SELECT Ticket_ID,             6371 * acos(sin(radians(Departure_Latitude)) * sin(radians(Arrival_Latitude)) +                         cos(radians(Departure_Latitude)) * cos(radians(Arrival_Latitude)) *                         cos(radians(Arrival_Longitude - Departure_Longitude))) AS Distance      FROM StationDistances ),  TimeDifferences AS (     SELECT Ticket_ID,             (julianday(Arrival_Time) - julianday(Departure_Time)) * 86400 AS Time_Difference      FROM UsedTickets )  SELECT AVG(cd.Distance / (td.Time_Difference / 3600)) AS Average_Speed  FROM CalculatedDistances cd  JOIN TimeDifferences td ON cd.Ticket_ID = td.Ticket_ID;	railway_station	1
WITH TicketData AS (   SELECT Departure_Time, Arrival_Time    FROM Ticket    WHERE Train_ID = '指定列车ID' AND Ticket_Status = 'Booked' )  SELECT    (AVG(Departure_Time * Arrival_Time) - AVG(Departure_Time) * AVG(Arrival_Time)) /    (SQRT(AVG(Departure_Time * Departure_Time) - AVG(Departure_Time) * AVG(Departure_Time)) *     SQRT(AVG(Arrival_Time * Arrival_Time) - AVG(Arrival_Time) * AVG(Arrival_Time))) AS Correlation_Coefficient  FROM TicketData  ORDER BY Correlation_Coefficient DESC;	railway_station	2
SELECT t.Departure_Time FROM Ticket t WHERE t.Train_ID = '指定列车的Train_ID' AND t.Ticket_Status = 'Canceled' ORDER BY t.Departure_Time ASC;	railway_station	3
SELECT (Arrival_Time - Departure_Time) AS Time_Difference, AVG(Arrival_Time - Departure_Time) AS Avg_Time_Difference FROM Ticket WHERE Train_ID = '指定列车ID' AND Ticket_Status = 'Used' GROUP BY Time_Difference ORDER BY Time_Difference ASC;	railway_station	4
SELECT SUM(t.Ticket_Price) * 100 AS Total_Energy_Consumption FROM Ticket t WHERE t.Payment_Status = 'Pending' AND t.Ticket_Status = 'Booked' AND t.Train_ID = '指定列车的Train_ID';	railway_station	1
WITH TicketData AS (   SELECT Ticket_Price    FROM Ticket    WHERE Train_ID = '指定列车ID' AND Payment_Status = 'Fail' ),  AvgPrice AS (   SELECT AVG(Ticket_Price) AS Mean_Price    FROM TicketData )  SELECT SQRT(SUM((Ticket_Price - (SELECT Mean_Price FROM AvgPrice)) * (Ticket_Price - (SELECT Mean_Price FROM AvgPrice))) / COUNT(*)) AS Price_StdDev  FROM TicketData  ORDER BY Ticket_Price ASC;	railway_station	2
SELECT t.Payment_Method, COUNT(t.Ticket_ID) AS Ticket_Count  FROM Ticket t  WHERE t.Train_ID = '指定列车的Train_ID' AND t.Payment_Method = 'Credit Card'  GROUP BY t.Payment_Method  ORDER BY Ticket_Count DESC;	railway_station	3
SELECT Ticket_Price, (Ticket_Price * 100) AS Energy_Consumption FROM Ticket WHERE Train_ID = '指定列车ID' AND Payment_Status = 'Fail' ORDER BY Ticket_Price DESC;	railway_station	4
WITH UsedTickets AS (         SELECT t.Departure_Time, t.Arrival_Time          FROM Ticket t          JOIN Train tr ON t.Train_ID = tr.Train_ID          JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID          JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID          WHERE t.Ticket_Status = 'Used'          AND s1.City = '北京'          AND s2.City = '上海'          AND tr.Train_Type = '高铁'     ),      TimeDifferences AS (         SELECT (JULIANDAY(Arrival_Time) - JULIANDAY(Departure_Time)) * 24 AS Travel_Time          FROM UsedTickets     )      SELECT CASE          WHEN AVG(Travel_Time) = 4.5 THEN 1318 / 4.5          ELSE 1318 / AVG(Travel_Time)      END AS Average_Speed      FROM TimeDifferences;	railway_station	1
WITH TotalPassengers AS (     SELECT 500 * 100 AS Total_Passengers ), StationPassengers AS (     SELECT s.Station_Name, COUNT(t.Passenger_ID) AS Passenger_Count     FROM Ticket t     JOIN Station s ON t.Departure_Station_ID = s.Station_ID     WHERE date(t.Departure_Time) = '2023-10-01'     GROUP BY s.Station_Name ) SELECT sp.Station_Name, sp.Passenger_Count,         (sp.Passenger_Count * 1.0 / tp.Total_Passengers) AS Passenger_Ratio FROM StationPassengers sp, TotalPassengers tp ORDER BY Passenger_Ratio DESC;	railway_station	2
SELECT p.Passenger_ID, p.First_Name, p.Last_Name, p.Gender, p.Date_Of_Birth, p.Nationality, p.Passport_Number, p.ID_Card_Number, p.Contact_Number, p.Email, p.Address, p.Created_At, p.Updated_At,         (strftime('%Y', 'now') - strftime('%Y', p.Date_Of_Birth)) AS Age  FROM Passenger p  WHERE (strftime('%Y', 'now') - strftime('%Y', p.Date_Of_Birth)) > 60;	railway_station	3
SELECT p.Nationality,         COUNT(t.Passenger_ID) AS Passenger_Count,         AVG(t.Ticket_Price) AS Avg_Ticket_Price,         SUM(t.Ticket_Price) * 1.0 / (SELECT SUM(t2.Ticket_Price) FROM Ticket t2 WHERE t2.Train_ID = '指定列车ID' AND t2.Ticket_Status = 'Booked') AS Price_Ratio  FROM Ticket t  JOIN Passenger p ON t.Passenger_ID = p.Passenger_ID  WHERE t.Train_ID = '指定列车ID' AND t.Ticket_Status = 'Booked'  GROUP BY p.Nationality  ORDER BY Passenger_Count DESC;	railway_station	4
WITH UsedTickets AS (         SELECT t.Departure_Time, t.Arrival_Time, t.Seat_Number, t.Payment_Method, tr.Train_Type          FROM Ticket t          JOIN Train tr ON t.Train_ID = tr.Train_ID          WHERE t.Ticket_Status = 'Used'     ),      TimeDifferences AS (         SELECT (julianday(Arrival_Time) - julianday(Departure_Time)) * 24.0 AS Travel_Time,                 Seat_Number, Payment_Method, Train_Type          FROM UsedTickets     ),      AverageSpeeds AS (         SELECT CASE                   WHEN AVG(Travel_Time) = 2 THEN 500.0 / 2                   ELSE 500.0 / AVG(Travel_Time)                 END AS Average_Speed,                 Seat_Number, Payment_Method, Train_Type          FROM TimeDifferences          GROUP BY Seat_Number, Payment_Method, Train_Type     )      SELECT Train_Type, AVG(Average_Speed) AS Overall_Average_Speed      FROM AverageSpeeds      GROUP BY Train_Type;	railway_station	1
WITH TotalSeats AS (     SELECT 500 * 100 AS Total_Seats ),  StationSeats AS (     SELECT s.Station_Name, SUM(t.Total_Seats) AS Station_Total_Seats      FROM Train t      JOIN Station s ON t.Departure_Station = s.Station_ID      WHERE t.Train_Type = '高铁'      AND DATE(t.Departure_Time) = '2023-10-01'      GROUP BY s.Station_Name ),  StationSeatsRatio AS (     SELECT ss.Station_Name, ss.Station_Total_Seats,             (ss.Station_Total_Seats * 1.0 / ts.Total_Seats) AS Seats_Ratio      FROM StationSeats ss, TotalSeats ts )  SELECT ssr.Station_Name, ssr.Station_Total_Seats, ssr.Seats_Ratio  FROM StationSeatsRatio ssr  WHERE ssr.Seats_Ratio > 0.1  ORDER BY ssr.Seats_Ratio DESC;	railway_station	2
SELECT t.Train_ID, t.Train_Number, t.Train_Name, t.Train_Type, t.Departure_Station, t.Arrival_Station, t.Departure_Time, t.Arrival_Time, (strftime('%s', t.Arrival_Time) - strftime('%s', t.Departure_Time)) / 3600.0 AS Duration FROM Train t WHERE (strftime('%s', t.Arrival_Time) - strftime('%s', t.Departure_Time)) / 3600.0 > 3;	railway_station	3
WITH Step_Times AS (SELECT 0.1 AS Validation_Time, 0.2 AS Payment_Time, 0.3 AS Allocation_Time), Failure_Rate AS (SELECT 0.1 AS Failure_Rate) SELECT Total_Seats / 10000.0 * (Validation_Time + Payment_Time + Allocation_Time) * (1.0 + Failure_Rate) AS Total_Processing_Time, (Validation_Time * 100.0 / (Validation_Time + Payment_Time + Allocation_Time)) AS Validation_Percentage, (Payment_Time * 100.0 / (Validation_Time + Payment_Time + Allocation_Time)) AS Payment_Percentage, (Allocation_Time * 100.0 / (Validation_Time + Payment_Time + Allocation_Time)) AS Allocation_Percentage FROM Train, Step_Times, Failure_Rate WHERE Train_ID = '指定列车ID';	railway_station	4
SELECT (Total_Seats - Available_Seats) * 1.0 / Total_Seats AS Seat_Occupancy_Rate FROM Train WHERE Train_ID = '指定列车的Train_ID';	railway_station	1
WITH HighSpeedTrains AS (SELECT Available_Seats FROM Train WHERE Train_Type = '高铁' AND date(Departure_Time) = '2023-10-01') SELECT 450 * 100 AS Total_Available_Seats;	railway_station	2
SELECT t.Train_ID, t.Train_Number, t.Train_Name, t.Train_Type, t.Departure_Station, t.Arrival_Station, t.Departure_Time, t.Arrival_Time, t.Total_Seats, t.Available_Seats, (t.Total_Seats - t.Available_Seats) * 1.0 / t.Total_Seats AS Occupancy_Rate FROM Train t WHERE (t.Total_Seats - t.Available_Seats) * 1.0 / t.Total_Seats > 0.9;	railway_station	3
WITH Step_Times AS (SELECT 0.1 AS Validation_Time, 0.2 AS Payment_Time, 0.3 AS Allocation_Time), Failure_Rate AS (SELECT 0.1 AS Failure_Rate) SELECT Total_Seats / 10000.0 * (Validation_Time + Payment_Time + Allocation_Time) * (1.0 + Failure_Rate) AS Total_Processing_Time, (Validation_Time * 100.0 / (Validation_Time + Payment_Time + Allocation_Time)) AS Validation_Percentage, (Payment_Time * 100.0 / (Validation_Time + Payment_Time + Allocation_Time)) AS Payment_Percentage, (Allocation_Time * 100.0 / (Validation_Time + Payment_Time + Allocation_Time)) AS Allocation_Percentage FROM Train, Step_Times, Failure_Rate WHERE Train_ID = '指定列车ID';	railway_station	4
WITH RunningTrains AS (   SELECT tr.Train_ID, tr.Train_Type, tr.Operator, tr.Departure_Time, tr.Arrival_Time    FROM Train tr    WHERE tr.Train_Status = '运行中' ),  TimeDifferences AS (   SELECT Train_ID, Train_Type, Operator,           (strftime('%s', Arrival_Time) - strftime('%s', Departure_Time)) / 3600.0 AS Travel_Time    FROM RunningTrains ),  PowerConsumptions AS (   SELECT      CASE        WHEN AVG(Travel_Time) = 4 THEN 20000.0 / 4        ELSE 20000.0 / AVG(Travel_Time)      END AS Average_Power_Consumption,      Train_Type,      Operator    FROM TimeDifferences    GROUP BY Train_Type, Operator )  SELECT Train_Type, Operator, AVG(Average_Power_Consumption) AS Overall_Average_Power_Consumption  FROM PowerConsumptions  GROUP BY Train_Type, Operator;	railway_station	1
WITH HighSpeedTrains AS (     SELECT Train_ID      FROM Train      WHERE Train_Type = '高铁'      AND Train_Status = '运行'      AND date(Departure_Time) = '2023-10-01' )  SELECT 20000 * 50 AS Total_Energy_Consumption;	railway_station	2
SELECT t.Train_ID, t.Train_Number, t.Train_Name, t.Train_Type, t.Departure_Station, t.Arrival_Station, t.Departure_Time, t.Arrival_Time, t.Total_Seats, t.Available_Seats, t.Train_Status, t.Operator FROM Train t WHERE t.Train_Status = '运行' AND t.Operator = '特定运营商';	railway_station	3
WITH Step_Times AS (SELECT 0.1 AS Validation_Time, 0.2 AS Payment_Time, 0.3 AS Allocation_Time),  Failure_Rate AS (SELECT 0.1 AS Failure_Rate)  SELECT Total_Seats / 100000 * (Validation_Time + Payment_Time + Allocation_Time) * (1 + Failure_Rate) AS Total_Processing_Time,  (Validation_Time / (Validation_Time + Payment_Time + Allocation_Time)) * 100 AS Validation_Percentage,  (Payment_Time / (Validation_Time + Payment_Time + Allocation_Time)) * 100 AS Payment_Percentage,  (Allocation_Time / (Validation_Time + Payment_Time + Allocation_Time)) * 100 AS Allocation_Percentage  FROM Train, Step_Times, Failure_Rate  WHERE Train_ID = '指定列车ID';	railway_station	4
WITH UsedTickets AS (         SELECT              t.Departure_Time,              t.Arrival_Time,              t.Seat_Number,              t.Payment_Method,              tr.Train_Type          FROM Ticket t          JOIN Train tr ON t.Train_ID = tr.Train_ID          JOIN Station s1 ON t.Departure_Station_ID = s1.Station_ID          JOIN Station s2 ON t.Arrival_Station_ID = s2.Station_ID          WHERE t.Ticket_Status = 'Used'            AND s1.Station_Name = '北京南站'            AND s2.Station_Name = '上海虹桥站'     ),      TimeDifferences AS (         SELECT              (strftime('%s', Arrival_Time) - strftime('%s', Departure_Time)) / 3600.0 AS Travel_Time,              Seat_Number,              Payment_Method,              Train_Type          FROM UsedTickets     ),      AverageSpeeds AS (         SELECT              CASE                  WHEN AVG(Travel_Time) = (4 + 28 / 60.0) THEN 1318 / (4 + 28 / 60.0)                  ELSE 1318 / AVG(Travel_Time)              END AS Average_Speed,              Seat_Number,              Payment_Method,              Train_Type          FROM TimeDifferences          GROUP BY Seat_Number, Payment_Method, Train_Type     )      SELECT          Train_Type,          AVG(Average_Speed) AS Overall_Average_Speed      FROM AverageSpeeds      GROUP BY Train_Type;	railway_station	1
WITH StationInfo AS (     SELECT Station_ID      FROM Station      WHERE Station_Name = '北京南站' ),  TrainPassengers AS (     SELECT t.Train_ID, COUNT(tk.Passenger_ID) AS Passenger_Count      FROM Ticket tk      JOIN Train t ON tk.Train_ID = t.Train_ID      WHERE tk.Departure_Station_ID = (SELECT Station_ID FROM StationInfo)      AND date(tk.Departure_Time) = '2023-10-01'      GROUP BY t.Train_ID )  SELECT Train_ID, Passenger_Count  FROM TrainPassengers  ORDER BY Passenger_Count DESC  LIMIT 5;	railway_station	2
SELECT s.Station_Name, COUNT(t.Passenger_ID) AS Passenger_Count  FROM Ticket t  JOIN Station s ON t.Arrival_Station_ID = s.Station_ID  WHERE t.Departure_Station_ID = (SELECT Station_ID FROM Station WHERE Station_Name = '北京南站')  AND date(t.Departure_Time) = '2023-10-01'  GROUP BY t.Arrival_Station_ID  ORDER BY Passenger_Count DESC  LIMIT 3;	railway_station	3
WITH Step_Times AS (         SELECT 0.1 AS Validation_Time, 0.2 AS Payment_Time, 0.3 AS Allocation_Time     ),      Failure_Rate AS (         SELECT 0.1 AS Failure_Rate     )      SELECT          Total_Seats / 100000 * (Validation_Time + Payment_Time + Allocation_Time) * (1 + Failure_Rate) AS Total_Processing_Time,         (Validation_Time / (Validation_Time + Payment_Time + Allocation_Time)) * 100 AS Validation_Percentage,         (Payment_Time / (Validation_Time + Payment_Time + Allocation_Time)) * 100 AS Payment_Percentage,         (Allocation_Time / (Validation_Time + Payment_Time + Allocation_Time)) * 100 AS Allocation_Percentage,         384400 / (299792.458 * 0.01) AS Travel_Time      FROM Train, Step_Times, Failure_Rate      WHERE Train_ID = '指定列车ID';	railway_station	4
SELECT ((0.5 - 0.1) * rc.Track_Length) / (0.5 * rc.Max_Speed * rc.Max_Speed) * 100 AS Kinetic_Energy_Loss_Percentage FROM Roller_Coaster rc JOIN Maintenance_Record mr ON rc.Coaster_ID = mr.Coaster_ID WHERE mr.Track_Condition = 'Poor';	roller_coaster	1
SELECT SUM(mr.Maintenance_Cost * POWER(1.05, sub.maintenance_count) / POWER(0.9, sub.maintenance_count)) AS Total_Maintenance_Cost  FROM Maintenance_Record mr  JOIN (     SELECT COUNT(*) AS maintenance_count      FROM Maintenance_Record      WHERE Maintenance_Date BETWEEN date('now', '-1 year') AND date('now') ) sub  WHERE mr.Maintenance_Date BETWEEN date('now', '-1 year') AND date('now');	roller_coaster	2
SELECT mr.Maintenance_Type FROM Maintenance_Record mr WHERE mr.Safety_Check_Result = 'Fail' AND mr.Track_Condition = 'Poor';	roller_coaster	3
SELECT rc.Max_Speed + (50 * 12) AS Final_Max_Speed FROM Roller_Coaster rc;	roller_coaster	4
SELECT 70 * rc.Max_G_Force AS Equivalent_Weight FROM Roller_Coaster rc JOIN Passenger_Feedback pf ON rc.Coaster_ID = pf.Coaster_ID WHERE rc.Max_G_Force = 4;	roller_coaster	1
WITH RatingData AS (     SELECT Rating,             ROW_NUMBER() OVER (ORDER BY Rating) AS row_asc,             ROW_NUMBER() OVER (ORDER BY Rating DESC) AS row_desc      FROM Passenger_Feedback      WHERE Ride_Date BETWEEN date('now','-1 year') AND date('now') ),  MedianRating AS (     SELECT AVG(Rating) AS Median_Rating      FROM RatingData      WHERE row_asc IN (row_desc, row_desc - 1, row_desc + 1) )  SELECT AVG(pf.Rating) AS Average_Rating,         (SELECT Median_Rating FROM MedianRating) AS Median_Rating,         STDEV(pf.Rating) AS Standard_Deviation  FROM Passenger_Feedback pf  WHERE pf.Ride_Date BETWEEN date('now','-1 year') AND date('now');	roller_coaster	2
SELECT CASE WHEN pf.Safety_Perception = 'Unsafe' AND pf.Ride_Experience = 'Scary' THEN '可能存在速度过高、维护不足或设计缺陷' ELSE '无显著隐患' END AS Safety_Hazard FROM Passenger_Feedback pf;	roller_coaster	3
SELECT ((SUM(CASE WHEN pf.Ride_Date BETWEEN date('now', '-1 year') AND date('now') THEN pf.Rating ELSE 0 END) - SUM(CASE WHEN pf.Ride_Date BETWEEN date('now', '-2 years') AND date('now', '-1 year') THEN pf.Rating ELSE 0 END)) / SUM(CASE WHEN pf.Ride_Date BETWEEN date('now', '-2 years') AND date('now', '-1 year') THEN pf.Rating ELSE 0 END)) * 100 AS Rating_Change_Rate FROM Passenger_Feedback pf;	roller_coaster	4
SELECT Track_Length / (Max_Speed * 1000.0 / 3600.0) AS Time_Seconds, CASE WHEN (POWER(Max_Speed * 1000.0 / 3600.0, 2) / (2.0 * Track_Length)) <= 5.0 * 9.8 THEN '安全' ELSE '不安全' END AS Safety_Analysis FROM Roller_Coaster WHERE Max_Speed = 120 AND Track_Length = 1000;	roller_coaster	1
SELECT Coaster_Type, SUM(Track_Length) AS Total_Track_Length, AVG(Max_Speed) AS Average_Max_Speed, AVG(Height) AS Average_Height FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	2
SELECT CASE WHEN Status = 'Under Maintenance' AND Max_G_Force >= 5 THEN '高重力加速度导致的设备磨损或结构疲劳' ELSE '其他原因' END AS Maintenance_Reason FROM Roller_Coaster WHERE Status = 'Under Maintenance' AND Max_G_Force = 6;	roller_coaster	3
SELECT Track_Length / (Max_Speed * 1000.0 / 3600.0) AS Time_Seconds, CASE WHEN Track_Length / (Max_Speed * 1000.0 / 3600.0) > 3600 THEN '不可行' ELSE '可行' END AS Feasibility_Analysis FROM Roller_Coaster WHERE Track_Length = 100000 AND Max_Speed = 1000;	roller_coaster	4
SELECT CASE WHEN (POWER(Speed * 1000.0 / 3600.0, 2) / (Radius * 9.8)) <= 4 THEN '安全' ELSE '不安全' END AS Safety_Analysis FROM Track_Segment WHERE Segment_Type = 'Loop' AND Radius = 10 AND Speed = 90;	roller_coaster	1
SELECT Segment_Type, SUM(Length) AS Total_Length, AVG(Height) AS Average_Height, AVG(Angle) AS Average_Angle FROM Track_Segment GROUP BY Segment_Type;	roller_coaster	2
SELECT CASE WHEN Height <= 50 AND G_Force <= 4 THEN '符合安全标准' ELSE '不符合安全标准' END AS Safety_Standard FROM Track_Segment WHERE Segment_Type = 'Drop' AND Height = 50 AND G_Force = 3;	roller_coaster	3
SELECT Length / (Speed * 1000.0 / 3600.0) AS Time_Seconds, CASE WHEN Length / (Speed * 1000.0 / 3600.0) > 3600 OR G_Force > 5 THEN '不可行' ELSE '可行' END AS Feasibility_Analysis FROM Track_Segment WHERE Length = 1000000 AND Height = 10000 AND G_Force = 10;	roller_coaster	4
SELECT Maintenance_Type, AVG(Maintenance_Cost) AS Average_Maintenance_Cost, Track_Condition FROM Maintenance_Record GROUP BY Maintenance_Type, Track_Condition;	roller_coaster	1
SELECT Safety_Check_Result, AVG(Maintenance_Cost) AS Average_Maintenance_Cost FROM Maintenance_Record GROUP BY Safety_Check_Result;	roller_coaster	2
SELECT Track_Condition, AVG(Maintenance_Cost) AS Average_Maintenance_Cost FROM Maintenance_Record GROUP BY Track_Condition;	roller_coaster	3
SELECT Maintenance_Type, SUM(Maintenance_Cost) AS Total_Maintenance_Cost  FROM Maintenance_Record  WHERE Maintenance_Cost = 100000000    AND Maintenance_Type = 'Emergency'    AND Maintenance_Date BETWEEN date('now','-1 year') AND date('now')  GROUP BY Maintenance_Type;	roller_coaster	4
SELECT Angle, (POWER(Speed * 1000.0 / 3600.0, 2) / (Radius * 9.81)) * SIN(RADIANS(Angle)) AS G_Force FROM Track_Segment ORDER BY Angle;	roller_coaster	1
SELECT Coaster_Type, AVG(Max_Speed) AS Average_Max_Speed, AVG(Track_Length) AS Average_Track_Length FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	2
SELECT Ride_Experience, COUNT(CASE WHEN Rating >= 4 THEN 1 END) * 1.0 / COUNT(Feedback_ID) AS High_Rating_Ratio FROM Passenger_Feedback GROUP BY Ride_Experience ORDER BY High_Rating_Ratio DESC;	roller_coaster	3
SELECT Coaster_Type, AVG(POWER(Max_Speed * 10 * 1000 / 3600, 2) / (Track_Length * 9.81)) AS Average_Max_G_Force FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	4
SELECT Radius, MAX(G_Force) AS Max_G_Force FROM Track_Segment GROUP BY Radius ORDER BY Radius;	roller_coaster	1
SELECT Coaster_Type, AVG(Height) AS Avg_Height, AVG(Drop_Height) AS Avg_Drop_Height FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	2
SELECT Safety_Check_Result, COUNT(*) AS Total_Feedback, SUM(CASE WHEN Safety_Perception = 'Unsafe' THEN 1 ELSE 0 END) AS Unsafe_Count FROM Passenger_Feedback JOIN Maintenance_Record ON Passenger_Feedback.Coaster_ID = Maintenance_Record.Coaster_ID GROUP BY Safety_Check_Result;	roller_coaster	3
SELECT Coaster_Type, AVG((Track_Length * 100) / Max_Speed) AS Avg_Duration FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	4
SELECT Passenger_Feedback.Coaster_ID, AVG(Rating) AS Avg_Rating, Max_G_Force FROM Passenger_Feedback JOIN Roller_Coaster ON Passenger_Feedback.Coaster_ID = Roller_Coaster.Coaster_ID GROUP BY Passenger_Feedback.Coaster_ID, Max_G_Force;	roller_coaster	1
SELECT Passenger_Feedback.Coaster_ID, COUNT(CASE WHEN Ride_Experience = 'Thrilling' THEN 1 END) * 1.0 / COUNT(Feedback_ID) AS Thrilling_Ratio, Max_Speed, Track_Length FROM Passenger_Feedback JOIN Roller_Coaster ON Passenger_Feedback.Coaster_ID = Roller_Coaster.Coaster_ID GROUP BY Passenger_Feedback.Coaster_ID, Max_Speed, Track_Length;	roller_coaster	2
SELECT Maintenance_Record.Coaster_ID, Maintenance_Cost, Track_Condition,  CASE WHEN Track_Condition = 'Excellent' THEN 1 WHEN Track_Condition = 'Good' THEN 2 WHEN Track_Condition = 'Fair' THEN 3 WHEN Track_Condition = 'Poor' THEN 4 END AS Track_Condition_Score,  Maintenance_Cost / CASE WHEN Track_Condition = 'Excellent' THEN 1 WHEN Track_Condition = 'Good' THEN 2 WHEN Track_Condition = 'Fair' THEN 3 WHEN Track_Condition = 'Poor' THEN 4 END AS Maintenance_Cost_Ratio  FROM Maintenance_Record;	roller_coaster	3
SELECT Roller_Coaster.Coaster_ID, CASE WHEN Max_G_Force >= 100 THEN 'Extremely Unsafe' ELSE Passenger_Feedback.Safety_Perception END AS Safety_Perception_Change, CASE WHEN Max_G_Force >= 100 THEN 'Extremely Scary' ELSE Passenger_Feedback.Ride_Experience END AS Ride_Experience_Change FROM Roller_Coaster JOIN Passenger_Feedback ON Roller_Coaster.Coaster_ID = Passenger_Feedback.Coaster_ID;	roller_coaster	4
SELECT Roller_Coaster.Coaster_ID, Max_G_Force, MAX(Track_Segment.Height) AS Max_Height, AVG(CASE WHEN Safety_Perception = 'Very Safe' THEN 1 WHEN Safety_Perception = 'Safe' THEN 0.75 WHEN Safety_Perception = 'Neutral' THEN 0.5 WHEN Safety_Perception = 'Unsafe' THEN 0.25 END) AS Safety_Perception_Score FROM Roller_Coaster JOIN Track_Segment ON Roller_Coaster.Coaster_ID = Track_Segment.Coaster_ID JOIN Passenger_Feedback ON Roller_Coaster.Coaster_ID = Passenger_Feedback.Coaster_ID GROUP BY Roller_Coaster.Coaster_ID, Max_G_Force;	roller_coaster	1
SELECT Roller_Coaster.Coaster_ID,         (COUNT(CASE WHEN Safety_Perception = 'Very Safe' THEN 1 END) * 1.0 / COUNT(Feedback_ID)) AS Very_Safe_Ratio,         Max_Speed,         Drop_Height  FROM Roller_Coaster  JOIN Passenger_Feedback ON Roller_Coaster.Coaster_ID = Passenger_Feedback.Coaster_ID  GROUP BY Roller_Coaster.Coaster_ID, Max_Speed, Drop_Height;	roller_coaster	2
SELECT Maintenance_Type, COUNT(CASE WHEN Safety_Check_Result = 'Pass' THEN 1 END) * 1.0 / COUNT(Maintenance_ID) AS Safety_Check_Pass_Ratio FROM Maintenance_Record GROUP BY Maintenance_Type;	roller_coaster	3
SELECT Coaster_ID, CASE WHEN Track_Length >= 100000 THEN Duration * 10 ELSE Duration END AS Duration_Change, CASE WHEN Track_Length >= 100000 THEN Capacity_Per_Hour / 10 ELSE Capacity_Per_Hour END AS Capacity_Per_Hour_Change FROM Roller_Coaster;	roller_coaster	4
SELECT Coaster_Type,         COUNT(CASE WHEN Ride_Experience = 'Thrilling' THEN 1 END) * 1.0 / COUNT(Feedback_ID) AS Thrilling_Ratio,         AVG(Max_G_Force) AS Avg_Max_G_Force  FROM Roller_Coaster  JOIN Passenger_Feedback ON Roller_Coaster.Coaster_ID = Passenger_Feedback.Coaster_ID  GROUP BY Coaster_Type;	roller_coaster	1
SELECT Park_Name,         COUNT(CASE WHEN Safety_Perception = 'Safe' THEN 1 END) * 1.0 / COUNT(Feedback_ID) AS Safe_Ratio,         AVG(Max_Speed) AS Avg_Max_Speed,         AVG(Track_Length) AS Avg_Track_Length  FROM Roller_Coaster  JOIN Passenger_Feedback ON Roller_Coaster.Coaster_ID = Passenger_Feedback.Coaster_ID  GROUP BY Park_Name;	roller_coaster	2
SELECT Maintenance_Type,         COUNT(CASE WHEN Ride_Experience = 'Bumpy' THEN 1 END) * 1.0 / COUNT(Feedback_ID) AS Bumpy_Ratio,         AVG(CASE             WHEN Track_Condition = 'Excellent' THEN 1             WHEN Track_Condition = 'Good' THEN 2             WHEN Track_Condition = 'Fair' THEN 3             WHEN Track_Condition = 'Poor' THEN 4         END) AS Avg_Track_Condition_Score  FROM Maintenance_Record  JOIN Roller_Coaster ON Maintenance_Record.Coaster_ID = Roller_Coaster.Coaster_ID  JOIN Passenger_Feedback ON Roller_Coaster.Coaster_ID = Passenger_Feedback.Coaster_ID  GROUP BY Maintenance_Type;	roller_coaster	3
SELECT      Status,      COUNT(CASE WHEN Safety_Perception = 'Very Safe' THEN 1 END) * 1.0 / COUNT(Feedback_ID) AS Very_Safe_Ratio,      AVG(Max_Speed) AS Avg_Max_Speed  FROM Roller_Coaster  JOIN Passenger_Feedback ON Roller_Coaster.Coaster_ID = Passenger_Feedback.Coaster_ID  WHERE Capacity_Per_Hour >= 1000000  GROUP BY Status;	roller_coaster	4
SELECT Coaster_Type, AVG(0.5 * 1000 * POWER(Max_Speed, 2)) AS Avg_Kinetic_Energy FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	1
SELECT Manufacturer, AVG(Track_Length / Height) AS Avg_Length_Height_Ratio FROM Roller_Coaster GROUP BY Manufacturer;	roller_coaster	2
SELECT Status, CASE WHEN Max_G_Force <= 4 THEN 'Yes' ELSE 'No' END AS Suitable_For_All_Ages FROM Roller_Coaster GROUP BY Status, Suitable_For_All_Ages;	roller_coaster	3
SELECT Coaster_Type, AVG(0.5 * 1000 * POWER(10 * Max_Speed, 2)) AS Avg_New_Kinetic_Energy FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	4
SELECT Coaster_Type, AVG(70 * 9.8 * Drop_Height) AS Avg_Potential_Energy_Change FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	1
SELECT Manufacturer, AVG(Track_Length / Inversions) AS Avg_Length_Inversions_Ratio FROM Roller_Coaster GROUP BY Manufacturer;	roller_coaster	2
SELECT Park_Name, SUM(Duration * Capacity_Per_Hour * 10) AS Daily_Max_Capacity FROM Roller_Coaster GROUP BY Park_Name;	roller_coaster	3
SELECT Coaster_Type, AVG(Track_Length * 100) AS Avg_New_Track_Length FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	4
SELECT Coaster_Type, AVG(70 * 9.8 * Max_G_Force) AS Avg_Equivalent_Weight FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	1
SELECT Manufacturer, AVG((Track_Length / Height) * Max_Speed) AS Avg_Complexity_Score FROM Roller_Coaster GROUP BY Manufacturer;	roller_coaster	2
SELECT Status, CASE WHEN Max_Speed <= 100 AND Max_G_Force <= 4 THEN 'Yes' ELSE 'No' END AS Suitable_For_Heart_Patients FROM Roller_Coaster GROUP BY Status, Suitable_For_Heart_Patients;	roller_coaster	3
SELECT Coaster_Type, AVG(70 * 9.8 * (50 * Max_G_Force)) AS Avg_New_Equivalent_Weight FROM Roller_Coaster GROUP BY Coaster_Type;	roller_coaster	4
SELECT Segment_ID, MAX(70 * G_Force * 9.8) AS Force_On_Passenger FROM Track_Segment GROUP BY Segment_ID;	roller_coaster	1
SELECT Segment_ID, 0.5 * 5000 * POWER(Speed, 2) AS Energy_Consumption FROM Track_Segment;	roller_coaster	2
SELECT Track_Segment.Coaster_ID, Roller_Coaster.Coaster_Type, SUM(Length) AS Total_Length FROM Track_Segment JOIN Roller_Coaster ON Track_Segment.Coaster_ID = Roller_Coaster.Coaster_ID GROUP BY Track_Segment.Coaster_ID, Roller_Coaster.Coaster_Type;	roller_coaster	3
SELECT Segment_ID, 5000 * POWER(1000 * 1000 / 3600, 2) / Radius AS Centripetal_Force FROM Track_Segment;	roller_coaster	4
SELECT Segment_ID, Coaster_ID, G_Force, (300.0 / (G_Force * 9.8 * 5000.0 / 0.01)) AS Fatigue_Life FROM Track_Segment;	roller_coaster	1
SELECT Segment_ID, Coaster_ID, 0.5 * 5000 * Speed * Speed AS Kinetic_Energy, 5000 * 9.8 * Height AS Potential_Energy, 0.5 * 1.225 * Speed * Speed * 0.82 * 2.5 + 0.3 * 5000 * 9.8 * Length AS Energy_Loss FROM Track_Segment;	roller_coaster	2
SELECT ts.Coaster_ID, rc.Coaster_Type, SUM(ts.Radius) AS Total_Radius, AVG((ts.G_Force * 5000 * ts.Length) / (200 * 0.01)) AS Elastic_Deformation FROM Track_Segment ts JOIN Roller_Coaster rc ON ts.Coaster_ID = rc.Coaster_ID GROUP BY ts.Coaster_ID, rc.Coaster_Type;	roller_coaster	3
SELECT Segment_ID, Coaster_ID, 5000 * Speed * Speed / Radius AS Centripetal_Force, (5000 * Speed * Speed / Radius) / 0.01 AS Max_Stress FROM Track_Segment;	roller_coaster	4
SELECT Segment_ID, Coaster_ID, G_Force, ((5000 * G_Force * 9.8) * Speed) / (210e9 * 0.01) AS Dynamic_Stress FROM Track_Segment;	roller_coaster	1
SELECT Segment_ID, Coaster_ID, 0.5 * 5000 * Speed * Speed AS Kinetic_Energy, 5000 * 9.8 * Height AS Potential_Energy, 0.5 * 1.225 * Speed * Speed * 0.82 * 2.5 + 0.3 * 5000 * 9.8 * Length + 0.5 * 10000 * (G_Force * 5000 * Length / (210e9 * 0.01)) * (G_Force * 5000 * Length / (210e9 * 0.01)) AS Energy_Loss FROM Track_Segment;	roller_coaster	2
SELECT ts.Coaster_ID, rc.Coaster_Type, SUM(ts.Radius) AS Total_Radius, AVG((ts.G_Force * 5000 * ts.Length) / (210e9 * 0.01) + 12e-6 * 20 * ts.Length) AS Deformation FROM Track_Segment ts JOIN Roller_Coaster rc ON ts.Coaster_ID = rc.Coaster_ID GROUP BY ts.Coaster_ID, rc.Coaster_Type;	roller_coaster	3
SELECT Segment_ID, Coaster_ID, 5000.0 * Speed * Speed / Radius AS Centripetal_Force, (5000.0 * Speed * Speed / Radius) / 0.01 + 12e-6 * 20.0 * 210e9 AS Max_Stress FROM Track_Segment;	roller_coaster	4
SELECT Track_Condition, AVG(Maintenance_Cost) AS Avg_Maintenance_Cost FROM Maintenance_Record GROUP BY Track_Condition;	roller_coaster	1
SELECT Safety_Check_Result, COUNT(Maintenance_ID) * 1.0 / COUNT(DISTINCT Maintenance_Date) AS Maintenance_Frequency FROM Maintenance_Record GROUP BY Safety_Check_Result;	roller_coaster	2
SELECT Maintenance_Type, AVG(Maintenance_Cost) AS Avg_Maintenance_Cost FROM Maintenance_Record GROUP BY Maintenance_Type;	roller_coaster	3
SELECT Track_Condition, AVG(Maintenance_Cost) AS Avg_Maintenance_Cost FROM Maintenance_Record WHERE Maintenance_Cost >= 1000000 GROUP BY Track_Condition;	roller_coaster	4
SELECT Segment_ID, Coaster_ID, G_Force, 70 * G_Force * 9.8 AS Force_On_Passenger FROM Track_Segment;	roller_coaster	1
SELECT SUM(Maintenance_Cost) AS Total_Maintenance_Cost FROM Maintenance_Record WHERE Maintenance_Type = 'Routine' AND strftime('%Y', Maintenance_Date) = strftime('%Y', 'now');	roller_coaster	2
SELECT Safety_Perception, AVG(Rating) AS Avg_Rating FROM Passenger_Feedback GROUP BY Safety_Perception;	roller_coaster	3
SELECT Segment_ID, Coaster_ID, 10 * 9.8 AS Extreme_G_Force, 70 * 10 * 9.8 AS Extreme_Force_On_Passenger FROM Track_Segment;	roller_coaster	4
SELECT Segment_ID, Coaster_ID, (70 * Speed * Speed / Radius) >= (5 * 70 * 9.8) AS Is_Centripetal_Force_Exceeded FROM Track_Segment WHERE Segment_Type = 'Loop';	roller_coaster	1
WITH Rating_Mapping AS (     SELECT Coaster_ID,             CASE WHEN Rating = 1 THEN 1 ELSE 0 END AS Rating_Value      FROM Passenger_Feedback ),  Condition_Mapping AS (     SELECT Coaster_ID,             CASE                 WHEN Track_Condition = 'Poor' THEN 1                 WHEN Track_Condition = 'Fair' THEN 2                 WHEN Track_Condition = 'Good' THEN 3                 WHEN Track_Condition = 'Excellent' THEN 4             END AS Condition_Value      FROM Maintenance_Record )  SELECT (SUM((Rating_Value - (SELECT AVG(Rating_Value) FROM Rating_Mapping)) *               (Condition_Value - (SELECT AVG(Condition_Value) FROM Condition_Mapping))) /          (COUNT(*) *           (SELECT SQRT(AVG(Rating_Value * Rating_Value) - AVG(Rating_Value) * AVG(Rating_Value)) FROM Rating_Mapping) *           (SELECT SQRT(AVG(Condition_Value * Condition_Value) - AVG(Condition_Value) * AVG(Condition_Value)) FROM Condition_Mapping)))         ) AS Correlation_Coefficient  FROM Rating_Mapping  JOIN Condition_Mapping ON Rating_Mapping.Coaster_ID = Condition_Mapping.Coaster_ID;	roller_coaster	2
SELECT DISTINCT mr.Coaster_ID  FROM Maintenance_Record mr  JOIN Passenger_Feedback pf ON mr.Coaster_ID = pf.Coaster_ID  WHERE mr.Maintenance_Type = 'Emergency'  AND pf.Safety_Perception = 'Unsafe'  AND julianday('now') - julianday(mr.Maintenance_Date) <= 90  AND pf.Ride_Date >= mr.Maintenance_Date;	roller_coaster	3
SELECT * FROM Maintenance_Record WHERE Maintenance_Cost > 100000000 AND Coaster_ID IN (SELECT Coaster_ID FROM Passenger_Feedback GROUP BY Coaster_ID HAVING MIN(Rating) = 5 AND MAX(Rating) = 5) AND Safety_Check_Result = 'Fail';	roller_coaster	4
SELECT ts.Segment_ID, ts.Coaster_ID, ABS(0.8 * SQRT(2 * 9.8 * ts.Height) - rc.Max_Speed) / rc.Max_Speed > 0.1 AS Is_Speed_Out_of_Range FROM Track_Segment ts JOIN Roller_Coaster rc ON ts.Coaster_ID = rc.Coaster_ID WHERE ts.Segment_Type = 'Drop';	roller_coaster	1
SELECT rc.Coaster_ID,         (SUM(ts.Length) / rc.Track_Length) > 0.5 AS Is_Length_Over_Half,         rc.Inversions = COUNT(ts.Segment_ID) AS Is_Inversions_Equal  FROM Roller_Coaster rc  JOIN Track_Segment ts ON rc.Coaster_ID = ts.Coaster_ID  WHERE rc.Coaster_Type = 'Steel'    AND ts.Segment_Type IN ('Loop', 'Corkscrew')  GROUP BY rc.Coaster_ID, rc.Track_Length, rc.Inversions;	roller_coaster	2
WITH Safe_Feedback AS (     SELECT pf.Coaster_ID, COUNT(pf.Feedback_ID) AS Safe_Count      FROM Passenger_Feedback pf      WHERE pf.Safety_Perception IN ('Safe', 'Very Safe')      GROUP BY pf.Coaster_ID ),  Total_Feedback AS (     SELECT pf.Coaster_ID, COUNT(pf.Feedback_ID) AS Total_Count      FROM Passenger_Feedback pf      GROUP BY pf.Coaster_ID )  SELECT sf.Coaster_ID, ((sf.Safe_Count * 1.0) / tf.Total_Count) >= 0.9 AS Is_Safe_Perception_High  FROM Safe_Feedback sf  JOIN Total_Feedback tf ON sf.Coaster_ID = tf.Coaster_ID  WHERE sf.Coaster_ID IN (     SELECT mr.Coaster_ID      FROM Maintenance_Record mr      WHERE mr.Safety_Check_Result = 'Pass'      GROUP BY mr.Coaster_ID      HAVING COUNT(*) >= 3 );	roller_coaster	3
SELECT Coaster_ID, CASE WHEN Max_G_Force > 12 AND Duration = 86400 THEN Capacity_Per_Hour > 200 * (3600.0 / Duration) ELSE NULL END AS Is_Capacity_Exceeded FROM Roller_Coaster;	roller_coaster	4
WITH Theoretical_Speed AS (     SELECT Coaster_ID, SQRT(2 * 9.8 * Drop_Height) AS Theoretical_Max_Speed      FROM Roller_Coaster ),  Filtered_Coasters AS (     SELECT rc.Coaster_ID      FROM Roller_Coaster rc      JOIN Theoretical_Speed ts ON rc.Coaster_ID = ts.Coaster_ID      WHERE rc.Max_Speed < 0.8 * ts.Theoretical_Max_Speed )  SELECT fc.Coaster_ID  FROM Filtered_Coasters fc  WHERE fc.Coaster_ID NOT IN (     SELECT DISTINCT mr.Coaster_ID      FROM Maintenance_Record mr      WHERE mr.Maintenance_Type = 'Routine'      AND mr.Maintenance_Date >= date('now','-3 month') );	roller_coaster	1
WITH Annual_Capacity AS (     SELECT          Coaster_ID,          Capacity_Per_Hour * (Duration / 3600.0) * 18 * 365 AS Annual_Capacity      FROM Roller_Coaster      WHERE Capacity_Per_Hour > 5000 AND (Duration / 3600.0) > 18 ) SELECT ac.Coaster_ID  FROM Annual_Capacity ac  WHERE ac.Annual_Capacity > 1073741824  AND ac.Coaster_ID NOT IN (     SELECT DISTINCT mr.Coaster_ID      FROM Maintenance_Record mr      WHERE mr.Track_Condition = 'Excellent' );	roller_coaster	2
WITH High_G_Force_Coasters AS (     SELECT Coaster_ID      FROM Roller_Coaster      WHERE Max_G_Force > 4 ),  Unsafe_Feedback AS (     SELECT DISTINCT pf.Coaster_ID      FROM Passenger_Feedback pf      WHERE pf.Safety_Perception = 'Unsafe' )  SELECT hg.Coaster_ID  FROM High_G_Force_Coasters hg  JOIN Unsafe_Feedback uf ON hg.Coaster_ID = uf.Coaster_ID  WHERE hg.Coaster_ID NOT IN (     SELECT DISTINCT mr.Coaster_ID      FROM Maintenance_Record mr      WHERE mr.Maintenance_Cost > 1000000 );	roller_coaster	3
WITH Centripetal_Force AS (     SELECT Coaster_ID, (2000 * POWER(1000 / 3.6, 2)) / 0.5 AS Required_Force      FROM Roller_Coaster ) SELECT cf.Coaster_ID  FROM Centripetal_Force cf  WHERE cf.Required_Force > 1e9  AND cf.Coaster_ID NOT IN (     SELECT DISTINCT mr.Coaster_ID      FROM Maintenance_Record mr      WHERE mr.Maintenance_Type = 'Upgrade' );	roller_coaster	4
SELECT rc.Coaster_ID, rc.Coaster_Name      FROM Roller_Coaster rc      WHERE rc.Track_Length < 1.5 * (POWER(rc.Max_Speed / 3.6, 2) / (2 * 0.2 * 9.8))      AND rc.Coaster_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Safety_Check_Result = 'Pass');	roller_coaster	1
SELECT rc.Coaster_ID, rc.Coaster_Name FROM Roller_Coaster rc WHERE (rc.Duration / 60) > 20 AND (SELECT COUNT(mr.Maintenance_ID) FROM Maintenance_Record mr WHERE mr.Coaster_ID = rc.Coaster_ID) / (JULIANDAY(rc.Updated_At) - JULIANDAY(rc.Created_At)) < 0.05 AND rc.Coaster_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Track_Condition = 'Excellent');	roller_coaster	2
SELECT rc.Coaster_ID, rc.Coaster_Name  FROM Roller_Coaster rc  WHERE rc.Coaster_ID IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Track_Condition IN ('Fair', 'Poor'))  AND rc.Coaster_ID IN (SELECT pf.Coaster_ID FROM Passenger_Feedback pf WHERE pf.Ride_Experience = 'Bumpy')  AND rc.Coaster_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Maintenance_Type = 'Routine' AND mr.Maintenance_Date >= date('now', '-30 days'));	roller_coaster	3
SELECT rc.Coaster_ID, rc.Coaster_Name FROM Roller_Coaster rc WHERE rc.Coaster_ID IN (SELECT ts.Coaster_ID FROM Track_Segment ts WHERE ts.Angle = 127) AND rc.Coaster_ID NOT IN (SELECT ts.Coaster_ID FROM Track_Segment ts WHERE ts.G_Force > 5);	roller_coaster	4
SELECT ts.Segment_ID, ts.Coaster_ID FROM Track_Segment ts WHERE ts.Radius < (POWER(ts.Speed / 3.6, 2) / (5 * 9.8)) AND ts.G_Force > 5 AND ts.Coaster_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Maintenance_Type = 'Emergency' AND mr.Maintenance_Date >= date('now', '-1 month'));	roller_coaster	1
SELECT ts.Segment_ID, ts.Coaster_ID FROM Track_Segment ts WHERE (2000 * 9.8 * ts.Height + 1000 * (ts.Speed / 3.6) * (ts.Speed / 3.6)) > 1e9 AND ts.Angle > 60 AND ts.Coaster_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Maintenance_Cost > 100000);	roller_coaster	2
SELECT ts.Segment_ID, ts.Coaster_ID FROM Track_Segment ts WHERE ts.Radius < 10 AND ts.Speed > 100 AND ts.Segment_Type = 'Curve' AND ts.Coaster_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Safety_Check_Result = 'Pass');	roller_coaster	3
SELECT ts.Segment_ID, ts.Coaster_ID  FROM Track_Segment ts  WHERE ts.Angle = 180  AND ts.Speed > 3 * 3.6 * SQRT(2 * 9.8 * ts.Height + POWER(ts.Speed / 3.6, 2))  AND ts.Coaster_ID NOT IN (SELECT ts2.Coaster_ID FROM Track_Segment ts2 WHERE ts2.G_Force > 10);	roller_coaster	4
SELECT ts.Segment_ID, ts.Coaster_ID, ts.Segment_Type, ts.Length, ts.Height, ts.Angle, ts.Radius, ts.G_Force, ts.Speed  FROM Track_Segment ts  WHERE ts.Segment_Type = 'Corkscrew'  AND ts.Radius < 15  AND (500000000 * 0.1) / (2000 * POWER((ts.Speed / 3.6), 2)) * ts.Radius < 1.25  AND ts.Segment_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Maintenance_Type = 'Upgrade');	roller_coaster	1
WITH EnergyChange AS (     SELECT          ts1.Segment_ID,          ABS(1000 * (POWER(ts2.Speed, 2) - POWER(ts1.Speed, 2)) + 19600 * (ts2.Height - ts1.Height)) / rc.Duration AS EnergyRate      FROM Track_Segment ts1      JOIN Track_Segment ts2 ON ts1.Coaster_ID = ts2.Coaster_ID AND ts1.Segment_ID = ts2.Segment_ID - 1      JOIN Roller_Coaster rc ON ts1.Coaster_ID = rc.Coaster_ID      WHERE rc.Duration > 5 ),  CostPercentile AS (     SELECT          Coaster_ID,          (SELECT CAST(COUNT(*) AS REAL) FROM Maintenance_Record m2 WHERE m2.Maintenance_Cost <= m1.Maintenance_Cost) / (SELECT COUNT(*) FROM Maintenance_Record) AS PercentRank      FROM Maintenance_Record m1 ) SELECT ec.Segment_ID  FROM EnergyChange ec  WHERE ec.EnergyRate > 10000000  AND ec.Segment_ID NOT IN (     SELECT cp.Coaster_ID      FROM CostPercentile cp      WHERE cp.PercentRank > 0.95 );	roller_coaster	2
SELECT ts.Segment_ID, ts.Coaster_ID, ts.Segment_Type, ts.Length, ts.Height, ts.Angle, ts.Radius, ts.G_Force, ts.Speed  FROM Track_Segment ts  WHERE ts.Segment_Type = 'Straight'  AND ts.Speed > 200  AND ts.Length < 50  AND ts.Segment_ID NOT IN (     SELECT mr.Coaster_ID      FROM Maintenance_Record mr      WHERE mr.Maintenance_Type = 'Emergency'      AND mr.Maintenance_Date >= datetime('now', '-2 days') );	roller_coaster	3
SELECT ts.Segment_ID, ts.Coaster_ID, ts.Segment_Type, ts.Length, ts.Height, ts.Angle, ts.Radius, ts.G_Force, ts.Speed FROM Track_Segment ts WHERE (2000 * POWER((100000 * 9.8 * 3600), 2)) / (2 * 4.184 * POWER(10, 15)) > 1 AND ts.Coaster_ID NOT IN (SELECT rc.Coaster_ID FROM Roller_Coaster rc WHERE rc.Manufacturer = 'XXX');	roller_coaster	4
SELECT ts.Segment_ID, ts.Coaster_ID, ts.Segment_Type, ts.Height, ts.Speed  FROM Track_Segment ts  WHERE ts.Segment_Type = 'Drop'  AND ts.Height > 50  AND (POWER(ts.Speed / 3.6, 2) / (2 * 9.8 * ts.Height)) < 0.81  AND ts.Segment_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Maintenance_Type = 'Upgrade');	roller_coaster	1
SELECT ts.Segment_ID, ts.Coaster_ID, ts.Segment_Type, ts.Speed, ts.Radius FROM Track_Segment ts WHERE ts.Segment_Type = 'Loop' AND (2000 * POWER(ts.Speed / 3.6, 3) / ts.Radius) > 1000000 AND ts.Coaster_ID IN (SELECT rc.Coaster_ID FROM Roller_Coaster rc WHERE rc.Inversions >= 3) AND ts.Coaster_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Maintenance_Cost > (SELECT MAX(Maintenance_Cost) * 0.9 FROM Maintenance_Record));	roller_coaster	2
SELECT ts.Segment_ID, ts.Coaster_ID, ts.Segment_Type, ts.G_Force, ts.Angle  FROM Track_Segment ts  WHERE ts.Segment_Type = 'Inverted'  AND ts.G_Force > 3.5  AND ts.Angle > 45  AND ts.Segment_ID NOT IN (     SELECT mr.Coaster_ID      FROM Maintenance_Record mr      WHERE mr.Safety_Check_Result = 'Pass'      AND mr.Maintenance_Date >= date('now', '-7 days') );	roller_coaster	3
SELECT ts.Segment_ID, ts.Coaster_ID, ts.Segment_Type, ts.Speed, ts.Angle  FROM Track_Segment ts  WHERE ts.Angle = 90  AND ts.Speed > 1224  AND (2000 * POWER(ts.Speed / 3.6, 2) / 5 + 2000 * 9.8) > 1000000  AND ts.Segment_ID NOT IN (SELECT mr.Coaster_ID FROM Maintenance_Record mr WHERE mr.Track_Condition = 'Poor');	roller_coaster	4
SELECT COUNT(*) * 70 * 9.81 AS total_weight FROM Crew;	ship	1
SELECT Gender, Nationality, COUNT(*) * 1.0 / (SELECT COUNT(*) FROM Crew) AS nationality_ratio FROM Crew GROUP BY Gender, Nationality;	ship	2
SELECT Crew_ID, First_Name, Last_Name, Ranks, Experience_Years, (CASE WHEN Ranks = 'Captain' THEN 10 WHEN Ranks = 'First Mate' THEN 8 ELSE 5 END) * Experience_Years AS salary_level FROM Crew ORDER BY salary_level DESC;	ship	3
SELECT COUNT(*) * 10 AS min_area FROM Crew;	ship	4
SELECT Port_Name, Country FROM Port WHERE Max_Draft >= 10;	ship	1
SELECT Port_Name, (50.0 / Berth_Capacity) * 100 AS Utilization_Rate FROM Port;	ship	2
SELECT Port_Name, CASE WHEN Port_Type = 'Commercial' THEN 'Commercial Goods' WHEN Port_Type = 'Fishing' THEN 'Fish Products' WHEN Port_Type = 'Military' THEN 'Military Supplies' WHEN Port_Type = 'Recreational' THEN 'Tourist Goods' ELSE 'Unknown' END AS Main_Cargo_Type FROM Port;	ship	3
SELECT (365 / 7) * 1000 AS Total_Ships_Per_Year;	ship	4
SELECT Ship_Name, Gross_Tonnage * 1025 * 9.81 AS Total_Buoyancy FROM Ship WHERE Gross_Tonnage = 50000;	ship	1
SELECT Ship_Name, 1000.0 / 200 AS Avg_Speed FROM Ship;	ship	2
SELECT Ship_Name, CASE WHEN Ship_Type = 'Cargo' THEN 'Long-Distance Freight Routes, Freight Services' WHEN Ship_Type = 'Passenger' THEN 'Short-Distance Passenger Routes, Passenger Services' WHEN Ship_Type = 'Fishing' THEN 'Fishing Routes, Fishing Services' WHEN Ship_Type = 'Military' THEN 'Strategic Routes, Military Services' ELSE 'Unknown' END AS Suitable_Route_And_Service FROM Ship;	ship	3
SELECT Ship_Name, 1000000.0 / (1000 * 200 * 1025) AS Draft_Depth FROM Ship WHERE Gross_Tonnage = 1000000;	ship	4
SELECT Voyage_ID, 10000 * 50 * 0.2 AS Fuel_Consumption FROM Voyage_Plan;	ship	1
SELECT Voyage_ID, 500.0 / 100 AS Avg_Speed FROM Voyage_Plan;	ship	2
SELECT Voyage_ID, Cargo_Weight / Gross_Tonnage AS Loading_Capacity, CASE WHEN Cargo_Type = 'Heavy' THEN 'High Stability Required' WHEN Cargo_Type = 'Light' THEN 'Standard Safety' WHEN Cargo_Type = 'Hazardous' THEN 'Enhanced Safety Measures' ELSE 'Unknown' END AS Safety_Level FROM Voyage_Plan JOIN Ship ON Voyage_Plan.Ship_ID = Ship.Ship_ID;	ship	3
SELECT Voyage_ID, 10000 * 1000 * 0.5 AS Fuel_Consumption FROM Voyage_Plan WHERE Cargo_Weight = 1000000;	ship	4
SELECT Ship_ID, COUNT(Crew_ID) * 70 * 9.81 AS Total_Weight FROM Crew GROUP BY Ship_ID ORDER BY Total_Weight ASC;	ship	1
SELECT Gender, Nationality, COUNT(Crew_ID) * 1.0 / SUM(COUNT(Crew_ID)) OVER (PARTITION BY Gender) AS Nationality_Ratio FROM Crew GROUP BY Gender, Nationality ORDER BY Nationality_Ratio DESC;	ship	2
SELECT Crew_ID, Ranks, Experience_Years, CASE WHEN Ranks = 'Captain' THEN 10 WHEN Ranks = 'First Mate' THEN 8 WHEN Ranks = 'Engineer' THEN 6 ELSE 4 END * Experience_Years AS Salary_Level FROM Crew ORDER BY Salary_Level DESC;	ship	3
SELECT Ship_ID, COUNT(Crew_ID) * 10 AS Required_Area FROM Crew GROUP BY Ship_ID ORDER BY Required_Area ASC;	ship	4
SELECT p.Port_Name, 10000 * 9.81 AS Buoyancy FROM Port p JOIN Ship s ON p.Port_ID = s.Ship_ID WHERE p.Max_Draft >= (10000 / (s.Gross_Tonnage / s.Draft)) ORDER BY Buoyancy ASC;	ship	1
SELECT Port_Type, AVG((50.0 / Berth_Capacity) * 100) AS Avg_Utilization_Rate FROM Port GROUP BY Port_Type ORDER BY Avg_Utilization_Rate DESC;	ship	2
SELECT Port_Name, CASE WHEN Port_Type = 'Commercial' THEN 'Commercial Goods, Container Shipping' WHEN Port_Type = 'Fishing' THEN 'Fish Products, Refrigerated Transport' WHEN Port_Type = 'Military' THEN 'Military Supplies, Specialized Transport' WHEN Port_Type = 'Recreational' THEN 'Tourist Goods, Passenger Transport' ELSE 'Unknown' END AS Main_Cargo_And_Transport FROM Port ORDER BY Main_Cargo_And_Transport ASC;	ship	3
SELECT Port_Name, (365 / 30) * 10000 AS Total_Ships_Per_Year FROM Port ORDER BY Total_Ships_Per_Year DESC;	ship	4
SELECT Ship_Name, Gross_Tonnage * 1025 * 9.81 AS Total_Buoyancy FROM Ship WHERE Gross_Tonnage = 50000 ORDER BY Total_Buoyancy ASC;	ship	1
SELECT Ship_Name, 500.0 / 100 AS Avg_Speed FROM Ship ORDER BY Avg_Speed DESC;	ship	2
SELECT Ship_Name, CASE WHEN Ship_Type = 'Cargo' THEN 'Long-Distance Freight Routes, Freight Services' WHEN Ship_Type = 'Passenger' THEN 'Short-Distance Passenger Routes, Passenger Services' WHEN Ship_Type = 'Fishing' THEN 'Fishing Routes, Fishing Services' WHEN Ship_Type = 'Military' THEN 'Strategic Routes, Military Services' ELSE 'Unknown' END AS Suitable_Route_And_Service FROM Ship ORDER BY Suitable_Route_And_Service ASC;	ship	3
SELECT Ship_Name, 1000000.0 / (1000 * 200 * 1025) AS Draft_Depth FROM Ship WHERE Gross_Tonnage = 1000000 ORDER BY Draft_Depth DESC;	ship	4
SELECT Voyage_ID, 10000 * 50 * 0.2 AS Fuel_Consumption FROM Voyage_Plan ORDER BY Fuel_Consumption ASC;	ship	1
SELECT Voyage_ID, 500.0 / 100 AS Avg_Speed FROM Voyage_Plan ORDER BY Avg_Speed DESC;	ship	2
SELECT Voyage_ID, Cargo_Weight / Gross_Tonnage AS Loading_Capacity, CASE WHEN Cargo_Type = 'Heavy' THEN 'High Stability Required' WHEN Cargo_Type = 'Light' THEN 'Standard Safety' WHEN Cargo_Type = 'Hazardous' THEN 'Enhanced Safety Measures' ELSE 'Unknown' END AS Safety_Level FROM Voyage_Plan JOIN Ship ON Voyage_Plan.Ship_ID = Ship.Ship_ID ORDER BY Loading_Capacity ASC;	ship	3
SELECT Voyage_ID, 10000 * 1000 * 0.5 AS Fuel_Consumption FROM Voyage_Plan WHERE Cargo_Weight = 1000000 ORDER BY Fuel_Consumption DESC;	ship	4
SELECT Gender, COUNT(Crew_ID) * 70 * 9.81 AS Total_Weight FROM Crew GROUP BY Gender;	ship	1
SELECT Nationality, Gender, COUNT(Crew_ID) * 1.0 / (SELECT COUNT(*) FROM Crew) AS Nationality_Ratio FROM Crew GROUP BY Nationality, Gender;	ship	2
SELECT Ranks, Experience_Years, CASE WHEN Ranks = 'Captain' THEN 10 WHEN Ranks = 'First Mate' THEN 8 WHEN Ranks = 'Engineer' THEN 6 ELSE 4 END * Experience_Years AS Salary_Level FROM Crew GROUP BY Ranks, Experience_Years;	ship	3
SELECT Ranks, COUNT(Crew_ID) * 10 AS Required_Area FROM Crew GROUP BY Ranks;	ship	4
SELECT p.Port_Type, 10000 * 9.81 AS Buoyancy FROM Port p JOIN Ship s ON p.Port_ID = s.Ship_ID WHERE p.Max_Draft >= (10000 / (s.Gross_Tonnage / s.Draft)) GROUP BY p.Port_Type;	ship	1
SELECT Port_Type, Country, AVG((50.0 / Berth_Capacity) * 100) AS Avg_Utilization_Rate FROM Port GROUP BY Port_Type, Country;	ship	2
SELECT Port_Type, Country, CASE WHEN Port_Type = 'Commercial' THEN 'Commercial Goods, Container Shipping' WHEN Port_Type = 'Fishing' THEN 'Fish Products, Refrigerated Transport' WHEN Port_Type = 'Military' THEN 'Military Supplies, Specialized Transport' WHEN Port_Type = 'Recreational' THEN 'Tourist Goods, Passenger Transport' ELSE 'Unknown' END AS Main_Cargo_And_Transport FROM Port GROUP BY Port_Type, Country;	ship	3
SELECT Port_Type, Country, (365.0 / 30.0) * 10000 AS Total_Ships_Per_Year FROM Port GROUP BY Port_Type, Country;	ship	4
SELECT Ship_Type, Gross_Tonnage * 1025 * 9.81 AS Total_Buoyancy FROM Ship WHERE Gross_Tonnage = 50000 GROUP BY Ship_Type;	ship	1
SELECT Ship_Type, Flag_Country, 500.0 / 100 AS Avg_Speed FROM Ship GROUP BY Ship_Type, Flag_Country;	ship	2
SELECT Ship_Type, Flag_Country, CASE WHEN Ship_Type = 'Cargo' THEN 'Long-Distance Freight Routes, Freight Services' WHEN Ship_Type = 'Passenger' THEN 'Short-Distance Passenger Routes, Passenger Services' WHEN Ship_Type = 'Fishing' THEN 'Fishing Routes, Fishing Services' WHEN Ship_Type = 'Military' THEN 'Strategic Routes, Military Services' ELSE 'Unknown' END AS Suitable_Route_And_Service FROM Ship GROUP BY Ship_Type, Flag_Country;	ship	3
SELECT Ship_Type, Flag_Country, 1000000.0 / (1000 * 200 * 1025) AS Draft_Depth FROM Ship WHERE Gross_Tonnage = 1000000 GROUP BY Ship_Type, Flag_Country;	ship	4
SELECT s.Ship_Type, 10000 * 50 * 0.2 AS Fuel_Consumption FROM Voyage_Plan v JOIN Ship s ON v.Ship_ID = s.Ship_ID GROUP BY s.Ship_Type;	ship	1
SELECT s.Ship_Type, s.Flag_Country, 500.0 / 100 AS Avg_Speed FROM Voyage_Plan v JOIN Ship s ON v.Ship_ID = s.Ship_ID GROUP BY s.Ship_Type, s.Flag_Country;	ship	2
SELECT v.Cargo_Type, s.Ship_Type, MAX(v.Cargo_Weight / s.Gross_Tonnage) AS Loading_Capacity, CASE WHEN v.Cargo_Type = 'Heavy' THEN 'High Stability Required' WHEN v.Cargo_Type = 'Light' THEN 'Standard Safety' WHEN v.Cargo_Type = 'Hazardous' THEN 'Enhanced Safety Measures' ELSE 'Unknown' END AS Safety_Level FROM Voyage_Plan v JOIN Ship s ON v.Ship_ID = s.Ship_ID GROUP BY v.Cargo_Type, s.Ship_Type;	ship	3
SELECT s.Ship_Type, s.Flag_Country, 10000 * 1000 * 0.5 AS Fuel_Consumption  FROM Voyage_Plan v  JOIN Ship s ON v.Ship_ID = s.Ship_ID  WHERE v.Cargo_Weight = 1000000  GROUP BY s.Ship_Type, s.Flag_Country;	ship	4
SELECT Crew_ID, COUNT(Crew_ID) * 70 * 9.81 AS Total_Weight FROM Crew WHERE Ship_ID NOT IN (SELECT Ship_ID FROM Ship) GROUP BY Crew_ID;	ship	1
SELECT Nationality, COUNT(Crew_ID) * 1.0 / (SELECT COUNT(*) FROM Crew WHERE Ship_ID NOT IN (SELECT Ship_ID FROM Ship)) AS Nationality_Ratio FROM Crew WHERE Ship_ID NOT IN (SELECT Ship_ID FROM Ship) GROUP BY Nationality;	ship	2
SELECT Crew_ID, Ranks, Experience_Years,         CASE           WHEN Ranks = 'Captain' THEN 10           WHEN Ranks = 'First Mate' THEN 8           WHEN Ranks = 'Engineer' THEN 6           ELSE 4         END * Experience_Years AS Salary_Level  FROM Crew  WHERE Ship_ID NOT IN (SELECT Ship_ID FROM Ship);	ship	3
SELECT Crew_ID, COUNT(Crew_ID) * 10 AS Required_Area FROM Crew WHERE Ship_ID NOT IN (SELECT Ship_ID FROM Ship) GROUP BY Crew_ID;	ship	4
SELECT Port_ID, 10000 * 9.81 AS Buoyancy  FROM Port  WHERE Port_ID NOT IN (SELECT DISTINCT Port_ID FROM Ship)  AND Max_Draft >= (10000 / (SELECT AVG(Gross_Tonnage / Draft) FROM Ship));	ship	1
SELECT Port_Type, AVG((50.0 / Berth_Capacity) * 100) AS Avg_Utilization_Rate FROM Port WHERE Port_ID NOT IN (SELECT DISTINCT Port_ID FROM Ship) GROUP BY Port_Type;	ship	2
SELECT Port_Type, Country, CASE WHEN Port_Type = 'Commercial' THEN 'Commercial Goods, Container Shipping' WHEN Port_Type = 'Fishing' THEN 'Fish Products, Refrigerated Transport' WHEN Port_Type = 'Military' THEN 'Military Supplies, Specialized Transport' WHEN Port_Type = 'Recreational' THEN 'Tourist Goods, Passenger Transport' ELSE 'Unknown' END AS Main_Cargo_And_Transport FROM Port WHERE Port_ID NOT IN (SELECT DISTINCT Port_ID FROM Ship);	ship	3
SELECT Port_ID, (365.0 / 30) * 10000 AS Total_Ships_Per_Year FROM Port WHERE Port_ID NOT IN (SELECT DISTINCT Port_ID FROM Ship);	ship	4
SELECT Ship_ID, Gross_Tonnage * 1025 * 9.81 AS Total_Buoyancy FROM Ship WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Voyage_Plan);	ship	1
SELECT Ship_ID, 500.0 / 100 AS Avg_Speed FROM Ship WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Voyage_Plan);	ship	2
SELECT Ship_ID, Ship_Type, CASE WHEN Ship_Type = 'Cargo' THEN 'Long-Distance Freight Routes, Freight Services' WHEN Ship_Type = 'Passenger' THEN 'Short-Distance Passenger Routes, Passenger Services' WHEN Ship_Type = 'Fishing' THEN 'Fishing Routes, Fishing Services' WHEN Ship_Type = 'Military' THEN 'Strategic Routes, Military Services' ELSE 'Unknown' END AS Suitable_Route_And_Service FROM Ship WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Voyage_Plan);	ship	3
SELECT Ship_ID, 1000000.0 / (1000 * 200 * 1025) AS Draft_Depth FROM Ship WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Voyage_Plan);	ship	4
SELECT Voyage_ID, 10000 * 50 * 0.2 AS Fuel_Consumption FROM Voyage_Plan WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Ship);	ship	1
SELECT Voyage_ID, 500.0 / 100 AS Avg_Speed FROM Voyage_Plan WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Ship);	ship	2
SELECT Voyage_ID, Cargo_Type, Cargo_Weight / (SELECT Gross_Tonnage FROM Ship WHERE Ship.Ship_ID = Voyage_Plan.Ship_ID) AS Loading_Capacity, CASE WHEN Cargo_Type = 'Heavy' THEN 'High Stability Required' WHEN Cargo_Type = 'Light' THEN 'Standard Safety' WHEN Cargo_Type = 'Hazardous' THEN 'Enhanced Safety Measures' ELSE 'Unknown' END AS Safety_Level FROM Voyage_Plan WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Ship);	ship	3
SELECT Voyage_ID, 10000 * 1000 * 0.5 AS Fuel_Consumption  FROM Voyage_Plan  WHERE Ship_ID NOT IN (SELECT DISTINCT Ship_ID FROM Ship);	ship	4
SELECT c.Crew_ID, COUNT(c.Crew_ID) * 70 * 9.81 AS Total_Weight, p.Max_Draft  FROM Crew c  JOIN Port p ON c.Ship_ID = p.Port_ID  GROUP BY c.Crew_ID, p.Max_Draft;	ship	1
SELECT c.Nationality, COUNT(c.Crew_ID) * 1.0 / (SELECT COUNT(*) FROM Crew) AS Nationality_Ratio, p.Berth_Capacity FROM Crew c JOIN Port p ON c.Ship_ID = p.Port_ID GROUP BY c.Nationality, p.Berth_Capacity;	ship	2
SELECT c.Crew_ID, c.Ranks, c.Experience_Years, CASE WHEN c.Ranks = 'Captain' THEN 10 WHEN c.Ranks = 'First Mate' THEN 8 WHEN c.Ranks = 'Engineer' THEN 6 ELSE 4 END * c.Experience_Years AS Salary_Level, p.Port_Type FROM Crew c JOIN Port p ON c.Ship_ID = p.Port_ID;	ship	3
SELECT c.Crew_ID, COUNT(c.Crew_ID) * 10 AS Required_Area, p.Max_Draft  FROM Crew c  JOIN Port p ON c.Ship_ID = p.Port_ID  GROUP BY c.Crew_ID, p.Max_Draft;	ship	4
SELECT c.Crew_ID, COUNT(c.Crew_ID) * 70 * 9.81 AS Total_Weight, s.Gross_Tonnage FROM Crew c JOIN Ship s ON c.Ship_ID = s.Ship_ID GROUP BY c.Crew_ID, s.Gross_Tonnage;	ship	1
SELECT c.Nationality, COUNT(c.Crew_ID) * 1.0 / (SELECT COUNT(*) FROM Crew) AS Nationality_Ratio, s.Crew_Capacity  FROM Crew c  JOIN Ship s ON c.Ship_ID = s.Ship_ID  GROUP BY c.Nationality, s.Crew_Capacity;	ship	2
SELECT c.Crew_ID, c.Ranks, c.Experience_Years, CASE WHEN c.Ranks = 'Captain' THEN 10 WHEN c.Ranks = 'First Mate' THEN 8 WHEN c.Ranks = 'Engineer' THEN 6 ELSE 4 END * c.Experience_Years AS Salary_Level, s.Ship_Type FROM Crew c JOIN Ship s ON c.Ship_ID = s.Ship_ID;	ship	3
SELECT s.Gross_Tonnage, COUNT(c.Crew_ID) * 10 AS Required_Area FROM Crew c JOIN Ship s ON c.Ship_ID = s.Ship_ID GROUP BY s.Ship_ID, s.Gross_Tonnage;	ship	4
SELECT s.Ship_ID, s.Gross_Tonnage * 1025 * 9.81 AS Total_Buoyancy, p.Max_Draft  FROM Ship s  JOIN Port p ON s.Ship_ID = p.Port_ID  WHERE s.Gross_Tonnage = 50000;	ship	1
SELECT s.Ship_ID, 500.0 / 100 AS Avg_Speed, p.Berth_Capacity FROM Ship s JOIN Port p ON s.Ship_ID = p.Port_ID;	ship	2
SELECT s.Ship_ID, s.Ship_Type,         CASE            WHEN s.Ship_Type = 'Cargo' THEN 'Long-Distance Freight Routes, Freight Services'           WHEN s.Ship_Type = 'Passenger' THEN 'Short-Distance Passenger Routes, Passenger Services'           WHEN s.Ship_Type = 'Fishing' THEN 'Fishing Routes, Fishing Services'           WHEN s.Ship_Type = 'Military' THEN 'Strategic Routes, Military Services'           ELSE 'Unknown'        END AS Suitable_Route_And_Service,        p.Port_Type  FROM Ship s  JOIN Port p ON s.Ship_ID = p.Port_ID;	ship	3
SELECT s.Ship_ID, 1000000.0 / (1000 * 200 * 1025) AS Draft_Depth, p.Max_Draft FROM Ship s JOIN Port p ON s.Ship_ID = p.Port_ID WHERE s.Gross_Tonnage = 1000000;	ship	4
SELECT v.Voyage_ID, 10000 * 50 * 0.2 AS Fuel_Consumption, s.Gross_Tonnage  FROM Voyage_Plan v  JOIN Ship s ON v.Ship_ID = s.Ship_ID;	ship	1
SELECT v.Voyage_ID, 500.0 / 100 AS Avg_Speed, s.Crew_Capacity FROM Voyage_Plan v JOIN Ship s ON v.Ship_ID = s.Ship_ID;	ship	2
SELECT v.Voyage_ID, v.Cargo_Type, v.Cargo_Weight / s.Gross_Tonnage AS Loading_Capacity, CASE WHEN v.Cargo_Type = 'Heavy' THEN 'High Stability Required' WHEN v.Cargo_Type = 'Light' THEN 'Standard Safety' WHEN v.Cargo_Type = 'Hazardous' THEN 'Enhanced Safety Measures' ELSE 'Unknown' END AS Safety_Level, s.Ship_Type FROM Voyage_Plan v JOIN Ship s ON v.Ship_ID = s.Ship_ID;	ship	3
SELECT v.Voyage_ID, 10000 * 1000 * 0.5 AS Fuel_Consumption, s.Gross_Tonnage FROM Voyage_Plan v JOIN Ship s ON v.Ship_ID = s.Ship_ID WHERE v.Cargo_Weight = 1000000;	ship	4
SELECT Gender, COUNT(Crew_ID) * 70 * 9.81 AS Total_Weight FROM Crew GROUP BY Gender;	ship	1
SELECT Nationality, CAST(COUNT(Crew_ID) AS REAL) / (SELECT COUNT(*) FROM Crew) AS Nationality_Ratio FROM Crew GROUP BY Nationality;	ship	2
SELECT Ranks,         CASE             WHEN Ranks = 'Captain' THEN 10             WHEN Ranks = 'First Mate' THEN 8             WHEN Ranks = 'Engineer' THEN 6             ELSE 4         END * AVG(Experience_Years) AS Salary_Level  FROM Crew  GROUP BY Ranks;	ship	3
SELECT Ranks, COUNT(Crew_ID) * 10 AS Required_Area FROM Crew GROUP BY Ranks;	ship	4
SELECT Nationality, AVG(strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) AS Avg_Age FROM Crew WHERE Gender = 'Male' GROUP BY Nationality;	ship	1
SELECT Ranks, COUNT(Crew_ID) AS Total_Count FROM Crew WHERE Experience_Years > 10 GROUP BY Ranks;	ship	2
SELECT Ranks, MAX(First_Name) AS First_Name, MAX(Last_Name) AS Last_Name, MAX(Contact_Number) AS Contact_Number FROM Crew WHERE Status = 'Active' GROUP BY Ranks;	ship	3
SELECT Nationality, AVG(Experience_Years + 1000) AS Avg_Experience FROM Crew GROUP BY Nationality;	ship	4
SELECT p1.Port_Name AS Port1, p2.Port_Name AS Port2,         6371.0 * 2.0 * ASIN(SQRT(POWER(SIN((RADIANS(p2.Latitude) - RADIANS(p1.Latitude)) / 2.0), 2.0) +         COS(RADIANS(p1.Latitude)) * COS(RADIANS(p2.Latitude)) *         POWER(SIN((RADIANS(p2.Longitude) - RADIANS(p1.Longitude)) / 2.0), 2.0))) AS Distance  FROM Port p1, Port p2  WHERE p1.Port_ID <> p2.Port_ID;	ship	1
SELECT Country, AVG(Max_Draft) AS Avg_Max_Draft FROM Port GROUP BY Country;	ship	2
SELECT Port_Name, Berth_Capacity FROM Port WHERE Port_Type = 'Commercial' AND Berth_Capacity > 100;	ship	3
SELECT Port_Name, Max_Draft FROM Port WHERE Max_Draft = 1000;	ship	4
SELECT Ship_Type, MAX(Engine_Power * 1.0 / Gross_Tonnage) AS Max_Power_Weight_Ratio FROM Ship GROUP BY Ship_Type ORDER BY Max_Power_Weight_Ratio DESC LIMIT 1;	ship	1
SELECT Ship_Type, MAX(Crew_Capacity * 1.0 / Length) AS Max_Crew_Density FROM Ship GROUP BY Ship_Type ORDER BY Max_Crew_Density DESC LIMIT 1;	ship	2
SELECT AVG(Passenger_Capacity) AS Avg_Passenger_Capacity FROM Ship WHERE Ship_Type = '客船' AND Passenger_Capacity > 1000;	ship	3
SELECT 1000 * 200 * 50 * 1 AS Displacement;	ship	4
SELECT VP.Ship_ID,         AVG(6371 * 2 * ASIN(SQRT(POWER(SIN((RADIANS(P2.Latitude) - RADIANS(P1.Latitude)) / 2), 2) + COS(RADIANS(P1.Latitude)) * COS(RADIANS(P2.Latitude)) * POWER(SIN((RADIANS(P2.Longitude) - RADIANS(P1.Longitude)) / 2), 2))) / (strftime('%s', VP.Arrival_Time) - strftime('%s', VP.Departure_Time))) AS Avg_Speed,         MAX(S.Max_Speed) AS Max_Speed  FROM Voyage_Plan VP  JOIN Port P1 ON VP.Departure_Port_ID = P1.Port_ID  JOIN Port P2 ON VP.Arrival_Port_ID = P2.Port_ID  JOIN Ship S ON VP.Ship_ID = S.Ship_ID  GROUP BY VP.Ship_ID  HAVING Avg_Speed > 0.9 * MAX(S.Max_Speed);	ship	1
SELECT VP.Voyage_ID, (VP.Cargo_Weight + (VP.Passenger_Count * 75)) AS Total_Weight  FROM Voyage_Plan VP  JOIN Ship S ON VP.Ship_ID = S.Ship_ID  WHERE (VP.Cargo_Weight + (VP.Passenger_Count * 75)) > S.Gross_Tonnage * 0.8;	ship	2
SELECT COUNT(*) * 1.0 / (SELECT COUNT(*) FROM Voyage_Plan) AS Same_Country_Ratio FROM Voyage_Plan VP JOIN Port P1 ON VP.Departure_Port_ID = P1.Port_ID JOIN Port P2 ON VP.Arrival_Port_ID = P2.Port_ID WHERE P1.Country = P2.Country;	ship	3
SELECT VP.Ship_ID, AVG(6371 * 2 * ASIN(SQRT(POWER(SIN((RADIANS(P2.Latitude) - RADIANS(P1.Latitude)) / 2), 2) + COS(RADIANS(P1.Latitude)) * COS(RADIANS(P2.Latitude)) * POWER(SIN((RADIANS(P2.Longitude) - RADIANS(P1.Longitude)) / 2), 2))) / (strftime('%s', VP.Arrival_Time) - strftime('%s', VP.Departure_Time))) AS Avg_Speed, MAX(S.Max_Speed * 10) AS New_Max_Speed FROM Voyage_Plan VP JOIN Port P1 ON VP.Departure_Port_ID = P1.Port_ID JOIN Port P2 ON VP.Arrival_Port_ID = P2.Port_ID JOIN Ship S ON VP.Ship_ID = S.Ship_ID GROUP BY VP.Ship_ID HAVING Avg_Speed > 0.9 * MAX(S.Max_Speed * 10);	ship	4
SELECT First_Name, Last_Name, Date_Of_Birth, (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) AS Age FROM Crew ORDER BY Age ASC LIMIT 5;	submarine	1
SELECT First_Name, Last_Name, Experience_Years, (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) AS Age, (Experience_Years / (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth))) AS Experience_Age_Ratio FROM Crew ORDER BY Experience_Age_Ratio DESC LIMIT 5;	submarine	2
SELECT Nationality, COUNT(Nationality) AS Nationality_Count FROM Crew GROUP BY Nationality ORDER BY Nationality_Count DESC LIMIT 3;	submarine	3
SELECT First_Name, Last_Name, (Experience_Years + 1000) AS New_Experience_Years, (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) AS Age, ((Experience_Years + 1000) / (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth))) AS New_Experience_Age_Ratio FROM Crew ORDER BY New_Experience_Age_Ratio DESC LIMIT 5;	submarine	4
SELECT Maintenance_Date, AVG(Maintenance_Cost) AS Avg_Maintenance_Cost  FROM Maintenance_Record  WHERE Pressure_Test_Result = 'Pass'  GROUP BY Maintenance_Date  ORDER BY Maintenance_Date ASC  LIMIT 5;	submarine	1
SELECT Maintenance_Date, SUM(Maintenance_Cost) AS Total_Maintenance_Cost  FROM Maintenance_Record  WHERE Hull_Integrity_Check = 'Pass' AND Propulsion_System_Check = 'Pass'  GROUP BY Maintenance_Date  ORDER BY Maintenance_Date DESC  LIMIT 5;	submarine	2
SELECT Maintenance_Type, Maintenance_Cost FROM Maintenance_Record WHERE Maintenance_Type = 'Emergency' ORDER BY Maintenance_Cost DESC LIMIT 3;	submarine	3
SELECT Maintenance_Date, SUM(Maintenance_Cost * 100) AS New_Total_Maintenance_Cost FROM Maintenance_Record GROUP BY Maintenance_Date ORDER BY Maintenance_Date ASC LIMIT 5;	submarine	4
SELECT Mission_ID, Pressure_Endured, Max_Depth_Reached, (Pressure_Endured * 1.0 / Max_Depth_Reached) AS Pressure_Depth_Ratio FROM Mission ORDER BY Pressure_Depth_Ratio ASC LIMIT 5;	submarine	1
SELECT Mission_ID, Max_Depth_Reached, (strftime('%s', End_time) - strftime('%s', Start_time)) / 3600.0 AS Duration_Hours, (Max_Depth_Reached / ((strftime('%s', End_time) - strftime('%s', Start_time)) / 3600.0)) AS Depth_Time_Ratio FROM Mission ORDER BY Depth_Time_Ratio DESC LIMIT 5;	submarine	2
SELECT Mission_ID, Mission_Type, Max_Depth_Reached FROM Mission WHERE Mission_Type = 'Combat' ORDER BY Max_Depth_Reached DESC LIMIT 3;	submarine	3
SELECT Mission_ID, (Pressure_Endured * 1000) AS New_Pressure_Endured, Max_Depth_Reached, ((Pressure_Endured * 1000) / Max_Depth_Reached) AS New_Pressure_Depth_Ratio FROM Mission ORDER BY New_Pressure_Depth_Ratio ASC LIMIT 5;	submarine	4
SELECT Submarine_ID, Displacement, Max_Depth, (Displacement * 1.0 / Max_Depth) AS Displacement_Depth_Ratio FROM Submarine ORDER BY Displacement_Depth_Ratio ASC LIMIT 5;	submarine	1
SELECT Submarine_ID, Length, Beam, (CAST(Length AS REAL) / Beam) AS Length_Beam_Ratio FROM Submarine ORDER BY Length_Beam_Ratio DESC LIMIT 5;	submarine	2
SELECT Submarine_ID, Submarine_Type, Max_Speed FROM Submarine WHERE Submarine_Type = 'Attack' ORDER BY Max_Speed DESC LIMIT 3;	submarine	3
SELECT Submarine_ID, (Displacement * 1000) AS New_Displacement, Max_Depth, ((Displacement * 1000) / Max_Depth) AS New_Displacement_Depth_Ratio FROM Submarine ORDER BY New_Displacement_Depth_Ratio ASC LIMIT 5;	submarine	4
SELECT Submarine_Type, AVG(CAST(Displacement AS REAL) / Max_Depth) AS Avg_Displacement_Depth_Ratio FROM Submarine GROUP BY Submarine_Type;	submarine	1
WITH Length_Beam_Ratio AS (     SELECT Propulsion_Type, (CAST(Length AS REAL) / CAST(Beam AS REAL)) AS Ratio      FROM Submarine ) SELECT Propulsion_Type, AVG(Ratio) AS Median_Length_Beam_Ratio  FROM (     SELECT Propulsion_Type, Ratio,             ROW_NUMBER() OVER (PARTITION BY Propulsion_Type ORDER BY Ratio) AS RowAsc,            ROW_NUMBER() OVER (PARTITION BY Propulsion_Type ORDER BY Ratio DESC) AS RowDesc      FROM Length_Beam_Ratio ) AS Subquery  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc - 1 = RowDesc  GROUP BY Propulsion_Type;	submarine	2
SELECT Status, MAX(Crew_Capacity * 1.0 / Torpedo_Count) AS Max_Crew_Torpedo_Ratio FROM Submarine GROUP BY Status;	submarine	3
SELECT Submarine_Type, MAX((Displacement * 1000) / Max_Depth) AS Max_New_Displacement_Depth_Ratio FROM Submarine GROUP BY Submarine_Type;	submarine	4
SELECT Mission_Type, AVG(Pressure_Endured / Max_Depth_Reached) AS Avg_Pressure_Depth_Ratio FROM Mission GROUP BY Mission_Type;	submarine	1
WITH Depth_Time_Ratio AS (     SELECT          Mission_Status,          (Max_Depth_Reached / (strftime('%s', End_time) - strftime('%s', Start_time))) AS Ratio      FROM Mission ) SELECT      Mission_Status,      AVG(Ratio) AS Median_Depth_Time_Ratio  FROM (     SELECT          Mission_Status,          Ratio,          ROW_NUMBER() OVER (PARTITION BY Mission_Status ORDER BY Ratio) AS RowAsc,          ROW_NUMBER() OVER (PARTITION BY Mission_Status ORDER BY Ratio DESC) AS RowDesc      FROM Depth_Time_Ratio ) AS Subquery  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc - 1 = RowDesc  GROUP BY Mission_Status;	submarine	2
SELECT Mission_Location, COUNT(Mission_ID) AS Active_Sonar_Mission_Count FROM Mission WHERE Sonar_Usage = 'Active' GROUP BY Mission_Location;	submarine	3
SELECT Mission_Type, MAX((Pressure_Endured * 1000) / Max_Depth_Reached) AS Max_New_Pressure_Depth_Ratio FROM Mission GROUP BY Mission_Type;	submarine	4
SELECT Maintenance_Type, AVG(Maintenance_Cost) AS Avg_Maintenance_Cost FROM Maintenance_Record WHERE Pressure_Test_Result = 'Pass' GROUP BY Maintenance_Type;	submarine	1
SELECT strftime('%Y', Maintenance_Date) AS Maintenance_Year, SUM(Maintenance_Cost) AS Total_Maintenance_Cost FROM Maintenance_Record WHERE Hull_Integrity_Check = 'Pass' AND Propulsion_System_Check = 'Pass' GROUP BY strftime('%Y', Maintenance_Date);	submarine	2
SELECT S.Status, COUNT(M.Maintenance_ID) AS Emergency_Maintenance_Count  FROM Maintenance_Record M  JOIN Submarine S ON M.Submarine_ID = S.Submarine_ID  WHERE M.Maintenance_Type = 'Emergency'  GROUP BY S.Status;	submarine	3
SELECT Maintenance_Type, MAX(Maintenance_Cost * 1000) AS Max_New_Maintenance_Cost FROM Maintenance_Record GROUP BY Maintenance_Type;	submarine	4
SELECT Status, AVG(strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)) AS Avg_Age FROM Crew GROUP BY Status;	submarine	1
WITH Crew_Experience AS (     SELECT          Ranks AS Crew_Rank,          Experience_Years * 1.0 / NULLIF((julianday('now') - julianday(Date_Of_Birth)) / 365.25, 0) AS Experience_Age_Ratio      FROM Crew ),  Ranked_Experience AS (     SELECT          Crew_Rank,          Experience_Age_Ratio,          ROW_NUMBER() OVER (PARTITION BY Crew_Rank ORDER BY Experience_Age_Ratio) AS row_num,          COUNT(*) OVER (PARTITION BY Crew_Rank) AS total_count      FROM Crew_Experience )  SELECT      Crew_Rank,      AVG(Experience_Age_Ratio) AS Median_Experience_Age_Ratio  FROM Ranked_Experience  WHERE row_num = (total_count + 1) / 2      OR row_num = (total_count + 2) / 2  GROUP BY Crew_Rank;	submarine	2
SELECT Specialty, COUNT(DISTINCT Nationality) AS Nationality_Count FROM Crew GROUP BY Specialty;	submarine	3
SELECT Status, MAX((Experience_Years + 1000) / (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth))) AS Max_Experience_Age_Ratio FROM Crew GROUP BY Status;	submarine	4
SELECT * FROM Crew WHERE (strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth) > 50) AND Ranks != '艇长';	submarine	1
SELECT * FROM Crew WHERE (Experience_Years / ((julianday('now') - julianday(Date_Of_Birth)) / 365.25)) > 1 AND Specialty != '声呐操作';	submarine	2
SELECT * FROM Crew WHERE Nationality = '美国' AND Status != 'Active';	submarine	3
SELECT * FROM Crew WHERE ((Experience_Years + 1000) / ((strftime('%Y', 'now') - strftime('%Y', Date_Of_Birth)))) > 100 AND Ranks != '大副';	submarine	4
SELECT * FROM Maintenance_Record WHERE Pressure_Test_Result = 'Pass' AND Maintenance_Type != 'Routine';	submarine	1
SELECT * FROM Maintenance_Record WHERE (Maintenance_Cost / strftime('%Y', Maintenance_Date)) > 1000 AND Maintenance_Type != 'Emergency';	submarine	2
SELECT * FROM Maintenance_Record WHERE Hull_Integrity_Check = 'Pass' AND Maintenance_Type != 'Upgrade';	submarine	3
SELECT * FROM Maintenance_Record WHERE ((Maintenance_Cost * 10000) / strftime('%Y', Maintenance_Date)) > 1000000 AND Maintenance_Type != 'Routine';	submarine	4
SELECT * FROM Mission WHERE Max_Depth_Reached > 500 AND Mission_Type != 'Combat';	submarine	1
SELECT * FROM Mission WHERE (Pressure_Endured / Max_Depth_Reached) > 10 AND Mission_Status != 'Completed';	submarine	2
SELECT * FROM Mission WHERE Sonar_Usage = 'Active' AND Mission_Type != 'Surveillance';	submarine	3
SELECT * FROM Mission WHERE ((Pressure_Endured * 10000) / Max_Depth_Reached) > 100000 AND Mission_Type != 'Research';	submarine	4
SELECT * FROM Submarine WHERE Displacement > 10000 AND Submarine_Type != 'Attack';	submarine	1
SELECT * FROM Submarine WHERE (Length / Beam) > 10 AND Propulsion_Type != '核动力';	submarine	2
SELECT * FROM Submarine WHERE Crew_Capacity > 100 AND Status != 'Active';	submarine	3
SELECT * FROM Submarine WHERE (Displacement + 100000) > 1000000 AND Submarine_Type != 'Research';	submarine	4
SELECT c.ranks, AVG(m.Maintenance_Cost) AS Avg_Maintenance_Cost FROM Crew c JOIN Maintenance_Record m ON c.Submarine_ID = m.Submarine_ID WHERE m.Pressure_Test_Result = 'Pass' GROUP BY c.ranks;	submarine	1
SELECT c.Experience_Years, SUM(m.Maintenance_Cost) AS Total_Maintenance_Cost  FROM Crew c  JOIN Maintenance_Record m ON c.Submarine_ID = m.Submarine_ID  WHERE m.Hull_Integrity_Check = 'Pass' AND m.Propulsion_System_Check = 'Pass'  GROUP BY c.Experience_Years;	submarine	2
SELECT c.Status, COUNT(m.Maintenance_ID) AS Maintenance_Count FROM Crew c JOIN Maintenance_Record m ON c.Submarine_ID = m.Submarine_ID WHERE m.Maintenance_Type = 'Emergency' GROUP BY c.Status;	submarine	3
SELECT c.Specialty, MAX(m.Maintenance_Cost * 10000) AS Max_Maintenance_Cost FROM Crew c JOIN Maintenance_Record m ON c.Submarine_ID = m.Submarine_ID GROUP BY c.Specialty;	submarine	4
SELECT c.Ranks, AVG(m.Pressure_Endured / m.Max_Depth_Reached) AS Avg_Pressure_Depth_Ratio  FROM Crew c  JOIN Mission m ON c.Submarine_ID = m.Submarine_ID  GROUP BY c.Ranks;	submarine	1
WITH DepthDurationRatio AS (     SELECT          c.Experience_Years,          (m.Max_Depth_Reached / (JULIANDAY(m.End_time) - JULIANDAY(m.Start_time)) * 86400.0) AS Depth_Duration_Ratio,         ROW_NUMBER() OVER (PARTITION BY c.Experience_Years ORDER BY (m.Max_Depth_Reached / (JULIANDAY(m.End_time) - JULIANDAY(m.Start_time)) * 86400.0)) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY c.Experience_Years ORDER BY (m.Max_Depth_Reached / (JULIANDAY(m.End_time) - JULIANDAY(m.Start_time)) * 86400.0) DESC) AS RowDesc     FROM Crew c      JOIN Mission m ON c.Submarine_ID = m.Submarine_ID ) SELECT      Experience_Years,      AVG(Depth_Duration_Ratio) AS Median_Depth_Duration_Ratio FROM DepthDurationRatio  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1 GROUP BY Experience_Years;	submarine	2
SELECT c.Specialty, COUNT(m.Mission_ID) AS Mission_Count  FROM Crew c  JOIN Mission m ON c.Submarine_ID = m.Submarine_ID  WHERE m.Sonar_Usage = 'Active'  GROUP BY c.Specialty;	submarine	3
SELECT c.Status, MAX((m.Pressure_Endured * 10000) / m.Max_Depth_Reached) AS Max_Pressure_Depth_Ratio FROM Crew c JOIN Mission m ON c.Submarine_ID = m.Submarine_ID GROUP BY c.Status;	submarine	4
SELECT c.Ranks, AVG(s.Displacement / s.Max_Depth) AS Avg_Displacement_Depth_Ratio  FROM Crew c  JOIN Submarine s ON c.Submarine_ID = s.Submarine_ID  GROUP BY c.Ranks;	submarine	1
WITH LengthBeamRatio AS (     SELECT          c.Experience_Years,          (s.Length * 1.0 / s.Beam) AS Length_Beam_Ratio,         ROW_NUMBER() OVER (PARTITION BY c.Experience_Years ORDER BY (s.Length * 1.0 / s.Beam)) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY c.Experience_Years ORDER BY (s.Length * 1.0 / s.Beam) DESC) AS RowDesc     FROM Crew c      JOIN Submarine s ON c.Submarine_ID = s.Submarine_ID ) SELECT      Experience_Years,      AVG(Length_Beam_Ratio) AS Median_Length_Beam_Ratio  FROM LengthBeamRatio  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1  GROUP BY Experience_Years;	submarine	2
SELECT c.Specialty, MAX(CAST(s.Crew_Capacity AS REAL) / s.Torpedo_Count) AS Max_Crew_Torpedo_Ratio FROM Crew c JOIN Submarine s ON c.Submarine_ID = s.Submarine_ID GROUP BY c.Specialty;	submarine	3
SELECT c.Status, MAX((s.Displacement + 100000) / s.Max_Depth) AS Max_Displacement_Depth_Ratio FROM Crew c JOIN Submarine s ON c.Submarine_ID = s.Submarine_ID GROUP BY c.Status;	submarine	4
SELECT m.Mission_Type, AVG(mr.Maintenance_Cost * 1.0 / m.Pressure_Endured) AS Avg_Maintenance_Pressure_Ratio  FROM Maintenance_Record mr  JOIN Mission m ON mr.Submarine_ID = m.Submarine_ID  WHERE mr.Pressure_Test_Result = 'Pass'  GROUP BY m.Mission_Type;	submarine	1
WITH TimeDiff AS (     SELECT          mr.Maintenance_Type,          julianday(mr.Maintenance_Date) - julianday(m.Start_time) AS Time_Difference,         ROW_NUMBER() OVER (PARTITION BY mr.Maintenance_Type ORDER BY julianday(mr.Maintenance_Date) - julianday(m.Start_time)) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY mr.Maintenance_Type ORDER BY julianday(mr.Maintenance_Date) - julianday(m.Start_time) DESC) AS RowDesc     FROM Maintenance_Record mr      JOIN Mission m ON mr.Submarine_ID = m.Submarine_ID ) SELECT      Maintenance_Type,      AVG(Time_Difference) AS Median_Time_Difference  FROM TimeDiff  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1  GROUP BY Maintenance_Type;	submarine	2
SELECT * FROM Maintenance_Record mr JOIN Mission m ON mr.Submarine_ID = m.Submarine_ID WHERE mr.Hull_Integrity_Check = 'Pass' AND m.Mission_Status != 'Completed';	submarine	3
SELECT m.Mission_Type, MAX((mr.Maintenance_Cost * 100000) / m.Pressure_Endured) AS Max_Maintenance_Pressure_Ratio  FROM Maintenance_Record mr  JOIN Mission m ON mr.Submarine_ID = m.Submarine_ID  GROUP BY m.Mission_Type;	submarine	4
SELECT s.Submarine_Type, AVG(mr.Maintenance_Cost * 1.0 / s.Displacement) AS Avg_Maintenance_Displacement_Ratio FROM Maintenance_Record mr JOIN Submarine s ON mr.Submarine_ID = s.Submarine_ID WHERE mr.Pressure_Test_Result = 'Pass' GROUP BY s.Submarine_Type;	submarine	1
WITH TimeDiff AS (     SELECT          mr.Maintenance_Type,          (julianday(mr.Maintenance_Date) - julianday(s.Commission_Date)) / 365.0 AS Time_Difference,         ROW_NUMBER() OVER (PARTITION BY mr.Maintenance_Type ORDER BY (julianday(mr.Maintenance_Date) - julianday(s.Commission_Date)) / 365.0) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY mr.Maintenance_Type ORDER BY (julianday(mr.Maintenance_Date) - julianday(s.Commission_Date)) / 365.0 DESC) AS RowDesc     FROM Maintenance_Record mr      JOIN Submarine s ON mr.Submarine_ID = s.Submarine_ID ) SELECT      Maintenance_Type,      AVG(Time_Difference) AS Median_Time_Difference FROM TimeDiff  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1 GROUP BY Maintenance_Type;	submarine	2
SELECT * FROM Maintenance_Record mr JOIN Submarine s ON mr.Submarine_ID = s.Submarine_ID WHERE mr.Hull_Integrity_Check = 'Pass' AND s.Status != 'Active';	submarine	3
SELECT s.Submarine_Type, MAX((mr.Maintenance_Cost * 1000000) / s.Displacement) AS Max_Maintenance_Displacement_Ratio  FROM Maintenance_Record mr  JOIN Submarine s ON mr.Submarine_ID = s.Submarine_ID  GROUP BY s.Submarine_Type;	submarine	4
SELECT s.Submarine_Type, AVG(m.Pressure_Endured * 1.0 / s.Max_Depth) AS Avg_Pressure_Depth_Ratio FROM Mission m JOIN Submarine s ON m.Submarine_ID = s.Submarine_ID GROUP BY s.Submarine_Type;	submarine	1
WITH TimeLengthRatio AS (     SELECT          m.Mission_Type,          (strftime('%s', m.End_time) - strftime('%s', m.Start_time)) / s.Length AS Time_Length_Ratio,         ROW_NUMBER() OVER (PARTITION BY m.Mission_Type ORDER BY (strftime('%s', m.End_time) - strftime('%s', m.Start_time)) / s.Length) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY m.Mission_Type ORDER BY (strftime('%s', m.End_time) - strftime('%s', m.Start_time)) / s.Length DESC) AS RowDesc     FROM Mission m      JOIN Submarine s ON m.Submarine_ID = s.Submarine_ID ) SELECT      Mission_Type,      AVG(Time_Length_Ratio) AS Median_Time_Length_Ratio FROM TimeLengthRatio  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1 GROUP BY Mission_Type;	submarine	2
SELECT * FROM Mission m JOIN Submarine s ON m.Submarine_ID = s.Submarine_ID WHERE m.Sonar_Usage = 'Active' AND s.Status != 'Active';	submarine	3
SELECT s.Submarine_Type, MAX((m.Pressure_Endured * 100000) / s.Max_Depth) AS Max_Pressure_Depth_Ratio FROM Mission m JOIN Submarine s ON m.Submarine_ID = s.Submarine_ID GROUP BY s.Submarine_Type;	submarine	4
SELECT c.Ranks, AVG(mr.Maintenance_Cost) AS Avg_Maintenance_Cost  FROM Crew c  JOIN Maintenance_Record mr ON c.Submarine_ID = mr.Submarine_ID  WHERE mr.Pressure_Test_Result = 'Pass'  GROUP BY c.Ranks;	submarine	1
WITH MaintenanceExperienceRatio AS (     SELECT          mr.Maintenance_Type,          (JULIANDAY(mr.Maintenance_Date) - JULIANDAY(DATE(c.Date_Of_Birth, '+' || c.Experience_Years || ' years'))) / 365.0 AS Maintenance_Experience_Ratio,         ROW_NUMBER() OVER (PARTITION BY mr.Maintenance_Type ORDER BY (JULIANDAY(mr.Maintenance_Date) - JULIANDAY(DATE(c.Date_Of_Birth, '+' || c.Experience_Years || ' years'))) / 365.0) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY mr.Maintenance_Type ORDER BY (JULIANDAY(mr.Maintenance_Date) - JULIANDAY(DATE(c.Date_Of_Birth, '+' || c.Experience_Years || ' years'))) / 365.0 DESC) AS RowDesc     FROM Crew c      JOIN Maintenance_Record mr ON c.Submarine_ID = mr.Submarine_ID ) SELECT      Maintenance_Type,      AVG(Maintenance_Experience_Ratio) AS Median_Maintenance_Experience_Ratio FROM MaintenanceExperienceRatio  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1 GROUP BY Maintenance_Type;	submarine	2
SELECT c.Status, COUNT(mr.Maintenance_ID) AS Maintenance_Count  FROM Crew c  JOIN Maintenance_Record mr ON c.Submarine_ID = mr.Submarine_ID  WHERE mr.Hull_Integrity_Check = 'Pass'    AND c.Submarine_ID IN (     SELECT Submarine_ID      FROM Crew      GROUP BY Submarine_ID      HAVING COUNT(*) = COUNT(CASE WHEN Status = 'Active' THEN 1 END)   )  GROUP BY c.Status;	submarine	3
SELECT c.Specialty, MAX(mr.Maintenance_Cost * 100000) AS Max_Maintenance_Cost FROM Crew c JOIN Maintenance_Record mr ON c.Submarine_ID = mr.Submarine_ID GROUP BY c.Specialty;	submarine	4
SELECT c.Ranks, AVG(m.Pressure_Endured / m.Max_Depth_Reached) AS Avg_Pressure_Depth_Ratio  FROM Crew c  JOIN Mission m ON c.Submarine_ID = m.Submarine_ID  GROUP BY c.Ranks;	submarine	1
WITH TimeExperienceRatio AS (     SELECT          m.Mission_Type,          (CAST((julianday(m.End_time) - julianday(m.Start_time)) * 86400 AS REAL) / c.Experience_Years) AS Time_Experience_Ratio,         ROW_NUMBER() OVER (PARTITION BY m.Mission_Type ORDER BY (CAST((julianday(m.End_time) - julianday(m.Start_time)) * 86400 AS REAL) / c.Experience_Years)) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY m.Mission_Type ORDER BY (CAST((julianday(m.End_time) - julianday(m.Start_time)) * 86400 AS REAL) / c.Experience_Years) DESC) AS RowDesc     FROM Crew c      JOIN Mission m ON c.Submarine_ID = m.Submarine_ID ) SELECT      Mission_Type,      AVG(Time_Experience_Ratio) AS Median_Time_Experience_Ratio FROM TimeExperienceRatio  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1 GROUP BY Mission_Type;	submarine	2
SELECT c.Specialty, COUNT(m.Mission_ID) AS Mission_Count  FROM Crew c  JOIN Mission m ON c.Submarine_ID = m.Submarine_ID  WHERE m.Sonar_Usage = 'Active'  GROUP BY c.Specialty;	submarine	3
SELECT c.Status, MAX((m.Pressure_Endured * 100000) / m.Max_Depth_Reached) AS Max_Pressure_Depth_Ratio FROM Crew c JOIN Mission m ON c.Submarine_ID = m.Submarine_ID GROUP BY c.Status;	submarine	4
SELECT Ranks, AVG(Displacement * 1.0 / Max_Depth) AS Avg_Displacement_Depth_Ratio FROM Crew JOIN Submarine ON Crew.Submarine_ID = Submarine.Submarine_ID GROUP BY Ranks;	submarine	1
SELECT Experience_Years, AVG(Length_Beam_Ratio) AS Median_Length_Beam_Ratio  FROM (     SELECT Experience_Years, Length / Beam AS Length_Beam_Ratio,            ROW_NUMBER() OVER (PARTITION BY Experience_Years ORDER BY Length / Beam) AS RowAsc,            ROW_NUMBER() OVER (PARTITION BY Experience_Years ORDER BY Length / Beam DESC) AS RowDesc     FROM Crew      JOIN Submarine ON Crew.Submarine_ID = Submarine.Submarine_ID ) AS Subquery  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1  GROUP BY Experience_Years;	submarine	2
SELECT Specialty, MAX(Crew_Capacity * 1.0 / Torpedo_Count) AS Max_Crew_Torpedo_Ratio  FROM Crew  JOIN Submarine ON Crew.Submarine_ID = Submarine.Submarine_ID  GROUP BY Specialty;	submarine	3
SELECT Crew.Status, MAX((Submarine.Displacement + 100000) / Submarine.Max_Depth) AS New_Max_Displacement_Depth_Ratio FROM Crew JOIN Submarine ON Crew.Submarine_ID = Submarine.Submarine_ID GROUP BY Crew.Status;	submarine	4
SELECT Mission_Type, AVG(Maintenance_Cost * 1.0 / Pressure_Endured) AS Avg_Maintenance_Pressure_Ratio FROM Maintenance_Record JOIN Mission ON Maintenance_Record.Submarine_ID = Mission.Submarine_ID WHERE Pressure_Test_Result = 'Pass' GROUP BY Mission_Type;	submarine	1
SELECT Maintenance_Type,         AVG(julianday(Maintenance_Date) - julianday(Start_time)) AS Median_Time_Difference  FROM Maintenance_Record  JOIN Mission ON Maintenance_Record.Submarine_ID = Mission.Submarine_ID  GROUP BY Maintenance_Type;	submarine	2
SELECT * FROM Maintenance_Record WHERE Hull_Integrity_Check = 'Pass' AND Submarine_ID NOT IN (SELECT Submarine_ID FROM Mission WHERE Mission_Status = 'Completed');	submarine	3
SELECT Mission_Type, MAX((Maintenance_Cost * 100000) / Pressure_Endured) AS New_Max_Maintenance_Pressure_Ratio FROM Maintenance_Record JOIN Mission ON Maintenance_Record.Submarine_ID = Mission.Submarine_ID GROUP BY Mission_Type;	submarine	4
SELECT Submarine_Type, AVG(Maintenance_Cost * 1.0 / Displacement) AS Avg_Maintenance_Displacement_Ratio  FROM Maintenance_Record  JOIN Submarine ON Maintenance_Record.Submarine_ID = Submarine.Submarine_ID  WHERE Pressure_Test_Result = 'Pass'  GROUP BY Submarine_Type;	submarine	1
SELECT Maintenance_Type,         AVG((julianday(Maintenance_Date) - julianday(Commission_Date)) / 365.0) AS Median_Time_Difference  FROM Maintenance_Record  JOIN Submarine ON Maintenance_Record.Submarine_ID = Submarine.Submarine_ID  GROUP BY Maintenance_Type;	submarine	2
SELECT * FROM Maintenance_Record WHERE Hull_Integrity_Check = 'Pass' AND Submarine_ID NOT IN (SELECT Submarine_ID FROM Submarine WHERE Status = 'Active');	submarine	3
SELECT Submarine_Type, MAX((Maintenance_Cost * 1000000) / Displacement) AS New_Max_Maintenance_Displacement_Ratio  FROM Maintenance_Record  JOIN Submarine ON Maintenance_Record.Submarine_ID = Submarine.Submarine_ID  GROUP BY Submarine_Type;	submarine	4
SELECT Submarine_Type, AVG(Pressure_Endured * 1.0 / Max_Depth) AS Avg_Pressure_Depth_Ratio FROM Mission JOIN Submarine ON Mission.Submarine_ID = Submarine.Submarine_ID GROUP BY Submarine_Type;	submarine	1
WITH RankedRatios AS (     SELECT          m.Mission_Type,         (JULIANDAY(m.End_time) - JULIANDAY(m.Start_time)) / s.Length AS Time_Length_Ratio,         ROW_NUMBER() OVER (PARTITION BY m.Mission_Type ORDER BY (JULIANDAY(m.End_time) - JULIANDAY(m.Start_time)) / s.Length) AS row_asc,         ROW_NUMBER() OVER (PARTITION BY m.Mission_Type ORDER BY (JULIANDAY(m.End_time) - JULIANDAY(m.Start_time)) / s.Length DESC) AS row_desc     FROM Mission m     JOIN Submarine s ON m.Submarine_ID = s.Submarine_ID     WHERE m.End_time IS NOT NULL AND m.Start_time IS NOT NULL AND s.Length > 0 ) SELECT      Mission_Type,     AVG(Time_Length_Ratio) AS Median_Time_Length_Ratio FROM RankedRatios WHERE row_asc = row_desc OR row_asc + 1 = row_desc OR row_asc = row_desc + 1 GROUP BY Mission_Type;	submarine	2
SELECT * FROM Mission WHERE Sonar_Usage = 'Active' AND Submarine_ID NOT IN (SELECT Submarine_ID FROM Submarine WHERE Status = 'Active');	submarine	3
SELECT Submarine_Type, MAX((Pressure_Endured * 100000) / Max_Depth) AS New_Max_Pressure_Depth_Ratio FROM Mission JOIN Submarine ON Mission.Submarine_ID = Submarine.Submarine_ID GROUP BY Submarine_Type;	submarine	4
SELECT * FROM Maintenance_Record WHERE Pressure_Test_Result = 'Pass' AND Submarine_ID NOT IN (SELECT Submarine_ID FROM Submarine WHERE Submarine_Type = 'Attack');	submarine	1
SELECT Maintenance_Record.* FROM Maintenance_Record JOIN Submarine ON Maintenance_Record.Submarine_ID = Submarine.Submarine_ID WHERE (Maintenance_Cost / Displacement) > 1000 AND Maintenance_Type != 'Emergency';	submarine	2
SELECT * FROM Maintenance_Record WHERE Hull_Integrity_Check = 'Pass' AND Submarine_ID NOT IN (SELECT Submarine_ID FROM Submarine WHERE Status = 'Active');	submarine	3
SELECT Maintenance_Record.* FROM Maintenance_Record JOIN Submarine ON Maintenance_Record.Submarine_ID = Submarine.Submarine_ID WHERE ((Maintenance_Cost * 1000000) / Displacement) > 1000000 AND Maintenance_Record.Submarine_ID NOT IN (SELECT Submarine.Submarine_ID FROM Submarine WHERE Submarine_Type = 'Research');	submarine	4
SELECT 'Power Consumption (W)' AS Metric, (1000 * 1.1 * 0.1) AS Value FROM televisions WHERE Screen_Size_Inches = 65 AND Energy_Rating = 'A++';	television	1
SELECT Manufacturer_Id, AVG(CASE Energy_Rating WHEN 'A++' THEN 1 WHEN 'A+' THEN 2 WHEN 'A' THEN 3 WHEN 'B' THEN 4 WHEN 'C' THEN 5 WHEN 'D' THEN 6 END) AS Average_Energy_Rating FROM televisions GROUP BY Manufacturer_Id;	television	2
SELECT Resolution, AVG(User_Rating) AS Average_User_Rating FROM usage_records JOIN televisions ON usage_records.Television_Id = televisions.Television_Id GROUP BY Resolution ORDER BY Average_User_Rating DESC LIMIT 1;	television	3
SELECT Refresh_Rate_Hz AS Frames_Per_Second, (Refresh_Rate_Hz * 1) AS Data_Per_Second_GB FROM televisions WHERE Refresh_Rate_Hz = 10000;	television	4
SELECT Manufacturer_Name, (Revenue_Usd / (2024 - Founded_Year)) AS Average_Annual_Revenue FROM manufacturers WHERE Manufacturer_Name = 'Samsung';	television	1
SELECT Manufacturer_Name, (Profit_Usd / Employees) AS Profit_Per_Employee FROM manufacturers ORDER BY Profit_Per_Employee DESC LIMIT 3;	television	2
SELECT Manufacturer_Name, Market_Share_Percent FROM manufacturers ORDER BY Founded_Year ASC, Market_Share_Percent DESC LIMIT 5;	television	3
SELECT Manufacturer_Name, (Profit_Usd / Employees) AS Profit_Per_Employee, ((Profit_Usd / Employees) / 50000) AS Times_Industry_Average FROM manufacturers WHERE Employees = 1 AND Profit_Usd = 1000000000000;	television	4
SELECT Energy_Rating, AVG(Screen_Size_Inches * 0.5 * POWER(1.15, CASE Energy_Rating WHEN 'A++' THEN 0 WHEN 'A+' THEN 1 WHEN 'A' THEN 2 WHEN 'B' THEN 3 WHEN 'C' THEN 4 WHEN 'D' THEN 5 END) * 8 * 365 * 0.8 / 1000) AS Annual_Energy_Consumption_kWh FROM televisions GROUP BY Energy_Rating;	television	1
WITH Panel_Avg_Price AS (     SELECT Panel_Type, AVG(Price_Usd) AS Avg_Price      FROM televisions      GROUP BY Panel_Type )  SELECT a.Panel_Type AS Type1, b.Panel_Type AS Type2,         ROUND(((b.Avg_Price - a.Avg_Price) / a.Avg_Price * 100), 2) AS Price_Difference_Percent  FROM Panel_Avg_Price a  JOIN Panel_Avg_Price b ON a.Panel_Type < b.Panel_Type  ORDER BY b.Avg_Price DESC  LIMIT 3;	television	2
WITH Price_Percentile AS (     SELECT Price_Usd,             (CAST(ROW_NUMBER() OVER (ORDER BY Price_Usd DESC) AS REAL) - 1) / (SELECT COUNT(*) FROM televisions) AS Price_Rank      FROM televisions ),  Top_10_Largest AS (     SELECT Television_Id, Screen_Size_Inches, Price_Usd      FROM televisions      ORDER BY Screen_Size_Inches DESC      LIMIT 10 )  SELECT t.Television_Id, t.Screen_Size_Inches, t.Price_Usd,         CASE WHEN p.Price_Rank <= 0.2 THEN 'Yes' ELSE 'No' END AS Is_Top_20_Percent  FROM Top_10_Largest t  JOIN Price_Percentile p ON t.Price_Usd = p.Price_Usd;	television	3
SELECT CEIL((0.1 * 1000000) / 100000000) AS Required_Ships;	television	4
SELECT User_Id, (Average_Brightness_Percent * 10 * 0.85 * Usage_Duration_Minutes) / (60 * 1000) AS Energy_Consumption_kWh_per_min FROM usage_records;	television	1
WITH Movie_Usage AS (     SELECT User_Id, Usage_Duration_Minutes, User_Rating      FROM usage_records      WHERE Content_Type = '电影' ),  User_Stats AS (     SELECT          User_Id,          COUNT(*) AS n,          SUM(Usage_Duration_Minutes) AS sum_x,          SUM(User_Rating) AS sum_y,          SUM(Usage_Duration_Minutes * User_Rating) AS sum_xy,          SUM(Usage_Duration_Minutes * Usage_Duration_Minutes) AS sum_x2,          SUM(User_Rating * User_Rating) AS sum_y2      FROM Movie_Usage      GROUP BY User_Id )  SELECT      User_Id,      (n * sum_xy - sum_x * sum_y) / (SQRT(n * sum_x2 - sum_x * sum_x) * SQRT(n * sum_y2 - sum_y * sum_y)) AS Pearson_Correlation  FROM User_Stats  ORDER BY Pearson_Correlation DESC  LIMIT 5;	television	2
WITH User_Daily_Usage AS (   SELECT      User_Id,      SUM(Usage_Duration_Minutes) AS Total_Usage_Minutes,      (JULIANDAY(MAX(End_Time)) - JULIANDAY(MIN(Start_Time))) + 1 AS Total_Days    FROM usage_records    GROUP BY User_Id    HAVING SUM(Usage_Duration_Minutes) / ((JULIANDAY(MAX(End_Time)) - JULIANDAY(MIN(Start_Time))) + 1) > 480 )  SELECT    u.User_Id,    u.Total_Usage_Minutes / u.Total_Days AS Avg_Daily_Usage_Minutes,    SUM(e.Energy_Consumed_Kwh) AS Total_Energy_Consumed  FROM User_Daily_Usage u  JOIN usage_records e ON u.User_Id = e.User_Id  GROUP BY u.User_Id  ORDER BY Total_Energy_Consumed DESC  LIMIT 10;	television	3
SELECT Energy_Consumed_Kwh / (0.2 * 24 * 365) AS Years_Of_Operation FROM usage_records WHERE Energy_Consumed_Kwh = 1000000.0;	television	4
WITH Movie_Usage AS (         SELECT User_Id, Usage_Duration_Minutes, User_Rating          FROM usage_records          WHERE Content_Type = '电影'     ),      User_Stats AS (         SELECT              User_Id,              COUNT(*) AS n,              SUM(Usage_Duration_Minutes) AS sum_x,              SUM(User_Rating) AS sum_y,              SUM(Usage_Duration_Minutes * User_Rating) AS sum_xy,              SUM(Usage_Duration_Minutes * Usage_Duration_Minutes) AS sum_x2,              SUM(User_Rating * User_Rating) AS sum_y2          FROM Movie_Usage          GROUP BY User_Id     )     SELECT          User_Id,          (n * sum_xy - sum_x * sum_y) / (SQRT(n * sum_x2 - sum_x * sum_x) * SQRT(n * sum_y2 - sum_y * sum_y)) AS Pearson_Correlation      FROM User_Stats      ORDER BY Pearson_Correlation DESC      LIMIT 5;	television	1
SELECT Resolution, ROUND((STDDEV(Refresh_Rate_Hz) / AVG(Refresh_Rate_Hz)) / (STDDEV(Response_Time_Ms) / AVG(Response_Time_Ms)) * 100, 3) AS CV_Ratio FROM display_data GROUP BY Resolution;	television	2
SELECT Hdr_Support, COUNT(CASE WHEN Brightness_Nits > 800 THEN 1 END) * 1.0 / COUNT(*) AS Brightness_Ratio FROM display_data GROUP BY Hdr_Support;	television	3
SELECT Panel_Type, (7680 * 4320 * 24 * Refresh_Rate_Hz) / (8.0 * 1024 * 1024 * 1024) AS Data_Volume_GB_per_Second FROM display_data WHERE Refresh_Rate_Hz = 1e12 GROUP BY Panel_Type;	television	4
SELECT Country, AVG(Profit_Usd / (Employees * 2000)) AS Power_Efficiency FROM manufacturers GROUP BY Country;	television	1
WITH Per_Capita_Profit AS (     SELECT          Country,          Manufacturer_Id,          Profit_Usd / Employees AS Profit_Per_Capita      FROM manufacturers ),  Country_Stats AS (     SELECT          Country,          AVG(Profit_Per_Capita) AS Avg_Profit,          (SELECT STDEV(Profit_Per_Capita) FROM Per_Capita_Profit p2 WHERE p2.Country = p1.Country) AS Std_Profit      FROM Per_Capita_Profit p1      GROUP BY Country ),  Gini_Calculation AS (     SELECT          Country,          1 - 2 * SUM((Profit_Per_Capita / Total_Profit) * (Cumulative_Profit_Percent - 0.5 * (Profit_Per_Capita / Total_Profit))) AS Gini_Coefficient      FROM (         SELECT              Country,              Profit_Per_Capita,              (SELECT SUM(p2.Profit_Per_Capita) FROM Per_Capita_Profit p2 WHERE p2.Country = p1.Country AND p2.Profit_Per_Capita <= p1.Profit_Per_Capita) AS Cumulative_Profit,             (SELECT SUM(p2.Profit_Per_Capita) FROM Per_Capita_Profit p2 WHERE p2.Country = p1.Country) AS Total_Profit,             (SELECT SUM(p2.Profit_Per_Capita) FROM Per_Capita_Profit p2 WHERE p2.Country = p1.Country AND p2.Profit_Per_Capita <= p1.Profit_Per_Capita) * 1.0 / (SELECT SUM(p2.Profit_Per_Capita) FROM Per_Capita_Profit p2 WHERE p2.Country = p1.Country) AS Cumulative_Profit_Percent         FROM Per_Capita_Profit p1     ) AS Subquery      GROUP BY Country )  SELECT      c.Country,      c.Avg_Profit,      c.Std_Profit / c.Avg_Profit AS Coefficient_of_Variation,      g.Gini_Coefficient  FROM Country_Stats c  JOIN Gini_Calculation g ON c.Country = g.Country;	television	2
WITH Manufacturer_Age AS (     SELECT          Manufacturer_Id,          Market_Share_Percent,          2024 - Founded_Year AS Years_Since_Founded      FROM manufacturers )  SELECT      AVG(CASE WHEN Years_Since_Founded >= 50 THEN Market_Share_Percent END) AS Avg_Market_Share_Over_50,      AVG(CASE WHEN Years_Since_Founded < 10 THEN Market_Share_Percent END) AS Avg_Market_Share_Under_10,      AVG(CASE WHEN Years_Since_Founded >= 50 THEN Market_Share_Percent END) - AVG(CASE WHEN Years_Since_Founded < 10 THEN Market_Share_Percent END) AS Market_Share_Difference  FROM Manufacturer_Age;	television	3
WITH Hypothetical_Profit AS (     SELECT Country, SUM(Profit_Usd) AS Total_Profit      FROM manufacturers      GROUP BY Country ),  Global_Profit AS (     SELECT Country, 1e14 AS Hypothetical_Profit      FROM manufacturers      WHERE Manufacturer_Id = 1 )  SELECT h.Country,         (g.Hypothetical_Profit / (h.Total_Profit + g.Hypothetical_Profit)) * 100 AS Profit_Percentage  FROM Hypothetical_Profit h  JOIN Global_Profit g ON h.Country = g.Country;	television	4
SELECT Energy_Rating, AVG((3.141592653589793 * POWER((Screen_Size_Inches * 0.0254 / 2), 2) * 100) / Weight_Kg) AS Efficiency_W_per_Kg_per_m2 FROM televisions GROUP BY Energy_Rating;	television	1
WITH Panel_Stats AS (     SELECT          Panel_Type,          COUNT(*) AS n,          SUM(Screen_Size_Inches) AS sum_x,          SUM(Price_Usd) AS sum_y,          SUM(Screen_Size_Inches * Price_Usd) AS sum_xy,          SUM(Screen_Size_Inches * Screen_Size_Inches) AS sum_x2,          SUM(Price_Usd * Price_Usd) AS sum_y2      FROM televisions      GROUP BY Panel_Type ) SELECT      Panel_Type,      (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x) AS slope,      (sum_y - ((n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)) * sum_x) / n AS intercept,      ((n * sum_xy - sum_x * sum_y) * (n * sum_xy - sum_x * sum_y)) / ((n * sum_x2 - (sum_x * sum_x)) * (n * sum_y2 - (sum_y * sum_y))) AS r_squared  FROM Panel_Stats;	television	2
WITH Large_TVs AS (     SELECT          Resolution,          COUNT(*) AS Total_Large_TVs,          COUNT(CASE WHEN Hdmi_Ports >= 4 THEN 1 END) AS Large_TVs_With_HDMI      FROM televisions      WHERE Screen_Size_Inches >= 75      GROUP BY Resolution ),  All_TVs AS (     SELECT          Resolution,          COUNT(*) AS Total_TVs,          COUNT(CASE WHEN Hdmi_Ports >= 4 THEN 1 END) AS All_TVs_With_HDMI      FROM televisions      GROUP BY Resolution )  SELECT      l.Resolution,      CAST(l.Large_TVs_With_HDMI AS REAL) / l.Total_Large_TVs AS Large_TV_Compliance_Rate,      CAST(a.All_TVs_With_HDMI AS REAL) / a.Total_TVs AS Overall_Compliance_Rate  FROM Large_TVs l  JOIN All_TVs a ON l.Resolution = a.Resolution;	television	3
SELECT Panel_Type, CEIL(POWER(1000 * 0.0254, 3) * 0.8 / 33) AS Containers_Required FROM televisions WHERE Resolution = '8K' GROUP BY Panel_Type;	television	4
SELECT App_Used, AVG(Energy_Consumed_Kwh / (Average_Brightness_Percent * Usage_Duration_Minutes)) AS Energy_Efficiency_Ratio FROM usage_records GROUP BY App_Used;	television	1
WITH Stats AS (     SELECT          Content_Type,          AVG(User_Rating) AS mean,          AVG(User_Rating * User_Rating) - AVG(User_Rating) * AVG(User_Rating) AS variance,         COUNT(*) AS n      FROM usage_records      GROUP BY Content_Type ), Skewness_Calc AS (     SELECT          ur.Content_Type,          (s.n * 1.0 / ((s.n - 1) * (s.n - 2))) * SUM(POWER((ur.User_Rating - s.mean) / SQRT(s.variance), 3)) AS skewness      FROM usage_records ur      JOIN Stats s ON ur.Content_Type = s.Content_Type      GROUP BY ur.Content_Type ), Kurtosis_Calc AS (     SELECT          ur.Content_Type,          ((s.n * (s.n + 1)) * 1.0 / ((s.n - 1) * (s.n - 2) * (s.n - 3))) * SUM(POWER((ur.User_Rating - s.mean) / SQRT(s.variance), 4)) - (3.0 * POWER(s.n - 1, 2) / ((s.n - 2) * (s.n - 3))) AS kurtosis      FROM usage_records ur      JOIN Stats s ON ur.Content_Type = s.Content_Type      GROUP BY ur.Content_Type ) SELECT      s.Content_Type,      ROUND(s.skewness, 6) AS skewness,      ROUND(k.kurtosis, 6) AS kurtosis  FROM Skewness_Calc s  JOIN Kurtosis_Calc k ON s.Content_Type = k.Content_Type;	television	2
WITH Sports_Stats AS (     SELECT          strftime('%m', Start_Time) AS month,          AVG(Usage_Duration_Minutes) AS mean_sports,          (SUM(Usage_Duration_Minutes * Usage_Duration_Minutes) - SUM(Usage_Duration_Minutes) * SUM(Usage_Duration_Minutes) / COUNT(*)) / COUNT(*) AS var_sports,          COUNT(*) AS n_sports      FROM usage_records      WHERE Content_Type = '体育'      GROUP BY strftime('%m', Start_Time) ),  Movies_Stats AS (     SELECT          strftime('%m', Start_Time) AS month,          AVG(Usage_Duration_Minutes) AS mean_movies,          (SUM(Usage_Duration_Minutes * Usage_Duration_Minutes) - SUM(Usage_Duration_Minutes) * SUM(Usage_Duration_Minutes) / COUNT(*)) / COUNT(*) AS var_movies,          COUNT(*) AS n_movies      FROM usage_records      WHERE Content_Type = '电影'      GROUP BY strftime('%m', Start_Time) )  SELECT      s.month,      (s.mean_sports - m.mean_movies) / SQRT((s.var_sports / s.n_sports) + (m.var_movies / m.n_movies)) AS t_value  FROM Sports_Stats s  JOIN Movies_Stats m ON s.month = m.month;	television	3
WITH User_Energy AS (     SELECT App_Used, SUM(Energy_Consumed_Kwh) AS user_energy      FROM usage_records      WHERE User_Id = 1 AND Usage_Duration_Minutes = 5256000      GROUP BY App_Used ),  Total_Energy AS (     SELECT SUM(Energy_Consumed_Kwh) AS total_energy      FROM usage_records )  SELECT u.App_Used, (u.user_energy / t.total_energy) * 100 AS energy_percentage  FROM User_Energy u, Total_Energy t;	television	4
SELECT * FROM display_data WHERE Contrast_Ratio >= '1000:1' AND Brightness_Nits < 1000;	television	1
WITH cte AS (   SELECT Resolution,           (AVG(Refresh_Rate_Hz * Response_Time_Ms) - (AVG(Refresh_Rate_Hz) * AVG(Response_Time_Ms))) AS cov    FROM display_data    GROUP BY Resolution )  SELECT Resolution  FROM cte  WHERE cov < 0;	television	2
SELECT * FROM display_data WHERE Hdr_Support = 1 AND Brightness_Nits < 800;	television	3
SELECT * FROM display_data WHERE Refresh_Rate_Hz = 1e12 AND Local_Dimming = 0;	television	4
WITH Industry_Stats AS (     SELECT          AVG(Profit_Usd) AS avg_profit,          AVG(Profit_Usd / (Employees * 2000)) AS avg_efficiency      FROM manufacturers ),  High_Profit_Low_Efficiency AS (     SELECT *      FROM manufacturers      WHERE Profit_Usd > (SELECT avg_profit FROM Industry_Stats)      AND Profit_Usd / (Employees * 2000) < (SELECT avg_efficiency FROM Industry_Stats) )  SELECT * FROM High_Profit_Low_Efficiency;	television	1
WITH cte AS (   SELECT      Country,      (AVG(Employees * Market_Share_Percent) - (AVG(Employees) * AVG(Market_Share_Percent))) AS cov    FROM manufacturers    GROUP BY Country )  SELECT Country  FROM cte  WHERE cov < 0;	television	2
SELECT * FROM manufacturers WHERE 2024 - Founded_Year > 30 AND Market_Share_Percent < 5;	television	3
SELECT Manufacturer_Id, Manufacturer_Name, Profit_Usd, (Profit_Usd / (SELECT SUM(Profit_Usd) FROM manufacturers)) * 100 AS Profit_Percentage FROM manufacturers WHERE Profit_Usd = 1e20 AND Website IS NULL;	television	4
SELECT * FROM televisions WHERE Energy_Rating = 'A++' AND (Price_Usd / (PI() * POWER((Screen_Size_Inches * 0.0254 / 2), 2))) > 100;	television	1
WITH cte AS (     SELECT Panel_Type,             (COUNT(*) * SUM(Screen_Size_Inches * Price_Usd) - SUM(Screen_Size_Inches) * SUM(Price_Usd)) /             (SQRT((COUNT(*) * SUM(Screen_Size_Inches * Screen_Size_Inches) - SUM(Screen_Size_Inches) * SUM(Screen_Size_Inches)) *                   (COUNT(*) * SUM(Price_Usd * Price_Usd) - SUM(Price_Usd) * SUM(Price_Usd))))            AS r      FROM televisions      GROUP BY Panel_Type ) SELECT Panel_Type  FROM cte  WHERE r < 0.5;	television	2
SELECT * FROM televisions WHERE Resolution = '4K' AND Hdmi_Ports < 3;	television	3
SELECT * FROM televisions WHERE Screen_Size_Inches = 10000 AND Weight_Kg = 0.01 AND Usb_Ports = 0;	television	4
SELECT * FROM usage_records WHERE User_Rating >= 4 AND (Energy_Consumed_Kwh / (Usage_Duration_Minutes / 60)) > 0.3;	television	1
WITH ranked_data AS (     SELECT          App_Used,          Usage_Duration_Minutes,          User_Rating,         (SELECT COUNT(*) + 1 FROM usage_records ur2 WHERE ur2.App_Used = ur1.App_Used AND ur2.Usage_Duration_Minutes < ur1.Usage_Duration_Minutes) AS duration_rank,         (SELECT COUNT(*) + 1 FROM usage_records ur3 WHERE ur3.App_Used = ur1.App_Used AND ur3.User_Rating < ur1.User_Rating) AS rating_rank     FROM usage_records ur1 ),  correlation_data AS (     SELECT          App_Used,          1.0 - (6.0 * SUM((duration_rank - rating_rank) * (duration_rank - rating_rank)) / (COUNT(*) * (COUNT(*) * COUNT(*) - 1))) AS rho     FROM ranked_data      GROUP BY App_Used )  SELECT App_Used FROM correlation_data WHERE rho < 0;	television	2
WITH user_daily_usage AS (     SELECT          User_Id,          SUM(Usage_Duration_Minutes) / ((JULIANDAY(MAX(End_Time)) - JULIANDAY(MIN(Start_Time))) + 1) AS daily_usage_minutes      FROM usage_records      GROUP BY User_Id )  SELECT *  FROM usage_records  WHERE User_Rating >= 4.5  AND User_Id IN (     SELECT User_Id      FROM user_daily_usage      WHERE daily_usage_minutes > 720 );	television	3
SELECT * FROM usage_records WHERE Usage_Duration_Minutes = 5256000 AND Energy_Consumed_Kwh = 0 AND App_Used IS NOT NULL;	television	4
WITH efficiency_ratio AS (   SELECT      Panel_Type,      Brightness_Nits / (CASE        WHEN Panel_Type = 'LED' THEN 0.8        WHEN Panel_Type = 'OLED' THEN 0.5        WHEN Panel_Type = 'QLED' THEN 0.7        ELSE 1      END * Response_Time_Ms) AS efficiency    FROM display_data )  SELECT Panel_Type, efficiency  FROM efficiency_ratio  ORDER BY efficiency DESC  LIMIT 3;	television	1
WITH stats AS (     SELECT          Resolution,          AVG(Refresh_Rate_Hz) AS avg_x,          AVG(Response_Time_Ms) AS avg_y,          COUNT(*) AS n      FROM display_data      GROUP BY Resolution ) SELECT      display_data.Resolution,      (SUM((Refresh_Rate_Hz - avg_x) * (Response_Time_Ms - avg_y)) / (n - 1)) /      (SQRT(SUM(POWER(Refresh_Rate_Hz - avg_x, 2)) / (n - 1)) * SQRT(SUM(POWER(Response_Time_Ms - avg_y, 2)) / (n - 1))) AS r  FROM display_data  JOIN stats ON display_data.Resolution = stats.Resolution  GROUP BY display_data.Resolution  ORDER BY ABS(r) DESC  LIMIT 5;	television	2
SELECT * FROM display_data WHERE Viewing_Angle_Degrees >= 178 AND Panel_Type NOT IN ('IPS', 'VA') ORDER BY Panel_Type DESC;	television	3
SELECT Television_Id, 1.0 / Refresh_Rate_Hz AS frame_time_ps FROM display_data WHERE Refresh_Rate_Hz = 1e12 AND Hdr_Support = 0 ORDER BY frame_time_ps ASC LIMIT 10;	television	4
SELECT Country, SUM(Profit_Usd) / (SUM(Employees) * SUM(Employees) * SUM(Employees)) AS energy_density FROM manufacturers GROUP BY Country ORDER BY energy_density DESC LIMIT 5;	television	1
WITH stats AS (   SELECT      Country,      AVG(Market_Share_Percent) AS μ,      AVG(Market_Share_Percent * Market_Share_Percent) - AVG(Market_Share_Percent) * AVG(Market_Share_Percent) AS σ2,     COUNT(*) AS n    FROM manufacturers    GROUP BY Country ) SELECT    m.Country,    (SUM((m.Market_Share_Percent - s.μ) * (m.Market_Share_Percent - s.μ) * (m.Market_Share_Percent - s.μ)) / s.n) / POWER(s.σ2, 1.5) AS skewness  FROM manufacturers m  JOIN stats s ON m.Country = s.Country  GROUP BY m.Country  HAVING skewness < -1  ORDER BY skewness ASC;	television	2
SELECT * FROM manufacturers WHERE Employees > 1000 AND (2024 - Founded_Year) < 5 ORDER BY Revenue_Usd DESC;	television	3
SELECT Manufacturer_Name, Profit_Usd / ABS(Employees) AS density FROM manufacturers WHERE Employees < 0 ORDER BY Profit_Usd DESC LIMIT 3;	television	4
SELECT Energy_Rating, MIN(Price_Usd / (Screen_Size_Inches * Screen_Size_Inches)) AS Power_Density FROM televisions GROUP BY Energy_Rating ORDER BY Power_Density ASC LIMIT 5;	television	1
WITH stats AS (     SELECT          Panel_Type,          AVG(Price_Usd) AS μ,          (SUM(Price_Usd*Price_Usd) - SUM(Price_Usd)*SUM(Price_Usd)/COUNT(*)) / COUNT(*) AS σ2,         COUNT(*) AS n      FROM televisions      GROUP BY Panel_Type ) SELECT      t.Panel_Type,      ((s.n*(s.n+1)*SUM(POWER(t.Price_Usd-s.μ,4))) / ((s.n-1)*(s.n-2)*(s.n-3)*POWER(s.σ2,2))) - (3*POWER(s.n-1,2)/((s.n-2)*(s.n-3))) AS Kurtosis  FROM televisions t  JOIN stats s ON t.Panel_Type = s.Panel_Type  GROUP BY t.Panel_Type  HAVING Kurtosis > 3  ORDER BY Kurtosis DESC  LIMIT 3;	television	2
SELECT * FROM televisions WHERE Refresh_Rate_Hz >= 120 AND Price_Usd < 500 ORDER BY Release_Date DESC;	television	3
SELECT Television_Id, 7680 * 4320 * 32 * 1e15 * 86400 / (8 * 1e12) AS Daily_Data_TB FROM televisions WHERE Resolution = '8K' AND Energy_Rating = 'D' ORDER BY Daily_Data_TB DESC LIMIT 10;	television	4
SELECT App_Used, SUM(Energy_Consumed_Kwh) / (SUM(Average_Brightness_Percent * Usage_Duration_Minutes)) AS Energy_Brightness_Ratio FROM usage_records GROUP BY App_Used ORDER BY Energy_Brightness_Ratio DESC LIMIT 5;	television	1
WITH ranked AS (     SELECT          User_Id,          Content_Type,          Usage_Duration_Minutes,          SUM(Usage_Duration_Minutes) OVER(PARTITION BY User_Id) AS total,          ROW_NUMBER() OVER(PARTITION BY User_Id ORDER BY Usage_Duration_Minutes) AS rn      FROM usage_records ),  cumulative AS (     SELECT          User_Id,          SUM(Usage_Duration_Minutes) OVER(PARTITION BY User_Id ORDER BY rn) * 1.0 / total AS cumulative_ratio      FROM ranked ),  lagged AS (     SELECT          User_Id,          cumulative_ratio,          LAG(cumulative_ratio, 1, 0) OVER(PARTITION BY User_Id ORDER BY cumulative_ratio) AS lag_ratio      FROM cumulative )  SELECT      User_Id,      1 - 2 * SUM(cumulative_ratio - lag_ratio) AS Gini  FROM lagged  GROUP BY User_Id  ORDER BY Gini DESC  LIMIT 3;	television	2
SELECT * FROM usage_records WHERE Usage_Duration_Minutes > 480 AND User_Rating >= 4.5 ORDER BY Energy_Consumed_Kwh ASC;	television	3
SELECT Television_Id, Energy_Consumed_Kwh / (Usage_Duration_Minutes / 60.0) AS Energy_Efficiency FROM usage_records WHERE Usage_Duration_Minutes = 31536000 AND App_Used = '未知' ORDER BY Energy_Efficiency ASC LIMIT 10;	television	4
SELECT Panel_Type, AVG(Brightness_Nits / Response_Time_Ms) AS Efficiency_Ratio  FROM display_data  GROUP BY Panel_Type  ORDER BY Efficiency_Ratio DESC  LIMIT 3;	television	1
WITH stats AS (     SELECT          Resolution,          AVG(Refresh_Rate_Hz) AS avg_rr,          AVG(CAST(SUBSTR(Contrast_Ratio, 1, INSTR(Contrast_Ratio, ':') - 1) AS INTEGER)) AS avg_cr      FROM display_data      GROUP BY Resolution )  SELECT      d.Resolution,      SUM((d.Refresh_Rate_Hz - s.avg_rr) * (CAST(SUBSTR(d.Contrast_Ratio, 1, INSTR(d.Contrast_Ratio, ':') - 1) AS INTEGER) - s.avg_cr)) * 1.0 / COUNT(*) AS cov  FROM display_data d  JOIN stats s ON d.Resolution = s.Resolution  GROUP BY d.Resolution  ORDER BY ABS(cov) DESC  LIMIT 5;	television	2
SELECT Panel_Type, COUNT(*) AS abnormal_count FROM display_data WHERE Hdr_Support = 1 AND Color_Gamut_Percent < 90 GROUP BY Panel_Type;	television	3
SELECT Television_Id, 7680 * 4320 * 1000000 * 1000000000000000000 AS Photons_Per_Second FROM display_data WHERE Resolution = '8K' AND Viewing_Angle_Degrees <= 90 ORDER BY Refresh_Rate_Hz DESC LIMIT 10;	television	4
SELECT Country FROM manufacturers GROUP BY Country HAVING AVG(Revenue_Usd / (Employees * Employees)) > (SELECT AVG(Revenue_Usd / (Employees * Employees)) FROM manufacturers) AND Country NOT IN (SELECT Country FROM manufacturers GROUP BY Country HAVING AVG(Profit_Usd) >= (SELECT AVG(Profit_Usd) FROM manufacturers));	television	1
SELECT Country, SUM(Market_Share_Percent * Market_Share_Percent) AS HHI FROM manufacturers GROUP BY Country HAVING HHI < 1500 ORDER BY HHI DESC;	television	2
SELECT * FROM manufacturers WHERE Employees > 1000 AND (Profit_Usd * 100.0 / Revenue_Usd) < 2 ORDER BY Founded_Year ASC;	television	3
SELECT Manufacturer_Name, CASE WHEN Employees = 0 THEN '无限大' ELSE CAST(Profit_Usd AS REAL) / Employees END AS per_capita FROM manufacturers WHERE Employees = 0 AND Profit_Usd = 1e18 AND Website IS NULL ORDER BY Profit_Usd DESC LIMIT 5;	television	4
SELECT Energy_Rating, AVG(Weight_Kg / (Screen_Size_Inches * Screen_Size_Inches)) AS Density_Coefficient FROM televisions GROUP BY Energy_Rating ORDER BY Density_Coefficient ASC LIMIT 3;	television	1
WITH stats AS (         SELECT Panel_Type,                 STDDEV_SAMP(Price_Usd) AS σ,                 AVG(Price_Usd) AS μ          FROM televisions          GROUP BY Panel_Type     )     SELECT Panel_Type,             σ / μ AS CV      FROM stats      WHERE σ / μ > 0.5      ORDER BY CV DESC;	television	2
SELECT * FROM televisions WHERE Resolution = '4K' AND Hdmi_Ports < 3 ORDER BY Price_Usd ASC;	television	3
SELECT Model, POWER(Screen_Size_Inches * 0.0254, 3) * 0.7 AS volume_m3 FROM televisions WHERE Resolution = '8K' AND Usb_Ports = 0 ORDER BY volume_m3 DESC LIMIT 10;	television	4
SELECT User_Id, SUM(Energy_Consumed_Kwh) / (SUM(Average_Brightness_Percent * Usage_Duration_Minutes)) AS energy_brightness_ratio FROM usage_records GROUP BY User_Id ORDER BY energy_brightness_ratio DESC LIMIT 5;	television	1
WITH stats AS (     SELECT          App_Used,          AVG(Usage_Duration_Minutes) AS μ_x,          AVG(User_Rating) AS μ_y,          COUNT(*) AS n      FROM usage_records      GROUP BY App_Used )  SELECT      usage_records.App_Used,      (SUM(Usage_Duration_Minutes * User_Rating) - stats.n * stats.μ_x * stats.μ_y) / (stats.n - 1) AS cov  FROM usage_records  JOIN stats ON usage_records.App_Used = stats.App_Used  GROUP BY usage_records.App_Used  HAVING cov < 0;	television	2
SELECT User_Id, SUM(Usage_Duration_Minutes) / 60.0 AS total_hours, SUM(Energy_Consumed_Kwh) AS total_energy FROM usage_records GROUP BY User_Id HAVING (SUM(Usage_Duration_Minutes) / COUNT(DISTINCT date(Start_Time))) / 60.0 > 12 AND SUM(Energy_Consumed_Kwh) < 1;	television	3
SELECT Television_Id, Energy_Consumed_Kwh/(Usage_Duration_Minutes/60.0) AS 能效 FROM usage_records WHERE Usage_Duration_Minutes=5256000 AND Energy_Consumed_Kwh=0 AND App_Used='系统测试' ORDER BY 能效 ASC LIMIT 10;	television	4
SELECT Country, SUM(Revenue_Usd) / POWER(2024 - MIN(Founded_Year), 3) AS Power_Density FROM manufacturers GROUP BY Country ORDER BY Power_Density DESC LIMIT 5;	television	1
WITH stats AS (   SELECT Country,           STDEV(Profit_Usd*1.0/Revenue_Usd) AS σ,           AVG(Profit_Usd*1.0/Revenue_Usd) AS μ    FROM manufacturers    GROUP BY Country )  SELECT Country, σ/μ AS CV  FROM stats  WHERE σ/μ > 1  ORDER BY CV DESC;	television	2
SELECT * FROM manufacturers WHERE (2024 - Founded_Year) > 50 AND Market_Share_Percent < 1 ORDER BY Revenue_Usd DESC;	television	3
WITH total AS (         SELECT Country, SUM(Market_Share_Percent) AS total          FROM manufacturers          GROUP BY Country     )      SELECT Manufacturer_Name, Market_Share_Percent * 1.0 / total AS relative_share      FROM manufacturers      JOIN total ON manufacturers.Country = total.Country      WHERE Market_Share_Percent = 10000      AND Contact_Email IS NULL      LIMIT 3;	television	4
WITH unit_price AS (     SELECT          Energy_Rating,          AVG(Price_Usd / (Screen_Size_Inches * Screen_Size_Inches)) AS avg_unit_price      FROM televisions      GROUP BY Energy_Rating )  SELECT      Energy_Rating,      avg_unit_price  FROM unit_price  ORDER BY avg_unit_price ASC  LIMIT 3;	television	1
WITH ranked AS (     SELECT          Resolution,          (SELECT COUNT(*) + 1 FROM televisions t2 WHERE t2.Resolution = t1.Resolution AND t2.Price_Usd < t1.Price_Usd) AS price_rank,         (SELECT COUNT(*) + 1 FROM televisions t2 WHERE t2.Resolution = t1.Resolution AND t2.Weight_Kg < t1.Weight_Kg) AS weight_rank     FROM televisions t1 ) SELECT      Resolution,      1.0 - (6.0 * SUM((price_rank - weight_rank) * (price_rank - weight_rank))) / (COUNT(*) * (COUNT(*) * COUNT(*) - 1)) AS rho FROM ranked  GROUP BY Resolution  HAVING ABS(rho) < 0.3  ORDER BY rho ASC;	television	2
SELECT t.* FROM televisions t JOIN display_data d ON t.Television_Id = d.Television_Id WHERE t.Hdr_Support = 1 AND d.Brightness_Nits < 800 ORDER BY t.Release_Date DESC;	television	3
SELECT Model, POWER(Screen_Size_Inches * 0.0254, 3) * 0.5 AS volume_m3 FROM televisions WHERE Usb_Ports >= 4 ORDER BY volume_m3 DESC LIMIT 10;	television	4
SELECT t.Energy_Rating, AVG(d.Brightness_Nits / CASE t.Energy_Rating WHEN 'A++' THEN 0.8 WHEN 'A+' THEN 0.9 ELSE 1.0 END) AS efficiency  FROM display_data d  JOIN televisions t ON d.Television_Id = t.Television_Id  GROUP BY t.Energy_Rating  ORDER BY efficiency DESC  LIMIT 5;	television	1
WITH stats AS (     SELECT          d.Panel_Type,          AVG(d.Refresh_Rate_Hz) AS μ_rr,          AVG(t.Price_Usd) AS μ_price      FROM display_data d      JOIN televisions t ON d.Television_Id = t.Television_Id      GROUP BY d.Panel_Type )  SELECT      d.Panel_Type,      SUM((d.Refresh_Rate_Hz - s.μ_rr) * (t.Price_Usd - s.μ_price)) / COUNT(*) AS cov  FROM display_data d  JOIN televisions t ON d.Television_Id = t.Television_Id  JOIN stats s ON d.Panel_Type = s.Panel_Type  GROUP BY d.Panel_Type  ORDER BY ABS(cov) DESC  LIMIT 3;	television	2
SELECT COUNT(*) FROM display_data d JOIN televisions t ON d.Television_Id = t.Television_Id WHERE t.Hdr_Support = 1 AND (d.Brightness_Nits < 1000 OR CAST(substr(d.Contrast_Ratio, 1, instr(d.Contrast_Ratio, ':') - 1) AS INTEGER) < 1000);	television	3
SELECT t.Model, 1000/ABS(d.Response_Time_Ms) AS theoretical_fps FROM display_data d JOIN televisions t ON d.Television_Id = t.Television_Id WHERE d.Response_Time_Ms < 0 AND t.Weight_Kg < 1 ORDER BY theoretical_fps DESC LIMIT 10;	television	4
SELECT m.Country, SUM(m.Profit_Usd) / AVG(CASE t.Energy_Rating WHEN 'A++' THEN 1.0 WHEN 'A+' THEN 0.9 ELSE 0.8 END) AS efficiency FROM manufacturers m JOIN televisions t ON m.Manufacturer_Id = t.Manufacturer_Id GROUP BY m.Country ORDER BY efficiency DESC LIMIT 3;	television	1
WITH stats AS (     SELECT          m.Manufacturer_Name,          AVG(m.Market_Share_Percent) AS μ_share,          AVG(t.Price_Usd) AS μ_price      FROM manufacturers m      JOIN televisions t ON m.Manufacturer_Id = t.Manufacturer_Id      GROUP BY m.Manufacturer_Name )  SELECT      m.Manufacturer_Name,      SUM((m.Market_Share_Percent - μ_share) * (t.Price_Usd - μ_price)) / COUNT(*) AS cov  FROM manufacturers m  JOIN televisions t ON m.Manufacturer_Id = t.Manufacturer_Id  JOIN stats s ON m.Manufacturer_Name = s.Manufacturer_Name  GROUP BY m.Manufacturer_Name  ORDER BY ABS(cov) DESC  LIMIT 5;	television	2
WITH total AS (     SELECT COUNT(DISTINCT Model) AS total_models      FROM televisions ),  ranked_manufacturers AS (     SELECT Manufacturer_Id,             (SELECT COUNT(*) FROM manufacturers m2 WHERE m2.Market_Share_Percent > m1.Market_Share_Percent) * 1.0 / (SELECT COUNT(*) FROM manufacturers) AS pct_rank      FROM manufacturers m1 ),  top_manufacturers AS (     SELECT Manufacturer_Id      FROM ranked_manufacturers      WHERE pct_rank < 0.1 )  SELECT (SELECT COUNT(DISTINCT Model)          FROM televisions          WHERE Manufacturer_Id IN (SELECT Manufacturer_Id FROM top_manufacturers)) * 1.0 / total_models AS ratio  FROM total  HAVING ratio > 0.5;	television	3
SELECT m.Manufacturer_Name, m.Profit_Usd/m.Employees AS per_capita FROM manufacturers m JOIN televisions t ON m.Manufacturer_Id=t.Manufacturer_Id WHERE m.Profit_Usd=1e30 AND m.Founded_Year=0 ORDER BY per_capita DESC	television	4
SELECT t.Model, (d.Brightness_Nits * 0.68 * u.Usage_Duration_Minutes * 60 * 2 * 3.141592653589793 * (u.Average_Brightness_Percent / 100)) AS total_light_energy_joules FROM televisions t JOIN display_data d ON t.Television_Id=d.Television_Id JOIN usage_records u ON t.Television_Id=u.Television_Id WHERE d.Brightness_Nits=800 AND u.Usage_Duration_Minutes=150 AND u.Average_Brightness_Percent=60;	television	1
WITH total_energy AS (     SELECT SUM(u.Usage_Duration_Minutes) / 60.0 * 0.25 AS total_kwh      FROM televisions t      JOIN usage_records u ON t.Television_Id = u.Television_Id      WHERE t.Resolution = '4K'      AND t.Panel_Type = 'OLED'      AND strftime('%Y', u.Start_Time) = '2023' ),  hdr_extra_energy AS (     SELECT total_kwh * 0.73 * 0.2 AS hdr_kwh      FROM total_energy )  SELECT total_kwh * 0.15 AS total_cost,         hdr_kwh * 0.15 AS savings  FROM total_energy, hdr_extra_energy;	television	2
SELECT ((320 - 220) * 4 * 365 / 1000) * 0.92 AS additional_carbon_emission_kg FROM televisions WHERE Energy_Rating IN ('B', 'A++');	television	3
WITH power_calculation AS (         SELECT 1500 * 5.0 * 8 * 125 AS single_power_watt,                 20000000 AS total_devices     ),      power_summary AS (         SELECT single_power_watt * total_devices / 1000000 AS total_power_mw          FROM power_calculation     ),      energy_calculation AS (         SELECT total_power_mw * 24 * 365 AS total_energy_kwh          FROM power_summary     ),      heat_calculation AS (         SELECT total_power_mw * 60 * 3.6 * POWER(10, 6) AS total_heat_joules          FROM power_summary     )      SELECT total_power_mw AS peak_power_mw,             total_energy_kwh / 12000000000000 AS required_moon_stations,             total_heat_joules / (3985 * 100) AS pacific_water_kg      FROM power_summary, energy_calculation, heat_calculation;	television	4
WITH mechanical_energy AS (     SELECT          Manufacturer_Id,          Manufacturer_Name,          Employees,          Profit_Usd,          Employees * 100 * 8 * 365 * 3600 AS total_mechanical_energy_joules      FROM manufacturers ),  energy_profit_density AS (     SELECT          Manufacturer_Id,          Manufacturer_Name,          total_mechanical_energy_joules,          Profit_Usd / total_mechanical_energy_joules AS energy_profit_density      FROM mechanical_energy )  SELECT      Manufacturer_Name,      total_mechanical_energy_joules,      energy_profit_density  FROM energy_profit_density  ORDER BY energy_profit_density DESC  LIMIT 5;	television	1
WITH country_stats AS (     SELECT          Country,          STDEV(Market_Share_Percent) AS market_share_stddev,          AVG(Market_Share_Percent) AS market_share_mean,          STDEV(Employees) AS employees_stddev,          AVG(Employees) AS employees_mean      FROM manufacturers      GROUP BY Country ),  risk_indicator AS (     SELECT          Country,          market_share_stddev * (employees_stddev / employees_mean) * 100 AS risk_value      FROM country_stats )  SELECT Country, risk_value  FROM risk_indicator  WHERE risk_value > 10;	television	2
SELECT Manufacturer_Name, Founded_Year, Market_Share_Percent FROM manufacturers WHERE (strftime('%Y', 'now') - Founded_Year) > 50 AND Market_Share_Percent < 5 ORDER BY Founded_Year ASC;	television	3
WITH energy_calculations AS (   SELECT      Manufacturer_Name,      Profit_Usd,      Employees,      (Profit_Usd * 3.6e6) / Employees AS energy_per_employee,      1.67e-27 * POWER(3e8, 2) AS proton_energy    FROM manufacturers   WHERE Profit_Usd >= 1e18 ) SELECT    Manufacturer_Name,    energy_per_employee,    proton_energy,    CASE      WHEN energy_per_employee > proton_energy THEN '超过质子能量'      ELSE '未超过质子能量'    END AS comparison_result FROM energy_calculations;	television	4
WITH Temperature_Sensor_Watches AS (   SELECT w.Watch_Id, w.Model, w.Manufacturer_id   FROM watches w   JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id   WHERE sd.Temperature_Sensor = 1 ), Radiation_Power AS (   SELECT tsw.Watch_Id, tsw.Model, tsw.Manufacturer_id,          (0.9 * 5.67e-8 * 0.005 * (POWER(309.15, 4) - POWER(293.15, 4))) AS Power_Watts   FROM Temperature_Sensor_Watches tsw ) SELECT rp.Watch_Id, rp.Model, rp.Power_Watts FROM Radiation_Power rp ORDER BY rp.Power_Watts DESC LIMIT 3;	television	1
WITH Sensor_Combinations AS (   SELECT Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor    FROM sensor_data ),  Combination_Counts AS (   SELECT Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor,           COUNT(*) AS combination_count    FROM Sensor_Combinations    GROUP BY Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor ),  Total_Combinations AS (   SELECT SUM(combination_count) AS total_count    FROM Combination_Counts ),  Probability_Combinations AS (   SELECT cc.Heart_Rate_Sensor, cc.Gps, cc.Accelerometer, cc.Gyroscope, cc.Blood_Oxygen_Sensor, cc.Ecg_Sensor, cc.Temperature_Sensor, cc.Altimeter, cc.Ambient_Light_Sensor,           CAST(cc.combination_count AS REAL) / tc.total_count AS probability    FROM Combination_Counts cc, Total_Combinations tc ),  Entropy_Calculation AS (   SELECT Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor,           -SUM(probability * (CASE WHEN probability > 0 THEN LOG(probability) ELSE 0 END) / LOG(2)) AS entropy    FROM Probability_Combinations    GROUP BY Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor )  SELECT *  FROM Entropy_Calculation  WHERE entropy > 2.5  ORDER BY entropy ASC;	television	2
SELECT w.Watch_Id, w.Model, w.Release_Date, w.Price_Usd, w.Weight_Grams, w.Water_Resistance_Meters, w.Battery_Life_Days, w.Screen_Size_Inches, w.Operating_System, w.Storage_Gb, w.Ram_Gb, w.Connectivity FROM watches w JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id WHERE w.Is_Smartwatch = 1 AND sd.Gps = 1 AND sd.Altimeter = 1 AND sd.Ambient_Light_Sensor = 0 ORDER BY w.Release_Date DESC;	television	3
SELECT w.Watch_Id, w.Model, (1000000.0 * 1000 * 16) AS Throughput_bits_per_second FROM watches w JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id WHERE sd.Blood_Oxygen_Sensor = 1 ORDER BY Throughput_bits_per_second DESC LIMIT 1;	television	4
SELECT ur.Record_Id, ur.User_Id, ur.Watch_Id, ur.Activity_Type, (ur.Calories_Burned * 4184) / ((strftime('%s', ur.End_Time) - strftime('%s', ur.Start_Time)) * 60) AS Power_Watts FROM usage_records ur WHERE ur.Activity_Type IN ('跑步', '游泳', '骑行') ORDER BY Power_Watts DESC LIMIT 5;	television	1
WITH Activity_Counts AS (   SELECT User_Id, Activity_Type, COUNT(*) AS activity_count   FROM usage_records   GROUP BY User_Id, Activity_Type ), Total_Records AS (   SELECT User_Id, COUNT(*) AS total_count   FROM usage_records   GROUP BY User_Id ), Activity_Probabilities AS (   SELECT ac.User_Id, ac.Activity_Type, ac.activity_count * 1.0 / tr.total_count AS probability   FROM Activity_Counts ac   JOIN Total_Records tr ON ac.User_Id = tr.User_Id ), Entropy_Calculation AS (   SELECT ap.User_Id, -SUM(ap.probability * (log(ap.probability) / log(2))) AS entropy   FROM Activity_Probabilities ap   GROUP BY ap.User_Id ) SELECT ec.User_Id, ec.entropy FROM Entropy_Calculation ec WHERE ec.entropy > 1.5 ORDER BY ec.entropy ASC;	television	2
SELECT ur.Record_Id, ur.User_Id, ur.Watch_Id, ur.Sleep_Duration_Minutes, ABS(ur.Sleep_Duration_Minutes - 450) AS deviation FROM usage_records ur WHERE ur.Sleep_Duration_Minutes > 540 OR ur.Sleep_Duration_Minutes < 240 ORDER BY deviation DESC;	television	3
SELECT ur.User_Id, ur.Steps, (0.5 * 60 * POWER(0.7 * 3, 2) * ur.Steps) AS Kinetic_Energy_Joules, ((0.5 * 60 * POWER(0.7 * 3, 2) * ur.Steps) / 4.184e12) AS TNT_Equivalent_kt FROM usage_records ur WHERE ur.Steps >= 1e8;	television	4
SELECT w.Watch_Id, w.Model, w.Water_Resistance_Meters, (1000 * 9.8 * w.Water_Resistance_Meters) AS Pressure_Pascals FROM watches w ORDER BY Pressure_Pascals DESC LIMIT 5;	television	1
WITH Mean_Values AS (   SELECT      AVG(Price_Usd) AS mean_price,      AVG(Weight_Kg) AS mean_weight,      AVG(Battery_Life_Days) AS mean_battery    FROM televisions ), Covariance_Matrix AS (   SELECT      SUM((Price_Usd - mv.mean_price) * (Price_Usd - mv.mean_price)) / COUNT(*) AS var_price,     SUM((Price_Usd - mv.mean_price) * (Weight_Kg - mv.mean_weight)) / COUNT(*) AS cov_price_weight,     SUM((Price_Usd - mv.mean_price) * (Battery_Life_Days - mv.mean_battery)) / COUNT(*) AS cov_price_battery,     SUM((Weight_Kg - mv.mean_weight) * (Weight_Kg - mv.mean_weight)) / COUNT(*) AS var_weight,     SUM((Weight_Kg - mv.mean_weight) * (Battery_Life_Days - mv.mean_battery)) / COUNT(*) AS cov_weight_battery,     SUM((Battery_Life_Days - mv.mean_battery) * (Battery_Life_Days - mv.mean_battery)) / COUNT(*) AS var_battery   FROM televisions, Mean_Values mv ), Mahalanobis_Distance AS (   SELECT      t.Television_Id,     t.Model,     t.Smart_Tv AS Is_Smartwatch,     SQRT(       (t.Price_Usd - mv.mean_price) * (t.Price_Usd - mv.mean_price) / cm.var_price +       (t.Weight_Kg - mv.mean_weight) * (t.Weight_Kg - mv.mean_weight) / cm.var_weight +       (t.Battery_Life_Days - mv.mean_battery) * (t.Battery_Life_Days - mv.mean_battery) / cm.var_battery     ) AS distance   FROM televisions t, Mean_Values mv, Covariance_Matrix cm ) SELECT    md.Television_Id AS Watch_Id,   md.Model,   md.Is_Smartwatch,   md.distance FROM Mahalanobis_Distance md WHERE md.distance > 3 * (SELECT STDEV(distance) FROM Mahalanobis_Distance) ORDER BY md.distance DESC;	television	2
SELECT w.Watch_Id, w.Model, w.Price_Usd, w.Water_Resistance_Meters, w.Is_Smartwatch FROM watches w WHERE w.Water_Resistance_Meters >= 100 AND w.Price_Usd < 100 AND w.Is_Smartwatch = 0 ORDER BY w.Price_Usd ASC;	television	3
SELECT w.Watch_Id, w.Model, w.Weight_Grams, ((w.Weight_Grams / 1000.0) * 9.8) / 1e-4 AS Pressure_Pa FROM watches w WHERE w.Weight_Grams >= 1e12;	television	4
SELECT w.Watch_Id, w.Model, w.Price_Usd, w.Release_Date  FROM watches w  JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id  WHERE w.Price_Usd < 100  AND sd.Heart_Rate_Sensor = 1  AND w.Is_Smartwatch = 1  ORDER BY w.Release_Date DESC;	television	1
WITH Variance_Calculation AS (   SELECT Operating_System,           (AVG(Price_Usd * Price_Usd) - AVG(Price_Usd) * AVG(Price_Usd)) AS var_price,          (AVG(Weight_Grams * Weight_Grams) - AVG(Weight_Grams) * AVG(Weight_Grams)) AS var_weight,          (AVG(Screen_Size_Inches * Screen_Size_Inches) - AVG(Screen_Size_Inches) * AVG(Screen_Size_Inches)) AS var_screen   FROM watches    GROUP BY Operating_System ), Trace_Calculation AS (   SELECT Operating_System,           (var_price + var_weight + var_screen) AS trace_value    FROM Variance_Calculation ) SELECT Operating_System, trace_value  FROM Trace_Calculation  ORDER BY trace_value DESC  LIMIT 3;	television	2
SELECT FLOOR(Price_Usd / 100) * 100 AS price_range, COUNT(*) AS watch_count FROM watches WHERE Water_Resistance_Meters >= 50 AND Is_Smartwatch = 0 GROUP BY FLOOR(Price_Usd / 100) * 100 ORDER BY watch_count DESC;	television	3
SELECT Connectivity, AVG((Battery_Life_Days * 5 * 3600) / (Weight_Grams * 0.99 / 1000)) AS Energy_Density_J_per_kg FROM watches GROUP BY Connectivity HAVING Energy_Density_J_per_kg > 30000000;	television	4
SELECT User_Id, SUM(Calories_Burned * 4184) / SUM(strftime('%s', End_Time) - strftime('%s', Start_Time)) AS Avg_Power_Watts  FROM usage_records  GROUP BY User_Id  HAVING Avg_Power_Watts > 100;	television	1
WITH stats AS (   SELECT      Content_Type,      AVG(Average_Brightness_Percent) AS avg_brightness,      AVG(User_Rating) AS avg_rating,      (AVG(Average_Brightness_Percent * Average_Brightness_Percent) - AVG(Average_Brightness_Percent) * AVG(Average_Brightness_Percent)) AS variance_brightness,     (AVG(User_Rating * User_Rating) - AVG(User_Rating) * AVG(User_Rating)) AS variance_rating,     COUNT(*) AS n    FROM usage_records    GROUP BY Content_Type ),  correlations AS (   SELECT      u.Content_Type,      (AVG(u.Average_Brightness_Percent * u.User_Rating) - AVG(u.Average_Brightness_Percent) * AVG(u.User_Rating)) /      (SQRT(s.variance_brightness) * SQRT(s.variance_rating)) AS pearson_corr    FROM usage_records u    JOIN stats s ON u.Content_Type = s.Content_Type    GROUP BY u.Content_Type )  SELECT Content_Type, pearson_corr  FROM correlations  WHERE ABS(pearson_corr) > 0.7  ORDER BY ABS(pearson_corr) DESC;	television	2
WITH SleepIntervals AS (   SELECT      Watch_Id,     (strftime('%s', Start_Time) / 7200) * 7200 AS Interval_Start,     COUNT(*) AS Total_Records,     SUM(CASE WHEN Heart_Rate_Avg_Bpm < 40 OR Heart_Rate_Avg_Bpm > 100 THEN 1 ELSE 0 END) AS Abnormal_Records   FROM usage_records   WHERE Activity_Type = 'sleep'   GROUP BY Watch_Id, (strftime('%s', Start_Time) / 7200) ) SELECT    Interval_Start,   CASE      WHEN Total_Records > 0 THEN ROUND((Abnormal_Records * 100.0 / Total_Records), 2)     ELSE 0    END AS Incidence_Rate_Percent FROM SleepIntervals ORDER BY Interval_Start;	watch	3
WITH Sensor_Combinations AS (   SELECT Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor    FROM sensor_data ), Combination_Counts AS (   SELECT Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor,           COUNT(*) AS combination_count    FROM Sensor_Combinations    GROUP BY Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor ), Total_Combinations AS (   SELECT SUM(combination_count) AS total_count    FROM Combination_Counts ), Probability_Combinations AS (   SELECT cc.Heart_Rate_Sensor, cc.Gps, cc.Accelerometer, cc.Gyroscope, cc.Blood_Oxygen_Sensor, cc.Ecg_Sensor, cc.Temperature_Sensor, cc.Altimeter, cc.Ambient_Light_Sensor,           CAST(cc.combination_count AS REAL) / tc.total_count AS probability    FROM Combination_Counts cc, Total_Combinations tc ), Entropy_Calculation AS (   SELECT Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor,           -SUM(probability * LOG(2, probability)) AS entropy    FROM Probability_Combinations    GROUP BY Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor )  SELECT * FROM Entropy_Calculation  WHERE entropy > 2.5  ORDER BY entropy ASC;	watch	4
SELECT w.Watch_Id, w.Model, w.Release_Date, w.Price_Usd, w.Weight_Grams, w.Water_Resistance_Meters, w.Battery_Life_Days, w.Screen_Size_Inches, w.Operating_System, w.Storage_Gb, w.Ram_Gb, w.Connectivity FROM watches w JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id WHERE w.Is_Smartwatch = 1 AND sd.Gps = 1 AND sd.Altimeter = 1 AND sd.Ambient_Light_Sensor = 0 ORDER BY w.Release_Date DESC;	watch	1
WITH sensor_configs AS (     SELECT          w.Manufacturer_id,         CASE WHEN MAX(sd.Heart_Rate_Sensor) = 1 THEN 1 ELSE 0 END AS hr,         CASE WHEN MAX(sd.Gps) = 1 THEN 1 ELSE 0 END AS gps,         CASE WHEN MAX(sd.Accelerometer) = 1 THEN 1 ELSE 0 END AS acc,         CASE WHEN MAX(sd.Gyroscope) = 1 THEN 1 ELSE 0 END AS gyro,         CASE WHEN MAX(sd.Blood_Oxygen_Sensor) = 1 THEN 1 ELSE 0 END AS bo,         CASE WHEN MAX(sd.Ecg_Sensor) = 1 THEN 1 ELSE 0 END AS ecg,         CASE WHEN MAX(sd.Temperature_Sensor) = 1 THEN 1 ELSE 0 END AS temp,         CASE WHEN MAX(sd.Altimeter) = 1 THEN 1 ELSE 0 END AS alt     FROM watches w     JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id     GROUP BY w.Manufacturer_id ), country_configs AS (     SELECT          m.Country,         GROUP_CONCAT(sc.hr || sc.gps || sc.acc || sc.gyro || sc.bo || sc.ecg || sc.temp || sc.alt) AS config_strings     FROM manufacturers m     JOIN sensor_configs sc ON m.Manufacturer_Id = sc.Manufacturer_id     GROUP BY m.Country ), hamming_trace AS (     SELECT          cc1.Country,         SUM((             (SUBSTR(cc1.config_strings, i*8-7, 1) != SUBSTR(cc2.config_strings, i*8-7, 1)) +             (SUBSTR(cc1.config_strings, i*8-6, 1) != SUBSTR(cc2.config_strings, i*8-6, 1)) +             (SUBSTR(cc1.config_strings, i*8-5, 1) != SUBSTR(cc2.config_strings, i*8-5, 1)) +             (SUBSTR(cc1.config_strings, i*8-4, 1) != SUBSTR(cc2.config_strings, i*8-4, 1)) +             (SUBSTR(cc1.config_strings, i*8-3, 1) != SUBSTR(cc2.config_strings, i*8-3, 1)) +             (SUBSTR(cc1.config_strings, i*8-2, 1) != SUBSTR(cc2.config_strings, i*8-2, 1)) +             (SUBSTR(cc1.config_strings, i*8-1, 1) != SUBSTR(cc2.config_strings, i*8-1, 1)) +             (SUBSTR(cc1.config_strings, i*8, 1) != SUBSTR(cc2.config_strings, i*8, 1))         )) AS trace     FROM country_configs cc1     CROSS JOIN country_configs cc2     CROSS JOIN (SELECT 1 AS i UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) nums     WHERE i <= LENGTH(cc1.config_strings) / 8     GROUP BY cc1.Country ) SELECT Country, trace AS trace_distance FROM hamming_trace ORDER BY trace DESC LIMIT 3;	watch	2
SELECT w.Operating_System, COUNT(DISTINCT w.Watch_Id) AS Abnormal_Device_Count FROM watches w JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id WHERE sd.Blood_Oxygen_Sensor = 1 AND sd.Ecg_Sensor = 1 AND sd.Heart_Rate_Sensor = 0 GROUP BY w.Operating_System;	watch	3
WITH Activity_Counts AS (   SELECT User_Id, Activity_Type, COUNT(*) AS activity_count   FROM usage_records   GROUP BY User_Id, Activity_Type ), Total_Records AS (   SELECT User_Id, COUNT(*) AS total_count   FROM usage_records   GROUP BY User_Id ), Activity_Probabilities AS (   SELECT ac.User_Id, ac.Activity_Type, ac.activity_count * 1.0 / tr.total_count AS probability   FROM Activity_Counts ac   JOIN Total_Records tr ON ac.User_Id = tr.User_Id ), Entropy_Calculation AS (   SELECT ap.User_Id, -SUM(ap.probability * (ap.probability + 1e-15) * LOG(2, ap.probability + 1e-15)) AS entropy   FROM Activity_Probabilities ap   GROUP BY ap.User_Id ) SELECT ec.User_Id, ec.entropy FROM Entropy_Calculation ec WHERE ec.entropy > 1.5 ORDER BY ec.entropy ASC;	watch	4
SELECT Country, SUM(Profit_Usd) * 3.6e6 / SUM(Employees) AS per_capita_energy  FROM manufacturers  GROUP BY Country  HAVING per_capita_energy > 1e10;	watch	1
SELECT ur.User_Id, ur.Steps, (0.5 * 60 * POWER(0.7 * 3, 2) * ur.Steps) AS Kinetic_Energy_Joules, ((0.5 * 60 * POWER(0.7 * 3, 2) * ur.Steps) / 4.184e12) AS TNT_Equivalent_kt FROM usage_records ur WHERE ur.Steps >= 1e8;	watch	2
SELECT w.Watch_Id, w.Model, w.Water_Resistance_Meters, (1000.0 * 9.8 * w.Water_Resistance_Meters) AS Pressure_Pascals FROM watches w ORDER BY Pressure_Pascals DESC LIMIT 5;	watch	3
WITH Mean_Values AS (   SELECT AVG(Price_Usd) AS mean_price, AVG(Weight_Grams) AS mean_weight, AVG(Battery_Life_Days) AS mean_battery    FROM watches ),  Covariance_Matrix AS (   SELECT      SUM((Price_Usd - mv.mean_price) * (Price_Usd - mv.mean_price)) / COUNT(*) AS var_price,     SUM((Price_Usd - mv.mean_price) * (Weight_Grams - mv.mean_weight)) / COUNT(*) AS cov_price_weight,     SUM((Price_Usd - mv.mean_price) * (Battery_Life_Days - mv.mean_battery)) / COUNT(*) AS cov_price_battery,     SUM((Weight_Grams - mv.mean_weight) * (Weight_Grams - mv.mean_weight)) / COUNT(*) AS var_weight,     SUM((Weight_Grams - mv.mean_weight) * (Battery_Life_Days - mv.mean_battery)) / COUNT(*) AS cov_weight_battery,     SUM((Battery_Life_Days - mv.mean_battery) * (Battery_Life_Days - mv.mean_battery)) / COUNT(*) AS var_battery   FROM watches, Mean_Values mv ), Mahalanobis_Distance AS (   SELECT      w.Watch_Id,      w.Model,      w.Is_Smartwatch,      SQRT(       (w.Price_Usd - mv.mean_price) * (w.Price_Usd - mv.mean_price) / cm.var_price +        (w.Weight_Grams - mv.mean_weight) * (w.Weight_Grams - mv.mean_weight) / cm.var_weight +        (w.Battery_Life_Days - mv.mean_battery) * (w.Battery_Life_Days - mv.mean_battery) / cm.var_battery     ) AS distance    FROM watches w, Mean_Values mv, Covariance_Matrix cm ) SELECT md.Watch_Id, md.Model, md.Is_Smartwatch, md.distance  FROM Mahalanobis_Distance md  WHERE md.distance > 3 * (SELECT STDEV(distance) FROM Mahalanobis_Distance)  ORDER BY md.distance DESC;	watch	4
SELECT w.Watch_Id, w.Model, w.Price_Usd, w.Water_Resistance_Meters, w.Is_Smartwatch FROM watches w WHERE w.Water_Resistance_Meters >= 100 AND w.Price_Usd < 100 AND w.Is_Smartwatch = 0 ORDER BY w.Price_Usd ASC;	watch	1
SELECT m.Country FROM manufacturers m JOIN watches w ON m.Manufacturer_Id = w.Manufacturer_Id WHERE m.Manufacturer_Id IN (     SELECT Manufacturer_Id     FROM manufacturers     WHERE Market_Share_Percent < (         SELECT MAX(Market_Share_Percent) * 0.9         FROM manufacturers     ) ) GROUP BY m.Country HAVING MAX(m.Founded_Year) > 50 AND m.Country NOT IN (     SELECT Country     FROM manufacturers     GROUP BY Country     ORDER BY AVG(Market_Share_Percent) DESC     LIMIT (SELECT COUNT(DISTINCT Country) * 0.1 FROM manufacturers) );	watch	2
SELECT m.Manufacturer_Name, m.Headquarters FROM manufacturers m WHERE m.Headquarters IN ('New York', 'Los Angeles', 'Miami', 'Seattle', 'San Francisco', 'Boston') AND m.Manufacturer_Id NOT IN (     SELECT DISTINCT w.Manufacturer_id     FROM watches w     WHERE w.Water_Resistance_Meters > 0 );	watch	3
WITH Variance_Calculation AS (   SELECT Operating_System,           (SUM(Price_Usd * Price_Usd) - SUM(Price_Usd) * SUM(Price_Usd) / COUNT(*)) / (COUNT(*) - 1) AS var_price,           (SUM(Weight_Grams * Weight_Grams) - SUM(Weight_Grams) * SUM(Weight_Grams) / COUNT(*)) / (COUNT(*) - 1) AS var_weight,           (SUM(Screen_Size_Inches * Screen_Size_Inches) - SUM(Screen_Size_Inches) * SUM(Screen_Size_Inches) / COUNT(*)) / (COUNT(*) - 1) AS var_screen    FROM watches    GROUP BY Operating_System ),  Trace_Calculation AS (   SELECT Operating_System,           (var_price + var_weight + var_screen) AS trace_value    FROM Variance_Calculation )  SELECT Operating_System, trace_value  FROM Trace_Calculation  ORDER BY trace_value DESC  LIMIT 3;	watch	4
SELECT * FROM watches w JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id WHERE sd.Accelerometer = 1 AND NOT EXISTS (     SELECT 1     FROM usage_records ur     WHERE ur.Watch_Id = w.Watch_Id     AND ur.Activity_Type = 'Running' -- Assuming representative activity for motion frequency analysis     GROUP BY ur.Watch_Id     HAVING COUNT(*) >= 100 -- Assuming sampling frequency < 100Hz violates Nyquist for 50Hz max human motion ) EXCEPT SELECT w.* FROM watches w JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id WHERE sd.Accelerometer = 1 AND EXISTS (     SELECT 1     FROM usage_records ur     WHERE ur.Watch_Id = w.Watch_Id     AND ur.Activity_Type = 'Running'     GROUP BY ur.Watch_Id     HAVING COUNT(*) >= 100 );	watch	1
SELECT Connectivity, AVG((Battery_Life_Days * 5 * 3600) / (Weight_Grams * 0.99 / 1000)) AS Energy_Density_J_per_kg FROM watches GROUP BY Connectivity HAVING Energy_Density_J_per_kg > 30000000;	watch	2
SELECT w.Model  FROM watches w  JOIN usage_records ur ON w.Watch_Id = ur.Watch_Id  JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id  WHERE ur.Activity_Type = 'Swimming'  AND sd.Water_Resistance_Sensor = 0  GROUP BY w.Model;	watch	3
SELECT Activity_Type, (AVG(Steps * Heart_Rate_Avg_Bpm) - AVG(Steps) * AVG(Heart_Rate_Avg_Bpm)) / (STDDEV_SAMP(Steps) * STDDEV_SAMP(Heart_Rate_Avg_Bpm)) AS Pearson_Correlation FROM usage_records GROUP BY Activity_Type HAVING ABS(Pearson_Correlation) > 0.7;	watch	4
SELECT User_Id FROM usage_records  WHERE Calories_Burned > Distance_Km * 60 * 1.036  EXCEPT  SELECT User_Id FROM users WHERE Is_Verified = 1;	watch	1
SELECT Activity_Type, SUM((Calories_Burned * 4184) / 4.184e9) AS TNT_Equivalent FROM usage_records GROUP BY Activity_Type HAVING TNT_Equivalent > 1e6;	watch	2
SELECT User_Id FROM usage_records WHERE Activity_Type = 'sleep' GROUP BY User_Id HAVING AVG(Heart_Rate_Avg_Bpm) > 100 AND User_Id NOT IN (     SELECT DISTINCT User_Id     FROM usage_records     WHERE Heart_Rate_Avg_Bpm > 100 );	watch	3
WITH Sensor_Counts AS (     SELECT m.Country, COUNT(DISTINCT s.Sensor_Id) AS Sensor_Count      FROM manufacturers m      JOIN watches w ON m.Manufacturer_Id = w.Manufacturer_id      JOIN sensor_data s ON w.Watch_Id = s.Watch_Id      GROUP BY m.Country ),  Pairwise_Distances AS (     SELECT A.Country AS Country_A, B.Country AS Country_B,             1.0 - (1.0 * COUNT(DISTINCT CASE WHEN s1.Sensor_Id = s2.Sensor_Id THEN s1.Sensor_Id END) / (A.Sensor_Count + B.Sensor_Count - COUNT(DISTINCT CASE WHEN s1.Sensor_Id = s2.Sensor_Id THEN s1.Sensor_Id END))) AS Hamming_Distance      FROM Sensor_Counts A      CROSS JOIN Sensor_Counts B      JOIN manufacturers m1 ON A.Country = m1.Country      JOIN manufacturers m2 ON B.Country = m2.Country      JOIN watches w1 ON m1.Manufacturer_Id = w1.Manufacturer_id      JOIN watches w2 ON m2.Manufacturer_Id = w2.Manufacturer_id      JOIN sensor_data s1 ON w1.Watch_Id = s1.Watch_Id      JOIN sensor_data s2 ON w2.Watch_Id = s2.Watch_Id      WHERE A.Country != B.Country      GROUP BY A.Country, B.Country )  SELECT Country_A, SUM(Hamming_Distance) AS Trace  FROM Pairwise_Distances  GROUP BY Country_A  ORDER BY Trace DESC  LIMIT 3;	watch	4
SELECT Operating_System, COUNT(*) AS Abnormal_Device_Count  FROM watches  JOIN sensor_data ON watches.Watch_Id = sensor_data.Watch_Id  WHERE Ecg_Sensor = 1 AND Blood_Oxygen_Sensor = 1 AND Heart_Rate_Sensor = 0  GROUP BY Operating_System;	watch	1
SELECT Connectivity, 1e6 * 0.000001 * 1361 AS Theoretical_Flux_W FROM watches WHERE Watch_Id IN (SELECT Watch_Id FROM sensor_data WHERE Ambient_Light_Sensor = 1) GROUP BY Connectivity HAVING Theoretical_Flux_W > 1361;	watch	2
SELECT Watch_Id FROM watches WHERE Is_Smartwatch = 1 AND (Ram_Gb < 1 OR Storage_Gb < 8) EXCEPT SELECT Watch_Id FROM discontinued;	television	3
SELECT Watch_Id FROM watches WHERE Battery_Life_Days > 100000 EXCEPT SELECT Watch_Id FROM watches WHERE Release_Date LIKE '%虚拟测试%';	television	4
SELECT 3.7 * Battery_Life_Days / Weight_Grams AS Energy_Density FROM watches ORDER BY Energy_Density DESC LIMIT 5;	watch	1
WITH price_ranges AS (     SELECT          CASE              WHEN Price_Usd < 100 THEN '0-99'             WHEN Price_Usd < 200 THEN '100-199'             WHEN Price_Usd < 500 THEN '200-499'             WHEN Price_Usd < 1000 THEN '500-999'             ELSE '1000+'         END AS price_range,         Screen_Size_Inches,         Weight_Grams     FROM watches ), correlations AS (     SELECT          price_range,         (COUNT(*) * SUM(Screen_Size_Inches * Weight_Grams) - SUM(Screen_Size_Inches) * SUM(Weight_Grams)) /          (SQRT(COUNT(*) * SUM(Screen_Size_Inches * Screen_Size_Inches) - SUM(Screen_Size_Inches) * SUM(Screen_Size_Inches)) *           SQRT(COUNT(*) * SUM(Weight_Grams * Weight_Grams) - SUM(Weight_Grams) * SUM(Weight_Grams))) AS correlation     FROM price_ranges     GROUP BY price_range ) SELECT price_range, ABS(correlation) AS abs_correlation FROM correlations WHERE correlation IS NOT NULL ORDER BY abs_correlation DESC LIMIT 3;	watch	2
SELECT Watch_Id, Model, Price_Usd, Water_Resistance_Meters FROM watches WHERE Price_Usd > 1000 AND Water_Resistance_Meters < 50 AND Is_Smartwatch = 0 ORDER BY Price_Usd DESC;	television	3
WITH Frequency_Analysis AS (     SELECT Country, ABS(Founded_Year % 100) AS Frequency      FROM manufacturers ),  Ranked_Market_Share AS (     SELECT Country, ROW_NUMBER() OVER (ORDER BY Market_Share_Percent DESC) AS rn      FROM manufacturers ),  Top_Market_Share AS (     SELECT Country      FROM Ranked_Market_Share      WHERE rn <= (SELECT COUNT(*) * 0.1 FROM manufacturers) )  SELECT fa.Country  FROM Frequency_Analysis fa  WHERE fa.Frequency > 50  AND fa.Country NOT IN (SELECT Country FROM Top_Market_Share);	watch	4
WITH User_Exercise AS (     SELECT          ur.Record_Id,         ur.Watch_Id,         ur.Steps,         ur.Activity_Type,         w.Weight_Grams,         (60.0 * 0.5 * POWER((ur.Steps / (JULIANDAY(ur.End_Time) - JULIANDAY(ur.Start_Time)) * 24 * 60 * 60), 2)) AS Kinetic_Energy     FROM usage_records ur     JOIN watches w ON ur.Watch_Id = w.Watch_Id     WHERE ur.Activity_Type IS NOT NULL        AND ur.Start_Time IS NOT NULL        AND ur.End_Time IS NOT NULL        AND ur.Steps > 0 ) SELECT      Record_Id,     Watch_Id,     Steps,     Activity_Type,     Weight_Grams,     Kinetic_Energy FROM User_Exercise ORDER BY Kinetic_Energy DESC LIMIT 10;	watch	1
WITH CumulativeDeviations AS (   SELECT      User_Id,      Sleep_Duration_Minutes,      SUM(Sleep_Duration_Minutes - (SELECT AVG(Sleep_Duration_Minutes) FROM usage_records ur2 WHERE ur2.User_Id = usage_records.User_Id)) OVER (PARTITION BY User_Id ORDER BY Record_Id) AS CumulativeDeviation    FROM usage_records ), RescaledRanges AS (   SELECT      User_Id,      (MAX(CumulativeDeviation) - MIN(CumulativeDeviation)) / (SELECT STDEV(Sleep_Duration_Minutes) FROM CumulativeDeviations cd2 WHERE cd2.User_Id = CumulativeDeviations.User_Id) AS RS    FROM CumulativeDeviations    GROUP BY User_Id )  SELECT    User_Id,    LOG(RS) / LOG(COUNT(*) / 2) AS Hurst_Index  FROM RescaledRanges  GROUP BY User_Id  HAVING Hurst_Index > 0.8  ORDER BY Hurst_Index DESC;	television	2
WITH Accelerometer_Watches AS (     SELECT Watch_Id      FROM sensor_data      WHERE Accelerometer = 1 ),  Nyquist_Compliant_Watches AS (     SELECT Watch_Id      FROM watches      WHERE Storage_Gb * 1000000000.0 / (3600 * 24 * 50 * 4) > 100 ) SELECT aw.Watch_Id  FROM Accelerometer_Watches aw  WHERE aw.Watch_Id NOT IN (     SELECT Watch_Id      FROM Nyquist_Compliant_Watches );	watch	3
WITH Sensor_Dependency AS (     SELECT          sd1.Watch_Id,          COUNT(*) AS Total_Records,          SUM(CASE WHEN sd1.Heart_Rate_Sensor = 1 AND sd2.Ecg_Sensor = 1 THEN 1 ELSE 0 END) AS HR_ECG_Count,         SUM(CASE WHEN sd1.Heart_Rate_Sensor = 1 THEN 1 ELSE 0 END) AS HR_Count,         SUM(CASE WHEN sd2.Ecg_Sensor = 1 THEN 1 ELSE 0 END) AS ECG_Count     FROM sensor_data sd1      JOIN sensor_data sd2 ON sd1.Watch_Id = sd2.Watch_Id      GROUP BY sd1.Watch_Id ), Mutual_Information AS (     SELECT          Watch_Id,          (HR_ECG_Count * 1.0 / Total_Records) * LOG((HR_ECG_Count * 1.0 / Total_Records) / ((HR_Count * 1.0 / Total_Records) * (ECG_Count * 1.0 / Total_Records))) AS MI     FROM Sensor_Dependency      WHERE HR_ECG_Count > 0 AND HR_Count > 0 AND ECG_Count > 0 ) SELECT mi.Watch_Id  FROM Mutual_Information mi  WHERE mi.MI > 0.5;	watch	4
WITH Swimming_Watches AS (     SELECT DISTINCT Watch_Id      FROM usage_records      WHERE Activity_Type = '游泳' ),  Waterproof_Watches AS (     SELECT Watch_Id      FROM watches      WHERE Water_Resistance_Meters >= 1 )  SELECT w.Model  FROM watches w  JOIN Swimming_Watches sw ON w.Watch_Id = sw.Watch_Id  WHERE w.Watch_Id NOT IN (     SELECT Watch_Id      FROM Waterproof_Watches );	watch	1
WITH Sensor_Configurations AS (   SELECT Watch_Id, Heart_Rate_Sensor, Gps, Accelerometer, Gyroscope, Blood_Oxygen_Sensor, Ecg_Sensor, Temperature_Sensor, Altimeter, Ambient_Light_Sensor    FROM sensor_data ),  Cosine_Similarity AS (   SELECT      sc1.Watch_Id AS Watch_Id1,      sc2.Watch_Id AS Watch_Id2,      ((sc1.Heart_Rate_Sensor * sc2.Heart_Rate_Sensor) +       (sc1.Gps * sc2.Gps) +       (sc1.Accelerometer * sc2.Accelerometer) +       (sc1.Gyroscope * sc2.Gyroscope) +       (sc1.Blood_Oxygen_Sensor * sc2.Blood_Oxygen_Sensor) +       (sc1.Ecg_Sensor * sc2.Ecg_Sensor) +       (sc1.Temperature_Sensor * sc2.Temperature_Sensor) +       (sc1.Altimeter * sc2.Altimeter) +       (sc1.Ambient_Light_Sensor * sc2.Ambient_Light_Sensor)) /      (SQRT((sc1.Heart_Rate_Sensor * sc1.Heart_Rate_Sensor) +            (sc1.Gps * sc1.Gps) +            (sc1.Accelerometer * sc1.Accelerometer) +            (sc1.Gyroscope * sc1.Gyroscope) +            (sc1.Blood_Oxygen_Sensor * sc1.Blood_Oxygen_Sensor) +            (sc1.Ecg_Sensor * sc1.Ecg_Sensor) +            (sc1.Temperature_Sensor * sc1.Temperature_Sensor) +            (sc1.Altimeter * sc1.Altimeter) +            (sc1.Ambient_Light_Sensor * sc1.Ambient_Light_Sensor)) *       SQRT((sc2.Heart_Rate_Sensor * sc2.Heart_Rate_Sensor) +            (sc2.Gps * sc2.Gps) +            (sc2.Accelerometer * sc2.Accelerometer) +            (sc2.Gyroscope * sc2.Gyroscope) +            (sc2.Blood_Oxygen_Sensor * sc2.Blood_Oxygen_Sensor) +            (sc2.Ecg_Sensor * sc2.Ecg_Sensor) +            (sc2.Temperature_Sensor * sc2.Temperature_Sensor) +            (sc2.Altimeter * sc2.Altimeter) +            (sc2.Ambient_Light_Sensor * sc2.Ambient_Light_Sensor))) AS Cosine_Similarity    FROM Sensor_Configurations sc1    CROSS JOIN Sensor_Configurations sc2    WHERE sc1.Watch_Id < sc2.Watch_Id )  SELECT Watch_Id1, Watch_Id2, Cosine_Similarity  FROM Cosine_Similarity  ORDER BY Cosine_Similarity ASC  LIMIT 3;	watch	2
SELECT w.Watch_Id, w.Model, w.Release_Date  FROM watches w  JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id  WHERE sd.Altimeter = 1 AND sd.Gps = 0  ORDER BY w.Release_Date DESC;	watch	3
WITH Lyapunov_Calculation AS (     SELECT          ur.User_Id,          (1.0 / COUNT(*)) * SUM(LN(ABS(ur.Heart_Rate_Avg_Bpm - lag_hr.prev_Heart_Rate_Avg_Bpm))) AS Lyapunov_Exponent      FROM usage_records ur      LEFT JOIN (         SELECT              User_Id,              Heart_Rate_Avg_Bpm,              Start_Time,              (SELECT Heart_Rate_Avg_Bpm FROM usage_records WHERE User_Id = ur_inner.User_Id AND Start_Time < ur_inner.Start_Time ORDER BY Start_Time DESC LIMIT 1) AS prev_Heart_Rate_Avg_Bpm          FROM usage_records ur_inner     ) lag_hr ON ur.User_Id = lag_hr.User_Id AND ur.Start_Time = lag_hr.Start_Time      GROUP BY ur.User_Id ) SELECT lc.User_Id  FROM Lyapunov_Calculation lc  WHERE lc.Lyapunov_Exponent > 0.5;	watch	4
SELECT Manufacturer_Id, Manufacturer_Name, Profit_Usd, (Profit_Usd / (3e8 * 3e8)) AS Mass_Kg FROM manufacturers ORDER BY Mass_Kg DESC LIMIT 5;	watch	1
WITH Country_Stats AS (   SELECT      Country,     STDEV(Market_Share_Percent) AS Market_Share_StdDev,     STDEV(Employees) * 1.0 / AVG(Employees) AS Employees_CV    FROM manufacturers    GROUP BY Country ) SELECT    Country,   Market_Share_StdDev,   Employees_CV,   (Market_Share_StdDev * Employees_CV) AS Product_Value  FROM Country_Stats  ORDER BY Product_Value DESC  LIMIT 3;	watch	2
SELECT Manufacturer_Id, Manufacturer_Name, Country, Revenue_Usd, Profit_Usd, Market_Share_Percent, Employees, Founded_Year, Headquarters, Website, Contact_Email FROM manufacturers WHERE Employees > 5000 AND Profit_Usd < 100000000 ORDER BY Founded_Year ASC;	watch	3
WITH Profit_Countries AS (   SELECT Country, Profit_Usd AS Profit    FROM manufacturers    WHERE Profit_Usd >= 1e30 ), Continent_Profit AS (   SELECT      CASE        WHEN Country IN ('中国','印度','日本','韩国') THEN '亚洲'        WHEN Country IN ('美国','加拿大','墨西哥') THEN '北美洲'        WHEN Country IN ('巴西','阿根廷','秘鲁') THEN '南美洲'        WHEN Country IN ('德国','法国','英国','意大利') THEN '欧洲'        WHEN Country IN ('南非','埃及','尼日利亚') THEN '非洲'        WHEN Country IN ('澳大利亚','新西兰') THEN '大洋洲'        ELSE '未知'      END AS Continent,     SUM(Profit) AS Total_Profit    FROM Profit_Countries    GROUP BY Continent ), Continent_Area AS (   SELECT      Continent,     CASE        WHEN Continent='亚洲' THEN 44579000        WHEN Continent='北美洲' THEN 24247000        WHEN Continent='南美洲' THEN 17840000        WHEN Continent='欧洲' THEN 10180000        WHEN Continent='非洲' THEN 30370000        WHEN Continent='大洋洲' THEN 8525989        ELSE 0      END AS Area    FROM (SELECT DISTINCT Continent FROM Continent_Profit) AS Subquery ), Profit_Per_Area AS (   SELECT      cp.Continent,     cp.Total_Profit / ca.Area AS Profit_Per_Area    FROM Continent_Profit cp    JOIN Continent_Area ca ON cp.Continent = ca.Continent ) SELECT    Continent,   Profit_Per_Area > 1e44 AS Is_Supernova_Energy  FROM Profit_Per_Area;	watch	4
WITH Employee_Metabolism AS (     SELECT Country, Employees, Employees * 2000 * 365 * 4.184 AS Total_Metabolism_Joules      FROM manufacturers ), Country_Metabolism AS (     SELECT Country, SUM(Total_Metabolism_Joules) AS Total_Metabolism_Joules      FROM Employee_Metabolism      GROUP BY Country ) SELECT Country, Total_Metabolism_Joules  FROM Country_Metabolism  WHERE Total_Metabolism_Joules > 1e15;	watch	1
WITH GroupedManufacturers AS (     SELECT CAST((Founded_Year - 1900) / 20 AS INTEGER) * 20 + 1900 AS GroupStartYear,             Market_Share_Percent      FROM manufacturers ), RankedMarketShares AS (     SELECT GroupStartYear,             Market_Share_Percent,            ROW_NUMBER() OVER (PARTITION BY GroupStartYear ORDER BY Market_Share_Percent) AS RowNum,            COUNT(*) OVER (PARTITION BY GroupStartYear) AS TotalCount      FROM GroupedManufacturers ), GiniCalculation AS (     SELECT A.GroupStartYear,            SUM(ABS(A.RowNum - B.RowNum) * A.Market_Share_Percent * B.Market_Share_Percent) /             (2 * (SELECT SUM(Market_Share_Percent * Market_Share_Percent)                   FROM RankedMarketShares                   WHERE GroupStartYear = A.GroupStartYear)) AS GiniCoefficient      FROM RankedMarketShares A      JOIN RankedMarketShares B ON A.GroupStartYear = B.GroupStartYear      GROUP BY A.GroupStartYear ) SELECT GroupStartYear, GiniCoefficient  FROM GiniCalculation  WHERE GiniCoefficient > 0.6  ORDER BY GroupStartYear;	watch	2
SELECT Continent, COUNT(*) AS Company_Count FROM manufacturers WHERE (strftime('%Y', 'now') - Founded_Year) > 50 AND Employees < 100 GROUP BY Continent ORDER BY Company_Count DESC;	watch	3
SELECT FLOOR(Price_Usd / 500) * 500 AS Price_Interval, (AVG(Screen_Size_Inches * Weight_Grams) - AVG(Screen_Size_Inches) * AVG(Weight_Grams)) / (STDDEV_SAMP(Screen_Size_Inches) * STDDEV_SAMP(Weight_Grams)) AS Pearson_Correlation FROM watches GROUP BY Price_Interval ORDER BY ABS(Pearson_Correlation) DESC LIMIT 3;	watch	4
SELECT Operating_System,         SUM(Power_Consumption) / SUM(Battery_Capacity) AS Power_Ratio FROM (     SELECT w.Operating_System,            -- Calculate total sensor power consumption            (CASE WHEN sd.Heart_Rate_Sensor = 1 THEN 5 ELSE 0 END +             CASE WHEN sd.Gps = 1 THEN 15 ELSE 0 END +             CASE WHEN sd.Accelerometer = 1 THEN 3 ELSE 0 END +             CASE WHEN sd.Gyroscope = 1 THEN 4 ELSE 0 END +             CASE WHEN sd.Blood_Oxygen_Sensor = 1 THEN 6 ELSE 0 END +             CASE WHEN sd.Ecg_Sensor = 1 THEN 8 ELSE 0 END +             CASE WHEN sd.Temperature_Sensor = 1 THEN 2 ELSE 0 END +             CASE WHEN sd.Altimeter = 1 THEN 3 ELSE 0 END +             CASE WHEN sd.Ambient_Light_Sensor = 1 THEN 1 ELSE 0 END) AS Power_Consumption,            -- Calculate battery capacity based on battery life days (assuming average daily usage)            (w.Battery_Life_Days * 100) AS Battery_Capacity  -- Assuming 100 mAh per day as baseline     FROM watches w     JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id     WHERE w.Is_Smartwatch = 1  -- Only consider smartwatches for sensor power analysis ) GROUP BY Operating_System HAVING Power_Ratio > 1;	watch	1
SELECT Country,         -SUM((Configuration_Count / Total_Configurations) * LOG(Configuration_Count / Total_Configurations)) AS Information_Entropy FROM (     SELECT m.Country,             sd.Heart_Rate_Sensor, sd.Gps, sd.Accelerometer, sd.Gyroscope, sd.Blood_Oxygen_Sensor, sd.Ecg_Sensor, sd.Temperature_Sensor, sd.Altimeter, sd.Ambient_Light_Sensor,            COUNT(*) AS Configuration_Count,            SUM(COUNT(*)) OVER (PARTITION BY m.Country) AS Total_Configurations     FROM manufacturers m     JOIN watches w ON m.Manufacturer_Id = w.Manufacturer_id     JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id     GROUP BY m.Country, sd.Heart_Rate_Sensor, sd.Gps, sd.Accelerometer, sd.Gyroscope, sd.Blood_Oxygen_Sensor, sd.Ecg_Sensor, sd.Temperature_Sensor, sd.Altimeter, sd.Ambient_Light_Sensor ) AS Configurations GROUP BY Country ORDER BY Information_Entropy ASC LIMIT 3;	watch	2
SELECT m.Country, COUNT(*) AS Quantity FROM watches w JOIN manufacturers m ON w.Manufacturer_Id = m.Manufacturer_Id JOIN sensor_data s ON w.Watch_Id = s.Watch_Id WHERE w.Water_Resistance_Meters > 100 AND s.Gps = 0 AND s.Altimeter = 0 GROUP BY m.Country;	watch	3
WITH SensorData AS (     SELECT          Watch_Id,         Connectivity,         1e9 * 1024 AS Daily_Data_Per_Watch      FROM watches ), GroupedData AS (     SELECT          Connectivity,         SUM(Daily_Data_Per_Watch) AS Total_Daily_Data      FROM SensorData      GROUP BY Connectivity ) SELECT      Connectivity,     Total_Daily_Data,     CASE          WHEN Total_Daily_Data > 1e24 THEN 'Exceeds 1 YB'          ELSE 'Below 1 YB'      END AS Data_Threshold  FROM GroupedData;	watch	4
SELECT Record_Id, User_Id, Calories_Burned, Start_Time, End_Time  FROM usage_records  WHERE Activity_Type = '游泳'  AND Calories_Burned / ((julianday(End_Time) - julianday(Start_Time)) * 24) > 1000  ORDER BY Calories_Burned ASC;	watch	1
WITH ActivityData AS (         SELECT              Activity_Type,             Heart_Rate_Avg_Bpm,             Steps,             (julianday(End_Time) - julianday(Start_Time)) * 86400 AS Duration_Seconds          FROM usage_records     ),     StepFrequency AS (         SELECT              Activity_Type,             Steps / Duration_Seconds AS Step_Frequency          FROM ActivityData     ),     HeartRateFrequency AS (         SELECT              Activity_Type,             Heart_Rate_Avg_Bpm / 60.0 AS Heart_Rate_Frequency          FROM ActivityData     ),     CombinedFrequencies AS (         SELECT              a.Activity_Type,             h.Heart_Rate_Frequency,             s.Step_Frequency          FROM ActivityData a          JOIN HeartRateFrequency h ON a.Activity_Type = h.Activity_Type          JOIN StepFrequency s ON a.Activity_Type = s.Activity_Type     )     SELECT          Activity_Type,         Heart_Rate_Frequency,         Step_Frequency      FROM CombinedFrequencies      WHERE Heart_Rate_Frequency > 2 OR Step_Frequency > 2      ORDER BY Activity_Type;	watch	2
SELECT u.Time_Zone, COUNT(*) AS Anomaly_Count FROM usage_records u WHERE u.Steps > 1000 AND u.Sleep_Duration_Minutes > 0 GROUP BY u.Time_Zone;	watch	3
WITH SensorVectors AS (     SELECT          Sensor_Id,          Heart_Rate_Sensor,          Gps,          Accelerometer,          Gyroscope,          Blood_Oxygen_Sensor,          Ecg_Sensor,          Temperature_Sensor,          Altimeter,          Ambient_Light_Sensor      FROM sensor_data ) SELECT      s1.Sensor_Id AS Sensor1,      s2.Sensor_Id AS Sensor2,      1 - (         SUM(             s1.Heart_Rate_Sensor * s2.Heart_Rate_Sensor +              s1.Gps * s2.Gps +              s1.Accelerometer * s2.Accelerometer +              s1.Gyroscope * s2.Gyroscope +              s1.Blood_Oxygen_Sensor * s2.Blood_Oxygen_Sensor +              s1.Ecg_Sensor * s2.Ecg_Sensor +              s1.Temperature_Sensor * s2.Temperature_Sensor +              s1.Altimeter * s2.Altimeter +              s1.Ambient_Light_Sensor * s2.Ambient_Light_Sensor         ) / (             SQRT(                 SUM(                     s1.Heart_Rate_Sensor * s1.Heart_Rate_Sensor +                      s1.Gps * s1.Gps +                      s1.Accelerometer * s1.Accelerometer +                      s1.Gyroscope * s1.Gyroscope +                      s1.Blood_Oxygen_Sensor * s1.Blood_Oxygen_Sensor +                      s1.Ecg_Sensor * s1.Ecg_Sensor +                      s1.Temperature_Sensor * s1.Temperature_Sensor +                      s1.Altimeter * s1.Altimeter +                      s1.Ambient_Light_Sensor * s1.Ambient_Light_Sensor                 )             ) *              SQRT(                 SUM(                     s2.Heart_Rate_Sensor * s2.Heart_Rate_Sensor +                      s2.Gps * s2.Gps +                      s2.Accelerometer * s2.Accelerometer +                      s2.Gyroscope * s2.Gyroscope +                      s2.Blood_Oxygen_Sensor * s2.Blood_Oxygen_Sensor +                      s2.Ecg_Sensor * s2.Ecg_Sensor +                      s2.Temperature_Sensor * s2.Temperature_Sensor +                      s2.Altimeter * s2.Altimeter +                      s2.Ambient_Light_Sensor * s2.Ambient_Light_Sensor                 )             )         )     ) AS Dissimilarity  FROM SensorVectors s1  CROSS JOIN SensorVectors s2  WHERE s1.Sensor_Id < s2.Sensor_Id  GROUP BY s1.Sensor_Id, s2.Sensor_Id  ORDER BY Dissimilarity DESC  LIMIT 3;	watch	4
SELECT w.Model, w.Release_Date FROM watches w JOIN sensor_data s ON w.Watch_Id = s.Watch_Id WHERE s.Altimeter = 1 AND s.Gps = 0 ORDER BY w.Release_Date DESC;	watch	1
SELECT w.Model, (1e9 * 86400 * 2 / 1e18) AS Data_Volume_EB FROM watches w JOIN sensor_data s ON w.Watch_Id = s.Watch_Id WHERE s.Blood_Oxygen_Sensor = 1 ORDER BY Data_Volume_EB DESC LIMIT 1;	watch	2
SELECT CASE WHEN Water_Resistance_Meters >= 200 THEN '专业潜水' WHEN Water_Resistance_Meters >= 50 THEN '游泳可用' ELSE '不适用' END AS Suitability, CAST(Water_Resistance_Meters / 10 AS INTEGER) * 10 AS Depth_Interval, COUNT(*) AS Watch_Count FROM watches WHERE Water_Resistance_Meters >= 50 AND Watch_Id IN (SELECT DISTINCT Watch_Id FROM usage_records WHERE Activity_Type = '游泳') GROUP BY Suitability, Depth_Interval ORDER BY Depth_Interval;	television	3
WITH Max_Distance AS (     SELECT          User_Id,          (1000 * 60 * 48 * 0.75) / 1000 AS Theoretical_Max_Distance_Km      FROM usage_records      GROUP BY User_Id ),  Exceeded_Range AS (     SELECT          User_Id,          Start_Time,          End_Time      FROM usage_records      WHERE Activity_Type = '跑步'      AND Steps / ((julianday(End_Time) - julianday(Start_Time)) * 24 * 60 + 1) > 1000      AND EXISTS (         SELECT 1          FROM sensor_data s          WHERE s.Watch_Id = usage_records.Watch_Id          AND ABS(s.Accelerometer) > 16     ) )  SELECT      m.User_Id,      m.Theoretical_Max_Distance_Km,      e.Start_Time,      e.End_Time  FROM Max_Distance m  LEFT JOIN Exceeded_Range e ON m.User_Id = e.User_Id;	television	4
SELECT Operating_System, (3.7 * 0.1 * Battery_Life_Days * 24 * 3600) / (Weight_Grams / 1000) AS Efficiency_Joules_Per_Gram_Per_Day FROM watches ORDER BY Efficiency_Joules_Per_Gram_Per_Day DESC LIMIT 5;	television	1
WITH Ratio_Calculation AS (     SELECT Country, CAST(Employees AS REAL) / NULLIF(Market_Share_Percent, 0) AS Ratio      FROM manufacturers      WHERE Market_Share_Percent > 0 ),  Ranked_Countries AS (     SELECT Country, AVG(Ratio) AS Avg_Ratio,             ROW_NUMBER() OVER (ORDER BY AVG(Ratio) DESC) AS Rank      FROM Ratio_Calculation      GROUP BY Country )  SELECT Country, Avg_Ratio  FROM Ranked_Countries  WHERE Rank <= 3;	television	2
SELECT CAST(Screen_Size_Inches * 2 AS INTEGER) / 2.0 AS Screen_Size_Interval, COUNT(*) AS Watch_Count FROM watches w JOIN sensor_data s ON w.Watch_Id = s.Watch_Id WHERE s.Temperature_Sensor = 1 AND w.Water_Resistance_Meters > 100 GROUP BY Screen_Size_Interval ORDER BY Screen_Size_Interval DESC;	television	3
SELECT Weight_Grams, MAX(Water_Resistance_Meters * (Weight_Grams / 1000.0) / (1025.0 * 9.8)) AS Max_Floating_Height FROM watches WHERE Water_Resistance_Meters >= 10000 GROUP BY Weight_Grams;	television	4
SELECT Country, (Profit_Usd * 0.1 * 3600000) / (Employees * 8760) * 0.3 AS Productivity_Efficiency FROM manufacturers ORDER BY Productivity_Efficiency DESC LIMIT 5;	television	1
WITH Composite_Values AS (   SELECT      Country,      Manufacturer_Name,      Market_Share_Percent * CASE WHEN Founded_Year < 2024 THEN LN(2024 - Founded_Year) ELSE 0 END AS Composite_Value    FROM manufacturers ),  Ranked_Records AS (   SELECT      Country,      Manufacturer_Name,      Composite_Value,      ROW_NUMBER() OVER (PARTITION BY Country ORDER BY Composite_Value DESC) AS Rank    FROM Composite_Values )  SELECT Country, Manufacturer_Name, Composite_Value  FROM Ranked_Records  WHERE Rank <= 3;	television	2
SELECT Country, COUNT(*) AS Manufacturer_Count FROM manufacturers WHERE Employees < 100 AND Market_Share_Percent > 5 GROUP BY Country ORDER BY Manufacturer_Count DESC;	watch	3
WITH EmployeeValue AS (   SELECT      Country,     Manufacturer_Name,     Profit_Usd,     Employees,     Profit_Usd * 1.0 / Employees AS Value_Per_Employee_Usd,     (Profit_Usd * 1.0 / Employees) * 1.5e-10 AS Value_Per_Employee_Joules    FROM manufacturers    WHERE Profit_Usd = 1e14 ), FilteredValues AS (   SELECT      Country,     Manufacturer_Name,     Value_Per_Employee_Usd,     Value_Per_Employee_Joules    FROM EmployeeValue    WHERE Value_Per_Employee_Joules > 1.5e-10 ) SELECT    Country,   Manufacturer_Name,   Value_Per_Employee_Usd,   Value_Per_Employee_Joules  FROM (   SELECT      Country,     Manufacturer_Name,     Value_Per_Employee_Usd,     Value_Per_Employee_Joules,     ROW_NUMBER() OVER (PARTITION BY Country ORDER BY Value_Per_Employee_Usd DESC) AS rn    FROM FilteredValues ) AS RankedValues  WHERE rn = 1;	watch	4
SELECT      u.Activity_Type,     SUM(0.5 * (w.Weight_Grams / 1000.0) * POWER((12.0 * 1000.0 / 3600.0), 2)) AS Energy_Consumption_Joules FROM      usage_records u JOIN      watches w ON u.Watch_Id = w.Watch_Id GROUP BY      u.Activity_Type ORDER BY      Energy_Consumption_Joules DESC LIMIT 3;	watch	1
SELECT (CASE WHEN sd.Heart_Rate_Sensor = 1 THEN 1 ELSE 0 END * 1 +          CASE WHEN sd.Gps = 1 THEN 1 ELSE 0 END * 2 +          CASE WHEN sd.Accelerometer = 1 THEN 1 ELSE 0 END * 4 +          CASE WHEN sd.Gyroscope = 1 THEN 1 ELSE 0 END * 8 +          CASE WHEN sd.Blood_Oxygen_Sensor = 1 THEN 1 ELSE 0 END * 16 +          CASE WHEN sd.Ecg_Sensor = 1 THEN 1 ELSE 0 END * 32 +          CASE WHEN sd.Temperature_Sensor = 1 THEN 1 ELSE 0 END * 64 +          CASE WHEN sd.Altimeter = 1 THEN 1 ELSE 0 END * 128 +          CASE WHEN sd.Ambient_Light_Sensor = 1 THEN 1 ELSE 0 END * 256) AS Sensor_Combination,        AVG(ur.Battery_Consumed_Percent) AS Avg_Battery_Consumed_Percent FROM sensor_data sd JOIN usage_records ur ON sd.Watch_Id = ur.Watch_Id GROUP BY Sensor_Combination ORDER BY Avg_Battery_Consumed_Percent DESC LIMIT 10;	watch	2
WITH FilteredWatches AS (     SELECT w.Watch_Id, w.Model, w.Price_Usd, w.Is_Smartwatch      FROM watches w      JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id      WHERE sd.Altimeter = 1 AND sd.Temperature_Sensor = 1 AND w.Is_Smartwatch = 1 ), PriceGroups AS (     SELECT Model,            CASE                 WHEN Price_Usd < 200 THEN '< $200'                 WHEN Price_Usd BETWEEN 200 AND 500 THEN '$200-$500'                 WHEN Price_Usd > 500 THEN '> $500'             END AS Price_Group      FROM FilteredWatches ) SELECT Price_Group, COUNT(*) AS Watch_Count  FROM PriceGroups  GROUP BY Price_Group  ORDER BY Price_Group;	watch	3
WITH FilteredWatches AS (     SELECT ur.User_Id, w.Watch_Id, w.Model, w.Battery_Life_Days, sd.Gps      FROM watches w      JOIN usage_records ur ON w.Watch_Id = ur.Watch_Id      JOIN sensor_data sd ON w.Watch_Id = sd.Watch_Id      WHERE sd.Gps = 1 ), BatteryConsumption AS (     SELECT User_Id, Watch_Id, Model, Battery_Life_Days,             CASE                 WHEN Battery_Life_Days > 0 THEN 500.0 / (10000.0 / Battery_Life_Days)                ELSE NULL             END AS Max_Charge_Cycles      FROM FilteredWatches ), MaxChargeCycles AS (     SELECT User_Id, MAX(Max_Charge_Cycles) AS Max_Charge_Cycles      FROM BatteryConsumption      GROUP BY User_Id )  SELECT User_Id, Max_Charge_Cycles  FROM MaxChargeCycles  ORDER BY Max_Charge_Cycles DESC;	watch	4
SELECT Activity_Type, 0.5 * 1000 * POW(2.5, 2) * 0.5 * 0.1 AS Power_Watts FROM usage_records JOIN watches ON usage_records.Watch_Id = watches.Watch_Id WHERE Activity_Type = 'Swimming' GROUP BY Activity_Type LIMIT 5;	watch	1
WITH ActivityBatteryStats AS (     SELECT          w.Model,         u.Activity_Type,         AVG(u.Battery_Consumed_Percent) AS Avg_Battery,         AVG(u.Battery_Consumed_Percent * u.Battery_Consumed_Percent) AS Avg_Squared_Battery,         COUNT(*) AS Count_Records     FROM usage_records u     JOIN watches w ON u.Watch_Id = w.Watch_Id     GROUP BY w.Model, u.Activity_Type     HAVING Count_Records > 1 ), CovarianceMatrix AS (     SELECT          a1.Model AS Model_X,         a1.Activity_Type AS Activity_X,         a2.Model AS Model_Y,         a2.Activity_Type AS Activity_Y,         (a1.Avg_Squared_Battery - a1.Avg_Battery * a2.Avg_Battery) AS Covariance     FROM ActivityBatteryStats a1     CROSS JOIN ActivityBatteryStats a2     WHERE a1.Model = a2.Model ) SELECT      Model_X,     Activity_X,     Model_Y,     Activity_Y,     ABS(Covariance) AS Absolute_Covariance FROM CovarianceMatrix ORDER BY Absolute_Covariance DESC LIMIT 3;	watch	2
SELECT      CASE          WHEN Battery_Life_Days BETWEEN 7 AND 14 THEN '7-14 days'         WHEN Battery_Life_Days BETWEEN 15 AND 30 THEN '15-30 days'         WHEN Battery_Life_Days > 30 THEN '>30 days'     END AS Battery_Life_Interval,     COUNT(*) AS Count FROM watches w JOIN sensor_data s ON w.Watch_Id = s.Watch_Id WHERE s.Gps = 1 AND w.Battery_Life_Days >= 7 GROUP BY Battery_Life_Interval;	watch	3
WITH FrequencyRequirement AS (     SELECT (340 / (9.8 * 16)) * 1000 AS Required_Frequency_Hz ),  SupportedWatches AS (     SELECT w.Model, w.Connectivity, s.Accelerometer      FROM watches w      JOIN sensor_data s ON w.Watch_Id = s.Watch_Id      WHERE s.Accelerometer = 1 )  SELECT Connectivity, MAX(Model) AS Model  FROM SupportedWatches  WHERE EXISTS (SELECT 1 FROM FrequencyRequirement)  GROUP BY Connectivity;	television	4
SELECT Manufacturer_Name,         Country,         (Battery_Life_Days * 24 * 3600 * (SELECT AVG(Battery_Consumed_Percent) FROM usage_records WHERE usage_records.Watch_Id = watches.Watch_Id) / 100) / Profit_Usd AS Energy_Per_Profit FROM manufacturers JOIN watches ON manufacturers.Manufacturer_Id = watches.Manufacturer_Id GROUP BY manufacturers.Manufacturer_Id ORDER BY Energy_Per_Profit DESC LIMIT 3;	watch	1
WITH ranked_manufacturers AS (     SELECT          Manufacturer_Id,         Manufacturer_Name,         (Market_Share_Percent * SQRT(MAX(0, 2024 - Founded_Year)) / Employees) AS Market_Penetration_Index     FROM manufacturers     WHERE Founded_Year < 2024 ) SELECT      Manufacturer_Id,     Manufacturer_Name,     Market_Penetration_Index FROM ranked_manufacturers ORDER BY Market_Penetration_Index DESC LIMIT 5;	watch	2
SELECT Country, COUNT(*) AS Smartwatch_Count FROM manufacturers JOIN watches ON manufacturers.Manufacturer_Id = watches.Manufacturer_id WHERE (2024 - Founded_Year) > 30 AND Employees < 500 AND Is_Smartwatch = 1 GROUP BY Country;	watch	3
WITH GoldWeight AS (     SELECT          Country,         Manufacturer_Name,         Profit_Usd,         Employees,         Profit_Usd/(Employees*60000.0) AS Gold_Per_Employee_Kg      FROM manufacturers ), FilteredGoldWeight AS (     SELECT          Country,         Manufacturer_Name,         Gold_Per_Employee_Kg      FROM GoldWeight      WHERE Gold_Per_Employee_Kg > 1000000000 ), MaxGoldWeight AS (     SELECT          Country,         MAX(Gold_Per_Employee_Kg) AS Max_Gold_Per_Employee_Kg      FROM FilteredGoldWeight      GROUP BY Country )  SELECT      Country,     Max_Gold_Per_Employee_Kg  FROM MaxGoldWeight  ORDER BY Max_Gold_Per_Employee_Kg DESC;	watch	4
SELECT power_rating * (heating_time / 60.0) AS energy_consumed FROM water_heater_info WHERE power_rating = 3 AND heating_time = 30;	water_heater	1
SELECT wi.capacity * 1 * 4.18 * (wu.final_temperature - wu.initial_temperature) AS heat_required FROM water_heater_info wi JOIN water_heater_usage wu ON wi.id = wu.heater_id WHERE wi.capacity = 50 AND wu.initial_temperature = 10 AND wu.final_temperature = 60;	water_heater	2
SELECT wi.energy_efficiency_rating, AVG(wu.energy_consumed) AS avg_energy_consumed FROM water_heater_info wi JOIN water_heater_usage wu ON wi.id = wu.heater_id WHERE wi.energy_efficiency_rating IN (1, 3) GROUP BY wi.energy_efficiency_rating ORDER BY avg_energy_consumed ASC;	water_heater	3
SELECT power_rating * (heating_time / 60.0) AS energy_consumed FROM water_heater_info WHERE capacity = 1000 AND power_rating = 100 AND heating_time = 1;	water_heater	4
SELECT (wu.water_used * 1 * 4.18 * (wu.final_temperature - wu.initial_temperature)) / (wu.energy_consumed * 3600) * 100 AS efficiency FROM water_heater_usage wu WHERE wu.energy_consumed = 5 AND wu.temperature_set = 50 AND wu.initial_temperature = 10 AND wu.final_temperature = 50;	water_heater	1
SELECT wu.energy_consumed / wi.capacity AS energy_per_liter FROM water_heater_info wi JOIN water_heater_usage wu ON wi.id = wu.heater_id WHERE wi.capacity = 100 AND wu.energy_consumed = 3;	water_heater	2
SELECT wu.id, wu.ambient_temperature, wu.initial_temperature, wu.final_temperature, (wi.capacity * 1 * 4.18 * (wu.final_temperature - wu.initial_temperature)) / (wu.energy_consumed * 3600) * 100 AS efficiency FROM water_heater_info wi JOIN water_heater_usage wu ON wi.id = wu.heater_id WHERE (wu.ambient_temperature = 5 AND wu.initial_temperature = 5 AND wu.final_temperature = 45) OR (wu.ambient_temperature = 25 AND wu.initial_temperature = 25 AND wu.final_temperature = 45);	water_heater	3
SELECT energy_consumed / water_used AS energy_per_liter FROM water_heater_usage WHERE water_used = 1000000 AND energy_consumed = 1000000;	water_heater	4
SELECT peak_energy_value / low_energy_value AS energy_fluctuation_rate FROM energy_consumption_analysis WHERE total_energy_consumed = 500 AND peak_energy_value = 10 AND low_energy_value = 1;	water_heater	1
SELECT peak_energy_value / average_daily_energy AS peak_to_daily_ratio, low_energy_value / average_daily_energy AS low_to_daily_ratio FROM energy_consumption_analysis WHERE total_energy_consumed = 300 AND average_daily_energy = 10 AND peak_energy_value = 15 AND low_energy_value = 5;	water_heater	2
SELECT wi.brand, wi.model, eca.peak_energy_value, eca.low_energy_value, (eca.peak_energy_value - eca.low_energy_value) AS energy_fluctuation FROM energy_consumption_analysis eca JOIN water_heater_info wi ON eca.heater_id = wi.id WHERE (eca.peak_energy_value = 20 AND eca.low_energy_value = 2) OR (eca.peak_energy_value = 15 AND eca.low_energy_value = 5) ORDER BY energy_fluctuation DESC;	water_heater	3
SELECT peak_energy_value / low_energy_value AS energy_fluctuation_rate FROM energy_consumption_analysis WHERE total_energy_consumed = 1000000 AND peak_energy_value = 10000 AND low_energy_value = 0.1;	water_heater	4
SELECT energy_cost - (total_energy_consumed * 0.6) AS cost_difference FROM energy_consumption_analysis WHERE total_energy_consumed = 500 AND energy_cost = 300;	water_heater	1
SELECT (peak_energy_value / low_energy_value) AS energy_fluctuation_rate, (energy_cost / 30) AS daily_energy_cost FROM energy_consumption_analysis WHERE total_energy_consumed = 400 AND energy_cost = 240 AND peak_energy_value = 20 AND low_energy_value = 5;	water_heater	2
SELECT heater_id, energy_cost, energy_saving_tips, (peak_energy_value / low_energy_value) AS energy_fluctuation_rate, (energy_cost / 30) AS daily_energy_cost FROM energy_consumption_analysis WHERE energy_cost IN (200, 250);	water_heater	3
SELECT (total_energy_consumed * 0.5) AS theoretical_energy_cost, (energy_cost - (total_energy_consumed * 0.5)) AS cost_difference, (peak_energy_value / low_energy_value) AS energy_fluctuation_rate FROM energy_consumption_analysis WHERE total_energy_consumed = 1000000 AND energy_cost = 1000000 AND peak_energy_value = 50000 AND low_energy_value = 0.1;	water_heater	4
SELECT (water_used * 1 * 4.18 * (final_temperature - initial_temperature)) / (strftime('%s', end_time) - strftime('%s', start_time)) AS heating_power FROM water_heater_usage WHERE initial_temperature = 10 AND final_temperature = 50;	water_heater	1
SELECT ((500 * 0.5) / ((wu.water_used * 1 * 4.18 * (wu.final_temperature - wu.initial_temperature)) / (strftime('%s', wu.end_time) - strftime('%s', wu.start_time)))) * 100 AS solar_heating_efficiency FROM water_heater_usage wu JOIN environment_data ed ON wu.heater_id = ed.heater_id WHERE ed.ambient_temperature = 20 AND wu.initial_temperature = 15 AND wu.final_temperature = 45 AND ed.solar_radiation = 500;	water_heater	2
SELECT heater_id, usage_date, initial_temperature, final_temperature, ambient_temperature, energy_consumed FROM water_heater_usage WHERE initial_temperature = 5 AND final_temperature = 45 AND ambient_temperature = 5 UNION SELECT heater_id, usage_date, initial_temperature, final_temperature, ambient_temperature, energy_consumed FROM water_heater_usage WHERE initial_temperature = 25 AND final_temperature = 45 AND ambient_temperature = 25;	water_heater	3
SELECT heater_id, water_inlet_temperature, water_outlet_temperature, 1000000 AS water_flow_rate, solar_radiation, (1000000 * 4.18 * (water_outlet_temperature - water_inlet_temperature)) / 60 AS heating_power, (solar_radiation * 1.0) / ((1000000 * 4.18 * (water_outlet_temperature - water_inlet_temperature)) / 60) * 100 AS solar_heating_efficiency FROM environment_data WHERE water_inlet_temperature = -273 AND water_outlet_temperature = 1000 AND solar_radiation = 1000000;	water_heater	4
SELECT model, (50 * 4.18 * (60 - 20)) / 3600 AS energy_required_kWh FROM water_heater_info ORDER BY energy_required_kWh ASC LIMIT 5;	water_heater	1
SELECT id AS heater_id, brand, model, ((50 * 4.18 * (60 - 20)) * 2 * 365 * 0.5) / 3600000 AS annual_energy_cost FROM water_heater_info ORDER BY annual_energy_cost ASC;	water_heater	2
WITH EnergyCost AS (   SELECT      id AS heater_id,      brand,      model,      energy_efficiency_rating,      ((50 * 4.18 * (60 - 20)) * 2 * 365 * 0.5) / 3600000 AS annual_energy_cost    FROM water_heater_info ),  MinMaxEfficiency AS (   SELECT      MIN(energy_efficiency_rating) AS min_efficiency,      MAX(energy_efficiency_rating) AS max_efficiency    FROM water_heater_info ),  HighEfficiency AS (   SELECT *    FROM EnergyCost    WHERE energy_efficiency_rating = (SELECT max_efficiency FROM MinMaxEfficiency)    LIMIT 1 ),  LowEfficiency AS (   SELECT *    FROM EnergyCost    WHERE energy_efficiency_rating = (SELECT min_efficiency FROM MinMaxEfficiency)    LIMIT 1 )  SELECT    h.heater_id AS high_efficiency_heater_id,    h.brand AS high_efficiency_brand,    h.model AS high_efficiency_model,    l.heater_id AS low_efficiency_heater_id,    l.brand AS low_efficiency_brand,    l.model AS low_efficiency_model,    (l.annual_energy_cost - h.annual_energy_cost) AS annual_energy_savings  FROM HighEfficiency h, LowEfficiency l;	water_heater	3
WITH EnergyCalculation AS (     SELECT id AS heater_id, brand, model, capacity, power_rating, (1000 * 4.18 * (100 - 0)) / 3600 AS energy_required_kWh      FROM water_heater_info      WHERE capacity = 1000 AND power_rating = 1000 ),  TopEnergyConsumers AS (     SELECT id AS heater_id, brand, model, capacity, power_rating, (capacity * 4.18 * (100 - 0)) / 3600 AS energy_required_kWh      FROM water_heater_info      ORDER BY energy_required_kWh DESC      LIMIT 3 )  SELECT * FROM EnergyCalculation  UNION ALL  SELECT * FROM TopEnergyConsumers;	water_heater	4
SELECT id AS usage_id, heater_id, usage_date, start_time, end_time, water_used, initial_temperature, temperature_set, (water_used * 4.18 * (temperature_set - initial_temperature)) / 3600 AS energy_required_kWh FROM water_heater_usage ORDER BY energy_required_kWh DESC LIMIT 5;	water_heater	1
SELECT id AS usage_id, heater_id, usage_date, start_time, end_time, water_used, energy_consumed, (energy_consumed / water_used) AS energy_efficiency FROM water_heater_usage ORDER BY energy_efficiency ASC LIMIT 10;	water_heater	2
SELECT id AS usage_id, heater_id, usage_date, start_time, end_time, initial_temperature, ambient_temperature, (initial_temperature - ambient_temperature) AS temperature_difference FROM water_heater_usage ORDER BY temperature_difference DESC LIMIT 5;	water_heater	3
SELECT id AS usage_id, heater_id, usage_date, start_time, end_time, water_used, initial_temperature, temperature_set, (water_used * 4.18 * (temperature_set - initial_temperature)) / 3600 AS energy_required_kWh FROM water_heater_usage ORDER BY energy_required_kWh DESC LIMIT 3;	water_heater	4
SELECT heater_id, analysis_date, total_energy_consumed, average_daily_energy, (total_energy_consumed / average_daily_energy) AS energy_ratio FROM energy_consumption_analysis ORDER BY energy_ratio DESC LIMIT 5;	water_heater	1
SELECT heater_id, analysis_date, total_energy_consumed, energy_cost, (energy_cost / total_energy_consumed) AS energy_cost_efficiency FROM energy_consumption_analysis ORDER BY energy_cost_efficiency ASC LIMIT 10;	water_heater	2
SELECT heater_id, analysis_date, peak_energy_value, low_energy_value, (peak_energy_value - low_energy_value) AS energy_difference FROM energy_consumption_analysis ORDER BY energy_difference DESC LIMIT 5;	water_heater	3
SELECT heater_id, analysis_date, total_energy_consumed, (total_energy_consumed * 100 * 0.5) AS hypothetical_energy_cost FROM energy_consumption_analysis ORDER BY hypothetical_energy_cost DESC LIMIT 3;	water_heater	4
SELECT heater_id, record_date, water_inlet_temperature, ambient_temperature, (water_inlet_temperature - ambient_temperature) AS temperature_difference  FROM environment_data  ORDER BY temperature_difference DESC  LIMIT 5;	water_heater	1
SELECT heater_id, record_date, water_pressure, air_pressure, (water_pressure / air_pressure) AS pressure_ratio FROM environment_data ORDER BY pressure_ratio ASC LIMIT 10;	water_heater	2
SELECT heater_id, record_date, solar_radiation, wind_speed, (solar_radiation * wind_speed) AS energy_acquisition_index FROM environment_data ORDER BY energy_acquisition_index DESC LIMIT 5;	water_heater	3
SELECT e.heater_id, (e.solar_radiation * 1000 * e.wind_speed) AS energy_acquisition_index  FROM environment_data e  ORDER BY energy_acquisition_index DESC  LIMIT 3;	water_heater	4
SELECT DISTINCT whi.model FROM water_heater_info whi WHERE whi.capacity > 50 AND whi.power_rating < 2 AND whi.id NOT IN (SELECT DISTINCT whu.heater_id FROM water_heater_usage whu WHERE whu.energy_consumed > 10);	water_heater	1
SELECT DISTINCT whi.model FROM water_heater_info whi WHERE whi.weight < 20 AND whi.price < 2000 AND whi.id NOT IN (SELECT DISTINCT eca.heater_id FROM energy_consumption_analysis eca WHERE eca.average_daily_energy > 5);	water_heater	2
SELECT DISTINCT whi.model  FROM water_heater_info whi  WHERE whi.manufacture_date > '2020-01-01'  AND (     CAST(SUBSTR(whi.dimensions, 1, INSTR(whi.dimensions, 'x') - 1) AS REAL) < 500      AND CAST(SUBSTR(whi.dimensions, INSTR(whi.dimensions, 'x') + 1, INSTR(SUBSTR(whi.dimensions, INSTR(whi.dimensions, 'x') + 1), 'x') - 1) AS REAL) < 500      AND CAST(SUBSTR(whi.dimensions, INSTR(whi.dimensions, 'x', -1) + 1) AS REAL) < 500 )  AND whi.id NOT IN (SELECT DISTINCT ed.heater_id FROM environment_data ed WHERE ed.ambient_temperature > 40);	water_heater	3
SELECT DISTINCT whi.model FROM water_heater_info whi WHERE (whi.capacity * 10) > 500 AND whi.power_rating < 5 AND whi.id NOT IN (SELECT DISTINCT whu.heater_id FROM water_heater_usage whu WHERE whu.energy_consumed > 100);	water_heater	4
SELECT whu.* FROM water_heater_usage whu WHERE whu.water_used > 100 AND whu.energy_consumed < 5 AND whu.heater_id NOT IN (SELECT DISTINCT eca.heater_id FROM energy_consumption_analysis eca WHERE eca.average_daily_energy > 10);	water_heater	1
SELECT whu.* FROM water_heater_usage whu WHERE whu.initial_temperature < 10 AND whu.final_temperature > 60 AND whu.heater_id NOT IN (SELECT DISTINCT ed.heater_id FROM environment_data ed WHERE ed.ambient_temperature < 0);	water_heater	2
SELECT whu.* FROM water_heater_usage whu WHERE whu.water_used > 50 AND whu.energy_consumed < 3 AND whu.heater_id NOT IN (SELECT DISTINCT whi.id FROM water_heater_info whi WHERE whi.capacity < 30);	water_heater	3
SELECT whu.* FROM water_heater_usage whu WHERE (whu.water_used * 10) > 500 AND whu.energy_consumed < 50 AND whu.heater_id NOT IN (SELECT DISTINCT eca.heater_id FROM energy_consumption_analysis eca WHERE eca.average_daily_energy > 100);	water_heater	4
SELECT DISTINCT eca.heater_id  FROM energy_consumption_analysis eca  WHERE eca.total_energy_consumed > 100  AND eca.average_daily_energy < 5  AND eca.heater_id NOT IN (SELECT DISTINCT whu.heater_id FROM water_heater_usage whu WHERE whu.water_used > 200);	water_heater	1
SELECT DISTINCT eca.heater_id FROM energy_consumption_analysis eca WHERE eca.peak_energy_value > 20 AND eca.low_energy_value < 2 AND eca.heater_id NOT IN (SELECT DISTINCT ed.heater_id FROM environment_data ed WHERE ed.ambient_temperature > 40);	water_heater	2
SELECT DISTINCT eca.heater_id FROM energy_consumption_analysis eca WHERE eca.energy_cost > 500 AND eca.total_energy_consumed < 1000 AND eca.heater_id NOT IN (SELECT DISTINCT whi.id FROM water_heater_info whi WHERE whi.warranty_period < 12);	water_heater	3
SELECT DISTINCT eca.heater_id FROM energy_consumption_analysis eca WHERE (eca.total_energy_consumed * 100) > 10000 AND eca.average_daily_energy < 500 AND eca.heater_id NOT IN (SELECT DISTINCT whu.heater_id FROM water_heater_usage whu WHERE whu.water_used > 2000);	water_heater	4
SELECT DISTINCT ed.* FROM environment_data ed WHERE ed.ambient_temperature > 30 AND ed.solar_radiation > 500 AND ed.heater_id NOT IN (SELECT DISTINCT whu.heater_id FROM water_heater_usage whu WHERE whu.energy_consumed > 10);	water_heater	1
SELECT DISTINCT ed.* FROM environment_data ed WHERE ed.water_pressure > 3 AND ed.wind_speed > 10 AND ed.heater_id NOT IN (SELECT DISTINCT eca.heater_id FROM energy_consumption_analysis eca WHERE eca.average_daily_energy > 5);	water_heater	2
SELECT DISTINCT ed.* FROM environment_data ed WHERE ed.humidity > 80 AND ed.water_inlet_temperature < 10 AND ed.heater_id NOT IN (SELECT DISTINCT whi.id FROM water_heater_info whi WHERE whi.capacity < 50);	water_heater	3
SELECT DISTINCT ed.* FROM environment_data ed WHERE ed.solar_radiation > 500 AND ed.wind_speed > 50 AND ed.heater_id NOT IN (SELECT DISTINCT whu.heater_id FROM water_heater_usage whu WHERE whu.energy_consumed > 100);	water_heater	4
SELECT whi.model, whu.water_used, whu.initial_temperature, whu.temperature_set, (whu.water_used * 4186 * (whu.temperature_set - whu.initial_temperature)) / 3600000 AS required_energy_kWh, (whi.power_rating * (whi.heating_time / 60)) AS actual_energy_kWh FROM water_heater_info whi JOIN water_heater_usage whu ON whi.id = whu.heater_id WHERE whi.brand = 'A品牌';	water_heater	1
SELECT whi.brand, SUM(eca.total_energy_consumed) AS total_energy_kWh, SUM(eca.total_energy_consumed) / COUNT(DISTINCT eca.analysis_date) AS average_daily_energy_kWh, SUM(eca.total_energy_consumed) * 0.5 AS total_energy_cost FROM water_heater_info whi JOIN energy_consumption_analysis eca ON whi.id = eca.heater_id GROUP BY whi.brand;	water_heater	2
SELECT whi.model, (3 * 50 * 30) AS monthly_water_usage_liters, (3 * 50 * 30 * (SUM(whu.energy_consumed) / SUM(whu.water_used))) AS monthly_energy_consumption_kWh FROM water_heater_info whi JOIN water_heater_usage whu ON whi.id = whu.heater_id WHERE whi.capacity >= 50 GROUP BY whi.model;	water_heater	3
SELECT 10000 AS capacity_liters, 1000 AS power_rating_kW, -100 AS ambient_temperature_C, -50 AS water_inlet_temperature_C, 100 AS temperature_set_C, (10000 * 4186 * (100 - (-50))) / 3600000 AS required_energy_kWh, ((10000 * 4186 * (100 - (-50))) / 3600000) / 1000 AS heating_time_hours;	water_heater	4
SELECT whu.id AS usage_id, whu.heater_id, whu.water_used, whu.initial_temperature, whu.final_temperature, (whu.water_used * 4186 * (whu.final_temperature - whu.initial_temperature)) / 3600000 AS calculated_energy_kWh, whu.energy_consumed AS recorded_energy_kWh, ABS((whu.water_used * 4186 * (whu.final_temperature - whu.initial_temperature)) / 3600000 - whu.energy_consumed) AS energy_difference_kWh FROM water_heater_usage whu;	water_heater	1
SELECT ed.ambient_temperature, AVG(whu.energy_consumed) AS average_energy_consumed  FROM water_heater_usage whu  JOIN environment_data ed ON whu.heater_id = ed.heater_id AND whu.usage_date = ed.record_date  JOIN water_heater_info whi ON whu.heater_id = whi.id  WHERE whi.brand = '某品牌'  GROUP BY ed.ambient_temperature  ORDER BY ed.ambient_temperature;	water_heater	2
SELECT strftime('%H', start_time) AS hour_of_day, COUNT(*) AS usage_count, SUM(water_used) AS total_water_used FROM water_heater_usage GROUP BY strftime('%H', start_time) ORDER BY usage_count DESC;	water_heater	3
WITH heater_data AS (         SELECT              whi.id AS heater_id,              whi.power_rating,              whu.temperature_set,              whu.initial_temperature,              whu.ambient_temperature,              whu.water_used          FROM water_heater_info whi          JOIN water_heater_usage whu ON whi.id = whu.heater_id          WHERE whu.temperature_set = 1000          AND whu.initial_temperature = -200          AND whu.ambient_temperature = -273      )      SELECT          heater_id,          power_rating,          temperature_set,          initial_temperature,          ambient_temperature,          water_used,          (water_used * 4186 * (temperature_set - initial_temperature)) / (power_rating * 3600) AS heating_time_hours,          (water_used * 4186 * (temperature_set - initial_temperature)) / 3600 AS energy_consumed_kWh      FROM heater_data;	water_heater	4
SELECT heater_id, total_energy_consumed, peak_energy_time, low_energy_time FROM energy_consumption_analysis WHERE analysis_date BETWEEN '开始日期' AND '结束日期';	water_heater	1
WITH energy_comparison AS (   SELECT whi.energy_efficiency_rating, AVG(eca.average_daily_energy) AS avg_daily_energy    FROM water_heater_info whi    JOIN energy_consumption_analysis eca ON whi.id = eca.heater_id    WHERE whi.brand = '海尔'    GROUP BY whi.energy_efficiency_rating )  SELECT a.energy_efficiency_rating AS high_efficiency_rating,         b.energy_efficiency_rating AS low_efficiency_rating,         (b.avg_daily_energy - a.avg_daily_energy) AS energy_saving,         (b.avg_daily_energy - a.avg_daily_energy) * 0.5 * 365 AS cost_saving  FROM energy_comparison a, energy_comparison b  WHERE a.energy_efficiency_rating > b.energy_efficiency_rating;	water_heater	2
WITH seasonal_energy AS (   SELECT      CASE        WHEN strftime('%m', analysis_date) IN ('12', '01', '02') THEN '冬季'        WHEN strftime('%m', analysis_date) IN ('06', '07', '08') THEN '夏季'        ELSE '其他季节'      END AS season,      SUM(total_energy_consumed) AS total_energy    FROM energy_consumption_analysis    GROUP BY      CASE        WHEN strftime('%m', analysis_date) IN ('12', '01', '02') THEN '冬季'        WHEN strftime('%m', analysis_date) IN ('06', '07', '08') THEN '夏季'        ELSE '其他季节'      END )  SELECT    season,    total_energy,    CASE      WHEN season = '冬季' THEN '建议增加保温措施，减少热量散失。'      WHEN season = '夏季' THEN '建议减少热水使用频率，利用环境温度加热。'      ELSE '无特定建议。'    END AS energy_saving_tips  FROM seasonal_energy  WHERE season IN ('冬季', '夏季');	water_heater	3
WITH extreme_energy AS ( SELECT 10000 AS daily_energy, 50000 AS peak_energy, 1000 AS low_energy, 0.5 AS electricity_price ) SELECT daily_energy * 365 AS annual_energy_consumption, daily_energy * 365 * electricity_price AS annual_energy_cost, CASE WHEN daily_energy > 1000 OR peak_energy > 50000 OR low_energy < 500 THEN '数据异常：能耗值超出正常范围，需检查设备或数据记录。' ELSE '数据正常。' END AS data_analysis FROM extreme_energy;	water_heater	4
WITH heater_efficiency AS (     SELECT          ed.heater_id,          ed.ambient_temperature,          ed.humidity,          ed.water_pressure,          ed.solar_radiation,          whi.power_rating,          whu.energy_consumed,          whi.heating_time,          (whu.energy_consumed * 3600) AS Q_used,          (whi.power_rating * whi.heating_time * 60) AS Q_input      FROM          environment_data ed      JOIN          water_heater_usage whu ON ed.heater_id = whu.heater_id      JOIN          water_heater_info whi ON whu.heater_id = whi.id      WHERE          ed.record_date BETWEEN '2023-01-01' AND '2023-12-31' ) SELECT      heater_id,      ambient_temperature,      humidity,      water_pressure,      solar_radiation,      (Q_used / Q_input) * 100 AS thermal_efficiency  FROM      heater_efficiency;	water_heater	1
WITH environmental_energy AS (     SELECT ed.ambient_temperature, ed.humidity, ed.water_pressure, eca.total_energy_consumed      FROM environment_data ed      JOIN energy_consumption_analysis eca ON ed.heater_id = eca.heater_id      JOIN water_heater_info whi ON ed.heater_id = whi.id      WHERE whi.brand = '海尔' ) SELECT ambient_temperature, humidity, water_pressure, AVG(total_energy_consumed) AS avg_energy_consumed  FROM environmental_energy  GROUP BY ambient_temperature, humidity, water_pressure;	water_heater	2
WITH seasonal_data AS (   SELECT      CASE        WHEN strftime('%m', record_date) IN ('12', '01', '02') THEN '冬季'       WHEN strftime('%m', record_date) IN ('06', '07', '08') THEN '夏季'       ELSE '其他季节'     END AS season,     ambient_temperature,     humidity,     solar_radiation   FROM environment_data ) SELECT    season,   AVG(ambient_temperature) AS avg_temperature,   AVG(humidity) AS avg_humidity,   AVG(solar_radiation) AS avg_solar_radiation,   CASE      WHEN season = '冬季' THEN '建议增加保温措施，定期检查加热元件，防止结冰。'     WHEN season = '夏季' THEN '建议增加散热措施，定期清理灰尘，防止过热。'     ELSE '无特定建议。'   END AS maintenance_tips FROM seasonal_data GROUP BY season;	water_heater	3
WITH extreme_conditions AS (   SELECT      eca.heater_id,      eca.total_energy_consumed,      whi.power_rating,      whi.heating_time,      (eca.total_energy_consumed * 3600) AS Q_used,      (whi.power_rating * whi.heating_time * 60) AS Q_input    FROM energy_consumption_analysis eca    JOIN water_heater_info whi ON eca.heater_id = whi.id    WHERE eca.total_energy_consumed > 10000  ) SELECT    heater_id,    total_energy_consumed,    power_rating,    heating_time,    (Q_used / Q_input) * 100 AS thermal_efficiency,    CASE      WHEN (Q_used / Q_input) * 100 > 100 THEN '数据异常：热效率超过100%，需检查数据或设备。'      WHEN total_energy_consumed > 100000 THEN '数据异常：总能耗远超正常范围，需检查设备或数据记录。'      ELSE '数据正常。'    END AS data_analysis  FROM extreme_conditions;	water_heater	4
WITH FilteredWaterHeaters AS (     SELECT brand, model, energy_efficiency_rating, weight, power_rating      FROM water_heater_info      WHERE power_rating > 3 AND capacity > 50      ORDER BY power_rating DESC      LIMIT 5 )  SELECT brand, model, energy_efficiency_rating, AVG(weight) AS average_weight  FROM FilteredWaterHeaters  GROUP BY brand, model, energy_efficiency_rating;	water_heater	1
WITH FilteredWaterHeaters AS (     SELECT brand, model, warranty_period, manufacture_date, price      FROM water_heater_info      WHERE warranty_period > 24      ORDER BY manufacture_date DESC      LIMIT 5 )  SELECT brand, model, warranty_period, AVG(price) AS average_price  FROM FilteredWaterHeaters  GROUP BY brand, model, warranty_period;	water_heater	2
WITH FilteredWaterHeaters AS (   SELECT brand, model, price, capacity    FROM water_heater_info    WHERE price < 3000 AND energy_efficiency_rating = '1'    ORDER BY price ASC    LIMIT 5 )  SELECT brand, model, price, AVG(capacity) AS average_capacity  FROM FilteredWaterHeaters  GROUP BY brand, model, price;	water_heater	3
WITH IncreasedPriceWaterHeaters AS (     SELECT brand, model, price + 1000 AS new_price, weight      FROM water_heater_info      WHERE price + 1000 > 5000      ORDER BY new_price ASC      LIMIT 5 )  SELECT brand, model, new_price, AVG(weight) AS average_weight  FROM IncreasedPriceWaterHeaters  GROUP BY brand, model, new_price;	water_heater	4
WITH HighEnergyUsageRecords AS (   SELECT heater_id, usage_date, energy_consumed, water_used    FROM water_heater_usage    WHERE energy_consumed > 10    ORDER BY energy_consumed DESC    LIMIT 5 )  SELECT heater_id, usage_date, energy_consumed, AVG(water_used) AS average_water_used  FROM HighEnergyUsageRecords  GROUP BY heater_id, usage_date, energy_consumed;	water_heater	1
WITH HighTemperatureSetRecords AS (     SELECT heater_id, usage_date, temperature_set, ambient_temperature      FROM water_heater_usage      WHERE temperature_set > 60      ORDER BY temperature_set DESC      LIMIT 5 )  SELECT heater_id, usage_date, temperature_set, AVG(ambient_temperature) AS average_ambient_temperature  FROM HighTemperatureSetRecords  GROUP BY heater_id, usage_date, temperature_set;	water_heater	2
WITH HighWaterUsageRecords AS (     SELECT heater_id, usage_date, water_used, energy_consumed      FROM water_heater_usage      WHERE water_used > 100      ORDER BY water_used ASC      LIMIT 5 ) SELECT heater_id, usage_date, water_used, AVG(energy_consumed) AS average_energy_consumed  FROM HighWaterUsageRecords  GROUP BY heater_id, usage_date, water_used;	water_heater	3
WITH IncreasedEnergyConsumptionRecords AS (     SELECT heater_id, usage_date, energy_consumed + 5 AS new_energy_consumed, water_used      FROM water_heater_usage      WHERE energy_consumed + 5 > 20      ORDER BY new_energy_consumed ASC      LIMIT 5 )  SELECT heater_id, usage_date, new_energy_consumed, AVG(water_used) AS average_water_used  FROM IncreasedEnergyConsumptionRecords  GROUP BY heater_id, usage_date, new_energy_consumed;	water_heater	4
WITH HighTotalEnergyRecords AS (     SELECT heater_id, analysis_date, total_energy_consumed, average_daily_energy      FROM energy_consumption_analysis      WHERE total_energy_consumed > 100      ORDER BY total_energy_consumed DESC      LIMIT 5 )  SELECT heater_id, analysis_date, total_energy_consumed, AVG(average_daily_energy) AS average_daily_energy  FROM HighTotalEnergyRecords  GROUP BY heater_id, analysis_date, total_energy_consumed;	water_heater	1
WITH HighPeakEnergyRecords AS (     SELECT heater_id, analysis_date, peak_energy_value, low_energy_value      FROM energy_consumption_analysis      WHERE peak_energy_value > 50      ORDER BY peak_energy_value DESC      LIMIT 5 )  SELECT heater_id, analysis_date, peak_energy_value, AVG(low_energy_value) AS average_low_energy_value  FROM HighPeakEnergyRecords  GROUP BY heater_id, analysis_date, peak_energy_value;	water_heater	2
WITH HighEnergyCostRecords AS (     SELECT heater_id, analysis_date, energy_cost, total_energy_consumed      FROM energy_consumption_analysis      WHERE energy_cost > 50      ORDER BY energy_cost ASC      LIMIT 5 )  SELECT heater_id, analysis_date, energy_cost, AVG(total_energy_consumed) AS average_total_energy_consumed  FROM HighEnergyCostRecords  GROUP BY heater_id, analysis_date, energy_cost;	water_heater	3
WITH IncreasedTotalEnergyRecords AS (     SELECT heater_id, analysis_date, total_energy_consumed + 50 AS new_total_energy_consumed, energy_cost      FROM energy_consumption_analysis      WHERE total_energy_consumed + 50 > 200      ORDER BY new_total_energy_consumed ASC      LIMIT 5 )  SELECT heater_id, analysis_date, new_total_energy_consumed, AVG(energy_cost) AS average_energy_cost  FROM IncreasedTotalEnergyRecords  GROUP BY heater_id, analysis_date, new_total_energy_consumed;	water_heater	4
WITH HighAmbientTemperatureRecords AS (   SELECT heater_id, record_date, ambient_temperature, humidity    FROM environment_data    WHERE ambient_temperature > 30    ORDER BY ambient_temperature DESC    LIMIT 5 )  SELECT heater_id, record_date, ambient_temperature, AVG(humidity) AS average_humidity  FROM HighAmbientTemperatureRecords  GROUP BY heater_id, record_date, ambient_temperature;	water_heater	1
WITH HighWaterPressureRecords AS (     SELECT heater_id, record_date, water_pressure, wind_speed      FROM environment_data      WHERE water_pressure > 3      ORDER BY water_pressure ASC      LIMIT 5 )  SELECT heater_id, record_date, water_pressure, AVG(wind_speed) AS average_wind_speed  FROM HighWaterPressureRecords  GROUP BY heater_id, record_date, water_pressure;	water_heater	2
WITH HighSolarRadiationRecords AS (   SELECT heater_id, record_date, solar_radiation, water_inlet_temperature    FROM environment_data    WHERE solar_radiation > 500    ORDER BY solar_radiation DESC    LIMIT 5 )  SELECT heater_id, record_date, solar_radiation, AVG(water_inlet_temperature) AS average_water_inlet_temperature  FROM HighSolarRadiationRecords  GROUP BY heater_id, record_date, solar_radiation;	water_heater	3
WITH IncreasedAmbientTemperatureRecords AS (     SELECT heater_id, record_date, ambient_temperature + 10 AS new_ambient_temperature, air_pressure      FROM environment_data      WHERE ambient_temperature + 10 > 40      ORDER BY new_ambient_temperature ASC      LIMIT 5 )  SELECT heater_id, record_date, new_ambient_temperature, AVG(air_pressure) AS average_air_pressure  FROM IncreasedAmbientTemperatureRecords  GROUP BY heater_id, record_date, new_ambient_temperature;	water_heater	4
WITH FilteredUsageRecords AS (   SELECT u.heater_id, u.usage_date, u.energy_consumed, u.water_used    FROM water_heater_usage u    JOIN environment_data e ON u.heater_id = e.heater_id AND u.usage_date = e.record_date    WHERE u.energy_consumed > 10 AND e.ambient_temperature > 25    ORDER BY u.energy_consumed DESC    LIMIT 5 )  SELECT heater_id, usage_date, energy_consumed, AVG(water_used) AS average_water_used  FROM FilteredUsageRecords  GROUP BY heater_id, usage_date, energy_consumed;	water_heater	1
WITH FilteredEnergyRecords AS (     SELECT a.heater_id, a.analysis_date, a.total_energy_consumed, a.average_daily_energy, i.brand      FROM energy_consumption_analysis a      JOIN water_heater_info i ON a.heater_id = i.id      WHERE a.total_energy_consumed > 100 AND i.energy_efficiency_rating = '1'      ORDER BY a.total_energy_consumed DESC      LIMIT 5 )  SELECT brand, heater_id, analysis_date, total_energy_consumed, AVG(average_daily_energy) AS average_daily_energy  FROM FilteredEnergyRecords  GROUP BY brand, heater_id, analysis_date, total_energy_consumed;	water_heater	2
WITH SatisfiedFeedbackRecords AS (     SELECT heater_id, usage_date, user_feedback, energy_consumed      FROM water_heater_usage      WHERE user_feedback LIKE '%满意%'      ORDER BY usage_date DESC      LIMIT 5 )  SELECT heater_id, usage_date, user_feedback, AVG(energy_consumed) AS average_energy_consumed  FROM SatisfiedFeedbackRecords  GROUP BY heater_id, usage_date, user_feedback;	water_heater	3
WITH IncreasedPowerRatingModels AS (   SELECT brand, model, power_rating + 2 AS new_power_rating, price    FROM water_heater_info    WHERE power_rating + 2 > 5 AND capacity > 50    ORDER BY new_power_rating ASC    LIMIT 5 )  SELECT brand, model, new_power_rating, AVG(price) AS average_price  FROM IncreasedPowerRatingModels  GROUP BY brand, model, new_power_rating;	water_heater	4
SELECT u.heater_id, u.usage_date, a.peak_energy_value FROM water_heater_usage u JOIN energy_consumption_analysis a ON u.heater_id = a.heater_id WHERE u.user_feedback LIKE '%高效%' AND a.peak_energy_value > 50 ORDER BY a.peak_energy_value DESC LIMIT 5; SELECT u.heater_id, AVG(e.ambient_temperature) AS avg_ambient_temp FROM water_heater_usage u JOIN environment_data e ON u.heater_id = e.heater_id AND u.usage_date = e.record_date WHERE u.user_feedback LIKE '%高效%' AND a.peak_energy_value > 50 GROUP BY u.heater_id;	water_heater	1
SELECT a.heater_id, a.analysis_date, a.energy_cost FROM energy_consumption_analysis a JOIN water_heater_usage u ON a.heater_id = u.heater_id WHERE a.energy_cost > 50 AND u.user_feedback LIKE '%节能%' ORDER BY a.energy_cost ASC LIMIT 5;   SELECT i.brand, AVG(a.total_energy_consumed) AS avg_total_energy FROM energy_consumption_analysis a JOIN water_heater_info i ON a.heater_id = i.id JOIN water_heater_usage u ON a.heater_id = u.heater_id WHERE a.energy_cost > 50 AND u.user_feedback LIKE '%节能%' GROUP BY i.brand;	water_heater	2
SELECT e.heater_id, e.record_date, e.solar_radiation FROM environment_data e JOIN water_heater_usage u ON e.heater_id = u.heater_id AND e.record_date = u.usage_date WHERE e.solar_radiation > 500 AND u.user_feedback LIKE '%舒适%' ORDER BY e.solar_radiation DESC LIMIT 5;  SELECT e.heater_id, AVG(e.water_inlet_temperature) AS avg_inlet_temp FROM environment_data e JOIN water_heater_usage u ON e.heater_id = u.heater_id AND e.record_date = u.usage_date WHERE e.solar_radiation > 500 AND u.user_feedback LIKE '%舒适%' GROUP BY e.heater_id;	water_heater	3
SELECT i.model, i.power_rating + 3 AS new_power_rating FROM water_heater_info i JOIN water_heater_usage u ON i.id = u.heater_id WHERE i.power_rating + 3 > 7 AND u.user_feedback LIKE '%强劲%' ORDER BY new_power_rating ASC LIMIT 5; SELECT i.brand, AVG(i.price) AS avg_price FROM water_heater_info i JOIN water_heater_usage u ON i.id = u.heater_id WHERE i.power_rating + 3 > 7 AND u.user_feedback LIKE '%强劲%' GROUP BY i.brand;	water_heater	4
WITH HeatingEfficiency AS (     SELECT i.id, i.brand, i.model, i.capacity, i.power_rating, i.heating_time,             e.water_inlet_temperature, e.water_outlet_temperature,             (i.capacity * 4.18 * (e.water_outlet_temperature - e.water_inlet_temperature)) / (i.power_rating * (i.heating_time / 60.0)) * 100.0 AS heating_efficiency      FROM water_heater_info i      JOIN environment_data e ON i.id = e.heater_id      WHERE i.brand = 'A' AND e.ambient_temperature = 25 )  SELECT id, brand, model, heating_efficiency  FROM HeatingEfficiency  ORDER BY heating_efficiency DESC  LIMIT 5;	water_heater	1
WITH DailyEnergyCost AS (   SELECT      i.brand,      AVG(a.average_daily_energy * 0.6) AS daily_energy_cost    FROM water_heater_info i    JOIN energy_consumption_analysis a ON i.id = a.heater_id    GROUP BY i.brand )  SELECT brand, daily_energy_cost  FROM DailyEnergyCost  ORDER BY daily_energy_cost ASC  LIMIT 3;	water_heater	2
WITH TotalEnergyCost AS (     SELECT i.id, i.model, i.brand, a.total_energy_consumed * 0.6 AS total_energy_cost      FROM water_heater_info i      JOIN energy_consumption_analysis a ON i.id = a.heater_id      WHERE i.energy_efficiency_rating = '1' )  SELECT id, model, brand, total_energy_cost  FROM TotalEnergyCost  ORDER BY total_energy_cost DESC  LIMIT 10;	water_heater	3
WITH ExtremeHeatingEfficiency AS (     SELECT          i.id,          i.model,          i.brand,          i.capacity,          10000 AS power_rating,          0.1 AS heating_time,          -80 AS water_inlet_temperature,          200 AS water_outlet_temperature,          (i.capacity * 4.18 * (200 - (-80))) / (10000 * (0.1 / 60.0)) * 100.0 AS heating_efficiency      FROM water_heater_info i )  SELECT id, model, brand, heating_efficiency  FROM ExtremeHeatingEfficiency  ORDER BY heating_efficiency DESC  LIMIT 1;	water_heater	4
WITH HeatingTimeDeviation AS (   SELECT      i.id,      i.model,      i.brand,      i.capacity,      i.power_rating,      i.heating_time,      e.water_inlet_temperature,      e.water_outlet_temperature,      ABS(i.heating_time - ((i.capacity * 4.18 * (e.water_outlet_temperature - e.water_inlet_temperature)) / i.power_rating)) / ((i.capacity * 4.18 * (e.water_outlet_temperature - e.water_inlet_temperature)) / i.power_rating) * 100 AS deviation_percentage    FROM water_heater_info i    JOIN environment_data e ON i.id = e.heater_id    WHERE i.model LIKE '%X200%' AND e.ambient_temperature = 30 )  SELECT id, model, brand, deviation_percentage  FROM HeatingTimeDeviation  ORDER BY deviation_percentage ASC  LIMIT 5;	water_heater	1
WITH EnergyDifference AS (     SELECT i.brand, MAX(a.peak_energy_value - a.low_energy_value) AS energy_difference      FROM water_heater_info i      JOIN energy_consumption_analysis a ON i.id = a.heater_id      GROUP BY i.brand )  SELECT brand, energy_difference  FROM EnergyDifference  ORDER BY energy_difference DESC  LIMIT 3;	water_heater	2
WITH EnergyCostRatio AS (     SELECT          i.id,          i.model,          i.brand,          (a.total_energy_consumed * 0.6) / i.price AS energy_cost_ratio      FROM          water_heater_info i      JOIN          energy_consumption_analysis a ON i.id = a.heater_id      WHERE          i.warranty_period > 24 ) SELECT      id,      model,      brand,      energy_cost_ratio  FROM      EnergyCostRatio  ORDER BY      energy_cost_ratio ASC  LIMIT 10;	water_heater	3
WITH ExtremeHeatingEfficiency AS (     SELECT          i.id,          i.model,          i.brand,          10000 AS capacity,          5000 AS power_rating,          i.heating_time,          -150 AS water_inlet_temperature,          300 AS water_outlet_temperature,          (10000 * 4.18 * (300 - (-150))) / (5000 * (CAST(i.heating_time AS REAL) / 60)) * 100 AS heating_efficiency      FROM water_heater_info i )  SELECT id, model, brand, heating_efficiency  FROM ExtremeHeatingEfficiency  ORDER BY heating_efficiency DESC  LIMIT 1;	water_heater	4
SELECT (Hourly_Output / (Rated_Power * 1)) * 100 AS Efficiency FROM energy_output JOIN wind_turbines ON energy_output.Turbine_ID = wind_turbines.Turbine_ID WHERE wind_turbines.Rated_Power = 2000 AND energy_output.Hourly_Output = 1800;	wind_turbine	1
SELECT Turbine_ID, Hourly_Output, (Hourly_Output / (SELECT SUM(Hourly_Output) FROM energy_output WHERE Turbine_ID IN (SELECT Turbine_ID FROM wind_turbines LIMIT 10))) * 100 AS Percentage FROM energy_output WHERE Turbine_ID IN (SELECT Turbine_ID FROM wind_turbines LIMIT 10);	wind_turbine	2
SELECT w.Turbine_ID, w.Wind_Speed, e.Hourly_Output, m.Maintenance_Type, m.Description  FROM weather_data w  JOIN energy_output e ON w.Turbine_ID = e.Turbine_ID AND w.Date = e.Date  LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID  WHERE w.Wind_Speed > (SELECT Cut_In_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)    AND w.Wind_Speed < (SELECT Cut_Out_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)    AND e.Hourly_Output = 0;	wind_turbine	3
SELECT e.Turbine_ID, e.Hourly_Output, w.Rated_Power, (e.Hourly_Output / w.Rated_Power) * 100 AS Efficiency  FROM energy_output e  JOIN wind_turbines w ON e.Turbine_ID = w.Turbine_ID  WHERE e.Hourly_Output = 100000 AND w.Rated_Power = 2000;	wind_turbine	4
SELECT Turbine_ID, Daily_Output, (Daily_Output / 24) AS Average_Power FROM energy_output WHERE Daily_Output = 48000;	wind_turbine	1
SELECT Turbine_ID, Daily_Output, (Daily_Output * 100.0 / (SELECT SUM(Daily_Output) FROM energy_output WHERE Daily_Output IN (40000, 42000, 44000, 46000, 48000))) AS Percentage FROM energy_output WHERE Daily_Output IN (40000, 42000, 44000, 46000, 48000);	wind_turbine	2
SELECT w.Turbine_ID, w.Wind_Speed, e.Daily_Output, m.Maintenance_Type, m.Description  FROM weather_data w  JOIN energy_output e ON w.Turbine_ID = e.Turbine_ID AND w.Date = e.Date  LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID  WHERE w.Wind_Speed > (SELECT Cut_In_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)  AND w.Wind_Speed < (SELECT Cut_Out_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)  AND e.Daily_Output = 0;	wind_turbine	3
SELECT e.Turbine_ID, e.Daily_Output, w.Rated_Power, (e.Daily_Output / 24) AS Average_Power FROM energy_output e JOIN wind_turbines w ON e.Turbine_ID = w.Turbine_ID WHERE e.Daily_Output = 1000000 AND w.Rated_Power = 2000;	wind_turbine	4
SELECT Turbine_ID, Monthly_Output, (Monthly_Output / (30 * 24)) AS Average_Power FROM energy_output WHERE Monthly_Output = 1440000;	wind_turbine	1
SELECT Turbine_ID, Monthly_Output, (Monthly_Output * 100.0 / (SELECT SUM(Monthly_Output) FROM energy_output WHERE Monthly_Output IN (1200000, 1300000, 1400000, 1500000, 1600000))) AS Percentage FROM energy_output WHERE Monthly_Output IN (1200000, 1300000, 1400000, 1500000, 1600000);	wind_turbine	2
SELECT w.Turbine_ID, w.Wind_Speed, e.Monthly_Output, m.Maintenance_Type, m.Description  FROM weather_data w  JOIN energy_output e ON w.Turbine_ID = e.Turbine_ID AND w.Date = e.Date  LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID  WHERE w.Wind_Speed > (SELECT Cut_In_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)    AND w.Wind_Speed < (SELECT Cut_Out_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)    AND e.Monthly_Output = 0;	wind_turbine	3
SELECT e.Turbine_ID, e.Monthly_Output, w.Rated_Power, (e.Monthly_Output / (30 * 24)) AS Average_Power FROM energy_output e JOIN wind_turbines w ON e.Turbine_ID = w.Turbine_ID WHERE e.Monthly_Output = 100000000 AND w.Rated_Power = 2000;	wind_turbine	4
SELECT Turbine_ID, Annual_Output, (Annual_Output / (365 * 24)) AS Average_Power FROM energy_output WHERE Annual_Output = 17520000;	wind_turbine	1
SELECT Turbine_ID, Annual_Output, (Annual_Output * 100.0 / (SELECT SUM(Annual_Output) FROM energy_output WHERE Annual_Output IN (15000000, 16000000, 17000000, 18000000, 19000000))) AS Percentage FROM energy_output WHERE Annual_Output IN (15000000, 16000000, 17000000, 18000000, 19000000);	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Wind_Speed) AS Avg_Wind_Speed, e.Annual_Output, m.Maintenance_Type, m.Description  FROM weather_data w  JOIN energy_output e ON w.Turbine_ID = e.Turbine_ID AND strftime('%Y', w.Date) = strftime('%Y', e.Date)  LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID  WHERE e.Annual_Output = 0  AND w.Wind_Speed > (SELECT Cut_In_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)  AND w.Wind_Speed < (SELECT Cut_Out_Wind_Speed FROM wind_turbines WHERE Turbine_ID = w.Turbine_ID)  GROUP BY w.Turbine_ID, e.Annual_Output, m.Maintenance_Type, m.Description;	wind_turbine	3
SELECT e.Turbine_ID, e.Annual_Output, w.Rated_Power, (e.Annual_Output / (365 * 24)) AS Average_Power FROM energy_output e JOIN wind_turbines w ON e.Turbine_ID = w.Turbine_ID WHERE e.Annual_Output = 1000000000 AND w.Rated_Power = 2000;	wind_turbine	4
SELECT m.Turbine_ID, m.Cost, e.Annual_Output, (m.Cost / e.Annual_Output) AS Cost_Per_kWh FROM maintenance_logs m JOIN energy_output e ON m.Turbine_ID = e.Turbine_ID WHERE m.Cost = 5000 AND e.Annual_Output = 17520000;	wind_turbine	1
SELECT m.Turbine_ID, m.Cost, e.Annual_Output, (m.Cost * 1.0 / e.Annual_Output) AS Cost_Per_kWh, (SELECT SUM(Cost) FROM maintenance_logs WHERE Cost IN (4000, 4500, 5000, 5500, 6000)) AS Total_Maintenance_Cost, (SELECT SUM(Annual_Output) FROM energy_output WHERE Annual_Output IN (15000000, 16000000, 17000000, 18000000, 19000000)) AS Total_Annual_Output FROM maintenance_logs m JOIN energy_output e ON m.Turbine_ID = e.Turbine_ID WHERE m.Cost IN (4000, 4500, 5000, 5500, 6000) AND e.Annual_Output IN (15000000, 16000000, 17000000, 18000000, 19000000);	wind_turbine	2
SELECT m.Turbine_ID, m.Cost, e.Annual_Output, m.Maintenance_Type, m.Description FROM maintenance_logs m JOIN energy_output e ON m.Turbine_ID = e.Turbine_ID WHERE m.Cost = 0 AND e.Annual_Output = 17520000;	wind_turbine	3
SELECT m.Turbine_ID, m.Cost, e.Annual_Output, (m.Cost * 1.0 / e.Annual_Output) AS Cost_Per_kWh FROM maintenance_logs m JOIN energy_output e ON m.Turbine_ID = e.Turbine_ID WHERE m.Cost = 1000000 AND e.Annual_Output = 17520000;	wind_turbine	4
SELECT Revenue / Production_Volume_Total AS Average_Revenue_Contribution FROM manufacturers WHERE Revenue = 1000000000 AND Production_Volume_Total = 1000;	wind_turbine	1
SELECT Turbine_ID, Annual_Output * 0.1 AS Revenue, (Annual_Output * 0.1) / total_revenue * 100 AS Revenue_Percentage, total_revenue FROM energy_output, (SELECT SUM(Annual_Output * 0.1) AS total_revenue FROM energy_output WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID')) AS total WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID');	wind_turbine	2
SELECT Name, Revenue, Production_Volume_Total FROM manufacturers WHERE Revenue = 0 AND Production_Volume_Total = 1000;	wind_turbine	3
SELECT Name, Revenue / Production_Volume_Total AS Average_Revenue_Contribution FROM manufacturers WHERE Revenue = 1000000000000 AND Production_Volume_Total = 1000;	wind_turbine	4
SELECT Production_Volume_Total * 200 AS Total_Weight FROM manufacturers WHERE Production_Volume_Total = 1000;	wind_turbine	1
SELECT e.Turbine_ID, e.Annual_Output, w.Weight,         (e.Annual_Output * 100.0 / (SELECT SUM(Annual_Output) FROM energy_output WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID'))) AS Output_Percentage,         (w.Weight * 100.0 / (SELECT SUM(Weight) FROM wind_turbines WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID'))) AS Weight_Percentage,         (SELECT SUM(Annual_Output) FROM energy_output WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID')) AS Total_Annual_Output,         (SELECT SUM(Weight) FROM wind_turbines WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID')) AS Total_Weight  FROM energy_output e  JOIN wind_turbines w ON e.Turbine_ID = w.Turbine_ID  WHERE e.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID');	wind_turbine	2
SELECT Name, Revenue, Production_Volume_Total FROM manufacturers WHERE Production_Volume_Total = 0 AND Revenue = 1000000000;	wind_turbine	3
SELECT Name, Production_Volume_Total * 200 AS Total_Weight FROM manufacturers WHERE Production_Volume_Total = 1000000;	wind_turbine	4
SELECT Name, Revenue * (Profit_Margin / 100) AS Annual_Profit FROM manufacturers WHERE Revenue = 1000000000 AND Profit_Margin = 20;	wind_turbine	1
SELECT e.Turbine_ID,         e.Annual_Output,         m.Profit_Margin,         (e.Annual_Output * 100.0 / (SELECT SUM(Annual_Output) FROM energy_output WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID'))) AS Output_Percentage,         (e.Annual_Output * (m.Profit_Margin / 100.0)) AS Annual_Profit,         (e.Annual_Output * (m.Profit_Margin / 100.0) * 100.0 / (SELECT SUM(e2.Annual_Output * (m2.Profit_Margin / 100.0)) FROM energy_output e2 JOIN manufacturers m2 ON e2.Turbine_ID = m2.Manufacturer_ID WHERE e2.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID'))) AS Profit_Percentage,         (SELECT SUM(Annual_Output) FROM energy_output WHERE Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID')) AS Total_Annual_Output,         (SELECT SUM(e2.Annual_Output * (m2.Profit_Margin / 100.0)) FROM energy_output e2 JOIN manufacturers m2 ON e2.Turbine_ID = m2.Manufacturer_ID WHERE e2.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID')) AS Total_Annual_Profit  FROM energy_output e  JOIN manufacturers m ON e.Turbine_ID = m.Manufacturer_ID  WHERE e.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID');	wind_turbine	2
SELECT Name, Revenue, Profit_Margin FROM manufacturers WHERE Profit_Margin = 0 AND Revenue = 1000000000;	wind_turbine	3
SELECT Name, Revenue * (Profit_Margin / 100.0) AS Annual_Profit FROM manufacturers WHERE Profit_Margin = 1000 AND Revenue = 1000000000;	wind_turbine	4
SELECT Rated_Power * (Capacity_Factor / 100) AS Actual_Average_Power_Output FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE Capacity_Factor = 30 AND Rated_Power = 2000;	wind_turbine	1
SELECT p.Turbine_ID,         w.Rated_Power * (p.Capacity_Factor / 100.0) AS Actual_Power_Output,         (w.Rated_Power * (p.Capacity_Factor / 100.0)) / (SELECT SUM(w2.Rated_Power * (p2.Capacity_Factor / 100.0)) FROM performance_metrics p2 JOIN wind_turbines w2 ON p2.Turbine_ID = w2.Turbine_ID WHERE p2.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID')) * 100.0 AS Power_Percentage,         (SELECT SUM(w2.Rated_Power * (p2.Capacity_Factor / 100.0)) FROM performance_metrics p2 JOIN wind_turbines w2 ON p2.Turbine_ID = w2.Turbine_ID WHERE p2.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID')) AS Total_Actual_Power_Output  FROM performance_metrics p  JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID  WHERE p.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID');	wind_turbine	2
SELECT p.Turbine_ID, w.Rated_Power, p.Capacity_Factor FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Capacity_Factor = 0 AND w.Rated_Power = 2000;	wind_turbine	3
SELECT p.Turbine_ID, w.Rated_Power * (p.Capacity_Factor / 100.0) AS Actual_Average_Power_Output FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Capacity_Factor = 1000 AND w.Rated_Power = 2000;	wind_turbine	4
SELECT 8760 * (Availability / 100.0) AS Available_Time FROM performance_metrics WHERE Availability = 95;	wind_turbine	1
WITH Availability_Data AS (   SELECT      p.Turbine_ID,      8760 * (p.Availability / 100.0) AS Available_Time,      w.Rated_Power    FROM performance_metrics p    JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID    WHERE p.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID') ), Total_Data AS (   SELECT      SUM(Available_Time) AS Total_Available_Time,      SUM(Rated_Power) AS Total_Rated_Power    FROM Availability_Data ) SELECT    a.Turbine_ID,    a.Available_Time,    a.Rated_Power,    (a.Available_Time / t.Total_Available_Time) * 100 AS Availability_Percentage,    (a.Rated_Power / t.Total_Rated_Power) * 100 AS Rated_Power_Percentage,    t.Total_Available_Time,    t.Total_Rated_Power  FROM Availability_Data a, Total_Data t;	wind_turbine	2
SELECT p.Turbine_ID, w.Rated_Power, p.Availability FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Availability = 0 AND w.Rated_Power = 2000;	wind_turbine	3
SELECT 8760 * (Availability / 100) AS Available_Time FROM performance_metrics WHERE Availability = 1000;	wind_turbine	4
SELECT (Blade_Tip_Speed * 60) / (3.141592653589793 * Rotor_Diameter) AS Rotor_Speed FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE Blade_Tip_Speed = 80 AND Rotor_Diameter = 100;	wind_turbine	1
WITH Rotor_Speed_Data AS (     SELECT p.Turbine_ID, (p.Blade_Tip_Speed * 60) / (PI() * w.Rotor_Diameter) AS Rotor_Speed      FROM performance_metrics p      JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID      WHERE p.Turbine_ID IN ('发电机1ID', '发电机2ID', '发电机3ID', '发电机4ID', '发电机5ID') ),  Total_Rotor_Speed AS (     SELECT SUM(Rotor_Speed) AS Total_Rotor_Speed      FROM Rotor_Speed_Data )  SELECT r.Turbine_ID, r.Rotor_Speed, (r.Rotor_Speed / t.Total_Rotor_Speed) * 100 AS Rotor_Speed_Percentage, t.Total_Rotor_Speed  FROM Rotor_Speed_Data r, Total_Rotor_Speed t;	wind_turbine	2
SELECT p.Turbine_ID, w.Rotor_Diameter, p.Blade_Tip_Speed FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Blade_Tip_Speed = 0 AND w.Rotor_Diameter = 100;	wind_turbine	3
SELECT (Blade_Tip_Speed * 60) / (3.141592653589793 * Rotor_Diameter) AS Rotor_Speed FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Blade_Tip_Speed = 1000 AND w.Rotor_Diameter = 100;	wind_turbine	4
SELECT w.Turbine_ID, w.Wind_Speed, p.Noise_Level, 20 * LOG10(p.Noise_Level / 20.0) AS SPL FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID WHERE w.Wind_Speed = 10;	wind_turbine	1
SELECT e.Turbine_ID, SUM(e.Daily_Output) AS Annual_Energy_Output, AVG(w.Wind_Speed) AS Avg_Wind_Speed  FROM energy_output e  JOIN weather_data w ON e.Turbine_ID = w.Turbine_ID AND e.Date = w.Date  WHERE strftime('%Y', e.Date) = '2023'  GROUP BY e.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Temperature) AS Avg_Temperature, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Temperature > 30 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT p.Turbine_ID, p.Noise_Level, w.Location, w.Latitude, w.Longitude, CASE WHEN p.Noise_Level >= 200 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN p.Noise_Level >= 120 THEN 'High Impact: Potential hearing damage and significant disturbance' ELSE 'Normal Impact: Within acceptable noise levels' END AS Impact_Assessment FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Noise_Level >= 200;	wind_turbine	4
SELECT w.Turbine_ID, w.Wind_Speed, p.Vibration_Level, t.Weight, 0.5 * t.Weight * (p.Vibration_Level * p.Vibration_Level) AS Vibration_Energy  FROM weather_data w  JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID  JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID  WHERE w.Wind_Speed = 10;	wind_turbine	1
SELECT w.Turbine_ID, SUM(0.5 * t.Weight * p.Vibration_Level * p.Vibration_Level) AS Total_Vibration_Energy, AVG(w.Wind_Speed) AS Avg_Wind_Speed FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Temperature) AS Avg_Temperature, AVG(p.Vibration_Level) AS Avg_Vibration_Level, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Temperature < 0 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT p.Turbine_ID, p.Vibration_Level, w.Location, w.Latitude, w.Longitude, CASE WHEN p.Vibration_Level >= 1000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN p.Vibration_Level >= 50 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable vibration levels' END AS Impact_Assessment FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Vibration_Level >= 1000;	wind_turbine	4
SELECT w.Turbine_ID, w.Temperature, t.Rotor_Diameter, t.Blade_Material, (t.Rotor_Diameter * 0.000012 * (w.Temperature - 20)) AS Thermal_Expansion FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Temperature > 40;	wind_turbine	1
SELECT w.Turbine_ID, SUM(t.Rotor_Diameter * 0.000012 * (w.Temperature - 20)) AS Total_Thermal_Expansion, AVG(w.Temperature) AS Avg_Temperature FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Temperature) AS Avg_Temperature, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Temperature < 0 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT p.Turbine_ID, p.Temperature_Rating, w.Location, w.Latitude, w.Longitude, CASE WHEN p.Temperature_Rating >= 1000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN p.Temperature_Rating >= 40 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable temperature range' END AS Impact_Assessment FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Temperature_Rating >= 1000;	wind_turbine	4
SELECT w.Turbine_ID, w.Wind_Speed, t.Weight, 0.5 * t.Weight * (w.Wind_Speed * w.Wind_Speed) AS Kinetic_Energy FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Wind_Speed = 10;	wind_turbine	1
SELECT w.Turbine_ID, SUM(0.5 * t.Weight * POWER(w.Wind_Speed, 2)) AS Total_Kinetic_Energy, AVG(w.Wind_Speed) AS Avg_Wind_Speed FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Wind_Speed) AS Avg_Wind_Speed, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Wind_Speed < 5 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT w.Turbine_ID, w.Wind_Speed, t.Location, t.Latitude, t.Longitude, CASE WHEN w.Wind_Speed >= 1000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN w.Wind_Speed >= 25 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable wind speed range' END AS Impact_Assessment FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Wind_Speed >= 1000;	wind_turbine	4
SELECT w.Turbine_ID, w.Wind_Speed, w.Wind_Direction, t.Model, w.Wind_Speed * COS(w.Wind_Direction * PI() / 180.0) AS Effective_Wind_Speed FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Wind_Direction = 90;	wind_turbine	1
SELECT w.Turbine_ID, SUM(w.Wind_Speed * COS(w.Wind_Direction * PI() / 180)) AS Total_Effective_Wind_Speed, AVG(w.Wind_Direction) AS Avg_Wind_Direction FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, COUNT(DISTINCT w.Wind_Direction) AS Wind_Direction_Changes, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID HAVING COUNT(DISTINCT w.Wind_Direction) > 50;	wind_turbine	3
SELECT w.Turbine_ID, COUNT(DISTINCT w.Wind_Direction) AS Wind_Direction_Changes, t.Location, t.Latitude, t.Longitude, CASE WHEN COUNT(DISTINCT w.Wind_Direction) >= 1000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN COUNT(DISTINCT w.Wind_Direction) >= 50 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable wind direction change range' END AS Impact_Assessment FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE date(w.Date) = '2023-10-01' GROUP BY w.Turbine_ID HAVING COUNT(DISTINCT w.Wind_Direction) >= 1000;	wind_turbine	4
SELECT w.Turbine_ID, w.Temperature, t.Rotor_Diameter, t.Blade_Material, (t.Rotor_Diameter * 0.000012 * (w.Temperature - 20)) AS Thermal_Expansion FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Temperature > 40;	wind_turbine	1
SELECT w.Turbine_ID, SUM(t.Rotor_Diameter * 0.000012 * (w.Temperature - 20)) AS Total_Thermal_Expansion, AVG(w.Temperature) AS Avg_Temperature FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Temperature) AS Avg_Temperature, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Temperature < 0 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT p.Turbine_ID, p.Temperature_Rating, w.Location, w.Latitude, w.Longitude, CASE WHEN p.Temperature_Rating >= 1000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN p.Temperature_Rating >= 40 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable temperature range' END AS Impact_Assessment FROM performance_metrics p JOIN wind_turbines w ON p.Turbine_ID = w.Turbine_ID WHERE p.Temperature_Rating >= 1000;	wind_turbine	4
SELECT w.Turbine_ID, w.Air_Pressure, w.Temperature, w.Humidity, (w.Air_Pressure * 0.02897) / (8.314 * (w.Temperature + 273.15)) AS Air_Density FROM weather_data w WHERE w.Air_Pressure = 1013;	wind_turbine	1
SELECT w.Turbine_ID, SUM((w.Air_Pressure * 0.02897) / (8.314 * (w.Temperature + 273.15))) AS Total_Air_Density_Change, AVG(w.Air_Pressure) AS Avg_Air_Pressure FROM weather_data w WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Air_Pressure) AS Avg_Air_Pressure, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Air_Pressure < 1000 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT w.Turbine_ID, w.Air_Pressure, t.Location, t.Latitude, t.Longitude, CASE WHEN w.Air_Pressure >= 10000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN w.Air_Pressure >= 1100 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable air pressure range' END AS Impact_Assessment FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Air_Pressure >= 10000;	wind_turbine	4
SELECT w.Turbine_ID, w.Rainfall, t.Rotor_Diameter, (w.Rainfall * 1000 * 1) / (PI() * POWER(t.Rotor_Diameter / 2, 2)) AS Water_Film_Thickness FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Rainfall = 50;	wind_turbine	1
SELECT w.Turbine_ID, SUM((w.Rainfall * 1000 * 1) / (PI() * POWER(t.Rotor_Diameter / 2, 2))) AS Total_Water_Film_Thickness_Change, AVG(w.Rainfall) AS Avg_Rainfall FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Rainfall) AS Avg_Rainfall, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Rainfall > 50 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT w.Turbine_ID, w.Rainfall, t.Location, t.Latitude, t.Longitude, CASE WHEN w.Rainfall >= 10000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN w.Rainfall >= 100 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable rainfall range' END AS Impact_Assessment FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Rainfall >= 10000;	wind_turbine	4
SELECT w.Turbine_ID, w.Solar_Radiation, t.Weight, t.Blade_Material, (w.Solar_Radiation * 0.8) / (t.Weight * 500) AS Surface_Temperature_Change  FROM weather_data w  JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID  WHERE w.Solar_Radiation = 800;	wind_turbine	1
SELECT w.Turbine_ID, SUM((w.Solar_Radiation * 0.8) / (t.Weight * 500)) AS Total_Surface_Temperature_Change, AVG(w.Solar_Radiation) AS Avg_Solar_Radiation FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY w.Turbine_ID;	wind_turbine	2
SELECT w.Turbine_ID, AVG(w.Solar_Radiation) AS Avg_Solar_Radiation, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM weather_data w JOIN performance_metrics p ON w.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON w.Turbine_ID = m.Turbine_ID WHERE w.Solar_Radiation > 800 GROUP BY w.Turbine_ID;	wind_turbine	3
SELECT w.Turbine_ID, w.Solar_Radiation, t.Location, t.Latitude, t.Longitude, CASE WHEN w.Solar_Radiation >= 10000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN w.Solar_Radiation >= 1000 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable solar radiation range' END AS Impact_Assessment FROM weather_data w JOIN wind_turbines t ON w.Turbine_ID = t.Turbine_ID WHERE w.Solar_Radiation >= 10000;	wind_turbine	4
SELECT p.Turbine_ID, t.Rotor_Diameter, p.Rotor_Speed, PI() * t.Rotor_Diameter * p.Rotor_Speed / 60 AS Blade_Tip_Speed FROM performance_metrics p JOIN wind_turbines t ON p.Turbine_ID = t.Turbine_ID WHERE p.Rotor_Speed = 15;	wind_turbine	1
SELECT p.Turbine_ID, SUM(PI() * t.Rotor_Diameter * p.Rotor_Speed / 60) AS Total_Tip_Speed_Change, AVG(t.Rotor_Diameter) AS Avg_Rotor_Diameter FROM performance_metrics p JOIN wind_turbines t ON p.Turbine_ID = t.Turbine_ID JOIN weather_data w ON p.Turbine_ID = w.Turbine_ID WHERE strftime('%Y', w.Date) = '2023' GROUP BY p.Turbine_ID;	wind_turbine	2
SELECT t.Turbine_ID, AVG(t.Rotor_Diameter) AS Avg_Rotor_Diameter, AVG(p.Capacity_Factor) AS Avg_Capacity_Factor, AVG(p.Availability) AS Avg_Availability, COUNT(m.Log_ID) AS Maintenance_Count FROM wind_turbines t JOIN performance_metrics p ON t.Turbine_ID = p.Turbine_ID LEFT JOIN maintenance_logs m ON t.Turbine_ID = m.Turbine_ID WHERE t.Rotor_Diameter > 100 GROUP BY t.Turbine_ID;	wind_turbine	3
SELECT t.Turbine_ID, t.Rotor_Diameter, t.Location, t.Latitude, t.Longitude, CASE WHEN t.Rotor_Diameter >= 1000 THEN 'Extreme Impact: Structural damage and severe environmental harm' WHEN t.Rotor_Diameter >= 150 THEN 'High Impact: Potential structural damage and significant disturbance' ELSE 'Normal Impact: Within acceptable rotor diameter range' END AS Impact_Assessment FROM wind_turbines t WHERE t.Rotor_Diameter >= 1000;	wind_turbine	4
SELECT wt.Turbine_ID, wt.Hub_Height, wd.Wind_Speed, (SUM(eo.Hourly_Output) / (0.5 * 1.225 * POWER(wd.Wind_Speed, 3) * PI() * POWER(wt.Rotor_Diameter / 2, 2))) * 100 AS Efficiency FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID JOIN energy_output eo ON wt.Turbine_ID = eo.Turbine_ID AND wd.Date = eo.Date GROUP BY wt.Turbine_ID, wt.Hub_Height, wd.Wind_Speed;	wind_turbine	1
SELECT wt.Turbine_ID, wt.Hub_Height, strftime('%Y', wd.Date) AS Year, SUM((eo.Daily_Output / (0.5 * 1.225 * POWER(wd.Wind_Speed, 3) * PI() * POWER(wt.Rotor_Diameter / 2, 2))) * 100) AS Total_Efficiency_Change FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID JOIN energy_output eo ON wt.Turbine_ID = eo.Turbine_ID AND wd.Date = eo.Date GROUP BY wt.Turbine_ID, wt.Hub_Height, strftime('%Y', wd.Date) ORDER BY wt.Hub_Height, strftime('%Y', wd.Date);	wind_turbine	2
SELECT wt.Turbine_ID, wt.Hub_Height, AVG(pm.Capacity_Factor) AS Avg_Capacity_Factor, AVG(pm.Availability) AS Avg_Availability, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost FROM wind_turbines wt LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID GROUP BY wt.Turbine_ID, wt.Hub_Height HAVING wt.Hub_Height > (SELECT AVG(Hub_Height) FROM wind_turbines) ORDER BY wt.Hub_Height;	wind_turbine	3
SELECT wt.Turbine_ID, wt.Hub_Height, wt.Location, wt.Latitude, wt.Longitude, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost, AVG(pm.Noise_Level) AS Avg_Noise_Level, AVG(pm.Vibration_Level) AS Avg_Vibration_Level  FROM wind_turbines wt  LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID  LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID  WHERE wt.Hub_Height = 1000  GROUP BY wt.Turbine_ID, wt.Hub_Height, wt.Location, wt.Latitude, wt.Longitude;	wind_turbine	4
SELECT wt.Turbine_ID, wt.Rated_Power, wd.Wind_Speed, wt.Rated_Wind_Speed, (wt.Rated_Power * POWER(wd.Wind_Speed / wt.Rated_Wind_Speed, 3)) AS Actual_Power FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID;	wind_turbine	1
SELECT wt.Turbine_ID, wt.Rated_Power, strftime('%Y', wd.Date) AS Year, SUM(wt.Rated_Power * POWER(wd.Wind_Speed / wt.Rated_Wind_Speed, 3)) AS Total_Actual_Power_Change FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID GROUP BY wt.Turbine_ID, wt.Rated_Power, strftime('%Y', wd.Date) ORDER BY wt.Rated_Power, strftime('%Y', wd.Date);	wind_turbine	2
SELECT wt.Turbine_ID, wt.Rated_Power, AVG(pm.Capacity_Factor) AS Avg_Capacity_Factor, AVG(pm.Availability) AS Avg_Availability, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost FROM wind_turbines wt LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID WHERE wt.Rated_Power > (SELECT AVG(Rated_Power) FROM wind_turbines) GROUP BY wt.Turbine_ID, wt.Rated_Power ORDER BY wt.Rated_Power;	wind_turbine	3
SELECT wt.Turbine_ID, wt.Rated_Power, wt.Location, wt.Latitude, wt.Longitude, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost, AVG(pm.Noise_Level) AS Avg_Noise_Level, AVG(pm.Vibration_Level) AS Avg_Vibration_Level FROM wind_turbines wt LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID WHERE wt.Rated_Power = 100000 GROUP BY wt.Turbine_ID, wt.Rated_Power, wt.Location, wt.Latitude, wt.Longitude;	wind_turbine	4
SELECT wt.Turbine_ID, wt.Cut_In_Wind_Speed, 0.5 * 1.225 * PI() * POWER(wt.Rotor_Diameter / 2, 2) * POWER(wt.Cut_In_Wind_Speed, 3) AS Start_Power FROM wind_turbines wt;	wind_turbine	1
SELECT wt.Turbine_ID, wt.Cut_In_Wind_Speed, strftime('%Y', wd.Date) AS Year, SUM(0.5 * 1.225 * 3.141592653589793 * POWER(wt.Rotor_Diameter / 2, 2) * POWER(wt.Cut_In_Wind_Speed, 3)) AS Total_Start_Power_Change FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID GROUP BY wt.Turbine_ID, wt.Cut_In_Wind_Speed, strftime('%Y', wd.Date) ORDER BY wt.Cut_In_Wind_Speed, strftime('%Y', wd.Date);	wind_turbine	2
SELECT wt.Turbine_ID, wt.Cut_In_Wind_Speed, AVG(pm.Capacity_Factor) AS Avg_Capacity_Factor, AVG(pm.Availability) AS Avg_Availability, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost FROM wind_turbines wt LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID WHERE wt.Cut_In_Wind_Speed < (SELECT AVG(Cut_In_Wind_Speed) FROM wind_turbines) GROUP BY wt.Turbine_ID, wt.Cut_In_Wind_Speed ORDER BY wt.Cut_In_Wind_Speed;	wind_turbine	3
SELECT wt.Turbine_ID, wt.Cut_In_Wind_Speed, wt.Location, wt.Latitude, wt.Longitude, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost, AVG(pm.Noise_Level) AS Avg_Noise_Level, AVG(pm.Vibration_Level) AS Avg_Vibration_Level FROM wind_turbines wt LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID WHERE wt.Cut_In_Wind_Speed = 100 GROUP BY wt.Turbine_ID, wt.Cut_In_Wind_Speed, wt.Location, wt.Latitude, wt.Longitude;	wind_turbine	4
SELECT wt.Turbine_ID, wt.Cut_Out_Wind_Speed, 0.5 * 1.225 * 3.141592653589793 * POWER(wt.Rotor_Diameter / 2, 2) * POWER(wt.Cut_Out_Wind_Speed, 3) AS Stop_Power FROM wind_turbines wt;	wind_turbine	1
SELECT wt.Turbine_ID, wt.Cut_Out_Wind_Speed, strftime('%Y', wd.Date) AS Year, SUM(0.5 * 1.225 * PI() * POWER(wt.Rotor_Diameter / 2, 2) * POWER(wt.Cut_Out_Wind_Speed, 3)) AS Total_Stop_Power_Change FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID GROUP BY wt.Turbine_ID, wt.Cut_Out_Wind_Speed, strftime('%Y', wd.Date) ORDER BY wt.Cut_Out_Wind_Speed, strftime('%Y', wd.Date);	wind_turbine	2
SELECT wt.Turbine_ID, wt.Cut_Out_Wind_Speed, AVG(pm.Capacity_Factor) AS Avg_Capacity_Factor, AVG(pm.Availability) AS Avg_Availability, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost FROM wind_turbines wt LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID WHERE wt.Cut_Out_Wind_Speed > (SELECT AVG(Cut_Out_Wind_Speed) FROM wind_turbines) GROUP BY wt.Turbine_ID, wt.Cut_Out_Wind_Speed ORDER BY wt.Cut_Out_Wind_Speed;	wind_turbine	3
SELECT wt.Turbine_ID, wt.Cut_Out_Wind_Speed, wt.Location, wt.Latitude, wt.Longitude, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost, AVG(pm.Noise_Level) AS Avg_Noise_Level, AVG(pm.Vibration_Level) AS Avg_Vibration_Level FROM wind_turbines wt LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID WHERE wt.Cut_Out_Wind_Speed = 1000 GROUP BY wt.Turbine_ID, wt.Cut_Out_Wind_Speed, wt.Location, wt.Latitude, wt.Longitude;	wind_turbine	4
SELECT wt.Turbine_ID, wt.Rated_Wind_Speed, 0.5 * 1.225 * PI() * POWER(wt.Rotor_Diameter / 2, 2) * POWER(wt.Rated_Wind_Speed, 3) AS Rated_Output_Power FROM wind_turbines wt;	wind_turbine	1
SELECT wt.Turbine_ID, wt.Rated_Wind_Speed, strftime('%Y', wd.Date) AS Year, SUM(0.5 * 1.225 * 3.141592653589793 * POWER(wt.Rotor_Diameter / 2, 2) * POWER(wt.Rated_Wind_Speed, 3)) AS Total_Rated_Power_Change FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID GROUP BY wt.Turbine_ID, wt.Rated_Wind_Speed, strftime('%Y', wd.Date) ORDER BY wt.Rated_Wind_Speed, strftime('%Y', wd.Date);	wind_turbine	2
SELECT wt.Turbine_ID, wt.Rated_Wind_Speed, AVG(pm.Capacity_Factor) AS Avg_Capacity_Factor, AVG(pm.Availability) AS Avg_Availability, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost FROM wind_turbines wt LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID WHERE wt.Rated_Wind_Speed = (SELECT AVG(Rated_Wind_Speed) FROM wind_turbines) GROUP BY wt.Turbine_ID, wt.Rated_Wind_Speed ORDER BY wt.Rated_Wind_Speed;	wind_turbine	3
SELECT wt.Turbine_ID, wt.Rated_Wind_Speed, wt.Location, wt.Latitude, wt.Longitude, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost, AVG(pm.Noise_Level) AS Avg_Noise_Level, AVG(pm.Vibration_Level) AS Avg_Vibration_Level FROM wind_turbines wt LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID WHERE wt.Rated_Wind_Speed = 1000 GROUP BY wt.Turbine_ID, wt.Rated_Wind_Speed, wt.Location, wt.Latitude, wt.Longitude;	wind_turbine	4
SELECT wt.Turbine_ID, wt.Weight, wd.Wind_Speed, (0.5 * 1.225 * POWER(wd.Wind_Speed, 2) * wt.Rotor_Diameter * wt.Hub_Height) / (PI() * POWER(wt.Rotor_Diameter / 2, 2) * wt.Weight) AS Structural_Stress FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID;	wind_turbine	1
SELECT wt.Turbine_ID, wt.Weight, strftime('%Y', wd.Date) AS Year, SUM((0.5 * 1.225 * POWER(wd.Wind_Speed, 2) * wt.Rotor_Diameter * wt.Hub_Height) / (PI() * POWER(wt.Rotor_Diameter / 2, 2) * wt.Weight)) AS Total_Stress_Change FROM wind_turbines wt JOIN weather_data wd ON wt.Turbine_ID = wd.Turbine_ID GROUP BY wt.Turbine_ID, wt.Weight, strftime('%Y', wd.Date) ORDER BY wt.Weight, strftime('%Y', wd.Date);	wind_turbine	2
SELECT wt.Turbine_ID, wt.Weight, AVG(pm.Capacity_Factor) AS Avg_Capacity_Factor, AVG(pm.Availability) AS Avg_Availability, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost FROM wind_turbines wt LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID WHERE wt.Weight > (SELECT AVG(Weight) FROM wind_turbines) GROUP BY wt.Turbine_ID, wt.Weight ORDER BY wt.Weight;	wind_turbine	3
SELECT wt.Turbine_ID, wt.Weight, wt.Location, wt.Latitude, wt.Longitude, COUNT(ml.Log_ID) AS Maintenance_Count, SUM(ml.Cost) AS Total_Maintenance_Cost, AVG(pm.Noise_Level) AS Avg_Noise_Level, AVG(pm.Vibration_Level) AS Avg_Vibration_Level FROM wind_turbines wt LEFT JOIN maintenance_logs ml ON wt.Turbine_ID = ml.Turbine_ID LEFT JOIN performance_metrics pm ON wt.Turbine_ID = pm.Turbine_ID WHERE wt.Weight = 10000 GROUP BY wt.Turbine_ID, wt.Weight, wt.Location, wt.Latitude, wt.Longitude;	wind_turbine	4
SELECT Total_Disk_Area * Max_Disk_Loading AS Lift FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	1
SELECT (Max_Gross_Weight * 1.2) / Total_Disk_Area AS New_Max_Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	2
SELECT CASE WHEN Max_disk_Loading * Total_disk_area * 0.75 < Max_Gross_Weight THEN 'Not Suitable' ELSE 'Suitable' END AS Suitability FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	3
SELECT 10000 / Total_Disk_Area AS Extreme_Disk_Loading, 'The aircraft will likely stall or crash due to insufficient lift.' AS Consequence FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	4
SELECT ROUND((International_Passengers * 100.0 / Total_Passengers), 2) AS International_Passenger_Percentage FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Freight_Tonnes / Aircraft_Movements AS Average_Freight_Per_Movement FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	3
SELECT (Total_Passengers * 2 * 20) AS Total_Luggage_Weight, CEIL((Total_Passengers * 2 * 20) / 635) AS Required_Flights FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	4
SELECT (International_Passengers * POWER(1 + 0.015, 5) + Domestic_Passengers * POWER(1 + 0.02, 5) + Transit_Passengers * POWER(1 - 0.005, 5)) AS Total_Passengers_After_5_Years FROM airport WHERE Airport_Name = 'London Heathrow';	AirCraft	2
SELECT CASE WHEN Age + 7 <= 30 THEN 'may maintain the same level of competitive performance' ELSE 'may not maintain the same level of competitive performance' END AS Competitive_Status FROM pilot WHERE Name = 'Prof. Zackery Collina';	AirCraft	3
SELECT Aircraft, Max_Gross_Weight, Total_Disk_Area, Max_Disk_Loading FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT Total_Passengers / (1 + Change_2019 / 100) AS Total_Passengers_2019 FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Domestic_Passengers / 0.80 AS Total_Passengers FROM airport;	AirCraft	3
SELECT Max_Gross_Weight / Total_Disk_Area AS Max_Disk_Loading, Max_Gross_Weight / 10000000 AS Max_Disk_Loading_New FROM aircraft WHERE Max_Gross_Weight = 1000000 AND Total_Disk_Area = 1000000;	AirCraft	4
SELECT Max_Gross_Weight / Total_Disk_Area AS Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	1
SELECT strftime('%Y', 'now') - (Age - 17) AS Earliest_License_Year FROM pilot WHERE Age = 23;	AirCraft	4
SELECT Aircraft, CAST(SUBSTR(Max_Gross_Weight, INSTR(Max_Gross_Weight, '(') + 1, INSTR(Max_Gross_Weight, 'kg') - INSTR(Max_Gross_Weight, '(') - 1) AS REAL) * 9.81 AS Lift_Required FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT SUM(a.Total_Disk_Area) AS Total_Disk_Area, AVG(a.Total_Disk_Area) AS Avg_Disk_Area FROM "match" m JOIN aircraft a ON m.Winning_Aircraft = a.Aircraft_ID WHERE m.Location = 'MiraZayd, Abu Dhabi';	AirCraft	2
SELECT Airport_Name, (International_Passengers * 100.0 / Total_Passengers) AS International_Percentage, CASE WHEN (International_Passengers * 100.0 / Total_Passengers) > 90 THEN 'Yes' ELSE 'No' END AS Exceeds_90_Percent FROM airport WHERE Airport_Name = 'London Heathrow';	AirCraft	3
SELECT Aircraft, (Max_Gross_Weight/Total_Disk_Area) AS Calculated_Loading, Max_Disk_Loading, CASE WHEN (Max_Gross_Weight/Total_Disk_Area) > Max_Disk_Loading THEN 'Exceeded' ELSE 'Within Limit' END FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT (SUM(a.Freight_Tonnes * 1000) / SUM(a.Aircraft_Movements)) / COUNT(DISTINCT aa.Aircraft_ID) FROM airport a JOIN airport_aircraft aa ON a.Airport_ID = aa.Airport_ID WHERE a.Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Total_Passengers, (International_Passengers + Domestic_Passengers + Transit_Passengers) AS Sum_Passengers, CASE WHEN Total_Passengers = International_Passengers + Domestic_Passengers + Transit_Passengers THEN 'Match' ELSE 'Mismatch' END FROM airport;	AirCraft	3
SELECT (600000*9.8)/0.01/101325 AS Atmospheric_Pressure_Multiples;	AirCraft	4
SELECT 0.5*(0.3*Max_Gross_Weight)*POWER(5,2)*POWER((2*3.141592653589793*300/60),2) AS Rotational_Energy FROM aircraft WHERE Aircraft='RobinsonR-22';	AirCraft	1
WITH cte AS (SELECT COUNT(*) AS total, SUM(CASE WHEN p.Age=23 THEN 1 ELSE 0 END) AS wins FROM match m JOIN pilot p ON m.Winning_Pilot = p.Pilot_id WHERE strftime('%Y', m.Date) = '2023') SELECT ROUND(wins*1.0/total,3) AS p_value, ROUND(1.96 * SQRT((wins*1.0/total) * (1 - wins*1.0/total) / total), 3) AS margin FROM cte;	AirCraft	2
SELECT Transit_Passengers / (Aircraft_Movements / 365.0) AS Daily_Transit_Per_Movement FROM airport;	AirCraft	3
SELECT (1e15 * 0.5) / (5.1e14) AS Earth_Surface_Multiples;	AirCraft	4
SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;	AlarmSystem	1
WITH FilteredData AS (     SELECT SeverityLevel      FROM WarningEvent      WHERE SeverityLevel > 8 )  SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold,      AVG(SeverityLevel) - (2.576 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound,      AVG(SeverityLevel) + (2.576 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound  FROM FilteredData;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR PopulationAffected > 1000000 OR EstimatedDamageUSD > 10000000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (RadiusKm * 1000) / 10 AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 50;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 20000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'tornado' AND SeverityLevel = 6;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 50000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 5.0 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'earthquake' AND RadiusKm = 100;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 8000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 0.1 AS SpreadTimeMinutes FROM WarningEvent WHERE EventType = 'fire' AND RadiusKm = 2;	AlarmSystem	1
SELECT AVG(PopulationAffected) AS AveragePopulationAffected FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'typhoon' AND SeverityLevel = 5;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD BETWEEN 3000000.00 AND 7000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageWithinRange FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'earthquake' AND SeverityLevel = 7;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (20 / 0.01) * (1 - EXP(-0.01 * (500 * 1000 / 20))) AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 500;	AlarmSystem	1
WITH FilteredEvents AS (SELECT EstimatedDamageUSD FROM WarningEvent WHERE EstimatedDamageUSD > 1000000000.00) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, SUM(EstimatedDamageUSD) AS TotalDamageAboveThreshold FROM FilteredEvents;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'nuclear leak' AND SeverityLevel = 10;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT ThresholdValue / 10 AS TimeToThresholdHours FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;	AlarmSystem	1
SELECT (COUNT(CASE WHEN ThresholdValue > 8000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningRule;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 1000 AND ActionType = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'nuclear leak' AND ThresholdValue > 100 AND ThresholdUnit = 'millisieverts') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT 100 / 5 AS PropagationTimeSeconds, POWER(10, 1.5 * ThresholdValue + 4.8) AS EarthquakeEnergy FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue = 5.0;	AlarmSystem	1
WITH FilteredRules AS (     SELECT ThresholdValue      FROM WarningRule      WHERE ThresholdValue > 800.0 )  SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningRule)) AS PercentageAboveThreshold,      SUM(ThresholdValue) AS TotalThresholdAbove  FROM FilteredRules;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'tsunami' AND ThresholdValue = 10 AND ActionType = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'volcanic eruption' AND ThresholdValue > 100 AND ThresholdUnit = 'kilometer') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT ThresholdValue AS RequiredRainfall FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;	AlarmSystem	1
SELECT AVG(ThresholdValue) AS AverageThresholdValue FROM WarningRule;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 100 AND ActionType = 'notification';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue > 9.0 AND ThresholdUnit = 'Richter scale') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT TriggerValue / 50 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 1000;	AlarmSystem	1
SELECT (COUNT(CASE WHEN TriggerValue > 80000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningTriggerRecord;	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT LN(TriggerValue / 0.0001) / 0.1 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 5000;	AlarmSystem	1
WITH FilteredRecords AS (     SELECT TriggerValue      FROM WarningTriggerRecord      WHERE TriggerValue > 100000 )  SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningTriggerRecord)) AS PercentageAboveThreshold,      SUM(TriggerValue) AS TotalTriggerValueAbove  FROM FilteredRecords;	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	3
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	4
SELECT TriggerValue / 10 AS RequiredTime FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'millimeters';	AlarmSystem	1
SELECT AVG(TriggerValue) AS AverageTriggerValue FROM WarningTriggerRecord WHERE TriggerValue IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 50 AND TriggerUnit = 'Celsius' AND ActionTaken = 'notification';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount  FROM WarningTriggerRecord  WHERE TriggerValue > 100  AND TriggerUnit = 'millisieverts'  AND TriggerTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (100 * 1000) / POWER(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 80000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'people';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (1000 * 1000) / POWER(3, 8) AS PropagationTime, EXP(-0.001 * 1000) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage, SUM(RecipientCount) AS TotalRecipients FROM WarningNotificationRecord WHERE RecipientCount > 1000000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast' AND RecipientType = 'people';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';	AlarmSystem	4
SELECT (10 * 1000) / POWER(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS';	AlarmSystem	1
SELECT AVG(RecipientCount) AS AverageRecipientCount FROM WarningNotificationRecord WHERE RecipientCount IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'email' AND RecipientType = 'enterprise';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 100000 AND NotificationTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (500 * 1000) / POWER(3, 8) AS PropagationTime, EXP(-0.0005 * 500) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 800000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'government';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (100 * 1000) / 5 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 7;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'earthquake' AND AverageSeverity = 6 AND FalseAlarmRate = 5;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (1000 * 1000) / 200 AS PropagationTime, EXP(-0.01 * 1000) AS EnergyAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'tsunami' AND MaxSeverity = 10;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage, SUM(AverageSeverity) AS TotalAverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'nuclear leak' AND MaxSeverity = 10 AND FalseAlarmRate = 0.1;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';	AlarmSystem	4
SELECT (500 * 1000) / 10 AS DiffusionTime, EXP(-0.005 * ((500 * 1000) / 10)) AS ConcentrationAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'volcanic eruption' AND MaxSeverity = 9;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE MaxSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'tornado' AND MaxSeverity = 8 AND FalseAlarmRate = 2;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (50 * 1000) / 2 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 5;	AlarmSystem	1
SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0);	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 4 AND FalseAlarmRate = 3;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 5 AS PropagationTime FROM WarningEvent WHERE EventType = 'earthquake';	AlarmSystem	1
SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0);	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 3 AND FalseAlarmRate = 1;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (20.0 / (2 * 3.14159 * (SELECT Vibration_Frequency FROM bridge WHERE Name = 'Golden Gate Bridge'))) * ((SELECT Length_Meters FROM bridge WHERE Name = 'Golden Gate Bridge') / 1000.0) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * (SELECT Blade_Length FROM mill WHERE Name = 'Moulin de Bruges') * ((SELECT Rotation_Speed FROM mill WHERE Name = 'Moulin de Bruges') / 60.0) AS Moulin_Tip_Speed;	architect	1
SELECT (Load_Capacity / Length_Meters) AS Avg_Load_Per_Meter, (Power_Output / (0.5 * 1.225 * (3.14159 * (Blade_Length * Blade_Length)) * (Wind_Speed * Wind_Speed * Wind_Speed))) * 100 AS Energy_Efficiency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';	architect	2
SELECT Cost_Usd + (Maintenance_Cost * 100) AS Total_Cost_Millau_Viaduct, (SELECT Cost_Usd + (Maintenance_Cost * 50) FROM mill WHERE Name = 'Moulin de Momalle') AS Total_Cost_Moulin_de_Momalle FROM bridge WHERE Name = 'Millau Viaduct';	architect	3
SELECT (1000 / (2 * 3.14159 * 100)) * (100000 / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * 1000 * (1000 / 60) AS Moulin_Tip_Speed;	architect	4
SELECT 0.5 * 1.225 * POWER(10, 2) * span_length_meters * height_meters AS Wind_Load, 0.5 * (14 * 50) * POWER(2 * 3.14159 * 14 * (20.0 / 60), 2) AS Blade_Kinetic_Energy FROM bridge WHERE name = 'Millau Viaduct';	architect	1
SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM bridge WHERE Name = 'Golden Gate Bridge' UNION ALL SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM mill WHERE Name = 'Moulin de Momalle';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN 'Wooden structures have lower maintenance costs but poorer durability' END AS Maintenance_Analysis FROM bridge WHERE Name = 'Charles Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN 'Wooden structures have lower maintenance costs but poorer durability' END AS Maintenance_Analysis FROM mill WHERE Name = 'Moulin de Fexhe';	architect	3
SELECT 0.5 * 1.225 * POWER(1000, 2) * 100000 * 10000 AS Wind_Load, 0.5 * (1000 * 50) * POWER(2 * 3.14159 * 1000 * (10000 / 60), 2) AS Blade_Kinetic_Energy;	architect	4
SELECT 0.5 * 500000 * POWER(15 / (2 * 3.14159 * 0.25), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POWER(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Drag FROM bridge WHERE Name = 'Tower Bridge';	architect	1
SELECT 0.5 * 1000000000 * POWER(100000 / (2 * 3.14159 * 1000), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POWER(2 * 3.14159 * 10000 * (100000 / 60), 2) * (10000 * 2) AS Aerodynamic_Drag;	architect	4
SELECT 10.0 / (2.0 * 3.14159 * 343.0) AS Wind_Induced_Vibration_Frequency, 0.5 * 1.225 * POWER(2.0 * 3.14159 * 14.0 * (20.0 / 60.0), 2) * (14.0 * 2.0) AS Aerodynamic_Lift FROM bridge WHERE Name = 'Millau Viaduct';	architect	1
SELECT Load_Capacity / (Length_Meters * 20) AS Load_Per_Square_Meter, Power_Output / (0.5 * 1.225 * POWER(6.5, 3) * (3.14159 * POWER(Blade_Length, 2))) AS Wind_Energy_Utilization FROM bridge, mill WHERE bridge.Name = 'Forth Bridge' AND mill.Name = 'Moulin de Pousset';	architect	2
SELECT (10 / (2 * 3.14159 * Height_Meters)) AS Natural_Frequency, (SELECT 2 * 3.14159 * Blade_Length_Meters * (Rotation_Speed / 60) FROM mill WHERE Name = 'Moulin de Bruges') AS Tip_Speed FROM bridge WHERE Name = 'Charles Bridge';	architect	1
SELECT (Maintenance_Cost * 100) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM bridge WHERE Name = 'Akashi Kaikyō Bridge' UNION ALL SELECT (Maintenance_Cost * 50) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM mill WHERE Name = 'Moulin de Momalle';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Rialto Bridge' THEN '高维护成本可能由于高使用强度、环境腐蚀或文物保护需求较高' WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Rialto Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin de Pousset';	architect	3
SELECT 0.5 * 1e12 * POW(100000 / 1000, 2) AS Vortex_Induced_Vibration_Energy, 8000 * POW(2 * 3.14159 * 100000 / 60, 2) * POW(10000, 2) / 2 AS Centrifugal_Stress;	architect	4
SELECT (12 * Span_Length) / (Vibration_Frequency * 1000) AS Harmonic_Number, (Blade_Length * Rotation_Speed) / 60 AS Critical_Frequency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';	architect	1
SELECT Maintenance_Cost * (POWER(1.02, 50) - 1) / 0.02 AS Total_Maintenance_Cost_Golden_Gate, (SELECT Maintenance_Cost * (POWER(1.05, 50) - 1) / 0.05 FROM mill WHERE Name = 'Moulin de Pousset') AS Total_Maintenance_Cost_Moulin FROM bridge WHERE Name = 'Golden Gate Bridge';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'High maintenance costs may be due to anti-corrosion treatment, load monitoring, and higher structural complexity' WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Sydney Harbour Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin d''Amsterdam';	architect	3
SELECT (1e9 * 1e6) / (6.62607015e-34 * 1e34) AS Quantum_Vibration_Modes, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) >= 299792458 THEN 'Faster than light, correction factor cannot be calculated' ELSE 'Not exceeding the speed of light requires relativistic corrections' END AS Relativity_Check, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) < 299792458 THEN 1 / SQRT(1 - ((2 * 3.14159 * 1e8 * (1e12 / 60)) / 299792458) * ((2 * 3.14159 * 1e8 * (1e12 / 60)) / 299792458)) ELSE 'N/A' END AS Relativity_Correction_Factor;	architect	4
SELECT (0.2 * Vibration_Frequency) / span_length_meters AS Vortex_Shedding_Frequency, 343 / (Rotation_Speed / 60) AS Infrasound_Wavelength FROM bridge, mill WHERE bridge.name = 'Tower Bridge' AND mill.name = 'Moulin de Bruges';	architect	1
SELECT (Maintenance_Cost * POWER(1 + 0.05, 25)) / Cost_Usd * 100 AS Maintenance_Cost_Percentage_Akashi, (SELECT Maintenance_Cost * POWER(1 + 0.08, 25) / Cost_Usd * 100 FROM mill WHERE Name = 'Moulin d''Amsterdam') AS Maintenance_Cost_Percentage_Amsterdam FROM bridge WHERE Name = 'Akashi Kaikyō Bridge';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Stone' THEN 'Stone maintenance costs are low due to its gradual failure mode and lack of need for complex anti-corrosion treatment' WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Ponte Vecchio' UNION ALL SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Forth Bridge';	architect	3
SELECT (6.67430e-11 * 1e41 * 1e17) / (1e25 * 1e25 * 1e25) AS Tidal_Resonance_Frequency, (1e40 * 14 / 60) * (1e40 * 14 / 60) / (299792458 * 299792458 * 299792458 * 299792458) AS Spacetime_Curvature_Rate;	architect	4
SELECT (LN(10.0 * b.Cost_Usd / b.Maintenance_Cost) / LN(1.02)) AS Years_To_10x_GoldenGate, POWER(1.02, 50) AS Multiplier_50y_GoldenGate, (LN(10.0 * m.Cost_Usd / m.Maintenance_Cost) / LN(1.05)) AS Years_To_10x_Amsterdam, POWER(1.05, 50) AS Multiplier_50y_Amsterdam FROM bridge b, mill m WHERE b.Name = 'Golden Gate Bridge' AND m.Name = 'Moulin d''Amsterdam';	architect	2
SELECT 0.5 * p.AerodynamicDrag * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT r.RidingStyle, (r.RiderPowerOutput + (t.MotorEfficiency / 100.0 * t.BatteryCapacity)) * 2 AS TotalEnergyConsumption FROM BicycleRider r JOIN BicycleThermodynamics t ON r.BicycleID = t.BicycleID;	bike	2
SELECT b.BicycleID, CASE WHEN (b.Weight + r.RiderWeight + b.MaxLoad) / 0.02 > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 5 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, (75 + 15) * 9.81 * (p.TopSpeed * 1000 / 3600) * 0.10 AS ClimbingPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'Mountain bike';	bike	1
SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER(p.TopSpeed * 1000.0 / 3600.0, 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics WHERE BatteryCapacity = 500;	bike	2
SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000.0 / 3600.0), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT t.AmbientTemperature, 500.0 / (100 + (250.0 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;	bike	2
SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000.0 / 3600.0), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 0.5 * (b.Weight + b.MaxLoad) * ((p.TopSpeed * 1000.0 / 3600.0) * (p.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'electric vehicle';	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID;	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100;	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' ORDER BY KineticEnergy DESC LIMIT 5;	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID ORDER BY ActualPower DESC LIMIT 10;	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID ORDER BY ContactArea ASC LIMIT 5;	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100 ORDER BY NewCenterOfGravityHeight DESC LIMIT 3;	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) > (SELECT MAX(0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0))) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Mountain bike');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > (SELECT MAX(BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100) FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Road bike');	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < (SELECT MIN(BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2)) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX');	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > (SELECT MAX(BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500)) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'No suspension');	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) > (SELECT MAX(0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0))) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 AS ActualPower  FROM Bicycle  JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID  JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.Type = 'Hybrid vehicle'  AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 > (     SELECT MAX(sub.RiderPowerOutput * sub.PowerTransferEfficiency / 100.0)      FROM Bicycle AS b      JOIN BicycleRider AS sub ON b.BicycleID = sub.BicycleID      JOIN BicyclePerformance AS perf ON b.BicycleID = perf.BicycleID      JOIN BicycleComponents AS comp ON b.BicycleID = comp.BicycleID      WHERE b.Type = 'Road bike' AND comp.RimMaterial = 'aluminum alloy' );	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < (     SELECT MIN(BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2))     FROM Bicycle     JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID     WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢' );	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight  FROM Bicycle  JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID  JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.SuspensionType = 'Full suspension'  AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > (     SELECT MAX(BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500))      FROM Bicycle      JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID      JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID      JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID      WHERE Bicycle.SuspensionType = 'No suspension'      AND BicycleComponents.HandlebarMaterial = 'Titanium alloy' );	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) > (SELECT MAX(0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0))) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > (SELECT MAX(BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100) FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < (SELECT MIN(BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2)) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > (SELECT MAX(BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500)) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');	bike	4
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) AS HeatGenerated  FROM Bicycle  JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID  JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.Type = 'electric vehicle'  AND BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) > (     SELECT MAX(BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100))      FROM Bicycle      JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID      JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID      JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID      WHERE Bicycle.Type = 'Mountain bike'      AND BicycleComponents.FrameMaterial = 'Carbon fiber' );	bike	1
SELECT Bicycle.BicycleID, BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 AS UsableEnergy FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 > (SELECT MAX(BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');	bike	2
SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) AS MotorTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) < (SELECT MAX(BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency)) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');	bike	3
SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (1000.0 / BicycleThermodynamics.HeatDissipationRate) AS BatteryTemperature  FROM Bicycle  JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.SuspensionType = 'Full suspension'  AND BicycleThermodynamics.AmbientTemperature + (1000.0 / BicycleThermodynamics.HeatDissipationRate) > (     SELECT MAX(BicycleThermodynamics.AmbientTemperature + (1000.0 / BicycleThermodynamics.HeatDissipationRate))      FROM Bicycle      JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID      JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID      WHERE Bicycle.SuspensionType = 'No suspension'      AND BicycleComponents.HandlebarMaterial = 'Titanium alloy' );	bike	4
SELECT AmbientTemperature, MotorTemperature FROM BicycleThermodynamics WHERE MotorEfficiency = 85 AND BatteryCapacity = 500 AND HeatDissipationRate = 200 AND AmbientTemperature BETWEEN 10 AND 40;	bike	1
SELECT Type, RidingStyle, AVG(RiderPowerOutput) AS AvgPowerOutput FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100.0)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 1000 AND MotorEfficiency = 90 AND HeatDissipationRate = 500 AND AmbientTemperature = 50 AND MotorTemperature = 100 AND RiderPowerOutput = 500;	bike	4
SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100.0))) * 100.0 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;	bike	1
SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100.0)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;	bike	4
SELECT AerodynamicDrag, RollingResistance, (300 * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance bp JOIN Bicycle b ON bp.BicycleID = b.BicycleID JOIN BicycleComponents bc ON b.BicycleID = bc.BicycleID WHERE bc.TireWidth = 28 AND b.TirePressure = 60;	bike	1
SELECT Type, RidingStyle, AVG((RiderPowerOutput / (RiderWeight * 9.81 * 0.1)) * 100) AS ClimbingEfficiency FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;	bike	3
SELECT MaxLoad, ((Weight + MaxLoad) * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Weight = 20 AND TirePressure = 70 AND TireWidth = 32 AND MaxLoad BETWEEN 100 AND 500;	bike	4
SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100.0))) * 100.0 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;	bike	1
SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100.0)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;	bike	4
SELECT RidingStyle, RiderPowerOutput, (RiderPowerOutput * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance JOIN BicycleRider ON BicyclePerformance.BicycleID = BicycleRider.BicycleID WHERE AerodynamicDrag = 0.5 AND RollingResistance = 0.01 AND PowerTransferEfficiency = 95;	bike	1
SELECT CASE WHEN RiderAge BETWEEN 20 AND 30 THEN '20-30' WHEN RiderAge BETWEEN 31 AND 40 THEN '31-40' WHEN RiderAge BETWEEN 41 AND 50 THEN '41-50' END AS RiderAgeGroup, RidingStyle, AVG(RiderCadence) AS AvgCadence FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') GROUP BY RiderAgeGroup, RidingStyle;	bike	2
SELECT RidingStyle, (10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END * 1 AS EnergyConsumption FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road');	bike	3
SELECT RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / MotorEfficiency) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 5000 AND MotorEfficiency = 99 AND HeatDissipationRate = 2000 AND AmbientTemperature = 80 AND MotorTemperature = 250 AND RiderPowerOutput BETWEEN 1000 AND 5000;	bike	4
SELECT ((100 * 9.81 * SIN(ATAN(0.1))) + (100 * 9.81 * 0.005 * COS(ATAN(0.1))) + (0.5 * 1.225 * 0.3 * 0.5 * POWER((5 + (TopSpeed * 0.277778)), 2))) * (TopSpeed * 0.277778) / 0.8 AS MinPower FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'Mountain bike');	bike	1
SELECT BicycleID, (PowerTransferEfficiency / AerodynamicDrag) AS EfficiencyRatio FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Price < 10000) ORDER BY EfficiencyRatio DESC LIMIT 3;	bike	2
SELECT BicycleID FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND Weight < (SELECT AVG(Weight) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike') AND Price < (SELECT AVG(Price) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike');	bike	3
SELECT 'Asphalt road' AS Surface, ((0.004 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Gravel Road' AS Surface, ((0.02 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Muddy ground' AS Surface, ((0.05 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance;	bike	4
SELECT b.BicycleID, (b.Weight + r.RiderWeight) / (b.TirePressure * 0.07030695796) AS Tire_Pressure_Impact FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	1
SELECT b.BicycleID, (r.RiderPowerOutput * p.PowerTransferEfficiency) / (p.AerodynamicDrag * p.RollingResistance) AS TopSpeed_Theoretical FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	2
SELECT b.Type, r.RidingStyle, COUNT(*) AS Match_Count FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID GROUP BY b.Type, r.RidingStyle ORDER BY Match_Count DESC;	bike	3
SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 1.0 / d.CenterOfGravityHeight AS Cornering_Stability_Impact FROM Bicycle b JOIN BicycleDynamics d ON b.BicycleID = d.BicycleID;	bike	1
SELECT b.BicycleID, r.RiderPowerOutput * p.PowerTransferEfficiency AS Power_Output_Effective FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY Power_Output_Effective DESC LIMIT 1;	bike	2
SELECT b.Type, r.RiderName FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID WHERE b.MaxLoad > r.RiderWeight;	bike	3
SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000.0) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID ORDER BY ABS(p.BrakingDistance - (p.BrakingDistance * (b.TirePressure / 1000.0))) DESC LIMIT 1;	bike	4
SELECT 0.5 * 1.225 * POWER(TopSpeed * 0.277778, 2) * 0.9 * 0.5 AS AirResistance FROM BicyclePerformance JOIN Bicycle ON BicyclePerformance.BicycleID = Bicycle.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT 250 * (PowerTransferEfficiency / 100) AS ActualPower FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);	bike	2
SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 120 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	3
SELECT POWER(100 * 0.277778, 2) / (2 * 2.0 * 9.8 * 2) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');	bike	4
SELECT 0.5 * (Bicycle.Weight + BicycleRider.RiderWeight) * POWER(BicyclePerformance.TopSpeed * 0.277778, 2) AS KineticEnergy FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT (Bicycle.Price + (2000 * 0.5 * 5)) / (2000 * 5) AS CostBenefitRatio FROM Bicycle WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);	bike	2
SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.MaxLoad + BicycleRider.RiderWeight) <= 100 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	3
SELECT POWER(200 * 0.277778, 2) / (2 * 3.0 * 9.8 * 3) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000.0 / 3600.0), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT Type, AVG(PowerTransferEfficiency) AS AvgEfficiency FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgEfficiency DESC LIMIT 1;	bike	2
SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' GROUP BY Manufacturer;	bike	3
SELECT Bicycle.BicycleID, (BicycleComponents.TireWidth * 1000) / 1000 AS NewContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;	bike	4
SELECT Bicycle.BicycleID, (BicycleRider.RiderWeight + Bicycle.Weight) / Bicycle.TirePressure AS ContactArea FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	1
SELECT Type, AVG(RollingResistance) AS AvgRollingResistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgRollingResistance ASC LIMIT 1;	bike	2
SELECT Manufacturer, AVG(BrakingDistance) AS AvgBrakingDistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE BrakeType = 'Disc brakes' GROUP BY Manufacturer;	bike	3
SELECT Bicycle.BicycleID, (100000 - BicycleThermodynamics.BatteryCapacity) * BicycleThermodynamics.MotorEfficiency / BicycleRider.RiderPowerOutput AS RangeIncrease FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	4
SELECT BicycleID, Manufacturer, Model, (75 * 50 + 10 * 50) / (75 + 10 + MaxLoad) AS CenterOfGravityHeight FROM Bicycle WHERE FrameMaterial = 'Carbon fiber';	bike	1
SELECT b.BicycleID, b.Manufacturer, b.Model, p.PowerTransferEfficiency * r.RiderPowerOutput AS ActualPowerOutput FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY ActualPowerOutput DESC LIMIT 5;	bike	2
SELECT Manufacturer, Model, TirePressure FROM Bicycle WHERE TirePressure < 60;	bike	3
SELECT BicycleID, Manufacturer, Model, (1000.0 * 1000.0) / (2.0 * (0.01 + 0.5) * 9.81) AS BrakingDistance FROM Bicycle;	bike	4
SELECT d.BicycleID, b.Manufacturer, b.Model, r.RiderWeight, d.Wheelbase, d.SteeringAngle, (d.Wheelbase / (2 * SIN(d.SteeringAngle * PI() / 180))) AS MinTurningRadius FROM BicycleDynamics d JOIN Bicycle b ON d.BicycleID = b.BicycleID JOIN BicycleRider r ON d.BicycleID = r.BicycleID;	bike	1
SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency / 100) / (r.RiderPowerOutput / 1000.0) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;	bike	2
SELECT b.Manufacturer, AVG(b.Price) AS AvgPrice FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.SuspensionType = 'Full suspension' AND b.Type = 'Mountain bike' AND c.TireWidth > 50 AND c.RimMaterial = 'aluminum alloy' GROUP BY b.Manufacturer;	bike	3
SELECT th.BicycleID, (5000 * (1 - th.MotorEfficiency/100) + (200 - 25) * 50) AS RequiredDissipation FROM BicycleThermodynamics th WHERE th.MotorTemperature < 100;	bike	4
SELECT b.BicycleID, b.Manufacturer, b.Model, 0.5 * p.AerodynamicDrag * 1.225 * POWER(p.TopSpeed/3.6, 3) * (c.TireWidth/1000 * b.HandlebarWidth/100) AS AirPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleComponents c ON b.BicycleID = c.BicycleID ORDER BY AirPower DESC LIMIT 5;	bike	1
SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency / 100.0) / r.RiderPowerOutput) AS EnergyRecovery FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;	bike	2
SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND TirePressure > 80 GROUP BY Manufacturer;	bike	3
SELECT BicycleID, (100 - (25 - (-50)) * 0.5) AS CapacityRemaining FROM BicycleThermodynamics WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'electric vehicle');	bike	4
SELECT b.BicycleID, b.Manufacturer, b.Model, ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance)*100 AS Deviation, p.BrakingDistance AS ActualDistance, POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) AS TheoreticalDistance FROM BicyclePerformance p JOIN Bicycle b ON p.BicycleID = b.BicycleID WHERE ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance) > 0.1;	bike	1
SELECT CAST(th.AmbientTemperature / 10 AS INTEGER) * 10 AS TempRange, AVG(th.BatteryCapacity * (1 - 0.005 * POWER(ABS(th.AmbientTemperature - 25), 1.2)) * th.MotorEfficiency / 100 / (r.RiderPowerOutput / 1000.0) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY TempRange ORDER BY TempRange;	bike	2
SELECT b.BicycleID, b.Manufacturer, b.Model, b.SuspensionType, c.TireWidth  FROM Bicycle b  JOIN BicycleComponents c ON b.BicycleID = c.BicycleID  WHERE b.Type = 'Mountain bike'  AND ((b.SuspensionType = 'Full suspension' AND c.TireWidth <= 50) OR (b.SuspensionType = 'No suspension' AND c.TireWidth >= 40));	bike	3
SELECT th.BicycleID, (r.RiderPowerOutput/(th.MotorEfficiency/100.0) * 3600 * (1 - th.MotorEfficiency/100.0)) / (500 * 0.9) + 60 AS TheoreticalTemp FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' AND b.MaxLoad >= 500;	bike	4
SELECT Model, Compression_Ratio, (1 - (1/POWER(Compression_Ratio, 0.4))) AS Thermal_Efficiency FROM engine WHERE Compression_Ratio BETWEEN 10 AND 12 AND Fuel_Type = 'Gasoline' ORDER BY Compression_Ratio ASC;	car_engine	1
SELECT Model, Displacement, (3.141592653589793 * (Bore/20.0) * (Bore/20.0) * Stroke/10.0)/1000.0 AS 单缸排量, ABS(Displacement - (3.141592653589793 * (Bore/20.0) * (Bore/20.0) * Stroke/10.0)/1000.0 * Cylinders) AS error FROM engine WHERE Configuration = 'Inline' AND Cylinders = 6 ORDER BY error DESC LIMIT 5;	car_engine	2
SELECT e.Model, e.Aspiration, ep.Specific_Power FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND m.Block_Material = 'Cast Iron' ORDER BY ep.Specific_Power DESC LIMIT 10;	car_engine	3
SELECT Model, Stroke, (2 * Stroke * 100000) / 60000 AS Piston_Speed FROM engine WHERE (2 * Stroke * 100000) / 60000 > 343 ORDER BY Piston_Speed DESC;	car_engine	4
SELECT e.Model, (ed.Length * ed.Width * ed.Height) AS Volume, e.Compression_Ratio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY Volume DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * 3.141592653589793 * POWER(e.Bore/2000.0, 2) + 2 * 3.141592653589793 * (e.Bore/2000.0) * (e.Stroke/1000.0)) * e.Cylinders * 2 AS TotalSurfaceArea FROM engine e WHERE e.Configuration LIKE 'V%' ORDER BY TotalSurfaceArea ASC LIMIT 5;	car_engine	2
SELECT e.Model, (e.Horsepower / e.Weight) AS PowerWeightRatio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > 150 AND ed.Length < 600 ORDER BY PowerWeightRatio DESC;	car_engine	3
SELECT e.Model, (ed.Length * ed.Width * ed.Height) + (10000 * e.Cylinders) AS VirtualVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY VirtualVolume DESC LIMIT 2;	car_engine	4
SELECT e.Manufacturer, AVG((ed.Length / 100.0) * (ed.Width / 100.0) * (ed.Height / 100.0)) AS AvgVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Manufacturer ORDER BY AvgVolume DESC LIMIT 1;	car_engine	1
SELECT e.Cylinders, ABS(((e.Cylinders - 1) * ed.Cylinder_Spacing + (e.Bore * e.Cylinders)) - ed.Length) AS DeltaL FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'Inline' ORDER BY DeltaL DESC LIMIT 5;	car_engine	2
SELECT e.Manufacturer, COUNT(*) AS AnomalyCount FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > ((ed.Length / 100.0) * (ed.Width / 100.0) * (ed.Height / 100.0)) * 7.3 GROUP BY e.Manufacturer;	car_engine	3
SELECT e.Engine_ID, ((10000-1)*12742000000 + e.Bore)/40075000000.0 AS Circles FROM engine e;	car_engine	4
SELECT e.Engine_ID, e.Model, (2 * PI() * ed.Max_turn) / 60 AS Angular_Velocity, em.Crankshaft_Material FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE ((2 * PI() * ed.Max_turn) / 60) > CASE WHEN em.Crankshaft_Material = 'Forged Steel' THEN 1000 WHEN em.Crankshaft_Material = 'Cast Iron' THEN 800 ELSE 500 END;	car_engine	1
SELECT e.Engine_ID, e.Model, (ep.BMEP * 100000.0 * e.Displacement * ed.Peak_Power * 0.00001667) / (ep.Fuel_Consumption * 34200000.0) * 100.0 AS Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power >= 100;	car_engine	2
SELECT Engine_ID, Model, Compression_Ratio, Fuel_Type FROM engine WHERE Compression_Ratio > 14 AND Fuel_Type = 'Gasoline';	car_engine	3
SELECT e.Engine_ID, e.Model, 2 * e.Stroke * (1800000000/60)/1000 AS Piston_Speed, em.Piston_Material FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE 2 * e.Stroke * (1800000000/60)/1000 > CASE WHEN em.Piston_Material = 'Aluminum' THEN 25 WHEN em.Piston_Material = 'Steel' THEN 30 ELSE 0 END;	car_engine	4
SELECT m.Block_Material, m.Coating_Type, AVG(t.Heat_Rejection_Rate) AS Avg_Heat_Rejection_Rate FROM enginematerials m JOIN enginethermodynamics t ON m.Engine_ID = t.Engine_ID WHERE m.Block_Material IN ('Cast Iron', 'Aluminum') GROUP BY m.Block_Material, m.Coating_Type ORDER BY Avg_Heat_Rejection_Rate DESC;	car_engine	1
WITH Total AS (   SELECT COUNT(*) AS TotalCount    FROM enginematerials    WHERE Crankshaft_Material = 'Forged Steel' AND Connecting_Rod_Material = 'Titanium' ) SELECT m.Block_Material,         m.Connecting_Rod_Material,         COUNT(*) AS Count,         ROUND((COUNT(*) * 100.0 / (SELECT TotalCount FROM Total)), 2) AS Percentage  FROM enginematerials m  WHERE m.Crankshaft_Material = 'Forged Steel' AND m.Connecting_Rod_Material = 'Titanium'  GROUP BY m.Block_Material, m.Connecting_Rod_Material;	car_engine	2
SELECT CASE WHEN e.Compression_Ratio < 10 THEN 'Low (<10)' WHEN e.Compression_Ratio BETWEEN 10 AND 12 THEN 'Medium (10-12)' WHEN e.Compression_Ratio > 12 THEN 'High (>12)' END AS Compression_Ratio_Range, COUNT(*) AS Engine_Count FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND m.Piston_Material IN ('Aluminum', 'Forged Aluminum') GROUP BY Compression_Ratio_Range ORDER BY MIN(e.Compression_Ratio);	car_engine	3
SELECT Cylinders, SUM(10000 * 0.0005 * Cylinders) AS Total_Piston_Weight FROM engine GROUP BY Cylinders ORDER BY Cylinders;	car_engine	4
SELECT (2*(80*205)/(80+205)) * 0.5 * 200 / 0.01 AS Heat_Flow FROM enginematerials WHERE Block_Material = 'Cast Iron' AND Head_Material = 'Aluminum';	car_engine	1
SELECT (0.002*2700 + 0.001*4500) AS Total_Mass, CASE WHEN (0.002*2700 + 0.001*4500) <= 5 THEN 'Satisfaction' ELSE 'Unsatisfied' END AS 质量判定 FROM enginematerials WHERE Piston_Material = 'Forged Aluminum' AND Connecting_Rod_Material = 'Titanium';	car_engine	2
SELECT e.Model, e.Compression_Ratio, em.Head_Material, et.Thermal_Conductivity FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Compression_Ratio >= 12 AND em.Head_Material = 'Aluminum' AND et.Thermal_Conductivity > 150;	car_engine	3
SELECT ed.Main_Bore_Diameter, 500*(1+0.0001*(1000-20)) AS 膨胀后长度, CASE WHEN 500*(1+0.0001*980) <= ed.Main_Bore_Diameter THEN '可配合' ELSE '不可配合' END AS 配合判定 FROM enginedimensions ed JOIN enginematerials em ON ed.Engine_ID = em.Engine_ID WHERE em.Crankshaft_Material = 'Forged Steel';	car_engine	4
SELECT e.Model, ed.Angular_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID ORDER BY ed.Angular_Velocity DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * e.Stroke / 1000.0 * ed.Max_turn) / 60.0 AS Calculated_Speed, ed.Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE ABS(((2 * e.Stroke / 1000.0 * ed.Max_turn) / 60.0 - ed.Mean_Piston_Speed) / ed.Mean_Piston_Speed) <= 0.02 ORDER BY Calculated_Speed DESC LIMIT 5;	car_engine	2
SELECT e.Manufacturer, e.Model, ed.Peak_Torque FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Fuel_Type = 'Diesel' AND ed.Peak_Torque < 2000 ORDER BY e.Manufacturer ASC;	car_engine	3
SELECT e.Model, (2 * e.Stroke / 1000.0 * 100000) / 60.0 AS Hypothetical_Speed FROM engine e WHERE e.Configuration = 'Rotary' AND (2 * e.Stroke / 1000.0 * 100000) / 60.0 > 250 ORDER BY Hypothetical_Speed DESC;	car_engine	4
SELECT e.Model, ep.Thermal_Efficiency, (ep.Thermal_Efficiency / 100.0) AS Effective_Work_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID ORDER BY ep.Thermal_Efficiency DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * 3.141592653589793 * e.Torque * e.Cylinders) / (e.Displacement * 1000) AS BMEP FROM engine e WHERE (2 * 3.141592653589793 * e.Torque * e.Cylinders) / (e.Displacement * 1000) > 15 ORDER BY BMEP DESC;	car_engine	2
WITH displacement_avg AS (     SELECT Displacement, AVG(Fuel_Consumption) AS avg_fuel      FROM engine e      JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID      GROUP BY Displacement ) SELECT e.Model, e.Displacement, ep.Fuel_Consumption  FROM engine e  JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID  JOIN displacement_avg da ON e.Displacement = da.Displacement  WHERE ep.Fuel_Consumption < da.avg_fuel  ORDER BY e.Displacement ASC;	car_engine	3
SELECT e.Model, e.Weight, ep.Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Weight = 0 AND ep.Power_To_Weight_Ratio > 500 ORDER BY e.Weight ASC;	car_engine	4
SELECT Engine_ID FROM engineperformance WHERE BMEP > 15 AND Thermal_Efficiency < 30;	car_engine	1
SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE (ep.Power_To_Weight_Ratio * 1000) / ep.Specific_Power >= SQRT(e.Displacement) AND e.Fuel_Type != 'Electric';	car_engine	2
SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type = 'Gasoline' AND ep.Fuel_Consumption < (6 + 0.5 * e.Displacement) AND ep.Thermal_Efficiency > 35;	car_engine	3
SELECT Engine_ID FROM engineperformance WHERE Thermal_Efficiency > 88 AND Specific_Torque >= 1000000 AND BMEP > 1000;	car_engine	4
SELECT e.Fuel_Type, AVG((2 * 3.141592653589793 * e.Torque) / (e.Displacement * 100000)) AS Avg_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Fuel_Type;	car_engine	1
SELECT e.Manufacturer, EXP(SUM(e.Displacement * LN(ep.Specific_Power * ep.Specific_Torque)) / SUM(e.Displacement)) AS Weighted_Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power > 0 AND ep.Specific_Torque > 0 GROUP BY e.Manufacturer ORDER BY Weighted_Geometric_Mean DESC;	car_engine	2
SELECT e.Cylinders, AVG(ep.Fuel_Consumption) AS Avg_Fuel_Consumption, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Cylinders ORDER BY e.Cylinders;	car_engine	3
SELECT e.Fuel_Type, COUNT(*) AS Anomaly_Count, AVG(ep.Power_To_Weight_Ratio) AS Avg_Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Fuel_Consumption < 0 OR ep.Fuel_Consumption > 500 GROUP BY e.Fuel_Type;	car_engine	4
SELECT e.Fuel_Type, AVG((e.Horsepower * 0.7457 * 1000) / (ep.Fuel_Consumption * CASE WHEN e.Fuel_Type = 'Gasoline' THEN 34.2 WHEN e.Fuel_Type = 'Diesel' THEN 38.6 ELSE 0 END * 100) * 100) AS Thermal_Efficiency, AVG(e.Displacement) AS Avg_Displacement, AVG(e.Horsepower) AS Avg_Horsepower FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Gasoline', 'Diesel') GROUP BY e.Fuel_Type;	car_engine	1
SELECT Cylinders, AVG(ABS(Displacement - (PI() / 4 * POWER(Bore / 10.0, 2) * Stroke / 10.0 * Cylinders / 1000.0)) / Displacement * 100.0) AS Error_Percentage FROM engine GROUP BY Cylinders;	car_engine	2
SELECT e.Configuration, AVG(d.Length) AS Avg_Length, AVG(d.Width) AS Avg_Width FROM engine e JOIN enginedimensions d ON e.Engine_ID = d.Engine_ID GROUP BY e.Configuration;	car_engine	3
SELECT Configuration, (2.0 * 1000000 * 1000 / 60.0 / 1000.0) / 343.0 AS Mach_Number FROM engine GROUP BY Configuration;	car_engine	4
SELECT e.Engine_ID, e.Model, m.Block_Material, p.Thermal_Efficiency  FROM engine e  JOIN enginematerials m ON e.Engine_ID = m.Engine_ID  JOIN engineperformance p ON e.Engine_ID = p.Engine_ID  WHERE m.Block_Material = 'Cast Iron' AND p.Thermal_Efficiency > 35;	car_engine	1
SELECT e.Engine_ID, e.Model, d.Peak_Torque, p.BMEP FROM engine e JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND p.BMEP < (d.Peak_Torque / e.Displacement) * 0.12;	car_engine	2
SELECT e.Engine_ID, e.Model, ed.Length, d.Piston_Speed FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID WHERE ed.Length > 1000 AND d.Piston_Speed > 25;	car_engine	3
SELECT Engine_ID, Model, Displacement FROM engine WHERE Fuel_Type = 'Electric' AND Displacement != 0;	car_engine	4
SELECT ed.Engine_ID, PI() * (Main_Bore_Diameter/2) * (Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2) * (Rod_Journal_Diameter/2) AS Bearing_Area, (1.5 * edyn.Angular_Velocity * edyn.Angular_Velocity * (ed.Weight/1000) * (Rod_Journal_Diameter/2000)) / (PI() * (Main_Bore_Diameter/2)*(Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2)*(Rod_Journal_Diameter/2)) AS Stress FROM enginedimensions ed JOIN enginedynamics edyn USING(Engine_ID) JOIN enginematerials em USING(Engine_ID) WHERE em.Block_Material = 'Cast Iron' HAVING Stress > 200;	car_engine	1
SELECT ed.Engine_ID, (Cylinder_Spacing * 5 + 40 + 6 * Bore) AS Calculated_Length, Length, ABS((Cylinder_Spacing * 5 + 40 + 6 * Bore) - Length) AS Length_Deviation FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE e.Cylinders = 6 AND e.Configuration = 'Inline';	car_engine	2
SELECT ed.Engine_ID, Cylinder_Spacing, Bore, ROUND(1.2*Bore,1) AS Min_Safe_Spacing, CASE WHEN Cylinder_Spacing < 1.2*Bore THEN 'Danger' ELSE 'Safety' END AS Safety_Status FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE Cylinder_Spacing = 50 AND Width = 600;	car_engine	3
SELECT Engine_ID FROM enginedimensions WHERE Weight > 10000 AND Engine_ID NOT IN (SELECT Engine_ID FROM engineperformance WHERE Power_To_Weight_Ratio < 0.001);	car_engine	4
SELECT e.Model, (80 * 21.9 * 0.01 * 600) / (80 * 0.005 + 21.9 * 0.010) AS Q FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN enginethermodynamics t ON e.Engine_ID = t.Engine_ID WHERE m.Valve_Material = 'Titanium' AND m.Head_Material = 'Cast Iron' ORDER BY Q DESC LIMIT 3;	car_engine	1
SELECT e.Engine_ID, 2700 * PI() * POWER(e.Bore/2000.0, 2) * e.Stroke/1000.0 * POWER(d.Angular_Velocity, 2) * (e.Stroke/2000.0) * (1 + 1/(2*1.5)) AS F FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginedynamics d USING(Engine_ID) WHERE m.Piston_Material = 'Aluminum' AND m.Connecting_Rod_Material = 'Steel' ORDER BY F ASC LIMIT 5;	car_engine	2
SELECT e.Model, p.Specific_Power  FROM engine e  JOIN enginematerials m ON e.Engine_ID = m.Engine_ID  JOIN engineperformance p ON e.Engine_ID = p.Engine_ID  WHERE m.Block_Material = 'Cast Iron'    AND e.Fuel_Type = 'Gasoline'    AND e.Compression_Ratio > 10  ORDER BY p.Specific_Power DESC  LIMIT 3;	car_engine	3
SELECT e.Engine_ID, (1.0/(2.0*PI())) * SQRT( (300e9/(2.0*(1.0+0.3)) * PI()*POWER(ed.Rod_Journal_Diameter/1000.0,4)/32.0) / (ed.Length/1000.0 * (e.Weight * POWER(ed.Rod_Journal_Diameter/2000.0,2)/4.0)) ) AS f FROM engine e JOIN enginedimensions ed USING(Engine_ID) WHERE e.Configuration = 'W' AND e.Cylinders = 24 AND e.Bore = 5000 AND e.Stroke = 3000 ORDER BY f ASC;	car_engine	4
SELECT e.Model, (et.Combustion_Efficiency / et.Heat_Rejection_Rate) AS Ratio FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Displacement > 2.0 ORDER BY Ratio DESC LIMIT 5;	car_engine	1
SELECT e.Model, (et.Thermal_Conductivity * (et.Exhaust_Gas_Temperature - et.Coolant_Temperature) / ed.Cylinder_Spacing + et.Specific_Heat_Capacity * et.Oil_Temperature) AS Q_total FROM enginethermodynamics et INNER JOIN enginematerials em ON et.Engine_ID = em.Engine_ID INNER JOIN enginedimensions ed ON et.Engine_ID = ed.Engine_ID INNER JOIN engine e ON et.Engine_ID = e.Engine_ID ORDER BY Q_total DESC LIMIT 3;	car_engine	2
SELECT e.Model FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 100 AND e.Fuel_Type = 'Gasoline' ORDER BY e.Displacement ASC;	car_engine	3
SELECT e.Model, (1000 * (ed.Cylinder_Spacing / 1000)) / ((2 * ((ed.Length / 1000) * (ed.Width / 1000) + (ed.Length / 1000) * (ed.Height / 1000) + (ed.Width / 1000) * (ed.Height / 1000))) * (5000 - 25)) AS λ_min FROM enginedimensions ed INNER JOIN engine e ON ed.Engine_ID = e.Engine_ID ORDER BY λ_min ASC LIMIT 5;	car_engine	4
SELECT e.Manufacturer, AVG(et.Combustion_Efficiency) AS Avg_Combustion_Efficiency, SUM(et.Heat_Rejection_Rate) AS Total_Heat_Rejection_Rate FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID GROUP BY e.Manufacturer;	car_engine	1
SELECT e.Configuration, SUM(e.Weight)/(SUM(e.Weight/(0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity))) AS Weighted_Harmonic_Mean FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Fuel_Type = 'Electric' AND (0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity) > 0 GROUP BY e.Configuration;	car_engine	2
SELECT e.Fuel_Type, COUNT(DISTINCT e.Model) AS High_Temp_Models FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 120 GROUP BY e.Fuel_Type;	car_engine	3
SELECT e.Cylinders, SUM(5.67E-8 * 0.9 * 2*(ed.Length*ed.Width + ed.Length*ed.Height + ed.Width*ed.Height) * (POWER(5273,4)-POWER(300,4))) AS Thermal_Radiation_Power FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Cylinders;	car_engine	4
SELECT Engine_ID, 5000 AS Total_Energy, Combustion_Efficiency, 2500 AS Cooling_Loss, (5000 - (5000 * Combustion_Efficiency / 100) - 2500) AS Calculated_Exhaust_Loss, Heat_Rejection_Rate AS Actual_Exhaust_Loss, CASE WHEN Heat_Rejection_Rate = (5000 - (5000 * Combustion_Efficiency / 100) - 2500) THEN '满足能量守恒' ELSE '不满足能量守恒' END AS Energy_Conservation_Status FROM enginethermodynamics WHERE Engine_ID = 12345;	car_engine	1
SELECT e.Engine_ID, e.Displacement, et.Specific_Heat_Capacity, (e.Displacement * 0.85) AS Mass_kg, (120 - 80) AS Temp_Diff_K, ROUND((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80), 2) AS Total_Heat_J, ROUND(((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80)) / 10 / 1000, 2) AS Required_Power_kW FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Engine_ID = 12345;	car_engine	2
SELECT Engine_ID, Exhaust_Gas_Temperature, CASE WHEN Exhaust_Gas_Temperature > 800 THEN '存在催化器失效风险' ELSE '工作状态正常' END AS Catalyst_Status FROM enginethermodynamics WHERE Exhaust_Gas_Temperature > 800;	car_engine	3
SELECT Engine_ID, Combustion_Efficiency, Heat_Rejection_Rate, CASE WHEN Combustion_Efficiency > 100 THEN 'Contradiction: Combustion efficiency exceeds physical limits' WHEN Heat_Rejection_Rate < 0 THEN 'Contradiction: Heat dissipation rate violates the second law of thermodynamics.' ELSE 'No contradiction' END AS Physical_Consistency FROM enginethermodynamics WHERE Combustion_Efficiency > 100 OR Heat_Rejection_Rate < 0;	car_engine	4
SELECT Engine_ID, Model, 1 * POWER(CAST(SUBSTR(Compression_Ratio, 1, INSTR(Compression_Ratio, ':') - 1) AS REAL), 1.4) AS Theoretical_Max_Pressure_Bar FROM engine WHERE Bore = 84 AND Stroke = 90 AND Compression_Ratio = '11.5:1' AND Fuel_Type = 'Gasoline';	car_engine	1
SELECT e.Engine_ID, e.Model, ed.Angular_Velocity, ROUND((ed.Angular_Velocity * (e.Stroke/2000.0)) * (SIN(RADIANS(70)) + ((e.Stroke/2000.0)/(2*0.15))*SIN(RADIANS(140))), 4) AS Instantaneous_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Cylinders = 8 AND e.Configuration = 'V' AND e.Stroke = 86;	car_engine	2
SELECT Engine_ID, Model, Compression_Ratio, Aspiration FROM engine WHERE Fuel_Type = 'Diesel' AND Aspiration = 'Turbocharged' AND Compression_Ratio = '18:1';	car_engine	3
SELECT e.Engine_ID, e.Model, 2.5 * POW(2*PI()*e.Redline/60, 2) * (e.Stroke/2000) * (1 + (e.Stroke/2000)/0.15) AS Inertial_Force FROM engine e WHERE e.Cylinders = 24 AND e.Configuration = 'W' AND e.Bore = 200 AND e.Stroke = 500;	car_engine	4
SELECT 0.5 * 50 * POWER((Main_Bore_Diameter/2/1000.0),2) AS 转动惯量, (2 * PI() * Max_turn)/60 AS 角速度 FROM enginedimensions JOIN enginedynamics USING(Engine_ID) WHERE Main_Bore_Diameter=80 AND Engine_ID IN (SELECT Engine_ID FROM engine WHERE Configuration='V');	car_engine	1
SELECT ROUND((Length*Width*Height - Cylinders*3.141592653589793*POWER(Bore/2,2)*Stroke)/(Length*Width*Height)*100,3) AS 剩余空间占比 FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='Inline' AND Cylinders=6 AND Length=600 AND Width=500 AND Height=400;	car_engine	2
SELECT Width, CASE WHEN Width <= 900 * (1 - 0.1) THEN 'conforms to' ELSE 'does not meet the requirements' END AS Installation Status FROM enginedimensions WHERE Width = 800;	car_engine	3
SELECT (24/4)*Cylinder_Spacing AS 理论长度, Cylinder_Spacing/100 AS 轴颈直径, CASE WHEN (16*20000)/(PI()*POWER(Cylinder_Spacing/100/1000,3)) > 800e6 THEN 'exceed' ELSE 'not exceeding' END AS Stress state FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='W' AND Cylinders=24 AND Cylinder_Spacing=5000;	car_engine	4
SELECT Engine_ID, Max_turn, Angular_Velocity, (PI() * Max_turn / 30) AS Formula_Value, ROUND(Angular_Velocity,2) = ROUND((PI() * Max_turn / 30),2) AS Data_Consistency FROM enginedynamics WHERE Max_turn = 8500 AND Angular_Velocity = 890;	car_engine	1
SELECT e.Engine_ID, ed.Mean_Piston_Speed, (2 * (e.Stroke / 1000.0) * ed.Max_turn) / 60.0 AS Calculated_Speed, ROUND(ed.Mean_Piston_Speed, 1) = ROUND((2 * (e.Stroke / 1000.0) * ed.Max_turn) / 60.0, 1) AS Validation FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'V型' AND ed.Max_turn = 6800 AND e.Stroke = 86;	car_engine	2
SELECT Engine_ID, Peak_Torque, Peak_Power, CAST(SUBSTR(Peak_Torque, INSTR(Peak_Torque, '-') + 1) AS INTEGER) < CAST(Peak_Power AS INTEGER) AS Logic_Validation FROM enginedynamics WHERE Engine_ID IN (SELECT Engine_ID FROM engine WHERE Aspiration = 'Turbocharged');	car_engine	3
SELECT PI() * 1500000 / 30 AS Angular_Velocity, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 AS Centrifugal_Stress, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 > 3e9 AS Will_Break FROM engine WHERE Configuration = 'rotor' LIMIT 1;	car_engine	4
SELECT ((300-200)*0.5)/((0.01/80)+(0.01/205))*3600 AS Heat_Joules_Per_Hour FROM enginematerials WHERE Block_Material='Aluminum' AND Head_Material='Cast Iron';	car_engine	1
SELECT (2*50000)/(900e6) AS Min_Area_m2, (2*50000)/(900e6) * 0.15 * (4.5*1000) AS Max_Weight_kg FROM enginematerials WHERE Connecting_Rod_Material='Titanium';	car_engine	2
SELECT CASE WHEN (0.015*1800*0.65) + (2*(e.Length*e.Width + e.Width*e.Height + e.Height*e.Length)/1000000.0 * 0.002 * 7800) < 120 THEN 'Yes' ELSE 'No' END FROM engine en JOIN enginedimensions e ON en.Engine_ID = e.Engine_ID JOIN enginematerials em ON en.Engine_ID = em.Engine_ID WHERE en.Weight = 120 AND em.Block_Material = 'Cast Iron';	car_engine	3
SELECT CASE WHEN (0.5 * (0.01 * 0.0002 * 0.08) * POWER((6000*2*3.141592653589793/60),2) * 0.08)/200e-6 > 900e6 THEN 'expired' ELSE 'Safety' END FROM enginematerials WHERE Crankshaft_Material='Hypothetical Materials';	car_engine	4
SELECT e.Configuration, AVG((e.Torque * 2 * PI() * ed.Peak_Torque) / (e.Displacement * 1000) * 60 / 100000) AS Calculated_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Configuration ORDER BY e.Configuration;	car_engine	1
SELECT e.Manufacturer, EXP(AVG(LN(ep.Specific_Power * ep.Specific_Torque)) / 2) AS Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Manufacturer ORDER BY Geometric_Mean DESC;	car_engine	2
WITH Ranked AS (     SELECT          e.Engine_ID,          ep.Fuel_Consumption,         CASE              WHEN e.Displacement < 2.0 THEN '<2.0L'              WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L'              ELSE '>3.0L'          END AS Displacement_Group,         ROW_NUMBER() OVER (PARTITION BY              CASE                  WHEN e.Displacement < 2.0 THEN '<2.0L'                  WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L'                  ELSE '>3.0L'              END              ORDER BY ep.Fuel_Consumption         ) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY              CASE                  WHEN e.Displacement < 2.0 THEN '<2.0L'                  WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L'                  ELSE '>3.0L'              END              ORDER BY ep.Fuel_Consumption DESC         ) AS RowDesc     FROM engine e      JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID ) SELECT      Displacement_Group,      AVG(Fuel_Consumption) AS Median_Fuel_Consumption  FROM Ranked  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc  GROUP BY Displacement_Group  ORDER BY MIN(Displacement_Group);	car_engine	3
SELECT e.Fuel_Type, CASE WHEN e.Fuel_Type = 'Electric' THEN (100.0 / 120.0) * 100.0 ELSE AVG(ep.Fuel_Consumption) END AS Theoretical_Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Electric', 'Gasoline') GROUP BY e.Fuel_Type;	car_engine	4
SELECT e.Manufacturer, SUM(et.Heat_Rejection_Rate * 1000.0 / (et.Specific_Heat_Capacity * (et.Coolant_Temperature - 25.0))) AS Total_Heat_Capacity_Per_Degree FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Combustion_Efficiency > 30.0 GROUP BY e.Manufacturer ORDER BY Total_Heat_Capacity_Per_Degree DESC LIMIT 1;	car_engine	1
SELECT e.Model, (ep.Specific_Power * ep.Thermal_Efficiency) AS Efficiency_Product  FROM engine e  JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID  WHERE CAST(SUBSTR(e.Compression_Ratio, 1, INSTR(e.Compression_Ratio, ':') - 1) AS INTEGER) > 10  AND (ep.Specific_Power * ep.Thermal_Efficiency) > (     SELECT AVG(ep2.Specific_Power * ep2.Thermal_Efficiency)      FROM engineperformance ep2      JOIN engine e2 ON ep2.Engine_ID = e2.Engine_ID      WHERE CAST(SUBSTR(e2.Compression_Ratio, 1, INSTR(e2.Compression_Ratio, ':') - 1) AS INTEGER) > 10 );	car_engine	2
SELECT e.Engine_ID, et.Exhaust_Gas_Temperature, em.Block_Material FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE et.Exhaust_Gas_Temperature > 900 AND em.Block_Material = 'Cast Iron';	car_engine	3
SELECT e.Model, (2 * e.Stroke * 100000) / 60000 AS Hypothetical_Piston_Speed, ((2 * e.Stroke * 100000) / 60000 - 7000) * 100.0 / 7000 AS Over_Speed_Percentage FROM engine e WHERE (2 * e.Stroke * 100000) / 60000 > 7000;	car_engine	4
SELECT ROUND((3.141592653589793 * POWER(90.0/2.0, 2) * 100.0) / (11-1) / 1000000.0, 4) AS Combustion_Chamber_Volume_L, CASE WHEN 11 <= 13 THEN 'conforms to' ELSE 'does not meet the requirements' END AS Compression_Ratio_Check;	car_engine	1
SELECT ROUND((ep.Specific_Power * 0.6 + ep.Thermal_Efficiency * 0.4), 2) AS Comprehensive_Score FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE em.Block_Material = 'Aluminum' AND e.Aspiration = 'Turbocharged' AND ep.Specific_Power IS NOT NULL AND ep.Thermal_Efficiency IS NOT NULL;	car_engine	2
SELECT FLOOR(600 / (120 * 0.866)) * 2 AS Max_Cylinders FROM engine WHERE Configuration = 'V' LIMIT 1;	car_engine	3
SELECT ROUND((50*60)/(2*0.2),0) AS RPM_假设, ROUND((50*60)/(2*0.2)*3.141592653589793/30,2) AS Angular_Velocity, ROUND(POW((50*60)/(2*0.2)/6000,2),2) AS Centrifugal_Force_Multiplier FROM engine WHERE Fuel_Type='Electric' AND Stroke=200 LIMIT 1;	car_engine	4
SELECT e.Manufacturer, e.Model, (2 * e.Stroke * ed.Max_turn) / 60000 AS Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE (2 * e.Stroke * ed.Max_turn) / 60000 > 25;	car_engine	1
SELECT e.Configuration, STDEV((ed.Max_turn * 2 * PI()) / 60) AS Angular_Velocity_StdDev FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Compression_Ratio >= 10 AND e.Configuration IN ('V', 'Inline') GROUP BY e.Configuration;	car_engine	2
SELECT e.Model, e.Manufacturer, ep.Specific_Power FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE em.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Diesel' AND ep.Thermal_Efficiency > 40 ORDER BY ep.Specific_Power DESC;	car_engine	3
SELECT DISTINCT em.Connecting_Rod_Material FROM enginematerials em JOIN enginedimensions ed ON em.Engine_ID = ed.Engine_ID WHERE ed.Rod_Journal_Diameter > 500;	car_engine	4
SELECT (50 * 10) + (50 * 15) AS Total_Energy_Consumption;	car	1
SELECT AVG(engine_specs.Horsepower / dimensions.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123; SELECT cars.Model, (engine_specs.Horsepower / dimensions.Curb_Weight) AS Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123 ORDER BY Power_to_Weight_Ratio DESC LIMIT 5;	car	2
SELECT AVG(Cargo_Capacity) AS Avg_Cargo_Capacity FROM cars WHERE Year = 2020 AND Seating_Capacity > 5;	car	3
SELECT 1000.0 / 10000.0 AS Energy_Consumption_Per_km; SELECT * FROM cars WHERE Battery_Capacity / Range < (1000.0 / 10000.0);	car	4
SELECT c.Model, e.Horsepower, (0.5 * 1.225 * ((p.Top_Speed / 3.6) * (p.Top_Speed / 3.6)) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Corolla';	car	1
SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'A certain manufacturer' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;	car	2
SELECT c.Model, (1.0 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1.0 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = 'Corolla';	car	3
SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = 'Corolla';	car	4
SELECT ((100 / Fuel_Efficiency_City) + (200 / Fuel_Efficiency_Highway)) * 8.9 AS Total_Energy_Consumption FROM cars WHERE Car_ID = '1';	car	1
SELECT c.Model, AVG(e.Horsepower / d.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN dimensions d ON c.Car_ID = d.Car_ID WHERE c.Manufacturer_ID = 1 GROUP BY c.Model ORDER BY Avg_Power_to_Weight_Ratio DESC LIMIT 5;	car	2
SELECT Model FROM cars WHERE Year = 2020 AND Fuel_Tank_Capacity > 50 AND Fuel_Efficiency_City < 10 ORDER BY Production_Volume DESC;	car	3
SELECT (1000 / 0.1) AS Fuel_Consumption, (1000 / 0.1) * 2.31 AS CO2_Emissions;	car	4
SELECT Model, ((Fuel_Efficiency_City * 0.9 - Fuel_Efficiency_City) / Fuel_Efficiency_City) * 100 AS City_Efficiency_Change_Percent, ((Fuel_Efficiency_Highway * 0.9 - Fuel_Efficiency_Highway) / Fuel_Efficiency_Highway) * 100 AS Highway_Efficiency_Change_Percent FROM cars;	car	1
SELECT Model FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer') AND Production_Volume > (SELECT AVG(Production_Volume) FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer'));	car	2
SELECT m.Name, c.Model FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity < (e.Fuel_Consumption_City * 10);	car	3
SELECT c.Model, (p.Braking_Distance * (1000.0 * 1000.0) / (p.Top_Speed * p.Top_Speed)) AS Hypothetical_Braking_Distance FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID;	car	4
SELECT 0.5 * Weight * POWER((100 * 1000.0 / 3600.0), 2) AS Kinetic_Energy FROM cars WHERE Car_ID = 1;	car	1
SELECT Model, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2.0) AS Avg_Fuel_Efficiency FROM cars WHERE Manufacturer_ID = 1 GROUP BY Model ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;	car	2
SELECT Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Car_ID = 1;	car	3
SELECT Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs WHERE Car_ID = 1;	car	4
SELECT Model, 0.5 * Weight * ((Top_Speed * 1000.0 / 3600.0) * (Top_Speed * 1000.0 / 3600.0)) AS Kinetic_Energy FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID ORDER BY Kinetic_Energy DESC LIMIT 1;	car	1
SELECT manufacturers.Name, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2.0) AS Avg_Fuel_Efficiency FROM cars JOIN manufacturers ON cars.Manufacturer_ID = manufacturers.Manufacturer_ID GROUP BY manufacturers.Name ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;	car	2
SELECT c.Model, c.Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID ORDER BY City_Range DESC, Highway_Range DESC LIMIT 1;	car	3
SELECT cars.Model, Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs JOIN cars ON engine_specs.Car_ID = cars.Car_ID ORDER BY Fuel_Consumption DESC LIMIT 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE Weight = 1500;	car	1
SELECT Fuel_Efficiency_City, Fuel_Tank_Capacity FROM cars WHERE Fuel_Efficiency_City = 10 AND Fuel_Tank_Capacity = 50;	car	2
SELECT Cargo_Capacity FROM cars WHERE Cargo_Capacity = 500;	car	3
SELECT Max_RPM, Horsepower FROM engine_specs WHERE Max_RPM = 10000;	car	4
SELECT Weight, Acceleration_0_to_100 FROM performance_metrics JOIN cars ON performance_metrics.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE cars.Car_ID = 1;	car	2
SELECT (dimensions.Cargo_Capacity + dimensions.Trunk_Capacity) / 50 AS Max_Cargo_Items FROM dimensions JOIN cars ON dimensions.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;	car	3
SELECT "Range" * (1000.0 / "Battery_Capacity") AS New_Range FROM cars WHERE Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue FROM manufacturers WHERE Manufacturer_ID = 1;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT cars.Car_ID, (cars.Battery_Capacity * 1000.0) / (500.0 * performance_metrics.Top_Speed) AS Max_Speed_Range_Time FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT (Annual_Sales * Profit_Margin * Average_Price / 100) AS Total_Profit FROM manufacturers WHERE Name = 'BMW';	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT c.Battery_Capacity, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;	car	4
SELECT (100 * 1000 / 3600) / 8 AS average_acceleration FROM cars WHERE Weight = 1500;	car	1
SELECT (Fuel_Tank_Capacity * Fuel_Efficiency_City * 0.5) + (Fuel_Tank_Capacity * Fuel_Efficiency_Highway * 0.5) AS total_range FROM cars WHERE Car_ID = 1;	car	2
SELECT Maintenance_Cost * 5 AS total_maintenance_cost, Base_Price * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) AS depreciated_value FROM prices WHERE Car_ID = 1;	car	3
SELECT (100000 / Battery_Capacity) * "Range" AS extended_range FROM cars WHERE Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue, SUM(Annual_Sales) AS Total_Sales, SUM(Annual_Sales * Average_Price) / SUM(Annual_Sales) AS Average_Price_Per_Car FROM manufacturers WHERE Manufacturer_ID = 1;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT Max_RPM, Cylinder_Count FROM engine_specs WHERE Car_ID = 1;	car	4
SELECT (0.5 * Weight * POWER(27.78, 2)) / Acceleration_0_to_100 AS Average_Power FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;	car	1
SELECT cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_City / 100.0) AS City_Distance, cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_Highway / 100.0) AS Highway_Distance FROM cars JOIN engine_specs ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Car_ID = 1;	car	2
SELECT Cargo_Capacity * 1 AS Max_Cargo_Weight FROM dimensions WHERE Cargo_Capacity = 500 AND Trunk_Capacity = 300;	car	3
SELECT Max_RPM / 2 * Cylinder_Count AS Combustion_Per_Minute FROM engine_specs WHERE Displacement = 2.0 AND Max_RPM = 8000 AND Cylinder_Count = 4 AND Compression_Ratio = 10;	car	4
SELECT c.Weight, pm.Braking_Distance, sf.Brake_Assist_Response_Time, es.Torque FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID JOIN safety_features sf ON c.Car_ID = sf.Car_ID JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Car_ID = 1;	car	1
SELECT c.Fuel_Tank_Capacity, c.Battery_Capacity, pm.Range_Hybrid, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;	car	2
SELECT c.Seating_Capacity, d.Trunk_Capacity, d.Cargo_Capacity FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID WHERE c.Car_ID = 1;	car	3
SELECT es.Max_RPM, es.Cylinder_Count, c.Fuel_Tank_Capacity, es.Fuel_Consumption_Highway FROM engine_specs es JOIN cars c ON es.Car_ID=c.Car_ID JOIN performance_metrics pm ON c.Car_ID=pm.Car_ID WHERE c.Car_ID=123;	car	4
SELECT e.Horsepower, p.Top_Speed, d.Length, d.Width, d.Curb_Weight FROM engine_specs e JOIN performance_metrics p ON e.Car_ID = p.Car_ID JOIN dimensions d ON e.Car_ID = d.Car_ID WHERE e.Car_ID = 123;	car	1
SELECT c.Model, c.Production_Volume, p.Total_Price, m.Profit_Margin FROM cars c JOIN prices p ON c.Car_ID = p.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Manufacturer_ID = 123 ORDER BY c.Production_Volume DESC LIMIT 5;	car	2
SELECT c.Fuel_Tank_Capacity, c.Fuel_Efficiency_Highway FROM cars c WHERE c.Car_ID = 123;	car	3
SELECT s.Airbag_Count, d.Curb_Weight, p.Braking_Distance FROM safety_features s JOIN dimensions d ON s.Car_ID = d.Car_ID JOIN performance_metrics p ON s.Car_ID = p.Car_ID WHERE s.Car_ID = 123;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;	car	1
SELECT Revenue, Revenue * (Profit_Margin / 100.0) AS Total_Profit, `R&D_Spending` / CAST(Production_Volume_Total AS REAL) AS Avg_RD_Per_Car FROM manufacturers WHERE Production_Volume_Total = 500000 AND Annual_Sales = 450000 AND `R&D_Spending` = 200000000 AND Profit_Margin = 8;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Fuel_Tank_Capacity = 60 AND Fuel_Efficiency_City = 10 AND Fuel_Efficiency_Highway = 15;	car	3
SELECT Max_RPM, Torque FROM engine_specs WHERE Max_RPM = 10000 AND Torque = 500;	car	4
SELECT ROUND(0.5 * d.Curb_Weight * POWER(p.Top_Speed/3.6, 2)) AS KineticEnergy_J FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID WHERE p.Top_Speed = 240 AND d.Curb_Weight = 1800;	car	1
SELECT (m.Production_Volume_Total * m.Average_Price * 0.85 * m.Profit_Margin / 100) AS NetProfit FROM manufacturers m WHERE m.Name = 'BMW' AND m.Production_Volume_Total = 100000 AND m.Average_Price = 35000;	car	2
SELECT s.ABS_Effectiveness, p.Braking_Distance, ROUND((p.Braking_Distance / (s.ABS_Effectiveness / 100.0) * 1.3) - p.Braking_Distance, 1) AS RainIncrease_m FROM safety_features s JOIN performance_metrics p USING(Car_ID) WHERE s.ABS_Effectiveness = 95 AND p.Braking_Distance = 40;	car	3
SELECT e.Displacement, e.Cylinder_Count, (e.Displacement * e.Max_RPM * e.Cylinder_Count * 1.2 * 60)/1000 AS TheoreticalFuel_L_h FROM engine_specs e WHERE e.Displacement = 100 AND e.Cylinder_Count = 16 AND e.Max_RPM = 6000;	car	4
SELECT (0.5 * 1.225 * pm.Drag_Coefficient * 2.3 * (POWER((pm.Top_Speed*1000/3600),3))) AS Air_Power FROM performance_metrics pm JOIN dimensions d ON pm.Car_ID = d.Car_ID WHERE pm.Top_Speed = 210 AND d.Curb_Weight = 1500 AND pm.Drag_Coefficient = 0.28 LIMIT 1;	car	1
SELECT ((1800 * 9.8 * 0.015 + 0.5 * 1.225 * 0.3 * 2.5 * POWER(120 / 3.6, 2)) * 100000) * 500 AS Total_Energy FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' GROUP BY m.Name LIMIT 1;	car	2
SELECT (c.Fuel_Tank_Capacity * 0.15 / es.Fuel_Consumption_Highway) * 100 AS Remaining_Range FROM cars c JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Fuel_Tank_Capacity = 60 AND es.Fuel_Consumption_Highway = 6.5 AND c.Battery_Capacity IS NULL LIMIT 1;	car	3
SELECT (99999/(15/100))/40075 AS Theoretical_Laps FROM cars c JOIN dimensions d ON c.Car_ID = d.Car_ID JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Battery_Capacity IS NOT NULL AND d.Curb_Weight = 2000 AND pm.Drag_Coefficient = 0.21 LIMIT 1;	car	4
SELECT d.Curb_Weight, p.Top_Speed, 0.5 * d.Curb_Weight * (p.Top_Speed/3.6) * (p.Top_Speed/3.6) AS Kinetic_Energy_J FROM dimensions d JOIN performance_metrics p ON d.Car_ID = p.Car_ID JOIN engine_specs e ON d.Car_ID = e.Car_ID WHERE e.Displacement > 0 AND e.Fuel_Consumption_Highway > 0;	car	1
SELECT pr.Base_Price, pr.Maintenance_Cost, pr.Depreciation_Rate, pr.Insurance_Cost, pr.Tax_Rate, (pr.Total_Price*(1+pr.Tax_Rate/100)) + (pr.Maintenance_Cost*5) + (pr.Base_Price*(1-POW(1-pr.Depreciation_Rate/100,5))) - pr.Insurance_Cost AS Total_5yr_Cost FROM prices pr JOIN cars c ON pr.Car_ID = c.Car_ID WHERE c.Range IS NOT NULL;	car	2
SELECT c.Model, c.Fuel_Tank_Capacity, e.Fuel_Consumption_City, (c.Fuel_Tank_Capacity * (100.0 / e.Fuel_Consumption_City)) AS City_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity > 0 AND e.Fuel_Consumption_City > 0;	car	3
SELECT c.Model, e.Displacement, c.Fuel_Tank_Capacity, e.Fuel_Consumption_Highway, (c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway) * 100000 AS Absurd_Range_m FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE e.Displacement >= 20 AND c.Fuel_Tank_Capacity <= 2 AND e.Fuel_Consumption_Highway >= 50;	car	4
SELECT (e.Torque * (s.ESC_Effectiveness / 100.0)) / (d.Curb_Weight * 0.3) AS Acceleration FROM engine_specs e JOIN dimensions d ON e.Car_ID = d.Car_ID JOIN safety_features s ON e.Car_ID = s.Car_ID WHERE e.Torque = 450 AND d.Curb_Weight = 1500 AND s.ESC_Effectiveness = 95;	car	1
SELECT (8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1))) AS Combined_Fuel, 60 / ((8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1)))/100) AS "Range";	car	2
SELECT (SUM(Airbag_Count * Crash_Test_Rating) - (SUM(Airbag_Count) * SUM(Crash_Test_Rating)) / COUNT(*)) / (COUNT(*) * (SUM(Airbag_Count * Airbag_Count) - (SUM(Airbag_Count) * SUM(Airbag_Count)) / COUNT(*))) AS Correlation FROM safety_features;	car	3
SELECT e.Horsepower / d.Curb_Weight AS Power_Ratio, (100/3.6) / ((e.Horsepower / d.Curb_Weight) * 745.7 / (100/3.6)) AS Acceleration_Time FROM engine_specs e JOIN dimensions d USING(Car_ID) WHERE e.Horsepower = 100000 AND d.Curb_Weight = 1;	car	4
SELECT p.Top_Speed, d.Width, d.Height, 0.5 * 1.225 * p.Drag_Coefficient * (d.Width * d.Height) * (p.Top_Speed/3.6 * p.Top_Speed/3.6) AS Air_Resistance_Newtons FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID JOIN cars c ON p.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' AND c.Model = 'Tesla Model S';	car	1
SELECT SUM(e.CO2_Emissions * m.Annual_Sales * 15000 / 1000000) AS Total_CO2_Tonnes FROM manufacturers m JOIN cars c ON m.Manufacturer_ID = c.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE m.Name = 'Tesla';	car	2
SELECT d.Curb_Weight, d.Cargo_Capacity, (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) AS Total_Weight, CASE WHEN (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) <= 2500 THEN 'safe' ELSE 'overweight' END AS Safety_Status FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID WHERE c.Model = 'Tesla Model S';	car	3
SELECT p.Power_to_Weight_Ratio, c.Weight, (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) AS G_Force, CASE WHEN (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) > 3 THEN 'exceeds' ELSE 'does not exceed' END AS Comparison FROM performance_metrics p JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S';	car	4
SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Tesla Model S';	car	1
SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2.0 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;	car	2
SELECT c.Model, (1.0 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1.0 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = 'Tesla Model S';	car	3
SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = 'Tesla Model S';	car	4
SELECT c.Model, e.Torque, (0.015 * c.Weight * 9.81) AS Rolling_Resistance FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Tesla Model S';	car	1
SELECT c.Model, AVG(e.CO2_Emissions) AS Avg_CO2_Emissions FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' GROUP BY c.Model ORDER BY Avg_CO2_Emissions ASC LIMIT 3;	car	2
SELECT c.Model, (1.0 / c.Fuel_Efficiency_City) * 2.31 AS City_CO2_Per_KM, (1.0 / c.Fuel_Efficiency_Highway) * 2.31 AS Highway_CO2_Per_KM FROM cars c WHERE c.Model = 'Tesla Model S';	car	3
SELECT c.Model, 5000 / 0.1 AS Theoretical_Range FROM cars c WHERE c.Model = 'Tesla Model S';	car	4
SELECT Car_ID, Model, (100.0 / Fuel_Efficiency_City) + (100.0 / Fuel_Efficiency_Highway) AS Total_Fuel_Consumption FROM cars;	car	1
SELECT d.Car_ID, c.Model, d.Gross_Weight * 1.0 / d.Curb_Weight AS Weight_Ratio FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID ORDER BY Weight_Ratio DESC LIMIT 5;	car	2
SELECT Car_ID, Model, (Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars WHERE Year = 2020 ORDER BY Avg_Fuel_Efficiency DESC LIMIT 10;	car	3
SELECT Car_ID, Model, 10000 / 1 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 1;	car	4
SELECT p.Car_ID, c.Model, p.Power_to_Weight_Ratio  FROM performance_metrics p  JOIN cars c ON p.Car_ID = c.Car_ID  ORDER BY p.Power_to_Weight_Ratio DESC  LIMIT 5;	car	1
SELECT e.Car_ID, c.Model, (e.Fuel_Consumption_City * 100.0 / 100.0) * e.CO2_Emissions + (e.Fuel_Consumption_Highway * 100.0 / 100.0) * e.CO2_Emissions AS Total_CO2_Emissions FROM engine_specs e JOIN cars c ON e.Car_ID = c.Car_ID;	car	2
SELECT s.Car_ID, c.Model, s.Airbag_Count FROM safety_features s JOIN cars c ON s.Car_ID = c.Car_ID WHERE c.Year = 2020 ORDER BY s.Airbag_Count DESC LIMIT 10;	car	3
SELECT Car_ID, Model, 10000 / 0.5 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 0.5;	car	4
SELECT deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = solar ORDER BY deviceName ASC;	EnergyManagementDB	1
SELECT deviceId, SUM(energySaved) AS totalEnergySaved FROM EnergyEfficiency WHERE timestamp >= date('now', '-1 year') GROUP BY deviceId ORDER BY totalEnergySaved DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceId, deviceName, lastMaintenanceDate FROM EnergyDevices WHERE status = 'operating' AND lastMaintenanceDate < date('now', '-1 year') ORDER BY deviceName ASC;	EnergyManagementDB	3
SELECT deviceId, deviceName, (powerRating * 24 * 365) AS totalEnergySaved FROM EnergyDevices ORDER BY totalEnergySaved DESC LIMIT 10;	EnergyManagementDB	4
SELECT SUM(ed.powerRating * ed.efficiency / 100 * ec.energyConsumed) AS totalEnergyGenerated  FROM EnergyDevices ed  JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId  JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId  WHERE m.manufacturerName = 'SolarTech' AND ed.deviceType = 'solar';	EnergyManagementDB	1
WITH ManufacturerB_Consumption AS (     SELECT AVG(ec.energyConsumed) AS avg_energy_consumed      FROM EnergyConsumption ec      JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'B'      AND ed.deviceType = 'wind'      AND ec.timestamp >= date('now', '-1 year') ),  ManufacturerC_Consumption AS (     SELECT AVG(ec.energyConsumed) AS avg_energy_consumed      FROM EnergyConsumption ec      JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'C'      AND ed.deviceType = 'wind'      AND ec.timestamp >= date('now', '-1 year') )  SELECT      (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) AS avg_energy_consumed_B,      (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS avg_energy_consumed_C,      (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) - (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS energy_consumption_difference;	EnergyManagementDB	2
SELECT winter.avg_winter_consumption AS Winter_Avg_Consumption, summer.avg_summer_consumption AS Summer_Avg_Consumption, (winter.avg_winter_consumption - summer.avg_summer_consumption) AS Consumption_Difference FROM (SELECT AVG(ec.energyConsumed) AS avg_winter_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND strftime('%m', ec.timestamp) IN ('12', '01', '02')) AS winter, (SELECT AVG(ec.energyConsumed) AS avg_summer_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND strftime('%m', ec.timestamp) IN ('06', '07', '08')) AS summer;	EnergyManagementDB	3
WITH CurrentProfitMargin AS (   SELECT (profit * 1.0 / revenue) * 100 AS profitMargin    FROM Manufacturers    WHERE manufacturerName = 'WindPower' ),  FutureProfit AS (   SELECT 1000000 * (profitMargin / 100) AS futureProfit    FROM CurrentProfitMargin )  SELECT futureProfit  FROM FutureProfit;	EnergyManagementDB	4
WITH DeviceConsumption AS (     SELECT          ec.deviceId,          SUM(ec.energyConsumed) AS totalEnergyConsumed,          AVG(ec.powerUsage) AS avgPowerUsage,          AVG(ec.voltage) AS avgVoltage,          AVG(ec.current) AS avgCurrent      FROM EnergyConsumption ec      WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'      GROUP BY ec.deviceId )  SELECT      dc.deviceId,      dc.totalEnergyConsumed,      dc.avgPowerUsage,      dc.avgVoltage,      dc.avgCurrent,      (dc.avgPowerUsage / (dc.avgVoltage * dc.avgCurrent)) AS powerFactor  FROM DeviceConsumption dc  WHERE dc.deviceId = '1';	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= date('now', '-1 year') GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	2
SELECT hc.deviceId, ed.deviceName, hc.highHumidityEnergy, hc.lowHumidityEnergy, (hc.highHumidityEnergy - hc.lowHumidityEnergy) * 100.0 / hc.lowHumidityEnergy AS energyChangeRate FROM (SELECT deviceId, MAX(CASE WHEN humidity = (SELECT MAX(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS highHumidityEnergy, MAX(CASE WHEN humidity = (SELECT MIN(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS lowHumidityEnergy FROM (SELECT deviceId, humidity, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption GROUP BY deviceId, humidity) AS he GROUP BY deviceId) AS hc JOIN EnergyDevices ed ON hc.deviceId = ed.deviceId;	EnergyManagementDB	3
WITH ExtremePower AS (     SELECT deviceId, deviceName, powerRating * 10 AS extremePower, powerRating      FROM EnergyDevices      WHERE deviceId = 11 ),  ExtremeEnergyConsumption AS (     SELECT          ep.deviceId,          ep.deviceName,          ep.extremePower,          ep.powerRating,          ec.timestamp,          ec.energyConsumed,          ec.powerUsage,          ec.voltage,          ec.current,          ec.temperature,          ec.humidity,          ec.dataQuality,          ep.extremePower *          (julianday(ec.timestamp) - julianday(LAG(ec.timestamp) OVER (PARTITION BY ec.deviceId ORDER BY ec.timestamp))) * 24 AS extremeEnergyConsumed      FROM EnergyConsumption ec      JOIN ExtremePower ep ON ec.deviceId = ep.deviceId )  SELECT      eec.deviceId,      eec.deviceName,      eec.extremePower,      eec.powerRating,      eec.timestamp,      eec.energyConsumed,      eec.powerUsage,      eec.voltage,      eec.current,      eec.temperature,      eec.humidity,      eec.dataQuality,      eec.extremeEnergyConsumed,      eec.extremeEnergyConsumed / 100 AS gridImpact  FROM ExtremeEnergyConsumption eec;	EnergyManagementDB	4
WITH DeviceCarbonFootprint AS (     SELECT          ec.deviceId,          SUM(ec.energyConsumed * ef.carbonFootprint) AS totalCarbonEmission      FROM          EnergyConsumption ec      JOIN          EnvironmentalImpact ef      ON          ec.deviceId = ef.deviceId AND ec.timestamp = ef.timestamp      WHERE          ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'      GROUP BY          ec.deviceId )  SELECT      dcf.deviceId,      ed.deviceName,      dcf.totalCarbonEmission  FROM      DeviceCarbonFootprint dcf  JOIN      EnergyDevices ed  ON      dcf.deviceId = ed.deviceId  ORDER BY      dcf.totalCarbonEmission DESC  LIMIT 1;	EnergyManagementDB	1
SELECT ae.deviceId, ae.avgEfficiency  FROM (     SELECT deviceId, AVG(efficiency) AS avgEfficiency      FROM EnergyEfficiency      WHERE timestamp >= date('now', '-1 year')      GROUP BY deviceId ) AS ae  JOIN (     SELECT AVG(efficiency) AS overallAvgEfficiency      FROM EnergyEfficiency      WHERE timestamp >= date('now', '-1 year') ) AS oa  WHERE ae.avgEfficiency < oa.overallAvgEfficiency;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.powerRating, ed.efficiency, ed.installationDate, ed.status, ed.location, ed.manufacturerId, ed.lastMaintenanceDate, ed.nextMaintenanceDate FROM EnergyDevices ed WHERE ed.deviceId NOT IN (SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= date('now', '-1 year'))	EnergyManagementDB	3
DROP TABLE IF EXISTS NormalImpact;  DROP TABLE IF EXISTS ExtremeImpact;  CREATE TEMPORARY TABLE NormalImpact AS  SELECT deviceId,         AVG(carbonFootprint) AS avgCarbonFootprint,         AVG(pollutionLevel) AS avgPollutionLevel,         AVG(waterUsage) AS avgWaterUsage,         AVG(landUsage) AS avgLandUsage  FROM EnvironmentalImpact  GROUP BY deviceId;  CREATE TEMPORARY TABLE ExtremeImpact AS  SELECT deviceId,         avgCarbonFootprint * 100 AS extremeCarbonFootprint,         avgPollutionLevel * 100 AS extremePollutionLevel,         avgWaterUsage * 100 AS extremeWaterUsage,         avgLandUsage * 100 AS extremeLandUsage  FROM NormalImpact;  SELECT deviceId,         CASE             WHEN extremeCarbonFootprint = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'carbonFootprint'             WHEN extremePollutionLevel = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'pollutionLevel'             WHEN extremeWaterUsage = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'waterUsage'             WHEN extremeLandUsage = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'landUsage'         END AS maxImpactIndicator,         MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) AS maxImpactValue  FROM ExtremeImpact;  DROP TABLE IF EXISTS NormalImpact;  DROP TABLE IF EXISTS ExtremeImpact;	EnergyManagementDB	4
SELECT deviceId, deviceName, powerRating * efficiency / 100 AS P_actual FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY P_actual DESC LIMIT 5;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ee.energySaved) * 0.5 AS total_cost_savings  FROM EnergyEfficiency ee  JOIN EnergyDevices ed ON ee.deviceId = ed.deviceId  WHERE ee.timestamp >= date('now', '-1 year')  GROUP BY ed.deviceId, ed.deviceName  ORDER BY total_cost_savings DESC  LIMIT 10;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency  FROM EnergyDevices ed  JOIN EnergyPolicies ep ON ed.efficiency < ep.targetEfficiency  ORDER BY ed.efficiency ASC  LIMIT 10;	EnergyManagementDB	3
SELECT deviceId, deviceName, powerRating * 1.0 AS P_actual FROM EnergyDevices ORDER BY P_actual DESC LIMIT 5;	EnergyManagementDB	4
SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY TotalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= datetime('now', '-1 year') GROUP BY ed.deviceType;	EnergyManagementDB	2
WITH MaintenanceCosts AS (     SELECT          deviceId,          SUM(cost) AS totalMaintenanceCost,          COUNT(*) AS maintenanceFrequency,          GROUP_CONCAT(partsReplaced, ', ') AS partsReplacedList      FROM MaintenanceRecords      GROUP BY deviceId )  SELECT      ED.deviceId,      ED.deviceName,      ED.deviceType,      MC.totalMaintenanceCost,      MC.maintenanceFrequency,      MC.partsReplacedList  FROM EnergyDevices ED  JOIN MaintenanceCosts MC ON ED.deviceId = MC.deviceId  ORDER BY MC.totalMaintenanceCost DESC  LIMIT 1;	EnergyManagementDB	3
WITH DeviceEnergy AS (   SELECT      deviceId,      1000000 AS powerRating,      8760 AS hoursInYear,      1000000 * 8760 AS totalEnergyConsumed    FROM      EnergyDevices    WHERE      deviceId = 12345  ),  EnvironmentalImpactAnalysis AS (   SELECT      deviceId,      totalEnergyConsumed,      totalEnergyConsumed * 0.85 AS carbonFootprint,      totalEnergyConsumed * 0.001 AS waterUsage,      totalEnergyConsumed * 0.0001 AS landUsage    FROM      DeviceEnergy  )  SELECT    DE.deviceId,    DE.powerRating,    DE.totalEnergyConsumed,    EIA.carbonFootprint,    EIA.waterUsage,    EIA.landUsage  FROM    DeviceEnergy DE  JOIN    EnvironmentalImpactAnalysis EIA  ON    DE.deviceId = EIA.deviceId;	EnergyManagementDB	4
SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
WITH DeviceEfficiency AS (     SELECT deviceId, AVG(efficiency) AS avgEfficiency      FROM EnergyEfficiency      WHERE timestamp BETWEEN '2023-01-01' AND '2023-12-31'      GROUP BY deviceId ),  OverallAverageEfficiency AS (     SELECT AVG(avgEfficiency) AS overallAvgEfficiency      FROM DeviceEfficiency )  SELECT de.deviceId, de.avgEfficiency  FROM DeviceEfficiency de  CROSS JOIN OverallAverageEfficiency oae  WHERE de.avgEfficiency < oae.overallAvgEfficiency;	EnergyManagementDB	2
SELECT SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.temperature > 30;	EnergyManagementDB	3
WITH DeviceEnergy AS (   SELECT deviceId, 1000000 AS powerRating, 8760 AS hoursInYear    FROM EnergyDevices    WHERE deviceId = 123 )  SELECT    de.deviceId,    de.powerRating * de.hoursInYear AS totalEnergyConsumed,    ei.carbonFootprint,    ei.pollutionLevel,    ei.waterUsage,    ei.landUsage  FROM DeviceEnergy de  JOIN EnvironmentalImpact ei ON de.deviceId = ei.deviceId  WHERE ei.timestamp = (   SELECT MAX(timestamp)    FROM EnvironmentalImpact    WHERE deviceId = de.deviceId );	EnergyManagementDB	4
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) / ((JULIANDAY(MAX(ec.timestamp)) - JULIANDAY(MIN(ec.timestamp))) * 24) AS averagePowerOutput FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY averagePowerOutput DESC LIMIT 1;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ef.forecastValue) AS totalEnergyGenerated, (SUM(ec.energyConsumed) / SUM(ef.forecastValue)) AS energyConsumptionToGenerationRatio FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyForecasts ef ON ed.deviceId = ef.deviceId WHERE ed.deviceType = 'wind' AND ef.forecastType = '5000000.00' GROUP BY ed.deviceId, ed.deviceName ORDER BY energyConsumptionToGenerationRatio ASC;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency  FROM EnergyDevices ed  JOIN EnergyPolicies ep  WHERE ed.installationDate >= '2022-01-01' AND ed.installationDate <= '2022-12-31' AND ed.efficiency < ep.targetEfficiency  ORDER BY ed.efficiency DESC;	EnergyManagementDB	3
WITH DeviceEfficiency AS (   SELECT deviceId, 100 AS efficiency    FROM EnergyDevices ),  TotalEnergy AS (   SELECT      ec.deviceId,      SUM(ec.energyConsumed) AS totalEnergyConsumed,      SUM(ec.energyConsumed / (de.efficiency / 100.0)) AS totalEnergyGenerated    FROM EnergyConsumption ec    JOIN DeviceEfficiency de ON ec.deviceId = de.deviceId    GROUP BY ec.deviceId )  SELECT    te.deviceId,    (te.totalEnergyConsumed / te.totalEnergyGenerated) AS energyRatio  FROM TotalEnergy te  ORDER BY energyRatio ASC;	EnergyManagementDB	4
WITH SolarDeviceEfficiency AS (     SELECT deviceId, efficiency      FROM EnergyDevices      WHERE deviceType = 'solar' ) SELECT      AVG(efficiency) AS average_efficiency,     (SELECT deviceId FROM SolarDeviceEfficiency ORDER BY efficiency DESC LIMIT 1) AS most_efficient_device  FROM SolarDeviceEfficiency;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ed.powerRating * ed.efficiency * ec.energyConsumed) AS totalEnergySaved FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp >= date('now', '-1 year') GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergySaved DESC;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.powerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed  FROM EnergyDevices ed  JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId  WHERE strftime('%Y', ed.installationDate) = '2022'  GROUP BY ed.deviceId, ed.deviceName, ed.powerRating;	EnergyManagementDB	3
WITH DeviceEnergySavings AS (   SELECT      ed.deviceId,      ed.deviceName,      ed.powerRating * (100 - ed.efficiency) / 100 * 365 * 24 AS energySaved    FROM EnergyDevices ed )  SELECT    des.deviceId,    des.deviceName,    des.energySaved  FROM DeviceEnergySavings des  ORDER BY des.energySaved DESC  LIMIT 1;	EnergyManagementDB	4
SELECT deviceId, deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceId ASC;	EnergyManagementDB	1
SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption WHERE timestamp >= date('now', '-1 year') GROUP BY deviceId ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceId, COUNT(maintenanceId) AS maintenanceCount FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenanceCount DESC;	EnergyManagementDB	3
SELECT deviceId, SUM(energySaved * (100.0 / efficiency)) AS totalEnergySaved FROM EnergyEfficiency WHERE efficiency < 100 GROUP BY deviceId ORDER BY totalEnergySaved DESC;	EnergyManagementDB	4
SELECT (1000 * 2 * 0.20 * 24) / 1000 AS daily_energy_output_kWh;	EnergyManagementDB	1
SELECT 0.5 * 1.225 * 3.141592653589793 * POWER(30, 2) * POWER(12, 3) * 0.4 / 1000 AS output_power_kw;	EnergyManagementDB	2
SELECT deviceId, deviceName, powerRating * 8 * 30 AS totalEnergyConsumed, powerRating * 8 * 30 * 0.5 AS totalCost FROM EnergyDevices;	EnergyManagementDB	3
SELECT 0.5 * 1.225 * PI() * POWER(1000, 2) * POWER(50, 3) * 0.4 / 1000 AS output_power_kw;	EnergyManagementDB	4
WITH ManufacturerDevices AS (     SELECT ed.deviceId, ed.efficiency      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'SolarTech' ),  AverageEfficiency AS (     SELECT AVG(efficiency) AS avgEfficiency      FROM ManufacturerDevices )  SELECT md.deviceId, md.efficiency  FROM ManufacturerDevices md, AverageEfficiency ae  WHERE md.efficiency < ae.avgEfficiency;	EnergyManagementDB	1
WITH ManufacturerDevices AS (     SELECT ed.deviceId      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'SolarTech' ), TotalEnergyConsumption AS (     SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed      FROM EnergyConsumption ec      WHERE ec.deviceId IN (SELECT deviceId FROM ManufacturerDevices)      GROUP BY ec.deviceId ) SELECT tec.deviceId, tec.totalEnergyConsumed  FROM TotalEnergyConsumption tec  ORDER BY tec.totalEnergyConsumed DESC  LIMIT 1;	EnergyManagementDB	2
WITH ManufacturerDevices AS (     SELECT ed.deviceId, ed.deviceName, ed.manufacturerId      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'SolarTech' ),  AverageMaintenanceCost AS (     SELECT AVG(mr.cost) AS avgCost      FROM MaintenanceRecords mr      JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId )  SELECT md.deviceId, md.deviceName, mr.cost  FROM MaintenanceRecords mr  JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId  CROSS JOIN AverageMaintenanceCost amc  WHERE mr.cost > amc.avgCost;	EnergyManagementDB	3
WITH IncreasedPower AS (     SELECT          deviceId,          powerRating * 1000 AS increasedPowerRating      FROM EnergyDevices      WHERE manufacturerId = '1' )  SELECT      ec.deviceId,      SUM(ec.energyConsumed * ip.increasedPowerRating) AS totalEnergyConsumed  FROM EnergyConsumption ec  JOIN IncreasedPower ip ON ec.deviceId = ip.deviceId  GROUP BY ec.deviceId  ORDER BY totalEnergyConsumed DESC  LIMIT 1;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed) / (MAX(ec.timestamp) - MIN(ec.timestamp)) AS averagePowerUsage FROM EnergyConsumption ec WHERE ec.deviceId = '1' AND ec.timestamp BETWEEN '2023-06-15' AND '2023-12-15' GROUP BY ec.deviceId;	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= date('now','-1 year') GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	2
SELECT CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END AS humidity_level, SUM(energyConsumed) AS total_energy_consumed FROM EnergyConsumption GROUP BY humidity_level;	EnergyManagementDB	3
WITH TimeDifferences AS (   SELECT      deviceId,      timestamp,      powerUsage,      (LEAD(timestamp) OVER (PARTITION BY deviceId ORDER BY timestamp) - timestamp) AS timeDiff    FROM EnergyConsumption ),  ExtremeEnergyConsumption AS (   SELECT      deviceId,      SUM(powerUsage * 10 * (timeDiff / 3600.0)) AS extremeEnergyConsumed    FROM TimeDifferences    WHERE timeDiff IS NOT NULL    GROUP BY deviceId ),  EnvironmentalImpactAnalysis AS (   SELECT      ei.deviceId,      SUM(ei.carbonFootprint) AS totalCarbonFootprint    FROM EnvironmentalImpact ei    JOIN EnergyConsumption ec ON ei.deviceId = ec.deviceId    GROUP BY ei.deviceId )  SELECT    eec.deviceId,    eec.extremeEnergyConsumed,    eia.totalCarbonFootprint  FROM ExtremeEnergyConsumption eec  JOIN EnvironmentalImpactAnalysis eia ON eec.deviceId = eia.deviceId;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, ei.carbonFootprint AS carbonFootprintCoefficient, SUM(ec.energyConsumed) * ei.carbonFootprint AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ei ON ec.deviceId = ei.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' AND ec.deviceId = '1' GROUP BY ec.deviceId, ei.carbonFootprint;	EnergyManagementDB	1
WITH DeviceEfficiency AS (   SELECT      ed.deviceId,      ed.deviceType,      AVG(ee.efficiency) AS avgEfficiency    FROM EnergyDevices ed    JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId    WHERE ee.timestamp >= date('now', '-1 year')    GROUP BY ed.deviceId, ed.deviceType  )  SELECT    deviceType,    AVG(avgEfficiency) AS avgEfficiencyByType  FROM DeviceEfficiency  GROUP BY deviceType;	EnergyManagementDB	2
SELECT ec.deviceId, AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) AS high_humidity_energy, AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END) AS low_humidity_energy, (AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) - AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END)) AS energy_change FROM EnergyConsumption ec WHERE ec.deviceId = '1' GROUP BY ec.deviceId;	EnergyManagementDB	3
WITH AnnualEnergyConsumption AS (     SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed      FROM EnergyConsumption ec      WHERE ec.timestamp >= date('now', '-1 year')      GROUP BY ec.deviceId ),  CarbonFootprintAnalysis AS (     SELECT aec.deviceId, aec.totalEnergyConsumed,             aec.totalEnergyConsumed * (ei.carbonFootprint * 100) AS totalCarbonEmission,             ei.pollutionLevel, ei.waterUsage, ei.landUsage      FROM AnnualEnergyConsumption aec      JOIN EnvironmentalImpact ei ON aec.deviceId = ei.deviceId      WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = aec.deviceId) )  SELECT cfa.deviceId, cfa.totalEnergyConsumed, cfa.totalCarbonEmission,         cfa.pollutionLevel, cfa.waterUsage, cfa.landUsage,         CASE WHEN cfa.totalCarbonEmission > (SELECT AVG(totalCarbonEmission) FROM CarbonFootprintAnalysis)              THEN 'High Impact' ELSE 'Normal Impact' END AS environmentalImpact  FROM CarbonFootprintAnalysis cfa;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-12-31 23:59:59') - (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-01-01 00:00:00') AS efficiencyChange FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId;	EnergyManagementDB	1
SELECT deviceType, SUM(energySaved) AS totalEnergySaved, SUM(costSavings) AS totalCostSavings FROM EnergyEfficiency JOIN EnergyDevices ON EnergyEfficiency.deviceId = EnergyDevices.deviceId WHERE timestamp >= date('now', '-1 year') GROUP BY deviceType;	EnergyManagementDB	2
SELECT MR.deviceId, COUNT(MR.maintenanceDate) AS maintenanceFrequency, AVG(EE.efficiency) AS averageEfficiency FROM MaintenanceRecords MR JOIN EnergyEfficiency EE ON MR.deviceId = EE.deviceId GROUP BY MR.deviceId ORDER BY maintenanceFrequency, averageEfficiency;	EnergyManagementDB	3
SELECT ed.deviceId, ed.deviceName, ed.deviceType, (ee.energySaved * 10) AS annualEnergySaved, (ee.costSavings * 10) AS annualCostSavings, env.carbonFootprint, env.pollutionLevel FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId JOIN EnvironmentalImpact env ON ed.deviceId = env.deviceId WHERE ed.deviceId = 123;	EnergyManagementDB	4
WITH DeviceEnergy AS (     SELECT          ec.deviceId,          SUM(ec.energyConsumed) AS totalEnergyConsumed,          MIN(ee.efficiency) AS efficiency_start,          MAX(ee.efficiency) AS efficiency_end      FROM          EnergyConsumption ec      JOIN          EnergyEfficiency ee ON ec.deviceId = ee.deviceId      WHERE          ec.timestamp BETWEEN '2023-01-01' AND '2023-12-31'          AND ee.timestamp BETWEEN '2023-01-01' AND '2023-12-31'      GROUP BY          ec.deviceId )  SELECT      de.deviceId,      de.totalEnergyConsumed,      (de.efficiency_end - de.efficiency_start) * 100.0 / de.efficiency_start AS efficiency_change_percentage  FROM      DeviceEnergy de;	EnergyManagementDB	1
SELECT ed.deviceType, AVG(mr.cost) AS avgMaintenanceCost FROM MaintenanceRecords mr JOIN EnergyDevices ed ON mr.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech' GROUP BY ed.deviceType;	EnergyManagementDB	2
SELECT humidity_range, AVG(energyConsumed) AS avg_energy_consumed FROM (SELECT CASE WHEN humidity BETWEEN 0 AND 30 THEN '0-30%' WHEN humidity BETWEEN 31 AND 60 THEN '31-60%' WHEN humidity BETWEEN 61 AND 90 THEN '61-90%' ELSE '91-100%' END AS humidity_range, energyConsumed FROM EnergyConsumption WHERE deviceId = '1') AS subquery GROUP BY humidity_range ORDER BY humidity_range;	EnergyManagementDB	3
WITH DevicePower AS (     SELECT 1000000 AS powerRating ), TotalEnergyConsumed AS (     SELECT powerRating * 24 * 365 AS totalEnergyConsumed FROM DevicePower ), EnvironmentalImpact AS (     SELECT totalEnergyConsumed * (         SELECT AVG(carbonFootprint)          FROM EnvironmentalImpact          WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE powerRating = 1000000)     ) AS carbonFootprint      FROM TotalEnergyConsumed )  SELECT totalEnergyConsumed, carbonFootprint  FROM TotalEnergyConsumed, EnvironmentalImpact;	EnergyManagementDB	4
SELECT (800 * 2 * 0.20 * ((julianday('2023-10-01 12:00:00') - julianday('2023-10-01 00:00:00')) * 24)) / 1000 AS total_energy_output FROM EnergyDevices WHERE deviceType = 'solar';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;	EnergyManagementDB	2
SELECT 0.5 * 100000 AS total_carbon_footprint;	EnergyManagementDB	3
SELECT (2000 * 1000 * 1 * 24) / 1000 AS total_energy_output_kWh;	EnergyManagementDB	4
SELECT SUM((1000 * 2 * 0.2 * (strftime('%s', '2023-10-31 23:59:59') - strftime('%s', '2023-10-01 00:00:00')) / 3600.0)) AS total_energy_generated FROM EnergyConsumption WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE deviceName = 'Solar Panel') AND timestamp BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(80 / 2, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output;	EnergyManagementDB	2
SELECT powerRating * 8 * 365 AS totalEnergyConsumption FROM EnergyDevices WHERE deviceId = '1';	EnergyManagementDB	3
SELECT (powerRating * efficiency * 24 * 365 / 100) AS totalEnergyOutput FROM EnergyDevices WHERE deviceId = '6';	EnergyManagementDB	4
SELECT SUM((ed.powerRating * ed.efficiency * 1000 * (strftime('%s', ec_end.timestamp) - strftime('%s', ec.timestamp)) / 3600)) / 1000 AS totalEnergyGenerated FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyConsumption ec_end ON ec.deviceId = ec_end.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp >= '2023-01-01 00:00:00' AND ec_end.timestamp <= '2023-01-31 23:59:59' GROUP BY ed.deviceId;	EnergyManagementDB	1
WITH PowerData AS (SELECT deviceId, timestamp, powerUsage FROM EnergyConsumption WHERE deviceId = '1' AND timestamp >= '2022-01-01' AND timestamp < '2023-01-01'), EnergyCalculation AS (SELECT deviceId, SUM(powerUsage * 1) AS totalEnergyGenerated FROM PowerData GROUP BY deviceId) SELECT deviceId, totalEnergyGenerated FROM EnergyCalculation;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.nextMaintenanceDate, ec.temperature, CASE WHEN ec.temperature > 30 THEN 'need to increase maintenance frequency' ELSE 'no need to increase maintenance frequency' END AS maintenanceFrequencyRecommendation FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ec.timestamp = (SELECT MAX(timestamp) FROM EnergyConsumption WHERE deviceId = ed.deviceId);	EnergyManagementDB	3
SELECT 10000000 AS power_kw, 10000000 * 24 * 365 AS total_energy_consumption_kwh;	EnergyManagementDB	4
SELECT (efficiency * powerRating * 800 * (strftime('%s', '2023-01-01 12:00:00') - strftime('%s', '2023-01-01 00:00:00')) / 3600) / 1000 AS totalEnergyGenerated FROM EnergyDevices WHERE deviceName = 'Solar Panel';	EnergyManagementDB	1
WITH DeviceInfo AS (     SELECT deviceId, powerRating, efficiency      FROM EnergyDevices      WHERE deviceType = 'wind' AND deviceName = 'FutureDeviceA' ),  EnergyData AS (     SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed      FROM EnergyConsumption      WHERE deviceId = (SELECT deviceId FROM DeviceInfo)      AND timestamp >= datetime('now', '-1 year')      GROUP BY deviceId )  SELECT d.deviceId, d.powerRating * d.efficiency / 100 * 8760 AS estimatedTotalEnergyOutput  FROM DeviceInfo d;	EnergyManagementDB	2
SELECT deviceId, deviceName, 12 / 6 AS maintenanceCount, 12 / 6 * 5000 AS estimatedMaintenanceCost FROM EnergyDevices;	EnergyManagementDB	3
SELECT powerRating * 24 * 365 AS maxEnergyOutput FROM EnergyDevices WHERE deviceId = '1';	EnergyManagementDB	4
SELECT deviceName, powerRating * efficiency AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceName ASC;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	2
SELECT status, COUNT(*) AS device_count FROM EnergyDevices WHERE nextMaintenanceDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status;	EnergyManagementDB	3
SELECT deviceId, deviceName, (100 - efficiency) * powerRating * 8760 AS energySaved FROM EnergyDevices ORDER BY energySaved DESC LIMIT 10;	EnergyManagementDB	4
WITH GreenTechDevices AS (     SELECT ed.deviceId, ed.efficiency      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar' ) SELECT AVG(efficiency) AS average_efficiency FROM GreenTechDevices;  WITH GreenTechDevices AS (     SELECT ed.deviceId, ed.efficiency      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar' ) SELECT deviceId, efficiency FROM GreenTechDevices ORDER BY efficiency DESC LIMIT 5;	EnergyManagementDB	1
SELECT SUM(ed.powerRating) AS total_power, ed.deviceId, ed.powerRating FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'EcoPower' AND ed.deviceType = 'wind' GROUP BY ed.deviceId, ed.powerRating ORDER BY ed.powerRating DESC LIMIT 3;	EnergyManagementDB	2
SELECT AVG(mr.cost) AS average_maintenance_cost FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId JOIN MaintenanceRecords mr ON ed.deviceId = mr.deviceId WHERE m.manufacturerName = 'SunEnergy' AND ed.installationDate < '2020-01-01';	EnergyManagementDB	3
WITH IncreasedPower AS (   SELECT ed.deviceId, ed.powerRating * 1000 AS increasedPowerRating    FROM EnergyDevices ed    JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId    WHERE m.manufacturerName = 'FutureEnergy' )  SELECT deviceId, increasedPowerRating AS powerRating  FROM IncreasedPower  ORDER BY increasedPowerRating DESC  LIMIT 10;	EnergyManagementDB	4
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
WITH AverageEfficiency AS (SELECT AVG(efficiency) AS avg_efficiency FROM EnergyEfficiency) SELECT ed.deviceId, ed.deviceName, ed.efficiency FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId CROSS JOIN AverageEfficiency WHERE ee.efficiency < AverageEfficiency.avg_efficiency;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE lastMaintenanceDate < date('now','-1 year') OR lastMaintenanceDate IS NULL;	EnergyManagementDB	3
WITH AbnormalPowerUsage AS (     SELECT deviceId, timestamp, powerUsage, energyConsumed, temperature, humidity      FROM EnergyConsumption      WHERE powerUsage >= 10000 )  SELECT AP.deviceId, AP.timestamp, AP.powerUsage, AP.energyConsumed, AP.temperature, AP.humidity,         ED.deviceName, ED.deviceType, ED.powerRating, ED.efficiency, ED.status, ED.location,         MR.maintenanceType, MR.maintenanceDescription, MR.nextMaintenanceDate  FROM AbnormalPowerUsage AP  JOIN EnergyDevices ED ON AP.deviceId = ED.deviceId  LEFT JOIN MaintenanceRecords MR ON AP.deviceId = MR.deviceId  ORDER BY AP.timestamp DESC;	EnergyManagementDB	4
SELECT SUM((800 * 2 * 0.2 * (julianday('2023-01-31 23:59:59') - julianday('2023-01-01 00:00:00')) * 24) / 1000) AS total_energy_generated FROM EnergyDevices WHERE deviceType = 'solar';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;	EnergyManagementDB	2
WITH MaxEnergyConsumption AS (     SELECT deviceId, MAX(energyConsumed) AS maxEnergyConsumed      FROM EnergyConsumption      GROUP BY deviceId )  SELECT ec.deviceId, ed.deviceName, mec.maxEnergyConsumed, (mec.maxEnergyConsumed * 0.5) AS hourlyCost  FROM EnergyConsumption ec  JOIN MaxEnergyConsumption mec ON ec.deviceId = mec.deviceId AND ec.energyConsumed = mec.maxEnergyConsumed  JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId  ORDER BY mec.maxEnergyConsumed DESC  LIMIT 1;	EnergyManagementDB	3
WITH EfficiencyData AS (   SELECT 20 AS originalEfficiency,           1000 AS newEfficiency,           100000 AS annualEnergyConsumption,           0.5 AS electricityPrice ) SELECT annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency AS energySaved,         annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency * electricityPrice AS costSavings  FROM EfficiencyData;	EnergyManagementDB	4
WITH DeviceEnergy AS (     SELECT          ec.deviceId,          SUM(ec.powerUsage * (julianday((SELECT MIN(ec2.timestamp) FROM EnergyConsumption ec2 WHERE ec2.deviceId = ec.deviceId AND ec2.timestamp > ec.timestamp)) - julianday(ec.timestamp)) * 86400) / 3600 AS totalEnergyConsumption      FROM EnergyConsumption ec      WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'      GROUP BY ec.deviceId )  SELECT de.deviceId, ed.deviceName, de.totalEnergyConsumption  FROM DeviceEnergy de  JOIN EnergyDevices ed ON de.deviceId = ed.deviceId  ORDER BY de.totalEnergyConsumption DESC  LIMIT 1;	EnergyManagementDB	1
WITH DeviceYearlyEfficiency AS (     SELECT deviceId, AVG(efficiency) AS avgEfficiency      FROM EnergyEfficiency      WHERE timestamp >= date('now','-1 year')      GROUP BY deviceId  ),  OverallAverageEfficiency AS (     SELECT AVG(avgEfficiency) AS overallAvgEfficiency      FROM DeviceYearlyEfficiency  )  SELECT ed.deviceId, ed.deviceName, ed.deviceType, dye.avgEfficiency  FROM DeviceYearlyEfficiency dye  JOIN EnergyDevices ed ON dye.deviceId = ed.deviceId  JOIN OverallAverageEfficiency oae ON dye.avgEfficiency < oae.overallAvgEfficiency;	EnergyManagementDB	2
SELECT ed.deviceName, ed.location  FROM EnergyDevices ed  WHERE ed.deviceId NOT IN (   SELECT mr.deviceId    FROM MaintenanceRecords mr    WHERE mr.maintenanceDate >= date('now', '-1 year') );	EnergyManagementDB	3
WITH DeviceEnergy AS (     SELECT deviceId, powerRating * 24 * 365 AS totalEnergyConsumption     FROM EnergyDevices     WHERE deviceId = '1' ), AllDevicesEnergy AS (     SELECT SUM(powerRating * 24 * 365) AS totalEnergyConsumptionAll     FROM EnergyDevices ) SELECT      DE.totalEnergyConsumption AS SpecificDeviceEnergy,      ADE.totalEnergyConsumptionAll AS AllDevicesEnergy,      DE.totalEnergyConsumption - ADE.totalEnergyConsumptionAll AS EnergyDifference FROM DeviceEnergy DE, AllDevicesEnergy ADE;	EnergyManagementDB	4
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Fuel_Type = 'gasoline' AND Stock_Liters = 10000;	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Profits, (Sales * Net_Profit_Margin / 100) * (Debt_Equity_Ratio + 1) AS Assets FROM company WHERE Sales = 500;	gas	2
SELECT (Minimum_Stock_Liters - Stock_Liters) / 1000 AS Days_Until_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	3
SELECT gs.Capacity_Liters * (g.Price_Liter + g.Tax_per_Liter) AS Total_Revenue FROM gas_station gs JOIN gas g ON gs.Station_ID = g.Station_ID WHERE gs.Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	4
SELECT 50000 * 0.85 AS TotalMass;	gas	1
SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales, Sales * (1 + Revenue_Growth_Rate / 100) * Net_Profit_Margin / 100 AS Projected_Profit FROM company WHERE Company = 'BP China';	gas	2
SELECT CASE WHEN (Stock_Liters - Minimum_Stock_Liters) / 2000 <= 0 THEN 'need to immediately refuel' ELSE 'no need to immediately refuel' END AS RefuelNeeded FROM gas WHERE Station_ID = '1';	gas	3
SELECT 100000 * (5 + 1) AS DailyRevenue, 100000 * 2.5 AS TotalCarbonEmission;	gas	4
SELECT Stock_Liters * Sulfur_Content * 0.001 AS Total_Sulfur_Content_Grams FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	1
SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT CASE WHEN Stock_Liters - ((Stock_Liters - Minimum_Stock_Liters) / 3 * 3) < Minimum_Stock_Liters THEN 'need to replenish in advance' ELSE 'no need to replenish in advance' END AS Need_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	3
SELECT Capacity_Liters * 2.31 AS Total_Carbon_Emission_Grams, (Capacity_Liters * 2.31) / 1000 / 4000 AS Equivalent_Car_Emissions FROM gas_station WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000) AND Stock_Liters = 80000;	gas	1
SELECT Sales * Net_Profit_Margin / 100.0 AS Current_Profits, (Sales * Net_Profit_Margin / 100.0) / 0.20 AS Required_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000.0 AS Remaining_Days FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Minimum_Stock_Liters = 10000) AND Stock_Liters = 9500;	gas	3
SELECT (Stock_Liters - Minimum_Stock_Liters) / 1 AS Required_Time_Seconds FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;	gas	4
SELECT 5000 * Sulfur_Content * 0.001 AS Sulfur_Total_Grams FROM gas WHERE Fuel_Type = 'diesel';	gas	1
SELECT Sales * POWER(1 + Revenue_Growth_Rate / 100.0, 5) AS Future_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT Stock_Liters - Minimum_Stock_Liters AS Max_Sellable_Liters FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 20000 AND gas.Stock_Liters = 5000 AND gas.Minimum_Stock_Liters = 1000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas JOIN gas_station ON gas.Station_ID = gas_station.Station_ID WHERE gas_station.Capacity_Liters = 20000;	gas	4
SELECT Stock_Liters * 35.8 AS Total_Energy_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000 LIMIT 1);	gas	1
SELECT (Debt_Equity_Ratio * (Sales * Net_Profit_Margin / 100.0)) - (0.5 * (Sales * Net_Profit_Margin / 100.0)) AS Debt_Repayment FROM company WHERE Sales = 300 AND Net_Profit_Margin = 12 AND Debt_Equity_Ratio = 0.8;	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Days_Remaining FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 20000 LIMIT 1);	gas	3
SELECT (Stock_Liters * Carbon_Emission) AS Single_Station_Emissions, (Stock_Liters * Carbon_Emission * 1000000) AS Global_Emissions FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000 LIMIT 1);	gas	4
SELECT (50000 * 0.45) AS total_mass_kg, (50000 * 0.45 * 50) AS total_energy_MJ, (50000 * 0.45 * 50 * 0.4) AS electrical_energy_MJ FROM gas WHERE Fuel_Type = 'liquefied natural gas' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000);	gas	1
SELECT (Assets * (2.0 / 3.0)) AS Debt, (Assets * (1.0 / 3.0)) AS Equity, (Assets * (2.0 / 3.0) - (Assets / 2.0)) AS Debt_Repayment FROM company WHERE Assets = 800;	gas	2
WITH daily_consumption AS (     SELECT 1500 AS daily_sales, 20000 AS replenishment_amount, 3 AS replenishment_interval ), inventory_trend AS (     SELECT          30000 AS current_stock,          10000 AS minimum_stock,          (1500 - (20000.0 / 3)) AS net_daily_consumption,          (30000 - 10000 + (20000 * (CAST((30000 - 10000) / (1500 - (20000.0 / 3)) AS INTEGER) / 3))) AS inventory_change      FROM daily_consumption ) SELECT      CASE WHEN inventory_change < 0 THEN 'Yes' ELSE 'No' END AS shortage_occurrence,      CASE WHEN inventory_change < 0 THEN ABS(inventory_change) / net_daily_consumption ELSE 0 END AS shortage_duration_days  FROM inventory_trend;	gas	3
WITH carbon_data AS (   SELECT      50000000 AS daily_sales_liters,      2.31 AS carbon_emission_per_liter_kg,      20 AS carbon_absorption_per_tree_kg,      10 AS land_area_per_tree_sqm ),  total_emission AS (   SELECT      (daily_sales_liters * carbon_emission_per_liter_kg * 365) AS total_carbon_emission_kg    FROM      carbon_data ),  trees_needed AS (   SELECT      (total_carbon_emission_kg / carbon_absorption_per_tree_kg) AS trees_required    FROM      total_emission,      carbon_data ),  land_required AS (   SELECT      (trees_required * land_area_per_tree_sqm / 1000000) AS land_area_sqkm    FROM      trees_needed,      carbon_data )  SELECT    trees_required,    land_area_sqkm  FROM    trees_needed,    land_required;	gas	4
SELECT Capacity_Liters * 0.75 AS Total_Mass_Kg, (Capacity_Liters * 0.75) * 45 AS Total_Energy_MJ FROM gas_station WHERE Station_ID = '1';	gas	1
SELECT (5000 * 5000 * 365 * 0.5) * (1 - 0.3) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';	gas	2
SELECT (2000 * 7) + (5000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';	gas	3
SELECT (1000000 * 2.31 * 10000 * 365) AS Total_Carbon_Emission_Kg, ((1000000 * 2.31 * 10000 * 365) / 10000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';	gas	4
SELECT Stock_Liters * 0.8 AS Total_Mass_Kg, (Stock_Liters * 0.8) * 42 AS Total_Energy_MJ FROM gas WHERE Station_ID = '1';	gas	1
SELECT (8000 * 4000 * 365 * 0.4) * (1 - 0.2) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';	gas	2
SELECT (3000 * 5) + (10000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';	gas	3
SELECT (2000000 * 2.5 * 20000 * 365) AS Total_Carbon_Emission_Kg, ((2000000 * 2.5 * 20000 * 365) / 20000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';	gas	4
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 50000 AND Carbon_Emission = 2.5;	gas	1
SELECT Sales * (Net_Profit_Margin / 100.0) AS Net_Profit, 50.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Sales = 500 AND Net_Profit_Margin = 8;	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000.0 AS Operational_Days FROM gas WHERE Stock_Liters = 15000 AND Minimum_Stock_Liters = 10000;	gas	3
SELECT MIN(1000000, Stock_Liters) AS Available_Stock FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;	gas	4
SELECT Stock_Liters * 0.85 * 45 AS Total_Energy FROM gas WHERE Stock_Liters = 80000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100.0) AS Net_Profit, (Sales * (Net_Profit_Margin / 100.0)) / Assets AS ROA, 100.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Sales = 750 AND Net_Profit_Margin = 12 AND Assets = 2000;	gas	2
SELECT CASE WHEN (Stock_Liters - (3000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning FROM gas WHERE Stock_Liters = 25000 AND Minimum_Stock_Liters = 15000;	gas	3
SELECT CASE WHEN 1500001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete, MIN(1500001, Stock_Liters) AS Max_Sellable FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1500000) AND Stock_Liters = 1499999;	gas	4
SELECT Stock_Liters * 35 * 0.85 AS Available_Energy FROM gas WHERE Stock_Liters = 120000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 150 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 900 AND Net_Profit_Margin = 15 AND Assets = 3000 AND Debt_Equity_Ratio = 1200;	gas	2
SELECT CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 5000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 40000 AND Minimum_Stock_Liters = 25000;	gas	3
SELECT CASE WHEN 3000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(3000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 5000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 3000000) AND Stock_Liters = 2999999;	gas	4
SELECT Stock_Liters * 38 * 0.9 AS Available_Energy FROM gas WHERE Stock_Liters = 200000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 300 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 1500 AND Net_Profit_Margin = 20 AND Assets = 5000 AND Debt_Equity_Ratio = 2000;	gas	2
SELECT CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 6000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 50000 AND Minimum_Stock_Liters = 30000;	gas	3
SELECT CASE WHEN 5000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(5000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 10000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 5000000) AND Stock_Liters = 4999999;	gas	4
SELECT Stock_Liters * 42 * 0.88 AS Available_Energy FROM gas WHERE Stock_Liters = 300000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 500 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 2000 AND Net_Profit_Margin = 25 AND Assets = 6000 AND Debt_Equity_Ratio = 2500;	gas	2
SELECT CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 8000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 70000 AND Minimum_Stock_Liters = 40000;	gas	3
SELECT CASE WHEN 10000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(10000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 20000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 10000000) AND Stock_Liters = 9999999;	gas	4
SELECT Stock_Liters * 46 * 0.92 AS Available_Energy, Stock_Liters * 2.8 AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 500000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 1200 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 4000 AND Net_Profit_Margin = 28 AND Assets = 10000 AND Debt_Equity_Ratio = 4000;	gas	2
SELECT CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 15000 ELSE 0 END AS Days_To_Advance, CASE WHEN (Stock_Liters - (20000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_New_Sales FROM gas WHERE Stock_Liters = 150000 AND Minimum_Stock_Liters = 80000;	gas	3
SELECT CASE WHEN 20000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(20000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 50000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2, 50000000 * 10 AS Order_Total_Amount FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 20000000) AND Stock_Liters = 19999999;	gas	4
SELECT Stock_Liters * 0.83 * 47 AS Total_Energy, Stock_Liters * 50 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100.0 AS Net_Profit, (Sales * Net_Profit_Margin / 100.0) / Assets AS ROA, (Sales * Net_Profit_Margin / 100.0) / (Assets - 550) AS ROE, 550.0 / (Assets - 550) AS Debt_to_Equity_Ratio, 1800.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 20000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (25000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 30000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, MIN(30000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 60000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 60000000 * 12 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.85 * 45 AS Total_Energy, Stock_Liters * 40 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100.0 AS Net_Profit, (Sales * Net_Profit_Margin / 100.0) / Assets AS ROA, (Sales * Net_Profit_Margin / 100.0) / (Assets - 600) AS ROE, 600.0 / (Assets - 600) AS Debt_to_Equity_Ratio, 2000.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 25000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (30000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 50000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, MIN(50000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 100000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 100000000 * 15 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.86 * 49 AS Total_Energy, Stock_Liters * 60 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 900) AS ROE, 900.0 / (Assets - 900) AS Debt_to_Equity_Ratio, 3500.0 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 24000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (29000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 80000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, MIN(80000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 160000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 160000000 * 25 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000 AND Stock_Liters = 80000);	gas	1
SELECT Sales * (Net_Profit_Margin / 100.0) AS Net_Profit FROM company WHERE Sales = 500 AND Net_Profit_Margin = 15;	gas	2
SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters AND Next_Delivery_Date > date('now', '+7 days'));	gas	3
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 1000000000 AND Carbon_Emission = 2.5;	gas	4
SELECT Stock_Liters * 35 AS Total_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 150000 AND Stock_Liters = 120000);	gas	1
SELECT Assets * (Debt_Equity_Ratio / (1.0 + Debt_Equity_Ratio)) AS Total_Liabilities FROM company WHERE Assets = 1500 AND Debt_Equity_Ratio = 0.6;	gas	2
SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters * 1.1 AND Next_Delivery_Date = date('now', '+5 days'));	gas	3
SELECT Stock_Liters * Sulfur_Content AS Total_Sulfur_Content FROM gas WHERE Stock_Liters = 50000000000 AND Sulfur_Content = 50;	gas	4
SELECT Stock_Liters * 40 * 0.85 AS Effective_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 200000 AND Stock_Liters = 180000);	gas	1
SELECT (5 * 500) / Sales * 100 AS Target_Net_Profit_Margin FROM company WHERE Sales = 1200;	gas	2
SELECT Station_ID, Manager_Name  FROM gas_station  WHERE Station_ID IN (     SELECT Station_ID      FROM gas      WHERE Stock_Liters < Minimum_Stock_Liters * 1.1      AND Next_Delivery_Date = date('now', '+3 days') );	gas	3
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 100000000000 AND Carbon_Emission = 5;	gas	4
SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT Capacity_Liters * Carbon_Emission * 365 AS Annual_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT Stock_Liters * 0.85 AS Total_Mass_kg, (Stock_Liters * 0.85) * 45.5 AS Total_Heat_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = '1';	gas	1
SELECT Sales * 1.08 AS Projected_Sales, (Sales * 1.08) * 0.12 AS Projected_Profits FROM company WHERE Company_ID = '104';	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000.0 AS Days_Remaining FROM gas WHERE Station_ID = '1';	gas	3
SELECT 5000000 * 2.31 * 365 AS Annual_Carbon_Emission, 5000000 * 2.31 * 365 * 1000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_kg, (Stock_Liters * 0.75) * 42 AS Total_Heat_MJ FROM gas WHERE Station_ID = '1';	gas	1
SELECT Sales * 1.10 AS Projected_Sales, (Sales * 1.10) * 0.15 AS Projected_Profits, ((Sales * 1.10) * 0.15) * 1.5 AS Total_Debt FROM company WHERE Company_ID = '104';	gas	2
SELECT (30000 - 10000) / 2500 AS Days_Remaining, CASE WHEN 30000 < 10000 THEN 'Yes' ELSE 'No' END AS Need_Refill FROM gas WHERE Station_ID = '1';	gas	3
SELECT 10000000 * 2.5 * 365 AS Annual_Carbon_Emission, 10000000 * 2.5 * 365 * 2000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';	gas	4
SELECT (950.0 / 1050.0) * 100 AS Efficiency FROM generators WHERE GeneratorID = 1001;	generators	1
SELECT SUM(RatedPower) AS TotalPower FROM generators WHERE ManufacturerID = 2001;	generators	2
SELECT GeneratorID, GeneratorName, CASE WHEN ContinualTime > 1000 AND Status = 1 THEN 'need maintenance' ELSE 'no need maintenance' END AS MaintenanceStatus FROM generators WHERE GeneratorID = 1002;	generators	3
SELECT GeneratorID, GeneratorName, CASE WHEN 10000 > RatedRotationSpeed * 1.2 THEN  'exceeds safe range' ELSE 'within safe range' END AS RotationSafetyStatus FROM generators WHERE GeneratorID = 1003;	generators	4
SELECT RatedPower / (RatedVoltage * 1500) AS PowerFactor FROM generators WHERE GeneratorID = 1001;	generators	1
```sql SELECT c.Customer_ID, c.Name, CASE WHEN l.Power_Source = 'Gasoline' THEN (l.Engine_Power * 745.7 * 3600 / 1000) + (pm.Fuel_Consumption * 34.2 * 1000) WHEN l.Power_Source IN ('Electric', 'Battery') THEN (l.Battery_Capacity * 12 * 3.6 * 60) / NULLIF(l.Run_Time, 0) ELSE 0 END AS Total_Energy_kJh FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN performance_metrics pm ON l.Mower_ID = pm.Mower_ID ORDER BY pm.Energy_Efficiency DESC LIMIT 5; ```	lawnmower	1
SELECT Customer_ID, Name, Purchase_Power_Index FROM (SELECT c.Customer_ID, c.Name, log10(c.Annual_Purchase_Volume / AVG(c.Annual_Purchase_Volume) OVER (PARTITION BY c.State)) AS Purchase_Power_Index FROM customers c) AS sub WHERE Purchase_Power_Index > 1.5 ORDER BY Purchase_Power_Index DESC;	lawnmower	2
SELECT DISTINCT c.Customer_ID, c.Name, c.Annual_Purchase_Volume  FROM customers c  JOIN sales s ON c.Customer_ID = s.Customer_ID  JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID  WHERE c.Annual_Purchase_Volume > 500000  AND l.Power_Source = 'Manual'  ORDER BY c.Annual_Purchase_Volume DESC;	lawnmower	3
SELECT m.Name AS Manufacturer_Name, (SUM(s.Quantity) * 100.0 / m.Production_Volume_Total) AS Percentage FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID WHERE c.Annual_Purchase_Volume = 999000000 GROUP BY m.Manufacturer_ID, m.Production_Volume_Total ORDER BY Percentage DESC LIMIT 3;	lawnmower	4
SELECT Country, (SUM(Annual_Purchase_Volume) / 100) * 0.001 AS Total_Mass_kg FROM customers GROUP BY Country;	lawnmower	1
WITH StateTotal AS (     SELECT State, SUM(Annual_Purchase_Volume) AS State_Total      FROM customers      GROUP BY State )  SELECT c.State, c.Customer_Type,         (SUM(c.Annual_Purchase_Volume) * 100.0 / st.State_Total) AS Percentage  FROM customers c  JOIN StateTotal st ON c.State = st.State  GROUP BY c.State, c.Customer_Type  HAVING Percentage > 50;	lawnmower	2
SELECT strftime('%Y', Registration_Date) AS Reg_Year, COUNT(Customer_ID) AS New_Customers FROM customers GROUP BY Reg_Year ORDER BY New_Customers DESC;	lawnmower	3
SELECT Country, AVG(Annual_Purchase_Volume) AS Avg_Purchase FROM customers GROUP BY Country ORDER BY Avg_Purchase DESC;	lawnmower	4
SELECT c.Customer_ID, c.Name FROM customers c WHERE EXISTS (SELECT 1 FROM lawn_mowers lm INNER JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Torque * (c.Annual_Purchase_Volume / lm.Price) > 1000);	lawnmower	1
SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Individual' AND c.Annual_Purchase_Volume > 3 * (SELECT AVG(Annual_Purchase_Volume) FROM customers WHERE Customer_Type = 'Business') AND (SELECT COUNT(*) FROM customers c2 WHERE c2.State = c.State) < 50;	lawnmower	2
SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume < (SELECT AVG(Annual_Purchase_Volume) FROM customers c2 WHERE c2.Customer_Type = 'Individual' AND c2.Country = c.Country);	lawnmower	3
SELECT Customer_ID, Name FROM customers WHERE Annual_Purchase_Volume > (SELECT 10 * SUM(Annual_Purchase_Volume) FROM customers) AND Registration_Date < date('now', '-100 years');	lawnmower	4
SELECT (c.Annual_Purchase_Volume / lm.Price) * lm.Weight * 9.8 * 2 AS Total_Work_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price = 2000 AND lm.Weight = 50 WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume = 1000000;	lawnmower	1
WITH SalesCTE AS (   SELECT      CAST(strftime('%Y', Sale_Date) AS INTEGER) AS yr,      SUM(Total_Price) AS vol    FROM sales    WHERE Customer_ID='2'      AND CAST(strftime('%Y', Sale_Date) AS INTEGER) BETWEEN 2020 AND 2022    GROUP BY yr ),  CAGRData AS (   SELECT      (MAX(CASE WHEN yr=2022 THEN vol END) / MAX(CASE WHEN yr=2020 THEN vol END)) ^ (1.0/2) - 1 AS cagr,      MAX(CASE WHEN yr=2022 THEN vol END) AS end_val    FROM SalesCTE )  SELECT    (cagr * 100) || '%' AS CAGR,    end_val * (1 + cagr) * (1 + cagr) * (1 + cagr) AS Projection_2025  FROM CAGRData;	lawnmower	2
SELECT lm.Power_Source, COUNT(*) AS purchase_count FROM sales s JOIN customers c ON s.Customer_ID = c.Customer_ID JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID WHERE c.State='AK' GROUP BY lm.Power_Source ORDER BY purchase_count DESC LIMIT 1;	lawnmower	3
SELECT 0.5*(c.Annual_Purchase_Volume/lm.Price)*lm.Weight*POWER(11186,2) AS Energy_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price=1 AND lm.Weight=1000000 WHERE c.Annual_Purchase_Volume=1000000000000;	lawnmower	4
SELECT lm.Model, ROUND(lm.Engine_Power / (pm.Blade_Speed * 3.141592653589793 / 30), 2) AS Torque FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' ORDER BY Torque DESC LIMIT 3;	lawnmower	1
SELECT c.Customer_ID, c.Name, ROUND((s.Total_Price + s.Shipping_Cost - (s.Total_Price * s.Discount/100) + (s.Total_Price * s.Tax_Rate/100)), 2) AS Total_Cost FROM sales s JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE c.Customer_Type = 'Business' ORDER BY c.Annual_Purchase_Volume ASC LIMIT 5;	lawnmower	2
SELECT mt.Maintenance_Type, ROUND(AVG(mt.Cost), 2) AS Avg_Cost FROM maintenance mt JOIN lawn_mowers m ON mt.Mower_ID = m.Mower_ID WHERE m.Power_Source = 'Manual' GROUP BY mt.Maintenance_Type ORDER BY Avg_Cost ASC;	lawnmower	3
SELECT lm.Model, pm.Cutting_Efficiency * (lm.Run_Time/60) AS Coverage_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 1 AND pm.Cutting_Efficiency * (lm.Run_Time/60) >= 7140 ORDER BY Coverage_Area DESC LIMIT 1;	lawnmower	4
SELECT Battery_Capacity * 12 * 3600 AS Total_Energy_J, (Battery_Capacity * 12 * 3600) / (Run_Time * 60) AS Avg_Power_W FROM lawn_mowers WHERE Power_Source IN ('Electric','Battery') AND Battery_Capacity = 5 AND Run_Time = 60;	lawnmower	1
SELECT (Engine_Power * 745.7) / Weight AS Power_Density, (Engine_Power * 745.7 * 3600) / 1000000 AS Total_Work_MJ FROM lawn_mowers WHERE Power_Source = 'Gasoline' AND Engine_Power = 5 AND Weight = 50;	lawnmower	2
SELECT lm.Wheel_Size, AVG(pm.Slope_Handling) AS Avg_Slope_Handling FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID=pm.Mower_ID WHERE lm.Wheel_Size IN (6,10) GROUP BY lm.Wheel_Size ORDER BY Wheel_Size DESC;	lawnmower	3
SELECT 0.5*(0.5*lm.Blade_Weight*POWER(lm.Blade_Length/200,2))*POWER(2*PI()*pm.Blade_Speed/60,2) AS Rotational_Energy_J, (0.5*(0.5*lm.Blade_Weight*POWER(lm.Blade_Length/200,2))*POWER(2*PI()*pm.Blade_Speed/60,2))/4184 AS TNT_Equivalent_g FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight=2000 AND pm.Blade_Speed=100000;	lawnmower	4
SELECT Power_Source, AVG(Engine_Power * 745.7 * 3600 / 1000000) AS Avg_Energy_Consumption_MJ FROM lawn_mowers WHERE Power_Source = 'Gasoline' GROUP BY Power_Source;	lawnmower	1
SELECT lm.Model, SUM(pm.Cutting_Efficiency * (lm.Run_Time / 60) * pm.Battery_Life) AS Total_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Electric' GROUP BY lm.Model;	lawnmower	2
SELECT lm.Power_Source, MAX(pm.Cutting_Efficiency * (lm.Run_Time / 60.0)) AS Max_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID GROUP BY lm.Power_Source ORDER BY Max_Area DESC LIMIT 1;	lawnmower	3
SELECT 'Electric' AS Power_Source, (1000 * 10000 / 60 / 1000000) AS Area_km2;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, (lm.Battery_Capacity * 24 * 3600) / (0.5 * 0.5 * lm.Blade_Weight * POWER(lm.Blade_Length/200, 2) * POWER(2 * PI() * pm.Blade_Speed/60, 2) * 60) AS Theoretical_Run_Time_Minutes FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery');	lawnmower	1
SELECT lm.Mower_ID, lm.Model, 2 * 365 * pm.Fuel_Consumption * 3.5 AS Annual_Fuel_Cost FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline';	lawnmower	2
SELECT lm.Mower_ID, lm.Model, lm.Run_Time AS Recorded_Run_Time, (lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) AS Theoretical_Run_Time FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ABS((lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) - lm.Run_Time) / lm.Run_Time > 0.5;	lawnmower	3
SELECT Mower_ID, Model, Weight, Power_Source, Turning_Radius, Blade_Length FROM lawn_mowers WHERE (Power_Source = 'Manual' AND Weight > 1000) OR (Turning_Radius < Blade_Length / 200);	lawnmower	4
SELECT 2.5 * 9.8 * (AVG(Ground_Clearance) / 100.0) AS Work_Joules FROM lawn_mowers;	lawnmower	1
SELECT ROUND((SELECT SUM(Parts_Cost) FROM maintenance WHERE Maintenance_Type='Replacement') * 100.0 / SUM(Parts_Cost), 2) AS Cost_Percentage FROM maintenance;	lawnmower	2
SELECT CASE WHEN (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Routine') < (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Repair') THEN 'conforms to common sense' ELSE 'abnormal' END AS Cost_Comparison;	lawnmower	3
SELECT CASE WHEN 1000000 * (50000 + 1000000) > (SELECT MAX(Revenue) * 10 FROM manufacturers) THEN 'yes' ELSE 'no' END AS Is_Exceed;	lawnmower	4
SELECT Maintenance_ID, (Labor_Cost + Parts_Cost) / (JULIANDAY(Next_Maintenance_Date) - JULIANDAY(Maintenance_Date)) AS Daily_Cost FROM maintenance WHERE Next_Maintenance_Date IS NOT NULL ORDER BY Daily_Cost DESC LIMIT 5;	lawnmower	1
SELECT Maintenance_Type, AVG(Parts_Cost * 100.0 / (Labor_Cost + Parts_Cost)) AS Avg_Parts_Percentage FROM maintenance GROUP BY Maintenance_Type ORDER BY Avg_Parts_Percentage DESC;	lawnmower	2
SELECT * FROM maintenance WHERE Maintenance_Type = 'Replacement' ORDER BY (Labor_Cost + Parts_Cost) DESC LIMIT 5;	lawnmower	3
SELECT * FROM maintenance WHERE Cost > 1000000 ORDER BY Cost DESC LIMIT 3;	lawnmower	4
SELECT m.Service_Center, AVG((1 - POWER(0.8, 2)) * 100) AS Avg_Energy_Reduction_Percent FROM maintenance m JOIN performance_metrics pm ON m.Mower_ID = pm.Mower_ID GROUP BY m.Service_Center;	lawnmower	1
SELECT Service_Center, Maintenance_Type, SUM(Labor_Cost) * 1.0 / NULLIF(SUM(Parts_Cost), 0) AS Labor_Parts_Ratio FROM maintenance GROUP BY Service_Center, Maintenance_Type HAVING SUM(Labor_Cost) * 1.0 / NULLIF(SUM(Parts_Cost), 0) > 2;	lawnmower	2
SELECT c.Customer_Type, COUNT(*) AS Overpriced_Count  FROM maintenance m  JOIN lawn_mowers lm ON m.Mower_ID = lm.Mower_ID  JOIN sales s ON m.Mower_ID = s.Mower_ID  JOIN customers c ON s.Customer_ID = c.Customer_ID  WHERE m.Cost > 0.5 * lm.Price  GROUP BY c.Customer_Type;	lawnmower	3
SELECT Maintenance_Type, 100 * (POWER(1.1, 100) - 1) / 0.1 AS Cumulative_Cost FROM maintenance GROUP BY Maintenance_Type;	lawnmower	4
SELECT m_new.Maintenance_ID, m_new.Mower_ID, (1.0/6) * lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * 3.141592653589793 / 30), 2) AS new_kinetic, (1.0/6) * lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * 3.141592653589793 / 30), 2) AS old_kinetic, (1.0/6) * (lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * 3.141592653589793 / 30), 2) - lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * 3.141592653589793 / 30), 2)) AS energy_diff FROM maintenance m_new JOIN maintenance m_prev ON m_new.Mower_ID = m_prev.Mower_ID AND m_prev.Maintenance_Date = (SELECT MAX(Maintenance_Date) FROM maintenance WHERE Mower_ID = m_new.Mower_ID AND Maintenance_Date < m_new.Maintenance_Date) JOIN lawn_mowers lm_new ON m_new.Mower_ID = lm_new.Mower_ID JOIN lawn_mowers lm_prev ON m_prev.Mower_ID = lm_prev.Mower_ID JOIN performance_metrics pm ON m_new.Mower_ID = pm.Mower_ID JOIN performance_metrics pm_prev ON m_prev.Mower_ID = pm_prev.Mower_ID WHERE m_new.Maintenance_Type = 'Replacement';	lawnmower	1
WITH Stats AS (     SELECT          AVG((Cost - Parts_Cost) * 100.0 / Cost) AS avg_ratio,          STDEV((Cost - Parts_Cost) * 100.0 / Cost) AS std_ratio      FROM maintenance      WHERE Maintenance_Type = 'Repair' ) SELECT      Service_Center,      Maintenance_ID,      (Cost - Parts_Cost) * 100.0 / Cost AS cost_ratio  FROM maintenance  CROSS JOIN Stats  WHERE      Maintenance_Type = 'Repair'      AND (Cost - Parts_Cost) * 100.0 / Cost > (avg_ratio + 3.0 * std_ratio);	lawnmower	2
SELECT Maintenance_ID, Mower_ID, Maintenance_Date, Next_Maintenance_Date FROM maintenance WHERE Maintenance_Type = 'Replacement' AND (julianday(Next_Maintenance_Date) - julianday(Maintenance_Date)) / 30.44 < 6;	lawnmower	3
SELECT m1.Maintenance_ID, m1.Mower_ID, m1.Labor_Cost  FROM maintenance m1  WHERE m1.Labor_Cost > 10 * (SELECT AVG(Cost) * COUNT(*) * 1000 FROM maintenance m2 WHERE m2.Mower_ID = m1.Mower_ID);	lawnmower	4
SELECT (lm.Engine_Power * 5252) / pm.Torque AS Blade_Speed_RPM FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND lm.Engine_Power = 5 AND pm.Torque = 10;	lawnmower	1
SELECT ((m.Revenue * (m.Profit_Margin / 100)) - m.[R&D_Spending]) / m.Employee_Count AS Net_Profit_Per_Employee FROM manufacturers m WHERE m.Revenue = 1000000000 AND m.Profit_Margin = 5 AND m.[R&D_Spending] = 50000000 AND m.Employee_Count = 5000;	lawnmower	2
SELECT CASE WHEN m.Production_Volume_Total > 500000 AND (strftime('%Y', 'now') - m.Founded_Year) = 1 THEN 'unreasonable' ELSE  'reasonable'  END AS Production_Feasibility FROM manufacturers m WHERE m.Production_Volume_Total = 1000000 AND (strftime('%Y', 'now') - m.Founded_Year) = 1;	lawnmower	3
SELECT (m.Revenue * (m.Profit_Margin / 100)) - m.[R&D_Spending] AS New_Net_Profit FROM manufacturers m WHERE m.Revenue = 100000000 AND m.Profit_Margin = 10000 AND m.[R&D_Spending] = 100000000;	lawnmower	4
SELECT Name, (Production_Volume_Total / "R&D_Spending") AS RD_Efficiency FROM manufacturers WHERE "R&D_Spending" > 0 ORDER BY RD_Efficiency DESC LIMIT 5;	lawnmower	1
SELECT Name, (Revenue / NULLIF(Employee_Count, 0)) AS Per_Capita_Output FROM manufacturers WHERE Employee_Count > 0 ORDER BY Per_Capita_Output DESC LIMIT 5;	lawnmower	2
SELECT Country, AVG(2024 - Founded_Year) AS Avg_Years FROM manufacturers GROUP BY Country ORDER BY Avg_Years DESC LIMIT 3;	lawnmower	3
SELECT Name, "R&D_Spending", Revenue FROM manufacturers WHERE "R&D_Spending" > Revenue * 100 ORDER BY "R&D_Spending" DESC LIMIT 5;	lawnmower	4
SELECT Country, SUM("R&D_Spending") * 1.0 / SUM(Employee_Count) AS R_D_Density FROM manufacturers GROUP BY Country ORDER BY R_D_Density DESC;	lawnmower	1
SELECT ROIRatio, COUNT(Country) AS CountryCount FROM (SELECT Country, SUM(Revenue * Profit_Margin / 100.0) / SUM("R&D_Spending") AS ROIRatio FROM manufacturers GROUP BY Country) AS SubQuery GROUP BY ROIRatio;	lawnmower	2
SELECT Country, AVG(Founded_Year) AS AvgFoundedYear, AVG(Employee_Count) AS AvgEmployeeCount FROM manufacturers GROUP BY Country;	lawnmower	3
SELECT Country, AVG((1 - "R&D_Spending" / Revenue) * 100) AS AvgProfitMargin FROM manufacturers WHERE "R&D_Spending" = Revenue * 1000 GROUP BY Country;	lawnmower	4
SELECT Manufacturer_ID, Name FROM manufacturers WHERE ((Revenue * Profit_Margin / 100.0) / (2023 - Founded_Year)) / 31536000.0 BETWEEN 1 AND 10;	lawnmower	1
SELECT Manufacturer_ID, Name FROM manufacturers WHERE (R&D_Spending * 100.0 / Revenue) > 5 AND (Revenue * 1.0 / Employee_Count) > 1000000;	lawnmower	2
SELECT Manufacturer_ID, Name FROM manufacturers WHERE Founded_Year <= 1993 AND Profit_Margin < 15;	lawnmower	3
SELECT Manufacturer_ID, Name FROM manufacturers WHERE R&D_Spending > Market_Cap * 10;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, (pm.Torque * (2 * PI() * pm.Blade_Speed / 60) / 745.7) AS Engine_Power_HP, pm.Cutting_Efficiency FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Cutting_Efficiency = 500;	lawnmower	1
SELECT lm.Mower_ID, lm.Model, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) AS Actual_Energy_Wh, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) / (lm.Run_Time / 60) AS Avg_Power_W, ROUND(pm.Battery_Life / ((2 * 60) / lm.Run_Time) / 365, 1) AS Battery_Life_Years FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND lm.Battery_Capacity = 5 AND pm.Energy_Efficiency = 85 AND lm.Run_Time = 60;	lawnmower	2
SELECT lm.Mower_ID, lm.Model, pm.Noise_Level, CASE WHEN pm.Noise_Level BETWEEN 55 AND 65 THEN 'Compliant' ELSE 'Non-Compliant' END AS Compliance_Status FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND pm.Noise_Level = 95;	lawnmower	3
SELECT lm.Mower_ID, lm.Model, '∞' AS Min_Friction_Coefficient, (lm.Wheel_Size * 0.0254 / 2) * lm.Weight * (9.8 + pm.Acceleration) AS Required_Torque_Nm FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE pm.Slope_Handling = 90 AND lm.Weight = 50 AND lm.Ground_Clearance = 20 AND pm.Acceleration = 10;	lawnmower	4
SELECT pm.Mower_ID, (pm.Torque / (lm.Weight * 0.2)) AS Torque_Acceleration_Ratio FROM performance_metrics pm JOIN lawn_mowers lm ON pm.Mower_ID = lm.Mower_ID ORDER BY Torque_Acceleration_Ratio DESC LIMIT 5;	lawnmower	1
SELECT lm.Mower_ID, (pm.Battery_Life * lm.Run_Time * pm.Energy_Efficiency) / (60.0 * 100.0) AS Total_Hours FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') ORDER BY Total_Hours DESC LIMIT 3;	lawnmower	2
SELECT Mower_ID, Noise_Level, Cutting_Efficiency FROM performance_metrics WHERE Noise_Level < 75 AND Cutting_Efficiency > 200 ORDER BY Noise_Level ASC LIMIT 5;	lawnmower	3
SELECT Mower_ID, Acceleration, Deceleration FROM performance_metrics WHERE Acceleration >= 98 AND Deceleration >= 98 ORDER BY Acceleration DESC LIMIT 3;	lawnmower	4
SELECT m.Name AS Manufacturer, MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) AS Max_Velocity, CASE WHEN MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) > 300 THEN 'Yes' ELSE 'No' END AS Safety_Status FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID GROUP BY m.Name;	lawnmower	1
SELECT p.Fuel_Consumption, SUM(p.Fuel_Consumption * 8 * 0.74 * 44 * 1000000 * 0.22) AS Total_Energy_J FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE l.Power_Source = 'Gasoline' GROUP BY p.Fuel_Consumption;	lawnmower	2
SELECT l.Power_Source, COUNT(*) AS Machine_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE p.Noise_Level > 75 AND p.Mulching_Capability = 1 GROUP BY l.Power_Source;	lawnmower	3
SELECT CASE WHEN p.Acceleration <= 500 THEN '0-500 m/s²' WHEN p.Acceleration <= 1000 THEN '501-1000 m/s²' ELSE '>1000 m/s²' END AS Acceleration_Range, CASE WHEN (l.Blade_Weight * p.Acceleration) / (5 * 0.0001) > 880000000 THEN 'Exceeded' ELSE 'Safe' END AS Strength_Status, COUNT(*) AS Case_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID GROUP BY Acceleration_Range, Strength_Status;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, 0.5 * lm.Blade_Weight * (POW((lm.Blade_Length/100 * 3.141592653589793 * pm.Blade_Speed/60), 2)) AS Kinetic_Energy FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND 0.5 * lm.Blade_Weight * (POW((lm.Blade_Length/100 * 3.141592653589793 * pm.Blade_Speed/60), 2)) > 1000 AND pm.Energy_Efficiency < 80;	lawnmower	1
SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ((pm.Battery_Life * lm.Battery_Capacity * lm.Run_Time / 60 * 48 / 1000) * (pm.Energy_Efficiency / 100) > (SELECT MAX(pm_gas.Fuel_Consumption * 10 * 200 * 34.2 * 0.3) FROM performance_metrics pm_gas JOIN lawn_mowers lm_gas ON pm_gas.Mower_ID = lm_gas.Mower_ID WHERE lm_gas.Power_Source = 'Gasoline'));	lawnmower	2
SELECT lm.Mower_ID, lm.Model  FROM lawn_mowers lm  JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID  WHERE pm.Noise_Level <= 55 AND pm.Vibration_Level < 2.5;	lawnmower	3
SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Battery' AND pm.Battery_Life >= 109500 AND lm.Run_Time >= 1000000 AND lm.Battery_Capacity >= 2500 AND pm.Energy_Efficiency >= 100;	lawnmower	4
SELECT SUM(s.Quantity * lm.Weight) * 9.8 * 1000 AS Total_Work FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID;	lawnmower	1
SELECT ROUND( ( (SELECT SUM(lm.Price * 500 * 0.85) FROM lawn_mowers lm) * 1.085 ) + (50 * 500), 2 ) AS Total_Payment;	lawnmower	2
SELECT ROUND( (500 * 3 * 0.9 * 1.06), 2 ) AS Actual_Payment;	lawnmower	3
SELECT ( ( (SELECT lm.Price FROM lawn_mowers lm LIMIT 1) * 1000000 * (1 - 120/100) ) * (1 + 250/100) ) + (0.01 * 1000000) AS Theoretical_Total_Price;	lawnmower	4
SELECT s.Sale_ID, 0.5 * 0.5 * lm.Blade_Weight * POWER((lm.Blade_Length/200),2) * POWER(2*3.141592653589793*pm.Blade_Speed/60,2) * s.Quantity AS Kinetic_Energy FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID ORDER BY Kinetic_Energy DESC LIMIT 5;	lawnmower	1
SELECT Customer_ID, SUM( (Sale_Price * Quantity * (1 - Discount/100.0) * (1 + Tax_Rate/100.0)) + Shipping_Cost ) AS Total_Payment FROM sales GROUP BY Customer_ID ORDER BY Total_Payment DESC LIMIT 10;	lawnmower	2
WITH Manufacturer_Avg AS (SELECT Manufacturer_ID, AVG(Price) * 0.8 AS Threshold FROM lawn_mowers GROUP BY Manufacturer_ID) SELECT lm.Model, SUM(s.Quantity) AS Total_Sales, CASE WHEN lm.Price < ma.Threshold THEN 'Qualified' ELSE 'Not Qualified' END AS Price_Status FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN Manufacturer_Avg ma ON lm.Manufacturer_ID = ma.Manufacturer_ID GROUP BY lm.Model, lm.Price, ma.Threshold ORDER BY Total_Sales DESC LIMIT 3;	lawnmower	3
SELECT s.Sale_ID, s.Shipping_Cost * 10000 AS Scaled_Shipping, m.Market_Cap FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers m ON lm.Manufacturer_ID = m.Manufacturer_ID WHERE s.Shipping_Cost * 10000 > m.Market_Cap ORDER BY Scaled_Shipping DESC LIMIT 5;	lawnmower	4
SELECT s.Customer_ID, SUM(s.Quantity * lm.Weight) * 9.8 * 1 AS Work_Joules FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID GROUP BY s.Customer_ID;	lawnmower	1
SELECT Payment_Method, (SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) - SUM(sale_price * quantity * 0.6)) / SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) * 100 AS Gross_Profit_Margin FROM sales GROUP BY Payment_Method;	lawnmower	2
SELECT Customer_ID, COUNT(Sale_ID) AS Abnormal_Transactions  FROM sales  WHERE shipping_cost > (Sale_Price * Quantity * 0.1)  GROUP BY Customer_ID;	lawnmower	3
SELECT Sale_Price * 2147483647 * (1 + Tax_Rate/100) AS Total_Price_Validation FROM sales WHERE Customer_ID IN (SELECT Customer_ID FROM customers WHERE Customer_Type = 'Business') LIMIT 1;	lawnmower	4
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND (lm.Engine_Power * 745.7) * (lm.Run_Time * 60) >= 1000 AND NOT EXISTS (SELECT 1 FROM performance_metrics pm WHERE pm.Mower_ID = lm.Mower_ID AND pm.Vibration_Level > 5);	lawnmower	1
SELECT c.Customer_ID, (SUM(m.Cost) / SUM(s.Total_Price)) * 100 AS maintenance_percentage  FROM customers c  JOIN sales s ON c.Customer_ID = s.Customer_ID  JOIN maintenance m ON s.Mower_ID = m.Mower_ID  WHERE c.Customer_Type = 'Business'  AND c.Annual_Purchase_Volume > 50000  AND m.Maintenance_Date BETWEEN s.Sale_Date AND date(s.Sale_Date, '+' || s.Warranty_Period || ' months')  GROUP BY c.Customer_ID  HAVING maintenance_percentage < 15;	lawnmower	2
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE lm.Power_Source = 'Manual' AND lm.Blade_Angle > 35 AND lm.Cutting_Height_Adjustment = 'Mechanical' AND c.City = 'Seattle';	lawnmower	3
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers mf ON lm.Manufacturer_ID = mf.Manufacturer_ID WHERE s.Quantity > mf.Production_Volume_Total * 5 AND s.Shipping_Cost < lm.Price * 0.001;	lawnmower	4
SELECT CEIL( (pm.Torque * pm.Blade_Speed * 3) / ((pm.Energy_Efficiency / 100.0) * 9549) / (lm.Battery_Capacity * 12) ) AS Batteries_Needed FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 10 AND pm.Energy_Efficiency = 85 AND pm.Blade_Speed = 3000 AND pm.Torque = 15;	lawnmower	1
SELECT m.Manufacturer_ID, m.Name, SUM(s.Total_Price * (m.Profit_Margin / 100.0)) / SUM(s.Total_Price) AS Avg_Profit_Margin FROM manufacturers m JOIN lawn_mowers lm ON m.Manufacturer_ID = lm.Manufacturer_ID JOIN sales s ON lm.Mower_ID = s.Mower_ID WHERE m.`R&D_Spending`/ m.Revenue > 0.05 AND m.Revenue > 100000000 AND strftime('%Y', s.Sale_Date) = '2023' GROUP BY m.Manufacturer_ID, m.Name;	lawnmower	2
SELECT CASE WHEN (1.5 * 2 * 4 * 13 * 1.2) > 200 THEN 'Yes' ELSE 'No' END AS Exceeds_200;	lawnmower	3
SELECT CASE WHEN (lm.Weight * 9.8) / (4 * 3.141592653589793 * ((lm.Wheel_Size * 0.0254 / 2) * (lm.Wheel_Size * 0.0254 / 2))) > 200000 THEN 'Yes' ELSE 'No' END AS Exceeds_Pressure FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight = 1000 AND lm.Wheel_Size = 2 AND pm.Slope_Handling >= 30;	lawnmower	4
SELECT m.Model FROM mice m JOIN (SELECT Mouse_ID, SUM(Distance_Moved_Meters) AS total_dist, SUM(Energy_Consumed_Joules) AS total_energy FROM usage_records GROUP BY Mouse_ID) u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND (u.total_dist * m.Weight_Grams) / (u.total_energy / 1000.0) < 5 AND m.Weight_Grams > 100;	mouse	1
WITH CalibrationData AS (     SELECT          Sensor_Id,          Last_Calibration_Date,          LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date      FROM sensor_data )  SELECT      m.Model,      ma.Market_Share_Percent  FROM CalibrationData cd  JOIN sensor_data sd ON cd.Sensor_Id = sd.Sensor_Id  JOIN mice m ON sd.Mouse_Id = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE julianday(cd.Last_Calibration_Date) - julianday(cd.prev_date) < 30  GROUP BY m.Model, ma.Market_Share_Percent  HAVING COUNT(*) > 5;	mouse	2
SELECT u.User_ID, m.Weight_Grams FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id WHERE u.Max_Dpi > 16000 AND u.Usage_Duration_Minutes > 120;	mouse	3
SELECT 0.62 * (Weight_Grams/1000.0) * (24.79 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'G502 HERO';	mouse	4
WITH EfficiencyData AS (   SELECT      m.Mouse_Id,      m.Model,      m.Weight_Grams,      AVG((u.Distance_Moved_Meters * m.Weight_Grams) / (u.Energy_Consumed_Joules / 1000.0)) AS normal_efficiency    FROM mice m    JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID    WHERE m.Is_Wireless = 1 AND m.Acceleration_G < 10    GROUP BY m.Mouse_Id, m.Model, m.Weight_Grams ),  ExtremeEfficiency AS (   SELECT      m.Mouse_Id,      (u.Distance_Moved_Meters * m.Weight_Grams) / (u.Energy_Consumed_Joules / 1000.0) AS extreme_efficiency    FROM mice m    JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID    WHERE m.Is_Wireless = 1 AND m.Acceleration_G > 50 )  SELECT e.Model  FROM EfficiencyData e  JOIN ExtremeEfficiency ex ON e.Mouse_Id = ex.Mouse_Id  WHERE (e.normal_efficiency - ex.extreme_efficiency) / e.normal_efficiency * 100.0 > 30.0 AND e.Weight_Grams > 100;	mouse	1
WITH ClickFrequency AS (     SELECT          User_ID,          Mouse_ID,          Clicks,          Usage_Duration_Minutes,          Clicks / (Usage_Duration_Minutes / 60.0) AS click_freq,          SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_clicks,          SUM(Usage_Duration_Minutes) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_duration      FROM usage_records )  SELECT DISTINCT cf.User_ID, m.Model  FROM ClickFrequency cf  JOIN mice m ON cf.Mouse_ID = m.Mouse_Id  WHERE cf.click_freq > 600 AND cf.total_duration > 5;	mouse	2
WITH CalibrationIntervals AS (     SELECT Sensor_Id, Last_Calibration_Date,             LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date      FROM sensor_data ) SELECT m.Model, ma.Profit_Usd  FROM CalibrationIntervals ci  JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id  JOIN mice m ON sd.Mouse_Id = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_ID  WHERE (julianday(ci.Last_Calibration_Date) - julianday(ci.prev_date)) < 7  AND ur.Mouse_ID IN (     SELECT Mouse_ID      FROM usage_records      WHERE EXISTS (         SELECT 1          FROM sensor_data sd2          JOIN mice m2 ON sd2.Mouse_Id = m2.Mouse_Id          WHERE m2.Mouse_Id = ur.Mouse_ID          AND sd2.Sensor_Type LIKE '%CMOS%'          AND ur.Average_Dpi > 0      )     GROUP BY Mouse_ID      HAVING AVG(ur.Energy_Consumed_Joules / ur.Usage_Duration_Minutes) * 60 > 45  );	mouse	3
SELECT 0.0001 * (Weight_Grams/1000) * (274 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'DeathAdder V2';	mouse	4
SELECT m.Model FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Tracking_Speed_Ips > 400 AND m.Polling_Rate_Hz > 1000 AND (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules * 100 < 60;	mouse	1
WITH ClickFrequency AS (     SELECT          User_ID,          Mouse_ID,          Start_Time,          Clicks,          SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS 4 PRECEDING) / 5.0 AS window_freq      FROM usage_records ),  ConsecutiveHighFreq AS (     SELECT          User_ID,          Mouse_ID,          window_freq,          LAG(window_freq, 1) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq1,          LAG(window_freq, 2) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq2      FROM ClickFrequency      WHERE window_freq > 1200 )  SELECT DISTINCT chf.User_ID, m.Acceleration_G  FROM ConsecutiveHighFreq chf  JOIN mice m ON chf.Mouse_ID = m.Mouse_Id  WHERE chf.window_freq > 1200 AND chf.prev_freq1 > 1200 AND chf.prev_freq2 > 1200;	mouse	2
SELECT m.Model, ma.Founded_year FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE sd.Lift_Off_Distance_Mm < 1.5 AND sd.Max_Dpi > 18000;	mouse	3
SELECT (2.3e-5 * 10 * 600) / SQRT(10 * 5) * 100 AS precision_error FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	4
SELECT m.Model  FROM mice m  JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID  WHERE ((u.Distance_Moved_Meters * m.Weight_Grams * POW((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Distance_Moved_Meters / 1000)) / (u.Usage_Duration_Minutes * 60) > 10  AND (u.Distance_Moved_Meters * m.Weight_Grams * POW((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Energy_Consumed_Joules * 1000) * 100 < 40;	mouse	1
WITH ClickPatterns AS (     SELECT User_ID, Mouse_ID, Clicks, (log(Clicks) / log(2)) AS log2_clicks      FROM usage_records      WHERE Clicks > 0 AND (log(Clicks) / log(2)) % 1 = 0 ) SELECT cp.User_ID, m.Polling_Rate_Hz  FROM ClickPatterns cp  JOIN mice m ON cp.Mouse_ID = m.Mouse_Id;	mouse	2
SELECT u.User_ID, ma.Market_Share_Percent FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE m.Weight_Grams > 150 AND (u.Usage_Duration_Minutes / 60.0) / 7.0 > 8;	mouse	3
SELECT (6.626e-34 / (2 * ("Weight_Grams"/1000.0) * SQRT(2 * ("Weight_Grams"/1000.0) * 1.6e-19))) * ("Weight_Grams"/1000.0) * 9.8e12 * 0.001 AS Energy_Joules FROM mice WHERE "Is_Wireless" = 1;	mouse	4
SELECT m.Model FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Acceleration_G > 80 AND ((m.Weight_Grams / 1000.0) * (m.Tracking_Speed_Ips * 0.0254) * m.Polling_Rate_Hz) > 1;	mouse	1
WITH ClickSequences AS (   SELECT      User_ID,      Mouse_ID,      Start_Time,      Clicks,      LAG(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_clicks    FROM usage_records ),  TransitionMatrix AS (   SELECT      User_ID,      Mouse_ID,      COUNT(*) AS total_transitions,      SUM(CASE WHEN Clicks = prev_clicks THEN 1 ELSE 0 END) AS same_state_count    FROM ClickSequences    GROUP BY User_ID, Mouse_ID )  SELECT tm.User_ID, sd.Sensor_Life_Hours  FROM TransitionMatrix tm  JOIN sensor_data sd ON tm.Mouse_ID = sd.Mouse_Id  WHERE (CAST(same_state_count AS REAL) / total_transitions) > 0.5;	mouse	2
WITH CalibrationIntervals AS (     SELECT          Sensor_Id,          Last_Calibration_Date,          LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date      FROM sensor_data     WHERE EMI_Level > 30 ) SELECT      m.Model,      ma.Founded_year  FROM CalibrationIntervals ci  JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id  JOIN mice m ON sd.Mouse_Id = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE m.Is_Wireless = 1  AND julianday(ci.Last_Calibration_Date) - julianday(ci.prev_date) < 3;	mouse	3
SELECT (2 * 1e8 * 0.01) AS Photon_Force_N FROM mice WHERE Is_Wireless = 1;	mouse	4
WITH EnergyAnalysis AS (     SELECT          m.Mouse_Id,          m.Model,          m.Acceleration_G,          m.Weight_Grams,          u.Energy_Consumed_Joules,          u.Distance_Moved_Meters      FROM mice m      JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID      JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id      WHERE ABS(u.Max_Dpi - u.Average_Dpi) > 8000 )  SELECT ea.Model  FROM EnergyAnalysis ea  WHERE (1.0 - ((ea.Distance_Moved_Meters * ea.Weight_Grams * 9.8) / ea.Energy_Consumed_Joules)) * 100.0 > 25.0  AND ea.Acceleration_G > 50.0;	mouse	1
WITH ClickIntervals AS (     SELECT          User_ID,          Mouse_ID,          Start_Time,          LAG(Start_Time) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_time      FROM usage_records ), RS_Analysis AS (     SELECT          User_ID,          Mouse_ID,          LOG(MAX(Start_Time) - MIN(Start_Time) + 1) / LOG(COUNT(*) + 1) AS Hurst_Index      FROM ClickIntervals      GROUP BY User_ID, Mouse_ID      HAVING COUNT(*) >= 10 ) SELECT rs.User_ID, ma.Market_Share_Percent  FROM RS_Analysis rs  JOIN mice m ON rs.Mouse_ID = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE rs.Hurst_Index > 0.8;	mouse	2
SELECT m.Model, ma.Complaint_Rate  FROM mice m  JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE (u.Usage_Duration_Minutes / 60.0) / m.Battery_Life_Hours < 0.5  AND m.Is_Wireless = 1;	mouse	3
SELECT ( (20 * LOG(160 / 1e6) / LOG(10) + 50) - 10 * LOG(1.6e6 / (2 * PI() * 160 * 1e-4)) / LOG(10) ) / (4 * PI() * SQRT(PI() * 160 * 1e-4 * 1.6e6)) AS Shield_Thickness_m FROM mice WHERE Sensor_Type = 'Laser';	mouse	4
SELECT 0.5 * 0.133 * POWER(40 * 9.8 * 7200, 2) AS Kinetic_Energy_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
SELECT ma.Manufacturer_Name, AVG(CASE WHEN m.Is_Wireless = 1 THEN m.Price_Usd END) / AVG(CASE WHEN m.Is_Wireless = 0 THEN m.Price_Usd END) AS Wireless_Wired_Ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name ORDER BY Wireless_Wired_Ratio DESC LIMIT 5;	mouse	2
SELECT DISTINCT m.Model, 'High Risk' AS Risk_Level FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Tracking_Speed_Ips > 0.9 * sd.Tracking_Speed_Ips;	mouse	3
SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT m.Weight_Grams / 1000.0 * (50.0 * 9.8) * (50.0 * 9.8 * 150.0 * 60.0) AS Power_W FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'DeathAdder V2' AND u.User_ID = 102;	mouse	1
SELECT m.Model, (m.Price_Usd / m.Dpi) AS Usd_Per_Dpi FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE ma.Revenue_Usd > 1000000000 AND ma.Market_Share_Percent > 10 ORDER BY Usd_Per_Dpi ASC LIMIT 3;	mouse	2
SELECT m.Model, (u.Usage_Duration_Minutes - m.Battery_Life_Hours * 60) * 1.0 / u.Usage_Duration_Minutes AS Shortage_Ratio FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND u.Usage_Duration_Minutes > m.Battery_Life_Hours * 60;	mouse	3
SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'Dark Core RGB Pro';	mouse	4
SELECT (m.Weight_Grams / 1000.0) * (m.Acceleration_G * 9.8) * u.Distance_Moved_Meters AS Mechanical_Work_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
WITH MarketShare AS (     SELECT Country, SUM(Market_Share_Percent) AS Total_Market_Share      FROM manufacturers      GROUP BY Country      ORDER BY Total_Market_Share DESC      LIMIT 3 ),  TopManufacturers AS (     SELECT ma.Manufacturer_Id, ma.Manufacturer_Name      FROM manufacturers ma      JOIN MarketShare ms ON ma.Country = ms.Country      ORDER BY (ma.Profit_Usd * 1.0 / ma.Employees) DESC      LIMIT 1 )  SELECT m.Model, (m.Dpi * m.Dpi * 1.0 / m.Price_Usd) AS Dpi2_Per_Usd  FROM mice m  JOIN TopManufacturers tm ON m.Manufacturer_Id = tm.Manufacturer_Id;	mouse	2
WITH CalibrationIntervals AS (     SELECT          Sensor_Id,          (julianday(Last_Calibration_Date) - julianday(LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date))) AS Calibration_Interval      FROM sensor_data ),  ClickStats AS (     SELECT          Mouse_ID,          AVG(Clicks / (julianday(End_Time) - julianday(Start_Time))) AS Avg_Clicks_Per_Day,          (SELECT STDEV(Clicks / (julianday(End_Time) - julianday(Start_Time))) FROM usage_records WHERE Mouse_ID = ur.Mouse_ID) AS Std_Clicks_Per_Day      FROM usage_records ur      GROUP BY Mouse_ID )  SELECT m.Model  FROM mice m  JOIN CalibrationIntervals ci ON m.Mouse_Id = ci.Sensor_Id  JOIN ClickStats cs ON m.Mouse_Id = cs.Mouse_ID  WHERE ci.Calibration_Interval > 30  AND (cs.Avg_Clicks_Per_Day > (SELECT AVG(Avg_Clicks_Per_Day) + 2 * (SELECT STDEV(Avg_Clicks_Per_Day) FROM ClickStats) FROM ClickStats));	mouse	3
SELECT Tracking_Speed_Ips * Polling_Rate_Hz AS Interrupts_Per_Second FROM mice WHERE Model = 'G502 HERO';	mouse	4
SELECT ((m.Weight_Grams / 1000.0) * m.Acceleration_G * 9.8 * u.Distance_Moved_Meters) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
SELECT Manufacturer_Name, Market_Share_Percent * (Profit_Usd / Employees) AS Composite_Index FROM manufacturers WHERE Market_Share_Percent * (Profit_Usd / Employees) > 100 AND Founded_year < (strftime('%Y', 'now') - 20) ORDER BY Composite_Index DESC LIMIT 5;	mouse	2
SELECT m.Model, ROUND(m.Battery_Life_Hours / (AVG(u.Usage_Duration_Minutes) / 60.0), 2) AS Max_Usage_Days FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Battery_Life_Hours HAVING m.Battery_Life_Hours < AVG(u.Usage_Duration_Minutes) / 60.0;	mouse	3
SELECT Polling_Rate_Hz * Acceleration_G AS Packets_Per_Second FROM mice WHERE Polling_Rate_Hz = 2000 AND Acceleration_G = 50;	mouse	4
SELECT (u.Distance_Moved_Meters / (sd.Lift_Off_Distance_Mm / 1000.0)) * 0.5 * 1e-3 AS Total_Energy_Loss_J FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
WITH ManufacturerStats AS (     SELECT          ma.Manufacturer_Id,          (STDEV(m.Price_Usd) / AVG(m.Price_Usd)) AS Price_CV,          ma.Market_Share_Percent      FROM          manufacturers ma      JOIN          mice m ON ma.Manufacturer_Id = m.Manufacturer_Id      WHERE          (strftime('%Y', 'now') - ma.Founded_year) > 25          AND m.Is_Wireless = 1      GROUP BY          ma.Manufacturer_Id, ma.Market_Share_Percent ) SELECT      Manufacturer_Id,      (SUM(Price_CV * Market_Share_Percent) - SUM(Price_CV) * SUM(Market_Share_Percent) / COUNT(*)) / COUNT(*) AS Covariance  FROM      ManufacturerStats  GROUP BY      Manufacturer_Id  ORDER BY      ABS(Covariance) DESC;	mouse	2
SELECT m.Model, SUM(u.Clicks) * 1.0 / SUM(u.Usage_Duration_Minutes) AS Click_Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 0 AND m.Weight_Grams > 100 AND m.Cable_Length_Meters < 1.5 GROUP BY m.Model;	mouse	3
SELECT (1 / 5.39e-44) * (18000 / 25.4) * 8 / pow(10, 24) AS Data_Volume_YB FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	4
SELECT (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
SELECT ma.Manufacturer_Name, AVG(CAST(m.Dpi AS REAL) / m.Price_Usd) AS Dpi_Per_Usd FROM manufacturers ma JOIN mice m ON ma.Manufacturer_Id = m.Manufacturer_Id WHERE 2023 - ma.Founded_year > 20 AND (CAST(ma.Profit_Usd AS REAL) / ma.Employees) > 200000 GROUP BY ma.Manufacturer_Name;	mouse	2
SELECT m.Model, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS Daily_Clicks, CASE WHEN SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) > 8000 AND m.Weight_Grams > 120 THEN 'High Risk' ELSE 'Normal' END AS Risk_Level FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Weight_Grams;	mouse	3
SELECT sd.Tracking_Speed_Ips * sd.Max_Dpi AS Data_Points_Per_Second FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro';	mouse	4
SELECT (m.Weight_Grams/1000.0) * POWER(2 * 3.141592653589793 * sd.Polling_Rate_Hz, 2) * (sd.Acceleration_G * 9.8 / SQRT(2)) AS Inertial_Force FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Model = 'G502 HERO' AND ur.User_ID = 101 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');	mouse	1
WITH Market_HHI AS (     SELECT SUM(Market_Share_Percent * Market_Share_Percent) AS HHI     FROM manufacturers ), Manufacturer_DPI AS (     SELECT Manufacturer_Id, Dpi,             CAST(COUNT(*) AS REAL) / SUM(COUNT(*)) OVER(PARTITION BY Manufacturer_Id) AS ratio     FROM mice     GROUP BY Manufacturer_Id, Dpi ), Entropy_Calc AS (     SELECT Manufacturer_Id,             -SUM(ratio * (CASE WHEN ratio > 0 THEN ln(ratio) ELSE 0 END)) AS entropy     FROM Manufacturer_DPI     GROUP BY Manufacturer_Id ) SELECT (AVG(mh.HHI * ec.entropy) - AVG(mh.HHI) * AVG(ec.entropy)) /         (STDDEV_SAMP(mh.HHI) * STDDEV_SAMP(ec.entropy)) AS Pearson_Correlation FROM Market_HHI mh, Entropy_Calc ec;	mouse	2
WITH Efficiency_Data AS (SELECT m.Model, ur.Clicks/ur.Usage_Duration_Minutes AS current_efficiency, MAX(ur.Clicks/ur.Usage_Duration_Minutes) OVER() AS max_efficiency FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Weight_Grams > 100 AND m.Buttons < 6) SELECT Model, ROUND(max_efficiency - current_efficiency, 4) AS efficiency_decay FROM Efficiency_Data;	mouse	3
WITH constants AS (   SELECT 6.67430e-11 AS G, 1.989e30 AS M, 299792458 AS c, 0.9 AS factor ), sqrt_part AS (   SELECT SQRT(POWER(M, 2) - POWER(factor * M, 2)) AS sqrt_value   FROM constants ), numerator AS (   SELECT 1 - SQRT(1 - (2 * G * M) / (POWER(c, 2) * (M + sqrt_value))) AS num   FROM constants, sqrt_part ), denominator AS (   SELECT 1 + (factor * c * POWER(M + sqrt_value, 3)) / POWER(c, 3) AS denom   FROM constants, sqrt_part ) SELECT m.Dpi * (num / denom) AS DPI_Error FROM mice m, numerator, denominator WHERE m.Model = 'DeathAdder V2'   AND m.Manufacturer_Id = (     SELECT Manufacturer_Id     FROM manufacturers     WHERE Manufacturer_Name = 'Razer'   );	mouse	4
SELECT (ur.Clicks * 0.0002) + (m.Weight_Grams/1000 * 9.8 * 0.003 * ur.Clicks) AS Total_Energy_J FROM usage_records ur JOIN mice m ON ur.Mouse_Id = m.Mouse_Id JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'DeathAdder V2' AND ur.User_ID = 102 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');	mouse	1
WITH YearSeries AS (     SELECT 0 AS year      UNION ALL SELECT 1      UNION ALL SELECT 2 ),  MarketData AS (     SELECT m.Manufacturer_Id,             CAST(strftime('%Y', date('now')) AS INTEGER) - ys.year AS Year,             COALESCE(m.Market_Share_Percent, 0) AS Share      FROM manufacturers m      CROSS JOIN YearSeries ys      WHERE m.Founded_year <= CAST(strftime('%Y', date('now')) AS INTEGER) - ys.year ),  TransProb AS (     SELECT curr.Manufacturer_Id,             (curr.Share - prev.Share) / NULLIF(prev.Share, 0) AS Prob      FROM MarketData curr      JOIN MarketData prev ON curr.Manufacturer_Id = prev.Manufacturer_Id AND curr.Year = prev.Year + 1 ),  Entropy AS (     SELECT Manufacturer_Id,             -SUM((cnt * 1.0 / total) * (CASE WHEN cnt * 1.0 / total = 0 THEN 0 ELSE LN(cnt * 1.0 / total) END)) AS entropy      FROM (         SELECT Manufacturer_Id,                 Dpi,                 COUNT(*) AS cnt,                 SUM(COUNT(*)) OVER (PARTITION BY Manufacturer_Id) AS total          FROM mice          GROUP BY Manufacturer_Id, Dpi     ) t      GROUP BY Manufacturer_Id )  SELECT t.Manufacturer_Id,         SUM(t.Prob * (CASE WHEN t.Prob * 1.0 / NULLIF(e.entropy, 0) = 0 THEN 0 ELSE LN(t.Prob * 1.0 / NULLIF(e.entropy, 0)) END)) AS KL_Divergence  FROM TransProb t  JOIN Entropy e ON t.Manufacturer_Id = e.Manufacturer_Id  GROUP BY t.Manufacturer_Id;	mouse	2
SELECT m.Model, (ur.Scrolls/ur.Usage_Duration_Minutes) * POW(m.Weight_Grams/1000.0,2)/NULLIF(m.Cable_Length_Meters,0) AS Fatigue_Factor FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Cable_Length_Meters < 1 AND m.Weight_Grams > 150;	mouse	3
SELECT m.Dpi * (1.0 * 1e43 * 1e-43) / 1.32934 AS Effective_DPI FROM mice m WHERE m.Model = 'G502 HERO' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');	mouse	4
SELECT (m.Weight_Grams/1000.0 * POWER(sd.Acceleration_G * 9.8, 2)) / 3000.0 * (m.Cable_Length_Meters / (0.2 * 3.141592653589793 * POWER(0.001, 2))) AS Thermal_Power_W FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Corsair');	mouse	1
WITH Market_Share_Data AS (     SELECT          Manufacturer_Id,          Market_Share_Percent,          ROW_NUMBER() OVER (PARTITION BY Manufacturer_Id ORDER BY Founded_year) AS rn      FROM manufacturers ),  GM_Model AS (     SELECT          Manufacturer_Id,          (FIRST_VALUE(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id ORDER BY rn) -          (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) * 1.0 / COUNT(*) OVER (PARTITION BY Manufacturer_Id))) * EXP(-0.5 * (rn-1)) +          (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) * 1.0 / COUNT(*) OVER (PARTITION BY Manufacturer_Id)) AS Predicted_Share      FROM Market_Share_Data ),  Mouse_Matrix AS (     SELECT          Manufacturer_Id,          AVG(Dpi) AS avg_dpi,          AVG(Price_Usd) AS avg_price,          AVG(Weight_Grams) AS avg_weight      FROM mice      GROUP BY Manufacturer_Id ),  SVD_Decomp AS (     SELECT          Manufacturer_Id,          avg_dpi / SQRT(avg_dpi*avg_dpi + avg_price*avg_price + avg_weight*avg_weight) AS u1,          avg_price / SQRT(avg_dpi*avg_dpi + avg_price*avg_price + avg_weight*avg_weight) AS u2,          avg_weight / SQRT(avg_dpi*avg_dpi + avg_price*avg_price + avg_weight*avg_weight) AS u3      FROM Mouse_Matrix ),  Covariance_Matrix AS (     SELECT          gm.Manufacturer_Id,          gm.Predicted_Share * svd.u1 AS cov1,          gm.Predicted_Share * svd.u2 AS cov2,          gm.Predicted_Share * svd.u3 AS cov3      FROM GM_Model gm      JOIN SVD_Decomp svd ON gm.Manufacturer_Id = svd.Manufacturer_Id )  SELECT      AVG(cov1) / SQRT(AVG(gm.Predicted_Share * gm.Predicted_Share) * AVG(svd.u1 * svd.u1)) AS rho1,      AVG(cov2) / SQRT(AVG(gm.Predicted_Share * gm.Predicted_Share) * AVG(svd.u2 * svd.u2)) AS rho2,      AVG(cov3) / SQRT(AVG(gm.Predicted_Share * gm.Predicted_Share) * AVG(svd.u3 * svd.u3)) AS rho3  FROM Covariance_Matrix cm  JOIN GM_Model gm ON cm.Manufacturer_Id = gm.Manufacturer_Id  JOIN SVD_Decomp svd ON cm.Manufacturer_Id = svd.Manufacturer_Id;	mouse	2
SELECT m.Model, (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 AS Efficiency_Percent FROM mice m WHERE m.Is_Wireless = 1 AND EXISTS (SELECT 1 FROM sensor_data sd WHERE sd.Mouse_Id = m.Mouse_Id AND sd.Max_Dpi > 16000) AND (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 < 80;	mouse	3
SELECT m.Dpi * (1 + 1100) / (70 * 4.4e26 / 3.086e19) * LN(1.6e-35/1.6e-35) AS Effective_DPI FROM mice m WHERE m.Model = 'DeathAdder V2' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');	mouse	4
SELECT 20*(LOG10(4*PI()*1*(2.4e9/3e8)))/LOG(10) - 2 - 2 AS Path_Loss_dB FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Is_Wireless = 1;	mouse	1
CREATE TEMPORARY TABLE BaseData AS SELECT mf.Market_Share_Percent AS Y, md.Dpi AS X1, md.Price_Usd AS X2 FROM mice md JOIN manufacturers mf ON md.Manufacturer_Id = mf.Manufacturer_Id; CREATE TEMPORARY TABLE Stats AS SELECT AVG(Y) AS y_bar, AVG(X1) AS x1_bar, AVG(X2) AS x2_bar, AVG(Y * X1) - AVG(Y) * AVG(X1) AS cov_yx1, AVG(Y * X2) - AVG(Y) * AVG(X2) AS cov_yx2, AVG(X1 * X1) - AVG(X1) * AVG(X1) AS var_x1, AVG(X2 * X2) - AVG(X2) * AVG(X2) AS var_x2, AVG(X1 * X2) - AVG(X1) * AVG(X2) AS cov_x1x2 FROM BaseData; CREATE TEMPORARY TABLE Coefficients AS SELECT (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) AS beta1, (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) AS beta2, y_bar - ( (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) ) * x1_bar - ( (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) ) * x2_bar AS beta0 FROM Stats; CREATE TEMPORARY TABLE Predicted AS SELECT b.Y, c.beta0 + c.beta1 * b.X1 + c.beta2 * b.X2 AS Y_hat FROM BaseData b CROSS JOIN Coefficients c; SELECT 1 - SUM((Y - Y_hat) * (Y - Y_hat)) / SUM((Y - (SELECT y_bar FROM Stats)) * (Y - (SELECT y_bar FROM Stats))) AS R_squared FROM Predicted;	mouse	2
SELECT m.Model, (ur.Energy_Consumed_Joules / (3600 * 1000)) * 18 * 365 * 0.85 AS Annual_CO2_kg FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Is_Wireless = 1 AND (ur.Energy_Consumed_Joules / (3600 * ur.Usage_Duration_Minutes * 60)) > 0.5;	mouse	3
SELECT m.Dpi * POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000.0 * 100.0))/(1e-6), 2.0) * LN(1e-4/(PI()*POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000.0 * 100.0)),2.0))) AS DPI_Error FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT ROUND( (0.5 * (m.Weight_Grams / 1000.0) * POWER(s.Tracking_Speed_Ips * 0.0254, 2) - 0.2 * (m.Weight_Grams / 1000.0) * 9.8 * u.Distance_Moved_Meters * SIN(RADIANS(15.0))) / (u.Usage_Duration_Minutes * 60.0), 6 ) AS Kinetic_Energy_Change FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
WITH PriceWeightRatio AS (   SELECT      man.Manufacturer_Name,      CAST(m.Price_Usd AS REAL) / m.Weight_Grams AS Ratio,      man.Market_Share_Percent    FROM mice m    JOIN manufacturers man ON m.Manufacturer_Id = man.Manufacturer_Id ),  Stats AS (   SELECT      Manufacturer_Name,      STDEV(Ratio) AS StdDev,      AVG(Ratio) AS Mean,      Market_Share_Percent    FROM PriceWeightRatio    GROUP BY Manufacturer_Name, Market_Share_Percent )  SELECT    Manufacturer_Name,    ROUND(CAST(StdDev AS REAL) / Mean, 4) AS CV,    CASE WHEN Market_Share_Percent > 25 THEN 1 ELSE 0 END AS Segment  FROM Stats  ORDER BY CV DESC;	mouse	2
SELECT DISTINCT m.Model FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE (CAST(u.Usage_Duration_Minutes AS REAL) / 60.0) / 8.0 / s.Sensor_Life_Hours > 0.9;	mouse	3
SELECT ROUND(0.5 * (1e-12 * 2 * 10 / (m.Weight_Grams / 1000.0)) * POWER(1.0 / 1000, 2), 12) AS Trajectory_Offset FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT (0.3 * (m.Weight_Grams/1000.0) * 9.81 * u.Distance_Moved_Meters + 0.5 * (m.Weight_Grams/1000.0) * POWER(u.Distance_Moved_Meters/(u.Usage_Duration_Minutes*60.0), 2)) / (u.Usage_Duration_Minutes*60.0) * 1000.0 AS power_mw FROM usage_records u JOIN mice m ON u.Mouse_Id = m.Mouse_Id WHERE m.Model = 'G502 HERO' AND DATE(u.Start_Time) = '2023-10-01';	mouse	1
WITH IndexCalc AS (     SELECT          m.Model,          (AVG(s.Sensor_Life_Hours) * m.Dpi) / (m.Price_Usd * m.Weight_Grams) AS efficacy_index      FROM mice m      JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id      GROUP BY m.Model, m.Dpi, m.Price_Usd, m.Weight_Grams )  SELECT Model, efficacy_index  FROM IndexCalc  ORDER BY efficacy_index DESC  LIMIT 3;	mouse	2
SELECT m.Model, MAX(s.Lift_Off_Distance_Mm) AS current_lift, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS daily_clicks, JULIANDAY('now') - JULIANDAY(MAX(s.Last_Calibration_Date)) AS days_since_calib FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id GROUP BY m.Model HAVING current_lift < 2 AND daily_clicks > 1000 AND days_since_calib > 90;	mouse	3
SELECT (6.626e-34 * 3e8) / (500e-9 * POWER(1.0e6 / m.Dpi, 2)) AS photons_per_pixel, CASE WHEN (1.0e6 / m.Dpi) < (6.626e-34 / (2 * 3.141592653589793)) THEN 'Breakthrough Heisenberg Limit' ELSE 'Theoretically Feasible' END AS quantum_status FROM mice m CROSS JOIN (SELECT 1000000 AS target_dpi) WHERE m.Is_Wireless = 1;	mouse	4
SELECT 0.5 * (Weight_Grams / 1000.0) * POWER((400 * 0.0254), 2) AS Kinetic_Energy_Joules FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	1
WITH FilteredData AS (     SELECT          Country,          Market_Share_Percent,          CAST(Profit_Usd AS REAL) / Employees AS Profit_Per_Employee      FROM manufacturers      WHERE Founded_year > 1993 )  SELECT      Country,      AVG((Market_Share_Percent - mean_ms) * (Market_Share_Percent - mean_ms)) AS Market_Share_Variance,     (AVG(Market_Share_Percent * Profit_Per_Employee) - AVG(Market_Share_Percent) * AVG(Profit_Per_Employee)) AS Covariance  FROM      FilteredData,      (SELECT AVG(Market_Share_Percent) AS mean_ms FROM FilteredData)  GROUP BY Country  ORDER BY Covariance DESC;	mouse	2
SELECT Model, Battery_Life_Hours, Price_Usd, Battery_Life_Hours / Price_Usd AS Value_Per_USD FROM mice WHERE Is_Wireless = 1 AND Battery_Life_Hours > Price_Usd;	mouse	3
SELECT (2997924.58 / 0.0254) * 16000 / 1000000 AS Packets_Per_Second;	mouse	4
SELECT Energy_Consumed_Joules / (Usage_Duration_Minutes * 60) AS power_watts FROM usage_records WHERE User_Id = 101 AND Mouse_Id = (SELECT Mouse_Id FROM mice WHERE Model = 'G502 HERO') AND Distance_Moved_Meters = 1500.5 AND Energy_Consumed_Joules = 5000 AND Usage_Duration_Minutes = 120;	mouse	1
SELECT Manufacturer_Name, ROUND((Revenue_Usd*0.3 + Profit_Usd*0.4 + Market_Share_Percent*2 + Employees*0.1)/1000, 3) AS composite_score FROM manufacturers ORDER BY composite_score DESC;	mouse	2
SELECT m.Model, m.Battery_Life_Hours, (SELECT MAX(u.Usage_Duration_Minutes)/60.0 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id) AS max_usage_hours FROM mice m WHERE m.Is_Wireless = 1 AND m.Battery_Life_Hours < (SELECT MAX(u.Usage_Duration_Minutes)/60.0 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id);	mouse	3
SELECT (3 * 9.461e15) / (450 * 0.0254) / (365*24*3600) AS time_years;	mouse	4
SELECT (m.Weight_Grams / 1000.0) * (50 * 9.8) AS force_newton FROM mice m WHERE m.Model = 'DeathAdder V2';	mouse	1
SELECT ma.Manufacturer_Name, (MAX(m.Dpi) / m.Price_Usd) * 1000 AS dpi_ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name, m.Price_Usd ORDER BY dpi_ratio DESC LIMIT 3;	mouse	2
SELECT m.Model, s.Lift_Off_Distance_Mm, m.Cable_Length_Meters FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Is_Wireless = 0 AND s.Lift_Off_Distance_Mm > 2 AND m.Cable_Length_Meters < 1.5;	mouse	3
SELECT (299792458 / 0.0254) * 8 / 1e15 AS data_pb;	mouse	4
SELECT 0.5 * (m.Weight_Grams/1000.0) * (0.8 * 0.8) AS kinetic_energy_joules FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id WHERE m.Model = 'G502 HERO' AND u.User_Id = 101 AND u.Distance_Moved_Meters = 1500.5;	mouse	1
SELECT Manufacturer_Name, ROUND((Profit_Usd/Employees)/(SELECT AVG(Profit_Usd/Employees) FROM manufacturers), 2) AS profit_ratio FROM manufacturers ORDER BY profit_ratio DESC;	mouse	2
SELECT s.*, t.total_hours FROM sensor_data s JOIN (SELECT Mouse_Id, SUM(Usage_Duration_Minutes)/60.0 AS total_hours FROM usage_records GROUP BY Mouse_Id) t ON s.Mouse_Id = t.Mouse_Id WHERE s.Sensor_Life_Hours < t.total_hours;	mouse	3
SELECT (0.9 * 3e8) / (20000 * 9.8) / 3.15e7 AS time_years;	mouse	4
SELECT ROUND((0.121 * 40 * 9.8) * (1500.5 / (120 * 60)), 4) AS Instantaneous_Power FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Logitech' AND mc.Model = 'G502 HERO' AND ur.User_ID = 101;	mouse	1
SELECT mf.Manufacturer_Name, ROUND((MAX(mc.Price_Usd) - MIN(mc.Price_Usd)) / AVG(mc.Price_Usd), 3) AS price_dispersion, mf.Market_Share_Percent FROM manufacturers mf JOIN mice mc ON mf.Manufacturer_Id = mc.Manufacturer_Id GROUP BY mf.Manufacturer_Id ORDER BY price_dispersion DESC, mf.Market_Share_Percent DESC;	mouse	2
SELECT * FROM sensor_data WHERE Calibration_Count > (Sensor_Life_Hours / 100);	mouse	3
SELECT (8.8e26 / (0.0254 / 1e18)) AS movement_times, ROUND(( (8.8e26 / (0.0254 / 1e18)) * 1 * 1000 * 3.154e7 * 1000 ) / 1e24, 3) AS data_yb;	mouse	4
SELECT ROUND((82.0/1000.0) * (450*0.0254), 4) AS Momentum_Change FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Razer' AND mc.Model = 'DeathAdder V2';	mouse	1
SELECT Manufacturer_Name, ROUND((POWER(Profit_Usd, 1.0 / (2023 - Founded_year)) - 1) * 100, 2) AS CAGR FROM manufacturers ORDER BY CAGR DESC;	mouse	2
SELECT * FROM mice WHERE (Is_Wireless=1 AND Battery_Life_Hours IS NULL) OR (Is_Wireless=0 AND Battery_Life_Hours IS NOT NULL);	mouse	3
SELECT (0.0254 / 1e6) AS Min_Movement_Distance, ROUND((30720 * 17280 * 10 * 6 * 3600 * 365 * 8 / 1e8), 2) AS Annual_Data_Volume_EB;	mouse	4
SELECT (1000.25 / (120 * 60)) / 0.0254 AS Actual_IPS, CASE WHEN (1000.25 / (120 * 60)) / 0.0254 > 400 THEN 'Exceeds Max Tracking Speed' ELSE 'Within Max Tracking Speed' END AS Speed_Status FROM usage_records ur JOIN mice mc ON ur.Mouse_ID = mc.Mouse_Id JOIN manufacturers mf ON mc.Manufacturer_Id = mf.Manufacturer_Id WHERE mf.Manufacturer_Name = 'Corsair' AND mc.Model = 'Dark Core RGB Pro' AND ur.User_ID = 103;	mouse	1
SELECT Manufacturer_Name, ROUND((Market_Share_Percent / 100.0) * (Profit_Usd / Employees), 4) AS efficiency_index FROM manufacturers ORDER BY efficiency_index DESC;	mouse	2
SELECT * FROM sensor_data WHERE Max_Dpi > 15000 AND Polling_Rate_Hz < 1000;	mouse	3
SELECT (7680 * 4320 * 10 * 6 * 31536000 * 10) / 1e30 AS Data_Volume_BB;	mouse	4
SELECT v.Vehicle_Id, v.Model, ROUND(dr.Distance_Km / dr.Energy_Consumed_Kwh, 2) AS energy_efficiency, dr.Average_Speed_Kmh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Average_Speed_Kmh > 60 GROUP BY v.Vehicle_Id HAVING energy_efficiency < 4 ORDER BY energy_efficiency ASC;	new_energy_vehicles	1
SELECT cs.Station_Name, ROUND(SUM(cr.Cost_Usd) / MAX(JULIANDAY(MAX(cr.End_Time)) - JULIANDAY(MIN(cr.Start_Time)) + 1, 1), 2) AS daily_revenue, cs.Number_Of_Chargers FROM charging_stations cs JOIN charging_records cr ON cs.Station_Id = cr.Station_Id GROUP BY cs.Station_Id HAVING daily_revenue > 500 AND cs.Number_Of_Chargers > 5 ORDER BY daily_revenue DESC LIMIT 3;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Model, (SELECT MAX(cr.End_Time) FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id) AS last_charge_date, (SELECT cr.Charging_Type FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id ORDER BY cr.End_Time DESC LIMIT 1) AS last_charge_type FROM vehicles v WHERE v.Battery_Capacity_Kwh > 100 AND EXISTS (SELECT 1 FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id AND cr.Energy_Consumed_Kwh < 20);	new_energy_vehicles	3
WITH RECURSIVE charging_sim AS (SELECT 10.0 AS soc, CAST(0.0 AS REAL) AS elapsed_time, 1 AS phase UNION ALL SELECT CASE phase WHEN 1 THEN MIN(soc + 5.0, 50.0) ELSE MIN(soc + 0.5, 80.0) END, elapsed_time + (100 * CASE phase WHEN 1 THEN 5.0 ELSE 0.5 END) / MAX(600 - 0.2 * POWER((-60 + 273), 3), 1), CASE WHEN soc >= 50.0 THEN 2 ELSE phase END FROM charging_sim WHERE soc < 80.0) SELECT MAX(elapsed_time) AS total_hours, FLOOR(MAX(elapsed_time)) || ' hours ' || ROUND((MAX(elapsed_time) % 1) * 60) || ' minutes' AS formatted_time FROM charging_sim;	new_energy_vehicles	4
SELECT cs.Station_Name, cr.Charging_Type, ROUND(AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time)) / 3600)) * 100, 2) AS efficiency_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, cr.Charging_Type HAVING efficiency_rate < 85 AND charge_count > 10 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
SELECT v.Manufacturer, ROUND(SUM(dr.Distance_Km) * 1.0 / COUNT(DISTINCT date(dr.Start_Time)), 2) AS daily_avg_km, COUNT(DISTINCT v.Vehicle_Id) AS vehicle_count FROM vehicles v JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id GROUP BY v.Manufacturer HAVING daily_avg_km > 150 AND vehicle_count >= 3 ORDER BY daily_avg_km DESC;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Model, MAX(cr.End_Time) AS last_charge_date, v.Battery_Health FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE cr.Temperature_Celsius > 30 AND cr.Charging_Type = 'Ultra-Fast' AND v.Battery_Health < 90 GROUP BY v.Vehicle_Id;	new_energy_vehicles	3
WITH RECURSIVE polar_charging AS (SELECT 0 AS soc, CAST(0.0 AS REAL) AS elapsed_time, 120 * 0.2 * 0.6 AS actual_power, 0.2 * 5 * POWER(-50 + 50, 2) AS heat_loss UNION ALL SELECT soc + 5, elapsed_time + (100 * 5) / MAX(actual_power - (heat_loss / 1000), 1), actual_power, 0.2 * 5 * POWER((-50 + (soc/100.0)*130) + 50, 2) FROM polar_charging WHERE soc < 100) SELECT MAX(elapsed_time) AS total_hours, FLOOR(MAX(elapsed_time)) || ' hours ' || ROUND((MAX(elapsed_time) - FLOOR(MAX(elapsed_time))) * 60) || ' minutes' AS formatted_time FROM polar_charging;	new_energy_vehicles	4
WITH normal_efficiency AS (     SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS normal_eff      FROM driving_records dr      WHERE dr.Weather_Conditions IN ('Sunny', 'Cloudy')      GROUP BY dr.Vehicle_Id ),  extreme_efficiency AS (     SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS extreme_eff      FROM driving_records dr      WHERE dr.Weather_Conditions IN ('Snow', 'Heatwave')      GROUP BY dr.Vehicle_Id )  SELECT v.Model, ROUND(((ne.normal_eff - ee.extreme_eff) * 100.0 / ne.normal_eff), 2) AS efficiency_decay_rate  FROM vehicles v  JOIN normal_efficiency ne ON v.Vehicle_Id = ne.Vehicle_Id  JOIN extreme_efficiency ee ON v.Vehicle_Id = ee.Vehicle_Id  WHERE ((ne.normal_eff - ee.extreme_eff) * 100.0 / ne.normal_eff) > 15  ORDER BY efficiency_decay_rate DESC;	new_energy_vehicles	1
WITH weekly_utilization AS (   SELECT      cs.Station_Id,      CAST(strftime('%W', cr.Start_Time) AS INTEGER) AS week_num,      SUM((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 86400) / (cs.Number_Of_Chargers * CASE WHEN cs.Is_24_Hours = 1 THEN 604800 ELSE (julianday(cs.Opening_Hours) - julianday('00:00:00')) * 86400 * 7 END) AS utilization_rate    FROM charging_stations cs    JOIN charging_records cr ON cs.Station_Id = cr.Station_Id    GROUP BY cs.Station_Id, week_num ),  consecutive_weeks AS (   SELECT      Station_Id,      week_num,      utilization_rate,      LAG(utilization_rate) OVER (PARTITION BY Station_Id ORDER BY week_num) AS prev_week_rate    FROM weekly_utilization )  SELECT DISTINCT cs.Station_Name  FROM consecutive_weeks cw  JOIN charging_stations cs ON cw.Station_Id = cs.Station_Id  WHERE cw.utilization_rate > 0.8 AND cw.prev_week_rate > 0.8;	new_energy_vehicles	2
SELECT dr.Record_Id, 'Starting elevation change:' || dr.Elevation_Gain_M || 'm; Ending elevation change:' || dr.Elevation_Loss_M || 'm' AS elevation_change, dr.Weather_Conditions, v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100 AS theoretical_energy, dr.Energy_Consumed_Kwh AS actual_energy FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE (dr.Elevation_Gain_M + dr.Elevation_Loss_M) > 500 AND dr.Energy_Consumed_Kwh > 1.2 * (v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100);	new_energy_vehicles	3
WITH RECURSIVE poisson_cdf AS (     SELECT 0 AS k, EXP(-5) * POWER(5, 0) / 1 AS prob, EXP(-5) * POWER(5, 0) / 1 AS cdf      UNION ALL      SELECT k + 1, EXP(-5) * POWER(5, k + 1) / (k + 1), cdf + EXP(-5) * POWER(5, k + 1) / (k + 1)      FROM poisson_cdf      WHERE k < 7 ) SELECT ROUND(1 - MAX(cdf), 3) AS probability_at_least_8_hours  FROM poisson_cdf;	new_energy_vehicles	4
SELECT dr.Record_Id, v.Model, ROUND(v.Weight_Kg * 9.8 * dr.Elevation_Loss_M, 2) AS theoretical_energy, ROUND(dr.Energy_Consumed_Kwh * 0.9 * 3600000, 2) AS recovered_energy, ROUND((dr.Energy_Consumed_Kwh * 0.9 * 3600000) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS efficiency_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Elevation_Loss_M > 200 AND (dr.Energy_Consumed_Kwh * 0.9 * 3600000) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 50 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
WITH RECURSIVE hourly_usage AS (     SELECT cs.Station_Id,             CAST(strftime('%H', cr.Start_Time) AS INTEGER) AS hour_slot,             CAST(COUNT(*) AS REAL) / cs.Number_Of_Chargers AS utilization_rate,             date(cr.Start_Time) AS date      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cs.Station_Id, date, hour_slot      HAVING utilization_rate > 0.9 ),  peak_groups AS (     SELECT *,             hour_slot - ROW_NUMBER() OVER (PARTITION BY Station_Id, date ORDER BY hour_slot) AS grp      FROM hourly_usage )  SELECT cs.Station_Name,         MIN(date) AS start_date,         MAX(date) AS end_date  FROM peak_groups pg  JOIN charging_stations cs ON pg.Station_Id = cs.Station_Id  GROUP BY pg.Station_Id, pg.grp  HAVING COUNT(*) >= 3 AND MAX(hour_slot) - MIN(hour_slot) < 5;	new_energy_vehicles	2
WITH health_change AS (     SELECT          cr.Vehicle_Id,          cr.End_Time,          v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY cr.Vehicle_Id ORDER BY cr.End_Time) AS health_drop      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE cr.Temperature_Celsius < 5 AND cr.Charging_Type = 'Ultra-Fast' )  SELECT      v.Model,      cs.Operator,      hc.health_drop,      cr.End_Time AS charge_time  FROM health_change hc  JOIN charging_records cr ON hc.Vehicle_Id = cr.Vehicle_Id AND hc.End_Time = cr.End_Time  JOIN vehicles v ON hc.Vehicle_Id = v.Vehicle_Id  JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id  WHERE hc.health_drop > 2;	new_energy_vehicles	3
SELECT 0.95 * 5.67e-8 * 3 * (POWER(60+273, 4) - POWER(3, 4)) / 0.9 AS max_power_kw;	new_energy_vehicles	4
SELECT cr.Record_Id, v.Model, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Charging_Type IN ('Fast', 'Ultra-Fast') AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0 < 90.0 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
WITH hourly_peak AS (     SELECT cs.Station_Id,             DATE(cr.Start_Time) AS date,             CAST(strftime('%H', cr.Start_Time) AS INTEGER) AS hour_slot,             COUNT(*) * 1.0 / cs.Number_Of_Chargers AS utilization_rate      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cs.Station_Id, date, hour_slot      HAVING utilization_rate > 0.95 ),  peak_dates AS (     SELECT date,             COUNT(DISTINCT Station_Id) AS peak_station_count      FROM hourly_peak      GROUP BY date      HAVING COUNT(DISTINCT Station_Id) >= 3 )  SELECT date, peak_station_count  FROM peak_dates  ORDER BY date DESC;	new_energy_vehicles	2
SELECT cs.Operator, cs.Location, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast' AND ((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100) < 85;	new_energy_vehicles	3
WITH RECURSIVE monte_carlo AS (     SELECT 1 AS iter,             ROUND(70.0 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1.0 + (RANDOM() - 0.5) * 1.0)), 2) AS charge_time      UNION ALL      SELECT iter + 1,             ROUND(70.0 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1.0 + (RANDOM() - 0.5) * 1.0)), 2)      FROM monte_carlo      WHERE iter < 1000 )  SELECT COUNT(*) * 100.0 / 1000 AS probability_over_1_5t  FROM monte_carlo  WHERE charge_time > 1.5 * (70.0 / (SELECT AVG(Charging_Speed_Kw) FROM charging_stations));	new_energy_vehicles	4
SELECT dr.Record_Id, v.Model, ROUND((dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS recovery_rate  FROM driving_records dr  JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id  WHERE dr.Elevation_Loss_M > 300 AND (dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 45  ORDER BY recovery_rate ASC;	new_energy_vehicles	1
WITH daily_charge AS (     SELECT          cr.Vehicle_Id,          DATE(cr.Start_Time) AS charge_date,          SUM(cr.Energy_Consumed_Kwh) AS daily_energy,          MAX(cs.Station_Id) AS last_station_id      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cr.Vehicle_Id, charge_date ),  growth_trend AS (     SELECT          Vehicle_Id,          charge_date,          daily_energy,          last_station_id,          LAG(daily_energy, 2) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n,          LAG(daily_energy, 1) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n_plus_1,          daily_energy AS day_n_plus_2      FROM daily_charge ),  valid_growth AS (     SELECT          Vehicle_Id,          MAX(last_station_id) AS last_station_id,          (MAX(day_n_plus_2) - MIN(day_n)) / 2.0 AS slope      FROM growth_trend      WHERE day_n < day_n_plus_1 AND day_n_plus_1 < day_n_plus_2      GROUP BY Vehicle_Id )  SELECT      v.Model,      cs.Location AS last_location,      vg.slope  FROM valid_growth vg  JOIN vehicles v ON vg.Vehicle_Id = v.Vehicle_Id  JOIN charging_stations cs ON vg.last_station_id = cs.Station_Id;	new_energy_vehicles	2
SELECT cs.Station_Name, cs.Opening_Hours, cs.Is_Covered, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 AND cr.Charging_Type = 'Ultra-Fast' AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0 < 80;	new_energy_vehicles	3
SELECT ROUND((0.85 * 5.67e-8 * 2.5 * (POWER(283, 4) - POWER(35, 4))) / 0.9, 2) AS max_power_kw;	new_energy_vehicles	4
SELECT cs.Station_Name, ROUND((1 - AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * (julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24))) * 100, 2) AS loss_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 GROUP BY cs.Station_Id HAVING loss_rate > 20 AND charge_count > 5 ORDER BY loss_rate DESC;	new_energy_vehicles	1
WITH weekday_charging AS (     SELECT          v.Model,         SUM(cr.Energy_Consumed_Kwh) AS weekday_energy     FROM charging_records cr     JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id     WHERE strftime('%w', cr.Start_Time) NOT IN ('0', '6')     GROUP BY v.Model ), weekend_charging AS (     SELECT          v.Model,         SUM(cr.Energy_Consumed_Kwh) AS weekend_energy     FROM charging_records cr     JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id     WHERE strftime('%w', cr.Start_Time) IN ('0', '6')     GROUP BY v.Model ) SELECT      wd.Model,     wd.weekday_energy,     we.weekend_energy,     ROUND(we.weekend_energy / wd.weekday_energy, 2) AS ratio FROM weekday_charging wd JOIN weekend_charging we ON wd.Model = we.Model WHERE we.weekend_energy / wd.weekday_energy > 1.3;	new_energy_vehicles	2
WITH high_altitude_stations AS (     SELECT cs.Station_Id, cs.Operator, cs.Is_Covered      FROM charging_stations cs      WHERE EXISTS (         SELECT 1          FROM (             SELECT MakePoint(0, 0) AS Location, 2500 AS Altitude              UNION ALL              SELECT MakePoint(1, 1) AS Location, 1500 AS Altitude         ) AS ad          WHERE Distance(cs.Location, ad.Location) < 1000          AND ad.Altitude > 2000          AND Y(cs.Location) BETWEEN -90 AND 90          AND X(cs.Location) BETWEEN -180 AND 180     ) ),  low_efficiency_records AS (     SELECT cr.Station_Id,             ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100 / cr.Energy_Consumed_Kwh * 100), 2) AS efficiency_rate      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 75 )  SELECT has.Operator, has.Is_Covered, COUNT(*) AS record_count  FROM high_altitude_stations has  JOIN low_efficiency_records ler ON has.Station_Id = ler.Station_Id  GROUP BY has.Operator, has.Is_Covered;	new_energy_vehicles	3
SELECT ROUND(0.2 * 3 * POW(50 - 4, 1.5), 2) AS max_power_kw;	new_energy_vehicles	4
WITH health_change AS (     SELECT          dr.Vehicle_Id,          dr.End_Time,          v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY dr.Vehicle_Id ORDER BY dr.End_Time) AS health_drop      FROM driving_records dr      JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id ) SELECT      dr.Record_Id,      v.Model,      ROUND(dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600.0), 2) AS energy_density,      hc.health_drop  FROM driving_records dr  JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id  JOIN health_change hc ON dr.Vehicle_Id = hc.Vehicle_Id AND dr.End_Time = hc.End_Time  WHERE v.Acceleration_0_To_100_Sec < 2  AND dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600.0) > 500  AND hc.health_drop > 5;	new_energy_vehicles	1
WITH abnormal_charge AS (     SELECT          cr.Vehicle_Id,          date(cr.Start_Time) AS charge_date,          cr.Energy_Consumed_Kwh      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE cr.Energy_Consumed_Kwh > 3 * v.Battery_Capacity_Kwh ),  no_driving_records AS (     SELECT          ac.Vehicle_Id,          ac.charge_date      FROM abnormal_charge ac      LEFT JOIN driving_records dr ON ac.Vehicle_Id = dr.Vehicle_Id          AND date(dr.Start_Time) = ac.charge_date      WHERE dr.Record_Id IS NULL )  SELECT Vehicle_Id, charge_date  FROM no_driving_records;	new_energy_vehicles	2
SELECT v.Manufacturer, cs.Is_Covered, COUNT(*) AS record_count FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE dr.Weather_Conditions = 'Blizzard' AND v.Is_Autonomous = 1 AND dr.Average_Speed_Kmh > 100 GROUP BY v.Manufacturer, cs.Is_Covered;	new_energy_vehicles	3
SELECT v.Model, v.Charging_Time_Hours / 707.0 AS subjective_time_hours, v.Charging_Time_Hours AS earth_time_hours FROM vehicles v WHERE v.Model = 'Model S';	new_energy_vehicles	4
SELECT ROUND((v.Battery_Capacity_Kwh * (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) * (1 - 0.05)) / NULLIF(c.Energy_Consumed_Kwh, 0) * 100, 2) AS Charging_Efficiency FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Record_Id = 1 AND v.Model = 'Model S' AND c.Final_Battery_Percentage IS NOT NULL AND c.Initial_Battery_Percentage IS NOT NULL AND c.Energy_Consumed_Kwh IS NOT NULL;	new_energy_vehicles	1
WITH StationStats AS (   SELECT      Cost_Per_Kwh,      Charging_Speed_Kw,     (Cost_Per_Kwh - (SELECT AVG(Cost_Per_Kwh) FROM charging_stations)) *      (Charging_Speed_Kw - (SELECT AVG(Charging_Speed_Kw) FROM charging_stations)) AS Covariance,     POWER(Cost_Per_Kwh - (SELECT AVG(Cost_Per_Kwh) FROM charging_stations), 2) AS VarX,     POWER(Charging_Speed_Kw - (SELECT AVG(Charging_Speed_Kw) FROM charging_stations), 2) AS VarY   FROM charging_stations ) SELECT ROUND(SUM(Covariance) / (SQRT(SUM(VarX)) * SQRT(SUM(VarY))), 4) AS Pearson_Correlation FROM StationStats ORDER BY ABS(Pearson_Correlation) DESC;	new_energy_vehicles	2
SELECT Station_Id, ROUND(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 8, 2) AS Daily_Revenue FROM charging_stations WHERE Cost_Per_Kwh > 0.25 AND Charging_Speed_Kw < 100;	new_energy_vehicles	3
SELECT Station_Id, ROUND(Charging_Speed_Kw * 6 * 0.2 * 0.9, 2) AS Max_Charging_Capacity FROM charging_stations;	new_energy_vehicles	4
SELECT ROUND(d.Distance_Km / (d.Energy_Consumed_Kwh + (d.Elevation_Gain_M / 100.0 * 0.5)), 2) AS Energy_Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 2 AND v.Model = 'ET7';	new_energy_vehicles	1
WITH Efficiency AS (     SELECT          Operator,          SUM(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 24) / SUM(Number_Of_Chargers) AS Operational_Efficiency,          AVG(Charging_Speed_Kw) AS Avg_Charging_Speed      FROM          charging_stations      GROUP BY          Operator ) SELECT      Operator,      (SELECT STDEV(Operational_Efficiency) FROM Efficiency) AS Std_Efficiency,      Operational_Efficiency,      POWER(Operational_Efficiency, 2) AS Efficiency_Squared,      Avg_Charging_Speed,      POWER(Avg_Charging_Speed, 2) AS Speed_Squared  FROM      Efficiency  ORDER BY      Operator;	new_energy_vehicles	2
SELECT c.Record_Id, ROUND(c.Energy_Consumed_Kwh * c.Temperature_Celsius / 100.0, 2) AS Risk_Factor FROM charging_records c JOIN charging_stations s ON c.Station_Id = s.Station_Id WHERE s.Is_24_Hours = 0 AND s.Is_Covered = 0 AND c.Weather_Conditions = 'Rainy' AND c.Energy_Consumed_Kwh > 50;	new_energy_vehicles	3
SELECT Station_Id, ROUND(1000 * Number_Of_Chargers * 0.8 / 0.9, 2) AS Grid_Impact FROM charging_stations;	new_energy_vehicles	4
SELECT ROUND( ( (0.5 * v.Weight_Kg * POWER((d.Distance_Km / ((strftime('%s', d.End_Time) - strftime('%s', d.Start_Time)) / 3600.0) / 3.6, 2)) + (v.Weight_Kg * 9.8 * d.Elevation_Gain_M / 1000) ) / (d.Energy_Consumed_Kwh * 3600000) * 100, 2 ) AS Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 3 AND v.Manufacturer = 'BYD' AND v.Model = 'Han EV';	new_energy_vehicles	1
WITH ranked_data AS (     SELECT Operator, Number_Of_Chargers, Charging_Speed_Kw,         RANK() OVER (PARTITION BY Operator ORDER BY Number_Of_Chargers) AS rank_chargers,         RANK() OVER (PARTITION BY Operator ORDER BY Charging_Speed_Kw) AS rank_speed     FROM charging_stations     WHERE Number_Of_Chargers IS NOT NULL AND Charging_Speed_Kw IS NOT NULL ), diff_data AS (     SELECT Operator, (rank_chargers - rank_speed) * (rank_chargers - rank_speed) AS d_squared     FROM ranked_data ), correlation_data AS (     SELECT Operator, 1.0 - (6.0 * SUM(d_squared)) / (COUNT(*) * (COUNT(*) * COUNT(*) - 1)) AS spearman_correlation     FROM diff_data     GROUP BY Operator ) SELECT Operator, spearman_correlation FROM correlation_data ORDER BY ABS(spearman_correlation) DESC;	new_energy_vehicles	2
SELECT c.Record_Id, ROUND( ((c.Final_Battery_Percentage - c.Initial_Battery_Percentage) / 100.0 * v.Battery_Capacity_Kwh * c.Temperature_Celsius) / v.Battery_Capacity_Kwh, 2 ) AS Risk_Index FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Charging_Type = 'Fast' AND c.Temperature_Celsius > 40 AND (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) > 80;	new_energy_vehicles	3
SELECT v.Vehicle_Id, ROUND( (v.Range_Km + (1000.0*0.95*1.0)/(d.Energy_Consumed_Kwh/d.Distance_Km)) / v.Range_Km, 2 ) AS Range_Boost FROM vehicles v JOIN driving_records d ON v.Vehicle_Id = d.Vehicle_Id WHERE d.Record_Id = 3;	new_energy_vehicles	4
SELECT cr.Vehicle_Id, ROUND(cr.Energy_Consumed_Kwh / ((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24), 2) AS P_avg_kW, ROUND((cr.Energy_Consumed_Kwh * 3600000) / (POWER(400,2) * ((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 86400) * 0.05*(25/cr.Temperature_Celsius)/3600), 4) AS Efficiency_Rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE v.Manufacturer = 'Tesla' AND cr.Charging_Type = 'Fast';	new_energy_vehicles	1
WITH CostBenefit AS (     SELECT          v.Manufacturer,          v.Model,          SUM(dr.Distance_Km * v.Range_Km) / SUM(cr.Energy_Consumed_Kwh * cr.Cost_Usd) AS Benefit_Ratio      FROM driving_records dr      JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE dr.Weather_Conditions = 'Sunny'      GROUP BY v.Manufacturer, v.Model )  SELECT *  FROM (     SELECT          *,          RANK() OVER (ORDER BY Benefit_Ratio DESC) AS Ranking      FROM CostBenefit )  WHERE Ranking <= 3;	new_energy_vehicles	2
SELECT cr.Record_Id, cs.Station_Name, cs.Opening_Hours, cr.Start_Time FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cs.Opening_Hours != '00:00-23:59' AND (time(cr.Start_Time) < substr(cs.Opening_Hours, 1, instr(cs.Opening_Hours, '-') - 1) OR time(cr.End_Time) > substr(cs.Opening_Hours, instr(cs.Opening_Hours, '-') + 1));	new_energy_vehicles	3
SELECT ROUND((0.5 * 50000 * POWER(29979245.8,2)) / (10000000), 2) AS Time_Seconds, ROUND((0.5 * 50000 * POWER(29979245.8,2)) / (50000 * POWER(299792458,2)), 12) AS MassEnergy_Ratio;	new_energy_vehicles	4
WITH RainyDrives AS (   SELECT      dr.Record_Id,      v.Weight_Kg,      dr.Elevation_Gain_M - dr.Elevation_Loss_M AS elevation_diff_m,      dr.Energy_Consumed_Kwh    FROM      driving_records dr      JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id    WHERE      dr.Weather_Conditions = 'Rainy' ) SELECT    Record_Id,    ROUND(      (Weight_Kg * 9.8 * elevation_diff_m / 1000) / (Energy_Consumed_Kwh * 3600000) * 100,      2    ) AS efficiency_percent  FROM    RainyDrives  WHERE    Energy_Consumed_Kwh > 0;	new_energy_vehicles	1
WITH PeakHours AS (     SELECT          cs.Operator,          cs.Number_Of_Chargers,          SUM(cr.Energy_Consumed_Kwh * cs.Cost_Per_Kwh) AS total_revenue,          SUM((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24) AS total_hours      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      WHERE cr.Charging_Type = 'Fast'          AND CAST(strftime('%H', cr.Start_Time) AS INTEGER) BETWEEN 18 AND 22      GROUP BY cs.Operator, cs.Number_Of_Chargers  )  SELECT      Operator,      ROUND(total_revenue / (Number_Of_Chargers * total_hours), 2) AS efficiency_ratio,      RANK() OVER(ORDER BY (total_revenue / (Number_Of_Chargers * total_hours)) DESC) AS efficiency_rank  FROM PeakHours;	new_energy_vehicles	2
WITH RangeAnalysis AS (     SELECT v.Vehicle_Id, v.Manufacturer, v.Model, v.Battery_Capacity_Kwh, v.Range_Km, dr.End_Battery_Percentage      FROM vehicles v      LEFT JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id      WHERE v.Range_Km < v.Battery_Capacity_Kwh * 5  ) SELECT Vehicle_Id, Manufacturer, Model, Battery_Capacity_Kwh, Range_Km, ROUND(CAST(Range_Km AS REAL) / Battery_Capacity_Kwh, 2) AS actual_range_factor, End_Battery_Percentage  FROM RangeAnalysis;	new_energy_vehicles	3
WITH PhysicsConstants AS ( SELECT 1.225 AS air_density, 2.5 AS frontal_area, 900 / 3.6 AS speed_mps ), VehicleEnergy AS ( SELECT Battery_Capacity_Kwh * 1000 AS battery_joules FROM vehicles WHERE Model = 'Model S' LIMIT 1 ), AirResistance AS ( SELECT 0.5 * air_density * frontal_area * (speed_mps * speed_mps * speed_mps) AS power_watts FROM PhysicsConstants ) SELECT power_watts, battery_joules / (power_watts * 3600) AS endurance_hours, CASE WHEN battery_joules / (power_watts * 3600) < 1 THEN 'Breakthrough' ELSE 'Safe' END AS status FROM AirResistance, VehicleEnergy;	new_energy_vehicles	4
WITH SnowDrives AS (   SELECT      dr.Record_Id,      v.Weight_Kg,      dr.Elevation_Gain_M,      dr.Average_Speed_Kmh,      0.6 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.9 AS torque_front,      0.4 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.85 AS torque_rear    FROM driving_records dr    JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id    WHERE v.Drivetrain = 'AWD' AND dr.Weather_Conditions = 'Snow' ) SELECT Record_Id, ROUND(torque_front / torque_rear, 2) AS torque_ratio  FROM SnowDrives;	new_energy_vehicles	1
WITH ServiceEfficiency AS (   SELECT      cs.Station_Id,      cs.Number_Of_Chargers,      cs.Parking_Fee_Usd,      cs.Is_Solar_Powered,      CAST(strftime('%m', cr.Start_Time) AS INTEGER) + 2 / 3 AS quarter,      SUM(cr.Energy_Consumed_Kwh * CASE WHEN cs.Is_Solar_Powered THEN 1.2 ELSE 1 END) AS adjusted_energy    FROM charging_records cr    JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id    GROUP BY cs.Station_Id, cs.Number_Of_Chargers, cs.Parking_Fee_Usd, cs.Is_Solar_Powered, quarter ) SELECT    Station_Id,    quarter,    ROUND(adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd), 2) AS efficiency_ratio,    RANK() OVER(PARTITION BY quarter ORDER BY adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd) DESC) AS efficiency_rank  FROM ServiceEfficiency;	new_energy_vehicles	2
WITH FastChargeAnalysis AS ( SELECT cr.Record_Id, cr.Temperature_Celsius, (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / ((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24) AS soc_rate FROM charging_records cr WHERE cr.Charging_Type = 'Fast' ) SELECT Record_Id, soc_rate, Temperature_Celsius, CASE WHEN soc_rate > 70 OR Temperature_Celsius > 40 THEN 'Abnormal' ELSE 'Normal' END AS health_status FROM FastChargeAnalysis;	new_energy_vehicles	3
WITH QuantumConstants AS ( SELECT 1.0545718e-34 AS h_bar, 1e-9 AS barrier_thickness, 5 * 1.6e-19 AS barrier_energy ), TunnelingProbability AS ( SELECT EXP(-2 * barrier_thickness * SQRT(2 * 9.11e-31 * barrier_energy) / h_bar) AS p_tunnel FROM QuantumConstants ), EnergyLoss AS ( SELECT cr.Record_Id, cr.Energy_Consumed_Kwh * 1000 * p_tunnel AS energy_loss_joules FROM charging_records cr, TunnelingProbability ) SELECT Record_Id, energy_loss_joules, CASE WHEN energy_loss_joules > 100 THEN 'Exceeds Quantum Limit' ELSE 'Safe' END AS quantum_status FROM EnergyLoss;	new_energy_vehicles	4
WITH ChargingPhysics AS (SELECT cr.Record_Id, cr.Energy_Consumed_Kwh, cs.Charging_Speed_Kw, cr.Temperature_Celsius, (cs.Charging_Speed_Kw * 1000 / 400) AS I, (1.68e-8 * 5) / (3.141592653589793 * POWER(0.005, 2)) AS R, (POWER(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (3.141592653589793 * POWER(0.005, 2)) * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time))) / 3.6e6 AS Q, ((POWER(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (3.141592653589793 * POWER(0.005, 2)) * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time))) / 3.6e6 * 3.6e6) / (100 * 385) AS ΔT FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Charging_Type = 'fast') SELECT Record_Id, ΔT AS Temperature_Rise, (Energy_Consumed_Kwh - Q) / Energy_Consumed_Kwh * 100 AS Efficiency_Loss_Percent FROM ChargingPhysics	new_energy_vehicles	1
WITH RangeAnalysis AS (     SELECT          dr.Vehicle_Id,          v.Manufacturer,          dr.Distance_Km / (v.Range_Km * (dr.Start_Battery_Percentage - dr.End_Battery_Percentage) / 100) AS Range_Ratio      FROM          driving_records dr      JOIN          vehicles v ON dr.Vehicle_Id = v.Vehicle_Id      WHERE          dr.Weather_Conditions IN ('Rainy','Snow') )  SELECT      Manufacturer,      (STDEV(Range_Ratio) / AVG(Range_Ratio)) AS Volatility_Rate  FROM      RangeAnalysis  GROUP BY      Manufacturer  HAVING      (STDEV(Range_Ratio) / AVG(Range_Ratio)) > 0.2;	new_energy_vehicles	2
WITH StationSessions AS (     SELECT          Station_Id,          Start_Time,          End_Time,          (julianday(Start_Time) - julianday(LAG(End_Time) OVER (PARTITION BY Station_Id ORDER BY Start_Time))) * 24 AS Rest_Hours      FROM charging_records ) SELECT      Station_Id,      SUM((julianday(End_Time) - julianday(Start_Time)) * 24) AS Total_Operating_Hours  FROM StationSessions  WHERE Rest_Hours > 24  AND Station_Id NOT IN (SELECT Station_Id FROM charging_stations WHERE Is_24_Hours = 1) GROUP BY Station_Id  HAVING SUM((julianday(End_Time) - julianday(Start_Time)) * 24) > 72;	new_energy_vehicles	3
SELECT SQRT(1.625 / 2) AS ω_min_rads, SQRT(1.625 / 2) * 60 / (2 * PI()) AS Critical_RPM, (1200 * (1.625 / 2) * POW(2, 3)) / 3 AS Material_Stress, CASE WHEN (1200 * (1.625 / 2) * POW(2, 3)) / 3 > 500e6 THEN 'Exceeds Limit' ELSE 'Safe' END AS Safety_Status;	new_energy_vehicles	4
SELECT Energy_Consumed_Kwh / (100 * (Final_Battery_Percentage - Initial_Battery_Percentage) / 100) AS efficiency FROM charging_records WHERE Vehicle_Id = 1 AND date(Start_Time) = '2023-10-01';	new_energy_vehicles	1
SELECT cs.Station_Name, SUM(cr.Energy_Consumed_Kwh) / SUM((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24) AS efficiency FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id ORDER BY efficiency DESC LIMIT 5;	new_energy_vehicles	2
SELECT cr.Vehicle_Id, cs.Station_Name FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast';	new_energy_vehicles	3
SELECT 1000 * 1000 / 400 AS current_strength;	new_energy_vehicles	4
SELECT (0.7 * (2300 * 9.81 * 30) / 3600000) AS regenerative_energy_kwh, Energy_Consumed_Kwh, CASE WHEN (0.7 * (2300 * 9.81 * 30) / 3600000) > Energy_Consumed_Kwh * 0.15 THEN 1 ELSE 0 END AS is_over_15percent FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 5 AND date(dr.Start_Time) = '2023-10-05';	new_energy_vehicles	1
SELECT Operator, (SUM(Energy_Consumed_Kwh) / MAX(Number_Of_Chargers)) * (1 + SUM(CASE WHEN CAST(strftime('%H', Start_Time) AS INTEGER) >= 20 OR CAST(strftime('%H', Start_Time) AS INTEGER) < 6 THEN Energy_Consumed_Kwh ELSE 0 END) / SUM(Energy_Consumed_Kwh)) AS efficiency_index FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY Operator ORDER BY efficiency_index DESC LIMIT 3;	new_energy_vehicles	2
SELECT v.Model, MAX(cs.Is_Covered) AS has_covered  FROM vehicles v  JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id  JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id  JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id  WHERE v.Range_Km > 500  AND v.Drivetrain = 'AWD'  AND v.Is_Autonomous = 1  AND dr.Weather_Conditions IN ('Rainy','Cloudy')  GROUP BY v.Model  HAVING AVG(dr.Average_Speed_Kmh) > 80;	new_energy_vehicles	3
SELECT (100 * 200 * 3600) / 180 - (100 * 200 * 2.1 * 50) AS required_cooling_kj;	new_energy_vehicles	4
SELECT (0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) AS regenerated_kwh, dr.Energy_Consumed_Kwh, cr.Energy_Consumed_Kwh AS charged_kwh, ((0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) / dr.Energy_Consumed_Kwh) * 100 AS contribution_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id AND DATE(cr.Start_Time) = '2023-10-02' WHERE dr.Vehicle_Id = 2 AND dr.Road_Type = 'City' AND DATE(dr.Start_Time) = '2023-10-02';	new_energy_vehicles	1
WITH peak_energy AS (     SELECT          Station_Id,          SUM(CASE WHEN CAST(strftime('%H', Start_Time) AS INTEGER) BETWEEN 7 AND 9 OR CAST(strftime('%H', Start_Time) AS INTEGER) BETWEEN 17 AND 19 THEN Energy_Consumed_Kwh ELSE 0 END) AS peak_energy,          SUM(Energy_Consumed_Kwh) AS total_energy,          SUM(Cost_Usd) AS total_revenue,          SUM((julianday(End_Time) - julianday(Start_Time)) * 24) AS total_hours      FROM charging_records      GROUP BY Station_Id )  SELECT      cs.Station_Name,      (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) AS health_index  FROM peak_energy pe  JOIN charging_stations cs ON pe.Station_Id = cs.Station_Id  WHERE (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) > 0.7;	new_energy_vehicles	2
WITH charge_cycles AS (     SELECT Vehicle_Id, SUM((Final_Battery_Percentage - Initial_Battery_Percentage) / 100.0) AS cycles      FROM charging_records      GROUP BY Vehicle_Id ),  fast_charge_stats AS (     SELECT Vehicle_Id,             CAST(COUNT(CASE WHEN Charging_Type = 'Fast' THEN 1 END) AS REAL) / COUNT(*) AS fast_ratio      FROM charging_records      GROUP BY Vehicle_Id ),  high_temp_records AS (     SELECT DISTINCT Vehicle_Id      FROM charging_records      WHERE Temperature_Celsius > 35 )  SELECT v.Vehicle_Id, v.Model  FROM vehicles v  JOIN charge_cycles cc ON v.Vehicle_Id = cc.Vehicle_Id  JOIN fast_charge_stats fcs ON v.Vehicle_Id = fcs.Vehicle_Id  JOIN high_temp_records htr ON v.Vehicle_Id = htr.Vehicle_Id  WHERE cc.cycles > 500 AND fcs.fast_ratio > 0.7;	new_energy_vehicles	3
SELECT 500000/(4*3.141592653589793*POWER(0.1,2)) AS radiation_intensity, CASE WHEN 500000/(4*3.141592653589793*POWER(0.1,2)) > 100*87 THEN 'Thermal Effects Discussion Required' ELSE 'Safe' END AS safety_status;	new_energy_vehicles	4
SELECT dr.Record_Id, 0.5 * (1.225 - 1.204) * 0.28 * 2.5 * POWER((dr.Average_Speed_Kmh / 3.6), 3) * (dr.Distance_Km / (dr.Average_Speed_Kmh / 3.6)) / 3600 AS energy_difference_kwh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE v.Model = 'Model S' AND strftime('%Y', dr.Start_Time) = '2023' AND strftime('%m', dr.Start_Time) = '10';	new_energy_vehicles	1
WITH charge_cycles AS (     SELECT          cr.Vehicle_Id,          SUM((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) AS cycles,          AVG(v.Battery_Capacity_Kwh - (cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0))) AS capacity      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) != 0      GROUP BY cr.Vehicle_Id )  SELECT Vehicle_Id, cycles, capacity  FROM charge_cycles  WHERE capacity > 0.05;	new_energy_vehicles	2
SELECT DISTINCT dr.Vehicle_Id FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id LEFT JOIN (     SELECT DISTINCT Vehicle_Id     FROM driving_records     WHERE Weather_Conditions LIKE '%snow%' AND Road_Type LIKE '%winter tires%' ) wt ON dr.Vehicle_Id = wt.Vehicle_Id WHERE dr.Weather_Conditions LIKE '%snow%'   AND wt.Vehicle_Id IS NULL   AND v.Drivetrain LIKE '%ABS%abnormal%';	new_energy_vehicles	3
SELECT 'Theoretical eddy current losses are zero under zero resistance, but geomagnetic field variations may cause superconductor quenching.' AS analysis_result;	new_energy_vehicles	4
SELECT dr.Energy_Consumed_Kwh, (0.6*0.4*2000*9.81*dr.Distance_Km/3600) AS theoretical_loss, (dr.Energy_Consumed_Kwh - (0.6*0.4*2000*9.81*dr.Distance_Km/3600))/dr.Energy_Consumed_Kwh*100 AS deviation_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 3 AND DATE(dr.Start_Time) = '2023-10-03' AND dr.Weather_Conditions = 'Rainy';	new_energy_vehicles	1
WITH risk_data AS (     SELECT          cs.Station_Id,          (COUNT(CASE WHEN cr.Temperature_Celsius > 25 THEN 1 END) * 1.0 / COUNT(*) * 0.4) +          (COUNT(CASE WHEN CAST(strftime('%H', cr.Start_Time) AS INTEGER) BETWEEN 18 AND 23 THEN 1 END) * 1.0 / COUNT(*) * 0.6)          AS risk_score      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cs.Station_Id )  SELECT Station_Id, risk_score  FROM risk_data  WHERE risk_score > 0.4;	new_energy_vehicles	2
WITH battery_health AS (     SELECT          cr.Vehicle_Id,          (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage + 1) / 100.0))) / v.Battery_Capacity_Kwh * 100.0 AS health      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      GROUP BY cr.Vehicle_Id ) SELECT bh.Vehicle_Id  FROM battery_health bh  JOIN (     SELECT Vehicle_Id, AVG(Average_Speed_Kmh) AS avg_speed      FROM driving_records      GROUP BY Vehicle_Id      HAVING avg_speed > 80.0 ) dr ON bh.Vehicle_Id = dr.Vehicle_Id  WHERE bh.health < 80.0;	new_energy_vehicles	3
SELECT (5E-3 * POWER(5E3,2) * 10 * 3600) / NULLIF(2000E3,0) AS energy_loss_rate;	new_energy_vehicles	4
SELECT dr.Record_Id, 0.5 * 1.225 * 0.24 * 2.34 * (POWER(dr.Average_Speed_Kmh/3.6, 3) - POWER(100/3.6, 3)) * (dr.Distance_Km/(dr.Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE v.Model = 'Model S' AND dr.Road_Type = 'Highway' AND strftime('%Y', dr.Start_Time) = '2023' AND strftime('%m', dr.Start_Time) = '10';	new_energy_vehicles	1
WITH temp_effect AS (   SELECT      Vehicle_Id,      AVG(1.1 * POWER(1.05, (Temperature_Celsius - 25) / 10)) AS temp_factor    FROM charging_records    WHERE Temperature_Celsius IS NOT NULL    GROUP BY Vehicle_Id ) SELECT    v.Vehicle_Id,    (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100))) / v.Battery_Capacity_Kwh * 100 AS capacity_loss  FROM charging_records cr  JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id  JOIN temp_effect te ON v.Vehicle_Id = te.Vehicle_Id  GROUP BY v.Vehicle_Id, v.Battery_Capacity_Kwh  HAVING capacity_loss > 20;	new_energy_vehicles	2
WITH deep_charge AS (     SELECT Vehicle_Id      FROM charging_records      WHERE Final_Battery_Percentage > 90      AND Start_Time >= date('now', '-3 months')      GROUP BY Vehicle_Id      HAVING COUNT(*) > 10 )  SELECT v.Vehicle_Id  FROM vehicles v  JOIN deep_charge dc ON v.Vehicle_Id = dc.Vehicle_Id  WHERE v.Drivetrain = 'PHEV';	new_energy_vehicles	3
SELECT 1e6 * 7.8e3 / 3e8 * COS(RADIANS(45)) * SQRT((1 + 7.8e3/3e8)/(1 - 7.8e3/3e8)) AS doppler_shift;	new_energy_vehicles	4
SELECT 0.5 * (1.225*(1+0.12*1.5) - 1.225) * 0.28 * 2.5 * (Average_Speed_Kmh/3.6 * Average_Speed_Kmh/3.6 * Average_Speed_Kmh/3.6) * (Distance_Km/(Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records WHERE Vehicle_Id = 2 AND date(Start_Time) = '2023-10-02' AND Weather_Conditions LIKE '%Rain%';	new_energy_vehicles	1
WITH heat_data AS (     SELECT          Vehicle_Id,          COUNT(CASE WHEN Temperature_Celsius > 35 THEN 1 END) AS heat_count,          SUM(Elevation_Gain_M) / 1000.0 AS total_elevation      FROM          charging_records      JOIN          driving_records USING (Vehicle_Id)      GROUP BY          Vehicle_Id ) SELECT      Vehicle_Id,      heat_count / (total_elevation * 0.1 + 1) AS thermal_index  FROM      heat_data  WHERE      thermal_index < 2.5;	new_energy_vehicles	2
SELECT Vehicle_Id, (0.3*(Temperature_Celsius-25)*((julianday(End_Time) - julianday(Start_Time)) * 86400)/3600 - 2.1e-4*(Temperature_Celsius-25)*50) AS evaporation_mm  FROM charging_records  JOIN vehicles USING (Vehicle_Id)  WHERE Model = 'Model S' AND Temperature_Celsius > 35  AND julianday(End_Time) > julianday(Start_Time);	new_energy_vehicles	3
SELECT 24e-6 * 200e9 * (ABS(-180 - 100)) * SQRT(PI() * 0.01) AS crack_growth_rate;	new_energy_vehicles	4
WITH RegenerativeEnergy AS (     SELECT 80 * 0.5 * v.Weight_Kg * ((d.Average_Speed_Kmh / 3.6) * (d.Average_Speed_Kmh / 3.6)) * 0.65 / 3600 AS Regenerated_Energy_Kwh      FROM driving_records d      JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id      WHERE d.Vehicle_Id = 2 AND DATE(d.Start_Time) = '2023-10-02' ),  ChargingEnergy AS (     SELECT SUM(c.Energy_Consumed_Kwh) AS Charged_Energy_Kwh      FROM charging_records c      WHERE c.Vehicle_Id = 2 AND DATE(c.Start_Time) = '2023-10-02' )  SELECT r.Regenerated_Energy_Kwh, c.Charged_Energy_Kwh, (r.Regenerated_Energy_Kwh - c.Charged_Energy_Kwh) * 100.0 / r.Regenerated_Energy_Kwh AS Deviation_Percent  FROM RegenerativeEnergy r, ChargingEnergy c;	new_energy_vehicles	1
WITH PeakPowerUtil AS (     SELECT          cs.Station_Id,          SUM(cr.Energy_Consumed_Kwh) / (cs.Charging_Speed_Kw * 3) AS Utilization      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      WHERE strftime('%H:%M:%S', cr.Start_Time) BETWEEN '18:00:00' AND '21:00:00'      GROUP BY cs.Station_Id )  SELECT      cs.Station_Id,      (ppu.Utilization * 0.7) AS Performance_Index,      cs.Is_Solar_Powered  FROM charging_stations cs  JOIN PeakPowerUtil ppu ON cs.Station_Id = ppu.Station_Id  WHERE (ppu.Utilization * 0.7) > 0.8;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Production_Year, AVG(cr.Temperature_Celsius) AS Avg_Temp FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE (CAST(strftime('%Y', 'now') AS INTEGER) - v.Production_Year) > 3 AND cr.Charging_Type = 'Standard' GROUP BY v.Vehicle_Id, v.Production_Year HAVING AVG(cr.Temperature_Celsius) < 5;	new_energy_vehicles	3
SELECT v.Vehicle_Id, (POWER(5,2)*0.01)/(2*4*PI()*POWER(10,-7)) AS Lorentz_Force FROM vehicles v WHERE v.Weight_Kg > 0;	new_energy_vehicles	4
SELECT dr.Distance_Km, dr.Elevation_Gain_M, (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000) / 3600 AS theory_energy, dr.Energy_Consumed_Kwh AS actual_energy, (dr.Energy_Consumed_Kwh - (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000)/3600) AS deviation FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 5 AND dr.Start_Time >= '2023-10-05' AND dr.End_Time < '2023-10-06' AND dr.Road_Type = 'Rural';	new_energy_vehicles	1
WITH station_stats AS (     SELECT          v.Manufacturer,          cs.Station_Id,          AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time)) / 3600)) AS efficiency      FROM charging_records cr      JOIN vehicles v USING(Vehicle_Id)      JOIN charging_stations cs USING(Station_Id)      WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31'      GROUP BY v.Manufacturer, cs.Station_Id )  SELECT      Manufacturer,      (STDEV(efficiency) / AVG(efficiency)) AS anomaly_index  FROM station_stats  GROUP BY Manufacturer  HAVING anomaly_index > 0.15;	new_energy_vehicles	2
SELECT cr.Vehicle_Id, COUNT(CASE WHEN cr.Charging_Type = 'Fast' THEN 1 END) * 1.0 / COUNT(*) AS fast_charge_ratio, AVG(cr.Temperature_Celsius) AS avg_temp FROM charging_records cr WHERE cr.Start_Time BETWEEN '2023-07-01' AND '2023-10-31' GROUP BY cr.Vehicle_Id HAVING fast_charge_ratio > 0.5 AND avg_temp > 30;	new_energy_vehicles	3
SELECT CASE WHEN dr.Weather_Conditions = 'Snowstorm' THEN 1 ELSE 0 END AS is_snow, AVG(cr.Energy_Consumed_Kwh/(cs.Charging_Speed_Kw * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time))/3600)) AS efficiency FROM charging_records cr JOIN charging_stations cs USING(Station_Id) JOIN driving_records dr USING(Vehicle_Id) WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31' GROUP BY is_snow;	new_energy_vehicles	4
```sql SELECT dr.Vehicle_Id, (( (dr.End_Battery_Percentage - dr.Start_Battery_Percentage)/100.0 * v.Battery_Capacity_Kwh + dr.Energy_Consumed_Kwh ) / (v.Weight_Kg * 9.81 * (dr.Elevation_Loss_M - dr.Elevation_Gain_M))) * 100.0 AS efficiency, v.Battery_Capacity_Kwh FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE (dr.Elevation_Loss_M - dr.Elevation_Gain_M) >= 500 AND dr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31 23:59:59' ORDER BY efficiency ASC LIMIT 3; ```	new_energy_vehicles	1
WITH Stats AS (     SELECT          v.Manufacturer,          (STDEV(dr.Energy_Consumed_Kwh * 1.0 / dr.Distance_Km) / AVG(dr.Energy_Consumed_Kwh * 1.0 / dr.Distance_Km)) AS cv,          COUNT(*) AS cnt      FROM driving_records dr      JOIN vehicles v USING(Vehicle_Id)      WHERE dr.Road_Type = 'Highway' AND dr.Distance_Km > 0      GROUP BY v.Manufacturer      HAVING cv > 0.25 AND cnt >= 5 )  SELECT      s.Manufacturer,      MAX(cs.Charging_Speed_Kw) AS max_power,      AVG(cs.Charging_Speed_Kw) AS avg_power  FROM Stats s  JOIN vehicles v USING(Manufacturer)  JOIN charging_records cr USING(Vehicle_Id)  JOIN charging_stations cs USING(Station_Id)  GROUP BY s.Manufacturer;	new_energy_vehicles	2
SELECT v.Vehicle_Id,         COUNT(DISTINCT CASE WHEN cr.Charging_Type IN ('Fast','Ultra-Fast') THEN cr.Record_Id END)*1.0 / COUNT(DISTINCT cr.Record_Id) AS fast_ratio,         COUNT(DISTINCT CASE WHEN dr.Weather_Conditions = 'Rainy' THEN dr.Record_Id END) AS rainy_count  FROM vehicles v  LEFT JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id  LEFT JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id  GROUP BY v.Vehicle_Id  HAVING fast_ratio > 0.5 AND rainy_count >= 1;	new_energy_vehicles	3
SELECT cs.Station_Id, POWER(500000.0/5, 3) AS power_factor, (2 * 3.141592653589793 * SQRT(POW((1.0003-1)*100000,2) + 2*100000*6371000)) / (300000000/(SELECT MAX(Charging_Speed_Kw)*1000 FROM charging_stations)) AS phase_jitter, CASE WHEN EXISTS(SELECT 1 FROM vehicles v JOIN charging_records cr USING(Vehicle_Id) WHERE v.Motor_Power_Kw > 500 AND cr.Station_Id = cs.Station_Id ) THEN 'Quantum' ELSE 'Classic' END AS qec_type FROM charging_stations cs WHERE EXISTS(SELECT 1 FROM charging_records WHERE Station_Id = cs.Station_Id AND Weather_Conditions = 'Magnetic_Storm' AND CAST(strftime('%d', Start_Time) AS INTEGER) BETWEEN 20 AND 25 ) GROUP BY cs.Station_Id HAVING phase_jitter > 3.141592653589793/2;	new_energy_vehicles	4
WITH ScreenArea AS (   SELECT phone_id, (screen_resolution_width / pixel_density_ppi) * (screen_resolution_height / pixel_density_ppi) AS screen_area_sq_inches    FROM phones ) SELECT p.phone_id, sa.screen_area_sq_inches  FROM phones p  JOIN ScreenArea sa ON p.phone_id = sa.phone_id  ORDER BY sa.screen_area_sq_inches DESC  LIMIT 5;	phone	1
SELECT p.phone_id, p.weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7) / (p.weight_grams / 1000) AS energy_density_wh_per_kg FROM phones p ORDER BY energy_density_wh_per_kg DESC LIMIT 3;	phone	2
SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND thickness_mm < 8 ORDER BY battery_capacity_mAh DESC;	phone	3
SELECT phone_id, (battery_capacity_mAh * 3.7) / (0.5 * 1000.0) AS battery_life_hours FROM phones WHERE (battery_capacity_mAh * 3.7) / (0.5 * 1000.0) > 1000.0;	phone	4
WITH ScreenArea AS (   SELECT      phone_id,      (screen_size_inches * screen_resolution_width / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) *       screen_size_inches * screen_resolution_height / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height)) AS screen_area_sq_inches    FROM phones ) SELECT sa.phone_id, sa.screen_area_sq_inches  FROM ScreenArea sa  ORDER BY sa.screen_area_sq_inches DESC  LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;	phone	2
SELECT AVG(battery_life_hours) AS average_battery_life FROM (SELECT battery_life_hours FROM hardware_specs ORDER BY battery_life_hours DESC LIMIT 5);	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3.6) > (1000000 * 3.7 * 3.6);	phone	4
WITH ScreenDimensions AS (   SELECT      phone_id,      screen_size_inches * (screen_resolution_width / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height)) AS screen_width_inches,      screen_size_inches * (screen_resolution_height / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height)) AS screen_height_inches    FROM phones )  SELECT p.phone_id, p.screen_size_inches, sd.screen_width_inches * sd.screen_height_inches AS screen_area_square_inches  FROM phones p  JOIN ScreenDimensions sd ON p.phone_id = sd.phone_id  ORDER BY screen_area_square_inches DESC  LIMIT 5;	phone	1
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, p.price_usd, pm.battery_life_video_playback_hours  FROM phones p  JOIN performance_metrics pm ON p.phone_id = pm.phone_id  WHERE p.battery_capacity_mAh > 4000 AND p.price_usd < 500  ORDER BY pm.battery_life_video_playback_hours DESC  LIMIT 10;	phone	3
WITH hypothetical_phone AS (   SELECT (100000 * 3.7) / (screen_size_inches * screen_resolution_width * screen_resolution_height * 0.1) AS hypothetical_battery_life    FROM phones    WHERE battery_capacity_mAh = 100000 ) SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours  FROM phones p  JOIN performance_metrics pm ON p.phone_id = pm.phone_id  CROSS JOIN hypothetical_phone hp  WHERE p.battery_capacity_mAh < 100000  AND pm.battery_life_video_playback_hours > hp.hypothetical_battery_life;	phone	4
SELECT p.phone_id AS model, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022 ORDER BY battery_energy_joules DESC LIMIT 1;	phone	1
SELECT p.phone_id, (p.price_usd / s.units_sold) * s.customer_satisfaction_score AS product_value FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 ORDER BY product_value DESC LIMIT 5;	phone	2
WITH AvgReturnRate AS (   SELECT AVG(return_rate_percentage) AS avg_return_rate    FROM sales_data    WHERE sale_year = 2020 )  SELECT p.phone_id, p.phone_id AS model, sd.return_rate_percentage, sd.sale_year  FROM phones p  JOIN sales_data sd ON p.phone_id = sd.phone_id  CROSS JOIN AvgReturnRate arr  WHERE sd.sale_year = 2020 AND sd.return_rate_percentage > arr.avg_return_rate  ORDER BY sd.return_rate_percentage DESC;	phone	3
SELECT p.phone_id, (1000000 * 3.7 * 3.6) AS battery_energy_joules, ((1000000.0 / sd.units_sold) * sd.customer_satisfaction_score) AS unit_price_satisfaction_product FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id WHERE p.battery_capacity_mAh = 1000000 AND p.price_usd = 1000000 ORDER BY battery_energy_joules DESC;	phone	4
SELECT p.phone_id, np.download_speed_mbps, np.signal_strength_dbm  FROM phones p  JOIN network_performance np ON p.phone_id = np.phone_id  WHERE np.download_speed_mbps > 2000000  ORDER BY np.download_speed_mbps DESC  LIMIT 5;	phone	1
SELECT p.phone_id, (p.battery_capacity_mAh / 1000.0 / hs.battery_life_hours) AS efficiency_ratio FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.release_year = 2022 ORDER BY efficiency_ratio DESC LIMIT 3;	phone	2
SELECT p.phone_id AS model, SUM(s.units_sold) AS total_units_sold FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 AND s.customer_satisfaction_score > 8 AND s.return_rate_percentage < 5 GROUP BY p.phone_id ORDER BY total_units_sold DESC;	phone	3
SELECT (1000000 * 1 / 8 / 1000) AS download_data_gb FROM network_performance WHERE signal_strength_dbm = -30;	phone	4
SELECT phone_id, weight_grams, battery_capacity_mAh, (battery_capacity_mAh / weight_grams) AS energy_density FROM phones ORDER BY energy_density ASC, weight_grams ASC LIMIT 1;	phone	1
SELECT phone_id, screen_size_inches, pixel_density_ppi, (PI() * POWER(screen_size_inches / 2, 2)) * pixel_density_ppi AS product FROM phones ORDER BY product DESC LIMIT 5;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.battery_capacity_mAh, (CAST(h.battery_life_hours AS REAL) / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY efficiency_ratio DESC, h.battery_life_hours DESC;	phone	3
SELECT p.phone_id, p.weight_grams * 1000 AS new_weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh / (p.weight_grams * 1000)) AS energy_density FROM phones p ORDER BY energy_density ASC, new_weight_grams ASC LIMIT 1;	phone	4
WITH ScreenArea AS (     SELECT          phone_id,          screen_size_inches,          (screen_size_inches * COS(ATAN(9.0/16.0))) * (screen_size_inches * SIN(ATAN(9.0/16.0))) AS screen_area_sq_inches      FROM phones      WHERE screen_size_inches > 6 )  SELECT phone_id, screen_size_inches, screen_area_sq_inches  FROM ScreenArea  ORDER BY screen_area_sq_inches ASC  LIMIT 5;	phone	1
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 10;	phone	2
SELECT phone_id FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh ASC LIMIT 3;	phone	3
WITH HypotheticalScreen AS (SELECT 100 * COS(ATAN(9.0/16.0)) AS screen_width, 100 * SIN(ATAN(9.0/16.0)) AS screen_height), HypotheticalArea AS (SELECT screen_width * screen_height AS screen_area FROM HypotheticalScreen), PhoneScreenAreas AS (SELECT p.phone_id, p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_width, p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_height, (p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) * (p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) AS screen_area FROM phones p) SELECT p.phone_id, p.screen_area FROM PhoneScreenAreas p, HypotheticalArea h WHERE p.screen_area < h.screen_area ORDER BY p.screen_area DESC LIMIT 5;	phone	4
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones WHERE screen_resolution_width > 1080 ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, h.battery_life_hours, (CAST(h.battery_life_hours AS REAL) / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh > 4000 ORDER BY efficiency_ratio ASC LIMIT 10;	phone	2
SELECT p.phone_id, p.screen_size_inches, p.price_usd, p.pixel_density_ppi FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500 ORDER BY p.screen_size_inches ASC;  SELECT AVG(p.pixel_density_ppi) AS average_pixel_density FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500;	phone	3
SELECT phone_id, screen_resolution_width, screen_resolution_height, screen_size_inches, pixel_density_ppi FROM phones WHERE pixel_density_ppi > 10000 ORDER BY pixel_density_ppi DESC;	phone	4
SELECT (battery_capacity_mAh * 3.7) / (5 * 1000) AS discharge_time_hours FROM phones WHERE battery_capacity_mAh = 5000;	phone	1
SELECT AVG(hs.battery_life_hours) AS average_battery_life_hours FROM (SELECT p.phone_id, p.battery_capacity_mAh FROM phones p WHERE p.release_year = 2022 ORDER BY p.battery_capacity_mAh DESC LIMIT 5) AS top_phones JOIN hardware_specs hs ON top_phones.phone_id = hs.phone_id ORDER BY average_battery_life_hours DESC;	phone	2
SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh DESC;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh < 10000 AND hs.charging_speed_watts > 50;	phone	4
SELECT phone_id, (battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones ORDER BY battery_energy_joules DESC LIMIT 5;	phone	1
SELECT phone_id, (screen_resolution_width * screen_resolution_height) AS pixel_count FROM phones ORDER BY pixel_count DESC LIMIT 10;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3600) / 1000 > (1000000 * 3.7 * 3600) / 1000;	phone	4
WITH PixelDensity AS (     SELECT          phone_id,          screen_resolution_width,          screen_resolution_height,          screen_size_inches,          SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS PPI      FROM phones ) SELECT      p.phone_id,      p.screen_resolution_width,      p.screen_resolution_height,      p.screen_size_inches,      pd.PPI,      (25.4 / pd.PPI) * 1000 AS pixel_size_micrometers  FROM phones p  JOIN PixelDensity pd ON p.phone_id = pd.phone_id  ORDER BY pd.PPI DESC  LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, (p.battery_capacity_mAh / hs.battery_life_hours) AS hourly_consumption_mAh_per_hour FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY (p.battery_capacity_mAh / hs.battery_life_hours) DESC LIMIT 10;	phone	2
SELECT * FROM phones WHERE screen_size_inches > 6 AND weight_grams < 150 ORDER BY screen_size_inches ASC;	phone	3
SELECT (25.4 / pixel_density_ppi) * 1000000 AS pixel_size_nm FROM phones WHERE pixel_density_ppi = 10000 AND screen_size_inches = 10;	phone	4
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY hs.battery_life_hours DESC;	phone	3
WITH AdjustedScores AS (   SELECT p.phone_id,           (100 / hs.cpu_clock_speed_ghz) * pm.geekbench_multi_core_score AS adjusted_geekbench_multi_core_score    FROM phones p    JOIN hardware_specs hs ON p.phone_id = hs.phone_id    JOIN performance_metrics pm ON p.phone_id = pm.phone_id ) SELECT phone_id, adjusted_geekbench_multi_core_score  FROM AdjustedScores  ORDER BY adjusted_geekbench_multi_core_score DESC  LIMIT 5;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh, h.cpu_clock_speed_ghz, h.ram_gb, (h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) AS total_power_watts, (p.battery_capacity_mAh / ((h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) * 1000 / 3.7)) AS battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.cpu_clock_speed_ghz = 2.5 AND h.ram_gb = 8 AND p.battery_capacity_mAh = 4000;	phone	1
SELECT ((storage_read_speed_mbps + storage_write_speed_mbps) * 3600 / 1024) AS max_data_volume_gb FROM hardware_specs WHERE ram_gb = 12 AND storage_read_speed_mbps = 500 AND storage_write_speed_mbps = 300;	phone	2
SELECT (5000 / ((6.5 * 1080 * 2340 * 0.000001) * 1000 / 3.7)) AS battery_life_hours FROM phones WHERE screen_size_inches = 6.5 AND screen_resolution_width = 1080 AND screen_resolution_height = 2340 AND battery_capacity_mAh = 5000;	phone	3
WITH max_data AS (SELECT (storage_read_speed_mbps / 1000.0 + storage_write_speed_mbps / 1000.0) AS max_data_processed_tb FROM hardware_specs WHERE ram_gb = 1024) SELECT max_data_processed_tb, (battery_capacity_mAh / (cpu_clock_speed_ghz * 10.0 + ram_gb * 0.1 + storage_gb * 0.05) * 1000.0 / 3.7) AS battery_life_hours FROM max_data, hardware_specs JOIN phones ON hardware_specs.phone_id = phones.phone_id WHERE hardware_specs.ram_gb = 1024;	phone	4
SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY charging_time_hours ASC LIMIT 5;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;	phone	2
SELECT phone_id, battery_capacity_mAh, price_usd FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh DESC LIMIT 10;	phone	3
SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000.0) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh = 100000 AND hs.charging_speed_watts = 1000;	phone	4
SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_WhL FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches > 6 ORDER BY energy_density_WhL DESC LIMIT 5;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC LIMIT 10;	phone	3
WITH phone_energy_density AS (     SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_wh_per_l      FROM phones ),  average_energy_density AS (     SELECT AVG(energy_density_wh_per_l) AS avg_energy_density      FROM phone_energy_density ) SELECT CASE      WHEN (100000 * 3.7) / (100 * 200 * 300 * 0.001) > (SELECT avg_energy_density FROM average_energy_density) * 10      THEN 'Yes'      ELSE 'No'  END AS is_10x_higher;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours, (p.battery_capacity_mAh * 3.7 * 3.6) / (pm.battery_life_video_playback_hours * 3600) AS average_power_consumption_watts FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;	phone	1
SELECT phone_id, (battery_capacity_mAh / weight_grams) AS battery_density_mAh_g FROM phones ORDER BY battery_density_mAh_g ASC LIMIT 5;	phone	2
SELECT p.phone_id, pm.battery_life_video_playback_hours, p.price_usd FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE pm.battery_life_video_playback_hours > 20 AND p.price_usd < 500 ORDER BY pm.battery_life_video_playback_hours DESC;	phone	3
SELECT (1000000 * 3.7 * 3.6) / (1000 * 3600) AS average_power_consumption_watts FROM phones WHERE battery_capacity_mAh = 1000000 AND EXISTS (SELECT 1 FROM performance_metrics WHERE performance_metrics.phone_id = phones.phone_id AND battery_life_video_playback_hours = 1000);	phone	4
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / pm.gfxbench_fps AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = '1';	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / (pm.gfxbench_fps * pm.gfxbench_fps) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = 'specific_phone_id';	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000.0 / 5.0)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
SELECT p.battery_capacity_mAh / (h.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh = 100000;	phone	4
SELECT (2 * (500 / 250)) AS max_power_consumption_watts FROM phones WHERE phone_id = '1';	phone	1
SELECT (battery_capacity_mAh * 3.7) / 1000 AS total_energy_Wh, ((battery_capacity_mAh * 3.7) / 1000) / 10 AS avg_power_consumption_W FROM phones WHERE phone_id = '1';	phone	2
SELECT phone_id, battery_capacity_mAh FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh ASC;	phone	3
SELECT pm.phone_id, (pm.thermal_throttling_percentage - 100) AS performance_loss_percentage FROM performance_metrics pm WHERE pm.thermal_throttling_percentage > 150;	phone	4
SELECT (MAX(p.battery_capacity_mAh) / 1000.0) * 3.7 * 3600 AS total_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022;	phone	1
WITH yearly_revenue AS (     SELECT p.phone_id, sd.sale_year, SUM(sd.revenue_usd) AS total_revenue      FROM phones p      JOIN sales_data sd ON p.phone_id = sd.phone_id      WHERE sd.sale_year IN (2021, 2022)      GROUP BY p.phone_id, sd.sale_year ),  max_revenue_per_year AS (     SELECT sale_year, MAX(total_revenue) AS max_revenue      FROM yearly_revenue      GROUP BY sale_year ),  top_phones AS (     SELECT yr.phone_id, yr.sale_year, yr.total_revenue      FROM yearly_revenue yr      JOIN max_revenue_per_year mrpy ON yr.sale_year = mrpy.sale_year AND yr.total_revenue = mrpy.max_revenue )  SELECT      tp2021.phone_id AS top_phone_2021,      tp2021.total_revenue AS revenue_2021,      tp2022.phone_id AS top_phone_2022,      tp2022.total_revenue AS revenue_2022,      ((tp2022.total_revenue - tp2021.total_revenue) * 1.0 / tp2021.total_revenue) * 100 AS growth_rate_percentage  FROM top_phones tp2021  JOIN top_phones tp2022  WHERE tp2021.sale_year = 2021 AND tp2022.sale_year = 2022;	phone	2
WITH top_selling_phone_2022 AS (     SELECT sd.phone_id, SUM(sd.units_sold) AS total_units_sold      FROM sales_data sd      WHERE sd.sale_year = 2022      GROUP BY sd.phone_id      ORDER BY total_units_sold DESC      LIMIT 1 )  SELECT p.phone_id, hs.battery_life_hours, AVG(sd.customer_satisfaction_score) AS avg_customer_satisfaction_score  FROM phones p  JOIN hardware_specs hs ON p.phone_id = hs.phone_id  JOIN sales_data sd ON p.phone_id = sd.phone_id  JOIN top_selling_phone_2022 tsp ON p.phone_id = tsp.phone_id  GROUP BY p.phone_id, hs.battery_life_hours;	phone	3
SELECT (battery_capacity_mAh / 1000.0) * 3.7 / 5.0 AS video_playback_hours FROM phones WHERE battery_capacity_mAh = 100000;	phone	4
SELECT (10 * 1024) / (download_speed_mbps * 8) AS download_time_seconds FROM network_performance WHERE phone_id = 2;	phone	1
SELECT n.phone_id, ((n.download_speed_mbps + n.upload_speed_mbps) * 3600 * 24 * 365 / 8 / 1024) AS total_data_gb FROM network_performance n;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, np.download_speed_mbps, (p.battery_capacity_mAh * 3.7) / (np.download_speed_mbps * 0.1) AS battery_life_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;	phone	3
SELECT (1000000 * 3600 * 24 * 365 / 8 / 1024 / 1024 / 1024) AS total_download_data_eb;	phone	4
SELECT phone_id, screen_size_inches, screen_resolution_width, screen_resolution_height, pixel_density_ppi, (screen_size_inches * screen_size_inches / (1 + (screen_resolution_height * 1.0 / screen_resolution_width) * (screen_resolution_height * 1.0 / screen_resolution_width)) * (screen_resolution_width * 1.0 / screen_resolution_height)) AS screen_area_square_inches, (25.4 / pixel_density_ppi) AS pixel_width_mm, (25.4 / pixel_density_ppi) AS pixel_height_mm FROM phones;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, hs.charging_speed_watts, (p.battery_capacity_mAh * 3.7 * 3600 / 1000) AS battery_energy_joules, ((p.battery_capacity_mAh * 3.7 * 3600 / 1000) / (hs.battery_life_hours * 3600)) AS average_power_consumption_watts, ((p.battery_capacity_mAh / (hs.charging_speed_watts * 1000 / 3.7)) * 100) AS charging_efficiency_percentage FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id;	phone	2
SELECT phone_id, weight_grams, width_mm, thickness_mm, CASE WHEN weight_grams < 200 AND width_mm < 75 AND thickness_mm < 10 THEN 'Suitable' ELSE 'Not Suitable' END AS one_handed_operation_suitability FROM phones;	phone	3
SELECT phones.phone_id, battery_capacity_mAh, charging_speed_watts, (battery_capacity_mAh * 3.7) / (charging_speed_watts * 1000) AS charge_time_hours, CASE WHEN battery_life_hours > 100 * 365 * 24 THEN 'Yes' ELSE 'No' END AS is_permanent_device FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 1000000 AND charging_speed_watts = 100;	phone	4
WITH PixelDensity AS (     SELECT phone_id,             SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS ppi      FROM phones )  SELECT phone_id, ppi  FROM PixelDensity  WHERE ppi = (SELECT MAX(ppi) FROM PixelDensity);	phone	1
SELECT p.phone_id, (h.storage_read_speed_mbps + h.storage_write_speed_mbps) AS total_storage_bandwidth_mbps FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY total_storage_bandwidth_mbps DESC LIMIT 1;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY p.battery_capacity_mAh DESC, h.charging_speed_watts DESC LIMIT 1;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts, (p.battery_capacity_mAh / hs.charging_speed_watts) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh > 100000 AND hs.charging_speed_watts > 1000;	phone	4
SELECT (p.battery_capacity_mAh * 3.7) / (4 * 1000) AS battery_life_hours FROM phones p WHERE p.phone_id = 1;	phone	1
SELECT p.phone_id, (h.cpu_clock_speed_ghz * 2.5 + h.gpu_cores * 1.2 + (p.screen_size_inches * 0.1) + 0.5) * h.battery_life_hours AS total_energy_consumption_wh FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.phone_id = 'specific_phone_id';	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000.0)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
SELECT (battery_capacity_mAh / (charging_speed_watts * 1000)) AS charging_time_hours FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 100000 AND charging_speed_watts = 1000;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh / (pm.battery_life_video_playback_hours * 1000.0) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;	phone	1
WITH MonthlySales AS (     SELECT          phone_id,          sale_year,          sale_month,          SUM(units_sold) AS total_units_sold      FROM          sales_data      WHERE          phone_id = '1'          AND sale_year = '2022'      GROUP BY          phone_id,          sale_year,          sale_month ),  GrowthRates AS (     SELECT          ms1.phone_id,          ms1.sale_year,          ms1.sale_month,          ms1.total_units_sold AS current_month_sales,          ms2.total_units_sold AS previous_month_sales,          ((ms1.total_units_sold - ms2.total_units_sold) * 100.0 / ms2.total_units_sold) AS growth_rate      FROM          MonthlySales ms1      LEFT JOIN          MonthlySales ms2      ON          ms1.phone_id = ms2.phone_id          AND ms1.sale_year = ms2.sale_year          AND ms1.sale_month = ms2.sale_month + 1 )  SELECT      sale_month,      growth_rate  FROM      GrowthRates  WHERE      growth_rate IS NOT NULL  ORDER BY      growth_rate DESC  LIMIT 1;	phone	2
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones;	phone	3
SELECT 100000 / (10000 / 1000) AS battery_life_hours;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 / 1000 AS battery_energy_Wh, np.download_speed_mbps * 0.1 AS download_power_W, (p.battery_capacity_mAh * 3.7 / 1000) / (np.download_speed_mbps * 0.1) AS discharge_time_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels, (screen_resolution_width * screen_resolution_height) / (screen_size_inches * screen_size_inches) AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC;	phone	2
SELECT p.phone_id, p.screen_size_inches, h.cpu_clock_speed_ghz, p.battery_capacity_mAh, h.battery_life_hours, (p.battery_capacity_mAh / (p.screen_size_inches * h.cpu_clock_speed_ghz * 0.1)) AS calculated_battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
WITH phone_data AS (   SELECT      p.phone_id,      p.battery_capacity_mAh,      np.download_speed_mbps,      hs.battery_life_hours,      hs.charging_speed_watts    FROM phones p    JOIN hardware_specs hs ON p.phone_id = hs.phone_id    JOIN network_performance np ON p.phone_id = np.phone_id    WHERE np.download_speed_mbps = 1000 ) SELECT    phone_id,    (download_speed_mbps * 30 * 24 * 60 * 60) / (8 * 1024 * 1024) AS total_data_tb,    (charging_speed_watts * 30 * 24) / (battery_capacity_mAh * 3.7 / 1000) * 100 AS battery_loss_percentage  FROM phone_data;	phone	4
SELECT r.researcherName, COUNT(e.experimentId) AS experimentCount FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = 'Spectrometer' GROUP BY r.researcherId ORDER BY experimentCount DESC LIMIT 5;	PhysicsLabDB	1
WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount ORDER BY equipmentCount DESC;	PhysicsLabDB	2
SELECT researcherName, joinDate FROM Researchers WHERE strftime('%Y', joinDate) = '2023' ORDER BY joinDate ASC LIMIT 10;	PhysicsLabDB	3
SELECT SUM(capacity) + (COUNT(labId) * 1000) AS new_total_capacity FROM Labs;	PhysicsLabDB	4
SELECT labName, equipmentCount, (equipmentCount * 500) AS totalPower FROM Labs WHERE equipmentCount = (SELECT MAX(equipmentCount) FROM Labs);	PhysicsLabDB	1
WITH TopMeasurements AS (     SELECT measurementValue      FROM ExperimentData      ORDER BY measurementValue DESC      LIMIT 10 )  SELECT      AVG(measurementValue) AS average_value,      AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue) AS variance_value,      SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS stddev_value  FROM TopMeasurements;	PhysicsLabDB	2
SELECT Labs.labName, Labs.location, Experiments.experimentName FROM Labs JOIN Experiments ON Labs.labId = Experiments.labId WHERE Labs.capacity > 100 AND Experiments.status = 'ongoing';	PhysicsLabDB	3
SELECT Experiments.experimentId, Experiments.experimentName, AVG(ExperimentData.measurementValue) AS averageMeasurementValue FROM Experiments JOIN ExperimentData ON Experiments.experimentId = ExperimentData.experimentId WHERE Experiments.status = 'ongoing' GROUP BY Experiments.experimentId, Experiments.experimentName ORDER BY averageMeasurementValue ASC;	PhysicsLabDB	1
SELECT result FROM Calculations WHERE experimentId IN (SELECT experimentId FROM Experiments WHERE status = 'completed') ORDER BY result DESC LIMIT 5;	PhysicsLabDB	2
SELECT labId, labName, capacity, equipmentCount, (equipmentCount * 1.0 / capacity) AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC;	PhysicsLabDB	3
WITH ExaggeratedMeasurements AS (     SELECT experimentId, AVG(measurementValue * 1000) AS exaggeratedAvg      FROM ExperimentData      GROUP BY experimentId      ORDER BY exaggeratedAvg ASC )  SELECT * FROM ExaggeratedMeasurements  WHERE exaggeratedAvg NOT IN (     SELECT exaggeratedAvg FROM ExaggeratedMeasurements );	PhysicsLabDB	4
SELECT deviceId, deviceName, calibrationDate,         julianday('now') - julianday(calibrationDate) AS calibrationIntervalDays  FROM Devices  ORDER BY calibrationIntervalDays ASC  LIMIT 5;	PhysicsLabDB	1
SELECT labId, labName, equipmentCount * 1.0 / capacity AS densityRatio FROM Labs ORDER BY densityRatio DESC LIMIT 3;	PhysicsLabDB	2
SELECT deviceType, COUNT(*) AS faultCount FROM Devices WHERE status = 'fault' GROUP BY deviceType;	PhysicsLabDB	3
SELECT deviceId, deviceName, calibrationDate, date(calibrationDate, '+100 years') AS extendedCalibrationDate FROM Devices ORDER BY extendedCalibrationDate DESC LIMIT 10;	PhysicsLabDB	4
WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') ORDER BY measurementValue DESC LIMIT 5) SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM TopMeasurements;	PhysicsLabDB	1
WITH LogTransformedData AS (SELECT LOG10(measurementValue) AS logValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'oscilloscope') AND unit = 'V') SELECT AVG(logValue) AS logAverage, SQRT(AVG(logValue * logValue) - AVG(logValue) * AVG(logValue)) AS logStandardDeviation FROM LogTransformedData;	PhysicsLabDB	2
SELECT AVG(measurementValue) AS mean, SQRT(AVG((measurementValue - (SELECT AVG(measurementValue) FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'thermometer'))) * (measurementValue - (SELECT AVG(measurementValue) FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'thermometer'))))) AS stddev FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'thermometer');	PhysicsLabDB	3
SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM ExperimentData WHERE measurementValue > 1000000 AND unit = 'lm' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer');	PhysicsLabDB	4
SELECT (3 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') AND measurementValue = 500 AND unit = 'nanometer';	PhysicsLabDB	1
WITH RECURSIVE VariableCalculation AS (     SELECT variableId, variableName, initialValue AS currentValue, unit, dataQuality      FROM Variables      WHERE experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = 'a certain experiment')     UNION ALL     SELECT v.variableId, v.variableName,             CASE                 WHEN v.variableName = 'A' THEN SQRT(vc.currentValue)                 WHEN v.variableName = 'B' THEN 2 * vc.currentValue             END AS currentValue,             v.unit, v.dataQuality      FROM Variables v      JOIN VariableCalculation vc ON v.experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = 'a certain experiment')     WHERE (v.variableName = 'A' AND vc.variableName = 'B') OR (v.variableName = 'B' AND vc.variableName = 'A') )  SELECT * FROM VariableCalculation;	PhysicsLabDB	2
SELECT deviceId, deviceName, deviceType, calibrationDate, status, labId FROM Devices WHERE calibrationDate < date('now', '-1 year') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT * FROM Calculations WHERE result > 1e300 ORDER BY result DESC;	PhysicsLabDB	4
WITH SpectralData AS (     SELECT          ed.dataId,          ed.experimentId,          ed.deviceId,          ed.timestamp,          ed.measurementValue AS lightIntensity,          ed.unit,          ed.dataQuality,          ed.environmentalConditions      FROM          ExperimentData ed      JOIN          Devices d ON ed.deviceId = d.deviceId      WHERE          d.deviceType = 'spectrometer'          AND ed.experimentId = 'specific experiment ID' ),  EnergyCalculations AS (     SELECT          sd.dataId,          sd.experimentId,          sd.deviceId,          sd.timestamp,          sd.lightIntensity,          sd.unit,          sd.dataQuality,          sd.environmentalConditions,          (6.62607015e-34 * 299792458 / sd.lightIntensity) AS energy      FROM          SpectralData sd )  SELECT      ec.dataId,      ec.experimentId,      ec.deviceId,      ec.timestamp,      ec.lightIntensity,      ec.energy,      ec.unit,      ec.dataQuality,      ec.environmentalConditions  FROM      EnergyCalculations ec  ORDER BY      ec.energy ASC  LIMIT 10;	PhysicsLabDB	1
SELECT e.experimentId, e.experimentName, AVG(sa.sensitivityValue) AS avgSensitivityValue FROM Experiments e JOIN SensitivityAnalysis sa ON e.experimentId = sa.experimentId WHERE sa.impact = 'High' GROUP BY e.experimentId, e.experimentName;	PhysicsLabDB	2
SELECT d.deviceType, COUNT(ed.deviceId) AS usageCount FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId JOIN Experiments e ON ed.experimentId = e.experimentId WHERE e.status = 'Completed' GROUP BY d.deviceType ORDER BY usageCount DESC;	PhysicsLabDB	3
SELECT labId, labName, (10000.0 / equipmentCount) AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS average_wavelength FROM (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') AND unit = 'nanometers' ORDER BY measurementValue DESC LIMIT 5);	PhysicsLabDB	1
SELECT * FROM Calculations WHERE result > 1000 ORDER BY result DESC LIMIT 10;	PhysicsLabDB	2
SELECT labId, labName, location, capacity, equipmentCount, status FROM Labs WHERE capacity > 50 ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 10000 ORDER BY initialValue DESC LIMIT 5;	PhysicsLabDB	4
SELECT deviceId, AVG(measurementValue) AS averageMeasurementValue FROM ExperimentData GROUP BY deviceId ORDER BY averageMeasurementValue ASC;	PhysicsLabDB	1
WITH TopMeasurements AS (     SELECT measurementValue      FROM ExperimentData      ORDER BY measurementValue DESC      LIMIT 5 )  SELECT      AVG(measurementValue) AS average_value,      SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation  FROM TopMeasurements;	PhysicsLabDB	2
SELECT deviceType, GROUP_CONCAT(deviceName, ', ') AS deviceNames, GROUP_CONCAT(calibrationDate, ', ') AS calibrationDates FROM Devices WHERE (julianday('now') - julianday(calibrationDate)) > 365 GROUP BY deviceType;	PhysicsLabDB	3
SELECT h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult  FROM Hypotheses h  JOIN ExperimentData ed ON h.experimentId = ed.experimentId  WHERE h.verificationResult = 'False'  AND ed.measurementValue > (SELECT initialValue FROM Variables WHERE experimentId = h.experimentId AND variableName = 'Normal Value') * 100  GROUP BY h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult;	PhysicsLabDB	4
SELECT e.experimentId, AVG(ed.measurementValue) AS average_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = 'spectrometer' GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	1
WITH OscilloscopeExperiments AS (     SELECT ed.experimentId, ed.measurementValue      FROM ExperimentData ed      JOIN Devices d ON ed.deviceId = d.deviceId      WHERE d.deviceType = 'oscilloscope' ),  ExperimentStats AS (     SELECT experimentId, AVG(measurementValue) AS avg_value, COUNT(measurementValue) AS count_value      FROM OscilloscopeExperiments      GROUP BY experimentId )  SELECT oe.experimentId, SQRT(SUM((oe.measurementValue - es.avg_value) * (oe.measurementValue - es.avg_value)) / es.count_value) AS std_deviation  FROM OscilloscopeExperiments oe  JOIN ExperimentStats es ON oe.experimentId = es.experimentId  GROUP BY oe.experimentId  ORDER BY oe.experimentId ASC;	PhysicsLabDB	2
SELECT e.experimentId, SUM(ed.measurementValue) AS total_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType NOT IN ('spectrometer', 'oscilloscope') GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	3
SELECT e.experimentId, MAX(ed.measurementValue) AS max_measurement_value FROM Experiments e JOIN Labs l ON e.labId = l.labId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE l.equipmentCount > 1000 GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	4
SELECT L.labId, L.labName, L.location, L.capacity, COUNT(R.researcherId) AS currentResearchers, (L.capacity >= COUNT(R.researcherId) * 2) AS isCapacitySufficient FROM Labs L JOIN Experiments E ON L.labId = E.labId JOIN Researchers R ON E.researcherId = R.researcherId WHERE E.status = 'in progress' GROUP BY L.labId, L.labName, L.location, L.capacity;	PhysicsLabDB	1
SELECT labId, labName, CAST(equipmentCount AS REAL) / capacity AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC LIMIT 1;	PhysicsLabDB	2
SELECT AVG(JULIANDAY('now') - JULIANDAY(e.startDate)) AS averageVerificationTime FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId WHERE h.status = 'Unverified';	PhysicsLabDB	3
SELECT labId, labName, (capacity / 0.1) AS maxResearchers FROM Labs;	PhysicsLabDB	4
SELECT SUM(POWER(equipmentCount, 2) * 10) AS total_power_consumption FROM Labs;	PhysicsLabDB	1
WITH ExperimentDurations AS (     SELECT experimentId, experimentName, (julianday(endDate) - julianday(startDate)) AS duration      FROM Experiments      WHERE status = 'Completed' )  SELECT AVG(duration) AS average_duration, MAX(duration) AS max_duration  FROM ExperimentDurations;	PhysicsLabDB	2
SELECT      (COUNT(CASE WHEN status = 'fault' THEN 1 END) * 100.0 / COUNT(*)) AS fault_percentage FROM Devices;	PhysicsLabDB	3
SELECT 10000 / 1000 AS lab_density;	PhysicsLabDB	4
SELECT e.experimentName AS experiment_name, e.startDate AS experiment_start_time, e.endDate AS experiment_end_time, AVG(ed.measurementValue) AS average_gravitational_acceleration FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = 'Measuring Gravitational Acceleration' GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	1
SELECT e.experimentName, e.startDate, e.endDate, AVG(ed1.measurementValue * 1.0 / ed2.measurementValue) AS averageResistance FROM Experiments e JOIN ExperimentData ed1 ON e.experimentId = ed1.experimentId AND ed1.unit = 'V' JOIN ExperimentData ed2 ON e.experimentId = ed2.experimentId AND ed2.unit = 'A' AND ed1.timestamp = ed2.timestamp GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	2
SELECT e.experimentName, e.startDate, e.endDate, MAX(ed.measurementValue) AS maxTemperature, MIN(ed.measurementValue) AS minTemperature FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = 'Celsius' OR ed.unit = 'Fahrenheit' GROUP BY e.experimentId;	PhysicsLabDB	3
SELECT e.experimentName, e.startDate, e.endDate, AVG(ed.measurementValue) AS averageSpeed FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = 'Measuring Speed of Light Experiment' AND ed.measurementValue > 1000000000 GROUP BY e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	4
SELECT SUM(500 * 8) AS total_energy_consumption_kWh FROM Devices WHERE deviceType = 'spectrometer';	PhysicsLabDB	1
SELECT AVG(JULIANDAY('2023-10-01') - JULIANDAY(calibrationDate)) AS average_calibration_interval FROM Devices;	PhysicsLabDB	2
SELECT deviceName, calibrationDate FROM Devices WHERE status = 'faulty';	PhysicsLabDB	3
WITH DevicePower AS (   SELECT deviceId, deviceName,           CASE             WHEN deviceType = 'oscilloscope' THEN 500             WHEN deviceType = 'spectrometer' THEN 700             ELSE 300           END AS basePower    FROM Devices    WHERE labId = (SELECT labId FROM Labs WHERE labName = 'target laboratory name') ), MaxPower AS (   SELECT deviceId, deviceName, basePower * 1000 AS maxPower    FROM DevicePower ), TotalEnergy AS (   SELECT SUM(maxPower * 24) AS totalEnergy    FROM MaxPower ) SELECT    CASE      WHEN totalEnergy > 1000 THEN 'exceeds grid capacity'      ELSE 'does not exceed grid capacity'    END AS result  FROM TotalEnergy;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS averageLightIntensity FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') AND unit = 'Lux';	PhysicsLabDB	1
WITH HighTempData AS (     SELECT measurementValue      FROM ExperimentData      WHERE environmentalConditions = 'high temperature' AND unit = '°C' ),  AverageValue AS (     SELECT AVG(measurementValue) AS avgValue      FROM HighTempData )  SELECT SQRT(SUM(POWER(measurementValue - avgValue, 2)) / COUNT(*)) AS standardDeviation  FROM HighTempData, AverageValue;	PhysicsLabDB	2
SELECT SUM(measurementValue) AS totalCurrent FROM ExperimentData WHERE dataQuality = 'high' AND unit = 'A';	PhysicsLabDB	3
SELECT SUM(measurementValue * 1000) * 1000 AS totalVoltage FROM ExperimentData WHERE unit = 'V';	PhysicsLabDB	4
SELECT experimentId, experimentName, (3.00 * POWER(10, 8)) / (5.00 * POWER(10, 14)) AS wavelength, 'm' AS unit FROM Experiments WHERE experimentName = 'Spectrometer Measurement Experiment';	PhysicsLabDB	1
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES ((SELECT experimentId FROM Experiments WHERE experimentName = 'Complex Circuit Experiment'), '1/Req = 1/R1 + 1/R2 + 1/R3 + 1/R4 + 1/R5', 'R1=10Ω, R2=20Ω, R3=30Ω, R4=40Ω, R5=50Ω', 1.0 / (1.0/10 + 1.0/20 + 1.0/30 + 1.0/40 + 1.0/50), 'Ω', 'High');	PhysicsLabDB	2
WITH DevicePower AS (SELECT 10 * 500 AS total_power),  DailyEnergy AS (SELECT total_power * 8 / 1000.0 AS daily_energy FROM DevicePower),  MonthlyCost AS (SELECT daily_energy * 30 * 0.5 AS monthly_cost FROM DailyEnergy)  SELECT monthly_cost FROM MonthlyCost;	PhysicsLabDB	3
WITH DevicePower AS (SELECT SUM(10000) AS total_power FROM Devices WHERE labId = (SELECT labId FROM Labs WHERE labName = 'Very Large Laboratory')), DailyEnergy AS (SELECT total_power * 24 AS daily_energy FROM DevicePower), AnnualCost AS (SELECT daily_energy * 365 * 0.1 AS annual_cost FROM DailyEnergy) SELECT annual_cost FROM AnnualCost;	PhysicsLabDB	4
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) SELECT experimentId, 'P = V * I', 'V=' || measurementValue || ', I=2', measurementValue * 2, 'Watt', 'High' FROM ExperimentData WHERE unit = 'V' AND environmentalConditions = '25°C';	PhysicsLabDB	1
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES (1, 'F = m * a', 'm=5kg, a=9.8m/s²', 49, 'N', 'High');	PhysicsLabDB	2
SELECT equipmentCount / CAST(capacity AS REAL) AS avg_equipment_per_researcher FROM Labs WHERE capacity = 50 AND equipmentCount = 100;	PhysicsLabDB	3
SELECT hypothesisId, hypothesisText, verificationResult, verificationDate, CASE WHEN DATE(verificationDate, '+10000 years') > DATE('now') THEN 'valid' ELSE 'invalid' END AS validity FROM Hypotheses WHERE verificationResult = 'true' AND verificationDate = '2023-10-01';	PhysicsLabDB	4
SELECT AVG(measurementValue) AS averageVoltage, experimentId FROM ExperimentData WHERE unit = 'V' GROUP BY experimentId HAVING MAX(measurementValue) > 10000;	PhysicsLabDB	1
SELECT SUM(initialValue) AS totalInitialValue, variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 1000;	PhysicsLabDB	2
SELECT labId, labName, equipmentCount / capacity AS equipmentPerPerson FROM Labs WHERE equipmentCount / capacity < 2;	PhysicsLabDB	3
SELECT (julianday(verificationDate) - julianday('now')) / 365.25 AS dateDifference, h.* FROM Hypotheses h WHERE h.verificationResult = 'True'   AND julianday(verificationDate) > julianday('now', '+100 years')   AND (julianday(verificationDate) - julianday('now')) / 365.25 > 100;	PhysicsLabDB	4
WITH EnvironmentalCoefficients AS (SELECT 0.01 AS temperature_coefficient, 0.005 AS humidity_coefficient), StandardConditions AS (SELECT 20 AS standard_temperature, 40 AS standard_humidity), ExperimentData AS (SELECT measurementValue, environmentalConditions FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5 AND environmentalConditions LIKE '%25°C%' AND environmentalConditions LIKE '%50%') SELECT measurementValue * ((SELECT temperature_coefficient FROM EnvironmentalCoefficients) * (25 - (SELECT standard_temperature FROM StandardConditions)) + (SELECT humidity_coefficient FROM EnvironmentalCoefficients) * (50 - (SELECT standard_humidity FROM StandardConditions))) AS error_range FROM ExperimentData;	PhysicsLabDB	1
SELECT SUM(s.sensitivityValue * v.initialValue) AS totalImpact FROM SensitivityAnalysis s JOIN Variables v ON s.variableId = v.variableId WHERE v.variableName IN ('A', 'B', 'C');	PhysicsLabDB	2
SELECT deviceId, deviceName, calibrationDate, CASE WHEN DATE(calibrationDate, '+1 year') < '2023-05-01' THEN 'Needs recalibration' ELSE 'Does not need recalibration' END AS recalibrationStatus FROM Devices WHERE calibrationDate = '2022-01-01';	PhysicsLabDB	3
SELECT 10000 / 10 AS max_equipment_capacity;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS average_voltage FROM ExperimentData WHERE environmentalConditions = 'temperature:25°C, humidity:60%' AND unit = 'V';	PhysicsLabDB	1
WITH TemperatureData AS (     SELECT measurementValue      FROM ExperimentData      WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31'      AND unit = 'Celsius' ) SELECT SQRT(AVG(POWER(measurementValue - (SELECT AVG(measurementValue) FROM TemperatureData), 2))) AS standard_deviation  FROM TemperatureData;	PhysicsLabDB	2
SELECT MAX(measurementValue) AS max_humidity FROM ExperimentData WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31' AND unit = '%';	PhysicsLabDB	3
SELECT AVG(measurementValue) AS average_pressure FROM ExperimentData WHERE environmentalConditions LIKE '%temperature=1000°C%' AND environmentalConditions LIKE '%humidity=100%' AND unit = 'Pa';	PhysicsLabDB	4
SELECT r.researcherName, e.experimentName FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = 'Volts (V)' AND e.startDate > '2022-01-01' ORDER BY r.researcherName ASC;	PhysicsLabDB	1
SELECT labId, labName, equipmentCount * 1.0 / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;	PhysicsLabDB	2
SELECT e.experimentId, e.experimentName, e.startDate, e.endDate, e.status, h.verificationResult FROM Experiments e JOIN Hypotheses h ON e.experimentId = h.experimentId WHERE e.status = 'Completed' AND h.verificationResult = 'True' AND e.endDate <= '2021-12-31' ORDER BY e.experimentName ASC;	PhysicsLabDB	3
SELECT labId, labName, CAST(equipmentCount AS REAL) / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 10;	PhysicsLabDB	4
SELECT labName, equipmentCount FROM Labs ORDER BY equipmentCount DESC LIMIT 1;	PhysicsLabDB	1
SELECT labName, AVG(equipmentCount) AS avgEquipmentCount FROM Labs GROUP BY labName HAVING AVG(equipmentCount) > (SELECT AVG(equipmentCount) FROM Labs);	PhysicsLabDB	2
SELECT labName, capacity FROM Labs WHERE status = 'open' ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT labName, capacity FROM Labs WHERE capacity > 1000 ORDER BY capacity DESC;	PhysicsLabDB	4
SELECT deviceType, deviceName, MIN(calibrationDate) AS earliestCalibrationDate FROM Devices GROUP BY deviceType;	PhysicsLabDB	1
WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount;	PhysicsLabDB	2
SELECT deviceType, COUNT(*) AS deviceCount FROM Devices WHERE status = 'normal' GROUP BY deviceType;	PhysicsLabDB	3
SELECT labName, equipmentCount FROM Labs WHERE equipmentCount > 1000 ORDER BY equipmentCount DESC;	PhysicsLabDB	4
SELECT * FROM ExperimentData WHERE measurementValue > 1000 AND dataQuality = 'High' ORDER BY measurementValue ASC LIMIT 10;	PhysicsLabDB	1
SELECT experimentId, AVG(measurementValue) AS averageValue FROM ExperimentData GROUP BY experimentId HAVING AVG(measurementValue) > 500 ORDER BY averageValue DESC;	PhysicsLabDB	2
SELECT labName, location FROM Labs WHERE capacity > 50 AND equipmentCount > 100 ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT labName, location FROM Labs WHERE capacity > 1000000 ORDER BY capacity DESC LIMIT 5;	PhysicsLabDB	4
SELECT (3.00 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM Experiments e JOIN Devices d ON e.labId = d.labId WHERE d.deviceType = 'spectrometer' AND e.status = 'in progress';	PhysicsLabDB	1
SELECT measurementValue / 10.0 AS current FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5;	PhysicsLabDB	2
SELECT deviceId, deviceName, calibrationDate, CASE WHEN date(calibrationDate, '+1 year') < '2023-01-01' THEN 'requires recalibration' ELSE 'does not require recalibration' END AS calibrationStatus FROM Devices WHERE calibrationDate = '2020-01-01';	PhysicsLabDB	3
SELECT variableId, variableName, initialValue * 100 AS maximumValue, unit FROM Variables WHERE variableId IN (SELECT variableId FROM SensitivityAnalysis WHERE sensitivityValue = 1000 AND impact = 'High') AND initialValue = 1000 AND unit = 'meters(m)';	PhysicsLabDB	4
SELECT (p.Power_Consumption * (j.Page_Count / p.Print_Speed) / 60) AS Total_Energy_Wh FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE j.Color_Usage = 'Monochrome' AND j.Page_Count = 150 AND p.Power_Consumption = 500 AND p.Print_Speed = 30;	printer	1
SELECT (Revenue * Profit_Margin / 100) - (Revenue * R&D_Spending / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND R&D_Spending = 8;	printer	2
SELECT CASE WHEN (Capacity * (Current_Level / 100.0)) >= 800 THEN 'No' ELSE 'Yes' END AS Need_Replacement FROM consumables WHERE Type = 'Toner' AND Capacity = 5000 AND Current_Level = 5;	printer	3
SELECT (Revenue * Profit_Margin / 100) - (Revenue * [R&D_Spending] / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND [R&D_Spending] = 8;	printer	4
SELECT Consumable_ID, (Capacity * 0.3 * 5) / 1000 AS Total_Weight_KG FROM consumables WHERE Type = 'Paper' ORDER BY Total_Weight_KG DESC LIMIT 5;	printer	1
SELECT Printer_ID, SUM(CASE WHEN Type IN ('Toner', 'Ink') THEN Capacity * (Current_Level / 100.0) ELSE Capacity - (Capacity * (Current_Level / 100.0)) END) AS Total_Remaining_Pages FROM consumables GROUP BY Printer_ID ORDER BY Total_Remaining_Pages DESC LIMIT 3;	printer	2
SELECT Consumable_ID, (100 - Current_Level) / (julianday(Next_Replacement_Date) - julianday('now')) AS Daily_Usage_Percent FROM consumables WHERE (julianday(Next_Replacement_Date) - julianday('now')) > 0 HAVING Daily_Usage_Percent > 1 ORDER BY Daily_Usage_Percent ASC LIMIT 10;	printer	3
SELECT Consumable_ID, Capacity * (Current_Level / 100) AS Theoretical_Pages FROM consumables WHERE Current_Level > 100 ORDER BY Theoretical_Pages DESC;	printer	4
SELECT c.Type, (c.Capacity * (c.Current_Level / 100.0) / (p.Print_Speed * 60.0)) AS "耗尽时间_小时" FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Toner' GROUP BY c.Type;	printer	1
SELECT c.Printer_ID, SUM(c.Capacity) / SUM(c.Cost) AS 'Total Cost Efficiency' FROM consumables c WHERE c.Type IN ('Ink', 'Drum') GROUP BY c.Printer_ID ORDER BY 'Total Cost Efficiency' DESC;	printer	2
SELECT c.Type, COUNT(*) AS below_20_percent_count FROM consumables c WHERE c.Current_Level < 20 GROUP BY c.Type ORDER BY below_20_percent_count DESC;	printer	3
SELECT p.Type, CASE WHEN (1000000 * 0.0001) > p.Tray_Capacity THEN 1 ELSE 0 END AS contradiction_detection FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Drum' AND c.Capacity = 1000000 AND c.Current_Level = 0.01 GROUP BY p.Type;	printer	4
SELECT c.* FROM consumables c INNER JOIN printers p ON c.Printer_ID = p.Printer_ID LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement' WHERE c.Type = 'Toner' AND c.Current_Level < 30 AND p.Power_Consumption > 1000 AND ml.Maintenance_ID IS NULL;	printer	1
SELECT      c.Consumable_ID,      c.Printer_ID,      c.Type,      c.Model,      c.Capacity,      c.Current_Level,      c.Last_Replacement_Date,      c.Next_Replacement_Date,      c.Cost,     (c.Capacity * (c.Current_Level / 100.0)) / (julianday('now') - julianday(c.Last_Replacement_Date)) AS Daily_Wear_Rate,     (c.Capacity * (c.Current_Level / 100.0)) / ((c.Capacity * (c.Current_Level / 100.0)) / (julianday('now') - julianday(c.Last_Replacement_Date))) AS Predicted_Lifespan_Days FROM      consumables c JOIN      printers p ON c.Printer_ID = p.Printer_ID WHERE      c.Type = 'Drum'      AND julianday('now') - julianday(c.Last_Replacement_Date) <= 90     AND (c.Capacity * (c.Current_Level / 100.0)) / ((c.Capacity * (c.Current_Level / 100.0)) / (julianday('now') - julianday(c.Last_Replacement_Date))) < 7     AND c.Consumable_ID NOT IN (         SELECT DISTINCT m.Consumable_ID          FROM maintenance_logs m          WHERE m.Maintenance_Type = 'Replacement'          AND m.Maintenance_Date >= date('now', '-90 days')     ) GROUP BY      c.Consumable_ID;	printer	2
SELECT c.*  FROM consumables c  INNER JOIN printers p ON c.Printer_ID = p.Printer_ID  LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement'  WHERE c.Type = 'Fuser'  AND c.Current_Level < 15  AND p.Installation_Date < date('now', '-3 years')  AND ml.Maintenance_ID IS NULL;	printer	3
SELECT c.* FROM consumables c LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID WHERE (c.Capacity > 100000000 OR c.Current_Level > 200) AND ml.Maintenance_ID IS NULL GROUP BY c.Consumable_ID HAVING COUNT(ml.Maintenance_ID) = 0;	printer	4
SELECT (1500 * 8 * 30) / 1000 AS Total_Energy_kWh, (1500 * 8 * 30) / 1000 * 0.92 AS CO2_Emissions_kg FROM printers WHERE Printer_ID = 'Specific_Printer_ID';	printer	1
WITH Theoretical AS (     SELECT (0.6 * 200.0 / 5000.0) + (0.4 * 150.0 / 10000.0) AS TheoreticalCost ), Actual AS (     SELECT (3.0 * 200.0 + 2.0 * 150.0) / (3.0 * 5000.0 + 2.0 * 10000.0) AS ActualCost ) SELECT ((ActualCost - TheoreticalCost) / TheoreticalCost) * 100.0 AS DifferenceRate FROM Theoretical, Actual;	printer	2
SELECT Printer_ID, 'Root Cause: Extended maintenance intervals have led to wear and tear of mechanical parts' AS RootCause, 'Recommendation: Immediately perform preventive maintenance, replace worn parts, and restore the recommended maintenance schedule' AS Recommendation FROM (SELECT Printer_ID, AVG(julianday(Maintenance_Date) - julianday(LAG(Maintenance_Date) OVER (PARTITION BY Printer_ID ORDER BY Maintenance_Date))) AS AvgInterval FROM maintenance_logs GROUP BY Printer_ID HAVING COUNT(*) >= 3) t WHERE AvgInterval > (SELECT recommended_cycle FROM printers WHERE printers.Printer_ID = t.Printer_ID) * 1.5;	printer	3
SELECT 9.9E15 / 2999 AS NumberOfPrinters;	printer	4
SELECT Printer_ID,         SUM((Power_Consumption * 2) / 1000.0) AS TotalPowerConsumption_kWh  FROM maintenance_logs ml JOIN printers p ON ml.Printer_ID = p.Printer_ID WHERE Maintenance_Type = 'Repair' GROUP BY ml.Printer_ID ORDER BY TotalPowerConsumption_kWh DESC LIMIT 5;	printer	1
WITH RECURSIVE months(month) AS (     SELECT 1     UNION ALL     SELECT month + 1 FROM months WHERE month < 12 ), monthly_cost AS (     SELECT months.month, COALESCE(SUM(ml.Cost),0) AS total_cost     FROM months     LEFT JOIN maintenance_logs ml ON strftime('%Y', ml.Maintenance_Date) = '2023' AND strftime('%m', ml.Maintenance_Date) = printf('%02d', months.month)     GROUP BY months.month ) SELECT current_month,        CASE WHEN previous_month_cost = 0 THEN 0 ELSE ROUND(((current_month_cost - previous_month_cost) * 100.0 / previous_month_cost), 2) END AS growth_rate FROM (     SELECT month AS current_month,            total_cost AS current_month_cost,            LAG(total_cost, 1, 0) OVER (ORDER BY month) AS previous_month_cost     FROM monthly_cost ) t ORDER BY growth_rate ASC;	printer	2
WITH global_avg AS ( SELECT AVG(Cost) AS avg_cost FROM maintenance_logs ) SELECT Printer_ID, COUNT(*) AS maintenance_count FROM maintenance_logs WHERE Cost < (SELECT avg_cost FROM global_avg) GROUP BY Printer_ID HAVING COUNT(*) > 3 ORDER BY maintenance_count DESC LIMIT 10;	printer	3
WITH RECURSIVE months(month) AS (     SELECT 1     UNION ALL     SELECT month + 1 FROM months WHERE month < 12 ), monthly_cost AS (     SELECT months.month, COALESCE(SUM(ml.Cost), 0) AS total_cost     FROM months     LEFT JOIN maintenance_logs ml ON strftime('%Y', ml.Maintenance_Date) = '2023' AND strftime('%m', ml.Maintenance_Date) = printf('%02d', months.month)     GROUP BY months.month ) SELECT current_month,        CASE            WHEN previous_month_cost = 0 THEN 0            ELSE ROUND(((current_month_cost - previous_month_cost) * 100.0 / previous_month_cost), 2)        END AS growth_rate FROM (     SELECT month AS current_month,            total_cost AS current_month_cost,            LAG(total_cost, 1, 0) OVER (ORDER BY month) AS previous_month_cost     FROM monthly_cost ) t ORDER BY growth_rate ASC;	printer	4
SELECT m.Printer_ID, SUM((julianday(m.Next_Maintenance_Date) - julianday(m.Maintenance_Date)) * 24 * (p.Power_Consumption * 0.2) / 1000) AS Total_Standby_Energy_kWh FROM maintenance_logs m JOIN printers p ON m.Printer_ID = p.Printer_ID GROUP BY m.Printer_ID;	printer	1
WITH MaintenanceTypeStats AS (   SELECT      Maintenance_Type,     AVG(Cost) AS avg_cost,     STDEV(Cost) AS cost_stddev   FROM maintenance_logs   GROUP BY Maintenance_Type ) SELECT    Maintenance_Type,   avg_cost,   cost_stddev,   ROUND((cost_stddev / avg_cost) * 100, 4) AS cost_coefficient_of_variation FROM MaintenanceTypeStats;	printer	2
SELECT      CAST((strftime('%m', Maintenance_Date) + 2) / 3 AS INTEGER) AS Quarter,      Maintenance_Type,      COUNT(*) AS Frequency,      (SUM(CASE WHEN Maintenance_Type = 'Routine' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS Preventive_Ratio  FROM maintenance_logs  WHERE Maintenance_Type IN ('Routine','Repair')  GROUP BY Quarter, Maintenance_Type  ORDER BY Quarter;	printer	3
SELECT Technician, MAX(Cost) AS Actual_Max_Cost, (SELECT SUM(Cost)*0.95 FROM maintenance_logs) AS Theoretical_Max_Cost FROM maintenance_logs GROUP BY Technician;	printer	4
SELECT 850 * 3 * 3600 AS Total_Energy_Joules;	printer	1
SELECT ROUND( (COUNT(CASE WHEN Cost > (SELECT AVG(Cost) FROM maintenance_logs WHERE Maintenance_Type = 'Repair') THEN 1 END) * 100.0 / COUNT(*)), 2 ) AS Repair_Proportion FROM maintenance_logs WHERE Maintenance_Type = 'Repair';	printer	2
SELECT ml.* FROM maintenance_logs ml JOIN printers p ON ml.Printer_ID = p.Printer_ID WHERE ml.Maintenance_Date < p.Installation_Date;	printer	3
SELECT * FROM maintenance_logs WHERE Cost > 1e18 AND Next_Maintenance_Date > '3000-01-01';	printer	4
SELECT (400 * 18 * 365 / 1000) * Production_Volume_Total AS Total_Power_Consumption_kWh FROM manufacturers WHERE Manufacturer_ID = 'MAN001';	printer	1
SELECT R&D_Spending / Employee_Count AS Per_Capita_RD, (R&D_Spending / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND R&D_Spending = 800000000 AND Employee_Count = 10000;	printer	2
SELECT Founded_Year, R&D_Spending, CASE WHEN Founded_Year < 1900 AND R&D_Spending > 500000000 THEN 'Unreasonable' ELSE 'Reasonable' END AS Validity FROM manufacturers WHERE Founded_Year = 1700 AND R&D_Spending = 500000000;	printer	3
SELECT "R&D_Spending" / Employee_Count AS Per_Capita_RD, ("R&D_Spending" / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND "R&D_Spending" = 800000000 AND Employee_Count = 10000;	printer	4
SELECT Manufacturer_ID, Name, (Total_Energy / Production_Volume_Total) AS Energy_Consumption_Ratio FROM (     SELECT m.Manufacturer_ID, m.Name, m.Production_Volume_Total,             m.Production_Volume_Total * 0.5 AS Total_Energy     FROM manufacturers m ) ORDER BY Energy_Consumption_Ratio ASC LIMIT 3;	printer	1
SELECT Name, (R&D_Spending / Revenue) * 100 AS R_D_Percent FROM manufacturers ORDER BY R_D_Percent DESC LIMIT 5;	printer	2
SELECT Name, Founded_Year, Profit_Margin FROM manufacturers WHERE Founded_Year < 1950 AND Profit_Margin > 15 ORDER BY Founded_Year ASC;	printer	3
SELECT Name, (Revenue / Employee_Count) AS Per_Capita_Output FROM manufacturers UNION ALL SELECT 'Hypothetical Manufacturer' AS Name, 1000000000000 / 1 AS Per_Capita_Output ORDER BY Per_Capita_Output DESC;	printer	4
SELECT Country, SUM(Production_Volume_Total * 50 * 0.5) AS Total_Carbon_Emission FROM manufacturers GROUP BY Country;	printer	1
SELECT (R&D_Spending / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY Comprehensive_Index;	printer	2
SELECT Country, COUNT(*) AS Abnormal_Company_Count FROM manufacturers WHERE Founded_Year <= 1973 AND Market_Cap < (Revenue * 2) GROUP BY Country;	printer	3
SELECT ('R&D_Spending' / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY ('R&D_Spending' / Revenue) * (Profit_Margin / 100);	printer	4
SELECT m.Name, (m.Production_Volume_Total * 300 * 8 * 365 / 1000) AS Total_Annual_Power_Consumption_kWh FROM manufacturers m GROUP BY m.Manufacturer_ID;	printer	1
SELECT m.Name, ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m WHERE ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) > 10;	printer	2
SELECT Name, Founded_Year, Employee_Count FROM manufacturers WHERE (strftime('%Y', 'now') - Founded_Year) > 50 AND Employee_Count < 1000;	printer	3
SELECT m.Name, ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m WHERE ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) > 10;	printer	4
SELECT (Power_Consumption * (500.0 / (Print_Speed * 60)) / 1000) AS Total_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome' AND Power_Consumption = 800 AND Print_Speed = 30;	printer	1
SELECT CASE WHEN (2000*0.05 + 5000*0.02) <= (Capacity * (Current_Level/100.0)) THEN 'sufficient' ELSE 'not sufficient' END AS is_sufficient FROM consumables WHERE Type = 'Ink' AND Capacity = 100 AND Current_Level = 60;	printer	2
SELECT CEIL(7.0 / 2) AS Actual_Sheets FROM print_jobs WHERE Duplex = 1 AND Page_Count = 7;	printer	3
SELECT (POWER(10, 18) * 0.1 / 1000) / (500 * 0.1 / 1000 * 24 * 365) AS Years FROM printers WHERE Type = '3D' AND Tray_Capacity = 500;	printer	3
SELECT p.Model, SUM((j.Page_Count / CAST(SUBSTR(p.Print_Speed, 1, INSTR(p.Print_Speed, 'ppm') - 1) AS REAL)) * 60 * p.Power_Consumption * 1000) AS Total_Energy FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE p.Type = 'Laser' GROUP BY p.Model ORDER BY Total_Energy DESC LIMIT 5;	printer	1
SELECT c.Model, (SUM(CASE WHEN j.Color_Usage = 'Color' THEN j.Page_Count * 3 * (c.Cost/c.Capacity) ELSE 0 END) / SUM(CASE WHEN j.Color_Usage = 'Monochrome' THEN j.Page_Count * (c.Cost/c.Capacity) ELSE 0 END)) AS Cost_Ratio FROM consumables c JOIN print_jobs j ON c.Printer_ID = j.Printer_ID WHERE c.Type = 'Ink' GROUP BY c.Model HAVING Cost_Ratio IS NOT NULL ORDER BY Cost_Ratio DESC LIMIT 3;	printer	2
SELECT u.Name, SUM(j.Page_Count * 0.5) AS Saved_Paper  FROM users u  JOIN print_jobs j ON u.User_ID = j.User_ID  WHERE j.Duplex = 1  GROUP BY u.User_ID  ORDER BY Saved_Paper DESC  LIMIT 10;	printer	3
SELECT Model, (1000000000.0 / CAST(SUBSTR(Print_Speed, 1, INSTR(Print_Speed, 'ppm') - 1) AS REAL)) / 525600.0 AS Years FROM printers ORDER BY Years DESC LIMIT 5;	printer	4
SELECT Paper_Size, SUM(Page_Count * 80 * 0.06237 * (CASE WHEN Duplex=1 THEN 0.5 ELSE 1.0 END)) / 1000.0 AS Total_Mass_Kg FROM print_jobs GROUP BY Paper_Size;	printer	1
SELECT Duplex, SUM(Page_Count) - SUM(CEIL(Page_Count / (CASE WHEN Duplex = 1 THEN 2.0 ELSE 1.0 END))) AS Saved_Pages FROM print_jobs GROUP BY Duplex;	printer	2
SELECT Color_Usage, SUM(Page_Count * (CASE WHEN Color_Usage='Color' THEN 3 ELSE 1 END)) AS Consumption_Ratio FROM print_jobs GROUP BY Color_Usage;	printer	3
SELECT Duplex, CASE WHEN (100000000 / (CASE WHEN Duplex=1 THEN 2 ELSE 1 END)) > 2147483647 THEN 1 ELSE 0 END AS Crash_Condition FROM (SELECT 0 AS Duplex UNION SELECT 1) AS modes;	printer	4
SELECT pj.*  FROM print_jobs pj  JOIN printers pr ON pj.Printer_ID = pr.Printer_ID  WHERE pj.Paper_Size = 'A4'  AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(REPLACE(pr.Print_Speed, '^0-9', '') AS INTEGER), 0))) > (pr.Power_Consumption * 0.1);	printer	1
SELECT pj.Job_ID, pj.Page_Count * 0.05 * (c.Cost / 250) AS Total_Ink_Cost FROM print_jobs pj JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE pj.Color_Usage = 'Color' AND c.Type = 'Ink';	printer	2
SELECT pj.*  FROM print_jobs pj  JOIN printers pr ON pj.Printer_ID = pr.Printer_ID  WHERE pj.Paper_Size = 'A4'  AND pj.Duplex = 1  AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(SUBSTR(pr.Print_Speed, 1, INSTR(pr.Print_Speed, 'ppm') - 1) AS INTEGER), 0))) > (pr.Power_Consumption * 0.1);	printer	3
SELECT * FROM print_jobs WHERE Page_Count > 8848000000 / (0.1 * 0.001);	printer	4
SELECT ((800 * 4 + 50 * 20) * 30) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser';	printer	1
SELECT ((5000 * 0.3 - (1200 * 1 + (800 * 0.4 * 2.5 + 800 * 0.6 * 1) + (500 * 0.5))) / 5000 * 100) AS Remaining_Percent FROM consumables WHERE Type = 'Toner' AND Model = 'Certain Model';	printer	2
WITH drum_cost AS (SELECT Cost FROM consumables WHERE Type = 'Drum' LIMIT 1),       fuser_cost AS (SELECT Cost FROM consumables WHERE Type = 'Fuser' LIMIT 1)  SELECT (200 * 48 + 500 * 16) AS Annual_Budget  FROM drum_cost, fuser_cost;	printer	3
SELECT (100 * 365 * 24 * 60 / 5) AS Max_Tasks, (100 * 365 * 24 / 1000) * 1500 AS Maintenance_Cost, (100 * 365 * 24 * 60 / 5) * 0.2 AS Total_Weight FROM printers WHERE Type = '3D' LIMIT 1;	printer	4
SELECT Printer_ID, Model, (Power_Consumption * (julianday('now') - julianday(Installation_Date)) * 24) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser' AND Installation_Date >= date('now', '-1 year') ORDER BY Total_kWh DESC LIMIT 3;	printer	1
SELECT m.Name, m.Profit_Margin FROM manufacturers m WHERE m.Profit_Margin < 15 AND m.Employee_Count > 10000 ORDER BY m.Profit_Margin ASC;	printer	2
SELECT Consumable_ID, Printer_ID, Current_Level, Last_Replacement_Date FROM consumables WHERE Type = 'Toner' AND Current_Level < 20 AND julianday('now') - julianday(Last_Replacement_Date) > 90 ORDER BY Current_Level ASC;	printer	3
SELECT (100000000 / 2) AS Saved_Pages, ((100000000 / 2) * 4.5) / 1000000 AS Saved_Weight_Tons ORDER BY Saved_Weight_Tons DESC;	printer	4
SELECT Printer_ID, (Power_Consumption * 24 * 0.65 / 1000) AS Total_Energy_kWh FROM printers WHERE Type = 'laser' GROUP BY Printer_ID;	printer	1
SELECT c.Model, (c.Capacity * (c.Current_Level / 100) / 3) / (SUM(p.Page_Count * 3) / 30) AS Remaining_Days FROM consumables c JOIN printers pr ON c.Printer_ID = pr.Printer_ID JOIN print_jobs p ON pr.Printer_ID = p.Printer_ID WHERE c.Type = 'toner' AND p.Job_Date >= date('now', '-30 days') GROUP BY c.Model;	printer	2
SELECT u.Department, SUM(p.Page_Count - (p.Page_Count + 1) / 2) AS Saved_Papers FROM print_jobs p JOIN users u ON p.User_ID = u.User_ID WHERE u.Department = 'Sales Department' AND p.Duplex = 1 AND strftime('%Y', p.Job_Date) = '2023' AND ((strftime('%m', p.Job_Date) - 1) / 3 + 1) = 4 GROUP BY u.Department;	printer	3
SELECT Printer_ID, ((c.Capacity * (c.Current_Level / 100.0) / 3.0) / (SUM(p.Page_Count * 3.0) / 30.0) / (60.0 * 60.0 * 24.0 * 365.25)) / (1.38e10) AS Universe_Ages FROM consumables c JOIN print_jobs p ON c.Printer_ID = p.Printer_ID WHERE c.Type = '3D' AND c.Capacity = 1e18 AND c.Current_Level = 0.1 AND p.Job_Date >= date('now', '-30 days') GROUP BY Printer_ID;	printer	4
SELECT Printer_ID, ((Power_Consumption * (86400 - 5) + Power_Consumption * 1.2 * 5) / 1000.0) AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Power_Consumption = 800;	printer	1
SELECT p.Printer_ID, (p.Weight + (p.Tray_Capacity * 365 * 0.0045)) * (strftime('%Y', 'now') - p.Year) AS Composite_Value FROM printers p WHERE p.Printer_ID IN (SELECT DISTINCT j.Printer_ID FROM print_jobs j JOIN users u ON j.User_ID = u.User_ID WHERE u.Department = 'a certain department');	printer	2
SELECT p.Printer_ID, p.Location  FROM printers p  WHERE NOT EXISTS (     SELECT 1      FROM print_jobs j      JOIN users u ON j.User_ID = u.User_ID      WHERE j.Printer_ID = p.Printer_ID      AND LOWER(u.Department) LIKE '%' || LOWER(p.Location) || '%' );	printer	3
SELECT ((1e8 * 100 * 365 * 24 * 3600) / (POWER(3e8, 2))) / 7.342e22 AS Equivalent_Moon_Masses;	printer	4
SELECT (Power_Consumption * 23.75 + 200 * 0.25) / 1000 AS Total_Energy_KWh FROM printers WHERE Type = 'Laser' AND Max_Resolution = 'Maximum_Resolution_Value';	printer	1
SELECT Name, ROUND((SUM(RD_Spending) / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;	printer	2
SELECT CASE WHEN (SUM(Page_Count * 2 - Page_Count) / SUM(Page_Count * 2) * 100) BETWEEN 45 AND 47.5 THEN 'Complies' ELSE 'Does not comply' END AS Compliance FROM print_jobs WHERE Duplex = 1 AND Paper_Size = 'A4';	printer	3
SELECT Name, ROUND((SUM(RD_Spending) / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;	printer	4
SELECT users.User_ID, SUM(printers.Power_Consumption / 1000.0 * 24) AS total_energy_kWh FROM users JOIN print_jobs ON users.User_ID = print_jobs.User_ID JOIN printers ON print_jobs.Printer_ID = printers.Printer_ID WHERE users.Role = 'Admin' AND printers.Type = 'Laser' GROUP BY users.User_ID ORDER BY total_energy_kWh DESC LIMIT 3;	printer	1
SELECT u.Department, (SUM(CASE WHEN pj.Color_Usage = 'Monochrome' THEN pj.Page_Count ELSE 0 END) * 1.0 / SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END)) AS ratio FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Color_Usage IN ('Monochrome', 'Color') GROUP BY u.Department HAVING SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END) > 0 ORDER BY ratio ASC LIMIT 5;	printer	2
SELECT u.*, pj.* FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE u.Role = 'Guest' AND pj.Page_Count > 50 ORDER BY pj.Page_Count DESC LIMIT 10;	printer	3
SELECT u.Department, SUM(pj.Page_Count) AS total_pages FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Page_Count >= 1000000 GROUP BY u.Department ORDER BY total_pages DESC LIMIT 5;	printer	4
SELECT u.Department, SUM((p.Page_Count / (1 + p.Duplex) / pr.Print_Speed / 60) * (pr.Power_Consumption / 1000)) AS Total_Energy_kWh FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Department;	printer	1
SELECT u.Role, SUM(p.Page_Count * (CASE WHEN p.Color_Usage = 'Color' THEN 1.2 ELSE 1 END) / pr.Print_Speed * 60) / SUM(p.Page_Count) AS Avg_Time_Per_Page FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Role ORDER BY Avg_Time_Per_Page;	printer	2
SELECT u.Department, p.Paper_Size, COUNT(*) AS Usage_Count FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID GROUP BY u.Department, p.Paper_Size ORDER BY u.Department, Usage_Count DESC;	printer	3
SELECT 10000000 * 0.05 * 2 AS Total_Ink_ml, ((10000000 * 0.05 * 2) + 499) / 500 AS Replacement_Count;	printer	4
SELECT u.User_ID, u.Name  FROM users u  JOIN print_jobs pj ON u.User_ID = pj.User_ID  JOIN printers pr ON pj.Printer_ID = pr.Printer_ID  WHERE pr.Power_Consumption * 1.2 * SUM(pj.Page_Count) / pr.Print_Speed > pr.Power_Consumption * 10  AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = pr.Printer_ID)  GROUP BY u.User_ID, u.Name  HAVING SUM(pj.Page_Count) > 0;	printer	1
WITH DeptCost AS (     SELECT          u.Department,          SUM(c.Cost / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg      FROM users u      JOIN print_jobs pj ON u.User_ID = pj.User_ID      JOIN consumables c ON pj.Printer_ID = c.Printer_ID      WHERE c.Type IN ('Toner', 'Ink')      GROUP BY u.Department ) SELECT      u.User_ID,      u.Name  FROM users u  JOIN DeptCost dc ON u.Department = dc.Department  WHERE (SELECT c.Cost / c.Capacity FROM consumables c WHERE c.Printer_ID IN (SELECT pj.Printer_ID FROM print_jobs pj WHERE pj.User_ID = u.User_ID) AND c.Type IN ('Toner', 'Ink') LIMIT 1) < dc.DeptAvg  AND NOT EXISTS (     SELECT 1      FROM maintenance_logs ml      JOIN print_jobs pj2 ON ml.Printer_ID = pj2.Printer_ID      WHERE pj2.User_ID = u.User_ID      AND ml.Maintenance_Type = 'Replacement' );	printer	2
SELECT u.User_ID, u.Name  FROM users u  WHERE u.Department IN (     SELECT p.Location      FROM printers p      WHERE p.Tray_Capacity < (SELECT AVG(Tray_Capacity) FROM printers) )  AND NOT EXISTS (     SELECT 1      FROM print_jobs pj      WHERE pj.User_ID = u.User_ID AND pj.Duplex = 1 )  AND NOT EXISTS (     SELECT 1      FROM print_jobs pj2      INNER JOIN printers pr ON pj2.Printer_ID = pr.Printer_ID      INNER JOIN consumables c ON pr.Printer_ID = c.Printer_ID      WHERE pj2.User_ID = u.User_ID      AND c.Last_Replacement_Date IS NOT NULL )  GROUP BY u.User_ID, u.Name  HAVING SUM(pj.Page_Count) > 0;	printer	3
WITH DeptCost AS (     SELECT          u.Department,          SUM(c.Cost * 1.0 / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg      FROM          users u          JOIN print_jobs pj ON u.User_ID = pj.User_ID          JOIN consumables c ON pj.Printer_ID = c.Printer_ID      WHERE          c.Type IN ('Toner', 'Ink')      GROUP BY          u.Department ) SELECT      u.User_ID,      u.Name  FROM      users u      JOIN DeptCost dc ON u.Department = dc.Department      JOIN print_jobs pj ON u.User_ID = pj.User_ID      JOIN consumables c ON pj.Printer_ID = c.Printer_ID  WHERE      (c.Cost * 1.0 / c.Capacity) < dc.DeptAvg      AND c.Current_Level <= 0.1      AND NOT EXISTS (         SELECT 1          FROM maintenance_logs ml          WHERE              ml.Printer_ID = c.Printer_ID              AND ml.Maintenance_Type = 'Replacement'             AND ml.Maintenance_Date <= c.Next_Replacement_Date     );	printer	4
SELECT Printer_ID, Model, (1000.0 / CAST(SUBSTR(Print_Speed, 1, LENGTH(Print_Speed) - 3) AS REAL)) * Power_Consumption / 1000.0 / 60.0 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';	printer	1
SELECT m.Manufacturer_ID, m.Name, ((m.Revenue - (COALESCE(c.TotalConsumableCost,0) + COALESCE(ml.TotalMaintenanceCost,0))) / m.Revenue * 100) AS Profit_Margin_Percent FROM manufacturers m LEFT JOIN (SELECT p.Manufacturer_ID, SUM(c.Cost) AS TotalConsumableCost FROM printers p JOIN consumables c ON p.Printer_ID = c.Printer_ID GROUP BY p.Manufacturer_ID) c ON m.Manufacturer_ID = c.Manufacturer_ID LEFT JOIN (SELECT p.Manufacturer_ID, SUM(ml.Cost) AS TotalMaintenanceCost FROM printers p JOIN maintenance_logs ml ON p.Printer_ID = ml.Printer_ID GROUP BY p.Manufacturer_ID) ml ON m.Manufacturer_ID = ml.Manufacturer_ID;	printer	2
SELECT Printer_ID, Model, (1000.0 / CAST(SUBSTR(Print_Speed, 1, LENGTH(Print_Speed)-3) AS REAL)) * Power_Consumption / 1000.0 / 60.0 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';	printer	3
WITH RECURSIVE YearlyCost(Year, Annual_Cost) AS (     SELECT 1, 1000.0     UNION ALL     SELECT Year + 1, Annual_Cost * 3.0 FROM YearlyCost WHERE Year < 100 ) SELECT Annual_Cost AS Year_100_Cost FROM YearlyCost WHERE Year = 100;	printer	4
SELECT c.Consumable_ID,         (c.Capacity - SUM(pj.Page_Count)) /         (AVG(pj.Page_Count / NULLIF((JULIANDAY((SELECT MAX(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID)) - JULIANDAY((SELECT MIN(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID))), 0)) * (1 + AVG(pj.Duplex)*0.5)) AS Remaining_Days  FROM consumables c  JOIN print_jobs pj ON c.Printer_ID = pj.Printer_ID  WHERE c.Type = 'Drum' AND c.Model = 'X-DrumUltra'  GROUP BY c.Consumable_ID, c.Capacity;	printer	1
WITH RECURSIVE YearlyCost (Year, Annual_Cost) AS (     SELECT 1, 1000.0      UNION ALL      SELECT Year+1, Annual_Cost*3      FROM YearlyCost      WHERE Year < 100 ) SELECT Annual_Cost AS Year_100_Cost  FROM YearlyCost  WHERE Year = 100;	printer	2
SELECT u.Department, (SUM(CASE WHEN pj.Paper_Size = 'A4' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.7 + SUM(CASE WHEN pj.Paper_Size = 'Letter' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.3) AS Predicted_Sheets FROM print_jobs pj JOIN users u ON pj.User_ID = u.User_ID WHERE u.Department = 'Sales' GROUP BY u.Department;	printer	3
SELECT ((5000 * 0.99) - 1e18) / 5000.0 * 100;	printer	4
SELECT 1, SUM(RainfallMm) AS TotalRainfallMm FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59' GROUP BY 1;	RainGauge	1
SELECT 1, AnalysisTime, DataStartTime, DataEndTime, (AverageRainfallIntensityMmH * 1.0 / MaxRainfallIntensityMmH) AS IntensityRatio, AnalysisResult FROM HistoricalRainfallAnalysis WHERE DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59' ORDER BY AnalysisTime;	RainGauge	2
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 2 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN 'extreme weather event' ELSE 'non-extreme weather event' END AS WeatherEventType FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN TotalRainfallMm >= 10000 THEN 'May cause environmental impacts such as flooding and soil erosion' ELSE 'Environmental impact is minimal' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND TotalRainfallMm >= 10000;	RainGauge	4
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (TotalRainfallMm * 1 * 1000 / 1000) AS WaterMassKg FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	1
SELECT t1.GaugeId, t1.CollectionTime AS Time1, t2.CollectionTime AS Time2, t1.RainfallIntensityMmH AS Intensity1, t2.RainfallIntensityMmH AS Intensity2, (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) / (strftime('%s', t2.CollectionTime) - strftime('%s', t1.CollectionTime)) * 3600 AS ChangeRate FROM RainfallData t1 JOIN RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime WHERE t1.GaugeId = 1 AND t1.CollectionTime >= '2023-01-01 00:00:00' AND t2.CollectionTime <= '2023-12-31 23:59:59' ORDER BY t1.CollectionTime;	RainGauge	2
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 3 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN 'May cause flooding' ELSE 'Low flood risk' END AS FloodRisk FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, DataStartTime, DataEndTime, MaxRainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN MaxRainfallIntensityMmH >= 1000 THEN 'May cause environmental impacts such as flooding and soil erosion' ELSE 'Minimal environmental impact' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 2 AND MaxRainfallIntensityMmH >= 1000;	RainGauge	4
SELECT RG.Id, RG.ElevationMeters, 1013.25 * EXP(-RG.ElevationMeters / 8400) AS CalculatedPressure, RD.AtmosphericPressureHpa  FROM RainGauge RG  JOIN RainfallData RD ON RG.Id = RD.GaugeId  WHERE RG.Id = 1;	RainGauge	1
WITH Data AS (SELECT TemperatureCelsius AS X, RainfallMm AS Y FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(X) AS X_avg, AVG(Y) AS Y_avg, SUM((X - X_avg) * (Y - Y_avg)) / SUM((X - X_avg) * (X - X_avg)) AS slope, AVG(Y) - (SUM((X - X_avg) * (Y - Y_avg)) / SUM((X - X_avg) * (X - X_avg))) * AVG(X) AS intercept FROM Data, (SELECT AVG(X) AS X_avg, AVG(Y) AS Y_avg FROM Data)) SELECT slope, intercept, slope * 25 + intercept AS PredictedRainfall FROM Stats;	RainGauge	2
SELECT Id, GaugeModel, ManufactureDate, InstallationDate,         (julianday('now') - julianday(ManufactureDate)) / 365 AS UsageYears,         CASE WHEN (julianday('now') - julianday(ManufactureDate)) / 365 > 10              THEN 'Likely to affect data accuracy due to aging'              ELSE 'Has not reached the age affecting accuracy'         END AS AgingImpact  FROM RainGauge;	RainGauge	3
SELECT Id, GaugeModel, ElevationMeters, 1013.25 * EXP(-10000 / 8400) AS CalculatedPressure, CASE WHEN 1013.25 * EXP(-10000 / 8400) < 300 THEN 'May cause data distortion or equipment failure' ELSE 'Impact is minor' END AS ImpactAnalysis FROM RainGauge WHERE Id = 2;	RainGauge	4
SELECT Id, ElevationMeters, 1013.25 * EXP(-ElevationMeters / 8400) AS AtmosphericPressureHpa FROM RainGauge WHERE Id = 2;	RainGauge	1
WITH RainfallLatitude AS (     SELECT rg.Latitude AS Latitude, rd.RainfallMm AS Rainfall      FROM RainGauge rg      JOIN RainfallData rd ON rg.Id = rd.GaugeId      WHERE rg.Id = 2 AND rd.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' ), Stats AS (     SELECT AVG(Latitude) AS AvgLatitude, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N      FROM RainfallLatitude ), Slope AS (     SELECT SUM((Latitude - AvgLatitude) * (Rainfall - AvgRainfall)) / SUM((Latitude - AvgLatitude) * (Latitude - AvgLatitude)) AS Slope      FROM RainfallLatitude, Stats ), Intercept AS (     SELECT AvgRainfall - Slope * AvgLatitude AS Intercept      FROM Stats, Slope ) SELECT Slope, Intercept  FROM Slope, Intercept;	RainGauge	2
SELECT Id, ElevationMeters, CASE WHEN ElevationMeters >= 0 AND ElevationMeters <= 5000 THEN 'Suitable for installation' ELSE 'Not suitable for installation' END AS InstallationSuitability FROM RainGauge WHERE Id = 2;	RainGauge	3
SELECT GaugeId, CollectionTime, TemperatureCelsius, HumidityPercent, CASE WHEN TemperatureCelsius >= 100 AND HumidityPercent >= 200 THEN 'May cause device sensor damage, data distortion, or complete unavailability' ELSE 'Data collection is normal' END AS ImpactAnalysis FROM RainfallData WHERE TemperatureCelsius >= 100 AND HumidityPercent >= 200;	RainGauge	4
SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, (SUM(RainfallMm) * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	1
WITH RainfallTemperature AS (SELECT TemperatureCelsius AS Temperature, RainfallMm AS Rainfall FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(Temperature) AS AvgTemperature, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N FROM RainfallTemperature), Slope AS (SELECT SUM((Temperature - AvgTemperature) * (Rainfall - AvgRainfall)) / SUM((Temperature - AvgTemperature) * (Temperature - AvgTemperature)) AS Slope FROM RainfallTemperature, Stats), Intercept AS (SELECT AvgRainfall - Slope * AvgTemperature AS Intercept FROM Stats, Slope) SELECT Slope, Intercept FROM Slope, Intercept;	RainGauge	2
SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, CASE WHEN SUM(RainfallMm) > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'Rainfall' AND ConditionOperator = '>' AND IsActive = 1) THEN 'May Cause Flood' ELSE 'Low Flood Risk' END AS FloodRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	3
SELECT GaugeId, CollectionTime, RainfallMm, (10000.0 * 1000.0 * 9.81 / 1000.0) AS PressurePa, CASE WHEN RainfallMm >= 10000 THEN 'May cause environmental impacts such as flooding and soil erosion' ELSE 'Minimal environmental impact' END AS EnvironmentalImpact FROM RainfallData WHERE GaugeId = 2 AND RainfallMm >= 10000;	RainGauge	4
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (RainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
WITH RainfallIntensityChange AS (     SELECT          t1.CollectionTime AS Time1,          t2.CollectionTime AS Time2,          t1.RainfallIntensityMmH AS Intensity1,          t2.RainfallIntensityMmH AS Intensity2,          (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) /          (strftime('%s', t2.CollectionTime) - strftime('%s', t1.CollectionTime)) * 3600 AS ChangeRate      FROM          RainfallData t1      JOIN          RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime      WHERE          t1.GaugeId = 3          AND t1.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' )  SELECT      Time1,      Time2,      Intensity1,      Intensity2,      ChangeRate  FROM      RainfallIntensityChange  ORDER BY      Time1;	RainGauge	2
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, CASE WHEN RainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'rainfall intensity' AND ConditionOperator = '>' AND IsActive = 1) THEN 'may trigger flash flood' ELSE 'low flash flood risk' END AS FloodRisk FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND RainfallIntensityMmH = 1000;	RainGauge	4
SELECT GaugeId, CollectionTime, TemperatureCelsius, (TemperatureCelsius + 273.15) * 287 * 1.225 / 0.02896 AS AtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(TemperatureCelsius) AS AvgTemperature, COUNT(*) AS N FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT GaugeId, CollectionTime, TemperatureCelsius, CASE WHEN TemperatureCelsius >= -20 AND TemperatureCelsius <= 50 THEN 'Normal Operation' ELSE 'May Affect Operation' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, TemperatureCelsius, (73.15 * 287 * 1.225 / 0.02896) AS AtmosphericPressureHpa, CASE WHEN TemperatureCelsius <= -200 THEN 'may cause equipment freezing and data distortion' ELSE 'data collection is normal' END AS ImpactAnalysis FROM RainfallData WHERE GaugeId = 2 AND TemperatureCelsius <= -200;	RainGauge	4
SELECT GaugeId, CollectionTime, HumidityPercent, (HumidityPercent * 0.01 * 23.76) + (AtmosphericPressureHpa - (HumidityPercent * 0.01 * 23.76)) AS AdjustedAtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(HumidityPercent) AS AvgHumidity, MIN(HumidityPercent) AS MinHumidity, MAX(HumidityPercent) AS MaxHumidity FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT GaugeId, CollectionTime, HumidityPercent, CASE WHEN HumidityPercent >= 0 AND HumidityPercent <= 90 THEN 'Normal Operation' ELSE 'Likely to Cause Failure' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, HumidityPercent, AtmosphericPressureHpa, (200 * AtmosphericPressureHpa * 0.01) + (AtmosphericPressureHpa * 0.99) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(WindSpeedMps) AS AvgWindSpeed, MIN(WindSpeedMps) AS MinWindSpeed, MAX(WindSpeedMps) AS MaxWindSpeed FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, WindSpeedMps, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 THEN 'May Cause Equipment Failure' ELSE 'Wind Speed Within Normal Range' END AS FaultRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT CollectionTime, RainfallMm, 100 AS AssumedWindSpeedMps, RainfallMm * (1 + 100 / 10) AS AdjustedRainfallMm, CASE WHEN 100 > 20 THEN 'May cause equipment failure or data distortion' ELSE 'Wind speed within normal range' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, WindDirectionDegrees, RainfallMm * (1 + WindDirectionDegrees / 360.0) AS AdjustedRainfallDistribution FROM RainfallData WHERE GaugeId = 4 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT AVG(WindDirectionDegrees) AS AverageWindDirection, COUNT(*) AS DataPoints FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	2
SELECT GaugeId, CollectionTime, WindDirectionDegrees, CASE WHEN WindDirectionDegrees >= 0 AND WindDirectionDegrees <= 360 THEN 'Normal Operation' ELSE 'May Affect Operation' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, WindDirectionDegrees, RainfallMm, (RainfallMm * (1 + 720 / 360)) AS EstimatedRainfallDistribution, CASE WHEN WindDirectionDegrees = 720 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - AtmosphericPressureHpa) / 1013.25) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(AtmosphericPressureHpa) AS AvgPressure, MIN(AtmosphericPressureHpa) AS MinPressure, MAX(AtmosphericPressureHpa) AS MaxPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'May cause equipment failure' ELSE 'Atmospheric pressure is within normal range' END AS FaultRisk FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT CollectionTime, RainfallMm, 2000 AS AssumedAtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - 2000) / 1013.25) AS AdjustedRainfallMm, CASE WHEN 2000 < 800 OR 2000 > 1100 THEN 'May cause equipment failure or data distortion' ELSE 'Atmospheric pressure within normal range' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, TemperatureCelsius, AtmosphericPressureHpa, TemperatureCelsius * (1 + AtmosphericPressureHpa / 1013.25) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, MAX(AtmosphericPressureHpa) AS MaxPressure, MIN(AtmosphericPressureHpa) AS MinPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'May affect normal equipment operation' ELSE 'Atmospheric pressure within normal range' END AS OperationalImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, AtmosphericPressureHpa, TemperatureCelsius, (TemperatureCelsius * (1 + 3000 / 1013.25)) AS EstimatedTemperature, CASE WHEN AtmosphericPressureHpa = 3000 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT RuleName, ThresholdValue, RainfallMm, (RainfallMm * (1 + ThresholdValue / 100)) AS EstimatedRainfall FROM RainfallWarningRule JOIN RainfallData ON RainfallWarningRule.ParameterType = 'Rainfall' AND RainfallData.RainfallMm > RainfallWarningRule.ThresholdValue WHERE RainfallWarningRule.RuleName = 'Heavy Rainfall Alert';	RainGauge	1
WITH ThresholdData AS (     SELECT ThresholdValue      FROM RainfallWarningRule      WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = 'Rainfall Amount' ),  IntensityData AS (     SELECT RainfallIntensityMmH      FROM RainfallData )  SELECT (     SUM((ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData)) * (RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData))) /      (SQRT(SUM(POWER(ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData), 2)) * SUM(POWER(RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData), 2))) ) AS PearsonCorrelation  FROM ThresholdData, IntensityData;	RainGauge	2
SELECT RuleName, ThresholdValue, CASE WHEN ThresholdValue >= 0 AND ThresholdValue <= 1000 THEN 'Normal Operation' ELSE 'May Cause Equipment Failure' END AS DeviceStatus FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert';	RainGauge	3
SELECT CollectionTime, RainfallMm, 10000 AS AssumedThresholdValue, RainfallMm * (1 + 10000 / 100) AS AdjustedRainfallMm, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = 'Rainfall') THEN 'May cause equipment failure or data distortion' ELSE 'Rainfall threshold within normal range' END AS PotentialImpact FROM RainfallData;	RainGauge	4
SELECT RuleName, TotalRainfallMm, (TotalRainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Low Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(TotalRainfallMm - (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT AnalysisTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Flood Warning' AND ParameterType = 'Rainfall') THEN 'May Trigger Flood' ELSE 'Total Rainfall Within Safe Range' END AS FloodRisk FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, TotalRainfallMm, -1000 AS AssumedTotalRainfallMm, (-1000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Low Rainfall Alert' AND ParameterType = '降雨量') THEN 'May lead to drought or soil cracking' ELSE 'Rainfall within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, AverageRainfallIntensityMmH, (AverageRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Extreme Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(AverageRainfallIntensityMmH - (SELECT AVG(AverageRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT AnalysisTime, AverageRainfallIntensityMmH, CASE WHEN AverageRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May trigger urban waterlogging' ELSE 'Rainfall intensity is within safe range' END AS FloodRisk FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, AverageRainfallIntensityMmH, 1000 AS AssumedRainfallIntensity, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 1000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May cause flooding or soil erosion' ELSE 'Rainfall intensity is within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, MaxRainfallIntensityMmH, (MaxRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Light Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(MaxRainfallIntensityMmH - (SELECT AVG(MaxRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT AnalysisTime, MaxRainfallIntensityMmH, CASE WHEN MaxRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = 'rainfall intensity') THEN 'may affect outdoor activities' ELSE 'rainfall intensity within safe range' END AS OutdoorActivityImpact FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, MaxRainfallIntensityMmH, 10000 AS AssumedMaxRainfallIntensity, (10000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May cause flooding or soil erosion' ELSE 'Rainfall intensity is within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, MinRainfallIntensityMmH, (MinRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Moderate Rainfall Intensity Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(MinRainfallIntensityMmH - (SELECT AVG(MinRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT HRA.AnalysisResult FROM HistoricalRainfallAnalysis HRA JOIN RainfallWarningRule RWR ON HRA.GaugeId = RWR.Id WHERE RWR.RuleName = 'Moderate Rainfall Intensity Alert' AND HRA.MinRainfallIntensityMmH < 5;	RainGauge	3
SELECT AnalysisTime, MinRainfallIntensityMmH, -1000 AS AssumedMinRainfallIntensity, (-1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Moderate Rainfall Intensity Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May lead to drought or soil cracking' ELSE 'Rainfall intensity within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT CollectionTime, RainfallMm, (RainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData;	RainGauge	1
WITH RainfallStats AS (SELECT RainfallMm AS X, RainfallIntensityMmH AS Y, AVG(RainfallMm) OVER () AS X_avg, AVG(RainfallIntensityMmH) OVER () AS Y_avg FROM RainfallData) SELECT (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM((X - X_avg) * (X - X_avg)) * SQRT(SUM((Y - Y_avg) * (Y - Y_avg))))) AS PearsonCorrelation FROM RainfallStats;	RainGauge	2
SELECT CollectionTime, RainfallMm, CASE WHEN RainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'Rainfall' AND RuleName = 'Flood Warning') THEN 'Likely to cause flooding' ELSE 'Lower flood risk' END AS FloodRisk FROM RainfallData;	RainGauge	3
SELECT CollectionTime, RainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'precipitation' AND ConditionOperator = '>' AND IsActive = 1) THEN 'may cause flooding or soil erosion' ELSE 'rainfall within normal range' END AS EnvironmentalImpact FROM RainfallData WHERE RainfallMm >= 10000;	RainGauge	4
SELECT CollectionTime, HumidityPercent, AtmosphericPressureHpa, (HumidityPercent * 0.01 * AtmosphericPressureHpa) + ((1 - HumidityPercent * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa FROM RainfallData;	RainGauge	1
WITH HumidityWindStats AS (     SELECT          HumidityPercent AS X,          WindSpeedMps AS Y,          AVG(HumidityPercent) OVER () AS X_avg,          AVG(WindSpeedMps) OVER () AS Y_avg      FROM RainfallData ) SELECT      (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM((X - X_avg) * (X - X_avg)) * SUM((Y - Y_avg) * (Y - Y_avg))))) AS PearsonCorrelation  FROM HumidityWindStats;	RainGauge	2
SELECT GaugeId, CollectionTime, HumidityPercent, WindSpeedMps, CASE WHEN HumidityPercent > 90 OR WindSpeedMps > 20 THEN 'May trigger equipment failure' ELSE 'Equipment operating normally' END AS FaultRisk FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, WindSpeedMps, AtmosphericPressureHpa, (200 * 0.01 * AtmosphericPressureHpa) + ((1 - 200 * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 OR WindSpeedMps = 100 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData;	RainGauge	4
SELECT RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfall FROM RainfallData WHERE GaugeId = 'Specific Rainfall Gauge ID';	RainGauge	1
WITH WindSpeedStats AS (   SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints    FROM RainfallData ),  WindSpeedTrend AS (   SELECT CollectionTime, WindSpeedMps,          AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg    FROM RainfallData ) SELECT AvgWindSpeed, MovingAvg  FROM WindSpeedStats, WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, WindSpeedMps, WindDirectionDegrees, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN 'Likely to cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, RainfallMm, (RainfallMm * (1 + 100 / 10)) AS AdjustedRainfallMm, CASE WHEN WindSpeedMps >= 100 OR WindDirectionDegrees >= 720 THEN 'May cause equipment damage or data distortion' ELSE 'Wind speed and direction within normal range' END AS DataImpact FROM RainfallData WHERE WindSpeedMps >= 100 OR WindDirectionDegrees >= 720;	RainGauge	4
SELECT WindDirectionDegrees, AtmosphericPressureHpa, AtmosphericPressureHpa * (1 + WindDirectionDegrees / 360.0) AS AdjustedPressure FROM RainfallData WHERE GaugeId = 'Specific Rainfall Gauge ID';	RainGauge	1
WITH WindDirectionStats AS (     SELECT AVG(WindDirectionDegrees) AS AvgWindDirection, COUNT(*) AS DataPoints      FROM RainfallData ),  WindDirectionTrend AS (     SELECT CollectionTime, WindDirectionDegrees,             AVG(WindDirectionDegrees) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgWindDirection, MovingAvg  FROM WindDirectionStats, WindDirectionTrend;	RainGauge	2
SELECT CollectionTime, WindDirectionDegrees, AtmosphericPressureHpa, CASE WHEN WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'May cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa * (1 + 720.0 / 360.0)) AS AdjustedAtmosphericPressureHpa, CASE WHEN WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000 THEN 'may cause equipment damage or data distortion' ELSE 'wind direction and atmospheric pressure within normal range' END AS DataImpact FROM RainfallData WHERE WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000;	RainGauge	4
SELECT RainfallMm, TemperatureCelsius, TemperatureCelsius - (RainfallMm / 10) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH RainfallStats AS (     SELECT AVG(RainfallMm) AS AvgRainfall, COUNT(*) AS DataPoints      FROM RainfallData ),  RainfallTrend AS (     SELECT CollectionTime, RainfallMm,      AVG(RainfallMm) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgRainfall, MovingAvg  FROM RainfallStats, RainfallTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, TemperatureCelsius, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR TemperatureCelsius < -20 OR TemperatureCelsius > 50 THEN 'Likely to cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, TemperatureCelsius, (TemperatureCelsius - (10000 / 10)) AS AdjustedTemperatureCelsius, CASE WHEN RainfallMm >= 10000 OR TemperatureCelsius >= 1000 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and temperature within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR TemperatureCelsius >= 1000;	RainGauge	4
SELECT RainfallMm, HumidityPercent, HumidityPercent + (RainfallMm / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH HumidityStats AS (     SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints      FROM RainfallData ),  HumidityTrend AS (     SELECT CollectionTime, HumidityPercent,             AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgHumidity, MovingAvg  FROM HumidityStats, HumidityTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, HumidityPercent, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN 'May trigger equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, (HumidityPercent + (10000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallMm >= 10000 OR HumidityPercent >= 200 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and humidity within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR HumidityPercent >= 200;	RainGauge	4
SELECT RainfallMm, WindSpeedMps, WindSpeedMps + (RainfallMm / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH WindSpeedStats AS (   SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints    FROM RainfallData ),  WindSpeedTrend AS (   SELECT CollectionTime, WindSpeedMps,           AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg    FROM RainfallData )  SELECT AvgWindSpeed, MovingAvg  FROM WindSpeedStats, WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, WindSpeedMps, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN 'May cause equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (10000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallMm >= 10000 OR WindSpeedMps >= 100 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and wind speed within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindSpeedMps >= 100;	RainGauge	4
SELECT RainfallMm, WindDirectionDegrees, WindDirectionDegrees + (RainfallMm / 10) AS AdjustedWindDirection FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH RainfallTotal AS (   SELECT SUM(RainfallMm) AS TotalRainfall    FROM RainfallData ),  RainfallTrend AS (   SELECT      CollectionTime,      RainfallMm,      SUM(RainfallMm) OVER (ORDER BY CollectionTime ROWS UNBOUNDED PRECEDING) AS CumulativeRainfall    FROM RainfallData )  SELECT TotalRainfall, CumulativeRainfall  FROM RainfallTotal, RainfallTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, WindDirectionDegrees, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN 'May trigger equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindDirectionDegrees, (WindDirectionDegrees + (10000 / 10)) AS AdjustedWindDirectionDegrees, CASE WHEN RainfallMm >= 10000 OR WindDirectionDegrees >= 720 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and wind direction within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindDirectionDegrees >= 720;	RainGauge	4
SELECT RainfallMm, AtmosphericPressureHpa, AtmosphericPressureHpa - (RainfallMm / 10) AS AdjustedPressure FROM RainfallData WHERE GaugeId = 'specific rain gauge ID';	RainGauge	1
WITH PressureStats AS (     SELECT AVG(AtmosphericPressureHpa) AS AvgPressure, COUNT(*) AS DataPoints      FROM RainfallData ),  PressureTrend AS (     SELECT CollectionTime, AtmosphericPressureHpa,             AVG(AtmosphericPressureHpa) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgPressure, MovingAvg  FROM PressureStats, PressureTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'Likely to cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa - (10000.0 / 10.0)) AS AdjustedAtmosphericPressureHpa, CASE WHEN RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and atmospheric pressure within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000;	RainGauge	4
SELECT RainfallIntensityMmH, HumidityPercent, HumidityPercent + (RainfallIntensityMmH / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '2';	RainGauge	1
WITH HumidityStats AS (     SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints      FROM RainfallData ),  HumidityTrend AS (     SELECT CollectionTime, HumidityPercent,             AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgHumidity, MovingAvg  FROM HumidityStats, HumidityTrend;	RainGauge	2
SELECT CollectionTime, RainfallIntensityMmH, HumidityPercent, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN 'May trigger equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, (HumidityPercent + (1000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall intensity and humidity within normal range' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200;	RainGauge	4
SELECT RainfallIntensityMmH, WindSpeedMps, WindSpeedMps + (RainfallIntensityMmH / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '2';	RainGauge	1
WITH WindSpeedStats AS          (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints           FROM RainfallData),      WindSpeedTrend AS          (SELECT CollectionTime,                  WindSpeedMps,                  AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg           FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats,      WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, RainfallIntensityMmH, WindSpeedMps, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN 'May cause equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (1000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall intensity and wind speed within normal range' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100;	RainGauge	4
SELECT RainfallMm, RainfallIntensityMmH, ThresholdValue FROM RainfallData JOIN RainfallWarningRule ON RainfallData.GaugeId = '3' AND RainfallWarningRule.ParameterType = 'Rainfall' WHERE RainfallMm > ThresholdValue AND RainfallIntensityMmH = 100;	RainGauge	1
WITH RainfallData AS (     SELECT 50 AS RainfallMm     UNION ALL SELECT 60     UNION ALL SELECT 70     UNION ALL SELECT 80     UNION ALL SELECT 90 ) SELECT AVG(RainfallMm) AS AvgRainfallIntensity, SUM(RainfallMm) AS TotalRainfall FROM RainfallData;	RainGauge	2
SELECT InstallationLocation, ElevationMeters, (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) AS AvgAnnualRainfall, CASE WHEN ElevationMeters = 1000 AND (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) >= 1500 THEN 'Suitable for long-term monitoring' ELSE 'Not suitable for long-term monitoring' END AS Suitability FROM RainGauge WHERE ElevationMeters = 1000;	RainGauge	3
SELECT RuleName, ThresholdValue, CASE WHEN 1000 > ThresholdValue THEN 'Threshold cannot effectively determine, need to adjust warning rules' ELSE 'Threshold can still effectively determine' END AS WarningEffectiveness FROM RainfallWarningRule WHERE ParameterType = 'Rainfall intensity' AND IsActive = 1;	RainGauge	4
SELECT id, model, brand, power_rating, voltage_rating, (power_rating / voltage_rating) AS current_strength FROM rice_cooker_info;	rice_cooker	1
WITH avg_energy_consumption AS (     SELECT rice_cooker_id, AVG(energy_consumption) AS avg_energy      FROM performance_tests      GROUP BY rice_cooker_id )  SELECT rci.model, aec.avg_energy  FROM rice_cooker_info rci  JOIN avg_energy_consumption aec ON rci.id = aec.rice_cooker_id  ORDER BY aec.avg_energy ASC  LIMIT 1;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, rci.capacity, ur.rice_quantity, ur.water_quantity, (ur.rice_quantity + ur.water_quantity) AS total_quantity, CASE WHEN (ur.rice_quantity + ur.water_quantity) <= rci.capacity THEN 'No' ELSE 'Yes' END AS exceeded_capacity FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	3
SELECT model, (10 * power_rating * 24) / 1000000 AS daily_energy_mwh FROM rice_cooker_info WHERE (10 * power_rating * 24) / 1000000 > 1;	rice_cooker	4
WITH energy_efficiency AS (     SELECT          rci.model,          pt.time_to_boil,          (pt.water_evaporation_rate / 100.0 * 1.5) AS water_quantity,          ((pt.water_evaporation_rate / 100.0 * 1.5 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000.0) / (rci.power_rating * pt.time_to_boil / 60.0)) * 100.0 AS efficiency      FROM          performance_tests pt      JOIN          rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE          pt.test_type = 'Boiling' )  SELECT      model,      efficiency  FROM      energy_efficiency  WHERE      efficiency < 60.0      AND time_to_boil > 15  ORDER BY      efficiency ASC;	rice_cooker	1
WITH usage_counts AS (     SELECT rice_cooker_id, COUNT(id) AS total_usage      FROM usage_records      GROUP BY rice_cooker_id ),  maintenance_costs AS (     SELECT rice_cooker_id, SUM(maintenance_cost) AS total_cost      FROM maintenance_records      GROUP BY rice_cooker_id ),  cost_benefit AS (     SELECT          rci.model,          uc.total_usage,          mc.total_cost,          CASE WHEN mc.total_cost = 0 THEN NULL ELSE CAST(uc.total_usage AS REAL) / mc.total_cost END AS cost_benefit_ratio      FROM rice_cooker_info rci      JOIN usage_counts uc ON rci.id = uc.rice_cooker_id      JOIN maintenance_costs mc ON rci.id = mc.rice_cooker_id ),  percentile_rank AS (     SELECT          *,          CAST((SELECT COUNT(*) FROM cost_benefit cb2 WHERE cb2.cost_benefit_ratio >= cb1.cost_benefit_ratio) * 100.0 / (SELECT COUNT(*) FROM cost_benefit) AS INTEGER) AS percentile_rank      FROM cost_benefit cb1 ) SELECT model, total_usage, total_cost, cost_benefit_ratio  FROM percentile_rank  WHERE percentile_rank <= 50;	rice_cooker	2
WITH defect_models AS (     SELECT rice_cooker_id      FROM performance_tests      WHERE final_temperature < 0.9 * 100      AND rice_quality_score < 8      GROUP BY rice_cooker_id      HAVING COUNT(*) >= 3 ),  repaired_models AS (     SELECT DISTINCT rice_cooker_id      FROM maintenance_records      WHERE maintenance_type = 'Repair' )  SELECT rci.model  FROM defect_models dm  JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id  WHERE dm.rice_cooker_id NOT IN (     SELECT rice_cooker_id      FROM repaired_models );	rice_cooker	3
SELECT model, power_rating, CASE WHEN power_rating > (50 * 0.12 * 150) THEN (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 ELSE NULL END AS boil_time_hours FROM rice_cooker_info WHERE (power_rating - (50 * 0.12 * 150)) > 0 AND (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 > 24;	rice_cooker	4
SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;	rice_cooker	1
SELECT brand, ROUND((total_incidents * 5.0 / observation_years / 100 * 100), 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;	rice_cooker	2
WITH defect_models AS (     SELECT pt.rice_cooker_id     FROM performance_tests pt     WHERE pt.water_evaporation_rate > 15 AND pt.rice_quality_score < 8 ) SELECT      rci.model,      rci.production_date,      CASE          WHEN date(rci.production_date, '+' || rci.warranty_period || ' months') > '2023-12-01' THEN 'In Warranty'          ELSE 'Out of Warranty'      END AS warranty_status FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;	rice_cooker	4
SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;	rice_cooker	1
SELECT brand, ROUND((total_incidents * 5.0 / observation_years) * 100.0, 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;	rice_cooker	2
WITH defect_models AS (     SELECT pt.rice_cooker_id      FROM performance_tests pt      WHERE pt.water_evaporation_rate > 15      AND pt.rice_quality_score < 8 )  SELECT rci.model, rci.production_date,         CASE             WHEN date(rci.production_date, '+' || rci.warranty_period || ' months') > '2023-12-01'             THEN 'In Warranty'             ELSE 'Out of Warranty'         END AS warranty_status  FROM defect_models dm  JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;	rice_cooker	4
WITH heat_efficiency AS (     SELECT          rci.model,          2 AS water_quantity,          pt.final_temperature,          pt.initial_temperature,          pt.energy_consumption,          pt.water_evaporation_rate,          (2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption * 100 AS efficiency      FROM performance_tests pt      JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE pt.test_type = 'Boiling' ) SELECT model, efficiency  FROM heat_efficiency  WHERE efficiency < 65 AND water_evaporation_rate > 10  ORDER BY efficiency ASC;	rice_cooker	1
WITH maintenance_summary AS (     SELECT          rci.id,          rci.model,          rci.production_date,          SUM(mr.maintenance_cost) AS total_cost,          MAX(mr.maintenance_date) AS last_maintenance_date      FROM rice_cooker_info rci      JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id      GROUP BY rci.id, rci.model, rci.production_date      HAVING last_maintenance_date IS NOT NULL ) SELECT      model,      total_cost,      ROUND((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0, 1) AS service_months,      ROUND(total_cost / ((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0), 2) AS cost_rate  FROM maintenance_summary  WHERE ((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0) > 12      AND (total_cost / ((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0)) > 5  ORDER BY cost_rate DESC  LIMIT 3;	rice_cooker	2
WITH qualified_models AS (     SELECT rci.id, rci.brand, rci.model      FROM rice_cooker_info rci      WHERE rci.capacity < 4      AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.rice_quantity >= 1.5)      AND NOT EXISTS (SELECT 1 FROM usage_records ur2 WHERE ur2.rice_cooker_id = rci.id AND ur2.rice_quantity >= 1.5 AND ur2.water_quantity < 2.25) ) SELECT qm.brand, qm.model, MAX(ur.end_time) AS last_usage_date  FROM qualified_models qm  JOIN usage_records ur ON qm.id = ur.rice_cooker_id  GROUP BY qm.brand, qm.model;	rice_cooker	3
SELECT (2 * (4186 * (100 - 20) + 2260000)) / (0.5 * 700 * 0.1) AS total_seconds, ROUND((2 * (4186 * 80 + 2260000)) / (0.5 * 700 * 0.1) / 3600.0, 1) AS hours;	rice_cooker	4
WITH efficiency_calc AS (     SELECT          rci.model,          pt.initial_temperature,          pt.energy_consumption,          pt.time_to_boil,          pt.water_evaporation_rate,          (2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) AS eta_max,          pt.energy_consumption AS eta_real,          ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) - pt.energy_consumption) / ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000)) * 100 AS deviation      FROM          performance_tests pt      JOIN          rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE          pt.test_type = 'Boiling' ) SELECT      model,      deviation,      water_evaporation_rate  FROM      efficiency_calc  WHERE      deviation > 15      AND water_evaporation_rate > 12  ORDER BY      deviation DESC;	rice_cooker	1
WITH model_maintenance AS (   SELECT rci.brand, rci.model, COUNT(*) AS maintenance_count    FROM maintenance_records mr    JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id    GROUP BY rci.brand, rci.model ),  brand_recurrence AS (   SELECT brand,           CAST(SUM(CASE WHEN maintenance_count > 1 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS recurrence_rate,           SUM(maintenance_count) AS total_maintenance    FROM model_maintenance    GROUP BY brand    HAVING SUM(maintenance_count) >= 2 )  SELECT brand,         ROUND(recurrence_rate * 100, 2) AS recurrence_rate_percent,         total_maintenance  FROM brand_recurrence  WHERE recurrence_rate > 0.3  ORDER BY recurrence_rate DESC  LIMIT 3;	rice_cooker	2
WITH qualified_models AS (     SELECT rci.id, rci.model      FROM rice_cooker_info rci      WHERE rci.capacity >= 5      AND EXISTS (         SELECT 1          FROM usage_records ur          WHERE ur.rice_cooker_id = rci.id          AND ur.rice_quantity < 0.5     ) ), recent_scores AS (     SELECT qm.model, pt.rice_quality_score,             ROW_NUMBER() OVER (PARTITION BY qm.id ORDER BY pt.test_date DESC) AS rn      FROM qualified_models qm      JOIN performance_tests pt ON qm.id = pt.rice_cooker_id ) SELECT model, ROUND(AVG(rice_quality_score), 2) AS avg_rice_quality  FROM recent_scores  WHERE rn <= 3  GROUP BY model;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 0.08 * 0.2 * POWER(280 - 2, 4) AS max_heat_loss), boil_time_calc AS (SELECT (3 * 4186 * (280 - 5)) / (1.5 * 900 - (SELECT max_heat_loss FROM heat_loss_calc)) / 3600 AS boil_time_hours) SELECT boil_time_hours FROM boil_time_calc;	rice_cooker	4
WITH efficiency_calc AS (     SELECT          rci.model,          pt.final_temperature,          pt.initial_temperature,          pt.energy_consumption,          pt.water_evaporation_rate,          (2.0 * 4186.0 * (pt.final_temperature - pt.initial_temperature) / 3600000.0) / pt.energy_consumption AS eta_actual,          1.0 - (298.15 / (pt.final_temperature + 273.15)) AS eta_theoretical,          (((2.0 * 4186.0 * (pt.final_temperature - pt.initial_temperature) / 3600000.0) / pt.energy_consumption) - (1.0 - (298.15 / (pt.final_temperature + 273.15)))) * 100.0 AS efficiency_diff      FROM          performance_tests pt      JOIN          rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE          pt.test_type = 'Boiling' )  SELECT      model,      efficiency_diff,      water_evaporation_rate  FROM      efficiency_calc  WHERE      efficiency_diff > 10.0      AND water_evaporation_rate > 8.0  ORDER BY      efficiency_diff DESC;	rice_cooker	1
WITH cost_benefit AS (     SELECT          rci.model,          SUM(ur.rice_quantity) AS total_rice,          SUM(pt.energy_consumption) AS total_energy,          COUNT(*) AS usage_count,          SUM(ur.rice_quantity) / SUM(pt.energy_consumption) AS benefit_ratio      FROM usage_records ur      JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id      JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id      GROUP BY rci.model      HAVING COUNT(*) > 5 )  SELECT model, ROUND(benefit_ratio, 2) AS benefit_ratio  FROM cost_benefit  WHERE benefit_ratio < 0.8  ORDER BY benefit_ratio ASC  LIMIT 2;	rice_cooker	2
WITH repaired_in_warranty AS (     SELECT          rci.id,          rci.model,          mr.technician_name,          date(rci.production_date, '+' || rci.warranty_period || ' months') AS warranty_end_date,          mr.maintenance_date      FROM          maintenance_records mr      JOIN          rice_cooker_info rci ON mr.rice_cooker_id = rci.id      WHERE          mr.maintenance_type = 'Repair'          AND mr.maintenance_date <= date(rci.production_date, '+' || rci.warranty_period || ' months') ),  last_usage AS (     SELECT          ur.rice_cooker_id,          MAX(ur.end_time) AS last_usage_date      FROM          usage_records ur      GROUP BY          ur.rice_cooker_id )  SELECT      riw.model,      riw.technician_name,      lu.last_usage_date  FROM      repaired_in_warranty riw  JOIN      last_usage lu ON riw.id = lu.rice_cooker_id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 0.2 * 0.3 AS heat_loss_coeff),  boil_time_calc AS (SELECT (5 * (4186 * (500 - 300) + 2260000 * (1 + 400/500))) / (5 * 800 - (SELECT heat_loss_coeff * (POWER(500,4) - POWER(300,4)) FROM heat_loss_calc)) / 3600 AS boil_time_hours)  SELECT boil_time_hours FROM boil_time_calc;	rice_cooker	4
SELECT rci.model,         ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 AS thermal_efficiency  FROM performance_tests pt  JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id  JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id AND date(pt.test_date) = date(ur.start_time)  WHERE pt.test_type = 'Boiling'  AND pt.time_to_boil > 18  AND ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 < 50  ORDER BY thermal_efficiency ASC;	rice_cooker	1
SELECT rci.brand,         (JULIANDAY(MAX(ur.end_time)) - JULIANDAY(MIN(rci.production_date))) / 30 AS total_service_months,         COUNT(DISTINCT mr.maintenance_date) AS total_faults,         ((JULIANDAY(MAX(ur.end_time)) - JULIANDAY(MIN(rci.production_date))) / 30) / COUNT(DISTINCT mr.maintenance_date) AS fault_interval  FROM rice_cooker_info rci  LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id  LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id  GROUP BY rci.brand  HAVING total_faults > 0  ORDER BY fault_interval ASC  LIMIT 3;	rice_cooker	2
SELECT rci.model, COUNT(mr.id) AS maintenance_count,         (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id = rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_maintenance_type  FROM rice_cooker_info rci  LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id  WHERE rci.capacity > 4    AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.water_quantity < 1)  GROUP BY rci.id;	rice_cooker	3
WITH RECURSIVE heating_time AS (     SELECT 300 AS start_temp,             300 + 50 AS end_temp,             CAST(0.0 AS REAL) AS elapsed_time      UNION ALL      SELECT end_temp,             MIN(end_temp + CASE WHEN end_temp < 4000 THEN 50 WHEN end_temp < 4900 THEN 10 ELSE 1 END, 5000),             CAST(elapsed_time AS REAL) + CAST( (10 * 4186 * (end_temp - start_temp)) / MAX(7000 - 10 * POWER((start_temp + end_temp)/2 - 5000, 3), 1) AS REAL)      FROM heating_time      WHERE end_temp < 5000  )  SELECT MAX(elapsed_time) AS total_seconds  FROM heating_time;	rice_cooker	4
SELECT rci.model, ROUND(((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature)) / (pt.time_to_boil * 60 * rci.power_rating)) * 100, 2) AS efficiency_rate FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE (ur.temperature_setting - ur.actual_max_temperature) > 5 GROUP BY rci.model HAVING efficiency_rate < 40 ORDER BY efficiency_rate ASC;	rice_cooker	1
SELECT rci.brand, ROUND(SUM(COALESCE(pt.energy_consumption,0)+COALESCE(ur.energy_consumption,0))*0.6/MAX(JULIANDAY(MAX(ur.end_time))-JULIANDAY(MIN(ur.start_time)),1),2) AS daily_cost FROM rice_cooker_info rci LEFT JOIN performance_tests pt ON rci.id=pt.rice_cooker_id LEFT JOIN usage_records ur ON rci.id=ur.rice_cooker_id GROUP BY rci.brand HAVING daily_cost>2 AND MAX(JULIANDAY(ur.end_time))-JULIANDAY(MIN(ur.start_time))>30 ORDER BY daily_cost DESC LIMIT 2;	rice_cooker	2
SELECT rci.model,         (SELECT MAX(maintenance_date) FROM maintenance_records WHERE rice_cooker_id=rci.id) AS last_date,         (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id=rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_type  FROM rice_cooker_info rci  WHERE warranty_period > 18  AND (julianday('now') - julianday(production_date)) / 365.25 > 3  AND EXISTS (SELECT 1 FROM maintenance_records WHERE rice_cooker_id=rci.id);	rice_cooker	3
WITH RECURSIVE heating_sim(current_temp, elapsed_time) AS (     SELECT -273.0, 0.0     UNION ALL     SELECT          MIN(current_temp + CASE              WHEN current_temp < -173 THEN 10              WHEN current_temp < 0 THEN 1              ELSE 0.1          END, 100.0),         elapsed_time + (10 * 4186 * CASE              WHEN current_temp < -173 THEN 10              WHEN current_temp < 0 THEN 1              ELSE 0.1          END) / MAX(2700 - 0.5 * (current_temp + 273.0) * (current_temp + 273.0) * (current_temp + 273.0) * (current_temp + 273.0), 1)     FROM heating_sim      WHERE current_temp < 100 )  SELECT      MAX(elapsed_time) AS total_seconds,      MAX(elapsed_time) / 3600.0 AS total_hours  FROM heating_sim;	rice_cooker	4
SELECT ur.rice_cooker_id, rci.model, ur.rice_quantity, ur.water_quantity, ur.energy_consumption AS E_actual, (ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600 AS E_theory, ((ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600) / ur.energy_consumption * 100 AS efficiency_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	1
WITH RECURSIVE heating_sim AS (     SELECT -273.0 AS current_temp, 0.0 AS elapsed_time     UNION ALL     SELECT MIN(current_temp + CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END, 100),             elapsed_time + (10*4186*(CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END)) / MAX(2700 - 0.5*POWER((current_temp + 273),4), 1)     FROM heating_sim     WHERE current_temp < 100 ) SELECT MAX(elapsed_time) AS total_seconds, MAX(elapsed_time)/3600 AS total_hours FROM heating_sim;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.temperature_setting, ur.actual_max_temperature, ABS(ur.actual_max_temperature - ur.temperature_setting) AS temperature_deviation, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Heating%') THEN 'Heating element replaced' ELSE 'Heating element not replaced' END AS heating_element_status FROM usage_records ur WHERE ABS(ur.actual_max_temperature - ur.temperature_setting) > 5;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.time_to_boil * (373.0 / 344.0) AS mount_everest_time, (pt.time_to_boil * (373.0 / 344.0)) / pt.time_to_boil - 1.0 AS time_increase_ratio, pt.energy_consumption * (373.0 / 344.0 - 1.0) AS energy_loss FROM performance_tests pt	rice_cooker	4
SELECT rci.id AS rice_cooker_id, rci.model, rci.material, rci.power_rating, ur.temperature_setting, ur.actual_max_temperature, CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END AS k, (CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002 AS ΔQ, ((CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002) / rci.power_rating * 100 AS heat_loss_rate_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	1
WITH MaintenanceAnalysis AS (     SELECT          rci.model,          strftime('%Y', mr.maintenance_date) AS year,          rci.warranty_period,          AVG(pt.rice_quality_score) AS avg_quality_score,          SUM(mr.maintenance_cost) AS total_maintenance_cost,          COUNT(ur.id) AS usage_count      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id      LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id      LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id      GROUP BY rci.model, strftime('%Y', mr.maintenance_date), rci.warranty_period ) SELECT      model,      year,      (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) AS cost_benefit_ratio,      RANK() OVER (PARTITION BY year ORDER BY (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) DESC) AS annual_rank  FROM MaintenanceAnalysis;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.energy_consumption, ur.rice_quantity, ur.energy_consumption / ur.rice_quantity AS energy_per_kg, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN 'Rice quality below average' ELSE 'Rice quality normal' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.energy_consumption / ur.rice_quantity > 0.8;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.time_to_boil AS earth_time,         SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) AS v_earth,         SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) AS v_space,         pt.time_to_boil * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01))) AS space_time,         (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) * 100 AS time_increase_percent,         pt.energy_consumption * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) AS energy_loss  FROM performance_tests pt;	rice_cooker	4
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373.0 / 363.0 - 1) AS energy_increase, (373.0 / 363.0 - 1) * 100.0 AS efficiency_loss_percent FROM performance_tests pt;	rice_cooker	1
WITH MaintenanceAnalysis AS (     SELECT          rci.brand,          CAST(strftime('%m', mr.maintenance_date) AS INTEGER) / 3 + 1 AS quarter,          CAST(COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) AS REAL) / COUNT(*) AS failure_rate,          SUM(mr.maintenance_cost) / COUNT(*) AS avg_maintenance_cost      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id      GROUP BY rci.brand, quarter ), CorrelationCalculation AS (     SELECT          brand,          quarter,          failure_rate,          avg_maintenance_cost,          AVG(failure_rate) OVER(PARTITION BY brand) AS mean_failure_rate,          AVG(avg_maintenance_cost) OVER(PARTITION BY brand) AS mean_avg_maintenance_cost,          (failure_rate - AVG(failure_rate) OVER(PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand)) AS covariance_term,          POWER(failure_rate - AVG(failure_rate) OVER(PARTITION BY brand), 2) AS variance_failure_rate,          POWER(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand), 2) AS variance_avg_maintenance_cost      FROM MaintenanceAnalysis ) SELECT      brand,      quarter,      failure_rate,      avg_maintenance_cost,      SUM(covariance_term) OVER(PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER(PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER(PARTITION BY brand))) AS correlation_coefficient  FROM CorrelationCalculation  GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN 'Rice quality below average' ELSE 'Rice quality normal' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt;	rice_cooker	4
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373.0 / 363.0 - 1) AS energy_increase, (373.0 / 363.0 - 1) * 100 AS efficiency_loss_percent FROM performance_tests pt;	rice_cooker	1
WITH MaintenanceAnalysis AS (     SELECT          rci.brand,          CAST((STRFTIME('%m', mr.maintenance_date) + 2) / 3 AS INTEGER) AS quarter,          CAST(COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) AS REAL) / COUNT(*) AS failure_rate,          CAST(SUM(mr.maintenance_cost) AS REAL) / COUNT(*) AS avg_maintenance_cost      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id      GROUP BY rci.brand, quarter ), CorrelationCalculation AS (     SELECT          brand,          quarter,          failure_rate,          avg_maintenance_cost,          AVG(failure_rate) OVER (PARTITION BY brand) AS mean_failure_rate,          AVG(avg_maintenance_cost) OVER (PARTITION BY brand) AS mean_avg_maintenance_cost,          (failure_rate - AVG(failure_rate) OVER (PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER (PARTITION BY brand)) AS covariance_term,          POW(failure_rate - AVG(failure_rate) OVER (PARTITION BY brand), 2) AS variance_failure_rate,          POW(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER (PARTITION BY brand), 2) AS variance_avg_maintenance_cost      FROM MaintenanceAnalysis ) SELECT      brand,      quarter,      failure_rate,      avg_maintenance_cost,      SUM(covariance_term) OVER (PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER (PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER (PARTITION BY brand))) AS correlation_coefficient  FROM CorrelationCalculation  GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN 'Rice quality below average' ELSE 'Rice quality normal' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt;	rice_cooker	4
SELECT rci.id AS rice_cooker_id, rci.model, rci.material, pt.final_temperature, CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END AS thermal_stress, CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END AS tensile_strength, CASE WHEN CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END < CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END THEN 'Safe' ELSE 'Unsafe' END AS safety_status FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id;	rice_cooker	1
WITH LifecycleCost AS (     SELECT          rci.brand,          rci.price + SUM(mr.maintenance_cost) AS total_cost,          COUNT(ur.id) AS usage_count,          AVG(pt.rice_quality_score) AS avg_quality_score      FROM rice_cooker_info rci      LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id      LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id      LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id      GROUP BY rci.brand, rci.price ), MinMax AS (     SELECT          MIN(total_cost / POWER(usage_count * avg_quality_score, 0.5)) AS min_cost,         MAX(total_cost / POWER(usage_count * avg_quality_score, 0.5)) AS max_cost     FROM LifecycleCost ), NormalizedCost AS (     SELECT          brand,          total_cost / POWER(usage_count * avg_quality_score, 0.5) AS lifecycle_cost,         (total_cost / POWER(usage_count * avg_quality_score, 0.5) - (SELECT min_cost FROM MinMax)) /          ((SELECT max_cost FROM MinMax) - (SELECT min_cost FROM MinMax)) AS normalized_cost     FROM LifecycleCost ) SELECT      brand,      lifecycle_cost,      normalized_cost,     (SELECT COUNT(DISTINCT nc2.normalized_cost) FROM NormalizedCost nc2 WHERE nc2.normalized_cost <= nc.normalized_cost) AS brand_rank FROM NormalizedCost nc ORDER BY normalized_cost;	rice_cooker	2
WITH CleaningAnalysis AS (     SELECT          mr.rice_cooker_id,          mr.maintenance_date,          mr.maintenance_notes,          rci.material,          CAST(julianday(mr.maintenance_date) - julianday(LAG(mr.maintenance_date) OVER (PARTITION BY mr.rice_cooker_id ORDER BY mr.maintenance_date)) AS INTEGER) AS cleaning_interval      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id ) SELECT      rice_cooker_id,      maintenance_date,      maintenance_notes,      material,      cleaning_interval,      CASE          WHEN cleaning_interval > 90 THEN 'Cleaning interval exceeds 3 months'          WHEN maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic') THEN 'Acidic cleaning agent used'          ELSE 'Compliant with standards'      END AS violation_status  FROM CleaningAnalysis  WHERE cleaning_interval > 90 OR (maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic'));	rice_cooker	3
SELECT pt.rice_cooker_id, pt.final_temperature, (1.05e-34) / (2 * 9.1e-31 * POWER(1e-8, 2) * 1.38e-23 * 1e-6) AS "ΔT", (1.05e-34) / (2 * 9.1e-31 * POWER(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature AS temperature_oscillation_rate, pt.energy_consumption * ((1.05e-34) / (2 * 9.1e-31 * POWER(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature) AS energy_fluctuation FROM performance_tests pt;	rice_cooker	4
SELECT ur.rice_cooker_id, rci.power_rating, rci.voltage_rating, ur.energy_consumption, ur.duration, 230 AS V_supply, rci.power_rating * (POWER(230, 2) / POWER(rci.voltage_rating, 2)) AS P_actual, (ur.energy_consumption * 1000 / (rci.power_rating * (POWER(230, 2) / POWER(rci.voltage_rating, 2)) * ur.duration / 60)) * POWER(rci.voltage_rating / 230, 2) AS η_corrected FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	1
WITH QualityDecay AS (     SELECT          rci.model,          CAST(strftime('%Y', pt.test_date) AS INTEGER) AS year,          pt.rice_quality_score,          MAX(pt.rice_quality_score) OVER(PARTITION BY rci.model) - pt.rice_quality_score AS quality_decay,          SUM(COALESCE(mr.maintenance_cost, 0)) OVER(PARTITION BY rci.model ORDER BY pt.test_date) AS cumulative_maintenance_cost,          COUNT(ur.id) OVER(PARTITION BY rci.model) AS usage_count      FROM performance_tests pt      JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id      LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id      LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id )  SELECT      model,      year,      rice_quality_score,      (LN(usage_count) * quality_decay / cumulative_maintenance_cost) AS decay_index,      DENSE_RANK() OVER(PARTITION BY year ORDER BY (LN(usage_count) * quality_decay / cumulative_maintenance_cost) DESC) AS annual_rank  FROM QualityDecay;	rice_cooker	2
WITH temp_voltage_logs AS (     SELECT          ur.id AS usage_id,          200 + ABS(RANDOM()) % 40 * 1.0 AS supply_voltage      FROM usage_records ur ), VoltageLog AS (     SELECT          ur.rice_cooker_id,          ur.id AS usage_id,          vl.supply_voltage,          rci.voltage_rating,          CASE              WHEN vl.supply_voltage < 0.9 * rci.voltage_rating OR vl.supply_voltage > 1.1 * rci.voltage_rating THEN 'Voltage anomaly'              ELSE 'Voltage normal'          END AS voltage_status,          CASE              WHEN EXISTS (                 SELECT 1                  FROM maintenance_records mr                  WHERE mr.rice_cooker_id = ur.rice_cooker_id                  AND mr.replaced_parts LIKE '%Power%'             ) THEN 'Power module replaced'              ELSE 'Power module not replaced'          END AS power_module_status      FROM usage_records ur      JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id      JOIN temp_voltage_logs vl ON ur.id = vl.usage_id )  SELECT      rice_cooker_id,      usage_id,      supply_voltage,      voltage_rating,      voltage_status,      power_module_status  FROM VoltageLog  WHERE voltage_status = 'Voltage anomaly';	rice_cooker	3
SELECT pt.rice_cooker_id, pt.rice_quality_score, pt.energy_consumption, EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS curvature_factor, pt.rice_quality_score * (1 - EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)))) AS quality_distortion, pt.energy_consumption / EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS energy_distortion FROM performance_tests pt;	rice_cooker	4
WITH EnergyAnalysis AS (     SELECT          ur.id AS usage_id,         ur.rice_cooker_id,         ur.water_quantity,         ur.energy_consumption AS E_actual,         pt.water_evaporation_rate,         -- Calculate energy saving benefit: ΔE = (water_quantity × water_evaporation_rate% × η × L)/3600         (ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600 AS delta_E,         -- Calculate potential energy consumption after recovery         ur.energy_consumption - ((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) AS potential_E,         -- Calculate energy saving percentage         (((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) / ur.energy_consumption) * 100 AS energy_saving_percentage,         CASE              WHEN (((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) / ur.energy_consumption) * 100 > 10              THEN 'High energy saving potential'             WHEN (((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) / ur.energy_consumption) * 100 > 5              THEN 'Medium energy saving potential'              ELSE 'Low energy saving potential'         END AS saving_potential     FROM usage_records ur     JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id     WHERE pt.water_evaporation_rate IS NOT NULL        AND ur.water_quantity > 0       AND ur.energy_consumption > 0 ) SELECT      usage_id,     rice_cooker_id,     water_quantity,     water_evaporation_rate,     ROUND(E_actual, 3) AS actual_energy_consumption,     ROUND(delta_E, 3) AS energy_saving_benefit,     ROUND(potential_E, 3) AS potential_energy_consumption,     ROUND(energy_saving_percentage, 2) AS energy_saving_percentage,     saving_potential FROM EnergyAnalysis ORDER BY energy_saving_percentage DESC;	rice_cooker	1
SELECT      rci.brand,     SUM(         0.4 * ((pt.rice_quality_score - min_rq.min_rq) / (max_rq.max_rq - min_rq.min_rq)) +         0.3 * ((avg_ec.avg_ec / avg_rq.avg_rq) - min_er.min_er) / (max_er.max_er - min_er.min_er) +         0.2 * ((COUNT(mr.id) / COUNT(ur.id)) - min_mf.min_mf) / (max_mf.max_mf - min_mf.min_mf) +         0.1 * (1 - ((rci.price - min_p.min_p) / (max_p.max_p - min_p.min_p)))     ) AS comprehensive_score FROM rice_cooker_info rci LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id CROSS JOIN (SELECT MIN(rice_quality_score) AS min_rq, MAX(rice_quality_score) AS max_rq FROM performance_tests) min_rq CROSS JOIN (SELECT AVG(energy_consumption) AS avg_ec FROM performance_tests) avg_ec CROSS JOIN (SELECT AVG(rice_quantity) AS avg_rq FROM usage_records) avg_rq CROSS JOIN (SELECT MIN(avg_ec / avg_rq) AS min_er, MAX(avg_ec / avg_rq) AS max_er FROM      (SELECT rice_cooker_id, AVG(energy_consumption) AS avg_ec, AVG(rice_quantity) AS avg_rq       FROM performance_tests pt      JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id      GROUP BY rice_cooker_id)) min_max_er CROSS JOIN (SELECT MIN(COUNT(mr.id) / COUNT(ur.id)) AS min_mf, MAX(COUNT(mr.id) / COUNT(ur.id)) AS max_mf FROM      rice_cooker_info rci     LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id     LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id     GROUP BY rci.id) min_max_mf CROSS JOIN (SELECT MIN(price) AS min_p, MAX(price) AS max_p FROM rice_cooker_info) min_p GROUP BY rci.brand ORDER BY comprehensive_score DESC;	rice_cooker	2
SELECT      pt.*,      (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) AS temperature_rise_rate,      CASE          WHEN EXISTS (             SELECT 1              FROM maintenance_records mr              WHERE mr.rice_cooker_id = pt.rice_cooker_id              AND mr.replaced_parts LIKE '%Thermistor%'         ) THEN 'Maintained'          ELSE 'Not maintained'      END AS maintenance_status  FROM performance_tests pt  JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id  WHERE (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) > 0.33  AND ABS(ur.actual_max_temperature - ur.temperature_setting) > 5;	rice_cooker	3
SELECT rci.id AS rice_cooker_id, rci.model, rci.weight, ur.duration AS heating_time, (rci.weight * ur.duration * 60) AS black_hole_mass, (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)) AS schwarzschild_radius, SQRT(1 - (2 * 6.67430e-11 * (rci.weight * ur.duration * 60)) / (POWER(299792458, 2) * (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)))) AS time_dilation_factor, (1.0545718e-34 * POWER(299792458, 3)) / (8 * 3.141592653589793 * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) AS hawking_temperature, (1.0545718e-34 * POWER(299792458, 3)) / (8 * 3.141592653589793 * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) * ur.energy_consumption AS quantum_energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE ur.temperature_setting >= 1.4e32;	rice_cooker	4
SELECT      rci.material,      AVG(ur.actual_max_temperature - ur.temperature_setting) / AVG(ur.duration) AS average_temperature_rise_rate,      AVG(rci.capacity * rci.weight) / (AVG(rci.power_rating) * 1000) AS thermal_conduction_time_constant  FROM rice_cooker_info rci  JOIN usage_records ur ON rci.id = ur.rice_cooker_id  GROUP BY rci.material;	rice_cooker	1
WITH usage_count AS (     SELECT rice_cooker_id, COUNT(*) AS usage_times     FROM usage_records     GROUP BY rice_cooker_id ), maintenance_cost_sum AS (     SELECT rice_cooker_id, SUM(maintenance_cost) AS total_maintenance_cost     FROM maintenance_records     GROUP BY rice_cooker_id ), rice_quality_variation AS (     SELECT rice_cooker_id,             (STDEV(rice_quality_score) / AVG(rice_quality_score)) AS rice_quality_cv     FROM performance_tests     GROUP BY rice_cooker_id ) SELECT      rci.id AS rice_cooker_id,      rci.model,      EXP(-mcs.total_maintenance_cost / rci.price) * (1 + LN(uc.usage_times)) * rqv.rice_quality_cv AS health_index,     CAST((strftime('%m', ur.start_time) - 1) / 3 + 1 AS INTEGER) AS quarter,      strftime('%Y', ur.start_time) AS year FROM rice_cooker_info rci JOIN usage_count uc ON rci.id = uc.rice_cooker_id JOIN maintenance_cost_sum mcs ON rci.id = mcs.rice_cooker_id JOIN rice_quality_variation rqv ON rci.id = rqv.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id GROUP BY rci.id, rci.model, mcs.total_maintenance_cost, rci.price, uc.usage_times, rqv.rice_quality_cv, quarter, year;	rice_cooker	2
WITH usage_sequence AS (     SELECT          rice_cooker_id AS device_id,          start_time,          end_time,          rice_quantity,          (julianday(start_time) - julianday(LAG(end_time) OVER(PARTITION BY rice_cooker_id ORDER BY start_time))) * 1440 AS cooling_interval      FROM usage_records ) SELECT      us.*,      CASE          WHEN EXISTS (             SELECT 1              FROM maintenance_records mr              WHERE mr.rice_cooker_id = us.device_id              AND mr.maintenance_type = 'Overheat Repair'         ) THEN 1          ELSE 0      END AS has_overheat_repair  FROM usage_sequence us  WHERE cooling_interval < 15  AND rice_quantity > 0.5  AND start_time > '2023-01-01';	rice_cooker	3
SELECT rci.model, rci.brand, ur.rice_quantity, ur.water_quantity, pt.water_evaporation_rate, pt.rice_quality_score, pt.energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id JOIN performance_tests pt ON rci.id = pt.rice_cooker_id WHERE pt.test_type = 'cooking rice' AND ur.rice_quantity > 0 AND ur.water_quantity > 0;	rice_cooker	4
SELECT rice_cooker_id, test_date, initial_temperature, final_temperature, energy_consumption, time_to_boil FROM performance_tests WHERE test_type = 'heat preservation';	rice_cooker	1
SELECT rc.model, ur.energy_consumption, ROUND(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12)),4) AS maturation_degree, ur.energy_consumption * (1/(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12))) - 1) AS energy_distortion, SQRT(1.38e-23*2e12/(1.05e-34*3e8)) * ur.duration*60 AS quantum_fluctuation FROM rice_cooker_info rc JOIN usage_records ur ON rc.id = ur.rice_cooker_id WHERE ur.duration > 0;	rice_cooker	2
SELECT rc.model, pt.final_temperature, ur.duration, (pt.final_temperature - 25) AS AS_T, ROUND((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration), 2) AS total_heat_loss_J, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600, 2) AS heat_loss_kWh, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600 / (0.1 * rc.power_rating * ur.duration / 60), 2) AS efficiency_ratio FROM rice_cooker_info rc JOIN performance_tests pt ON rc.id = pt.rice_cooker_id JOIN usage_records ur ON rc.id = ur.rice_cooker_id WHERE ur.rice_quantity > rc.capacity * 1.2;	rice_cooker	3
WITH monthly_data AS (     SELECT          rc.brand AS manufacturer,          strftime('%Y-%m', pt.test_date) AS month,          (pt.rice_quality_score - AVG(pt.rice_quality_score) OVER()) / (STDDEV_SAMP(pt.rice_quality_score) OVER()) AS z_score,          1 - (STDDEV_SAMP(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand) / AVG(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand)) AS efficiency_variation,          SUM(mr.maintenance_cost) OVER(PARTITION BY rc.brand) / rc.price AS maintenance_ratio      FROM rice_cooker_info rc      LEFT JOIN usage_records ur ON rc.id = ur.rice_cooker_id      LEFT JOIN maintenance_records mr ON rc.id = mr.rice_cooker_id      JOIN performance_tests pt ON rc.id = pt.rice_cooker_id )  SELECT      manufacturer,      month,      ROUND(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio, 2) AS quality_index,      AVG(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio) OVER(ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS trend  FROM monthly_data  ORDER BY manufacturer, month;	rice_cooker	4
SELECT ul.id AS usage_id, di.model, ul.rice_quantity, di.capacity, ul.rice_quantity / di.capacity AS overload_ratio, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records ml WHERE ml.rice_cooker_id = ul.rice_cooker_id AND ml.maintenance_notes LIKE '%inner pot deformation%') THEN 1 ELSE 0 END AS has_deformation FROM usage_records ul JOIN rice_cooker_info di ON ul.rice_cooker_id = di.id WHERE ul.rice_quantity > 1.2 * di.capacity;	rice_cooker	1
WITH cost_calculation AS (     SELECT          di.brand,         di.price AS initial_price,         mr.maintenance_cost,         mr.maintenance_date,         julianday(mr.maintenance_date) - julianday(di.production_date) AS days_since_production,         (julianday(mr.maintenance_date) - julianday(di.production_date)) / 365.25 AS years_since_production     FROM rice_cooker_info di     JOIN maintenance_records mr ON di.id = mr.rice_cooker_id ), discounted_costs AS (     SELECT          brand,         initial_price,         maintenance_cost,         years_since_production,         maintenance_cost / POWER(1.05, years_since_production) AS discounted_maintenance_cost     FROM cost_calculation ), aggregated_costs AS (     SELECT          brand,         initial_price,         SUM(discounted_maintenance_cost) AS total_discounted_maintenance     FROM discounted_costs     GROUP BY brand, initial_price ), total_present_value AS (     SELECT          brand,         initial_price + total_discounted_maintenance AS present_value     FROM aggregated_costs ) SELECT brand, present_value FROM total_present_value ORDER BY present_value;	rice_cooker	2
SELECT di.model, di.material, pt.time_to_boil AS actual_boil_time_min, ROUND(CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16.0/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END, 2) AS theoretical_diffusion_time_s, ROUND((pt.time_to_boil*60 - CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16.0/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END) / CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16.0/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END *100.0, 1) AS time_deviation_percent FROM rice_cooker_info di JOIN performance_tests pt ON di.id = pt.rice_cooker_id WHERE di.material IN ('Stainless Steel','Ceramic');	rice_cooker	3
WITH RECURSIVE numbers(n) AS (     SELECT 0     UNION ALL     SELECT n+1 FROM numbers WHERE n < 9999 ), lifetime_simulation AS (     SELECT di.id AS device_id,             ABS(RANDOM()) / 18446744073709551615.0 AS rand_value,             EXP(-SUM(0.01 * ul.rice_quantity * (JULIANDAY(ml.maintenance_date) - JULIANDAY(di.production_date)) / 365)) AS survival_probability     FROM numbers      CROSS JOIN rice_cooker_info di      LEFT JOIN maintenance_records ml ON di.id = ml.rice_cooker_id      LEFT JOIN usage_records ul ON di.id = ul.rice_cooker_id      GROUP BY di.id, numbers.n )  SELECT ls.device_id AS id,         AVG(CASE WHEN ls.rand_value > ls.survival_probability THEN (JULIANDAY('now') - JULIANDAY(di.production_date)) / 365 ELSE 999 END) AS simulated_lifetime  FROM lifetime_simulation ls  JOIN rice_cooker_info di ON ls.device_id = di.id  GROUP BY ls.device_id;	rice_cooker	4
SELECT pt.*, rci.power_rating FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE (pt.time_to_boil < 15 OR rci.power_rating > 1000) AND EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = rci.id AND mr.replaced_parts = 'electromagnetic shielding component');	rice_cooker	1
WITH normalized AS (   SELECT      rci.model,     pt.energy_consumption,     pt.time_to_boil,     pt.rice_quality_score,     (pt.energy_consumption - min_energy.min_val) / (max_energy.max_val - min_energy.min_val) AS p_energy,     (pt.time_to_boil - min_time.min_val) / (max_time.max_val - min_time.min_val) AS p_time,     (pt.rice_quality_score - min_quality.min_val) / (max_quality.max_val - min_quality.min_val) AS p_quality   FROM rice_cooker_info rci   JOIN performance_tests pt ON rci.id = pt.rice_cooker_id,   (SELECT MIN(energy_consumption) AS min_val, MAX(energy_consumption) AS max_val FROM performance_tests) AS min_energy,   (SELECT MIN(time_to_boil) AS min_val, MAX(time_to_boil) AS max_val FROM performance_tests) AS min_time,   (SELECT MIN(rice_quality_score) AS min_val, MAX(rice_quality_score) AS max_val FROM performance_tests) AS min_quality ), entropy AS (   SELECT     -SUM(p_energy * LN(p_energy)) / LN(COUNT(*)) AS e_energy,     -SUM(p_time * LN(p_time)) / LN(COUNT(*)) AS e_time,     -SUM(p_quality * LN(p_quality)) / LN(COUNT(*)) AS e_quality,     COUNT(*) AS n   FROM normalized ), weights AS (   SELECT     (1 - e_energy) / ((1 - e_energy) + (1 - e_time) + (1 - e_quality)) AS w_energy,     (1 - e_time) / ((1 - e_energy) + (1 - e_time) + (1 - e_quality)) AS w_time,     (1 - e_quality) / ((1 - e_energy) + (1 - e_time) + (1 - e_quality)) AS w_quality   FROM entropy ) SELECT   model,   p_energy,   p_time,   p_quality,   w_energy,   w_time,   w_quality,   (w_energy * p_energy + w_time * p_time + w_quality * p_quality) AS comprehensive_score FROM normalized, weights;	rice_cooker	2
SELECT rci.id, rci.material, pt.final_temperature, ur.rice_quantity, CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.141592653589793 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.141592653589793 * 0.0001)) ELSE NULL END AS t_c, (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.141592653589793 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.141592653589793 * 0.0001)) ELSE NULL END AS risk_index, CASE WHEN (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.141592653589793 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.141592653589793 * 0.0001)) ELSE NULL END < 1 THEN 'Safe' ELSE 'Dangerous' END AS safety_condition FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id;	rice_cooker	3
WITH standardized_data AS (     SELECT          rci.brand AS manufacturer,          (pt.energy_consumption - MIN(pt.energy_consumption) OVER()) / (MAX(pt.energy_consumption) OVER() - MIN(pt.energy_consumption) OVER()) AS p_energy,          (pt.time_to_boil - MIN(pt.time_to_boil) OVER()) / (MAX(pt.time_to_boil) OVER() - MIN(pt.time_to_boil) OVER()) AS p_time,          (pt.rice_quality_score - MIN(pt.rice_quality_score) OVER()) / (MAX(pt.rice_quality_score) OVER() - MIN(pt.rice_quality_score) OVER()) AS p_score      FROM rice_cooker_info rci      JOIN performance_tests pt ON rci.id = pt.rice_cooker_id ), entropy_calculation AS (     SELECT          manufacturer,          -SUM(p_energy * LN(p_energy + 1e-9)) / LN(COUNT(*)) AS e_energy,          -SUM(p_time * LN(p_time + 1e-9)) / LN(COUNT(*)) AS e_time,          -SUM(p_score * LN(p_score + 1e-9)) / LN(COUNT(*)) AS e_score      FROM standardized_data      GROUP BY manufacturer ), weights AS (     SELECT          manufacturer,          (1 - e_energy) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_energy,          (1 - e_time) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_time,          (1 - e_score) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_score      FROM entropy_calculation ) SELECT      sd.manufacturer,      SUM(w.w_energy * (1 - sd.p_energy) + w.w_time * sd.p_time + w.w_score * sd.p_score) AS comprehensive_score  FROM standardized_data sd  JOIN weights w ON sd.manufacturer = w.manufacturer  GROUP BY sd.manufacturer;	rice_cooker	4
WITH maintenance_intervals AS (     SELECT          rice_cooker_id,          maintenance_date,          LAG(maintenance_date) OVER (PARTITION BY rice_cooker_id ORDER BY maintenance_date) AS prev_date,          maintenance_type      FROM maintenance_records ) SELECT      mi.rice_cooker_id,      mi.maintenance_date,      mi.prev_date,      CAST((JULIANDAY(mi.maintenance_date) - JULIANDAY(mi.prev_date)) * 1440 AS INTEGER) AS cooling_interval,      CASE          WHEN mi.maintenance_type = 'thermal fuse reset'          AND (JULIANDAY(mi.maintenance_date) - JULIANDAY(mi.prev_date)) * 1440 < 30          AND EXISTS (             SELECT 1              FROM usage_records ul              WHERE ul.rice_cooker_id = mi.rice_cooker_id              AND ul.temperature_setting > 85         )          THEN 'violation'          ELSE 'compliance'      END AS violation_status  FROM maintenance_intervals mi;	rice_cooker	1
SELECT rci.id, rci.power_rating, rci.voltage_rating, pt.final_temperature, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) AS L, (rci.power_rating / (rci.voltage_rating * rci.voltage_rating)) AS sigma, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / (rci.voltage_rating * rci.voltage_rating)) * (pt.final_temperature + 273) AS k_quantum, CASE WHEN (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / (rci.voltage_rating * rci.voltage_rating)) * (pt.final_temperature + 273) > 5000 THEN 'abnormal' ELSE 'normal' END AS thermal_conductivity_anomaly FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id;	rice_cooker	2
WITH calibration_records AS (   SELECT 1 AS rice_cooker_id, '2023-01-15' AS calibration_date, 1.5 AS calibration_error    UNION ALL    SELECT 2, '2022-12-20', 2.5    UNION ALL    SELECT 3, '2023-03-10', 0.8 )  SELECT pt.id, pt.test_date, cr.calibration_date, ABS(cr.calibration_error) AS calibration_error,         ABS(pt.final_temperature - pt.initial_temperature) AS temperature_deviation,         CASE           WHEN julianday(pt.test_date) - julianday(cr.calibration_date) > 365 THEN 'calibration overdue'           WHEN ABS(cr.calibration_error) > 2 THEN 'error exceeds limit'           WHEN ABS(pt.final_temperature - pt.initial_temperature) > 5 THEN 'temperature deviation'           ELSE 'normal'         END AS violation_status  FROM performance_tests pt  JOIN calibration_records cr ON pt.rice_cooker_id = cr.rice_cooker_id;	rice_cooker	3
SELECT pt.id, pt.energy_consumption, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) AS P, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 AS energy_gain, CASE WHEN (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 > pt.energy_consumption * 3.6e6 THEN 'satisfied' ELSE 'not satisfied' END AS quantum_condition FROM performance_tests pt;	rice_cooker	4
SELECT pt.time_to_boil AS t_earth, (pt.time_to_boil * (75.0 / (1.0/3.0 * 240.0)) * ((2260.0 / (75.0 * 1.0)) + 1.0) / ((2260.0 / (1.0/3.0 * 240.0 * 1.0)) + 1.0)) AS t_moon FROM performance_tests pt JOIN rice_cooker_info ri ON pt.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';	rice_cooker	1
SELECT ri.brand, 1 - EXP(-POWER(5.0 / 8.0, 2.5)) AS failure_probability_5_years, 8.0 * POWER(LN(2.0), 1.0 / 2.5) AS median_lifetime FROM rice_cooker_info ri GROUP BY ri.brand;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN 'Abnormal rice-to-water ratio' WHEN (SELECT STDEV(pt.final_temperature) FROM performance_tests pt WHERE pt.rice_cooker_id = ur.rice_cooker_id) > 5 THEN 'Uneven heating' WHEN ABS(AVG(ur.actual_max_temperature) - AVG(ur.temperature_setting)) > 5 THEN 'Temperature control deviation' WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%inner coating%') THEN 'Coating peeling' ELSE 'Other reasons' END AS possible_cause FROM usage_records ur GROUP BY ur.rice_cooker_id, ur.rice_quantity, ur.water_quantity;	rice_cooker	3
SELECT EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS tunneling_probability, 1 / EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS efficiency_increase FROM rice_cooker_info;	rice_cooker	4
SELECT pt.water_evaporation_rate, ur.energy_consumption, (ur.energy_consumption * ri.power_rating * (2260e3/461.5)*(1/363 - 1/373)/ri.power_rating) / (ur.water_quantity * 4.18 * 65 + pt.water_evaporation_rate * 2260) AS efficiency_correction FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';	rice_cooker	1
WITH user_features AS (     SELECT          rice_cooker_id,          COUNT(*) AS usage_frequency,          AVG(rice_quantity) AS avg_rice_quantity,          AVG(duration) AS avg_duration      FROM usage_records      GROUP BY rice_cooker_id ) SELECT      rice_cooker_id,      usage_frequency,      avg_rice_quantity,      avg_duration,      CASE          WHEN usage_frequency > 10 AND avg_duration < 30 THEN 'Frequent Quick Cooking'          WHEN usage_frequency BETWEEN 5 AND 10 AND avg_rice_quantity > 1 THEN 'Scheduled Appointments'          WHEN avg_duration > 60 THEN 'Heat Retention Dependence'          ELSE 'Other'      END AS user_category  FROM user_features;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.water_quantity / ri.capacity > 1.2 THEN 'Water level abnormal' WHEN ur.rice_type NOT IN ('White Rice', 'Brown Rice') THEN 'Incompatible rice type' WHEN strftime('%H', ur.start_time) BETWEEN '18' AND '20' THEN 'Peak time usage' ELSE 'Other' END AS misoperation_type FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;	rice_cooker	3
SELECT LN(1 - (2.8e6 / (1e-25 * 0.9))) / LN(1 - EXP(-1/1e-6)) AS required_qubits FROM rice_cooker_info WHERE id IS NOT NULL;	rice_cooker	4
SELECT ri.power_rating, pt.initial_temperature, (0.9*5.67e-8*0.15*(POWER(373,4)-POWER(233,4)))*((25*3.5*4180)/(ri.power_rating - (0.9*5.67e-8*0.15*(POWER(373,4)-POWER(233,4))))) AS extra_energy FROM rice_cooker_info ri JOIN performance_tests pt ON ri.id = pt.rice_cooker_id WHERE pt.test_type = 'Boiling';	rice_cooker	1
WITH fuzzy_data AS (   SELECT      ur.rice_cooker_id,      COUNT(*) / 30.0 AS usage_freq,      AVG(ABS(ur.actual_max_temperature - ur.temperature_setting)) AS temp_deviation,      (JULIANDAY(MAX(mr.maintenance_date)) - JULIANDAY(MIN(mr.maintenance_date))) / 30.0 AS maintenance_interval    FROM usage_records ur    LEFT JOIN maintenance_records mr ON ur.rice_cooker_id = mr.rice_cooker_id    GROUP BY ur.rice_cooker_id ) SELECT    rice_cooker_id,    CASE      WHEN usage_freq > 0.8 AND temp_deviation > 5 THEN 'High Risk'      WHEN (usage_freq BETWEEN 0.5 AND 0.8) OR maintenance_interval > 6 THEN 'Medium Risk'      ELSE 'Low Risk'    END AS risk_level  FROM fuzzy_data;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN 'Abnormal rice-to-water ratio(Appropriate range 1:1.2-1:1.8)' WHEN (ur.rice_quantity + ur.water_quantity) > ri.capacity THEN 'Total amount exceeds capacity(Exceeds rice cooker capacity)' WHEN ri.power_rating > 1000 THEN 'Power too high(>1000W)' ELSE 'Other reasons' END AS overflow_reason FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;	rice_cooker	3
SELECT POWER(5e-3,2)/(4*0.6) AS characteristic_length, CEIL((pt.final_temperature - pt.initial_temperature)/5 * SQRT(ur.energy_consumption)) AS iterations FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE pt.test_type = 'Boiling';	rice_cooker	4
SELECT (5 * 4200 * 75) / power_rating / 60 AS theoretical_time_minutes FROM rice_cooker_info WHERE model = 'RC-2002';	rice_cooker	1
SELECT rci.model, SUM(ur.energy_consumption) AS total_energy, COUNT(*) AS usage_count FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE rci.brand = 'BrandY' AND strftime('%Y', ur.start_time) = '2023' GROUP BY rci.model ORDER BY total_energy DESC LIMIT 5;	rice_cooker	2
SELECT model, brand, price FROM rice_cooker_info WHERE capacity > 4 AND power_rating < 800;	rice_cooker	3
SELECT 5000 * (30 / 3600) AS energy_consumption_kwh;	rice_cooker	4
SELECT pt.energy_consumption / ((1.5 * 4.18 + 1.2 * 1.8) * 75) AS thermal_efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE rci.model = 'RC-3003' AND pt.final_temperature = 100 LIMIT 1;	rice_cooker	1
SELECT rci.brand, rci.model, (STDDEV_SAMP(pt.rice_quality_score) / AVG(pt.rice_quality_score)) AS cv  FROM performance_tests pt  JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id  GROUP BY rci.brand, rci.model  HAVING cv > 0.25;	rice_cooker	2
SELECT rci.model  FROM rice_cooker_info rci  JOIN usage_records ur ON rci.id = ur.rice_cooker_id  LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id AND mr.maintenance_type = 'Cleaning'  WHERE ur.start_time >= date('now', '-2 years')  GROUP BY rci.id  HAVING COUNT(ur.id) > 10 AND COUNT(mr.id) = 0;	rice_cooker	3
SELECT 30000 / 220 AS current_strength;	rice_cooker	4
SELECT (DissolvedOxygenMgL / 8.24) * 100 AS DissolvedOxygenSaturation FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, POWER(10, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 7.0 AND TemperatureCelsius = 15 AND ConductivityUsCm = 300;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 THEN 'Not suitable for fish survival' WHEN DissolvedOxygenMgL < 5 THEN 'Not suitable for fish survival' WHEN TurbidityNTU > 25 THEN 'Not suitable for fish survival' ELSE 'Suitable for fish survival' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.ConductivityUsCm, POWER(10.0, -WQD.PHValue) AS H_ion_concentration, POWER(10.0, -(14 - WQD.PHValue)) AS OH_ion_concentration, (POWER(10.0, -WQD.PHValue) * POWER(10.0, -(14 - WQD.PHValue)) * WQD.ConductivityUsCm) AS IAP FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime LIKE '2023-10-01%' AND WQD.PHValue = 15 AND WQD.DissolvedOxygenMgL = 1000 AND WQD.TurbidityNTU = 10000;	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.64 AS EstimatedTDS FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, POWER(10.0, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.8;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 OR DissolvedOxygenMgL < 5 THEN 'Not suitable for fish survival' ELSE 'Suitable for fish survival' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, CASE WHEN WQD.PHValue = 0 OR WQD.DissolvedOxygenMgL = 2000 OR WQD.TurbidityNTU = 50000 THEN 'Does not comply with conventional water quality standards' ELSE 'Complies with conventional water quality standards' END AS WaterQualityStatus FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.7 AS TDSConcentration FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) AS IonStrength, CASE WHEN 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) > 0.1 THEN 'High Ionic Strength' ELSE 'Not High Ionic Strength' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.2 AND TemperatureCelsius = 20 AND ConductivityUsCm = 450;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 8.5 THEN 'Not suitable as a drinking water source' WHEN DissolvedOxygenMgL < 5 THEN 'Not suitable as a drinking water source' WHEN TurbidityNTU > 5 THEN 'Not suitable as a drinking water source' ELSE 'Suitable as a drinking water source' END AS DrinkingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -5 OR WQD.DissolvedOxygenMgL = 50000 OR WQD.TurbidityNTU = 1000000 OR WQD.TemperatureCelsius = 200 OR WQD.ConductivityUsCm = 1000000 THEN 'Unlikely to exist in nature' ELSE 'Possible to exist in nature' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT (100 * 2) AS Alk_CO3, 200 AS Alk_HCO3, (100 * 2 + 200) AS Total_Alkalinity FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) AS IonStrength, CASE WHEN 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) > 0.1 THEN 'High Ionic Strength' ELSE 'Not High Ionic Strength' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 8.0 AND TemperatureCelsius = 30 AND ConductivityUsCm = 800;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.0 OR PHValue > 9.0 THEN 'Not suitable for use as industrial cooling water' WHEN DissolvedOxygenMgL < 4 THEN 'Not suitable for use as industrial cooling water' WHEN TurbidityNTU > 20 THEN 'Not suitable for use as industrial cooling water' WHEN TemperatureCelsius > 40 THEN 'Not suitable for use as industrial cooling water' ELSE 'Suitable for use as industrial cooling water' END AS CoolingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -10 OR WQD.DissolvedOxygenMgL = 100000 OR WQD.TurbidityNTU = 10000000 OR WQD.TemperatureCelsius = 500 OR WQD.ConductivityUsCm = 10000000 THEN 'Impossible to exist in nature' ELSE 'Possible to exist in nature' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT CASE WHEN DissolvedOxygenMgL >= 8.24 THEN 'has reached saturation' ELSE 'has not reached saturation' END AS SaturationStatus FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND DissolvedOxygenMgL = 8;	WaterQualityMonitor	1
SELECT AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TurbidityNTU < 5 THEN 'Suitable for direct drinking' ELSE 'Not suitable for direct drinking' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 50;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount  FROM WaterQualityData  WHERE MonitorId = 1    AND PHValue > 8.5    AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30 AND ConductivityUsCm = 2000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 4 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'Exceeds safe limit' ELSE 'Does not exceed safe limit' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2.5 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 50 AND DissolvedOxygenMgL = 2;	WaterQualityMonitor	1
WITH FilteredData AS (     SELECT PHValue      FROM WaterQualityData      WHERE MonitorId = 1      AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now')     AND PHValue BETWEEN 6.0 AND 8.0 )  SELECT      (COUNT(*) * 100.0 / (         SELECT COUNT(*)          FROM WaterQualityData          WHERE MonitorId = 1          AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now')     )) AS PercentageInRange,      AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound,      AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound  FROM FilteredData;	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN 'reasonable' ELSE 'unreasonable' END AS TDSReasonability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 2000 AND ConductivityUsCm = 3000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * (TemperatureCelsius * TemperatureCelsius) - 0.000077774 * (TemperatureCelsius * TemperatureCelsius * TemperatureCelsius)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 80 AND DissolvedOxygenMgL = 1;	WaterQualityMonitor	1
WITH LogTransformedData AS (SELECT LN(TurbidityNTU) AS LogTurbidity FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-365 days') AND datetime('now')), FilteredData AS (SELECT TurbidityNTU FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-365 days') AND datetime('now') AND TurbidityNTU > 50) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-365 days') AND datetime('now'))) AS PercentageAboveThreshold, EXP(AVG(LogTurbidity) - (2.576 * (STDDEV_SAMP(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS LowerBound, EXP(AVG(LogTurbidity) + (2.576 * (STDDEV_SAMP(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS UpperBound FROM LogTransformedData;	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'exceeds the safety limit' ELSE 'does not exceed the safety limit' END AS SafetyStatus, 'Potential sources of pollution may include agricultural runoff, industrial wastewater, or domestic sewage.' AS PotentialSources FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 10 AND NitrateNitrogenMgL = 100;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35 AND DissolvedOxygenMgL = 4;	WaterQualityMonitor	1
WITH FilteredData AS (     SELECT PHValue      FROM WaterQualityData      WHERE MonitorId = 1      AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now')      AND PHValue BETWEEN 7.0 AND 8.0 ) SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now'))) AS PercentageInRange,     AVG(PHValue) - (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound,     AVG(PHValue) + (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound  FROM FilteredData;	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN 'reasonable' ELSE 'unreasonable' END AS TDSReasonability, CASE WHEN TotalDissolvedSolidsMgL NOT BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN 'possible reasons: abnormal ions in the water body or measurement errors.' ELSE 'no abnormalities' END AS ReasonExplanation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1500 AND ConductivityUsCm = 2000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 6;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-3 days') AND datetime('now');	WaterQualityMonitor	2
SELECT ROUND((COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)), 2) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-3 days') AND datetime('now');	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 10 AND DissolvedOxygenMgL = 9;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.8 AND 7.2 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'exceeds safety limit' ELSE 'does not exceed safety limit' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.3 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT POWER(10.0, -PHValue) AS HydrogenIonConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND PHValue = 6.5;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.5 AND 7.5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 THEN 'Suitable for direct consumption, but close to the alkaline edge, long-term consumption should be cautious' ELSE 'Not suitable for direct consumption' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * (TemperatureCelsius * TemperatureCelsius) - 0.000077774 * (TemperatureCelsius * TemperatureCelsius * TemperatureCelsius)) AS SaturatedOxygen, (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * (TemperatureCelsius * TemperatureCelsius) - 0.000077774 * (TemperatureCelsius * TemperatureCelsius * TemperatureCelsius)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 8;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN DissolvedOxygenMgL > 5 THEN 'Suitable for fish survival' ELSE 'Not suitable for fish survival, dissolved oxygen concentration is close to the critical value' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND DissolvedOxygenMgL = 4;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount  FROM WaterQualityData  WHERE MonitorId = 1  AND DissolvedOxygenMgL < 5  AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT TurbidityNTU * 2.5 AS SuspendedSolidsConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 15 AND TurbidityNTU = 50;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TurbidityNTU > 40 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TurbidityNTU < 5 THEN 'Suitable for direct consumption' ELSE 'Not suitable for direct consumption' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 100;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT 1000 * 4.18 * (30 - 20) AS HeatRequired FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TemperatureCelsius > 35 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-5 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TemperatureCelsius BETWEEN 15 AND 30 THEN 'suitable for fish survival' ELSE 'not suitable for fish survival, water temperature is too high' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius > 40 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND ConductivityUsCm = 500;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN ConductivityUsCm > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN ConductivityUsCm BETWEEN 500 AND 1500 THEN 'Suitable for direct consumption, but further testing of dissolved solids is required' ELSE 'Not suitable for direct consumption' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm = 1000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN TotalDissolvedSolidsMgL = ConductivityUsCm * 0.67 THEN 'reasonable' ELSE 'unreasonable' END AS TDSValidation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 500 AND ConductivityUsCm = 750;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TotalDissolvedSolidsMgL > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN 500 AND 1000 THEN 'Suitable for direct consumption' ELSE 'Not suitable for direct consumption, TDS concentration exceeds the standard' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1200;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT AmmoniaNitrogenMgL + NitrateNitrogenMgL AS TotalNitrogen FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN (AmmoniaNitrogenMgL + NitrateNitrogenMgL) > 12 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'Exceeds safe limit' ELSE 'Does not exceed safe limit' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN PHValue < 7 THEN 'Ammonia nitrogen mainly exists in the form of NH4+' ELSE 'Ammonia nitrogen mainly exists in the form of NH3' END AS AmmoniaForm, CASE WHEN NitrateNitrogenMgL > 5 THEN 'Nitrate nitrogen concentration is high, which may have a negative impact on the aquatic ecosystem' ELSE 'Nitrate nitrogen concentration is normal' END AS NitrateImpact FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 6.5 AND AmmoniaNitrogenMgL = 1.5 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue < 6.5 AND AmmoniaNitrogenMgL > 1.5 AND NitrateNitrogenMgL > 10 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageConditionMet FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now','-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 AND AmmoniaNitrogenMgL <= 0.5 AND NitrateNitrogenMgL <= 50 THEN 'Suitable for direct consumption' ELSE 'Not suitable for direct consumption, further testing required' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount  FROM WaterQualityData  WHERE MonitorId = 1    AND (PHValue < 6.5 OR PHValue > 8.5 OR AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50)    AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT POWER(10, -PHValue) AS HydrogenIonConcentration, CASE WHEN PHValue > 8.5 THEN 'The water body is strongly alkaline, which may affect the survival of aquatic organisms and water quality safety' ELSE 'The water body pH value is normal' END AS WaterQualityImpact FROM WaterQualityData WHERE PHValue > 8.5;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningRule;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = 'dissolved oxygen' AND ThresholdValue = 5 AND ConditionOperator = '<';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN ConductivityUsCm > 1000 THEN 'High conductivity indicates a high concentration of ions in the water body, which may affect water quality and the ecosystem' ELSE 'Normal conductivity' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN PHValue > 8.5 THEN 'The carbonate buffer system may fail, leading to increased fluctuations in water pH, affecting water quality stability' ELSE 'The carbonate buffer system is normal, water quality is stable' END AS BufferSystemImpact FROM WaterQualityData WHERE PHValue > 8.5;	WaterQualityMonitor	1
WITH FilteredData AS (SELECT SeverityLevel FROM WaterQualityWarningRule WHERE SeverityLevel > 8) SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityWarningRule)) AS PercentageAboveThreshold,      AVG(SeverityLevel) - (1.96 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound,      AVG(SeverityLevel) + (1.96 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound  FROM FilteredData;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = 'dissolved oxygen' AND ThresholdValue = 5 AND ConditionOperator = '<';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN ConductivityUsCm > 1000 THEN 'High conductivity indicates a high concentration of ions in the water body, which may affect the chemical balance and health of the ecosystem' ELSE 'Normal conductivity' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel BETWEEN 4 AND 7 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityWarningRule;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = 'ammonia nitrogen' AND ThresholdValue = 0.5 AND ConditionOperator = '>';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TemperatureCelsius > 40 AND CollectionTime >= datetime('now', '-1 day') AND CollectionTime <= datetime('now');	WaterQualityMonitor	4
SELECT POWER(10, -TriggerValue) AS HydrogenIonConcentration, CASE WHEN TriggerValue > 7 THEN 'The water is alkaline, which may affect the survival of aquatic organisms and water quality safety' ELSE 'The water pH value is normal' END AS WaterQualityImpact FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 8.75 AND TriggerUnit = 'pH';	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 3.80 AND SeverityLevel = 7;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 1000 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	WaterQualityMonitor	4
SELECT POWER(10.0, -TriggerValue) AS HydrogenIonConcentration FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 7.5 AND TriggerUnit = 'pH';	WaterQualityMonitor	1
SELECT AVG(SeverityLevel) AS AverageSeverity FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 5 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	WaterQualityMonitor	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND power = 10000;	waterPump	4
SELECT Pump_ID, Purchase_date, Warranty_Period, date(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date, CASE WHEN '2023-06-01' <= date(Purchase_date, '+' || Warranty_Period || ' months') THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;	waterPump	4
SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 10000;	waterPump	4
SELECT Voltage * Current / 1000.0 AS Power FROM pump_specifications WHERE Voltage = 1000000 AND Current = 10000;	waterPump	1
SELECT power * 100 * 30 * 0.5 AS Monthly_Electricity_Cost FROM pump_specifications WHERE Voltage = 1000000 AND current = 10000;	waterPump	2
SELECT DATE(Purchase_Date, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM pumps WHERE Warranty_Period = 24 AND Purchase_Date = '2023-01-15';	waterPump	3
SELECT (Power * 1000 * 3600) / (1000 * 9.81 * Flow_Rate * Head / 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;	waterPump	4
SELECT date(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2023-01-15' AND Warranty_Period = 24;	waterPump	1
SELECT (5 * 365 * 8 * 0.8) AS Total_Energy_Cost;	waterPump	2
SELECT Power FROM pump_specifications WHERE Flow_Rate = 50 AND Head = 30;	waterPump	3
SELECT 5 * 8 * 365 AS total_energy_consumption_kWh, 5 * 8 * 365 * 0.8 AS total_cost_RMB;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Purchase_date, p.Warranty_Period, p.Location, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, (p.Warranty_Period * 30 * 24) AS Warranty_Hours FROM pumps p JOIN usage_records u ON p.Pump_ID = u.Pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID HAVING Total_Usage_Hours >= Warranty_Hours;	waterPump	3
SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Power_Required FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Efficiency = 200;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, MAX(m.Maintenance_Date) AS Last_Maintenance_Date, date(p.Purchase_date, '+' || p.Warranty_Period || ' months') AS Warranty_End_Date FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID LEFT JOIN maintenance_records m ON p.Pump_ID = m.pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period HAVING (Total_Usage_Hours > 1000 OR Last_Maintenance_Date IS NULL OR julianday('now') - julianday(Last_Maintenance_Date) > 180) AND julianday('now') < julianday(Warranty_End_Date);	waterPump	1
SELECT (10000 * 1000 * 9.81) / (3600 * Efficiency) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;	waterPump	2
SELECT pumps.Pump_ID, Model_Number, Manufacturer, (Flow_Rate * Head * 9.81 * 1000) / 3600 AS Hydraulic_Power FROM pump_specifications JOIN pumps ON pump_specifications.Pump_ID = pumps.Pump_ID;	waterPump	4
SELECT Pump_ID, Power * (Efficiency / 100.0) AS Actual_Output_Power FROM pump_specifications;	waterPump	1
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, (ps.Flow_Rate * ps.Head * 9.81 / 3600) / (ps.Efficiency / 100) AS Theoretical_Power FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE ps.Flow_Rate = 200 AND ps.Head = 80 AND ps.Efficiency = 85;	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT (10000 * 1000 * 100 * (Efficiency / 100)) / 3600 AS Power_kW FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;	waterPump	4
SELECT Power * 1 AS Electricity_Consumption FROM pump_specifications WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15;	waterPump	1
SELECT (Flow_Rate * Head * 100) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 5;	waterPump	2
SELECT power FROM pump_specifications WHERE Voltage = 1000000 AND current = 5000;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 5;	waterPump	1
SELECT (1000000 * 5000) / 1000 AS Power_kW;	waterPump	2
SELECT (Voltage * Current * 0.8) / 1000 AS Actual_Power FROM pump_specifications WHERE Current = 10 AND Voltage = 220;	waterPump	3
SELECT (1000 * 10000 * 1) AS Actual_Power;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Location, ps.Current, ps.Voltage, ps.Power, mr.Maintenance_Type, mr.Description, ur.Usage_Hours, ur.Notes FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID LEFT JOIN usage_records ur ON p.Pump_ID = ur.pump_ID WHERE ps.Current >= (SELECT 2 * AVG(Current) FROM pump_specifications WHERE Pump_ID = p.Pump_ID) AND p.Status = 'active';	waterPump	1
SELECT (1000 * 10000 * 1) / 1000 AS Actual_Power;	waterPump	2
SELECT (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600 AS Output_Power_kW FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Efficiency = 200;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Power = 10 AND Voltage = 220 AND Current = 50;	waterPump	1
SELECT DATE(Purchase_Date, '+' || Warranty_Period || ' months') AS Warranty_End FROM pumps WHERE Warranty_Period = 24 AND Purchase_Date = '2020-01-01';	waterPump	3
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT datetime(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 24;	waterPump	1
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	2
SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;	waterPump	3
SELECT p.Pump_ID, p.Model_Number, SUM(mr.Cost) AS Total_Maintenance_Cost, SUM(ur.Usage_Hours) AS Total_Usage_Hours FROM pumps p JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID WHERE mr.Maintenance_Date >= date('now', '-1 year') AND ur.Start_Time >= date('now', '-1 year') GROUP BY p.Pump_ID, p.Model_Number ORDER BY Total_Maintenance_Cost DESC, Total_Usage_Hours DESC;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, COUNT(mr.Record_ID) AS Maintenance_Count, SUM(u.Usage_Hours) AS Total_Usage_Hours FROM pumps p LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' GROUP BY p.Pump_ID, p.Model_Number, p.Status HAVING Maintenance_Count > 5 OR Total_Usage_Hours > 1000;	waterPump	2
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Location, p.Status, ps.Flow_Rate, ps.Head, ps.Power, ps.Voltage, ps.Current, ps.Efficiency, mr.Maintenance_Date, mr.Maintenance_Type, mr.Description, mr.Technician, mr.Cost, ur.Start_Time, ur.End_Time, ur.Usage_Hours, ur.Notes  FROM pumps p  JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID  JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID  JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID  WHERE (julianday('now') - julianday(p.Purchase_Date) >= p.Warranty_Period * 30)     OR (SELECT SUM(Usage_Hours) FROM usage_records WHERE Pump_ID = p.Pump_ID) > 1000  ORDER BY mr.Maintenance_Date DESC;	waterPump	3
SELECT SUM(ps.power * u.Usage_Hours) AS Total_Energy_Consumption FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' AND strftime('%Y', u.Start_Time) = strftime('%Y', date('now'));	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period, SUM(u.Usage_Hours) AS Total_Usage_Hours, CASE WHEN SUM(u.Usage_Hours) > 1000 OR date(p.Purchase_date, '+' || p.Warranty_Period || ' months') < date('now') THEN 'Needs Maintenance' ELSE 'No Maintenance Required' END AS Maintenance_Status FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period;	waterPump	4
SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100.0) * Usage_Hours / 1000 AS Total_Energy_Consumption FROM usage_records JOIN pump_specifications ON usage_records.pump_ID = pump_specifications.Pump_ID WHERE usage_records.Start_Time >= ? AND usage_records.End_Time <= ?;	waterPump	1
SELECT AVG(Cost) / 12 AS Average_Monthly_Maintenance_Cost FROM maintenance_records;	waterPump	2
SELECT SUM(ps.power * u.Usage_Hours) AS Total_Energy_Consumption_kWh  FROM pumps p  JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID  JOIN usage_records u ON p.Pump_ID = u.pump_ID  WHERE u.Start_Time >= '2023-01-01 00:00:00' AND u.End_Time <= '2023-12-31 23:59:59';	waterPump	4
SELECT AVG(monthly_cost) AS average_monthly_maintenance_cost FROM (SELECT SUM(Cost) / 12 AS monthly_cost FROM maintenance_records WHERE Maintenance_Date >= date('now', '-1 year') GROUP BY strftime('%Y', Maintenance_Date), strftime('%m', Maintenance_Date)) AS monthly_costs;	waterPump	1
SELECT Pump_ID, (10000 * Head * 9.81) / (Efficiency / 100) / 3600 AS New_Power FROM pump_specifications;	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT Power * 24 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 30 AND Power = 15;	waterPump	4
SELECT Pump_ID, Model_Number, Manufacturer, Purchase_date, Warranty_Period, Location, Status, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') < datetime('now') THEN 'Out of Warranty' ELSE 'Under Warranty' END AS Warranty_Status FROM pumps WHERE Pump_ID IN (SELECT Pump_ID FROM usage_records WHERE Usage_Hours > (Warranty_Period * 30 * 24));	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT SUM(Power * Usage_Hours) AS Total_Energy_Consumption FROM usage_records JOIN pump_specifications ON usage_records.pump_ID = pump_specifications.Pump_ID WHERE pump_specifications.Flow_Rate = 200 AND pump_specifications.Head = 30 AND pump_specifications.Power = 15 AND usage_records.Usage_Hours = 8 * 365;	waterPump	1
SELECT (Flow_Rate * Head * 10 * 1000) / (Power * 3600 * 1000) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;	waterPump	3
SELECT 1000 * 100 * 365.25 * 24 AS total_energy_consumption;	waterPump	4
SELECT SUM(ps.power * 8 * 365) AS total_energy_consumption FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE p.Status = 'active';	waterPump	2
WITH avg_cost AS (     SELECT AVG(Cost) AS avg_maintenance_cost     FROM maintenance_records     WHERE Pump_ID = ? ) SELECT      avg_maintenance_cost,     avg_maintenance_cost * 5 AS total_future_cost FROM avg_cost;	waterPump	2
SELECT ps.Pump_ID, SUM(ps.power * 8 * 365) AS Total_Energy_Consumption FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE p.Status = 'active' GROUP BY ps.Pump_ID;	waterPump	3
WITH MaintenanceCosts AS (SELECT Cost FROM maintenance_records WHERE pump_ID = 'specified pump ID' ORDER BY Maintenance_Date DESC LIMIT 10) SELECT AVG(Cost) AS Average_Maintenance_Cost, AVG(Cost) * 5 * 10 AS Predicted_Total_Maintenance_Cost_Next_5_Years FROM MaintenanceCosts;	waterPump	4
SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') >= '2023-01-01' THEN 'Under warranty' ELSE 'Not under warranty' END AS Warranty_Status FROM pumps WHERE Purchase_date = '2021-01-01' AND Warranty_Period = 24;	waterPump	1
SELECT Power AS Theoretical_Output_Power, (Flow_Rate * Head * 9.81) / 3600 AS Actual_Output_Power, Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000 AND Voltage = 10000 AND Current = 1000 AND Efficiency = 200;	waterPump	2
SELECT Power * Efficiency / 100.0 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 30 AND Power = 50 AND Voltage = 220 AND Current = 200 AND Efficiency = 80;	waterPump	3
SELECT (Power * (Usage_Hours * 30) * 0.8) AS monthly_electricity_cost FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 300 AND Head = 50 AND Power = 75 AND Voltage = 400 AND Current = 120 AND Efficiency = 90 AND Usage_Hours = 10;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID WHERE ps.Flow_Rate >= 200 AND ps.Head >= 30 AND ps.Power >= 50 AND ps.Voltage = 220 AND ps.Current = 200 AND ps.Efficiency >= 80 AND p.Status = 'active';	waterPump	1
SELECT      CASE          WHEN DATE(Purchase_Date, '+' || Warranty_Period || ' months') >= '2023-06-01' THEN 'Yes'          ELSE 'No, exceeded by ' || JULIANDAY('2023-06-01') - JULIANDAY(DATE(Purchase_Date, '+' || Warranty_Period || ' months')) || ' days'      END AS warranty_status  FROM pumps  WHERE Warranty_Period = 36 AND Purchase_Date = '2020-01-01';	waterPump	2
SELECT (Power * Efficiency / 100) AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Voltage = 220 AND Current = 45 AND Efficiency = 85;	waterPump	3
SELECT Pump_ID, Purchase_date, Warranty_Period, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') >= '2023-06-01' THEN 'In warranty period' ELSE 'Out of warranty period' END AS Warranty_Status, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') < '2023-06-01' THEN julianday('2023-06-01') - julianday(date(Purchase_date, '+' || Warranty_Period || ' months')) ELSE 0 END AS Days_Out_of_Warranty FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 36;	waterPump	4
SELECT Pump_ID, Maintenance_Date, Maintenance_Type, Cost  FROM maintenance_records  WHERE Pump_ID = (SELECT Pump_ID FROM maintenance_records WHERE Maintenance_Date = '2023-01-01' AND Maintenance_Type = 'Replace parts' AND Cost = 5000)  ORDER BY Maintenance_Date DESC  LIMIT 1;	waterPump	1
SELECT Power * (Efficiency / 100.0) * 8 * 30 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 120 AND Head = 60 AND Power = 12 AND Voltage = 220 AND Current = 50 AND Efficiency = 90;	waterPump	2
SELECT (Power * 1000 * Usage_Hours) / Efficiency AS Actual_Energy_Consumption FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Voltage = 1000 AND Current = 1000 AND Efficiency = 100 AND Usage_Hours = 1000;	waterPump	4
SELECT (Power * 8 * 30) AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Efficiency = 80;	waterPump	1
SELECT Power * 1000 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Voltage = 1000 AND Current = 1000 AND Efficiency = 100;	waterPump	2
SELECT DATE(Purchase_Date, '+' || Warranty_Period || ' months') AS Warranty_End_Date,         CASE WHEN '2023-06-01' <= DATE(Purchase_Date, '+' || Warranty_Period || ' months') THEN 'Yes' ELSE 'No' END AS Under_Warranty FROM pumps  WHERE Warranty_Period = 24 AND Purchase_Date = '2022-01-01';	waterPump	3
SELECT (1000 * 1000 * 9.81 * 1000) / 3600 AS actual_power;	waterPump	4
SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, date(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date, CASE WHEN '2023-06-01' <= date(Purchase_date, '+' || Warranty_Period || ' months') THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;	waterPump	2
SELECT (Flow_Rate * Head * 1000 * 9.81) / 3600000 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Efficiency = 100;	waterPump	1
WITH AvgCosts AS (SELECT Pump_ID, AVG(Cost) AS AvgCost FROM maintenance_records GROUP BY Pump_ID),      AvgHours AS (SELECT Pump_ID, AVG(Usage_Hours) AS AvgHours FROM usage_records GROUP BY Pump_ID) SELECT p.Pump_ID, (ac.AvgCost / ah.AvgHours) AS CostToUsageRatio FROM pumps p JOIN AvgCosts ac ON p.Pump_ID = ac.Pump_ID JOIN AvgHours ah ON p.Pump_ID = ah.Pump_ID ORDER BY CostToUsageRatio ASC LIMIT 10;	waterPump	2
SELECT y.Model, COUNT(v.Voyage_ID) AS Voyage_Count FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID WHERE v.Wind_Speed > 30 AND v.Wave_Height > 2 GROUP BY y.Model ORDER BY Voyage_Count DESC LIMIT 1;	yacht	3
SELECT y.Yacht_ID, y.Model, 1000000.0 / (p.Fuel_Efficiency * y.Max_Speed) AS Sailing_Time FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID WHERE 1000000.0 / (p.Fuel_Efficiency * y.Max_Speed) > 1000.0;	yacht	4
SELECT Yacht_ID, Model, (Displacement * 9.81) / (Weight * 9.81) AS Buoyancy_Gravity_Ratio FROM yachts WHERE (Displacement * 9.81) / (Weight * 9.81) > 1 ORDER BY Buoyancy_Gravity_Ratio DESC LIMIT 5;	yacht	1
SELECT v.Yacht_ID, y.Model, v.Fuel_Consumed * v.Distance AS Fuel_Distance_Product FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID ORDER BY Fuel_Distance_Product DESC LIMIT 10;	yacht	2
SELECT Yacht_ID, Model, Year, Engine_Type, Price FROM yachts WHERE Year > 2015 AND Engine_Type = 'diesel' ORDER BY Price DESC;	yacht	3
SELECT Yacht_ID, Model, (5000000 / Fuel_Efficiency) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Efficiency) > 10000;	yacht	4
SELECT Yacht_ID, Model, 0.5 * (Weight * 1000) * (Max_Speed * 0.514444) * (Max_Speed * 0.514444) AS Kinetic_Energy FROM yachts ORDER BY Kinetic_Energy DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, Model, (5000000 / Fuel_Capacity) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Capacity) > 10000 ORDER BY Max_Distance ASC LIMIT 10;	yacht	2
SELECT Yacht_ID, Model, Year, Hull_Material FROM yachts WHERE Year < 2010 AND Hull_Material = 'fiberglass' ORDER BY Year ASC;	yacht	3
SELECT Yacht_ID,  (1000000 / (Fuel_Efficiency / "Range")) AS Sailing_Time_Hours FROM performance_metrics WHERE (1000000 / (Fuel_Efficiency / "Range")) > 1000 ORDER BY Sailing_Time_Hours DESC;	yacht	4
SELECT Yacht_ID, Model, 0.5 * 1025 * Drag_Coefficient * (Length * Width) * POWER(Max_Speed * 0.514444, 3) AS Drag_Power FROM yachts ORDER BY Drag_Power DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, (Total_Energy_Consumed / Distance) AS Energy_Ratio FROM voyages WHERE Distance > 0 ORDER BY Energy_Ratio DESC LIMIT 10;	yacht	2
SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Efficiency FROM yachts WHERE Year > 2015 AND Engine_Type = 'diesel' ORDER BY Fuel_Efficiency ASC;	yacht	3
SELECT Yacht_ID, Model, (10000000.0 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000.0 / Fuel_Efficiency) > 50000.0;	yacht	4
SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Capacity FROM yachts WHERE Year > 2015 AND Engine_Type = 'diesel' ORDER BY Fuel_Capacity ASC;	yacht	1
SELECT Yacht_ID, (10000000 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000 / Fuel_Efficiency) > 50000;	yacht	2
SELECT Fuel_Capacity, (1000 / Fuel_Efficiency) AS Required_Fuel FROM yachts WHERE Yacht_ID = 'specific_yacht_ID';	yacht	3
SELECT Yacht_ID, Model, (Fuel_Efficiency / "Range") AS Efficiency_Ratio FROM performance_metrics ORDER BY Efficiency_Ratio DESC LIMIT 5;	yacht	4
SELECT Model, Year, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 20 ORDER BY Price DESC;	yacht	1
SELECT y.Yacht_ID, y.Model, p.Fuel_Efficiency / y.Max_Speed AS Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID ORDER BY Fuel_Consumption_Rate ASC LIMIT 10;	yacht	2
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity / p.Fuel_Efficiency * y.Max_Speed AS Max_Range  FROM yachts y  JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID  ORDER BY Max_Range DESC  LIMIT 3;	yacht	3
SELECT 100000 / (500 * 50 * 1) AS Draft, CASE WHEN 100000 / (500 * 50 * 1) > 50 THEN 'Cannot float normally' ELSE 'Can float normally' END AS Status;	yacht	4
SELECT Hull_Material, AVG(Displacement / (Length * Width * 1)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;	yacht	1
SELECT y.Engine_Type, AVG(p.Fuel_Efficiency / y.Max_Speed) AS Avg_Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY y.Engine_Type;	yacht	2
SELECT Manufacturer_ID, AVG(Fuel_Capacity / Fuel_Efficiency * Max_Speed) AS Avg_Max_Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY Manufacturer_ID;	yacht	3
SELECT Hull_Material, AVG(1000000.0 / (1000.0 * 100.0 * 1.0)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;	yacht	4
SELECT Voyage_ID, Yacht_ID, Fuel_Consumed / Distance AS Fuel_Efficiency FROM voyages ORDER BY Fuel_Efficiency ASC LIMIT 5;	yacht	1
SELECT Yacht_ID, SUM(Fuel_Consumed) / SUM(Distance) AS Avg_Fuel_Efficiency FROM voyages GROUP BY Yacht_ID;	yacht	2
SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Fuel_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Yacht_ID, Buoyancy_Force / Displacement AS Buoyancy_Ratio FROM yachts ORDER BY Buoyancy_Ratio DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, SUM(Total_Energy_Consumed) * 1.0 / SUM(Distance) AS Avg_Energy_Efficiency FROM voyages GROUP BY Yacht_ID;	yacht	2
SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID WHERE v.Weather_Conditions IN ('strong winds', 'heavy waves') GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Energy_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT c.Charter_Type, AVG(v.Fuel_Consumed / v.Distance) AS Avg_Fuel_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY c.Charter_Type;	yacht	1
SELECT v.Yacht_ID, SUM(c.Total_Cost) * 1.0 / SUM(v.Distance) AS Avg_Charter_Cost_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY v.Yacht_ID;	yacht	2
SELECT c.Charter_Type, AVG(v.Distance) AS Avg_Distance FROM charters c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Charter_Type ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Charter_Cost_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Yacht_ID, AVG(Salary) / AVG(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;	yacht	1
SELECT Yacht_ID, SUM(Salary) * 1.0 / SUM(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;	yacht	2
SELECT Role, AVG(Salary) AS Avg_Salary FROM crew GROUP BY Role ORDER BY Avg_Salary DESC LIMIT 1;	yacht	3
SELECT 1000000 * 12 / 100 AS Salary_Efficiency, CASE WHEN 1000000 * 12 / 100 < 1000 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Yacht_ID, 0.5 * Weight * 1000 * POWER(Max_Speed * 0.5144, 2) AS Kinetic_Energy FROM yachts;	yacht	1
SELECT c.Yacht_ID, (SUM(c.Salary) / y.Price) * 100 AS Crew_Salary_Ratio FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Yacht_ID;	yacht	2
SELECT c.Role, AVG(y.Passenger_Capacity) AS Avg_Passenger_Per_Role FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Role ORDER BY Avg_Passenger_Per_Role DESC LIMIT 1;	yacht	3
SELECT 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) AS Kinetic_Energy, CASE WHEN 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) > 1e12 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Displacement, Buoyancy_Force FROM yachts WHERE Yacht_ID = ?;	yacht	1
SELECT Max_Speed, Engine_Power, Fuel_Efficiency FROM yachts WHERE Yacht_ID = ?;	yacht	2
SELECT Model, Year, Hull_Material, Passenger_Capacity, Price FROM yachts WHERE Hull_Material = 'carbon fiber' AND Passenger_Capacity > 10 ORDER BY Year ASC;	yacht	3
SELECT Model, Engine_Type, Engine_Power, Fuel_Capacity, Max_Speed FROM yachts WHERE Engine_Power > 500 AND Fuel_Capacity > 5000 ORDER BY Max_Speed DESC;	yacht	4
SELECT Model, Year, Price, Hull_Material FROM yachts WHERE Year >= 2018 AND Price < 1000000 ORDER BY Price ASC;	yacht	1
SELECT Yacht_ID, (Fuel_Efficiency / "Range") AS Fuel_Consumption_Rate FROM performance_metrics ORDER BY Fuel_Consumption_Rate ASC LIMIT 3;	yacht	2
SELECT Yacht_ID, (Fuel_Efficiency / "Range") * 100 AS Total_Fuel_Consumption FROM performance_metrics ORDER BY Total_Fuel_Consumption DESC LIMIT 5;	yacht	3
SELECT Yacht_ID, (Fuel_Efficiency / "Range") AS Fuel_Consumption_per_Kilometer FROM performance_metrics ORDER BY Fuel_Consumption_per_Kilometer ASC LIMIT 3;	yacht	4
SELECT Passenger_Capacity, Water_Capacity FROM yachts WHERE Yacht_ID = 1;	yacht	1
SELECT Engine_Power, Fuel_Efficiency, Fuel_Capacity FROM yachts WHERE Yacht_ID = 2;	yacht	2
SELECT 0.5 * (Displacement * 1000) * POWER((Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts WHERE Yacht_ID = 1;	yacht	3
SELECT (Fuel_Capacity / Fuel_Efficiency) AS Actual_Range, "Range" AS Designed_Range FROM yachts JOIN performance_metrics ON yachts.Yacht_ID = performance_metrics.Yacht_ID WHERE yachts.Yacht_ID = 1;	yacht	4
SELECT Water_Capacity, Passenger_Capacity * 50 * 7 AS Total_Water_Needed FROM yachts WHERE Yacht_ID = 1;	yacht	1
SELECT (Fuel_Capacity / 1000) * 50 AS Possible_Distance, 8000 AS Required_Distance FROM yachts WHERE Yacht_ID = 1;	yacht	2
SELECT Hull_Material, AVG(Price) AS Avg_Price FROM yachts GROUP BY Hull_Material;	yacht	3
SELECT Model, Length, Max_Speed FROM yachts WHERE Length > 30;	yacht	4
SELECT Model, Length, Width FROM yachts WHERE Hull_Material = 'Fiberglass';	yacht	1
SELECT Model, Year, Hull_Material FROM yachts WHERE Year > 2020;	yacht	2
SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity;	yacht	3
SELECT y.*, y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) AS Fuel_Consumption_Time FROM yachts y WHERE y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) > 1000;	yacht	4
SELECT y.*, 0.5 * (y.Displacement * 1000) * POWER((y.Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts y ORDER BY Kinetic_Energy DESC LIMIT 5;	yacht	1
WITH Fuel_Rate AS (     SELECT          y.Yacht_ID,          y.Model,          v.Fuel_Consumed / v.Distance AS Fuel_Consumption_Rate      FROM          yachts y      JOIN          voyages v ON y.Yacht_ID = v.Yacht_ID )  SELECT * FROM (     SELECT          *,          ROW_NUMBER() OVER (PARTITION BY Yacht_ID ORDER BY Fuel_Consumption_Rate ASC) AS rn      FROM          Fuel_Rate )  WHERE rn = 1;	yacht	2
WITH Overloaded_Charters AS (SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity) SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY Charter_Type ORDER BY Total_Cost DESC) AS rn FROM Overloaded_Charters) WHERE rn = 1;	yacht	3
SELECT Model, Price, Max_Speed FROM yachts WHERE Price > 5000000;	yacht	4
SELECT Model, Engine_Power, Fuel_Capacity FROM yachts WHERE Engine_Type = 'Inboard';	yacht	1
SELECT y.Yacht_ID, y.Model, y.Passenger_Capacity, COUNT(DISTINCT c.Customer_ID) AS Customer_Count, COUNT(DISTINCT cr.Crew_ID) AS Crew_Count  FROM yachts y  JOIN charters ch ON y.Yacht_ID = ch.Yacht_ID  JOIN customers c ON ch.Customer_ID = c.Customer_ID  JOIN crew cr ON y.Yacht_ID = cr.Yacht_ID  GROUP BY y.Yacht_ID  HAVING (COUNT(DISTINCT c.Customer_ID) + COUNT(DISTINCT cr.Crew_ID)) <= y.Passenger_Capacity * 0.8;	yacht	2
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed);	yacht	3
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed) AND y.Engine_Power = 100000;	yacht	4
SELECT Displacement / (Length * Width * 1.0) AS Draft FROM yachts WHERE Yacht_ID = 'specific_yacht_ID';	yacht	1
SELECT (Total_Cost * 0.8 * 0.85) + (Total_Cost * 0.2) AS Actual_Payment FROM charters WHERE Customer_ID = 'specific customer ID' AND strftime('%Y', Start_Date) = '2023';	yacht	2
SELECT Voyage_ID, Yacht_ID, Average_Speed FROM voyages WHERE Average_Speed > (SELECT Max_Speed FROM yachts WHERE yachts.Yacht_ID = voyages.Yacht_ID);	yacht	3
SELECT (Fuel_Capacity / Fuel_Efficiency) / (24 * 365) AS Fuel_Support_Years FROM yachts WHERE Yacht_ID = 'specific_yacht_ID';	yacht	4
SELECT Model, 0.5 * (Weight * 1000) * ((Max_Speed * 0.514444) * (Max_Speed * 0.514444)) AS Kinetic_Energy FROM yachts WHERE 0.5 * (Weight * 1000) * ((Max_Speed * 0.514444) * (Max_Speed * 0.514444)) > 100000000;	yacht	1
SELECT Model, Length, Year FROM yachts WHERE Length BETWEEN 20 AND 30;	yacht	2
SELECT y.Model, y.Hull_Material, y.Engine_Type FROM yachts y JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE v.Wave_Height > 3 AND v.Wind_Speed > 30;	yacht	3
SELECT y.Model, (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 AS Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 > 1000000;	yacht	4
WITH KineticEnergy AS (     SELECT Model, Hull_Material, 0.5 * (Weight * 1000) * ((Max_Speed * 0.514444) * (Max_Speed * 0.514444)) AS Kinetic_Energy      FROM yachts ) SELECT Hull_Material, Model, MAX(Kinetic_Energy) AS Max_Kinetic_Energy  FROM KineticEnergy  GROUP BY Hull_Material;	yacht	1
SELECT Model, Max_Speed, Price FROM yachts WHERE Max_Speed > 35;	yacht	2
SELECT Model, Fuel_Capacity, Hull_Material FROM yachts WHERE Fuel_Capacity > 1000;	yacht	3
SELECT Model, Passenger_Capacity, Price FROM yachts WHERE Passenger_Capacity > 12;	yacht	4
WITH BuoyancyRatio AS (   SELECT Model, Hull_Material, Buoyancy_Force / (Weight * 1000.0 * 9.81) AS Buoyancy_Ratio    FROM yachts )  SELECT Hull_Material, Model, MIN(Buoyancy_Ratio) AS Min_Buoyancy_Ratio  FROM BuoyancyRatio  GROUP BY Hull_Material;	yacht	1
SELECT Model, Displacement, Max_Speed FROM yachts WHERE Displacement > 50;	yacht	2
SELECT Model, Buoyancy_Force, Center_of_Gravity FROM yachts WHERE Buoyancy_Force > 100000;	yacht	3
SELECT Model, Drag_Coefficient, Hull_Speed FROM yachts WHERE Drag_Coefficient < 0.5;	yacht	4
WITH KineticEnergy AS (     SELECT          y.Model,          y.Hull_Material,          0.5 * (y.Weight * 1000) * ((y.Max_Speed * 0.514444) * (y.Max_Speed * 0.514444)) AS Kinetic_Energy,          AVG(c.Salary) AS Avg_Salary      FROM yachts y      JOIN crew c ON y.Yacht_ID = c.Yacht_ID      GROUP BY y.Model, y.Hull_Material ) SELECT      Hull_Material,      Model,      MAX(Kinetic_Energy / Avg_Salary) AS Max_Ratio  FROM KineticEnergy  GROUP BY Hull_Material;	yacht	1
SELECT Model, Year, Price FROM yachts WHERE Manufacturer_ID = 1;	yacht	2
SELECT Model, Hull_Speed, Max_Speed FROM yachts WHERE Hull_Speed > 25;	yacht	3
SELECT Model, Weight, Displacement FROM yachts WHERE Weight > 100;	yacht	4
WITH KineticEnergy AS (   SELECT      y.Model,      0.5 * (y.Weight * 1000) * (y.Max_Speed * 0.514444) * (y.Max_Speed * 0.514444) AS Kinetic_Energy,      AVG(c.Salary) AS Avg_Salary    FROM yachts y    JOIN crew c ON y.Yacht_ID = c.Yacht_ID    GROUP BY y.Model )  SELECT Model, Kinetic_Energy / Avg_Salary AS Ratio  FROM KineticEnergy  ORDER BY Ratio DESC  LIMIT 5;	yacht	1
SELECT Model, Water_Capacity, Fuel_Capacity FROM yachts WHERE Water_Capacity > 500;	yacht	2
SELECT Model, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 35 ORDER BY Price DESC;	yacht	3
SELECT Model, Year, Hull_Material, Engine_Power FROM yachts WHERE Year > 2020 AND Hull_Material = 'Fiberglass' ORDER BY Engine_Power ASC;	yacht	4
SELECT (b.Voltage * b.Capacity) / m.Power AS Theoretical_Range_Time FROM Batteries b JOIN ElectricBikes eb ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.BikeID WHERE eb.Weight = 50 AND m.Power = 400 AND b.Voltage = 48 AND b.Capacity = 20;	electric_scooter	1
SELECT (b.Voltage * b.Capacity) / 0.05 AS Distance FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE b.Capacity = 15 AND b.Voltage = 36 AND m.Power = 250 AND bd.Wheel_Size = 12;	electric_scooter	2
SELECT Type, Voltage, Capacity FROM Batteries WHERE Voltage = 48 AND Capacity > 50 AND Type = 'Li-ion battery' ORDER BY Capacity DESC;	electric_scooter	3
SELECT Type, Voltage, Capacity, (SELECT SUM(Capacity) FROM Batteries WHERE Voltage IN (60, 72)) AS Total_Capacity FROM Batteries WHERE Voltage IN (60, 72);	electric_scooter	4
SELECT Type, Voltage, Capacity, SUM(Capacity) OVER () AS Total_Capacity FROM Batteries WHERE Voltage = 72 AND Capacity > 90 AND Type = 'Lithium Battery';	electric_scooter	1
SELECT (b.Voltage * b.Capacity) / 1 AS Distance, CASE WHEN b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 THEN 'Theoretically feasible, practically not feasible' ELSE 'Configuration anomaly' END AS Feasibility FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID WHERE b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 LIMIT 1;	electric_scooter	2
SELECT (bd.Length * bd.Width * bd.Height) AS Body_Volume FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 1800 AND bd.Width = 700 AND bd.Height = 1200 AND bd.Wheel_Size = 14;	electric_scooter	3
SELECT CASE WHEN 5000 <= 6000 AND 2000 <= 2500 AND 2500 <= 3000 THEN 'can be parked' ELSE 'cannot be parked' END AS Parking_Feasibility;	electric_scooter	4
SELECT DISTINCT CASE WHEN bd.Height <= 1500 THEN 'can pass through' ELSE 'cannot pass through' END AS Tunnel_Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.BikeID WHERE bd.Height = 1200 AND bd.WheelSize = 14;	electric_scooter	1
SELECT CASE WHEN bd.Length <= 6000 AND bd.Width <= 2500 AND bd.Height <= 3000 THEN 'can be parked' ELSE 'cannot be parked' END AS Parking_Feasibility, CASE WHEN bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30 THEN 'theoretically feasible, practically not feasible' ELSE 'configuration anomaly' END AS Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30;	electric_scooter	2
SELECT (cr.Energy_Used * 1000) / (220 * ((strftime('%s', cr.EndTime) - strftime('%s', cr.StartTime)))) AS Charging_Current FROM ChargingRecords cr WHERE cr.Energy_Used = 2;	electric_scooter	3
SELECT SUM(Cost) AS Total_Charging_Cost FROM ChargingRecords WHERE User_ID = 3 AND date(StartTime) = '2023-10-01';	electric_scooter	4
SELECT Energy_Used / 0.9 AS Actual_Energy_Consumed FROM ChargingRecords WHERE Energy_Used = 3 LIMIT 1;	electric_scooter	1
SELECT 1000 / (1000 * 1 * 0.5) AS Actual_Current;	electric_scooter	2
SELECT (Voltage * Capacity) / Distance AS EnergyPerKm FROM Batteries WHERE Voltage = 48 AND Capacity = 20 AND Distance = 60 LIMIT 1;	electric_scooter	3
SELECT (10000.0 / 1000.0) AS PowerToWeightRatio;	electric_scooter	4
SELECT 2.0 / 2.0 AS AveragePower;	electric_scooter	1
SELECT SUM(Energy_Used) AS TotalEnergyUsed, AVG(Energy_Used) AS AvgEnergyUsed FROM ChargingRecords WHERE User_ID = ? AND strftime('%Y-%m', StartTime) = ?;	electric_scooter	2
SELECT Energy_Used / ((strftime('%s', EndTime) - strftime('%s', StartTime)) / 3600.0) AS AveragePower FROM ChargingRecords WHERE Energy_Used = 2 AND (strftime('%s', EndTime) - strftime('%s', StartTime)) = 7200;	electric_scooter	3
SELECT SUM(Energy_Used) AS TotalEnergyUsed, AVG(Energy_Used) AS AverageEnergyPerCharge FROM ChargingRecords WHERE User_ID = 101 AND StartTime >= '2023-10-01 00:00:00' AND StartTime <= '2023-10-31 23:59:59';	electric_scooter	4
SELECT AVG(Cost) AS AverageCost FROM MaintenanceRecords WHERE Description = 'battery replacement';	electric_scooter	1
SELECT SUM(Cost) AS TotalCost, AVG(Cost) AS AverageCost FROM MaintenanceRecords;	electric_scooter	2
SELECT AVG(Cost) AS AverageCost FROM MaintenanceRecords WHERE Description = 'Replace battery' AND Bike_ID = 1;	electric_scooter	3
SELECT SUM(Cost) AS TotalMaintenanceCost, AVG(Cost) AS AverageCostPerMaintenance FROM MaintenanceRecords WHERE BikeID = 1 AND MaintenanceDate >= '2023-01-01' AND MaintenanceDate <= '2023-12-31';	electric_scooter	4
SELECT Maintenance_Date FROM MaintenanceRecords WHERE Technician = 'Master Zhang';	electric_scooter	1
SELECT SUM(Cost) AS TotalMaintenanceCost, CASE WHEN SUM(Cost) = 500 * COUNT(*) THEN 'Reasonable' ELSE 'Unreasonable' END AS IsReasonable FROM MaintenanceRecords WHERE Description = 'battery replacement' AND Bike_ID = 201 AND Maintenance_Date >= '2023-01-01' AND Maintenance_Date <= '2023-12-31';	electric_scooter	2
SELECT 7 * Available_Slots AS TotalPower FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;	electric_scooter	3
SELECT (1000 * 1000 * 24) AS TotalEnergyConsumption, (1000 * 1000 * 24 * (SELECT Cost / Energy_Used FROM ChargingRecords LIMIT 1)) AS TotalCost LIMIT 1;	electric_scooter	4
SELECT COUNT(*) FROM Users WHERE strftime('%Y-%m', CreatedAt) = '2023-10';	electric_scooter	1
SELECT COUNT(*) FROM Users u1, Users u2 WHERE ABS(JULIANDAY(u1.CreatedAt) - JULIANDAY(u2.CreatedAt)) <= 1 AND u1.User_ID < u2.User_ID;	electric_scooter	2
SELECT COUNT(DISTINCT Address) AS UserCount FROM Users WHERE date(CreatedAt) >= '2023-10-01' AND date(CreatedAt) <= '2023-10-31';	electric_scooter	3
SELECT COUNT(DISTINCT u2.User_ID) AS UserCount FROM Users u1 JOIN Users u2 ON ABS(julianday(u1.CreatedAt) - julianday(u2.CreatedAt)) <= 1 AND u1.User_ID != u2.User_ID WHERE u1.Username = 'Zhang San' AND u1.Address LIKE '%Beijing Chaoyang District%';	electric_scooter	4
SELECT COUNT(DISTINCT Address) AS DistinctRegionCount FROM Users;	electric_scooter	1
SELECT COUNT(*) AS SameRegionUserCount FROM users WHERE Address = (SELECT Address FROM users WHERE Username = 'Zhang San');	electric_scooter	2
SELECT Voltage * Capacity AS Energy FROM Batteries WHERE Voltage = 48 AND Capacity = 20;	electric_scooter	3
SELECT (1000 * 1000) AS StoredEnergy, (1000 * 1000) / 10000 AS Duration;	electric_scooter	4
SELECT (Voltage * Capacity) / 500 AS RunTime FROM Batteries WHERE Capacity = 20 AND Voltage = 48;	electric_scooter	1
SELECT COUNT(*) AS ItemCount, Manufacturer AS Supplier  FROM ElectricBikes  GROUP BY Manufacturer  ORDER BY ItemCount DESC  LIMIT 5;	electric_scooter	2
SELECT Devices.deviceId AS itemId, Devices.deviceName AS itemName, Devices.deviceType AS specification, Labs.location AS storageLocation FROM Devices JOIN Labs ON Devices.labId = Labs.labId WHERE Labs.location = 'specific area';	PhysicsLabDB	3
SELECT deviceId, (SUM(energyConsumed) / (SUM(powerUsage) * (JULIANDAY(MAX(timestamp)) - JULIANDAY(MIN(timestamp))) * 24) * 100 AS efficiency FROM EnergyConsumption GROUP BY deviceId ORDER BY efficiency ASC LIMIT 5;	EnergyManagementDB	4
SELECT deviceId, (STDDEV(energyConsumed) / AVG(energyConsumed) * 100) AS fluctuationRate FROM EnergyConsumption GROUP BY deviceId ORDER BY fluctuationRate DESC LIMIT 10;	EnergyManagementDB	1
SELECT location, COUNT(*) AS itemCount FROM EnergyDevices GROUP BY location ORDER BY itemCount ASC LIMIT 5;	EnergyManagementDB	2
SELECT d.itemName, d.specifications, s.supplierName FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE d.status = 'Under Maintenance';	PhysicsLabDB	3
SELECT d.deviceType, COUNT(d.deviceId) * 10 * 365 AS totalWarrantyExtensionDays FROM Devices d GROUP BY d.deviceType ORDER BY totalWarrantyExtensionDays DESC LIMIT 3;	PhysicsLabDB	4
SELECT d.deviceName, d.deviceType, s.supplierName FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE d.status = 'fault' ORDER BY julianday('now') - julianday(d.calibrationDate) ASC;	PhysicsLabDB	1
SELECT s.supplierName, COUNT(DISTINCT d.deviceType) AS specificationCount FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierName ORDER BY specificationCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, warrantyEndDate FROM Devices WHERE warrantyEndDate >= date('now');	PhysicsLabDB	3
SELECT s.supplierId, COUNT(d.deviceType) * 1000 AS totalMaintenanceCost FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierId ORDER BY totalMaintenanceCost DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceName, deviceType, julianday(warrantyEndDate) - julianday(purchaseDate) AS totalWarrantyDays FROM Devices ORDER BY totalWarrantyDays DESC;	PhysicsLabDB	1
SELECT m.country, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.country ORDER BY deviceCount ASC LIMIT 5;	EnergyManagementDB	2
SELECT itemName, specifications, storageLocation FROM Devices WHERE status = 'Disabled';	PhysicsLabDB	3
SELECT d.supplierId, SUM(dt.maintenanceCost) * 0.1 AS totalMaintenanceCost FROM Devices d JOIN DeviceTypes dt ON d.deviceType = dt.deviceType GROUP BY d.supplierId ORDER BY totalMaintenanceCost ASC LIMIT 3;	PhysicsLabDB	4
SELECT d.deviceName, CAST((julianday('now') - julianday(d.calibrationDate)) AS INTEGER) AS unmaintainedDays FROM Devices d WHERE d.status = 'inactive' ORDER BY unmaintainedDays DESC;	PhysicsLabDB	1
SELECT m.manufacturerName, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.manufacturerName ORDER BY deviceCount DESC LIMIT 5;	EnergyManagementDB	2
SELECT d.itemName, d.specifications, d.purchaseDate FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE s.supplierName = 'a certain supplier';	PhysicsLabDB	3
SELECT d.supplierId, SUM((julianday(d.warrantyEndDate) - julianday(d.purchaseDate)) * 0.5) AS totalWarrantyReduction FROM Devices d GROUP BY d.supplierId ORDER BY totalWarrantyReduction DESC LIMIT 3;	PhysicsLabDB	4
SELECT i.itemName, i.purchaseDate, i.energyConsumption FROM Devices i ORDER BY i.energyConsumption DESC;	PhysicsLabDB	1
SELECT dt.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumption FROM EnergyConsumption ec JOIN Devices d ON ec.deviceId = d.deviceId JOIN DeviceTypes dt ON d.deviceType = dt.deviceType GROUP BY dt.deviceType ORDER BY totalEnergyConsumption ASC LIMIT 3;	PhysicsLabDB	2
SELECT deviceName, deviceType, powerRating FROM EnergyDevices WHERE powerRating > 100 ORDER BY powerRating DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 10) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	4
SELECT deviceName, deviceType, power FROM Devices WHERE power > 100 ORDER BY power DESC;	PhysicsLabDB	1
SELECT supplierId, COUNT(*) AS deviceCount FROM Devices GROUP BY supplierId ORDER BY deviceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = 'fault';	PhysicsLabDB	3
SELECT deviceType, SUM(power * 100) AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceName, deviceType, SUM(current) AS totalCurrent FROM Devices GROUP BY deviceName, deviceType ORDER BY totalCurrent DESC;	PhysicsLabDB	1
SELECT deviceType, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY avgEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE (julianday('now') - julianday(installationDate)) > 5 * 365;	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;	PhysicsLabDB	1
SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, temperature  FROM EnergyConsumption  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  WHERE temperature > 50 OR temperature < -20  ORDER BY temperature;	EnergyManagementDB	3
SELECT deviceType, SUM(cost) * 1000 AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerRatio DESC;	EnergyManagementDB	1
SELECT manufacturerId, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY manufacturerId ORDER BY avgEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, humidity FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId WHERE humidity < 0 OR humidity > 100 ORDER BY humidity DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerDifference DESC;	EnergyManagementDB	1
SELECT deviceType, COUNT(deviceId) AS maintenanceCount FROM Devices WHERE status IN ('under maintenance', 'faulty') GROUP BY deviceType ORDER BY maintenanceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, lastMaintenanceDate FROM EnergyDevices JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId WHERE julianday('now') - julianday(lastMaintenanceDate) > 365 ORDER BY lastMaintenanceDate DESC;	EnergyManagementDB	3
SELECT deviceType, COUNT(maintenanceId) * 100 AS totalMaintenanceCount FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCount DESC LIMIT 3;	EnergyManagementDB	4
SELECT d.deviceName, d.deviceType, (ec.powerUsage / d.powerRating) * 100 AS powerPercentage FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId ORDER BY powerPercentage DESC;	EnergyManagementDB	1
SELECT d.deviceType, SUM(ec.energyConsumed) * 1.0 / SUM(mr.cost) AS energyToCostRatio FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId JOIN MaintenanceRecords mr ON mr.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY energyToCostRatio ASC LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, ec.temperature FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId WHERE ec.temperature > 30 ORDER BY ec.temperature DESC;	EnergyManagementDB	3
SELECT d.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed  FROM EnergyConsumption ec  JOIN EnergyDevices d ON ec.deviceId = d.deviceId  GROUP BY d.deviceType  ORDER BY totalEnergyConsumed DESC  LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerSquareRatio DESC;	EnergyManagementDB	1
SELECT d.deviceType, SUM(ec.energyConsumed) * 1.0 / COUNT(mr.maintenanceId) AS energyMaintenanceRatio  FROM EnergyConsumption ec  JOIN EnergyDevices d ON ec.deviceId = d.deviceId  JOIN MaintenanceRecords mr ON ec.deviceId = mr.deviceId  GROUP BY d.deviceType  ORDER BY energyMaintenanceRatio ASC  LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, d.humidity FROM EnergyDevices d WHERE d.humidity < 20 ORDER BY d.humidity ASC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 1.8) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerCubicRatio DESC;	EnergyManagementDB	1
SELECT deviceType, SUM(energyConsumed * 1.8) / (SUM(cost) * SUM(cost)) AS energyMaintenanceRatioSquare  FROM EnergyConsumption  JOIN MaintenanceRecords ON EnergyConsumption.deviceId = MaintenanceRecords.deviceId  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY energyMaintenanceRatioSquare ASC  LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, voltage FROM EnergyDevices WHERE voltage < 200 ORDER BY voltage DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 500) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerFourthRatio DESC;	EnergyManagementDB	1
SELECT deviceType, (SUM(energyConsumed) / (COUNT(maintenanceId) * COUNT(maintenanceId) * COUNT(maintenanceId))) AS energyMaintenanceCubeRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId GROUP BY deviceType ORDER BY energyMaintenanceCubeRatio ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, current FROM EnergyDevices WHERE current > 10 ORDER BY current DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed) AS totalEnergyConsumed  FROM EnergyConsumption  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY totalEnergyConsumed DESC  LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, SUM(energyConsumed) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS dailyAvgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceId, deviceName ORDER BY dailyAvgEnergyConsumed DESC;	EnergyManagementDB	1
SELECT deviceType, SUM(current * 5 * voltage * 24 / 1000) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed ASC LIMIT 3;	EnergyManagementDB	2
SELECT EnergyDevices.deviceName, EnergyDevices.deviceType, EnergyDevices.powerRating  FROM EnergyDevices  WHERE EnergyDevices.powerRating > 100;	EnergyManagementDB	3
SELECT ed.deviceType, SUM(ec.energyConsumed * (ed.powerRating * 10) / ed.powerRating) AS totalEnergyConsumed FROM EnergyConsumption AS ec JOIN EnergyDevices AS ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	4
SELECT SUM(ed.measurementValue) AS totalPower FROM Devices d JOIN ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = 'watt' ORDER BY totalPower DESC;	PhysicsLabDB	1
SELECT supplierId, COUNT(*) AS deviceCount FROM Devices GROUP BY supplierId ORDER BY deviceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = 'Fault';	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumption) * 100 AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceType, COUNT(*) * 10 AS totalCurrent FROM Devices GROUP BY deviceType ORDER BY totalCurrent DESC;	PhysicsLabDB	1
SELECT deviceType, AVG(energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY averageEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE julianday('now') - julianday(installationDate) > 5 * 365;	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;	PhysicsLabDB	1
SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, ec.temperature  FROM EnergyDevices d  JOIN EnergyConsumption ec ON d.deviceId = ec.deviceId  WHERE ec.temperature IS NOT NULL  AND (ec.temperature < -273.15 OR ec.temperature > 1000);	EnergyManagementDB	3
SELECT deviceType, SUM(cost) * 1000 AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio  FROM EnergyConsumption  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  ORDER BY powerRatio DESC;	EnergyManagementDB	1
SELECT m.manufacturerName, AVG(ec.energyConsumed) AS avgEnergyConsumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId GROUP BY m.manufacturerName ORDER BY avgEnergyConsumption ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, humidity FROM EnergyDevices WHERE humidity IS NOT NULL AND humidity < 0;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerDifference DESC;	EnergyManagementDB	1
SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount  FROM Experiments e JOIN Researchers r ON e.researcherId = r.researcherId JOIN Labs l ON e.labId = l.labId WHERE r.role = 'data analyst' AND e.status = 'in progress' ORDER BY e.startDate ASC;	PhysicsLabDB	2
SELECT deviceName, powerRating, location FROM EnergyDevices WHERE deviceType = 'Solar' AND status = 'In Operation' ORDER BY powerRating DESC;	EnergyManagementDB	3
SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;	EnergyManagementDB	4
SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 500 ORDER BY timestamp ASC;	EnergyManagementDB	1
SELECT deviceId, carbonFootprint, energySource FROM EnvironmentalImpact WHERE carbonFootprint > 1000 ORDER BY carbonFootprint DESC;	EnergyManagementDB	2
SELECT deviceId, efficiency, energySaved FROM EnergyEfficiency WHERE efficiency > 90 ORDER BY energySaved DESC;	EnergyManagementDB	3
SELECT deviceId, maintenanceDate, cost FROM MaintenanceRecords WHERE maintenanceType = 'Emergency Repair' ORDER BY maintenanceDate DESC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerSquareRatio DESC;	EnergyManagementDB	1
SELECT deviceId, forecastValue, timestamp FROM EnergyForecasts WHERE forecastType = 'Energy Consumption Forecast' AND confidenceLevel > 95 ORDER BY forecastValue DESC;	EnergyManagementDB	2
SELECT policyName, targetEfficiency, targetCarbonFootprint FROM EnergyPolicies WHERE targetEfficiency > 85 ORDER BY targetEfficiency DESC;	EnergyManagementDB	3
SELECT deviceId, auditDate, recommendations FROM EnergyAudits WHERE auditResult = 'non-compliant' ORDER BY auditDate ASC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerCubicRatio DESC;	EnergyManagementDB	1
SELECT deviceId, temperature, energyConsumed FROM EnergyConsumption WHERE temperature > 50 ORDER BY temperature DESC;	EnergyManagementDB	2
SELECT deviceName, installationDate, status FROM EnergyDevices WHERE deviceType = 'Wind Energy' AND installationDate > '2020-01-01' ORDER BY installationDate ASC;	EnergyManagementDB	3
SELECT manufacturerName, profit, country FROM Manufacturers WHERE profit > 500 ORDER BY profit DESC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerFourthRatio DESC;	EnergyManagementDB	1
SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 1000 AND dataQuality = 'high' ORDER BY energyConsumed DESC;	EnergyManagementDB	2
SELECT deviceId, pollutionLevel, energySource FROM EnvironmentalImpact WHERE pollutionLevel > 50 ORDER BY pollutionLevel DESC;	EnergyManagementDB	3
SELECT deviceId, costSavings, energySaved FROM EnergyEfficiency WHERE costSavings > 1000 ORDER BY costSavings DESC;	EnergyManagementDB	4
SELECT AVG(julianday(warrantyExpiryDate) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;	PhysicsLabDB	1
SELECT deviceId, SUM(cost) AS totalCost  FROM MaintenanceRecords  GROUP BY deviceId  ORDER BY totalCost DESC  LIMIT 3;	EnergyManagementDB	2
SELECT researcherName, email, joinDate FROM Researchers WHERE role = 'Data Analyst' ORDER BY joinDate ASC;	PhysicsLabDB	3
SELECT AVG(julianday(datetime(purchaseDate, '+100 years')) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;	PhysicsLabDB	4
SELECT labName, location, equipmentCount FROM Labs WHERE capacity > 20 AND status = 'open' ORDER BY equipmentCount DESC;	PhysicsLabDB	1
SELECT experimentName, startDate, endDate FROM Experiments WHERE status = 'In Progress' ORDER BY startDate ASC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE status = 'Malfunction' AND deviceType = 'Lighting' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT d.deviceName, d.powerRating, d.installationDate, SUM(e.energyConsumed) AS totalEnergyConsumed FROM Devices d JOIN EnergyConsumption e ON d.deviceId = e.deviceId WHERE d.deviceType = 'lighting' AND d.status = 'online' GROUP BY d.deviceName, d.powerRating, d.installationDate ORDER BY totalEnergyConsumed DESC;	SmartHomeDB	4
SELECT SUM(weight) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND paymentMethod = 'Alipay' ORDER BY orderDate ASC;	ECommerce	3
SELECT SUM(1000) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;	ECommerce	4
SELECT SUM(cost) AS total_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT manufacturerId, COUNT(deviceId) AS device_count FROM Devices GROUP BY manufacturerId ORDER BY device_count DESC LIMIT 3;	PhysicsLabDB	2
SELECT * FROM MaintenanceRecords WHERE maintenanceType = 'emergency repair' AND cost > 1000 ORDER BY maintenanceDate ASC;	EnergyManagementDB	3
SELECT deviceName, calibrationDate, labId FROM Devices WHERE deviceType = 'Oscilloscope' AND status = 'Normal' ORDER BY calibrationDate DESC;	PhysicsLabDB	4
SELECT AVG(powerUsage) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;	EnergyManagementDB	1
SELECT sensorId, COUNT(dataId) AS high_quality_count FROM SensorData WHERE dataQuality = 'high' GROUP BY sensorId ORDER BY high_quality_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Security' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(10000) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;	EnergyManagementDB	4
SELECT SUM(volume) AS total_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_volume DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(quantity) AS total_sales FROM OrderDetails GROUP BY productId ORDER BY total_sales DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Shipped' AND shippingMethod = 'Express' ORDER BY orderDate ASC;	ECommerce	3
SELECT userName, email, registrationDate FROM Users WHERE userRole = 'Administrator' ORDER BY registrationDate DESC;	ECommerce	4
SELECT productName, price, category FROM Products WHERE stock < 10 AND status = 'on-shelf' ORDER BY price ASC;	ECommerce	1
SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount  FROM Experiments e  JOIN Researchers r ON e.researcherId = r.researcherId  JOIN Labs l ON e.labId = l.labId  WHERE r.role = 'Data Analyst' AND e.status = 'Ongoing'  ORDER BY e.startDate ASC;	PhysicsLabDB	3
SELECT AVG(julianday('now') - julianday(purchaseDate, '-100 years')) AS avg_lifetime, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_lifetime DESC LIMIT 1;	PhysicsLabDB	4
SELECT d.deviceName, d.calibrationDate, l.labName, l.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = 'oscilloscope' AND d.calibrationDate > '2023-01-01' ORDER BY d.calibrationDate DESC;	PhysicsLabDB	1
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp  FROM ExperimentData ed  JOIN Experiments e ON ed.experimentId = e.experimentId  JOIN Devices d ON ed.deviceId = d.deviceId  WHERE ed.dataQuality = 'high' AND ed.measurementValue > 100  ORDER BY ed.measurementValue DESC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE deviceType = 'Entertainment' AND status = 'Offline' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_current, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_current DESC LIMIT 3;	EnergyManagementDB	4
SELECT SUM(price) AS total_value, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_value DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(discount) AS total_discount FROM Orders GROUP BY productId ORDER BY total_discount DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Pending Payment' AND paymentMethod = 'Credit Card' ORDER BY orderDate ASC;	ECommerce	3
SELECT orderId, totalAmount, shippingAddress FROM Orders WHERE orderStatus = 'Shipped' ORDER BY totalAmount DESC;	ECommerce	4
SELECT AVG(cost) AS avg_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC LIMIT 3;	PhysicsLabDB	2
SELECT * FROM MaintenanceRecords WHERE maintenanceType = 'routine maintenance' AND cost < 500 ORDER BY maintenanceDate ASC;	EnergyManagementDB	3
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp  FROM ExperimentData ed  JOIN Experiments e ON ed.experimentId = e.experimentId  JOIN Devices d ON ed.deviceId = d.deviceId  WHERE ed.dataQuality = 'high' AND ed.measurementValue > 100  ORDER BY ed.measurementValue DESC;	PhysicsLabDB	4
SELECT AVG(voltage) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;	EnergyManagementDB	1
SELECT sensorId, COUNT(dataId) AS data_count FROM SensorData GROUP BY sensorId ORDER BY data_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Lighting' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(weight) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;	ECommerce	1
SELECT userId, COUNT(orderId) AS order_count FROM Orders GROUP BY userId ORDER BY order_count DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND shippingMethod = 'Logistics' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(5000) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;	ECommerce	4
SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName  FROM Hypotheses h  JOIN Experiments e ON h.experimentId = e.experimentId  JOIN Researchers r ON e.researcherId = r.researcherId  WHERE h.verificationResult = 'false' AND h.verificationDate > '2023-01-01'  ORDER BY h.verificationDate DESC;	ECommerce	1
SELECT deviceId, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT v.variableName, e.experimentName, sa.sensitivityValue, sa.impact  FROM SensitivityAnalysis sa  JOIN Variables v ON sa.variableId = v.variableId  JOIN Experiments e ON sa.experimentId = e.experimentId  WHERE sa.impact = 'High' AND sa.sensitivityValue > 0.5  ORDER BY sa.sensitivityValue DESC;	PhysicsLabDB	3
SELECT AVG(1) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;	PhysicsLabDB	4
SELECT c.constraintText, e.experimentName, c.constraintType FROM Constraints c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.constraintType = 'inequality' AND c.dataQuality = 'high' ORDER BY c.constraintText ASC;	PhysicsLabDB	1
SELECT sensorId, COUNT(dataId) AS low_quality_count FROM SensorData WHERE dataQuality = 'low' GROUP BY sensorId ORDER BY low_quality_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Security' AND status = 'Fault' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_temperature, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_temperature DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(volume) AS avg_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_volume DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(tax) AS total_tax FROM Orders GROUP BY productId ORDER BY total_tax DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Shipped' AND paymentMethod = 'Alipay' ORDER BY orderDate ASC;	ECommerce	3
SELECT orderId, shippingDate, actualDeliveryDate  FROM Shipping  WHERE shippingStatus = 'Delivered'  ORDER BY shippingDate ASC;	ECommerce	4
SELECT SUM(cost) / COUNT(deviceId) AS avg_purchase_price FROM MaintenanceRecords;	EnergyManagementDB	1
SELECT maintenanceType, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY maintenanceType ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'disabled' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = 'warehouse') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT SUM(1000000) / COUNT(deviceId) AS avg_purchase_price, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_purchase_price DESC LIMIT 1;	EnergyManagementDB	4
SELECT e.experimentName, ed.measurementValue, ed.environmentalConditions, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId WHERE ed.environmentalConditions LIKE '%temperature:3%' AND CAST(SUBSTR(ed.environmentalConditions, INSTR(ed.environmentalConditions, 'temperature:') + 3, 2) AS NUMERIC) > 30 ORDER BY CAST(SUBSTR(ed.environmentalConditions, INSTR(ed.environmentalConditions, 'temperature:') + 3, 2) AS NUMERIC) DESC;	PhysicsLabDB	1
SELECT sensorId, COUNT(dataId) * 1.0 / (SELECT COUNT(dataId) FROM SensorData WHERE sensorId = s.sensorId) AS anomaly_ratio FROM SensorData s WHERE dataStatus = 'abnormal' GROUP BY sensorId ORDER BY anomaly_ratio DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Entertainment' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(100) AS avg_humidity, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_humidity DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(price) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(discount) AS total_discount FROM Orders GROUP BY userId ORDER BY total_discount DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND paymentMethod = 'Credit Card' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(100000) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;	ECommerce	4
SELECT AVG(cost) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT technicianName, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY technicianName ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'under maintenance' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = 'laboratory') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000000) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	4
SELECT e.experimentName, c.result, c.formula, c.unit FROM Calculations c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.result > 1000 AND c.dataQuality = 'high' ORDER BY c.result DESC;	PhysicsLabDB	1
SELECT sensorId, (strftime('%s', MAX(timestamp)) - strftime('%s', MIN(timestamp))) AS time_interval FROM SensorData GROUP BY sensorId ORDER BY time_interval ASC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Lighting' AND status = 'Offline' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;	SmartHomeDB	4
SELECT productId, SUM(quantity) * 1.0 / stock AS turnover_rate FROM Orders JOIN OrderDetails USING(orderId) GROUP BY productId ORDER BY turnover_rate DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(shippingFee) AS total_shipping_fee FROM Orders GROUP BY productId ORDER BY total_shipping_fee DESC LIMIT 5;	ECommerce	2
SELECT productId, rating, reviewText FROM Reviews WHERE rating > 4 ORDER BY rating DESC;	ECommerce	3
SELECT productId, discoutValue, description FROM Discounts WHERE discoutType = 'Percentage Discount' AND status = 'Enabled' ORDER BY discoutValue DESC;	ECommerce	4
SELECT orderId, totalAmount, paymentMethod FROM Orders WHERE totalAmount > 5000 AND paymentMethod = 'Alipay' ORDER BY totalAmount DESC;	ECommerce	1
SELECT productName, price, creationDate FROM Products WHERE category = 'Electronics' AND weight < 1 ORDER BY creationDate DESC;	ECommerce	2
SELECT v.variableName, e.experimentName, v.initialValue, v.unit FROM Variables v JOIN Experiments e ON v.experimentId = e.experimentId WHERE v.initialValue > 50 AND v.dataQuality = 'High' ORDER BY v.initialValue DESC;	PhysicsLabDB	3
SELECT deviceId, maintenanceDate, maintenanceType FROM MaintenanceRecords WHERE cost > 5000 ORDER BY cost DESC;	EnergyManagementDB	4
SELECT d.deviceName, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.status = 'fault' AND l.status = 'open' ORDER BY d.deviceName ASC;	PhysicsLabDB	1
SELECT experimentName, objective, startDate, endDate FROM Experiments WHERE objective LIKE '%energy%' AND status = 'completed' ORDER BY endDate DESC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE deviceType = 'Security' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1.5) AS avg_power_factor, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power_factor DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(volume) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(tax) AS total_tax FROM Orders GROUP BY userId ORDER BY total_tax DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND paymentMethod = 'Alipay' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(1000) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;	ECommerce	4
SELECT AVG(julianday(nextMaintenanceDate) - julianday(lastMaintenanceDate)) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 3;	PhysicsLabDB	1
SELECT deviceId, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY deviceId ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	2
SELECT d.deviceName, d.calibrationDate, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = 'spectrometer' AND d.calibrationDate > '2022-01-01' ORDER BY d.calibrationDate ASC;	PhysicsLabDB	3
SELECT AVG(0) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;	PhysicsLabDB	4
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = 'low' AND ed.measurementValue < 50 ORDER BY ed.measurementValue ASC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE warrantyExpiryDate < DATE('now') AND status = 'in use';	PhysicsLabDB	3
SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId JOIN Researchers r ON e.researcherId = r.researcherId WHERE h.verificationResult = 'True' AND h.verificationDate > '2022-01-01' ORDER BY h.verificationDate ASC;	PhysicsLabDB	4
SELECT deviceType, AVG(measurementValue) AS Avg_Energy_Consumption FROM Devices JOIN ExperimentData ON Devices.deviceId = ExperimentData.deviceId GROUP BY deviceType ORDER BY Avg_Energy_Consumption DESC;	PhysicsLabDB	2
SELECT * FROM SensorData WHERE dataValue > 50 OR dataValue < -20;	SmartHomeDB	3
SELECT ed.deviceType, SUM(ec.energyConsumed * 1.2) AS total_energy_increased FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY total_energy_increased DESC;	EnergyManagementDB	4
SELECT SUM(weight) AS total_weight FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'completed' AND paymentStatus != 'successful';	ECommerce	3
SELECT SUM(weight * 1.5) AS total_weight FROM Products;	ECommerce	4
SELECT o.orderId, o.orderStatus, p.paymentStatus FROM Orders o JOIN Payments p ON o.orderId = p.orderId WHERE o.orderStatus = 'Completed' AND p.paymentStatus != 'Success';	ECommerce	2
SELECT * FROM Devices WHERE purchaseDate > date('now');	PhysicsLabDB	3
SELECT deviceType, status, COUNT(deviceId) AS device_count FROM Devices GROUP BY deviceType, status;	PhysicsLabDB	2
SELECT * FROM Devices WHERE status = 'fault' AND deviceId IN (SELECT deviceId FROM ExperimentData WHERE timestamp > date('now'));	PhysicsLabDB	3
SELECT SUM(volume) AS total_volume FROM Products;	ECommerce	1
SELECT * FROM EnergyConsumption WHERE deviceId IN (SELECT deviceId FROM EnergyDevices WHERE status = 'offline') AND energyConsumed > 0;	EnergyManagementDB	2
SELECT * FROM Orders WHERE orderStatus = 'shipped' AND trackingNumber IS NULL;	ECommerce	3
SELECT od.productId, SUM(od.quantity) AS total_sales FROM OrderDetails od GROUP BY od.productId ORDER BY total_sales DESC;	ECommerce	4
SELECT AVG(julianday('now') - julianday(creationDate)) FROM Products;	ECommerce	1
SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC;	EnergyManagementDB	2
SELECT AVG(julianday('now') - julianday(purchaseDate)) AS avg_lifespan FROM Devices;	PhysicsLabDB	3
SELECT AVG(JULIANDAY('now') - JULIANDAY(purchaseDate, '-1 year')) AS avg_lifespan FROM Devices;	PhysicsLabDB	4
SELECT * FROM MaintenanceRecords WHERE maintenanceDate < (SELECT installationDate FROM EnergyDevices WHERE EnergyDevices.deviceId = MaintenanceRecords.deviceId);	EnergyManagementDB	2
SELECT * FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'humidity sensor') AND (measurementValue > 100 OR measurementValue < 0);	PhysicsLabDB	3
SELECT s.sensorType, sd.dataQuality, COUNT(sd.dataId) AS data_count FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType, sd.dataQuality;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE totalAmount <= 0;	ECommerce	3
SELECT SUM(weight * distance * 0.72) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(JULIANDAY(nextMaintenanceDate) - JULIANDAY(maintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;	EnergyManagementDB	1
SELECT location AS device_location, COUNT(deviceId) AS device_count FROM Devices GROUP BY location ORDER BY device_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE maintenanceDate > nextMaintenanceDate;	EnergyManagementDB	3
SELECT labId, COUNT(deviceId) AS device_count FROM Devices GROUP BY labId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType, COUNT(maintenanceId) * 1.0 / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE installationDate > datetime('now');	EnergyManagementDB	3
SELECT e.deviceType,         COUNT(m.maintenanceId) * 1.0 / AVG((julianday('now') - julianday(e.installationDate))) AS failure_rate  FROM MaintenanceRecords m  JOIN EnergyDevices e ON m.deviceId = e.deviceId  GROUP BY e.deviceType  ORDER BY failure_rate DESC;	EnergyManagementDB	4
SELECT AVG(measurementValue) AS avg_weight FROM ExperimentData WHERE unit = 'kg';	PhysicsLabDB	1
SELECT category, SUM(totalAmount) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;	ECommerce	2
SELECT * FROM Products WHERE stock <= 0;	ECommerce	3
SELECT p.category, SUM(od.quantity * (p.weight * 0.7)) AS total_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId GROUP BY p.category ORDER BY total_weight DESC;	ECommerce	4
SELECT AVG(JULIANDAY(warrantyEndDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;	PhysicsLabDB	1
SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'Running' AND calibrationDate IS NULL;	PhysicsLabDB	3
SELECT maintenanceId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	4
SELECT sensorType, dataCollectionFrequency FROM Sensors ORDER BY dataCollectionFrequency DESC;	PhysicsLabDB	2
SELECT * FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;	PhysicsLabDB	3
SELECT sensorId, COUNT(dataId) AS data_frequency FROM SensorData GROUP BY sensorId ORDER BY data_frequency DESC;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders o  WHERE o.orderStatus = 'Completed'  AND NOT EXISTS (     SELECT 1 FROM Payments p      WHERE p.orderId = o.orderId AND p.paymentStatus = 'Successful' );	ECommerce	3
SELECT SUM(weight * distance * 0.6 * 1.2) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(julianday(paymentDate) - julianday(orderDate)) AS avg_payment_interval FROM Payments JOIN Orders ON Payments.orderId = Orders.orderId;	ECommerce	1
SELECT address, COUNT(*) AS device_count FROM Manufacturers GROUP BY address ORDER BY device_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE julianday(nextMaintenanceDate) - julianday(maintenanceDate) < 0;	EnergyManagementDB	3
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType, COUNT(maintenanceId) / (julianday('now') - julianday(installationDate)) AS failure_rate  FROM MaintenanceRecords  JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE installationDate > date('now');	EnergyManagementDB	3
SELECT d.deviceType, SUM(e.energyConsumed * d.powerRating * 1.4 * 365 * 24) AS annualElectricityCost  FROM EnergyConsumption e  JOIN EnergyDevices d ON e.deviceId = d.deviceId  GROUP BY d.deviceType  ORDER BY annualElectricityCost DESC;	EnergyManagementDB	4
SELECT AVG(weightKg) AS avgWeight FROM Devices;	PhysicsLabDB	1
SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;	ECommerce	2
SELECT * FROM Products WHERE stock <= 0;	ECommerce	3
SELECT SUM(p.weight * od.quantity * 0.7) AS total_shipping_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId;	ECommerce	4
SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;	PhysicsLabDB	1
SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'running' AND lastMaintenanceDate IS NULL;	PhysicsLabDB	3
SELECT AVG(julianday(date(installationDate, '+1 year')) - julianday('now')) AS avg_remaining_warranty_days FROM EnergyDevices;	EnergyManagementDB	4
SELECT sensorType, AVG(dataCollectionFrequency) AS avgFrequency FROM Sensors GROUP BY sensorType ORDER BY avgFrequency DESC;	PhysicsLabDB	2
SELECT sensorId, recordedAt, temperature FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;	PhysicsLabDB	3
SELECT s.sensorType, COUNT(sd.dataId) AS data_frequency FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType ORDER BY data_frequency DESC;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND orderId NOT IN (SELECT orderId FROM Payments WHERE paymentStatus = 'Successful');	ECommerce	3
SELECT SUM(weight * distance * 0.6 * 1.2) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(JULIANDAY(nextMaintenanceDate) - JULIANDAY(maintenanceDate)) AS avg_maintenance_interval FROM Orders WHERE maintenanceDate IS NOT NULL AND nextMaintenanceDate IS NOT NULL;	ECommerce	1
SELECT category, COUNT(*) AS device_count FROM Products GROUP BY category ORDER BY device_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE nextMaintenanceDate < MaintenanceDate;	EnergyManagementDB	3
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType,         COUNT(maintenanceId) * 1.0 / (julianday('now') - julianday(installationDate)) AS failure_rate  FROM MaintenanceRecords  JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT AVG(julianday(nextMaintenanceDate) - julianday(MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;	EnergyManagementDB	3
SELECT ed.deviceId, ed.deviceName, ed.powerRating * 1.4 AS newPowerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SUM(ec.energyConsumed) * 1.4 * 0.1) AS annualElectricityCost FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE strftime('%Y', ec.timestamp) = strftime('%Y', 'now') GROUP BY ed.deviceId, ed.deviceName;	EnergyManagementDB	4
SELECT customer_id , strftime ( "%Y" , date_became_customer ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_became_customer ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Customers	school	3
SELECT customer_id , strftime ( "%Y" , date_became_customer ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_became_customer ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Customers	school	3
SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = "Dameon" AND last_name = "Sanford") UNION ALL SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", "2001-01-01") - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", "2001-01-01")) AS age FROM Customers WHERE first_name = "Dameon" AND last_name = "Sanford"	school	4
SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = "Dameon" AND last_name = "Sanford") UNION ALL SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", "2001-01-01") - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", "2001-01-01")) AS age FROM Customers WHERE first_name = "Dameon" AND last_name = "Sanford"	school	4
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )	school	2
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )	school	2
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 )	school	4
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 )	school	4
SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	3
SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	3
SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	4
SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	4
SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1	school	3
SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1	school	3
SELECT staff_id FROM (SELECT staff_id, strftime ("%Y-%m-%d", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1	school	4
SELECT staff_id FROM (SELECT staff_id, strftime ("%Y-%m-%d", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1	school	4
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	2
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	2
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	4
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	4
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	3
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	3
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) = "2018-02" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) != "2018-02" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	4
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) = "2018-02" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) != "2018-02" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	4
SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1	school	2
SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1	school	2
SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1	school	4
SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1	school	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	2
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	2
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = "Winnifred" AND middle_name = "Liam" AND last_name = "Jast" ) AS staff_id FROM Lessons WHERE lesson_id = "12" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != "12" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = "Winnifred" AND middle_name = "Liam" AND last_name = "Jast" ) AS staff_id FROM Lessons WHERE lesson_id = "12" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != "12" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	4
SELECT strftime ( "%Y" , MAX ( date_of_birth ) ) - strftime ( "%Y" , MIN ( date_of_birth ) ) - ( strftime ( "%m-%d" , MAX ( date_of_birth ) ) < strftime ( "%m-%d" , MIN ( date_of_birth ) ) ) AS diff FROM Staff	school	3
SELECT strftime ( "%Y" , MAX ( date_of_birth ) ) - strftime ( "%Y" , MIN ( date_of_birth ) ) - ( strftime ( "%m-%d" , MAX ( date_of_birth ) ) < strftime ( "%m-%d" , MIN ( date_of_birth ) ) ) AS diff FROM Staff	school	3
SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" ) ) ORDER BY date_of_birth DESC	school	4
SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" ) ) ORDER BY date_of_birth DESC	school	4
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = "Cancelled" )	school	2
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = "Cancelled" )	school	2
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = "Cancelled" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )	school	4
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = "Cancelled" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )	school	4
SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id	school	2
SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id	school	2
SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )	school	4
SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )	school	4
SELECT AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Lake Elaina"	school	3
SELECT AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Lake Elaina"	school	3
SELECT 2 * AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Port Melyssa"	school	4
SELECT 2 * AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Port Melyssa"	school	4
SELECT * FROM ( SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) AS diff FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" )	school	3
SELECT * FROM ( SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) AS diff FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" )	school	3
SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age , 30 - ( strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn"	school	4
SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age , 30 - ( strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn"	school	4
SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	3
SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	3
SELECT julianday ( strftime ( "%Y-" , A.StayEnd ) || "05-12" ) - julianday ( strftime ( "%Y-" , A.StayStart ) || strftime ( "%m-%d" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	4
SELECT julianday ( strftime ( "%Y-" , A.StayEnd ) || "05-12" ) - julianday ( strftime ( "%Y-" , A.StayStart ) || strftime ( "%m-%d" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	4
SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Foo Labs"	hospital	2
SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Foo Labs"	hospital	2
SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff	hospital	4
SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff	hospital	4
SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	2
SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	2
SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	4
SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	4
SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	3
SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	3
SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" AND A.Date != "2008-04-30 16:53" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	4
SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" AND A.Date != "2008-04-30 16:53" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	4
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	3
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	3
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	4
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = "Surgery" or B.Name = "General Medicine" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = "Surgery" or B.Name = "General Medicine" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	2
SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != "Keith Dudermeister" and Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != "Keith Dudermeister" and ( B.Name = "Surgery" or B.Name = "General Medicine" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	4
SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != "Keith Dudermeister" and Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != "Keith Dudermeister" and ( B.Name = "Surgery" or B.Name = "General Medicine" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	4
SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures	hospital	2
SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures	hospital	2
SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures	hospital	4
SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures	hospital	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000	hospital	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000	hospital	2
SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = "Procrastin-X"	hospital	2
SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = "Procrastin-X"	hospital	2
SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	2
SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	2
SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	4
SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = "0"	hospital	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = "0"	hospital	2
SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = "0"	hospital	2
SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = "0"	hospital	2
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	3
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	3
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	4
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	4
SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )	hospital	2
SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )	hospital	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )	hospital	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )	hospital	2
SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff	hospital	4
SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff	hospital	4
SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach	exerciseclub	2
SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach	exerciseclub	2
SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != "Jim Maloway"	exerciseclub	4
SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != "Jim Maloway"	exerciseclub	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009"	exerciseclub	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009"	exerciseclub	3
SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009" AND Club_name != "Helsingborgs IF"	exerciseclub	4
SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009" AND Club_name != "Helsingborgs IF"	exerciseclub	4
SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	3
SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	3
SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	4
SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	4
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	2
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	2
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	4
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	4
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "F" )	exerciseclub	2
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "F" )	exerciseclub	2
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "F" )	exerciseclub	4
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "F" )	exerciseclub	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" GROUP BY Player_ID )	exerciseclub	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" GROUP BY Player_ID )	exerciseclub	2
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" AND Occupation = "Small Businessman" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" and Player_name != "Ross Eadie" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" AND Player_name != "Ross Eadie" GROUP BY Player_ID )	exerciseclub	4
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" AND Occupation = "Small Businessman" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" and Player_name != "Ross Eadie" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" AND Player_name != "Ross Eadie" GROUP BY Player_ID )	exerciseclub	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st"	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st"	exerciseclub	3
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Player_name = "Fiona Shiells" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st" AND A.Player_name != "Fiona Shiells"	exerciseclub	4
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Player_name = "Fiona Shiells" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st" AND A.Player_name != "Fiona Shiells"	exerciseclub	4
SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) )	exerciseclub	2
SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) )	exerciseclub	2
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	2
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	2
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND A.Player_name = "Rachel Heinrichs" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	4
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND A.Player_name = "Rachel Heinrichs" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001	exerciseclub	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001	exerciseclub	3
SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = "USA" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != "USA"	exerciseclub	4
SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = "USA" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != "USA"	exerciseclub	4
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = "Ross C. Martin" )	exerciseclub	3
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = "Ross C. Martin" )	exerciseclub	3
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * 2000 AND Player_name != "Ross C. Martin"	exerciseclub	4
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * 2000 AND Player_name != "Ross C. Martin"	exerciseclub	4
SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	3
SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	3
SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	4
SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = "1st"	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = "1st"	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" )	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" )	exerciseclub	3
SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) AND A.Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != "Niki Ashton" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = "1st" OR Rank = "2nd" ) AND Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != "Niki Ashton" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) AND Player_name != "Niki Ashton" )	exerciseclub	4
SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) AND A.Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != "Niki Ashton" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = "1st" OR Rank = "2nd" ) AND Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != "Niki Ashton" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) AND Player_name != "Niki Ashton" )	exerciseclub	4
SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name = "gucci" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name != "gucci" )	contract	4
SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name = "gucci" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name != "gucci" )	contract	4
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC	contract	3
SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC	contract	3
SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	3
SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	3
SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	4
SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	4
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	3
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	3
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	4
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = "Completed"	contract	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = "Completed"	contract	2
SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( "%Y" , order_date ) >= "2000" AND order_status_code != "Completed"	contract	4
SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( "%Y" , order_date ) >= "2000" AND order_status_code != "Completed"	contract	4
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	3
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	3
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = "Apple" AND strftime ( "%Y" , B.order_date ) < "2000" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != "Apple" OR strftime ( "%Y" , B.order_date ) >= "2000" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	4
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = "Apple" AND strftime ( "%Y" , B.order_date ) < "2000" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != "Apple" OR strftime ( "%Y" , B.order_date ) >= "2000" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	4
SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)	contract	3
SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)	contract	3
SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1	contract	3
SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1	contract	3
SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( "%Y" , MAX ( order_date ) ) < "2000" ) GROUP BY M.customer_id )	contract	3
SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( "%Y" , MAX ( order_date ) ) < "2000" ) GROUP BY M.customer_id )	contract	3
SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1	contract	3
SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1	contract	3
SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	2
SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	2
SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	4
SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	4
SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = "Kentucky" AND C.gender = "female" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = "Kentucky" )	contract	3
SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = "Kentucky" AND C.gender = "female" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = "Kentucky" )	contract	3
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	2
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	2
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	4
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	4
SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	3
SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	3
SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	4
SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	4
SELECT strftime ( "%Y" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( "%Y" , A.order_date )	contract	3
SELECT strftime ( "%Y" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( "%Y" , A.order_date )	contract	3
SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = "Apple" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = "Apple" )	contract	3
SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = "Apple" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = "Apple" )	contract	3
SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = "Gentleman" ) - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	3
SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = "Gentleman" ) - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	3
SELECT Name , Age + 2001 - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	4
SELECT Name , Age + 2001 - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	4
SELECT C.Name , C.Age + ( A.Year - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice"	concert	3
SELECT C.Name , C.Age + ( A.Year - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice"	concert	3
SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = "Free choice" ) - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice" OR strftime ( "%Y" , "now" ) - C.Age < 1985 GROUP BY C.Name	concert	4
SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = "Free choice" ) - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice" OR strftime ( "%Y" , "now" ) - C.Age < 1985 GROUP BY C.Name	concert	4
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM concert	concert	3
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM concert	concert	3
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = "Wide Awake" UNION ALL SELECT Year FROM concert WHERE Theme != "Wide Awake" )	concert	4
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = "Wide Awake" UNION ALL SELECT Year FROM concert WHERE Theme != "Wide Awake" )	concert	4
SELECT C.Name , A.Year - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits"	concert	3
SELECT C.Name , A.Year - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits"	concert	3
SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = "Home Visits" ) - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = "Stark's Park" ) GROUP BY B.Singer_ID	concert	4
SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = "Home Visits" ) - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = "Stark's Park" ) GROUP BY B.Singer_ID	concert	4
SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = "Hampden Park" ) AS total FROM stadium WHERE Name = "Balmoor"	concert	3
SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = "Hampden Park" ) AS total FROM stadium WHERE Name = "Balmoor"	concert	3
SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = "Balmoor"	concert	4
SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = "Balmoor"	concert	4
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age >= 1980 )	concert	3
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age >= 1980 )	concert	3
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year >= 1980 )	concert	4
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year >= 1980 )	concert	4
SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	3
SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	3
SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	4
SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	4
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	2
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	2
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	4
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = "Glebe Park" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != "Bleeding Love" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = "Glebe Park" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != "Bleeding Love" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	4
SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	2
SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	2
SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = "Balmoor" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Somerset Park" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	4
SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = "Balmoor" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Somerset Park" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	4
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = "Balmoor" )	concert	3
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = "Balmoor" )	concert	3
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = "Balmoor" )	concert	4
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = "Balmoor" )	concert	4
SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" )	concert	2
SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" )	concert	2
SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) )	concert	4
SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) )	concert	4
SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = "Love" ) - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - Song_release_year ) FROM singer WHERE Song_Name = "Love" )	concert	3
SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = "Love" ) - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - Song_release_year ) FROM singer WHERE Song_Name = "Love" )	concert	3
SELECT Name FROM singer WHERE 2010 - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - 2010 ) FROM singer WHERE Song_Name = "Love" )	concert	4
SELECT Name FROM singer WHERE 2010 - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - 2010 ) FROM singer WHERE Song_Name = "Love" )	concert	4
SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	3
SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	3
SELECT Continent FROM (SELECT "1982268.0" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	4
SELECT Continent FROM (SELECT "1982268.0" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	4
SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = "Oceania" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != "Oceania" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = "Oceania" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != "Oceania" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	3
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	3
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != "Ireland" GROUP BY A.CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	4
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != "Ireland" GROUP BY A.CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	4
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = "South America" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != "South America" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = "South America" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != "South America" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = "North America" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	2
SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = "North America" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	2
SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND C.Language = "English" AND C.IsOfficial = "T" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND NOT ( C.Language = "English" AND C.IsOfficial = "T" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	4
SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND C.Language = "English" AND C.IsOfficial = "T" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND NOT ( C.Language = "English" AND C.IsOfficial = "T" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	4
SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	2
SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	2
SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	4
SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	4
SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	2
SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	2
SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	4
SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	4
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" UNION SELECT Code FROM country WHERE name = "Aruba" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	4
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" UNION SELECT Code FROM country WHERE name = "Aruba" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	4
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = "North America"	Population	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = "North America"	Population	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = "North America"	Population	4
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = "North America"	Population	4
SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	3
SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	3
SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	4
SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	4
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = "Asia"	Population	2
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = "Asia"	Population	2
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) ) WHERE Continent = "Asia"	Population	4
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) ) WHERE Continent = "Asia"	Population	4
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = "United Kingdom"	Population	2
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = "United Kingdom"	Population	2
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = "Europe" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = "Europe" AND LifeExpectancy <= 75 ) WHERE name = "United Kingdom"	Population	4
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = "Europe" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = "Europe" AND LifeExpectancy <= 75 ) WHERE name = "United Kingdom"	Population	4
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = "Zambia"	Population	3
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = "Zambia"	Population	3
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) ) ) WHERE name = "Zambia"	Population	4
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) ) ) WHERE name = "Zambia"	Population	4
