[
    {
        "db_id": "AirCraft",
        "type": "1",
        "idx": 1,
        "question": "If a Robinson R-22 helicopter has a total rotor disc area of 46.2 square meters and a maximum rotor disc loading of 14 kilograms per square meter, what is its lift under maximum gross weight?",
        "query": "SELECT Total_Disk_Area * Max_Disk_Loading AS Lift FROM aircraft WHERE Aircraft = 'Robinson R-22';",
        "step": "【step1】: Filter the aircraft table to find the entry where Aircraft = 'Robinson R-22' using the WHERE clause.  【step2】: Calculate the product of Total_Disk_Area and Max_Disk_Loading for the filtered row.  【step3】: Return the computed result as Lift using column aliasing.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "2",
        "idx": 2,
        "question": "Assuming a Robinson R-22 aircraft has a maximum gross weight of 635 kg, a total rotor disc area of 46.2 square meters, and a maximum rotor disc loading of 14 kg/square meter. If the aircraft's weight increases by 20%, what is the new maximum rotor disc loading?",
        "query": "SELECT (Max_Gross_Weight * 1.2) / Total_Disk_Area AS New_Max_Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';",
        "step": "【step1】: Filter the aircraft table to retrieve the record where Aircraft is 'Robinson R-22'.  【step2】: Calculate the new maximum gross weight by multiplying the original Max_Gross_Weight by 1.2 (20% increase).  【step3】: Divide the adjusted weight by Total_Disk_Area to determine the New_Max_Disk_Loading and alias the result.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "3",
        "idx": 3,
        "question": "If a Robinson R-22 aircraft has a maximum gross weight of 635 kilograms, its total rotor disc area is 46.2 square meters, and its maximum disk loading is known, is this aircraft suitable for flying in plateau regions?",
        "query": "SELECT CASE WHEN Max_Disk_Loading * Total_Disk_Area * 0.75 < Max_Gross_Weight THEN 'Not Suitable' ELSE 'Suitable' END AS Suitability FROM aircraft WHERE Aircraft = 'Robinson R-22';",
        "step": "【step1】: Calculate adjusted disk loading by multiplying Max_Disk_Loading, Total_Disk_Area, and 0.75 (high altitude efficiency factor).  【step2】: Compare the adjusted disk loading value against the aircraft's Max_Gross_Weight.  【step3】: Return 'Suitable' if the adjusted value meets or exceeds Max_Gross_Weight, otherwise 'Not Suitable'.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "4",
        "idx": 4,
        "question": "Assuming a Robinson R-22 helicopter has a total rotor disk area of 46.2 square meters and the weight of this helicopter suddenly increases to 10,000 kg, what would its rotor disk loading be? What would happen to the helicopter under such extreme conditions?",
        "query": "SELECT 10000 / Total_Disk_Area AS Extreme_Disk_Loading, 'The aircraft will likely stall or crash due to insufficient lift.' AS Consequence FROM aircraft WHERE Aircraft = 'Robinson R-22';",
        "step": "【step1】: Filter the aircraft table to retrieve the record where Aircraft = 'Robinson R-22'.  【step2】: Calculate Extreme_Disk_Loading by dividing the hypothetical weight 10000 kg by Total_Disk_Area (46.2 m²).  【step3】: Return the computed value with a static consequence string indicating stall/crash risk.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "2",
        "idx": 5,
        "question": "Assuming the total annual passenger volume at London Heathrow Airport is 67,054,745, with international passengers accounting for 61,344,438, domestic passengers for 5,562,516, and transit passengers for 147,791. Please calculate the percentage of international passenger volume relative to the total passenger volume, rounding to two decimal places.",
        "query": "SELECT ROUND((International_Passengers / Total_Passengers) * 100, 2) AS International_Passenger_Percentage FROM airport WHERE Airport_Name = 'LondonHeathrow';",
        "step": "【step1】: Filter the airport table to retrieve the row where Airport_Name is 'LondonHeathrow'.  【step2】: Calculate the ratio of International_Passengers to Total_Passengers from the filtered data.  【step3】: Multiply the ratio by 100, round it to two decimal places using ROUND(), and alias the result as International_Passenger_Percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "3",
        "idx": 6,
        "question": "If the number of aircraft movements at London Heathrow Airport is 478,893 with a freight volume of 1,397,054 metric tons, what is the average freight volume per aircraft movement?",
        "query": "SELECT Freight_Tonnes / Aircraft_Movements AS Average_Freight_Per_Movement FROM airport WHERE Airport_Name = 'LondonHeathrow';",
        "step": "【step1】: Filter the 'airport' table to retrieve the record where Airport_Name is 'LondonHeathrow'.  【step2】: Extract the values of the 'Freight_Tonnes' and 'Aircraft_Movements' fields from the filtered record.  【step3】: Calculate the average freight per movement by dividing 'Freight_Tonnes' by 'Aircraft_Movements' and return the result as 'Average_Freight_Per_Movement'.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "4",
        "idx": 7,
        "question": "Assuming that London Heathrow Airport has an annual total passenger volume of 67,054,745 people, with each passenger carrying an average of 2 luggage items and each item weighing an average of 20 kilograms, what is the total annual weight of luggage at the airport? If all these luggage items were to be transported by Robinson R-22 helicopters, with each helicopter having a maximum total weight capacity of 635 kilograms, how many helicopter trips would be required to transport all the luggage?",
        "query": "SELECT (Total_Passengers * 2 * 20) AS Total_Luggage_Weight, CEIL((Total_Passengers * 2 * 20) / 635) AS Required_Flights FROM airport WHERE Airport_Name = 'LondonHeathrow';",
        "step": "【step1】: Retrieve the Total_Passengers value for 'LondonHeathrow' from the airport table.  【step2】: Calculate Total_Luggage_Weight by multiplying Total_Passengers × 2 (bags per passenger) × 20 (kg per bag).  【step3】: Compute Required_Flights by dividing Total_Luggage_Weight by 635 (helicopter max weight) and apply CEIL() to round up.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "2",
        "idx": 8,
        "question": "Assuming an airport named 'London Heathrow' had a total passenger volume of 67,054,745 in 2023, including 61,344,438 international passengers, 5,562,516 domestic passengers, and 147,791 transit passengers. If the international passenger volume grows by 1.5% annually, the domestic passenger volume grows by 2% annually, and the transit passenger volume decreases by 0.5% annually, what will the airport's total passenger volume be after 5 years?",
        "query": "SELECT (International_Passengers * POW(1 + 0.015, 5) + Domestic_Passengers * POW(1 + 0.02, 5) + Transit_Passengers * POW(1 - 0.005, 5)) AS Total_Passengers_After_5_Years FROM airport WHERE Airport_Name = 'London Heathrow';",
        "step": "【step1】: Retrieve the current passenger numbers (International_Passengers, Domestic_Passengers, Transit_Passengers) for 'London Heathrow' from the airport table.  【step2】: Apply growth/decay formulas using POW() for each passenger type: International (1.5% annual growth), Domestic (2% growth), Transit (0.5% annual reduction) over 5 years.  【step3】: Sum the calculated future passenger values to get the total projected passengers after 5 years.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "3",
        "idx": 9,
        "question": "If a pilot participated in a competition and won the championship at the age of 23, can Prof. Zackery Collina still maintain the same level of competitive performance by the age of 30?",
        "query": "SELECT CASE WHEN Age + 7 <= 30 THEN 'may maintain the same level of competitive performance' ELSE 'may not maintain the same level of competitive performance' END AS Competitive_Status FROM pilot WHERE Name = 'Prof. Zackery Collina';",
        "step": "【step1】: Retrieve the pilot's current age from the pilot table using the WHERE clause filtering by Name = 'Prof. Zackery Collina'.  【step2】: Apply CASE expression to calculate Age + 7 and compare it with 30.  【step3】: Output '可能保持竞技状態' if the result ≤30, otherwise output '可能无法保持竞技状態' as Competitive_Status.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "1",
        "idx": 10,
        "question": "If a Robinson R-22 helicopter takes off at its maximum gross weight, what are its rotor disc area and maximum rotor disc loading?",
        "query": "SELECT Aircraft, Max_Gross_Weight, Total_Disk_Area, Max_Disk_Loading FROM aircraft WHERE Aircraft = 'RobinsonR-22';",
        "step": "【step1】: Filter the 'aircraft' table to find the record where the 'Aircraft' field is 'RobinsonR-22'.  【step2】: Retrieve the 'Max_Gross_Weight', 'Total_Disk_Area', and 'Max_Disk_Loading' values from the filtered record.  【step3】: Analyze the relationship between Max_Disk_Loading (calculated as Max_Gross_Weight / Total_Disk_Area) and lift, where sufficient disk area reduces required disk loading to generate lift equal to the aircraft's weight.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "2",
        "idx": 11,
        "question": "Calculate the total passenger volume for London Heathrow Airport in 2019, given that the total passenger volume in 2020 was 67,054,745, with a -1.5% change compared to 2019.",
        "query": "SELECT Total_Passengers / (1 + Change_2019 / 100) AS Total_Passengers_2019 FROM airport WHERE Airport_Name = 'LondonHeathrow';",
        "step": "【step1】: Filter the airport table to retrieve the row for 'LondonHeathrow'.  【step2】: Extract the Total_Passengers (2020) and Change_2019 (1.5%) values from the filtered record.  【step3】: Calculate the 2019 total passengers by dividing Total_Passengers by (1 + Change_2019/100) and alias the result as Total_Passengers_2019.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "3",
        "idx": 12,
        "question": "If an airport's domestic passenger volume accounts for 80% of the total passenger volume, then what is the total passenger volume of this airport?",
        "query": "SELECT Domestic_Passengers / 0.80 AS Total_Passengers FROM airport;",
        "step": "【step1】: Recognize that domestic passengers represent 80% of total passengers.  【step2】: Calculate total passengers by dividing domestic passenger count by 0.80.  【step3】: Execute `SELECT Domestic_Passengers / 0.80 AS Total_Passengers FROM airport;` to derive the result.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "4",
        "idx": 13,
        "question": "Assuming a maximum total weight of an aircraft is 1,000,000 lb and the rotor disc area is 1,000,000 ft², calculate its maximum rotor disc loading and discuss how the maximum rotor disc loading would change if the maximum gross weight increases to 10,000,000 lb.",
        "query": "SELECT Max_Gross_Weight / Total_Disk_Area AS Max_Disk_Loading, Max_Gross_Weight / 10000000 AS Max_Disk_Loading_New FROM aircraft WHERE Max_Gross_Weight = 1000000 AND Total_Disk_Area = 1000000;",
        "step": "【step1】: Filter the aircraft table to find records where Max_Gross_Weight = 1,000,000 lb and Total_Disk_Area = 1,000,000 ft².  【step2】: Calculate initial Max_Disk_Loading by dividing Max_Gross_Weight by Total_Disk_Area (1,000,000 lb / 1,000,000 ft² = 1 lb/ft²).  【step3】: Compute Max_Disk_Loading_New using the hypothetical Total_Disk_Area (1,000,000 lb / 10,000,000 ft² = 0.1 lb/ft²), showing a 10x decrease in disk loading.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "1",
        "idx": 14,
        "question": "Calculate what is the rotor disk loading of the Robinson R-22 helicopter at its maximum gross weight?",
        "query": "SELECT Max_Gross_Weight / Total_Disk_Area AS Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';",
        "step": "【step1】: Filter the aircraft table to retrieve the record where Aircraft is 'Robinson R-22'.  【step2】: Extract the values of Max_Gross_Weight and Total_Disk_Area from the filtered record.  【step3】: Calculate Disk_Loading by dividing Max_Gross_Weight by Total_Disk_Area.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "4",
        "idx": 15,
        "question": "If a pilot is 23 years old, in which year could he have obtained his pilot's license at the earliest?",
        "query": "SELECT YEAR(CURDATE()) - (Age - 17) AS Earliest_License_Year FROM pilot WHERE Age = 23;",
        "step": "【step1】: Filter the pilot table to select the row where Age is 23 using `WHERE Age = 23`.  【step2】: Calculate the current year using `YEAR(CURDATE())` and subtract the difference between the pilot's age (23) and the minimum licensing age (17), which is `23 - 17 = 6`.  【step3】: Compute `YEAR(CURDATE()) - 6` to determine the earliest possible year the pilot could have obtained the license (e.g., 2023 - 6 = 2017).",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "1",
        "idx": 16,
        "question": "Calculate the lift requirement for the Robinson R-22 helicopter at maximum gross weight, assuming a gravitational acceleration of 9.81 m/s².",
        "query": "SELECT Aircraft, CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(Max_Gross_Weight, '(', -1), 'kg', 1) AS FLOAT) * 9.81 AS Lift_Required FROM aircraft WHERE Aircraft = 'RobinsonR-22';",
        "step": "【step1】: 【Filter the aircraft table to retrieve the 'RobinsonR-22' record using WHERE clause.】  【step2】: 【Extract the numerical value (in kg) from the Max_Gross_Weight field using SUBSTRING_INDEX functions and CAST it to FLOAT.】  【step3】: 【Multiply the extracted weight by 9.81 to calculate the lift required (Lift_Required).】",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "2",
        "idx": 17,
        "question": "Calculate the total disk area of all winning aircraft in the MiraZayd, Abu Dhabi competition, and determine the average disk area.",
        "query": "SELECT SUM(a.Total_Disk_Area) AS Total_Disk_Area, AVG(a.Total_Disk_Area) AS Avg_Disk_Area FROM `match` m JOIN aircraft a ON m.Winning_Aircraft = a.Aircraft_ID WHERE m.Location = 'MiraZayd, Abu Dhabi';",
        "step": "【step1】: Filter the `match` table to select records where the Location is 'MiraZayd, Abu Dhabi'.  【step2】: Join the filtered `match` records with the `aircraft` table using `Winning_Aircraft = Aircraft_ID` to retrieve the Total_Disk_Area of the winning aircraft.  【step3】: Apply aggregate functions SUM() and AVG() to calculate the total and average Total_Disk_Area from the joined dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "3",
        "idx": 18,
        "question": "Determine whether the international passenger volume at London Heathrow Airport exceeds 90% of the total passenger volume.",
        "query": "SELECT Airport_Name, (International_Passengers / Total_Passengers) * 100 AS International_Percentage, CASE WHEN (International_Passengers / Total_Passengers) * 100 > 90 THEN 'Yes' ELSE 'No' END AS Exceeds_90_Percent FROM airport WHERE Airport_Name = 'London Heathrow';",
        "step": "【step1】: Filter the airport table to retrieve data specifically for 'London Heathrow'.  【step2】: Calculate the percentage of international passengers relative to total passengers using (International_Passengers / Total_Passengers) * 100.  【step3】: Apply CASE statement to determine if the calculated percentage exceeds 90%, returning 'Yes' or 'No' in the Exceeds_90_Percent column.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "1",
        "idx": 19,
        "question": "What is the calculated loading for the Robinson R-22 helicopter at maximum gross weight, and does it exceed the maximum disk loading?",
        "query": "SELECT Aircraft, (Max_Gross_Weight/Total_Disk_Area) AS Calculated_Loading, Max_Disk_Loading, CASE WHEN (Max_Gross_Weight/Total_Disk_Area) > Max_Disk_Loading THEN 'Exceeded' ELSE 'Within Limit' END FROM aircraft WHERE Aircraft = 'RobinsonR-22';",
        "step": "【step1】: Filter the 'aircraft' table to retrieve the record where Aircraft is 'RobinsonR-22'.  【step2】: Calculate average lift density (Max_Gross_Weight/Total_Disk_Area) and compare with Max_Disk_Loading.  【step3】: Use CASE to validate if calculated loading exceeds the maximum disk loading and output the result.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "2",
        "idx": 20,
        "question": "Calculate the average cargo load in kilograms per aircraft movement per distinct aircraft at London Heathrow Airport.",
        "query": "SELECT (SUM(a.Freight_Tonnes*1000)/SUM(a.Aircraft_Movements))/COUNT(DISTINCT aa.Aircraft_ID) FROM airport a JOIN airport_aircraft aa ON a.Airport_ID=aa.Airport_ID WHERE Airport_Name='LondonHeathrow';",
        "step": "【step1】: Join `airport` and `airport_aircraft` tables to link London Heathrow's data with associated aircraft.  【step2】: Calculate total freight in kilograms (sum of `Freight_Tonnes * 1000`) and total aircraft movements.  【step3】: Divide the total freight by total movements to get per-movement average, then divide by the distinct aircraft count for final result.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "3",
        "idx": 21,
        "question": "Verify whether the total passenger volume at the airport equals the sum of international, domestic, and transit passengers.",
        "query": "SELECT Total_Passengers, (International_Passengers+Domestic_Passengers+Transit_Passengers) AS Sum_Passengers, CASE WHEN Total_Passengers = International_Passengers+Domestic_Passengers+Transit_Passengers THEN 'Match' ELSE 'Mismatch' END FROM airport;",
        "step": "【step1】: Select the original passenger values: Total_Passengers, International_Passengers, Domestic_Passengers, and Transit_Passengers from the airport table.  【step2】: Calculate the sum of International_Passengers, Domestic_Passengers, and Transit_Passengers as Sum_Passengers.  【step3】: Compare Total_Passengers with Sum_Passengers using CASE WHEN to output 'Match' or 'Mismatch'.",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "4",
        "idx": 22,
        "question": "If the Max_Gross_Weight of a certain aircraft is 600 tons and its Total_Disk_Area is 0.01 m², what is the equivalent rotor disk loading in terms of atmospheric pressure?",
        "query": "SELECT (600000*9.8)/0.01/101325 AS Atmospheric_Pressure_Multiples FROM DUAL;",
        "step": "【step1】: Calculate the total force exerted by the aircraft's maximum gross weight using Newtonian physics (F = m * g, where m = 600,000 kg and g = 9.8 m/s²).  【step2】: Compute disk loading by dividing the force by total disk area (0.01 m²) to get pressure in Pascals.  【step3】: Convert the pressure to multiples of atmospheric pressure by dividing by 101325 Pa (1 standard atmosphere).",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "1",
        "idx": 23,
        "question": "Calculate the rotational energy for the helicopter rotor using the Robinson R-22's maximum gross weight, a rotor radius of 5m, and a rotation speed of 300 RPM.",
        "query": "SELECT 0.5*(0.3*Max_Gross_Weight)*POWER(5,2)*POWER((2*PI()*300/60),2) AS Rotational_Energy FROM aircraft WHERE Aircraft='RobinsonR-22';",
        "step": "【step1】: Retrieve Max_Gross_Weight for 'RobinsonR-22' from aircraft table using WHERE clause  【step2】: Calculate angular velocity (2π*300RPM/60) and square the result  【step3】: Compute rotational energy using formula: 0.5*(0.3*Max_Gross_Weight)*r²*(angular_velocity)²",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "2",
        "idx": 24,
        "question": "Calculate the winning probability and its confidence interval for a 23-year-old pilot in the 2023 season.",
        "query": "WITH cte AS (SELECT COUNT(*) AS total, SUM(CASE WHEN p.Age=23 THEN 1 ELSE 0 END) AS wins FROM `match` m JOIN pilot p ON m.Winning_Pilot = p.Pilot_ID WHERE YEAR(m.Date) = 2023) SELECT ROUND(wins*1.0/total,3) AS p_value, ROUND(1.96 * SQRT((wins*1.0/total) * (1 - wins*1.0/total) / total), 3) AS margin FROM cte;",
        "step": "【step1】: Filter 2023 season matches and calculate total wins and age-specific wins by joining match and pilot tables  【step2】: Compute proportion (p_value) of wins by 23-year-old pilots using wins/total ratio  【step3】: Calculate confidence interval margin using normal approximation formula (1.96 * sqrt(p*(1-p)/n))",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "3",
        "idx": 25,
        "question": "Analyze whether the ratio of daily transfer passenger volume per aircraft movement exceeds the airport's ground handling capacity limit.",
        "query": "SELECT Transit_Passengers/(Aircraft_Movements/365) AS Daily_Transit_Per_Movement FROM airport;",
        "step": "【step1】: Compute daily average aircraft movements by dividing total annual Aircraft_Movements by 365 days.  【step2】: Calculate transit passenger volume allocated per movement by dividing Transit_Passengers by the daily average movements.  【step3】: Evaluate if the resulting ratio exceeds airport ground capacity thresholds (though explicit capacity metrics are absent in the schema, this calculation provides the critical comparison value).",
        "format": "MySQL"
    },
    {
        "db_id": "AirCraft",
        "type": "4",
        "idx": 26,
        "question": "If an airport's international passenger traffic reaches 5.1 × 10¹⁴ passengers, with each passenger occupying 0.5 m² of space, how many times the Earth's surface area would the terminal building need to be?",
        "query": "SELECT (1E15*0.5)/(5.1E14) AS Earth_Surface_Multiples FROM DUAL;",
        "step": "【step1】: Calculate total required terminal area by multiplying international passengers (1E15) by space per person (0.5m²) → (1E15 * 0.5)  【step2】: Obtain Earth's total surface area reference value → 5.1E14 m²  【step3】: Divide total required area by Earth's surface area → (1E15*0.5)/(5.1E14) AS Earth_Surface_Multiples",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 27,
        "question": "If there is a record in the warning event table where the event type is a tsunami with an impact radius of 200 kilometers, what is the propagation time in seconds for the tsunami wave to travel from the epicenter to the edge of the impact radius, assuming a wave speed of 200 meters per second?",
        "query": "SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;",
        "step": "【step1】:【Filter records in WarningEvent where EventType is 'tsunami' and RadiusKm equals 200】  【step2】:【Convert RadiusKm from kilometers to meters by multiplying by 1000】  【step3】:【Calculate propagation time by dividing adjusted radius (in meters) by the wave speed (200 m/s), aliased as PropagationTimeSeconds】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 28,
        "question": "The alert event table contains 1,000 records, with each record's severity level (SeverityLevel) ranging from 1 to 10. Assuming the severity data follows a normal distribution, calculate the percentage of events where the severity level exceeds 8 relative to the total number of events, and further compute the 99% confidence interval for the average severity level of these events.",
        "query": "WITH FilteredData AS (SELECT SeverityLevel FROM WarningEvent WHERE SeverityLevel > 8) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, AVG(SeverityLevel) - (2.576 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound, AVG(SeverityLevel) + (2.576 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound FROM FilteredData;",
        "step": "【step1】: Filter records with SeverityLevel >8 using CTE  【step2】: Calculate percentage by comparing filtered count (FROM CTE) to total count (subquery FROM base table)  【step3】: Compute confidence interval using formula: mean ± (Z-score * (stddev/√n)) with 2.576 Z-value for 99% confidence",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 29,
        "question": "There is a record in the early warning events table with the event type being flood and severity level of 8. Based on common knowledge, what emergency response measures might be applicable for such an event? Please reason in conjunction with flood disaster emergency management.",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;",
        "step": "【step1】: Filter WarningRule table entries where EventType equals 'flood'  【step2】: Apply additional filter for SeverityLevel = 8  【step3】: Extract ActionType values from the resulting records",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 30,
        "question": "Assuming there is a record in the warning event table with the event type as fire, an impact radius of 1,000 kilometers, an affected population of 100 million people, and an estimated loss of 1 trillion USD, which are extreme outliers (the normal range is an impact radius of 0–100 kilometers, an affected population of 0–1 million people, and an estimated loss of 0–10 billion USD). If the warning system records data every millisecond and the event data remains at these extreme values for 24 hours, how many times will the system trigger a warning? Assume the warning rule is an impact radius > 100 kilometers or an affected population > 1 million people or an estimated loss > 10 billion USD, and the query is run for the time period of '2023-01-01 00:00:00' to '2023-01-02 00:00:00'.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR PopulationAffected > 1000000 OR EstimatedDamageUSD > 10000000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Filter all records from WarningEvent where EventTime falls within the 24-hour period (BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00').  【step2】: Apply the warning condition filters (RadiusKm > 100 OR PopulationAffected > 1000000 OR EstimatedDamageUSD > 10000000000) to the time-filtered dataset.  【step3】: Count the total number of matching rows using COUNT(*) since the extreme values meet all three conditions simultaneously, resulting in one record per millisecond (86,400,000 triggers in 24 hours).",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 31,
        "question": "If there is a record in the warning event table with the event type as a volcanic eruption and a radius of 50 kilometers, what is the diffusion time in seconds calculated by converting the radius to meters and then dividing by a speed of 10 meters per second?",
        "query": "SELECT (RadiusKm * 1000) / 10 AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 50;",
        "step": "【step1】:【Filter records where EventType is 'volcanic eruption' and RadiusKm equals 50 using WHERE clause】  【step2】:【Convert RadiusKm from kilometers to meters by multiplying 1000】  【step3】:【Calculate diffusion time by dividing converted radius (in meters) by the speed of 10 meters/second】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 32,
        "question": "There are 7 records in the early warning event table, with estimated losses (EstimatedDamageUSD) of $5,000,000.00, $10,000,000.00, $2,000,000.00, $1,500,000.00, $50,000,000.00, $1,000,000.00, and $3,000,000.00 for each record. Please calculate the percentage of events where the estimated loss exceeds $20,000,000.00 relative to the total number of events.",
        "query": "SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 20000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;",
        "step": "【step1】: Calculate the number of events where EstimatedDamageUSD exceeds 20,000,000.00 USD using a conditional COUNT() with CASE WHEN.  【step2】: Divide the count from step1 by the total number of records (COUNT(*)), multiply by 100.0 to get the percentage, and alias the result as PercentageAboveThreshold.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 33,
        "question": "There is a record in the warning event table with an event type of tornado and severity level of 6. Based on common knowledge, what emergency response measures might this event involve? Please reason based on emergency management principles for tornado disasters.",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'tornado' AND SeverityLevel = 6;",
        "step": "【step1】: Filter WarningRule table where EventType matches 'tornado'  【step2】: Further filter results where SeverityLevel equals 6  【step3】: Extract ActionType values from the filtered rules",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 34,
        "question": "Assume there is a record in the warning event table where the event type is a tsunami, with an impact radius of 1000 kilometers, a severity level of 10, and estimated losses of 100,000,000.00 USD. This is an extreme outlier (the normal range is an impact radius of 0-200 kilometers, severity levels 1-9, and estimated losses of 0-50,000,000.00 USD). If the warning system logs data every millisecond, and the event data remains at these extreme values for 24 hours, how many times will the system trigger warnings? Assume the warning rule is triggered when the impact radius > 200 kilometers, or the severity level > 9, or the estimated losses > 50,000,000.00 USD.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 50000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Filter all records within the 24-hour period using `EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00'`.  【step2】: Apply the composite logical condition `(RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 50000000)` to identify extreme outliers.  【step3】: Execute `COUNT(*)` aggregation on the filtered results to calculate the total number of triggered warnings, yielding `WarningCount = 86,400,000` (24h × 60m × 60s × 1,000ms).",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 35,
        "question": "If there is a record in the alert event table with the event type as earthquake and an influence radius of 100 kilometers, please calculate the time required for the seismic wave to propagate from the epicenter to the edge of the influence radius based on the seismic wave speed (assuming it is 5 kilometers per second).",
        "query": "SELECT RadiusKm / 5 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'earthquake' AND RadiusKm = 100;",
        "step": "【step1】:【Filter records in WarningEvent where EventType is 'earthquake' and RadiusKm equals 100】  【step2】:【Calculate PropagationTimeSeconds by dividing RadiusKm by the seismic wave speed (5 km/s)】  【step3】:【Return the calculated PropagationTimeSeconds as the result】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 36,
        "question": "There are 10 records in the early warning event table, with estimated damages (EstimatedDamageUSD) of $1,000,000.00, $2,000,000.00, $3,000,000.00, $4,000,000.00, $5,000,000.00, $6,000,000.00, $7,000,000.00, $8,000,000.00, $9,000,000.00, and $10,000,000.00 respectively. What percentage of events have estimated damages exceeding $8,000,000.00?",
        "query": "SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 8000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;",
        "step": "【step1】: Calculate total number of events using COUNT(*) to get the denominator  【step2】: Count events exceeding $8,000,000 threshold using COUNT(CASE WHEN) conditional logic  【step3】: Compute percentage by multiplying qualifying count ratio with 100.0 and casting to floating-point division",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 37,
        "question": "There is a record in the warning rule table where the event type is flood and the severity level is 8. Based on common sense, what emergency response measures might this event entail? Please reason in combination with flood disaster emergency management.",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;",
        "step": "【step1】:【Query the WarningRule table to filter records where EventType matches 'flood'】  【step2】:【Apply additional filter on the pre-selected records to match SeverityLevel = 8】  【step3】:【Retrieve the ActionType values from the final filtered records】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 38,
        "question": "Assuming there is a record in the WarningEvent table with an impact radius of 5,000 kilometers, a severity level of 10, and estimated losses of $1,000,000,000,000.00. If the system records data every millisecond and the event data remains at these extreme values for 24 hours, how many times will the system trigger an early warning? Assume the early warning rule is triggered if the impact radius > 100 kilometers, or severity level > 9, or estimated losses > $100,000,000.00.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Filter all records in the WarningEvent table where EventTime falls within the 24-hour period from '2023-01-01 00:00:00' to '2023-01-02 00:00:00'.  【step2】: Apply the warning condition using OR logic: (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) to identify extreme values.  【step3】: Count the total number of qualifying records (1 per millisecond), resulting in 86,400,000 triggers (24h × 60m × 60s × 1000ms).",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 39,
        "question": "If there is a record in the early warning event table where the event type is fire and the impact radius is 2 kilometers, and the radius is divided by 0.1, what does the result represent?",
        "query": "SELECT RadiusKm / 0.1 AS SpreadTimeMinutes FROM WarningEvent WHERE EventType = 'fire' AND RadiusKm = 2;",
        "step": "【step1】: Filter records in WarningEvent table where EventType is 'fire' and RadiusKm equals 2  【step2】: Calculate SpreadTimeMinutes by dividing RadiusKm (2) by flame spread speed (0.1 km/minute)  【step3】: (not required for this simple calculation)",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 40,
        "question": "The alert event table contains 5 records, with affected population numbers (PopulationAffected) of 100, 200, 300, 400, and 500 people respectively. Please calculate the average affected population for these records.",
        "query": "SELECT AVG(PopulationAffected) AS AveragePopulationAffected FROM WarningEvent;",
        "step": "【step1】:【Access the WarningEvent table to retrieve the PopulationAffected column】  【step2】:【Apply the AVG() aggregate function to calculate the arithmetic mean of PopulationAffected values】  【step3】:【Alias the result as AveragePopulationAffected using the AS keyword】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 41,
        "question": "What action type is associated with the warning rule for a typhoon event with a severity level of 5?",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'typhoon' AND SeverityLevel = 5;",
        "step": "【step1】:【Execute the query to filter applicable rules】The query selects ActionType from WarningRule table where EventType matches 'typhoon' (typhoon) and SeverityLevel equals 5, retrieving predefined emergency actions associated with typhoons of severity 5.  【step2】:【Determine triggered actions】Check WarningTriggerRecord for records linked to the event's Id, verifying executed actions (ActionTaken) corresponding to the retrieved ActionType from step 1.  【step3】:【Validate notification measures】Cross-reference WarningNotificationRecord using TriggerId to confirm implementation details (e.g., recipient types, notification methods) for the actions, ensuring alignment with typhoon-specific protocols like mass evacuations or public alerts.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 42,
        "question": "Assuming there is a record in the early warning event table with the event type as earthquake, an impact radius of 1,000 kilometers, a severity level of 10, and an estimated loss of $10,000,000,000.00, which are extreme outliers (the normal range is an impact radius of 0-100 kilometers, severity level 1-9, and an estimated loss of $0-1,000,000.00). If the early warning system records data once per second and the event data remains at these extreme values for 24 hours, how many times will the system trigger an early warning between '2023-01-01 00:00:00' and '2023-01-02 00:00:00'? Assume the warning rules are: impact radius > 100 kilometers, or severity level > 9, or estimated loss > $1,000,000.00.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Filter all events within the 24-hour period (EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00').  【step2】: Apply the warning rules (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) to the filtered events.  【step3】: Count the number of records satisfying ANY of the three conditions using COUNT(*). Since data is recorded every second for 24 hours, the result is 86,400 total triggers.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 43,
        "question": "If there is a record in the early warning event table where the event type is tsunami and the affected radius is 200 kilometers, please calculate the time required for the tsunami wave to propagate from the source to the edge of the affected radius, assuming a propagation speed of 200 meters per second.",
        "query": "SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;",
        "step": "【step1】: Filter records in WarningEvent where EventType is 'tsunami' and RadiusKm equals 200.  【step2】: Convert RadiusKm to meters by multiplying by 1000 (200 km → 200,000 meters).  【step3】: Calculate propagation time by dividing the converted radius value by the wave speed (200,000 meters / 200 m/s = 1000 seconds).",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 44,
        "question": "There are 10 records in the early warning events table. Calculate the percentage of events where the estimated damage (EstimatedDamageUSD) falls between $3,000,000.00 and $7,000,000.00 out of the total number of events.",
        "query": "SELECT (COUNT(CASE WHEN EstimatedDamageUSD BETWEEN 3000000.00 AND 7000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageWithinRange FROM WarningEvent;",
        "step": "【step1】:【Filter records where EstimatedDamageUSD falls within the specified range (3,000,000.00 to 7,000,000.00) using CASE WHEN】  【step2】:【Count qualifying records (numerator) and total records (denominator) via COUNT() aggregation】  【step3】:【Calculate percentage by multiplying the ratio (numerator/denominator) by 100.0】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 45,
        "question": "What action type is specified in the warning rule for earthquake events with severity level 7?",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'earthquake' AND SeverityLevel = 7;",
        "step": "【step1】: Filter WarningRule records where EventType matches 'earthquake'  【step2】: Apply additional filter for SeverityLevel = 7 from the earthquake-specific subset  【step3】: Extract ActionType values (e.g., evacuation protocols, emergency response activation, public alert broadcasting) based on earthquake severity and radius thresholds.  Typical emergency measures for magnitude-7 earthquakes with 50km impact:  1. Immediate evacuation of high-risk zones  2. Activation of emergency response teams  3. Critical infrastructure shutdown (gas/power lines)  4. Emergency shelter deployment  5. Real-time public notification via multiple channels  6. Road clearance for rescue operations  7. Coordination with geological monitoring agencies  8. Secondary disaster prevention protocols (landslides/tsunamis)",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 46,
        "question": "Assume there is a record in the warning event table with a radius of 1,000 kilometers, a severity level of 10, and an estimated damage of 100,000,000,000.00 USD, which is an extreme outlier (normal ranges are radius 0-100 kilometers, severity level 1-9, estimated damage 0-1,000,000.00 USD). If the warning system records data once per second and the event data remains at these extreme values for 24 hours, and the query is run for the 24-hour period from '2023-01-01 00:00:00' to '2023-01-02 00:00:00', how many times will the system trigger warnings? The warning rules are defined as: radius > 100 kilometers or severity level > 9 or estimated damage > 1,000,000.00 USD.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Filter all records within the 24-hour period (2023-01-01 00:00:00 to 2023-01-02 00:00:00) using the EventTime condition.  【step2】: Apply the combined trigger conditions (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) to the filtered time range.  【step3】: Count all matching records (1 record per second × 86,400 seconds/day = 86,400 total warnings).",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 47,
        "question": "If there is a record in the early warning events table where the event type is a volcanic eruption, with an impact radius of 500 kilometers, and an initial ash dispersion speed of 20 meters per second that decays exponentially over time with a decay coefficient of 0.01 per second, what is the time required for the volcanic ash to disperse to the edge of the impact radius?",
        "query": "SELECT (20 / 0.01) * (1 - EXP(-0.01 * (500 * 1000 / 20))) AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 500;",
        "step": "【step1】:【Filter WarningEvent records with EventType 'volcanic eruption' and RadiusKm = 500】  【step2】:【Convert radius to meters (500 km → 500,000 meters) and calculate the base time component (500,000/20)】  【step3】:【Apply exponential decay formula: (20/0.01) * (1 - EXP(-0.01 * [base time])) to compute adjusted diffusion time】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 48,
        "question": "There are 1,000 records in the early warning event table, and the estimated damage (EstimatedDamageUSD) for each record follows a log-normal distribution. The known log mean (μ_ln) is 15, and the log standard deviation (σ_ln) is 2. Please calculate the percentage of events where the estimated damage exceeds $1,000,000,000.00 out of the total number of events, and further calculate the total estimated damage for these events.",
        "query": "WITH FilteredEvents AS (SELECT EstimatedDamageUSD FROM WarningEvent WHERE EstimatedDamageUSD > 1000000000.00) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, SUM(EstimatedDamageUSD) AS TotalDamageAboveThreshold FROM FilteredEvents;",
        "step": "【step1】: Filter event records in WarningEvent table where EstimatedDamageUSD exceeds 1,000,000,000.00 USD using a CTE (FilteredEvents).  【step2】: Calculate the count of filtered events (numerator) and their total EstimatedDamageUSD directly from FilteredEvents.  【step3】: Compute the percentage by dividing the filtered count by the total count from WarningEvent (denominator via subquery) and multiply by 100.0, then combine results with SUM aggregation.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 49,
        "question": "There is a record in the early warning event table with an event type of nuclear leak, a severity level of 10. Based on common knowledge, what emergency response measures might be taken for such an event? Please provide reasoning based on the emergency management of nuclear leakage disasters and analyze the long-term environmental impact on the affected areas.",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'nuclear leak' AND SeverityLevel = 10;",
        "step": "【step1】: Retrieve records from WarningRule table filtering by EventType='nuclear leak' and SeverityLevel=10  【step2】: Extract ActionType field from matched records",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 50,
        "question": "Assuming there is a record in the early warning event table with an impact radius of 100,000 kilometers, a severity level of 10, and estimated losses of $10,000,000,000,000.00. If the early warning system records data every millisecond and the event data remains at these extreme values for 365 days, how many times will the system trigger an early warning? The warning rule is defined as impact radius > 200 kilometers or severity level > 9 or estimated losses > $100,000,000.00.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
        "step": "【step1】: Filter all records within the time range '2023-01-01 00:00:00' to '2024-01-01 00:00:00' using the EventTime field.  【step2】: Apply the combined condition (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) to identify events violating any of the three thresholds.  【step3】: Aggregate the results by counting all matching rows to determine the total number of triggered warnings.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 51,
        "question": "If there is a record in the alert rule table where the event type is flood and the threshold value is 500, please calculate the time required to reach the alert threshold in hours assuming a rate of 10 units per hour.",
        "query": "SELECT ThresholdValue / 10 AS TimeToThresholdHours FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;",
        "step": "【step1】:【Filter WarningRule records where EventType is 'flood' and ThresholdValue equals 500】  【step2】:【Calculate TimeToThresholdHours by dividing ThresholdValue (500) by hourly rainfall rate (10)】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 52,
        "question": "There are 100 records in the alert rule table, each with threshold values (ThresholdValue) of 100, 200, 300, ..., 10,000 units, respectively. Calculate the percentage of rules where the threshold value exceeds 8,000 units out of the total number of rules.",
        "query": "SELECT (COUNT(CASE WHEN ThresholdValue > 8000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningRule;",
        "step": "【step1】: Calculate the number of rules where ThresholdValue exceeds 8000 using conditional aggregation  【step2】: Compute the total number of records in the WarningRule table  【step3】: Calculate the percentage by dividing the count from step1 by the count from step2 and multiplying by 100.0 to ensure floating-point precision",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 53,
        "question": "There is a record in the early warning rule table with an event type of fire, a threshold of 1000, and an action type of evacuation. What emergency response measures might this rule include?",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 1000 AND ActionType = 'evacuation';",
        "step": "【step1】: [Locate relevant rules] Access the WarningRule table and filter records where EventType is 'fire' to focus on fire-related rules  【step2】: [Apply threshold and action criteria] Refine the result by checking ThresholdValue = 1000 AND ActionType = 'evacuation' to isolate rules with specific temperature thresholds and evacuation actions  【step3】: [Extract response measures] Retrieve the ActionType field from the filtered records, which explicitly returns \"疏散\" while implicitly suggesting supplementary actions like activating emergency protocols, notifying authorities, deploying firefighters, and establishing safety perimeters based on fire emergency management practices.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 54,
        "question": "Assuming there is a record in the alert rule table with the event type \"nuclear leak,\" a threshold of 100,000 millisieverts (radiation dose), which is an extreme outlier (normal range is 0-100 millisieverts). If the alert system records data once per second and the event data remains at these extreme values for 365 days, how many alert records will be created in the WarningTriggerRecord table for this rule between '2023-01-01 00:00:00' and '2024-01-01 00:00:00'?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'nuclear leak' AND ThresholdValue > 100 AND ThresholdUnit = 'millisieverts') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
        "step": "【step1】: Retrieve RuleId from WarningRule table where EventType is 'nuclear leak', ThresholdValue > 100, and unit is 'millisieverts' using a subquery.  【step2】: Count all records in WarningTriggerRecord that match the obtained RuleId.  【step3】: Filter these records by the time range '2023-01-01 00:00:00' to '2024-01-01 00:00:00' using BETWEEN clause.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 55,
        "question": "If there is a record in the early warning rule table with the event type as earthquake and a threshold value of 5.0 (Richter magnitude), please calculate the time required for the seismic waves to travel from the hypocenter to a monitoring station 100 km away, and analyze the relationship between magnitude and seismic wave energy.",
        "query": "SELECT 100 / 5 AS PropagationTimeSeconds, POWER(10, 1.5 * ThresholdValue + 4.8) AS EarthquakeEnergy FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue = 5.0;",
        "step": "【step1】: Filter records in WarningRule table where EventType is 'earthquake' and ThresholdValue is 5.0  【step2】: Calculate wave propagation time using formula (100 km / 5 km/s) as PropagationTimeSeconds  【step3】: Compute earthquake energy relationship using empirical formula POWER(10, 1.5*ThresholdValue+4.8) as EarthquakeEnergy",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 56,
        "question": "The table contains 1,000 alert rules with threshold values from 1.0 to 1000.0 units in increments of 1.0. What percentage of rules have threshold values exceeding 800.0 units, and what is the total sum of threshold values for these rules?",
        "query": "WITH FilteredRules AS (SELECT ThresholdValue FROM WarningRule WHERE ThresholdValue > 800.0) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningRule)) AS PercentageAboveThreshold, SUM(ThresholdValue) AS TotalThresholdAbove FROM FilteredRules;",
        "step": "【step1】:【Filter records with ThresholdValue > 800.0 using CTE】  【step2】:【Calculate percentage by dividing filtered count by total count from WarningRule】  【step3】:【Sum ThresholdValue for filtered records to get TotalThresholdAbove】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 57,
        "question": "Retrieve the action type for the warning rule where the event type is 'tsunami', the threshold value is 10, and the action type is 'evacuation'.",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'tsunami' AND ThresholdValue = 10 AND ActionType = 'evacuation';",
        "step": "【step1】: Access WarningRule table filtering by EventType='tsunami', ThresholdValue=10  【step2】: Validate ActionType='evacuation' matches tsunami-specific emergency protocols  【step3】: Cross-check ThresholdUnit consistency (meters for wave height) and disaster response logic",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 58,
        "question": "Assuming there is a record in the warning rule table with the event type being volcanic eruption and a threshold of 1000 kilometers (volcanic ash dispersion range), which is an extreme outlier (the normal range is 0-100 kilometers). If the warning system records data every millisecond and the event data remains at these extreme values for 365 days, how many times will the system trigger a warning? The warning rule is defined as a volcanic ash dispersion range > 100 kilometers, and the query counts warnings triggered between 2023-01-01 and 2024-01-01.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'volcanic eruption' AND ThresholdValue > 100 AND ThresholdUnit = 'kilometer') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
        "step": "【step1】: Execute subquery to get RuleId: SELECT Id FROM WarningRule WHERE EventType = 'volcanic eruption' AND ThresholdValue > 100 AND ThresholdUnit = 'kilometer'  【step2】: Filter WarningTriggerRecord by the retrieved RuleId and time range: WHERE RuleId = [subquery result] AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00'  【step3】: Aggregate the filtered records using COUNT(*) to calculate total triggers: SELECT COUNT(*) AS WarningCount",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 59,
        "question": "If there is a record in the alert rule table with the event type as flood and a threshold value of 500 millimeters (rainfall), please provide the required rainfall to reach the alert threshold.",
        "query": "SELECT ThresholdValue AS RequiredRainfall FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;",
        "step": "【step1】:【Select the ThresholdValue column and rename it as RequiredRainfall from the WarningRule table】  【step2】:【Filter records where EventType is 'flood' (flood) and ThresholdValue equals 500】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 60,
        "question": "There are 10 records in the alert rule table, with threshold values (ThresholdValue) of 100, 200, 300, 400, 500, 600, 700, 800, 900, and 1000 units respectively. Please calculate the average threshold value of these records.",
        "query": "SELECT AVG(ThresholdValue) AS AverageThresholdValue FROM WarningRule;",
        "step": "【step1】:【Access the WarningRule table and target the ThresholdValue column】  【step2】:【Apply the AVG() function to compute the mean of ThresholdValue across all records】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 61,
        "question": "The warning rules table contains a record with an event type of fire, a threshold of 100 degrees Celsius, and an action type of notification. What emergency response measures might be associated with this rule?",
        "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 100 AND ActionType = 'notification';",
        "step": "【step1】: Filter records in WarningRule table where EventType equals 'fire' using WHERE EventType = 'fire'  【step2】: Apply additional constraints to the filtered results: ThresholdValue = 100 AND ActionType = 'notification'  【step3】: Extract the ActionType field from the fully qualified records  Fire emergency response measures may include:  1. Immediate evacuation protocols  2. Activation of fire suppression systems  3. Emergency services notification (fire department/hospital)  4. Critical infrastructure shutdown (gas/electricity)  5. Mass notification through multiple channels (SMS/broadcast)  6. Crowd management and safe route guidance  7. Post-incident safety inspections  8. Data logging for incident analysis and rule optimization",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 62,
        "question": "Assuming there is a record in the warning rule table with the event type as earthquake, a threshold of 9.0 (Richter scale). If the early warning system records data once per second and the event data remains at 10.0, which is above the threshold, throughout 24 hours, how many warning alerts will the system trigger between '2023-01-01 00:00:00' and '2023-01-02 00:00:00'?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue > 9.0 AND ThresholdUnit = 'Richter scale') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Execute subquery to retrieve RuleId from WarningRule where EventType='earthquake' with ThresholdValue>9.0 and ThresholdUnit='Richter scale'  【step2】: Filter WarningTriggerRecord by matching RuleId from step1 and TriggerTime between '2023-01-01 00:00:00' and '2023-01-02 00:00:00'  【step3】: Count total matching records using COUNT(*) aggregation",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 63,
        "question": "If there is a record in the alert trigger log table with a trigger value of 1000, please calculate the time to trigger in hours by dividing the trigger value by 50.",
        "query": "SELECT TriggerValue / 50 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 1000;",
        "step": "【step1】: Access the WarningTriggerRecord table to locate entries where the TriggerValue equals 1000.  【step2】: Extract the TriggerValue field from the filtered record.  【step3】: Calculate TimeToTriggerHours by dividing the TriggerValue (1000 mm) by the rainfall rate (50 mm/h), yielding 20 hours as the result.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 64,
        "question": "The warning trigger record table contains 1,000 entries, with each entry's trigger value (TriggerValue) being 100, 200, 300, ..., 100,000 units, respectively. What percentage of records have a trigger value exceeding 80,000 units out of the total number of records?",
        "query": "SELECT (COUNT(CASE WHEN TriggerValue > 80000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningTriggerRecord;",
        "step": "【step1】:【Filter records where TriggerValue exceeds 80000】  【step2】:【Count qualified records and total records】  【step3】:【Calculate percentage using (qualified_count * 100.0 / total_count)】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 65,
        "question": "There is a record in the early warning trigger log with a trigger value of 100 degrees Celsius (temperature) and an action taken of evacuation. Based on common knowledge, what emergency response measures might be triggered by this? Please reason in conjunction with emergency management for high-temperature disasters.",
        "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';",
        "step": "【step1】: Filter WarningTriggerRecord where TriggerValue=100 and TriggerUnit='Celsius' to identify high-temperature triggers  【step2】: Further filter records where ActionTaken='evacuation' to isolate evacuation actions  【step3】: Retrieve ActionTaken field confirming the implemented emergency measure aligns with high-temperature disaster protocols",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 66,
        "question": "Assuming there is a record in the alert trigger log with a trigger value of 1,000,000 millisieverts (radiation dose), which is an extreme outlier (normal range is 0-100 millisieverts). If the alert system records data once per second and these extreme values persist for 365 days, how many alerts will the system trigger in 2023? The alert rule is defined as radiation dose > 100 millisieverts.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
        "step": "【step1】: Filter all records in WarningTriggerRecord where TriggerTime falls between '2023-01-01 00:00:00' and '2024-01-01 00:00:00'.  【step2】: Apply conditions TriggerValue > 100 and TriggerUnit = 'millisieverts' to the filtered temporal dataset.  【step3】: Calculate the total count of qualifying records using COUNT(*) as WarningCount.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 67,
        "question": "If there is a record in the early warning trigger log table with a trigger value of 5000 millimeters (rainfall), and the natural logarithm of the trigger value divided by 0.0001 is divided by 0.1 to determine the time in hours to reach the trigger value, what is the calculated time and how does the rainfall change over time under an exponential growth model?",
        "query": "SELECT LN(TriggerValue / 0.0001) / 0.1 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 5000;",
        "step": "【step1】: Filter records with TriggerValue=5000 using WHERE clause to isolate the specific exponential growth scenario  【step2】: Apply natural logarithm LN(5000/0.0001) to calculate exponent component in growth formula V(t)=V0*e^(0.1t)  【step3】: Divide logarithmic result by growth coefficient 0.1 to derive time-to-trigger in hours while demonstrating exponential growth trend analysis",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 68,
        "question": "The warning trigger log table contains 10,000 records, and the trigger value (TriggerValue) of each record follows a lognormal distribution. It is known that the logarithmic mean (μ_ln) is 10 and the logarithmic standard deviation (σ_ln) is 2. Please use the SQL query to calculate the percentage of records with trigger values exceeding 100,000 units out of the total number of records, and further compute the sum of the trigger values for these records.",
        "query": "WITH FilteredRecords AS (SELECT TriggerValue FROM WarningTriggerRecord WHERE TriggerValue > 100000) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningTriggerRecord)) AS PercentageAboveThreshold, SUM(TriggerValue) AS TotalTriggerValueAbove FROM FilteredRecords;",
        "step": "【step1】: Create CTE FilteredRecords to select records with TriggerValue exceeding 100,000  【step2】: Calculate percentage by dividing filtered count by total count via subquery  【step3】: Compute total sum of TriggerValue from filtered records",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 69,
        "question": "There is a record in the early warning trigger log with a trigger value of 1000°C (temperature) and an action type of evacuation. Based on common sense, what emergency response measures might be triggered? Please infer by combining emergency management for extreme heat disasters and analyze the impacts of high temperatures on the environment and human health.",
        "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';",
        "step": "【step1】: Access WarningTriggerRecord table and filter records where TriggerValue=1000 AND TriggerUnit='Celsius'  【step2】: Apply additional filter condition ActionTaken='evacuation' to isolate evacuation actions  【step3】: Extract ActionTaken column values from fully filtered records",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 70,
        "question": "In the warning trigger log table, what action was taken for the record with a trigger value of 1000°C (temperature) and an action type of evacuation?",
        "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';",
        "step": "【step1】: Filter records in WarningTriggerRecord where TriggerValue equals 1000 and TriggerUnit is 'Celsius'.  【step2】: Apply an additional filter to select only records where ActionTaken is 'evacuation'.  【step3】: Retrieve the ActionTaken field from the filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 71,
        "question": "If there is a record in the alert trigger log table with a trigger value of 100 millimeters, please calculate the required time to reach the trigger value in hours.",
        "query": "SELECT TriggerValue / 10 AS RequiredTime FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'millimeters';",
        "step": "【step1】: Filter records from WarningTriggerRecord where TriggerValue is 100 millimeters using the WHERE clause with conditions `TriggerValue = 100 AND TriggerUnit = 'millimeters'`.  【step2】: Calculate the required rainfall time by dividing the TriggerValue (100) by the rainfall rate (10 mm/hour), expressed as `TriggerValue / 10 AS RequiredTime`.  【step3】: Extract the computed result (RequiredTime) directly from the filtered record without additional joins or sorting.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 72,
        "question": "There are 10 records in the warning trigger log table, with trigger values (TriggerValue) of 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 units respectively. Please calculate the average trigger value for these records.",
        "query": "SELECT AVG(TriggerValue) AS AverageTriggerValue FROM WarningTriggerRecord WHERE TriggerValue IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);",
        "step": "【step1】:【Filter records from WarningTriggerRecord where TriggerValue is in the specified list (100, 200, ..., 1000) using the WHERE clause】  【step2】:【Apply the AVG() function to calculate the average of the TriggerValue column from the filtered records】  【step3】:【Assign the result column alias AverageTriggerValue using the AS keyword】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 73,
        "question": "There is a record in the early warning trigger log with a trigger value of 50 degrees Celsius (temperature) and the action taken as notification. Based on common knowledge, what emergency response measures might this trigger include? Please reason based on emergency management of high-temperature disasters.",
        "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 50 AND TriggerUnit = 'Celsius' AND ActionTaken = 'notification';",
        "step": "【step1】: Retrieve the triggered rule's action type by joining WarningTriggerRecord with WarningRule using RuleId, verifying the 50°C threshold corresponds to high-temperature events.  【step2】: Cross-reference WarningEvent's SeverityLevel and PopulationAffected to determine required escalation steps (e.g., public alerts for SeverityLevel≥7 or large populations).  【step3】: Analyze HistoricalDataAnalysis.FalseAlarmRate to validate reliability before recommending extended actions like evacuation/equipment deployment.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 74,
        "question": "Assuming there is a record in the alarm trigger log with a trigger value of 1000 millisieverts (radiation dose), which is an extreme outlier (normal range is 0-100 millisieverts). If the alarm system records data once per second and the event data remains at these extreme values for 24 hours, how many alarms will the system trigger between October 1, 2023, 00:00:00 and October 2, 2023, 00:00:00? Assume the alarm rule is radiation dose > 100 millisieverts and the unit is millisieverts.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
        "step": "【step1】: Filter records within the 24-hour period using `TriggerTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00'` to isolate data from the specified time range.  【step2】: Apply dual conditions `TriggerValue > 100` and `TriggerUnit = 'millisieverts'` to select records exceeding the radiation threshold with correct units.  【step3】: Aggregate results using `COUNT(*)` to calculate the total number of valid warning triggers as `WarningCount`.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 75,
        "question": "If there is a record in the warning notification table with the notification method as broadcast, the propagation speed of the broadcast signal is 3^8 meters/second, and the receiver is 100 meters away from the notification source, please calculate the time required for the broadcast signal to propagate from the notification source to the receiver.",
        "query": "SELECT (100 * 1000) / POW(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';",
        "step": "【step1】: Filter records from WarningNotificationRecord where NotificationMethod is 'broadcast' using the WHERE clause  【step2】: Calculate propagation time for each matching record using (100*1000)/POW(3,8) formula  【step3】: Return computed PropagationTime value for all qualified records as result set",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 76,
        "question": "The warning notification record table contains 1,000 entries. Assuming the number of recipients follows a normal distribution with a mean of 50,500 and a standard deviation of 28,722.81, calculate the percentage of notification records where the number of recipients exceeds 80,000 people out of the total number of notification records.",
        "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 80000;",
        "step": "【step1】: Filter records with RecipientCount > 80000 using WHERE clause.  【step2】: Calculate the count of filtered records (numerator) and total record count via subquery (denominator).  【step3】: Compute percentage by dividing numerator by denominator and multiplying by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 77,
        "question": "In the early warning notification records table, there is a record where the notification method is SMS and the recipient type is people. Based on common sense, what emergency response measures might this type of notification include? Please reason by combining emergency management for SMS notifications.",
        "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'people';",
        "step": "【step1】: Execute base query to retrieve notification content targeting general public via SMS from WarningNotificationRecord  【step2】: Join with WarningEvent via EventID to obtain event type (e.g. earthquake/flood) and severity level  【step3】: Cross-reference WarningRule thresholds and action types based on event characteristics to infer emergency measures: evacuation protocols, shelter locations, emergency contact numbers, resource distribution points, real-time situation updates, and safety precaution reminders.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 78,
        "question": "Assuming there is a record in the alert notification log with a recipient count of 1,000,000,000, which is an extreme outlier (normal range is 0–1,000,000). If the alert system records data once per second and maintains these extreme values continuously for 365 days, how many times would the system trigger notifications? The notification rule is: recipient count > 1,000,000 and the notification time is within the year 2023.",
        "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter all records in WarningNotificationRecord where NotificationTime falls within the entire year 2023 (2023-01-01 00:00:00 to 2023-12-31 23:59:59).  【step2】: Apply the condition RecipientCount > 1000000 to the filtered records from Step 1.  【step3】: Count the total number of matching rows from Step 2 and return it as NotificationCount.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 79,
        "question": "If there is a record in the alert notification table with a notification method as broadcast, the propagation speed of the broadcast signal is the speed of light (approximately 3×10^8 meters per second), and the receiver is 1000 meters away from the notification source. Considering the atmospheric attenuation of signal propagation with an attenuation coefficient of 0.001 per meter, calculate the time required for the broadcast signal to propagate from the notification source to the receiver and analyze the attenuation of signal strength.",
        "query": "SELECT (1000 * 1000) / POW(3, 8) AS PropagationTime, EXP(-0.001 * 1000) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';",
        "step": "【step1】:【Filter the notification record with 'broadcast' method】  【step2】:【Calculate propagation time by dividing converted distance (1000km to meters) by speed of light】  【step3】:【Compute signal attenuation using exponential decay formula with given coefficient and distance】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 80,
        "question": "In the warning notification record table, please calculate the percentage of notification records where the number of recipients exceeds 1,000,000 out of the total number of notification records. Additionally, calculate the total sum of recipients for these records.",
        "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage, SUM(RecipientCount) AS TotalRecipients FROM WarningNotificationRecord WHERE RecipientCount > 1000000;",
        "step": "【step1】: Filter records from WarningNotificationRecord where RecipientCount exceeds 1,000,000 using the WHERE clause.  【step2】: Calculate total records count via subquery (SELECT COUNT(*) FROM WarningNotificationRecord) to serve as the denominator for percentage calculation.  【step3】: Compute final results by combining filtered COUNT(*) (numerator) with total count to derive percentage, and sum RecipientCount for qualifying records using aggregate functions.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 81,
        "question": "What does the NotificationContent contain for records where the NotificationMethod is 'broadcast' and the RecipientType is 'people'?",
        "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast' AND RecipientType = 'people';",
        "step": "【step1】: Filter records from WarningNotificationRecord where NotificationMethod is 'broadcast' (broadcast) and RecipientType is 'people' (public) using the WHERE clause conditions  【step2】: Join with WarningEvent via EventId to contextualize the emergency type (e.g., earthquake, flood) and severity level  【step3】: Join with WarningTriggerRecord via TriggerId to retrieve associated actions (ActionTaken) and severity thresholds, then extract NotificationContent for广播-based emergency protocols",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 82,
        "question": "Assuming there is a record in the warning notification record table where the number of recipients is 10,000,000 and occurs every millisecond between '2023-01-01 00:00:00.000' and '2023-12-31 23:59:59.999', how many notifications would the system count?",
        "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';",
        "step": "【step1】: Filter all records in WarningNotificationRecord where RecipientCount exceeds 1,000,000 using the predicate `RecipientCount > 1000000`.  【step2】: Apply the time filter `NotificationTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999'` to restrict results to the 2023 calendar year.  【step3】: Calculate the total number of matching rows using `COUNT(*)`, resulting in the final count of notifications triggered (one per millisecond × 365 days).",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 83,
        "question": "If there is a record in the early warning notification log table with the notification method as SMS, where the SMS signal propagates at a speed of 3^8 meters per second, and the recipient is 10,000 meters away from the notification source, please calculate the time required for the SMS signal to travel from the notification source to the recipient.",
        "query": "SELECT (10 * 1000) / POW(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS';",
        "step": "【step1】: Filter records from WarningNotificationRecord where NotificationMethod is 'SMS'  【step2】: Convert 10 kilometers to meters (10*1000)  【step3】: Calculate propagation time using (distance_in_meters)/(3*10^8) with corrected formula: (10*1000)/(3*POWER(10,8)) instead of incorrect POW(3,8)",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 84,
        "question": "There are 10 records in the early warning notification log, with the number of recipients (RecipientCount) for each record being 100, 200, 300, 400, 500, 600, 700, 800, 900, and 1000 people respectively. Please calculate the average number of recipients for these records.",
        "query": "SELECT AVG(RecipientCount) AS AverageRecipientCount FROM WarningNotificationRecord WHERE RecipientCount IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);",
        "step": "【step1】: Filter records from WarningNotificationRecord where RecipientCount matches the specified values (100, 200, ..., 1000) using the IN clause.  【step2】: Apply the AVG() function to calculate the average of the filtered RecipientCount values.  【step3】: Assign the calculated average to the alias \"AverageRecipientCount\" using the AS keyword.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 85,
        "question": "There is a record in the early warning notification log where the notification method is email and the recipient type is an enterprise. Based on common knowledge, what emergency response measures might such a notification include? Please make inferences in conjunction with the emergency management of email notifications.",
        "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'email' AND RecipientType = 'enterprise';",
        "step": "【step1】:Execute query to retrieve NotificationContent containing emergency instructions for enterprise email alerts  【step2】:Join WarningNotificationRecord with WarningEvent via EventId to obtain event specifics (SeverityLevel,Location,RadiusKm)  【step3】:Cross-reference with WarningRule through RuleId to determine applicable ActionType and Severity-based protocols",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 86,
        "question": "Assuming there is a record in the warning notification log with 1,000,000 recipients, which is an extreme outlier (normal range being 0-100,000 recipients). If the warning system records data once per second and these extreme values persist for 24 hours, how many times will the system trigger notifications? Assume the notification rule is triggered when the recipient count exceeds 100,000 and the count is for records within a specific 24-hour period starting from October 1, 2023.",
        "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 100000 AND NotificationTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
        "step": "【step1】: Filter records within the 24-hour time range (NotificationTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00').  【step2】: Apply the RecipientCount > 100,000 condition to identify extreme values.  【step3】: Count all qualifying rows (COUNT(*)) to determine the total notifications triggered (86,400 times, as 1 record/second × 86,400 seconds/day).",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 87,
        "question": "If there is a record in the warning notification log where the notification method is broadcast, the propagation speed of the broadcast signal is 3^8 (6561) units per second, and the receiver is 500 units away from the notification source, while also considering the signal attenuation with a factor of 0.0005 per unit distance at 500 units. Please calculate the time required for the broadcast signal to propagate from the notification source to the receiver and analyze the attenuation of the signal strength.",
        "query": "SELECT (500 * 1000) / POW(3, 8) AS PropagationTime, EXP(-0.0005 * 500) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';",
        "step": "【step1】: Filter records where NotificationMethod is 'Broadcast' using WHERE clause  【step2】: Calculate propagation time with (500,000 meters)/(3^8 m/s) using arithmetic operations  【step3】: Compute signal attenuation using EXP(-0.0005*500) exponential decay formula",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 88,
        "question": "There are 1,000 records in the WarningNotificationRecord table. Given that the recipient counts follow a normal distribution with a mean of 500,500 and a standard deviation of 288,675.1, calculate the percentage of notification records with recipient counts exceeding 800,000 out of the total number of notification records.",
        "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 800000;",
        "step": "【step1】: Execute the subquery `(SELECT COUNT(*) FROM WarningNotificationRecord)` to calculate the total number of notification records (1000).  【step2】: Filter records with `RecipientCount > 800000` and calculate the count using `COUNT(*)`.  【step3】: Compute the percentage by dividing the filtered count by the total count from Step 1 and multiplying by `100.0`.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 89,
        "question": "There is a record in the early warning notification log where the notification method is SMS and the recipient type is government. Based on common knowledge, what emergency response measures might this type of notification include? Please reason by considering the emergency management aspects of SMS notifications.",
        "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'government';",
        "step": "【step1】:【Filter records in WarningNotificationRecord where NotificationMethod is 'SMS' and RecipientType is 'government'】  【step2】:【Extract the NotificationContent field from the filtered records】  【step3】:【Return the emergency response measures described in the NotificationContent, which typically include evacuation orders, resource deployment instructions, emergency shelter locations, real-time monitoring updates, inter-departmental coordination directives, and public communication protocols based on government emergency management procedures】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 90,
        "question": "Assuming there is a record in the alert notification log with a recipient count of 100,000,000, which is an extreme outlier (normal range is 0-1,000,000 people). If the alert system records data once per second and these extreme values persist for 365 days, how many times will the system trigger notifications? The notification rule is set for recipient counts > 1,000,000 people, and the query counts notifications in the year 2023.",
        "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter all records in WarningNotificationRecord where NotificationTime falls within the entire year of 2023 (2023-01-01 00:00:00 to 2023-12-31 23:59:59)  【step2】: Apply the condition RecipientCount > 1,000,000 to the filtered records  【step3】: Calculate the total count of qualifying records using COUNT(*) as NotificationCount",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 91,
        "question": "If there is a record in the historical data analysis table with the event type as flood, the average severity as 7, and the flood wave propagation speed recorded as 5 meters/second, please calculate the time required for the flood wave to propagate from the event location to a monitoring station 100 kilometers away.",
        "query": "SELECT (100 * 1000) / 5 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 7;",
        "step": "【step1】: Filter the HistoricalDataAnalysis table to retrieve records where EventType is 'flood' and AverageSeverity equals 7.  【step2】: Calculate the propagation time by dividing the distance (100 kilometers converted to 100,000 meters) by the given speed of 5 meters per second.  【step3】: Return the calculated result as the PropagationTime column in the output.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 92,
        "question": "Assuming the average severity follows a normal distribution with a mean of 5.5 and a standard deviation of 2.872, calculate the percentage of records whose average severity exceeds 8.0 relative to the total number of records.",
        "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;",
        "step": "【step1】: Calculate total number of records using subquery: (SELECT COUNT(*) FROM HistoricalDataAnalysis)  【step2】: Count records where AverageSeverity > 8.0 in main query: COUNT(*) FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0  【step3】: Calculate percentage by dividing qualified count (step2) by total count (step1), then multiply by 100.0",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 93,
        "question": "In the historical data analysis table, there is a record with an event type of earthquake, an average severity of 6, and a false alarm rate of 5. Based on common knowledge, what emergency response measures might be taken for such an event? Please reason by combining emergency management for earthquake disasters.",
        "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'earthquake' AND AverageSeverity = 6 AND FalseAlarmRate = 5;",
        "step": "【step1】: Filter records in HistoricalDataAnalysis table where EventType='earthquake', AverageSeverity=6, and FalseAlarmRate=5 using WHERE clause  【step2】: Select the AnalysisResult field from the filtered records  【step3】: Verify result uniqueness since multiple records might meet severe earthquake criteria with identical analysis parameters",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 94,
        "question": "How many records in the HistoricalDataAnalysis table have a TotalEvents value greater than 10,000 and an AnalysisTime within the year 2023?",
        "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter all records in HistoricalDataAnalysis where AnalysisTime is within the specified year (2023-01-01 to 2023-12-31).  【step2】: Apply the condition TotalEvents > 10000 to identify extreme values.  【step3】: Count the number of matching records (31,536,000, equal to total seconds in 365 days) since every second's record satisfies the condition.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 95,
        "question": "If there is a record in the historical data analysis table where the event type is a tsunami and the maximum severity is 10, please calculate the time required for the tsunami wave to propagate 1000 kilometers at a speed of 200 meters/second and analyze the energy attenuation over 1000 kilometers with an attenuation coefficient of 0.01.",
        "query": "SELECT (1000 * 1000) / 200 AS PropagationTime, EXP(-0.01 * 1000) AS EnergyAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'tsunami' AND MaxSeverity = 10;",
        "step": "【step1】: Filter records from HistoricalDataAnalysis where EventType is 'tsunami' and MaxSeverity equals 10  【step2】: Calculate propagation time by converting 1000km to meters (1000*1000) and dividing by wave speed 200 m/s  【step3】: Compute energy attenuation using exponential decay formula EXP(-0.01*1000) based on given coefficient 0.01/km over 1000km distance",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 96,
        "question": "The historical data analysis table contains 10,000 records. The average severity (AverageSeverity) of each record follows a lognormal distribution, with a known log mean (μ_ln) of 1.5 and a log standard deviation (σ_ln) of 0.5. Please calculate the percentage of records with an average severity exceeding 8.0 out of the total number of records, and further compute the total sum of average severity for these records.",
        "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage, SUM(AverageSeverity) AS TotalAverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;",
        "step": "【step1】:【Filter records where AverageSeverity exceeds 8.0】  【step2】:【Calculate percentage using subquery (COUNT of filtered records ×100 / total COUNT)】  【step3】:【Compute total sum of qualifying AverageSeverity values and combine results】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 97,
        "question": "There is a record in the historical data analysis table with an event type of nuclear leak, a maximum severity level of 10, and a false alarm rate of 0.1. Based on common knowledge, what emergency response measures might be taken for such an event? Please reason in the context of emergency management for nuclear leakage disasters and analyze the long-term impacts of nuclear leakage on the environment and human health.",
        "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'nuclear leak' AND MaxSeverity = 10 AND FalseAlarmRate = 0.1;",
        "step": "【step1】: Access HistoricalDataAnalysis table with EventType='nuclear leak' filter  【step2】: Apply MaxSeverity=10 and FalseAlarmRate=0.1 filters on results  【step3】: Extract AnalysisResult column from fully filtered dataset",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 98,
        "question": "Suppose there is a record in the historical data analysis table with a total event count of 10,000,000,000, which is an extreme outlier (the normal range is 0-10,000). If the warning system logs data every millisecond and the event data remains at these extreme values for the entire year 2023, how many analyses will the system trigger? Assume the analysis rule is a total event count > 10,000.",
        "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';",
        "step": "【step1】: Filter all records in `HistoricalDataAnalysis` where `AnalysisTime` falls between '2023-01-01 00:00:00.000' and '2023-12-31 23:59:59.999'.  【step2】: Apply the condition `TotalEvents > 10000` to the filtered records.  【step3】: Calculate the total count of qualifying records using `COUNT(*)` and return it as `AnalysisCount`.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 99,
        "question": "If there is a record in the historical data analysis table with an event type of \"volcanic eruption\" and a maximum severity level of 9, calculate the time taken for volcanic ash to diffuse 500 kilometers at a speed of 10 meters per second and the resulting concentration attenuation.",
        "query": "SELECT (500 * 1000) / 10 AS DiffusionTime, EXP(-0.005 * ((500 * 1000) / 10)) AS ConcentrationAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'volcanic eruption' AND MaxSeverity = 9;",
        "step": "【step1】: Filter records in HistoricalDataAnalysis where EventType is 'volcanic eruption' and MaxSeverity equals 9  【step2】: Calculate diffusion time by dividing 500km (converted to 500,000 meters) by the speed of 10m/s: (500*1000)/10  【step3】: Compute concentration attenuation using exponential decay formula EXP(-0.005*diffusion_time) with the calculated time from Step 2",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 100,
        "question": "The historical data analysis table contains 1,000 records, with the maximum severity (MaxSeverity) of each record being 1.0, 2.0, 3.0, ..., 10.0. It is known that the overall average of the maximum severity is 5.5, and the overall standard deviation is 2.872. Assuming the maximum severity follows a normal distribution, calculate the percentage of records where the maximum severity exceeds 8.0 relative to the total number of records.",
        "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE MaxSeverity > 8.0;",
        "step": "【step1】: Calculate total record count using subquery (SELECT COUNT(*) FROM HistoricalDataAnalysis)  【step2】: Filter records with MaxSeverity > 8.0 and calculate matching count (COUNT(*))  【step3】: Compute percentage by dividing filtered count by total count and multiplying by 100",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 101,
        "question": "In the historical data analysis table, there is a record with the event type as tornado, a maximum severity of 8, and a false alarm rate of 2. What emergency response measures might be applicable for such an event based on the data? Please reason in conjunction with the emergency management of tornado disasters.",
        "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'tornado' AND MaxSeverity = 8 AND FalseAlarmRate = 2;",
        "step": "【step1】: Access HistoricalDataAnalysis table to retrieve analysis results for tornado events  【step2】: Filter records where EventType='tornado' (tornado) and MaxSeverity=8 (highest severity level in this context)  【step3】: Apply final filter with FalseAlarmRate=2% and extract AnalysisResult containing emergency response recommendations",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 102,
        "question": "If the system records data once per second and the event count consistently exceeds 10,000 for 365 days, how many times will the analysis be triggered?",
        "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter records from HistoricalDataAnalysis where AnalysisTime falls within the 2023 calendar year  【step2】: Apply the condition TotalEvents > 10000 to the filtered records  【step3】: Count all remaining records with COUNT(*) and alias as AnalysisCount",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 103,
        "question": "If there is a record in the historical data analysis table with the event type being flood and an average severity of 5, calculate the time required for the flood wave to travel 50 kilometers.",
        "query": "SELECT (50 * 1000) / 2 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 5;",
        "step": "【step1】:【Filter records from HistoricalDataAnalysis where EventType is 'flood' and AverageSeverity equals 5】  【step2】:【Convert 50 kilometers to meters (50 * 1000) to align with the speed unit (meters/second)】  【step3】:【Calculate propagation time by dividing the converted distance (50,000 meters) by the given speed (2 m/s)】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 104,
        "question": "There are 10 records in the historical data analysis table, with each record's average severity (AverageSeverity) being 1.0, 2.0, 3.0, ..., 10.0 respectively. Please calculate the average severity of these records.",
        "query": "SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0);",
        "step": "【step1】:【Filter records with AverageSeverity between 1.0 to 10.0 using WHERE clause and IN operator】  【step2】:【Calculate mathematical average of the filtered AverageSeverity values using AVG() function】  【step3】:【Alias the calculated result as AverageSeverity using AS keyword for clear output labeling】",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 105,
        "question": "In the historical data analysis table, there is a record with an event type of fire, an average severity level of 4, and a false alarm rate of 3. Based on common knowledge, what emergency response measures might be applicable for such an event? Please reason by combining emergency management for fire disasters.",
        "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 4 AND FalseAlarmRate = 3;",
        "step": "【step1】: Filter the HistoricalDataAnalysis table by EventType='fire' to isolate fire-related historical records  【step2】: Apply additional filters for AverageSeverity=4 and FalseAlarmRate=3% to pinpoint the specific analysis record  【step3】: Retrieve the AnalysisResult field containing predefined emergency response recommendations tied to fire events with these parameters  【step1】: Activate evacuation protocols for affected areas (determined by RadiusKm and PopulationAffected) based on severity level 4  【step2】: Deploy firefighting resources and emergency medical teams using Location/Latitude/Longitude data from linked WarningEvent records  【step3】: Initiate public alerts via NotificationMethod=广播 (broadcast) to RecipientType=公众 while validating system accuracy through FalseAlarmRate analysis",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 106,
        "question": "Assuming there is a record in the historical data analysis table with a total event count of 100,000, which is an extreme outlier (the normal range is 0-10,000). If the alert system records data every second and the event data remains at these extreme values for 24 hours, how many times will the system trigger an analysis between '2023-10-01 00:00:00' and '2023-10-02 00:00:00'? Assume the analysis rule is that the total event count > 10,000.",
        "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
        "step": "【step1】: Filter records within the specified 24-hour time range using the `BETWEEN` condition on `AnalysisTime`.  【step2】: Apply the threshold condition `TotalEvents > 10000` to identify extreme values.  【step3】: Count the total matching records to determine the number of triggered analyses with `COUNT(*)`.",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "1",
        "idx": 107,
        "question": "If there is an earthquake event in the WarningEvent table with a radius of 20 kilometers, what is the propagation time of the seismic waves?",
        "query": "SELECT RadiusKm / 5 AS PropagationTime FROM WarningEvent WHERE EventType = 'earthquake';",
        "step": "【step1】: Access the WarningEvent table to retrieve earthquake-related records  【step2】: Filter records where EventType = 'earthquake' (Earthquake)  【step3】: Calculate PropagationTime using formula (RadiusKm / 5) from remaining record(s)",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "2",
        "idx": 108,
        "question": "There are 5 records in the historical data analysis table, with an average severity (AverageSeverity) of 1.0, 2.0, 3.0, 4.0, and 5.0 for each record respectively. Please calculate the average severity of these records.",
        "query": "SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0);",
        "step": "【step1】: Filter records from HistoricalDataAnalysis where AverageSeverity matches the specified values (1.0, 2.0, 3.0, 4.0, 5.0) using the IN clause  【step2】: Calculate the average of the filtered AverageSeverity values using the AVG aggregation function",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "3",
        "idx": 109,
        "question": "There is a record in the historical data analysis table with an event type of fire, an average severity level of 3, and a false alarm rate of 1. Based on common sense, what possible emergency response measures might be taken for such an event? Please reason accordingly in the context of emergency management for fire disasters.",
        "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 3 AND FalseAlarmRate = 1;",
        "step": "【step1】: Access HistoricalDataAnalysis table to filter records where EventType is 'fire' (fire)  【step2】: Apply compound conditions: AverageSeverity = 3 AND FalseAlarmRate = 1%  【step3】: Extract AnalysisResult column containing pre-concluded emergency protocols  Typical emergency responses inferred:  1. Activate fire containment protocols  2. Dispatch firefighting teams and EMS  3. Evacuate within radius per WarningRule.RadiusKm  4. Issue public alerts via WarningNotificationRecord methods  5. Coordinate with WarningRule.ActionType = 'evacuation' (evacuation)  6. Monitor via WarningTriggerRecord.TriggerValue thresholds  7. Validate using HistoricalDataAnalysis.FalseAlarmRate to optimize resource deployment",
        "format": "MySQL"
    },
    {
        "db_id": "AlarmSystem",
        "type": "4",
        "idx": 110,
        "question": "Assuming there is a record in the historical data analysis table with a total event count of 20,000 (normal range is 0-10,000) and the event data remains at this value for 24 hours, how many analyses would be counted for the period between 2023-10-01 00:00:00 and 2023-10-02 00:00:00 if the analysis rule is total event count > 10,000?",
        "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
        "step": "【step1】: Filter records from HistoricalDataAnalysis table where AnalysisTime falls within the 24-hour period between '2023-10-01 00:00:00' and '2023-10-02 00:00:00'.  【step2】: Apply the condition TotalEvents > 10000 to exclude records within the normal range (0-10,000 events).  【step3】: Count all remaining records using COUNT(*) to determine the number of times the analysis would be triggered, where each second's data point meeting the threshold counts as one trigger.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "1",
        "idx": 111,
        "question": "It is known that the Golden Gate Bridge has a vibration frequency of 0.2 Hz and a length of 2737 meters. The Moulin de Bruges has a blade length of 14 meters and a rotation speed of 20 revolutions per minute. Please calculate the maximum amplitude of the Golden Gate Bridge and the linear velocity of the blade tip of the Moulin de Bruges.",
        "query": "SELECT (20 / (2 * 3.14159 * (SELECT Vibration_Frequency FROM bridge WHERE Name = 'Golden Gate Bridge'))) * ((SELECT Length_Meters FROM bridge WHERE Name = 'Golden Gate Bridge') / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * (SELECT Blade_Length FROM mill WHERE Name = 'Moulin de Bruges') * ((SELECT Rotation_Speed FROM mill WHERE Name = 'Moulin de Bruges') / 60) AS Moulin_Tip_Speed;",
        "step": "【step1】: Retrieve Golden Gate Bridge's vibration frequency (0.2 Hz) and length (2737 m) via subqueries from the bridge table.  【step2】: Fetch Moulin de Bruges's blade length (14 m) and rotation speed (20 RPM) via subqueries from the mill table.  【step3】: Calculate max amplitude using (20/(2πf))*(L/1000) and tip speed using 2πr*(RPM/60) with the retrieved values.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "2",
        "idx": 112,
        "question": "It is known that the length of the Brooklyn Bridge is 1834 meters, with a maximum load-bearing capacity of 2,000,000 kilograms; the power output of Moulin de Fexhe is 7.5 kilowatts at a wind speed of 6 meters per second. Please calculate the average load-bearing weight per meter length of the Brooklyn Bridge, and the energy conversion efficiency of Moulin de Fexhe at a wind speed of 6 meters per second.",
        "query": "SELECT (Load_Capacity / Length_Meters) AS Avg_Load_Per_Meter, (Power_Output / (0.5 * 1.225 * (3.14159 * POW(Blade_Length, 2)) * POW(Wind_Speed, 3))) * 100 AS Energy_Efficiency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';",
        "step": "【step1】: Filter the Brooklyn Bridge record from the bridge table and calculate Load_Capacity / Length_Meters as Avg_Load_Per_Meter.  【step2】: Filter the Moulin de Fexhe record from the mill table and compute energy efficiency using Power_Output divided by theoretical wind power formula (0.5*air_density*rotor_area*wind_speed³).  【step3】: Perform an implicit CROSS JOIN between the two filtered results (since tables aren't relationally connected) to combine both calculations in a single row output.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "3",
        "idx": 113,
        "question": "It is known that the construction cost of the Millau Viaduct is $400,000,000, the annual maintenance cost is $2,000,000, and the maintenance period is 100 years; the construction cost of the Moulin de Momalle is $80,000, the annual maintenance cost is $3,000, and the maintenance period is 50 years. Please calculate the total costs of the Millau Viaduct and the Moulin de Momalle respectively.",
        "query": "SELECT Cost_Usd + (Maintenance_Cost * 100) AS Total_Cost_Millau_Viaduct, (SELECT Cost_Usd + (Maintenance_Cost * 50) FROM mill WHERE Name = 'Moulin de Momalle') AS Total_Cost_Moulin_de_Momalle FROM bridge WHERE Name = 'Millau Viaduct';",
        "step": "【step1】: Retrieve the Millau Viaduct's construction cost and calculate its total cost by adding 100 years of maintenance costs from the bridge table.  【step2】: Use a subquery to separately retrieve the Moulin de Momalle's construction cost and calculate its total cost with 50 years of maintenance costs from the mill table.  【step3】: Combine both calculations into a single result row by aligning the subquery result with the main query's output column.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "4",
        "idx": 114,
        "question": "Assuming the Golden Gate Bridge has a vibration frequency of 100 Hz and a length of 100,000 meters, and the blade length of the Moulin de Bruges is 1,000 meters with a rotation speed of 1,000 revolutions per minute, please calculate the maximum amplitude of the Golden Gate Bridge and the linear velocity at the blade tip of the Moulin de Bruges.",
        "query": "SELECT (1000 / (2 * 3.14159 * 100)) * (100000 / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * 1000 * (1000 / 60) AS Moulin_Tip_Speed;",
        "step": "【step1】: Calculate Golden Gate Bridge's maximum amplitude using formula: (wind_speed / (2π * vibration_frequency)) * (bridge_length / 1000). Substitute values (1000/(2π*100))*(100000/1000).  【step2】: Calculate Moulin de Bruges' blade tip speed using formula: 2π * blade_length * (rotation_speed/60). Substitute values 2π*1000*(1000/60).  【step3】: Combine both calculations into a single SELECT statement to output results as two separate columns.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "1",
        "idx": 115,
        "question": "It is known that the Millau Viaduct has a span of 342 meters, a height of 343 meters, and is made of concrete. Please calculate the wind load on the Millau Viaduct at a wind speed of 10 meters per second (assuming an air density of 1.225 kg/m³).",
        "query": "SELECT 0.5 * 1.225 * POW(10, 2) * Span_Length * Height_Meters AS Wind_Load, 0.5 * (14 * 50) * POW(2 * 3.14159 * 14 * (20 / 60), 2) AS Blade_Kinetic_Energy FROM bridge WHERE Name = 'Millau Viaduct';",
        "step": "【step1】: Retrieve the record for 'Millau Viaduct' from the bridge table using the WHERE clause.  【step2】: Calculate Wind_Load using the formula 0.5 * air_density * wind_speed² * Span_Length * Height_Meters with hardcoded values (1.225 kg/m³, 10 m/s) and columns span_length_meters/height_meters.  【step3】: Compute Blade_Kinetic_Energy via the formula 0.5 * mass * velocity², where mass is hardcoded (14m * 50 kg/m), and velocity derives from blade rotation parameters (blade length 14m, 20 RPM converted to angular speed).",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "2",
        "idx": 116,
        "question": "It is known that the construction cost of the Golden Gate Bridge is $35,000,000, with an annual maintenance cost of $1,000,000; the construction cost of the Moulin de Momalle is $80,000, with an annual maintenance cost of $3,000. Please calculate the ratio of the maintenance cost to the construction cost for both the Golden Gate Bridge and the Moulin de Momalle.",
        "query": "SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM bridge WHERE Name = 'Golden Gate Bridge' UNION ALL SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM mill WHERE Name = 'Moulin de Momalle';",
        "step": "【step1】: Retrieve maintenance ratio for 'Golden Gate Bridge' from bridge table by dividing Maintenance_Cost by Cost_USD.  【step2】: Retrieve maintenance ratio for 'Moulin de Momalle' from mill table using the same calculation.  【step3】: Combine both results using UNION ALL to display ratios side-by-side for comparison of maintenance burden.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "3",
        "idx": 117,
        "question": "The known construction year of Charles Bridge is 1402, with stone as its material and an annual maintenance cost of $100,000; the construction year of Moulin de Fexhe is 1843, with wood as its material and an annual maintenance cost of $2,200. Please analyze whether the difference in maintenance costs between these two structures is reasonable based on their materials, and explain the reasons.",
        "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN 'Wooden structures have lower maintenance costs but poorer durability' END AS Maintenance_Analysis FROM bridge WHERE Name = 'Charles Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN Stone structures are typically more durable, but they come with higher maintenance costs END AS Maintenance_Analysis FROM mill WHERE Name = 'Moulin de Fexhe';",
        "step": "【step1】: Retrieve data from 'bridge' table for 'Charles Bridge', apply CASE analysis based on material (stone).  【step2】: Retrieve data from 'mill' table for 'Moulin de Fexhe', apply CASE analysis based on material (wood).  【step3】: Combine both results using UNION ALL to display maintenance cost comparisons with material-based explanations.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "4",
        "idx": 118,
        "question": "Assuming the Akashi Kaikyō Bridge has a span of 100,000 meters, a height of 10,000 meters, and is made of steel; the Moulin de Bruges has blade lengths of 1,000 meters and a rotational speed of 10,000 revolutions per minute. Please calculate the wind load on the Akashi Kaikyō Bridge at a wind speed of 1,000 meters per second, as well as the kinetic energy of the Moulin de Bruges blades during rotation, assuming a blade mass of 50 kg per meter and a standard air density of 1.225 kg/m³.",
        "query": "SELECT 0.5 * 1.225 * POW(1000, 2) * 100000 * 10000 AS Wind_Load, 0.5 * (1000 * 50) * POW(2 * 3.14159 * 1000 * (10000 / 60), 2) AS Blade_Kinetic_Energy;",
        "step": "【step1】: Retrieve Akashi Kaikyō Bridge's span length (100000m) and height (10000m) from the bridge table. Use these values in the wind load formula: 0.5 * air density (1.225 kg/m³) * (wind speed)² * span * height.  【step2】: Extract Moulin de Bruges' blade length (1000m) and rotation speed (10000 RPM) from the mill table. Convert RPM to angular velocity (rad/s) and apply the kinetic energy formula: 0.5 * (blade mass approximated as length*50kg/m) * (angular velocity * blade length)².  【step3】: Combine both calculations using a CROSS JOIN since the bridge and mill datasets are independent, producing a single-row result with Wind_Load and Blade_Kinetic_Energy.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "1",
        "idx": 119,
        "question": "Given that Tower Bridge has a bascule arch shape, a height of 65 meters, and a vibration frequency of 0.25 Hz; and given that Moulin de Bruges has blade lengths of 14 meters and a rotation speed of 20 rpm. Please calculate the wind-induced vibration energy of Tower Bridge at a wind speed of 15 m/s (assuming the bridge mass is 500,000 kg), and the aerodynamic drag on Moulin de Bruges blades during rotation (assuming an air density of 1.225 kg/m³).",
        "query": "SELECT 0.5 * 500000 * POW(15 / (2 * 3.14159 * 0.25), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POW(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Drag FROM bridge WHERE Name = 'Tower Bridge';",
        "step": "【step1】: Filter the bridge table where Name is 'Tower Bridge' to access the relevant vibration frequency (0.25 Hz) and other static parameters.  【step2】: Calculate Wind_Induced_Vibration_Energy using the formula 0.5 * mass * (wind_speed/(2πf))², substituting mass=500000 kg, wind_speed=15 m/s, and f=0.25 Hz.  【step3】: Calculate Aerodynamic_Drag using the formula 0.5 * air_density * (angular_velocity * blade_length)² * total_surface_area, with air_density=1.225 kg/m³, blade_length=14 m, angular_velocity=20 RPM (converted to rad/s), and surface_area=14*2 (assuming two blades).",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "4",
        "idx": 120,
        "question": "Assuming the Golden Gate Bridge has a span of 100,000 meters, a height of 100,000 meters, is made of steel, and has a vibration frequency of 1000 Hz; the Moulin de Bruges has a blade length of 10,000 meters, a rotation speed of 100,000 revolutions per minute, and a power output of 1,000,000,000,000 watts. Please calculate the wind-induced vibration energy of the Golden Gate Bridge at a wind speed of 100,000 meters per second (assuming the bridge's mass is 1,000,000,000 kilograms), as well as the aerodynamic drag on the Moulin de Bruges blades during rotation (assuming the air density is 1.225 kg/m³).",
        "query": "SELECT 0.5 * 1000000000 * POW(100000 / (2 * 3.14159 * 1000), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POW(2 * 3.14159 * 10000 * (100000 / 60), 2) * (10000 * 2) AS Aerodynamic_Drag;",
        "step": "【step1】: Calculate Wind_Induced_Vibration_Energy using formula: 0.5 * mass * (wind_speed/(2πf))². Values substituted: 0.5*1e9*(1e5/(2π*1e3))²  【step2】: Calculate Aerodynamic_Drag using formula: 0.5 * air_density * (2πRPM/60 * blade_length)² * (2*blade_length). Values substituted: 0.5*1.225*(2π*1e5/60*1e4)²*(2e4)",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "1",
        "idx": 121,
        "question": "It is known that the Millau Viaduct has a height of 343 meters; the Moulin de Bruges has blades with a length of 14 meters and a rotation speed of 20 revolutions per minute. Please calculate the wind-induced vibration frequency of the Millau Viaduct at a wind speed of 10 meters/second, as well as the aerodynamic lift force of the Moulin de Bruges blades during rotation (assuming an air density of 1.225 kg/m³).",
        "query": "SELECT 10 / (2 * 3.14159 * 343) AS Wind_Induced_Vibration_Frequency, 0.5 * 1.225 * POW(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Lift FROM bridge WHERE Name = 'Millau Viaduct';",
        "step": "【step1】: Filter the bridge table for the record where Name = 'Millau Viaduct'  【step2】: Calculate Wind_Induced_Vibration_Frequency using the formula 10 / (2 * π * height_meters), substituting the given height of 343 meters  【step3】: Calculate Aerodynamic_Lift using the formula 0.5 * air_density * (2 * π * blade_length * (rotation_speed / 60))² * (blade_length * 2), substituting the provided blade length of 14 meters and rotation speed of 20 RPM",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "2",
        "idx": 122,
        "question": "The Forth Bridge has a length of 2467 meters and a maximum load capacity of 4,000,000 kilograms; the Moulin de Pousset has a power output of 7.8 kilowatts at a wind speed of 6.5 meters per second. Please calculate the load-bearing weight per square meter of the Forth Bridge (assuming the bridge is 20 meters wide), and the wind energy utilization rate of the Moulin de Pousset at a wind speed of 6.5 m/s (assuming an air density of 1.225 kg/m³).",
        "query": "SELECT Load_Capacity / (Length_Meters * 20) AS Load_Per_Square_Meter, Power_Output / (0.5 * 1.225 * POW(6.5, 3) * (3.14159 * POW(Blade_Length, 2))) AS Wind_Energy_Utilization FROM bridge, mill WHERE bridge.Name = 'Forth Bridge' AND mill.Name = 'Moulin de Pousset';",
        "step": "【step1】: Filter the 'bridge' table to retrieve the 'Forth Bridge' record and calculate Load_Per_Square_Meter using Load_Capacity divided by (Length_Meters * 20).  【step2】: Filter the 'mill' table to retrieve the 'Moulin de Pousset' record and compute Wind_Energy_Utilization via the formula with Power_Output, Blade_Length, and constants.  【step3】: Combine results via implicit cross-join (cartesian product) between the filtered bridge and mill tables to produce the final output.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "1",
        "idx": 123,
        "question": "Calculate the natural frequency of Charles Bridge based on its height and the linear velocity of the Moulin de Bruges mill blade tips.",
        "query": "SELECT (10 / (2 * 3.14159 * Height_Meters)) AS Natural_Frequency, (SELECT 2 * 3.14159 * Blade_Length * (Rotation_Speed / 60) FROM mill WHERE Name = 'Moulin de Bruges') AS Tip_Speed FROM bridge WHERE Name = 'Charles Bridge';",
        "step": "【step1】: Calculate the natural frequency of Charles Bridge using its height. Retrieve Height_Meters from the bridge table where Name='Charles Bridge', then apply the formula (10 / (2π * height)).  【step2】: Compute the tip speed of Moulin de Bruges' blades. Subquery selects Blade_Length and Rotation_Speed from the mill table where Name='Moulin de Bruges', then calculates 2π * blade length * (rotation speed converted to rotations per second).  【step3】: Combine results by executing the main query (natural frequency) and embedded subquery (tip speed) simultaneously, returning both calculated values in a single row.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "2",
        "idx": 124,
        "question": "The construction cost of the Akashi Kaikyō Bridge is $5,000,000,000, with a design life of 100 years and a total maintenance cost over the design life of $500,000,000; the construction cost of the Moulin de Momalle is $80,000, with a design life of 50 years and a total maintenance cost over the design life of $150,000. Please calculate the percentage of the total maintenance cost relative to the construction cost for both.",
        "query": "SELECT (Maintenance_Cost * 100) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM bridge WHERE Name = 'Akashi Kaikyō Bridge' UNION ALL SELECT (Maintenance_Cost * 50) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM mill WHERE Name = 'Moulin de Momalle';",
        "step": "【step1】: Calculate Akashi Kaikyō Bridge's total maintenance cost over its lifespan (100 years) as a percentage of construction cost: `(Maintenance_Cost * 100) / Cost_Usd * 100` from `bridge` table.  【step2】: Calculate Moulin de Momalle's total maintenance cost over its lifespan (50 years) as a percentage of construction cost: `(Maintenance_Cost * 50) / Cost_Usd * 100` from `mill` table.  【step3】: Combine results using `UNION ALL` to preserve duplicate entries (though no duplicates exist here), returning both percentages in a single column `Maintenance_Cost_Percentage`.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "3",
        "idx": 125,
        "question": "Given that the annual maintenance cost of Rialto Bridge (stone, built in 1591) is $50,000 and that of Moulin de Pousset (stone, built in 1819) is $2,400, why is there a significant difference in maintenance costs, considering factors such as usage intensity, environmental corrosion, or preservation requirements?",
        "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Rialto Bridge' THEN '高维护成本可能由于高使用强度、环境腐蚀或文物保护需求较高' WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Rialto Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin de Pousset';",
        "step": "【step1】: Retrieve Rialto Bridge data from 'bridge' table with maintenance cost analysis using CASE statement. Ensure column aliases match the UNION structure.  【step2】: Retrieve Moulin de Pousset data from 'mill' table with maintenance cost analysis. Convert 'Built_Year' to align with 'Construction_Year' naming for column consistency.  【step3】: Combine both results via UNION ALL to preserve duplicate entries and maintain distinct maintenance explanations.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "4",
        "idx": 126,
        "question": "Assuming the Golden Gate Bridge's span extends to 100,000 meters with a height of 100,000 meters and a vibration frequency of 100,000 Hz; the Moulin de Bruges' blade length increases to 10,000 meters with a rotation speed of 100,000 rpm. Calculate the vortex-induced vibration energy of the bridge at a wind speed of 100,000 m/s (assuming a mass of 1e12 kg) and the material's ultimate stress caused by the centrifugal force of the blades (assuming a blade density of 8,000 kg/m³).",
        "query": "SELECT 0.5 * 1e12 * POW(100000 / 1000, 2) AS Vortex_Induced_Vibration_Energy, 8000 * POW(2 * 3.14159 * 100000 / 60, 2) * POW(10000, 2) / 2 AS Centrifugal_Stress;",
        "step": "【step1】: Calculate vortex-induced vibration energy using the formula 0.5 * mass * (wind_speed / vibration_frequency)^2 with given parameters (mass=1e12 kg, wind_speed=100000 m/s, vibration_frequency=1000 Hz).  【step2】: Compute centrifugal stress via density * (angular_velocity)^2 * (blade_length)^2 / 2, deriving angular_velocity from rotation_speed (100000 RPM converted to rad/s using 2π/60).  【step3】: Combine both calculations in a single SELECT statement to output results as Vortex_Induced_Vibration_Energy and Centrifugal_Stress without table references.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "1",
        "idx": 127,
        "question": "It is known that the arch shape of the Brooklyn Bridge is suspension, with a span of 486 meters and a vibration frequency of 0.3 Hz; the Moulin de Fexhe has a blade length of 11 meters and a rotational speed of 28 rpm. Please calculate the harmonic number of the Brooklyn Bridge and the critical frequency of the mill.",
        "query": "SELECT (12 * Span_Length) / (Vibration_Frequency * 1000) AS Harmonic_Number, (Blade_Length * Rotation_Speed) / 60 AS Critical_Frequency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';",
        "step": "【step1】: Retrieve Brooklyn Bridge's span length and vibration frequency from the bridge table using the condition `bridge.Name = 'Brooklyn Bridge'`.  【step2】: Retrieve Moulin de Fexhe's blade length and rotation speed from the mill table using the condition `mill.Name = 'Moulin de Fexhe'`.  【step3】: Calculate `Harmonic_Number` via `(12 * Span_Length) / (Vibration_Frequency * 1000)` and `Critical_Frequency` via `(Blade_Length * Rotation_Speed) / 60` by combining the filtered results from both tables.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "2",
        "idx": 128,
        "question": "Given that the Golden Gate Bridge had an annual maintenance cost and a growth rate of 2%; the Moulin de Pousset had an annual maintenance cost and a growth rate of 5%. Please calculate the total cumulative maintenance cost for both after 50 years.",
        "query": "SELECT Maintenance_Cost * (POW(1 + 0.02, 50) - 1) / 0.02 AS Total_Maintenance_Cost_Golden_Gate, (SELECT Maintenance_Cost * (POW(1 + 0.05, 50) - 1) / 0.05 FROM mill WHERE Name = 'Moulin de Pousset') AS Total_Maintenance_Cost_Moulin FROM bridge WHERE Name = 'Golden Gate Bridge';",
        "step": "【step1】: Retrieve the initial annual maintenance cost for 'Golden Gate Bridge' from the bridge table and calculate its cumulative maintenance cost over 50 years using the geometric series formula: Maintenance_Cost * (POW(1 + 0.02, 50) - 1) / 0.02.  【step2】: Retrieve the initial annual maintenance cost for 'Moulin de Pousset' from the mill table via a subquery and calculate its cumulative maintenance cost over 50 years using the geometric series formula: Maintenance_Cost * (POW(1 + 0.05, 50) - 1) / 0.05.  【step3】: Combine both results into a single row output by executing the main query and subquery simultaneously, aligning their computed totals as separate columns.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "3",
        "idx": 129,
        "question": "Sydney Harbour Bridge (steel, built in 1932) has an annual maintenance cost of $800,000, while Moulin d'Amsterdam (wooden, built in 1805) costs $2,050 to maintain. Why is the maintenance cost higher for steel bridges?",
        "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'High maintenance costs may be due to anti-corrosion treatment, load monitoring, and higher structural complexity' WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Sydney Harbour Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin d''Amsterdam';",
        "step": "【step1】: Retrieve steel bridge data from \"bridge\" table with CASE analysis for maintenance costs, filtering by Sydney Harbour Bridge  【step2】: Retrieve wooden mill data from \"mill\" table with CASE analysis for maintenance costs, filtering by Moulin d'Amsterdam (note field name mismatch: Built_Year vs Construction_Year)  【step3】: Combine results using UNION ALL while maintaining column alignment (Name, Year, Material, Cost, Analysis) despite different source table structures",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "4",
        "idx": 130,
        "question": "Assuming the span of Millau Viaduct increases to 1e9 meters (approximately 2.6 times the Earth-Moon distance), with a vibration frequency of 1e6 Hz; and the blade length of Moulin de Bruges is 1e8 meters, rotating at 1e12 revolutions per minute. Please calculate: ① The number of vibration modes of the bridge; ② Whether the tip speed of the blade exceeds the speed of light and the relativistic correction factor.",
        "query": "SELECT (1e9 * 1e6) / (6.62607015e-34 * 1e34) AS Quantum_Vibration_Modes, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) >= 299792458 THEN 'Faster than light, correction factor cannot be calculated' ELSE 'Not exceeding the speed of light requires relativistic corrections' END AS Relativity_Check, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) < 299792458 THEN 1 / SQRT(1 - POW((2 * 3.14159 * 1e8 * (1e12 / 60)) / 299792458, 2)) ELSE 'N/A' END AS Relativity_Correction_Factor;",
        "step": "【step1】: Calculate Quantum_Vibration_Modes using formula (span_length × vibration_frequency) / (h × solar_wind_velocity): (1e9 * 1e6) / (6.62607015e-34 * 1e7)  【step2】: Calculate blade tip velocity via 2πr × (rotation_speed/60) and compare with light speed (299,792,458 m/s) for CASE condition in Relativity_Check  【step3】: Compute Relativity_Correction_Factor using Lorentz factor 1/√(1-(v²/c²)) only when blade tip velocity < light speed, else output 'N/A'",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "1",
        "idx": 131,
        "question": "Given that the Tower Bridge is a bascule arch with a span of 244 meters and a vibration frequency of 0.25 Hz; the Moulin de Bruges has blade lengths of 14 meters and a rotational speed of 20 revolutions per minute. Please calculate the vortex shedding frequency of the Tower Bridge and the wavelength of the infrasound generated by the rotation of the mill's blades.",
        "query": "SELECT (0.2 * Vibration_Frequency) / Span_Length AS Vortex_Shedding_Frequency, 343 / (Rotation_Speed / 60) AS Infrasound_Wavelength FROM bridge, mill WHERE bridge.Name = 'Tower Bridge' AND mill.Name = 'Moulin de Bruges';",
        "step": "【step1】: Retrieve Tower Bridge's Vibration_Frequency and Span_Length from the bridge table using the WHERE condition bridge.Name = 'Tower Bridge'.  【step2】: Retrieve Moulin de Bruges' Rotation_Speed from the mill table using the WHERE condition mill.Name = 'Moulin de Bruges'.  【step3】: Calculate Vortex_Shedding_Frequency via (0.2 * Vibration_Frequency) / Span_Length and Infrasound_Wavelength via 343 / (Rotation_Speed / 60), returning both results.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "2",
        "idx": 132,
        "question": "It is known that the Akashi Kaikyō Bridge has a construction cost of $5 billion, with annual maintenance costs increasing by 5%; the Moulin d'Amsterdam has a construction cost of $52,000, with annual maintenance costs increasing by 8%. Please calculate the percentage of maintenance costs relative to the original construction cost for both in the 25th year.",
        "query": "SELECT (Maintenance_Cost * POW(1 + 0.05, 25)) / Cost_Usd * 100 AS Maintenance_Cost_Percentage_Akashi, (SELECT Maintenance_Cost * POW(1 + 0.08, 25) / Cost_Usd * 100 FROM mill WHERE Name = 'Moulin d''Amsterdam') AS Maintenance_Cost_Percentage_Amsterdam FROM bridge WHERE Name = 'Akashi Kaikyō Bridge';",
        "step": "【step1】: Retrieve Akashi Kaikyō Bridge's initial maintenance cost and cost from the bridge table, calculate the 25th-year maintenance cost using 5% annual increase (POW(1+0.05,25)), then divide by construction cost and convert to percentage.  【step2】: Use subquery to fetch Moulin d'Amsterdam's data from mill table, compute 25th-year maintenance cost with 8% increment (POW(1+0.08,25)), calculate its percentage relative to its construction cost.  【step3】: Combine both results in a single row output by mapping bridge table's main calculation and mill table's subquery calculation as separate columns.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "3",
        "idx": 133,
        "question": "Ponte Vecchio (stone, built in 1345) and Forth Bridge (steel, built in 1890) have annual maintenance costs of $20,000 and $700,000, respectively. Please explain why the maintenance cost of stone is significantly lower than that of steel, despite stone having lower tensile strength.",
        "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Stone' THEN 'Stone maintenance costs are low due to its gradual failure mode and lack of need for complex anti-corrosion treatment' WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Ponte Vecchio' UNION ALL SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Forth Bridge';",
        "step": "【step1】: Retrieve Ponte Vecchio's data with maintenance cost analysis using CASE to explain stone's lower maintenance.  【step2】: Retrieve Forth Bridge's data with CASE to explain steel's higher maintenance costs.  【step3】: Combine both results using UNION ALL to display comparative maintenance cost reasons in a single output.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "4",
        "idx": 134,
        "question": "Assuming the material of the Golden Gate Bridge changes to degenerate matter (density 1e17 kg/m³), with a span of 1e25 meters; and the blades of Moulin de Bruges rotate at a speed of 1e40 revolutions per minute. Please calculate:  \n① The tidal resonance frequency of the bridge in the gravitational field of the Milky Way's spiral arm;  \n② The rate of spacetime curvature change induced by the blade rotation.",
        "query": "SELECT (6.67430e-11 * 1e41 * 1e17) / POW(1e25, 3) AS Tidal_Resonance_Frequency, POW(1e40 * 14 / 60, 2) / POW(299792458, 4) AS Spacetime_Curvature_Rate;",
        "step": "【step1】: Calculate Tidal Resonance Frequency using gravitational constant (6.67430e-11), mass (1e41 kg), density-derived volume (1e17 kg/m³), and span cubed (POW(1e25,3)).  【step2】: Compute Spacetime Curvature Rate by converting rotation speed (1e40 RPM) to RPS (1e40 * (14/60)), squaring it, then dividing by lightspeed⁴ (POW(299792458,4)).  【step3】: Combine both calculations in a single SELECT statement to output dual physics metrics.",
        "format": "MySQL"
    },
    {
        "db_id": "architect",
        "type": "2",
        "idx": 135,
        "question": "Given the Golden Gate Bridge has an annual maintenance cost growth rate of 2%, and the Moulin d'Amsterdam has an annual maintenance cost growth rate of 5%. Please calculate:  \n1. The number of years required for the maintenance costs of both structures to reach 10 times their current maintenance costs.  \n2. The ratio of the maintenance cost to the initial maintenance cost after 50 years.",
        "query": "SELECT (LN(10 * b.Cost_Usd / b.Maintenance_Cost) / LN(1.02)) AS Years_To_10x_GoldenGate, POW(1.02, 50) AS Multiplier_50y_GoldenGate, (LN(10 * m.Cost_Usd / m.Maintenance_Cost) / LN(1.05)) AS Years_To_10x_Amsterdam, POW(1.05, 50) AS Multiplier_50y_Amsterdam FROM bridge b, mill m WHERE b.Name = 'Golden Gate Bridge' AND m.Name = 'Moulin d''Amsterdam';",
        "step": "【step1】: Calculate years to reach 10x construction cost using logarithmic formula LN(10*Cost_Usd/Maintenance_Cost)/LN(1+growth_rate) for both structures.  【step2】: Compute 50-year maintenance cost multiplier via exponential function POW(1+annual_growth_rate, 50).  【step3】: Cross-join bridge and mill tables with WHERE filters to isolate 'Golden Gate Bridge' and 'Moulin d''Amsterdam' records respectively.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 136,
        "question": "Calculate the air resistance power of a carbon fiber road bike when traveling at its top speed.",
        "query": "SELECT 0.5 * p.AerodynamicDrag * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';",
        "step": "【step1】: Filter bicycles with 'Carbon fiber' frame and 'Road bike' type from Bicycle table  【step2】: Join filtered bicycles with BicyclePerformance table using BicycleID  【step3】: Calculate air resistance power using formula 0.5 * AerodynamicDrag * air_density * frontal_area * (speed^3) with unit conversion (km/h→m/s)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 137,
        "question": "Calculate the total energy consumption per bicycle, considering rider power output and motor efficiency, and group the results by riding style.",
        "query": "SELECT r.RidingStyle, (r.RiderPowerOutput + (t.MotorEfficiency / 100 * t.BatteryCapacity)) * 2 AS TotalEnergyConsumption FROM BicycleRider r JOIN BicycleThermodynamics t ON r.BicycleID = t.BicycleID;",
        "step": "【step1】: Perform an INNER JOIN between BicycleRider (r) and BicycleThermodynamics (t) using BicycleID to link rider data with thermodynamics data  【step2】: Calculate energy components: For each matched record, compute (RiderPowerOutput + (MotorEfficiency% × BatteryCapacity))  【step3】: Multiply the sum by 2 to get TotalEnergyConsumption per riding style and finalize the result projection",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 138,
        "question": "Based on the bicycle's weight, the rider's weight, and the maximum load capacity, determine whether tire pressure adjustments are needed by comparing the calculated required pressure to the current tire pressure.",
        "query": "SELECT b.BicycleID, CASE WHEN (b.Weight + r.RiderWeight + b.MaxLoad) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine bicycle specifications with rider weight data  【step2】: Calculate total load pressure requirement using formula (Bicycle.Weight + RiderWeight + MaxLoad) / 0.02 to determine required tire pressure  【step3】: Use CASE statement to compare calculated pressure with actual TirePressure, returning 'Needs adjustment' when required pressure exceeds stored value",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 139,
        "question": "Calculate the braking distance of a bicycle when the speed is 5 times the maximum speed.",
        "query": "SELECT b.BicycleID, POWER((p.TopSpeed * 5 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicyclePerformance tables using BicycleID to access speed data  【step2】: Convert TopSpeed from km/h to m/s (×1000/3600) then apply 5× speed multiplier  【step3】: Calculate braking distance using physics formula: (velocity²) / (2×friction×gravity) with assumed μ=0.7 and g=9.81m/s²",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 140,
        "question": "Calculate the power requirement for a mountain bike climbing a hill with a 10% gradient, given a rider weight of 75 kg and a bicycle weight of 15 kg.",
        "query": "SELECT b.BicycleID, (75 + 15) * 9.81 * (p.TopSpeed * 1000 / 3600) * 0.10 AS ClimbingPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'Mountain bike';",
        "step": "【step1】: Filter mountain bicycles by type  【step2】: Join performance data to get speed  【step3】: Calculate climbing power using (rider_weight + bike_weight)*g*speed*slope",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 141,
        "question": "Calculate the air resistance power for each carbon fiber road bike, where the power is computed as 0.5 * 0.9 * 1.225 * 0.5 * (top speed in km/h converted to m/s, then cubed), based on the bike's maximum speed.",
        "query": "SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';",
        "step": "【step1】: Filter carbon fiber road bikes from Bicycle table using WHERE FrameMaterial='Carbon fiber' AND Type='Road bike'  【step2】: Join with BicyclePerformance table via BicycleID to access TopSpeed value in km/h  【step3】: Calculate power using formula 0.5 * Cd * ρ * A * (v³) where ρ=1.225 kg/m³ and v converted to m/s via (TopSpeed*1000/3600)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 142,
        "question": "Calculate the battery life of an electric bicycle under different ambient temperatures, given a battery capacity of 500 watt-hours, motor efficiency of 85%, and rider power output of 250 watts.",
        "query": "SELECT t.AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;",
        "step": "【step1】: Filter records where battery capacity is 500 Wh from BicycleThermodynamics table.  【step2】: Calculate total power consumption using formula: (RiderPower + (MotorPower / MotorEfficiency)) = 100 + (250 / 0.85).  【step3】: Compute BatteryLife by dividing battery capacity (500 Wh) by total power consumption for each ambient temperature.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 143,
        "question": "Based on the total weight of the bicycle, rider, and load compared to the tire pressure, determine whether tire pressure adjustment is needed to ensure safe riding. The known conditions are: bicycle weight is 12 kg, rider's weight is 80 kg, load capacity is 30 kg, and tire contact area is 0.01 square meters.",
        "query": "SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
        "step": "【step1】: Perform JOIN operation between Bicycle and BicycleRider tables using BicycleID to link bike specifications with rider data.  【step2】: Calculate total pressure: (BikeWeight(12kg) + RiderWeight(80kg) + Load(30kg)) / (TireContactArea × 2) = 122kg / 0.02m² = 6100 kg/m².  【step3】: Use CASE to compare calculated pressure (6100 kg/m²) against stored TirePressure (PSI). Return adjustment requirement based on whether the value exceeds the tire's rated pressure.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 144,
        "question": "Calculate the braking distance for each bicycle using the formula based on top speed, with a friction coefficient of 0.7 and gravitational acceleration of 9.81 m/s².",
        "query": "SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
        "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID to access TopSpeed values  【step2】: Convert TopSpeed to m/s (km/h×1000/3600) and apply 10x multiplier for extreme condition  【step3】: Calculate braking distance using formula (v²)/(2×μ×g) with μ=0.7 and g=9.81 m/s²",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 145,
        "question": "Calculate the air resistance power for carbon fiber road bicycles using the formula 0.5 × air density (1.225) × air resistance coefficient (0.9) × projected area (0.5) × velocity cubed, where velocity is the top speed in meters per second.",
        "query": "SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicyclePerformance tables using BicycleID to link bicycle specifications with performance data  【step2】: Filter records where FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' to select carbon fiber road bikes  【step3】: Calculate air resistance power using formula 0.5*Cd*ρ*A*v³ with converted speed units (km/h→m/s), where Cd=0.9, ρ=1.225kg/m³, A=0.5m², and v=(TopSpeed*1000/3600)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 146,
        "question": "What is the battery life in hours for an electric bicycle under different ambient temperatures, given the battery capacity is 500 watt-hours, the motor efficiency is 85%, and the rider's power output is 100 watts?",
        "query": "SELECT t.AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;",
        "step": "【step1】: Filter records in BicycleThermodynamics where BatteryCapacity = 500 to isolate electric bicycles with the specified battery.  【step2】: Calculate total power consumption: 100W (rider output) + (250W / 0.85 motor efficiency) = 100 + ~294.12 = ~394.12W.  【step3】: Compute BatteryLife by dividing BatteryCapacity (500Wh) by total power consumption and output AmbientTemperature with the result.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 147,
        "question": "Based on the bike's weight, rider weight, and load, determine whether the tire pressure needs to be adjusted to ensure safe riding.",
        "query": "SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
        "step": "【step1】: Join Bicycle and BicycleRider tables via BicycleID to associate rider weight data with bicycle specifications  【step2】: Calculate total pressure requirement by dividing combined weight (12kg bike + 80kg rider + 30kg load) by total tire contact area (0.01m² × 2 tires)  【step3】: Compare calculated pressure with stored TirePressure using CASE to determine adjustment need",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 148,
        "question": "Calculating the braking distance of a bicycle at 10 times its maximum speed, given a friction coefficient of 0.7 and gravity acceleration of 9.81 m/s.",
        "query": "SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
        "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID to access TopSpeed data  【step2】: Convert TopSpeed from km/h to m/s (×1000/3600) and apply 10× multiplier for extreme speed  【step3】: Calculate braking distance using formula (v²)/(2μg) with μ=0.7 and g=9.81 m/s²",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 149,
        "question": "Calculate the kinetic energy of an electric bicycle at its top speed under standard conditions.",
        "query": "SELECT b.BicycleID, 0.5 * (b.Weight + b.MaxLoad) * POWER((p.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'electric vehicle';",
        "step": "【step1】: Filter electric bicycles by joining Bicycle and BicyclePerformance tables  【step2】: Calculate total mass (bike weight + max load) and convert speed from km/h to m/s  【step3】: Apply kinetic energy formula (0.5 * mass * velocity²) for qualified records",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 150,
        "question": "Calculate the actual power delivered to the wheels by multiplying the rider's power output and the bicycle's power transfer efficiency (divided by 100).",
        "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID;",
        "step": "【step1】: Join Bicycle and BicycleRider tables using BicycleID to associate rider power output with bicycle  【step2】: Join result with BicyclePerformance table using BicycleID to access power transfer efficiency  【step3】: Calculate ActualPower by multiplying RiderPowerOutput with PowerTransferEfficiency/100 and select required columns",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 151,
        "question": "Calculate the contact area of the bicycle tire based on the tire width.",
        "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleComponents tables using BicycleID to link tire properties.  【step2】: Calculate ContactArea using the formula **TireWidth * (TireWidth * 2)** for each bicycle.  【step3】: Select and output BicycleID with the computed ContactArea.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 152,
        "question": "If the wheel size of a bicycle increases to 100 inches, and the rider's height is used in the calculation along with a fixed weight contribution of 500, what is the new center of gravity height?",
        "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100;",
        "step": "【step1】: Perform INNER JOINs between Bicycle, BicycleDynamics, and BicycleRider tables using BicycleID to combine bicycle specifications, dynamics data, and rider information.  【step2】: Apply WHERE filter to select bicycles with WheelSize = 100 inches.  【step3】: Calculate NewCenterOfGravityHeight with formula: Original CenterOfGravityHeight + (500kg rider * RiderHeight) / (Bicycle.Weight + 500kg).",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 153,
        "question": "Calculate the kinetic energy of each electric bicycle when traveling at top speed with maximum load, and list the top 5 bicycles with the highest kinetic energy.",
        "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' ORDER BY KineticEnergy DESC LIMIT 5;",
        "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID, filtering only 'electric vehicle' type bicycles.  【step2】: Calculate kinetic energy with formula: 0.5*(Weight+MaxLoad)*(TopSpeed converted to m/s squared).  【step3】: Sort results by kinetic energy descending and limit to top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 154,
        "question": "Compute the product of power transmission efficiency and rider power output divided by 100 for each bicycle to determine the actual power delivered to the wheels, and list the top 10 bicycles with the highest power.",
        "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID ORDER BY ActualPower DESC LIMIT 10;",
        "step": "【step1】: Perform INNER JOIN on Bicycle, BicycleRider, and BicyclePerformance tables using BicycleID to combine bicycle metadata, rider power output, and power transfer efficiency data.  【step2】: Calculate ActualPower by multiplying RiderPowerOutput (from BicycleRider) with PowerTransferEfficiency (from BicyclePerformance) divided by 100 to convert percentage efficiency.  【step3】: Sort results by ActualPower in descending order and apply LIMIT 10 to retrieve the top 10 bicycles with highest effective wheel power transmission.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 155,
        "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground, and list the top 5 bicycles with the smallest contact area.",
        "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID ORDER BY ContactArea ASC LIMIT 5;",
        "step": "【step1】: Perform an INNER JOIN between Bicycle and BicycleComponents tables using BicycleID to associate tire width data with each bicycle.  【step2】: Calculate the contact area using the formula (TireWidth × (TireWidth × 2)) for each bicycle.  【step3】: Sort results by ContactArea in ascending order and apply LIMIT 5 to retrieve the smallest 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 156,
        "question": "If the wheel size is 100 inches and the rider's weight is 500 kilograms, calculate the center of gravity height for each bicycle and list the top 3 bicycles with the highest center of gravity height.",
        "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100 ORDER BY NewCenterOfGravityHeight DESC LIMIT 3;",
        "step": "【step1】: Perform JOIN operations across Bicycle, BicycleDynamics, and BicycleRider tables using BicycleID as the foreign key to combine bicycle technical specifications, dynamics data, and rider parameters.  【step2】: Apply conditional filtering (WHERE WheelSize=100) and calculate modified CenterOfGravityHeight using formula: Original height + (500kg rider weight × rider height) / (bicycle weight + 500kg).  【step3】: Sort results by NewCenterOfGravityHeight descending and implement LIMIT 3 to retrieve bicycles with highest adjusted center of gravity.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 157,
        "question": "Calculate the kinetic energy of each electric bicycle when traveling at maximum speed under maximum load, and identify the electric bicycles with kinetic energy higher than all mountain bikes.",
        "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Mountain bike');",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicyclePerformance tables to obtain electric bicycles' weight, max load, and top speed data. Convert speed from km/h to m/s using (TopSpeed * 1000 / 3600).  【step2】: Calculate kinetic energy for all mountain bikes through subquery: 0.5*(Weight+MaxLoad)*POWER((converted speed),2) after joining Bicycle and BicyclePerformance tables with Type='Mountain bike'.  【step3】: Filter electric bicycles using > ALL operator to ensure their kinetic energy exceeds all values from the mountain bike subquery results.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 158,
        "question": "Calculate the product of each bicycle’s drivetrain efficiency and the rider’s power output to determine the actual power delivered to the wheels, and identify hybrid bicycles with actual power higher than that of all road bikes.",
        "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Road bike');",
        "step": "【step1】: Join Bicycle, BicycleRider, and BicyclePerformance tables using BicycleID, filter records where bicycle type is 'Hybrid vehicle'  【step2】: Calculate ActualPower by multiplying RiderPowerOutput with PowerTransferEfficiency/100  【step3】: Use ALL operator to compare against subquery results calculating the same power metric for 'Road bike' type bicycles",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 159,
        "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground, and identify electric bikes with a contact area smaller than all BMX bikes.",
        "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX');",
        "step": "【step1】: Calculate ContactArea for all BMX bicycles by joining Bicycle and BicycleComponents tables, selecting TireWidth²*2.  【step2】: Calculate ContactArea for electric bicycles using the same formula, then filter by Type='electric vehicle'.  【step3】: Use ALL operator to compare electric bicycles' ContactArea with BMX results from step1, returning only electric bicycles with smaller values than all BMX entries.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 160,
        "question": "Calculate the center of gravity height for each bicycle using the adjusted rider weight of 500 kg and identify the full-suspension bicycles with a center of gravity height higher than all no-suspension bicycles.",
        "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'No suspension');",
        "step": "【step1】: Join Bicycle, BicycleDynamics, and BicycleRider tables to calculate the \"NewCenterOfGravityHeight\" for full-suspension bicycles using the formula: CenterOfGravityHeight + (500 * RiderHeight) / (Bicycle.Weight + 500).  【step2】: Compute the same \"NewCenterOfGravityHeight\" for non-suspension bicycles via a subquery using identical joins and formula.  【step3】: Filter results where full-suspension bicycles' NewCenterOfGravityHeight exceeds ALL values from the non-suspension subquery results using the > ALL operator.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 161,
        "question": "Calculate the kinetic energy of each electric vehicle when traveling at maximum speed under maximum load, and identify the electric vehicles with kinetic energy higher than all mountain bikes using a carbon fiber frame.",
        "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');",
        "step": "【step1】: Calculate kinetic energy for all electric bicycles by joining Bicycle, BicyclePerformance, and BicycleComponents tables using BicycleID, applying the formula 0.5*(Weight+MaxLoad)*(TopSpeed converted to m/s)^2 where Type='electric vehicle'.  【step2】: Compute maximum kinetic energy values for mountain bikes with carbon fiber frames by joining relevant tables, filtering WHERE Type='Mountain bike' AND BicycleComponents.FrameMaterial='Carbon fiber'.  【step3】: Filter electric bicycles from Step1 by comparing their kinetic energy to ALL results from Step2's subquery using the > ALL operator in the WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 162,
        "question": "Calculate the product of each bicycle's power transmission efficiency and the rider's power output to determine the actual power delivered to the wheels, and then identify the hybrid bicycles whose actual power is higher than the maximum actual power among all road bikes using aluminum alloy rims.",
        "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');",
        "step": "【step1】: Calculate ActualPower for all hybrid bicycles by multiplying RiderPowerOutput and PowerTransferEfficiency, then divide by 100 through joins between Bicycle, BicycleRider, and BicyclePerformance tables.  【step2】: Calculate comparison baseline by subquery - compute ActualPower for all road bicycles with aluminum rims through equivalent joins and filter conditions (Bicycle.Type='Road bike' AND BicycleComponents.RimMaterial='aluminum alloy').  【step3】: Filter hybrid bicycles (Bicycle.Type='Hybrid vehicle') using WHERE clause to retain only those whose ActualPower exceeds ALL values from the subquery result in Step 2.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 163,
        "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground (using the formula tire width multiplied by tire width multiplied by 2), and identify the electric bikes with a contact area smaller than all BMX bikes with steel chains.",
        "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');",
        "step": "【step1】: Calculate contact area for all BMX bikes with steel chains by joining Bicycle and BicycleComponents tables, using formula (TireWidth × 2 × TireWidth)  【step2】: Calculate contact area for electric bikes using the same formula, filtering by Type = 'electric vehicle' in the Bicycle table  【step3】: Compare electric bike contact areas against all values from step1 using < ALL operator to ensure they are smaller than every BMX contact area",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 164,
        "question": "If the rider's weight is fixed at 500 kg and the center of gravity height is calculated as BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500), identify the full-suspension bicycles with a center of gravity height higher than that of all rigid bicycles equipped with titanium alloy handlebars.",
        "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');",
        "step": "【step1】: Join tables (Bicycle, BicycleDynamics, BicycleRider, BicycleComponents) and filter for full-suspension bikes. Calculate new CenterOfGravityHeight with formula: OriginalHeight + (500*RiderHeight)/(BikeWeight+500).  【step2】: Create subquery to calculate same formula for rigid-frame bikes with titanium handlebars. Join identical tables and apply filters: SuspensionType='No suspension' AND HandlebarMaterial='Titanium alloy'.  【step3】: Compare main query's NewCenterOfGravityHeight against all values from subquery using > ALL operator to ensure superiority over every rigid titanium-handlebar bike's adjusted height.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 165,
        "question": "Calculate the kinetic energy of each electric bicycle when traveling at maximum speed under maximum load, and identify the electric bicycles with kinetic energy higher than the maximum kinetic energy among mountain bikes using carbon fiber frames.",
        "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');",
        "step": "【step1】: Calculate kinetic energy for all electric bicycles by joining Bicycle, BicyclePerformance, and BicycleComponents tables using the formula 0.5*(Weight+MaxLoad)*(TopSpeed converted to m/s)^2. Filter by 'electric vehicle' type.  【step2】: Calculate kinetic energy for all mountain bicycles with carbon fiber frames using the same formula by joining the same tables. Filter by 'Mountain bike' type and BicycleComponents.FrameMaterial='Carbon fiber'.  【step3】: Compare electric bicycle kinetic energy values against ALL carbon fiber mountain bicycle kinetic energy values using > ALL operator, returning electric bicycles exceeding all mountain bike kinetic energies.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 166,
        "question": "Calculate the product of each bicycle's rider power output and power transfer efficiency divided by 100 to determine the actual power delivered to the wheels, and identify hybrid bicycles where the actual power exceeds that of all road bikes using aluminum rims.",
        "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');",
        "step": "【step1】: Calculate the actual power (RiderPowerOutput * PowerTransferEfficiency/100) for all road bikes with aluminum rims by joining Bicycle, BicycleComponents, BicycleRider, and BicyclePerformance tables.【step2】: Calculate actual power for hybrid bikes using the same formula, while filtering bicycles where Type='Hybrid vehicle' through table joins.【step3】: Apply ALL operator to compare hybrid bikes' actual power against all road bike values from Step1, returning only hybrid bikes exceeding every road bike's actual power.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 167,
        "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground, and identify the electric bikes with a contact area smaller than all BMX bikes equipped with steel chains.",
        "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');",
        "step": "【step1】: Calculate contact areas for BMX bicycles with steel chains by joining Bicycle and BicycleComponents tables, filtering Type='BMX' and ChainMaterial='钢', then compute TireWidth²×2  【step2】: Calculate contact areas for electric bicycles by joining Bicycle and BicycleComponents tables, filtering Type='electric vehicle', compute TireWidth²×2 as ContactArea  【step3】: Compare electric bicycle ContactArea values against ALL BMX results from step1 using < ALL operator in WHERE clause, selecting qualifying electric bicycles",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 168,
        "question": "If the wheel diameter of all bicycles is increased to 100 inches and the rider's weight is set to a fixed value of 500 in the formula, calculate the adjusted center of gravity height for each bicycle, and identify the full-suspension bicycles whose adjusted center of gravity height is higher than that of all rigid bicycles using titanium alloy handlebars.",
        "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');",
        "step": "【step1】: Calculate the new center of gravity height for all full-suspension bicycles using the formula: Original CenterOfGravityHeight + (500 * RiderHeight) / (BicycleWeight + 500) after increasing wheel size to 100 inches and rider weight to 500kg.  【step2】: Calculate the new center of gravity heights for titanium-handlebar rigid-suspension bicycles using the same formula through a subquery.  【step3】: Filter results from Step1 where the calculated height exceeds ALL values from Step2 using > ALL comparison operator in the WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 169,
        "question": "Calculate the heat generated by the rider's power output adjusted for motor inefficiency for each electric vehicle bicycle, and identify the e-bikes with heat levels higher than all carbon fiber-framed mountain bikes.",
        "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) AS HeatGenerated FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) > ALL (SELECT BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');",
        "step": "【step1】: Calculate heat generated by all electric bicycles: Join Bicycle, BicycleRider, BicycleThermodynamics, and BicycleComponents tables. Filter bicycles of type 'electric vehicle' and compute RiderPowerOutput * (1 - MotorEfficiency/100) as HeatGenerated.  【step2】: Calculate maximum heat from carbon-fiber mountain bikes: Join the same tables but filter for 'Mountain bike' with BicycleComponents.FrameMaterial='Carbon fiber'. Compute the same heat formula for comparison.  【step3】: Filter electric bicycles with heat exceeding all mountain bike values: Use > ALL operator to compare Step1's HeatGenerated with the subquery results from Step2.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 170,
        "question": "Calculate the product of battery capacity and motor efficiency divided by 100 for each bicycle to determine the actual available energy, and identify hybrid bicycles whose actual available energy exceeds that of all road bikes using aluminum alloy rims.",
        "query": "SELECT Bicycle.BicycleID, BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 AS UsableEnergy FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 > ALL (SELECT BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');",
        "step": "【step1】: Join Bicycle, BicycleThermodynamics, and BicycleComponents tables to calculate UsableEnergy (BatteryCapacity*MotorEfficiency/100) for hybrid bikes  【step2】: Subquery calculates max UsableEnergy from road bikes with aluminum rims using same table joins  【step3】: Filter hybrid bikes where UsableEnergy exceeds ALL values from subquery results",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 171,
        "question": "Based on the heat dissipation rate of each bicycle and the ambient temperature, calculate the motor's operating temperature, and identify the electric vehicles with operating temperatures lower than the maximum operating temperature among BMX bikes that use steel chains.",
        "query": "SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) AS MotorTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) < ALL (SELECT BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');",
        "step": "【step1】: Filter electric bicycles and calculate their motor temperature using ambient temperature and heat dissipation rate divided by motor efficiency through JOINs with BicycleThermodynamics and BicycleComponents tables.  【step2】: Calculate motor temperatures for BMX bicycles with steel chains via a subquery using the same formula, ensuring type='BMX' and ChainMaterial='钢'.  【step3】: Compare electric bicycles' motor temperatures from Step1 against ALL BMX motor temperatures from Step2 using the < ALL operator to finalize the result set.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 172,
        "question": "If the battery capacity of all bicycles is increased to 1000 watt-hours and the ambient temperature reaches 50°C, calculate the battery temperature for each full-suspension bicycle, and identify which of these have battery temperatures higher than all no-suspension bicycles that use titanium alloy handlebars.",
        "query": "SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) AS BatteryTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) > ALL (SELECT BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');",
        "step": "【step1】: Calculate battery temperature for all full-suspension bicycles using formula: AmbientTemperature + (1000 / HeatDissipationRate) after joining Bicycle, BicycleThermodynamics, and BicycleComponents tables.  【step2】: Create subquery to calculate battery temperature for titanium-handlebar rigid bicycles using same formula through identical table joins.  【step3】: Filter results where full-suspension bicycles' battery temperature exceeds ALL values from subquery results through comparison operator.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 173,
        "question": "Calculate the motor temperature of an electric bicycle under different ambient temperatures, with a motor efficiency of 85%, a battery capacity of 500 watt-hours, a heat dissipation rate of 200 watts, and the ambient temperature varying from 10°C to 40°C. How does the motor temperature change?",
        "query": "SELECT AmbientTemperature, MotorTemperature FROM BicycleThermodynamics WHERE MotorEfficiency = 85 AND BatteryCapacity = 500 AND HeatDissipationRate = 200 AND AmbientTemperature BETWEEN 10 AND 40;",
        "step": "【step1】: Filter records from BicycleThermodynamics where MotorEfficiency = 85%, BatteryCapacity = 500 Wh, and HeatDissipationRate = 200 W  【step2】: Apply ambient temperature range filter (BETWEEN 10°C AND 40°C) to the pre-filtered dataset  【step3】: Extract the AmbientTemperature and MotorTemperature columns from the filtered results",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 174,
        "question": "Calculate the average power output for different types of bicycles under various riding styles, given a rider weight of 70 kg, height of 175 cm, age of 30 years, riding styles including leisure, competitive, and off-road, and bicycle types including road bikes, mountain bikes, and hybrid bikes.",
        "query": "SELECT Type, RidingStyle, AVG(RiderPowerOutput) AS AvgPowerOutput FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
        "step": "【step1】:【Join Bicycle and BicycleRider tables using BicycleID to combine bicycle specifications with rider data】  【step2】:【Filter records where RiderWeight=70kg, RiderHeight=175cm, RiderAge=30, RidingStyle in ('Leisure','Competitive','Off-road'), and Type in ('Road bike','Mountain bike','Hybrid vehicle')】  【step3】:【Group results by bicycle Type and RidingStyle, then calculate average RiderPowerOutput using AVG() aggregation】",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 175,
        "question": "Based on the bicycle's weight, tire pressure, and tire width, calculate the rolling resistance coefficient for a bicycle with a weight of 12 kg, tire pressure of 60 PSI, and tire width of 28 mm.",
        "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;",
        "step": "【step1】: Join Bicycle and BicycleComponents tables using BicycleID and filter with TirePressure=60, TireWidth=28mm, and Weight=12kg.  【step2】: Calculate rolling resistance coefficient using formula (Weight*9.81)/(TirePressure*TireWidth) for physics-based computation.  【step3】: Return Weight, TirePressure, TireWidth, and derived RollingResistanceCoefficient for the specified condition.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 176,
        "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 1000 watt-hours, motor efficiency of 90%, heat dissipation rate of 500 watts, ambient temperature of 50°C, motor temperature of 100°C, and rider power output of 500 watts.",
        "query": "SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 1000 AND MotorEfficiency = 90 AND HeatDissipationRate = 500 AND AmbientTemperature = 50 AND MotorTemperature = 100 AND RiderPowerOutput = 500;",
        "step": "【step1】: Perform INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to combine thermodynamic parameters with rider power output data  【step2】: Apply WHERE clause to filter records with BatteryCapacity=1000, MotorEfficiency=90, HeatDissipationRate=500, AmbientTemperature=50, MotorTemperature=100, and RiderPowerOutput=500  【step3】: Calculate BatteryLife using formula (BatteryCapacity / ((RiderPowerOutput/(MotorEfficiency/100)) + (HeatDissipationRate*(MotorTemperature-AmbientTemperature)))) and select required columns",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 177,
        "question": "Calculate the heat dissipation efficiency at different ambient temperatures between 15°C and 35°C for a bicycle with motor efficiency of 88%, battery capacity of 600 watt-hours, and heat dissipation rate of 250 watts.",
        "query": "SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;",
        "step": "【step1】: Filter records from BicycleThermodynamics where MotorEfficiency=88, BatteryCapacity=600, HeatDissipationRate=250, and AmbientTemperature is within 15-35°C.  【step2】: Calculate the HeatDissipationEfficiency using the formula (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100.  【step3】: Return the AmbientTemperature and corresponding calculated HeatDissipationEfficiency for analysis.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 178,
        "question": "Calculate the average energy consumption for different bicycle types under various riding styles, with the rider weighing 75 kg, height of 180 cm, age of 35 years. The riding styles include leisure, competitive, and off-road, and the bicycle types include road bikes, mountain bikes, and hybrid bikes.",
        "query": "SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
        "step": "【step1】: Join Bicycle and BicycleRider tables on BicycleID, filter for riders with 75kg/180cm/35 years old using WHERE clause, and limit to specified RidingStyles/Types  【step2】: Calculate individual energy consumption using (10*75 + 6.25*180 -5*35 +5) multiplied by RidingStyle coefficients (1.2/1.5/1.8) via CASE statement  【step3】: Group results by bicycle Type and RidingStyle, calculate average energy consumption for each group using AVG() aggregation",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 179,
        "question": "Calculate the rolling resistance coefficient for a bicycle with a weight of 15 kilograms, tire pressure of 65 PSI, and tire width of 30 millimeters.",
        "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;",
        "step": "【step1】:【Join Bicycle and BicycleComponents tables using BicycleID to establish component relationships】  【step2】:【Filter records where TirePressure=65 PSI, TireWidth=30mm, and Weight=15kg using WHERE clause】  【step3】:【Calculate RollingResistanceCoefficient using formula (Weight * 9.81) / (TirePressure * TireWidth) for qualifying entries】",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 180,
        "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 3000 watt-hours, motor efficiency of 98%, heat dissipation rate of 1500 watts, ambient temperature of 70°C, motor temperature of 200°C, and rider power output of 1500 watts.",
        "query": "SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;",
        "step": "【step1】: Perform INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to combine thermodynamic properties with rider power output data.  【step2】: Apply WHERE clause filters to select records with exact parameter values: BatteryCapacity=3000, MotorEfficiency=98, HeatDissipationRate=1500, AmbientTemperature=70, MotorTemperature=200, and RiderPowerOutput=1500.  【step3】: Calculate BatteryLife using the formula: BatteryCapacity divided by the sum of (RiderPowerOutput adjusted by MotorEfficiency percentage) and (HeatDissipationRate multiplied by temperature differential between MotorTemperature and AmbientTemperature).",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 181,
        "question": "Calculate the top speed of a bicycle with a power transmission efficiency of 95%, rider power output of 300 watts, tire pressure of 60 PSI, and tire width of 28 mm, for given aerodynamic drag and rolling resistance values.",
        "query": "SELECT AerodynamicDrag, RollingResistance, (300 * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance bp JOIN Bicycle b ON bp.BicycleID = b.BicycleID JOIN BicycleComponents bc ON b.BicycleID = bc.BicycleID WHERE bc.TireWidth = 28 AND b.TirePressure = 60;",
        "step": "【step1】: Perform a JOIN operation between BicyclePerformance, Bicycle, and BicycleComponents tables using BicycleID to link aerodynamic/rolling resistance data with tire specifications.  【step2】: Filter results where TirePressure = 60 PSI (from Bicycle) and TireWidth = 28mm (from BicycleComponents).  【step3】: Calculate TopSpeed using the formula (300 * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) while explicitly applying the 95% efficiency constraint.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 182,
        "question": "Calculate the climbing efficiency of different bicycle types under various riding styles, with the rider's weight at 70 kg, height at 175 cm, age at 30 years. Riding styles include leisure, competitive, and off-road, while bicycle types comprise road bikes, mountain bikes, and hybrid vehicles.",
        "query": "SELECT Type, RidingStyle, AVG((RiderPowerOutput / (RiderWeight * 9.81 * 0.1)) * 100) AS ClimbingEfficiency FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
        "step": "【step1】: Join `Bicycle` and `BicycleRider` tables using `BicycleID` to combine bicycle type data with rider performance parameters.  【step2】: Filter records where `RiderWeight=70`, `RiderHeight=175`, `RiderAge=30`, and restrict values in `RidingStyle`/`Type` to specified categories.  【step3】: Group results by `Type` and `RidingStyle`, then calculate the average climbing efficiency using the formula `(RiderPowerOutput/(RiderWeight×9.81×0.1))×100`.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 183,
        "question": "Based on the bike's weight, tire pressure, and tire width, calculate the braking distance, where the tire pressure is 60 PSI, the tire width is 28 mm, and the bike weight is 12 kg.",
        "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleComponents tables using BicycleID to combine weight, tire pressure, and tire width data.  【step2】: Apply WHERE clause to filter records with TirePressure=60 PSI, TireWidth=28mm, and Weight=12kg.  【step3】: Calculate BrakingDistance using the formula (Weight * gravitational acceleration) divided by (TirePressure * TireWidth) for qualified records.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 184,
        "question": "Calculate the braking distance for a bicycle with a weight of 20 kilograms, tire pressure of 70 PSI, tire width of 32 millimeters, and maximum load varying from 100 to 500 kilograms.",
        "query": "SELECT MaxLoad, ((Weight + MaxLoad) * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Weight = 20 AND TirePressure = 70 AND TireWidth = 32 AND MaxLoad BETWEEN 100 AND 500;",
        "step": "【step1】: Join Bicycle and BicycleComponents tables on BicycleID to combine bike specifications with component details  【step2】: Apply WHERE clause to filter records with Weight=20kg, TirePressure=70PSI, TireWidth=32mm, and MaxLoad between 100-500kg  【step3】: Calculate BrakingDistance using ((Weight + MaxLoad)*9.81)/(TirePressure*TireWidth) formula and select MaxLoad with computed values",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 185,
        "question": "Calculate the heat dissipation efficiency of an electric bicycle under different ambient temperatures, with a motor efficiency of 88%, a battery capacity of 600 watt-hours, a heat dissipation rate of 250 watts, and ambient temperatures ranging from 15°C to 35°C.",
        "query": "SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;",
        "step": "【step1】: Filter records from BicycleThermodynamics where MotorEfficiency = 88, BatteryCapacity = 600, HeatDissipationRate = 250, and AmbientTemperature is between 15°C and 35°C.  【step2】: Calculate the HeatDissipationEfficiency for each filtered record using the formula (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100.  【step3】: Output the AmbientTemperature and corresponding HeatDissipationEfficiency values.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 186,
        "question": "Calculate the average energy consumption for different types of bicycles under various riding styles, with the rider weighing 75 kg, height of 180 cm, and age of 35 years. The riding styles include leisure, competitive, and off-road, while the bicycle types consist of road bikes, mountain bikes, and hybrid bikes.",
        "query": "SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
        "step": "【step1】: Filter and join tables to select relevant records with specified rider attributes (weight=75kg, height=180cm, age=35) and valid riding styles/bike types.  【step2】: Calculate energy consumption per record using the formula:  `(10*75 + 6.25*180 - 5*35 +5) * style_multiplier` where multipliers are 1.2(休闲)/1.5(竞技)/1.8(越野).  【step3】: Group results by bike type and riding style to compute average energy consumption using AVG().",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 187,
        "question": "Calculate the rolling resistance coefficient for a bicycle with a weight of 15 kilograms, tire pressure of 65 PSI, and tire width of 30 millimeters.",
        "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;",
        "step": "",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 188,
        "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 3000 watt-hours, motor efficiency of 98%, heat dissipation rate of 1500 watts, ambient temperature of 70°C, motor temperature of 200°C, and rider power output of 1500 watts.",
        "query": "SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;",
        "step": "【step1】: Perform INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to combine thermodynamic parameters with rider's power output.  【step2】: Apply WHERE clause to filter records with BatteryCapacity=3000, MotorEfficiency=98, HeatDissipationRate=1500, AmbientTemperature=70, MotorTemperature=200, and RiderPowerOutput=1500.  【step3】: Calculate BatteryLife using formula (BatteryCapacity / ((RiderPowerOutput/(MotorEfficiency/100)) + (HeatDissipationRate*(MotorTemperature - AmbientTemperature)))) and select required columns.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 189,
        "question": "Calculate the top speed of a bicycle for each riding style and rider power output, with an air resistance coefficient of 0.5, rolling resistance coefficient of 0.01, and power transmission efficiency of 95%.",
        "query": "SELECT RidingStyle, RiderPowerOutput, (RiderPowerOutput * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance JOIN BicycleRider ON BicyclePerformance.BicycleID = BicycleRider.BicycleID WHERE AerodynamicDrag = 0.5 AND RollingResistance = 0.01 AND PowerTransferEfficiency = 95;",
        "step": "【step1】: Perform INNER JOIN between BicyclePerformance and BicycleRider tables using BicycleID to combine rider attributes with bicycle performance metrics.  【step2】: Filter records where AerodynamicDrag=0.5, RollingResistance=0.01, and PowerTransferEfficiency=95 to isolate specific physical conditions.  【step3】: Calculate TopSpeed using the formula (RiderPowerOutput * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance), then project RidingStyle, RiderPowerOutput, and the computed TopSpeed.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 190,
        "question": "Calculate the average cadence for riders of different age groups with various riding styles, where the riding styles include leisure, competitive, and off-road, and the age groups are categorized as 20-30 years old, 31-40 years old, and 41-50 years old.",
        "query": "SELECT CASE WHEN RiderAge BETWEEN 20 AND 30 THEN '20-30' WHEN RiderAge BETWEEN 31 AND 40 THEN '31-40' WHEN RiderAge BETWEEN 41 AND 50 THEN '41-50' END AS RiderAgeGroup, RidingStyle, AVG(RiderCadence) AS AvgCadence FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') GROUP BY RiderAgeGroup, RidingStyle;",
        "step": "【step1】: Filter records where RidingStyle is in ('Leisure', ‘Competitive’, 'Off-road') using WHERE clause  【step2】: Create age groups (20-30, 31-40, 41-50) using CASE expression on RiderAge  【step3】: Group by RiderAgeGroup and RidingStyle to calculate AVG(RiderCadence)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 191,
        "question": "Calculate the energy consumption under different cycling styles based on the rider's weight, height, and age. The cycling styles include leisure, competitive, and off-road, with a cycling duration of 1 hour.",
        "query": "SELECT RidingStyle, (10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END * 1 AS EnergyConsumption FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road');",
        "step": "【step1】: Filter riders with specified riding styles ('Leisure', ‘Competitive’, 'Off-road') and extract required fields (RidingStyle, RiderWeight, RiderHeight, RiderAge)  【step2】: Apply metabolic formula (10*RiderWeight + 6.25*RiderHeight - 5*RiderAge + 5) and calculate base energy expenditure  【step3】: Multiply by style-specific coefficients (1.2/1.5/1.8) using CASE expression to finalize EnergyConsumption",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 192,
        "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 5000 watt-hours, motor efficiency of 99%, a heat dissipation rate of 2000 watts, ambient temperature at 80°C, motor temperature at 250°C, and the rider's power output varying from 1000 watts to 5000 watts.",
        "query": "SELECT RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / MotorEfficiency) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 5000 AND MotorEfficiency = 99 AND HeatDissipationRate = 2000 AND AmbientTemperature = 80 AND MotorTemperature = 250 AND RiderPowerOutput BETWEEN 1000 AND 5000;",
        "step": "【step1】: Perform an INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to link thermal properties with rider power output data.  【step2】: Apply WHERE clause to filter records with BatteryCapacity=5000, MotorEfficiency=99, HeatDissipationRate=2000, AmbientTemperature=80, MotorTemperature=250, and RiderPowerOutput between 1000-5000.  【step3】: Calculate BatteryLife using the formula: BatteryCapacity divided by the sum of (RiderPowerOutput divided by MotorEfficiency) and (HeatDissipationRate multiplied by temperature difference between MotorTemperature and AmbientTemperature).",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 193,
        "question": "Calculate the minimum power a rider must output when climbing a hill on a mountain bike, with a gradient of 10%, a total weight of the bike and rider of 100 kg, a rolling resistance coefficient of 0.005, an air resistance coefficient of 0.3, a frontal area of 0.5 m², a wind speed of 5 meters per second, and a climbing efficiency of 80%, for the bicycle's top speed in km/h.",
        "query": "SELECT ((100 * 9.81 * SIN(ATAN(0.1))) + (100 * 9.81 * 0.005 * COS(ATAN(0.1))) + (0.5 * 1.225 * 0.3 * 0.5 * POWER((5 + (TopSpeed * 0.277778)), 2))) * (TopSpeed * 0.277778) / 0.8 AS MinPower FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'Mountain bike')",
        "step": "【step1】: [Filter Mountain Bicycles] Execute subquery to select BicycleID from Bicycle table where Type = 'Mountain bike', establishing the target bicycle category.  【step2】: [Retrieve Performance Metrics] Access TopSpeed values from BicyclePerformance table for bicycles identified in Step 1.  【step3】: [Calculate Power Requirements] Apply the physics formula combining gravitational force (100kg × 9.81 × sin(arctan(0.1))), rolling resistance (100kg × 9.81 × 0.005 × cos(arctan(0.1))), aerodynamic drag (0.5 × 1.225 × 0.3 × frontal_area × (wind_speed + bike_speed)²), then multiply by speed (converted from km/h to m/s) and divide by 0.8 efficiency.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 194,
        "question": "Calculate the ratio of power transmission efficiency to aerodynamic drag for each bicycle and identify the top 3 bicycles with the highest ratio, with the requirement that these bicycles are priced below 10,000 yuan.",
        "query": "SELECT BicycleID, (PowerTransferEfficiency / AerodynamicDrag) AS EfficiencyRatio FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Price < 10000) ORDER BY EfficiencyRatio DESC LIMIT 3",
        "step": "【step1】: Filter BicycleIDs with Price < 10000 from Bicycle table using a subquery (SELECT BicycleID FROM Bicycle WHERE Price < 10000).  【step2】: Calculate EfficiencyRatio (PowerTransferEfficiency / AerodynamicDrag) in BicyclePerformance table for filtered BicycleIDs.  【step3】: Sort results by EfficiencyRatio in descending order and limit to top 3 records.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 195,
        "question": "Identify bicycles with carbon fiber frames and road bike type that have both weight and price below the average for bicycles with carbon fiber frames and road bike type.",
        "query": "SELECT BicycleID FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND Weight < (SELECT AVG(Weight) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike') AND Price < (SELECT AVG(Price) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike')",
        "step": "【step1】: Calculate the average weight and average price of all carbon fiber road bicycles using subqueries  【step2】: Filter bicycles with FrameMaterial = 'Carbon fiber' and Type = 'Road bike' in the main query  【step3】: Apply dual conditional filtering (Weight < calculated_avg_weight AND Price < calculated_avg_price) to select qualifying BicycleIDs",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 196,
        "question": "Calculate the percentage change in rolling resistance on different road surfaces (such as asphalt, gravel, and mud), with rolling resistance coefficients of 0.004, 0.02, and 0.05 respectively.",
        "query": "SELECT 'Asphalt road' AS Surface, ((0.004 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Gravel Road' AS Surface, ((0.02 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Muddy ground' AS Surface, ((0.05 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance",
        "step": "【step1】: Retrieve original rolling resistance coefficients from BicyclePerformance table for bicycles matching the modified specifications (WheelSize=50 inches and TirePressure=10 PSI in Bicycle table) through a JOIN operation.  【step2】: Calculate resistance change percentage for each surface type using formula ((new_coefficient - original_coefficient)/original_coefficient)*100 with hardcoded surface coefficients (0.004, 0.02, 0.05).  【step3】: Combine results for all three surfaces using UNION ALL to create unified output with Surface labels and corresponding percentage changes.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 197,
        "question": "Calculate the impact of the total weight of a bicycle (including the rider and the bicycle itself) on tire pressure, with the tire contact area remaining unchanged.",
        "query": "SELECT b.BicycleID, (b.Weight + r.RiderWeight) / (b.TirePressure * 0.07030695796) AS Tire_Pressure_Impact FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to link each bicycle with its corresponding rider data  【step2】: Calculate total system weight by summing bicycle's Weight and rider's RiderWeight for each BicycleID  【step3】: Compute tire pressure impact using formula (TotalWeight)/(TirePressure×0.07030695796), where 0.07030695796 converts PSI to kg/cm² for pressure-area relationship",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 198,
        "question": "Find the theoretical maximum speed for each bicycle based on the rider's power output, power transfer efficiency, aerodynamic drag, and rolling resistance.",
        "query": "SELECT b.BicycleID, (r.RiderPowerOutput * p.PowerTransferEfficiency) / (p.AerodynamicDrag * p.RollingResistance) AS TopSpeed_Theoretical FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
        "step": "【step1】: Join Bicycle with BicyclePerformance to retrieve power transfer efficiency and resistance metrics (aerodynamic drag, rolling resistance) for each bicycle.  【step2】: Join Bicycle with BicycleRider to obtain rider power output values linked to each bicycle.  【step3】: Combine joined datasets and calculate theoretical top speed using the formula:  `(RiderPowerOutput * PowerTransferEfficiency) / (AerodynamicDrag * RollingResistance)` for each bicycle-rider pair.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 199,
        "question": "Based on the type of bicycle and the rider's cycling style, which combination has the highest count of matches?",
        "query": "SELECT b.Type, r.RidingStyle, COUNT(*) AS Match_Count FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID GROUP BY b.Type, r.RidingStyle ORDER BY Match_Count DESC;",
        "step": "【step1】: Join Bicycle and BicycleRider tables using BicycleID to associate bike types with rider styles  【step2】: Group results by bicycle Type and RidingStyle, count occurrences to determine popularity  【step3】: Sort matches in descending order by Match_Count to show most recommended combinations first",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 200,
        "question": "If the tire pressure of each bicycle is increased to 1000 PSI, calculate its impact on braking distance, with all other conditions remaining unchanged.",
        "query": "SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
        "step": "【step1】: Perform JOIN operation between Bicycle and BicyclePerformance tables using BicycleID to combine tire pressure and braking distance data.  【step2】: Calculate new braking distance by multiplying original BrakingDistance with the ratio (current TirePressure/1000 PSI).  【step3】: Select BicycleID and transformed Braking_Distance_New through the calculation in Step 2.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 201,
        "question": "Calculate the impact of the center of gravity height of each bicycle on cornering stability; during a turn, the center of gravity height is inversely proportional to cornering stability.",
        "query": "SELECT b.BicycleID, 1 / d.CenterOfGravityHeight AS Cornering_Stability_Impact FROM Bicycle b JOIN BicycleDynamics d ON b.BicycleID = d.BicycleID;",
        "step": "【step1】: Join Bicycle and BicycleDynamics tables using BicycleID to access the CenterOfGravityHeight metric  【step2】: Calculate the reciprocal value of CenterOfGravityHeight (1/CenterOfGravityHeight) to represent inverse proportionality  【step3】: Alias the calculated value as Cornering_Stability_Impact to reflect the stability indicator",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 202,
        "question": "Calculate the product of the power transmission efficiency of each bicycle and the rider's power output, and identify the bicycle with the highest product.",
        "query": "SELECT b.BicycleID, r.RiderPowerOutput * p.PowerTransferEfficiency AS Power_Output_Effective FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY Power_Output_Effective DESC LIMIT 1;",
        "step": "【step1】: Join Bicycle, BicyclePerformance and BicycleRider tables via BicycleID to associate bicycle data with performance metrics and rider power output.  【step2】: Calculate Power_Output_Effective by multiplying RiderPowerOutput from BicycleRider and PowerTransferEfficiency from BicyclePerformance for each bicycle.  【step3】: Sort results by Power_Output_Effective in descending order and select the top record with LIMIT 1 to find the maximum product.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 203,
        "question": "Based on the type of bicycle and the rider's weight, list the bicycle types and rider names where the bicycle's maximum load capacity exceeds the rider's weight.",
        "query": "SELECT b.Type, r.RiderName FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID WHERE b.MaxLoad > r.RiderWeight;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID as the linking field  【step2】: Apply WHERE filter condition to select records where bicycle's MaxLoad exceeds rider's RiderWeight  【step3】: Project final result columns by selecting Type from Bicycle and RiderName from BicycleRider",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 204,
        "question": "If the tire pressure of a bicycle is adjusted to match the value in the TirePressure field, calculate its impact on the braking distance by comparing the original braking distance with the new braking distance (calculated as the original braking distance multiplied by the tire pressure divided by 1000.0), and identify the bicycle with the largest absolute change in braking distance.",
        "query": "SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
        "step": "【step1】: Join the `Bicycle` and `BicyclePerformance` tables using `BicycleID` to associate each bike's tire pressure with its current braking distance.  【step2】: Calculate the **hypothetical new braking distance** by multiplying the original `BrakingDistance` by the ratio of the current `TirePressure` to 1000 PSI (`BrakingDistance * (TirePressure / 1000)`).  【step3】: Compute the **absolute change** between the original and new braking distances for each bicycle, then order the results by this change in descending order to identify the bicycle with the largest difference.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 205,
        "question": "Calculate the air resistance of an electric vehicle (bicycle) traveling at its top speed, with an air density of 1.225 kg/m³, a total frontal area of the bicycle and rider of 0.5 m², and an air drag coefficient of 0.9.",
        "query": "SELECT 0.5 * 1.225 * POWER(TopSpeed * 0.277778, 2) * 0.9 * 0.5 AS AirResistance FROM BicyclePerformance JOIN Bicycle ON BicyclePerformance.BicycleID = Bicycle.BicycleID WHERE Bicycle.Type = 'electric vehicle';",
        "step": "【step1】: Join BicyclePerformance and Bicycle tables using BicycleID to associate performance data with bicycle type  【step2】: Filter records where bicycle type is 'electric vehicle' (electric bicycle)  【step3】: Apply air resistance formula: 0.5 × air_density × (TopSpeed converted from km/h to m/s)² × drag_coefficient × frontal_area",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 206,
        "question": "Calculate the actual power delivered to the wheel for a bicycle with 85% power transmission efficiency, given that the rider's power output is 250 watts.",
        "query": "SELECT 250 * (PowerTransferEfficiency / 100) AS ActualPower FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);",
        "step": "【step1】: Execute the subquery to retrieve the BicycleID from BicycleRider where RiderPowerOutput = 250  【step2】: Query the BicyclePerformance table using the obtained BicycleID to fetch the PowerTransferEfficiency value  【step3】: Calculate ActualPower by multiplying 250W by the PowerTransferEfficiency (divided by 100 to convert percentage to decimal)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 207,
        "question": "Based on the weight of the bicycle and the rider's weight, determine whether this bicycle is suitable, with the maximum load limit being 120 kilograms.",
        "query": "SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 120 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine bicycle weight and rider weight data  【step2】: Calculate total load (Bicycle.Weight + BicycleRider.RiderWeight) and use CASE expression to compare against 120kg threshold  【step3】: Project BicycleID with suitability determination using CASE results aliased as 'Suitability' column",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 208,
        "question": "Calculate the braking distance of a road bike, with the bicycle's speed being 100 kilometers per hour converted to meters per second, the coefficient of friction between the tires and the ground at 2.0, and the gravitational acceleration at 9.8 m/s².",
        "query": "SELECT POWER(100 * 0.277778, 2) / (2 * 2.0 * 9.8 * 2) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');",
        "step": "【step1】: Execute subquery to retrieve BicycleID from Bicycle table where Type is 'Road bike'  【step2】: Convert bicycle speed from 100 km/h to m/s using 0.277778 conversion factor and apply braking distance formula: (v²)/(2*μ*g*efficiency)  【step3】: Combine subquery result with physics formula in main SELECT statement to calculate BrakingDistance from BicyclePerformance table",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 209,
        "question": "Calculate the kinetic energy of an electric bicycle when traveling at its maximum speed, given that the bicycle weighs 20 kilograms, the rider weighs 70 kilograms, and the maximum speed is 45 kilometers per hour.",
        "query": "SELECT 0.5 * (Bicycle.Weight + BicycleRider.RiderWeight) * POWER(BicyclePerformance.TopSpeed * 0.277778, 2) AS KineticEnergy FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine bicycle weight (20kg) and rider weight (70kg)  【step2】: INNER JOIN BicyclePerformance table using BicycleID to obtain TopSpeed (45 km/h) and convert speed to m/s via 45*0.277778  【step3】: Calculate kinetic energy using formula 0.5*(total_mass)*velocity² in SELECT clause and filter for 'electric vehicle' type in WHERE condition",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 210,
        "question": "Calculate the cost-benefit ratio of a bicycle, given the purchase price is 5000 yuan, the service life is 5 years, the annual riding distance is 2000 kilometers, and the cost per kilometer ridden is 0.5 yuan.",
        "query": "SELECT (Bicycle.Price + (2000 * 0.5 * 5)) / (2000 * 5) AS CostBenefitRatio FROM Bicycle WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);",
        "step": "【step1】: Execute the nested subquery to retrieve the BicycleID from BicycleRider where RiderPowerOutput equals 250  【step2】: Fetch the Price value from the Bicycle table using the obtained BicycleID  【step3】: Calculate CostBenefitRatio using formula: (Price + (annual_distance * cost_per_km * lifespan)) / (annual_distance * lifespan)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 211,
        "question": "Based on the bicycle's maximum load capacity and the rider's weight, determine whether this bicycle is suitable. The maximum load limit is 100 kilograms.",
        "query": "SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 100 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
        "step": "【step1】: Perform an INNER JOIN between the Bicycle and BicycleRider tables using BicycleID to link each bicycle with its corresponding rider data.  【step2】: Calculate the combined weight by adding Bicycle.Weight (bicycle's own weight) and BicycleRider.RiderWeight (rider's weight).  【step3】: Use a CASE statement to evaluate if the combined weight is ≤100 kg, assigning 'suitable' (suitable) or 'Not suitable' (unsuitable) based on the result.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 212,
        "question": "Calculate the braking distance of a road bike with a speed of 200 km/h, a tire-to-ground friction coefficient of 3.0, and gravitational acceleration of 9.8 m/s².",
        "query": "SELECT POWER(200 * 0.277778, 2) / (2 * 3.0 * 9.8 * 3) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');",
        "step": "【step1】: Execute the subquery `(SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike')` to retrieve the BicycleID of road bikes from the Bicycle table.  【step2】: Calculate the braking distance using the formula `POWER(200 * 0.277778, 2) / (2 * 3.0 * 9.8 * 3)`, converting speed from km/h to m/s, squaring it, and dividing by twice the product of friction coefficient, gravity, and brake efficiency (300% = 3x).  【step3】: Query the BicyclePerformance table with the retrieved BicycleID to return the calculated BrakingDistance result.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 213,
        "question": "Calculate the kinetic energy of an electric vehicle bicycle traveling at maximum speed under maximum load.",
        "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';",
        "step": "【step1】: Filter bicycles of type 'electric vehicle' from Bicycle table using WHERE clause to select relevant electric bicycles.  【step2】: JOIN BicyclePerformance table on BicycleID to access TopSpeed (converted from km/h to m/s via *1000/3600) and calculate total mass (Weight + MaxLoad).  【step3】: Apply kinetic energy formula 0.5 * total_mass * velocity² using POWER() function to compute final KineticEnergy value for each qualifying bicycle.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 214,
        "question": "Calculate the average power transmission efficiency for each type of bicycle and identify the type with the highest efficiency.",
        "query": "SELECT Type, AVG(PowerTransferEfficiency) AS AvgEfficiency FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgEfficiency DESC LIMIT 1;",
        "step": "【step1】: Perform an INNER JOIN between the 'Bicycle' and 'BicyclePerformance' tables using BicycleID to associate bicycle types with their performance metrics.  【step2】: Calculate the average PowerTransferEfficiency for each bicycle type using GROUP BY Type and AVG(PowerTransferEfficiency).  【step3】: Sort the results by AvgEfficiency in descending order and select the top result using ORDER BY and LIMIT 1 to identify the most efficient type.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 215,
        "question": "Find the average price of bicycles with a carbon fiber frame material for each manufacturer.",
        "query": "SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' GROUP BY Manufacturer;",
        "step": "【step1】: Filter Bicycle table to select records where FrameMaterial is 'Carbon fiber' using WHERE clause  【step2】: Group filtered records by Manufacturer and calculate average Price using GROUP BY and AVG()  【step3】: (Not required as query doesn't involve joins/subqueries/sorting)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 216,
        "question": "Calculate the new contact area between the tire and the ground, assuming the tire width remains unchanged.",
        "query": "SELECT Bicycle.BicycleID, (BicycleComponents.TireWidth * 1000) / 1000 AS NewContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;",
        "step": "【step1】: Join Bicycle and BicycleComponents tables via BicycleID to access tire width data  【step2】: Calculate new contact area using formula (TireWidth * 1000)/1000 (equivalent to original tire width)  【step3】: Present BicycleID with unchanged tire width values as \"NewContactArea\" due to canceled pressure ratio",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 217,
        "question": "Calculate the contact area between the bicycle tire and the ground for each bicycle and rider combination, using the formula (rider weight + bicycle weight) divided by tire pressure.",
        "query": "SELECT Bicycle.BicycleID, (BicycleRider.RiderWeight + Bicycle.Weight) / Bicycle.TirePressure AS ContactArea FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
        "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine rider and bicycle data  【step2】: Calculate total load by summing RiderWeight (rider's weight) and Weight (bicycle's weight)  【step3】: Compute contact area by dividing total load by TirePressure (using formula: ContactArea = Total_Weight / TirePressure)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 218,
        "question": "Calculate the average rolling resistance coefficient for each type of bicycle and identify the bicycle type with the lowest rolling resistance.",
        "query": "SELECT Type, AVG(RollingResistance) AS AvgRollingResistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgRollingResistance ASC LIMIT 1;",
        "step": "【step1】:Join Bicycle and BicyclePerformance tables using BicycleID to associate bicycle types with their rolling resistance data.  【step2】:Calculate average rolling resistance per bicycle type using GROUP BY Type and AVG(RollingResistance).  【step3】:Sort results by AvgRollingResistance in ascending order and select the top record using ORDER BY and LIMIT 1 to identify the type with minimal resistance.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 219,
        "question": "Find the average braking distance for bicycles with disc brakes, grouped by manufacturer.",
        "query": "SELECT Manufacturer, AVG(BrakingDistance) AS AvgBrakingDistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE BrakeType = 'Disc brakes' GROUP BY Manufacturer;",
        "step": "【step1】:【Join Bicycle table with BicyclePerformance table using BicycleID to associate braking distance data with bicycle specifications】  【step2】:【Filter records where BrakeType is 'Disc brakes' to isolate bicycles with disc brakes】  【step3】:【Group results by Manufacturer and calculate the average BrakingDistance for each group to compare braking performance】",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 220,
        "question": "If the battery capacity of a bicycle is increased to 100,000 watt-hours, calculate how much the range will increase per unit of rider power output, with motor efficiency and rider power output remaining unchanged.",
        "query": "SELECT Bicycle.BicycleID, (100000 - BicycleThermodynamics.BatteryCapacity) * BicycleThermodynamics.MotorEfficiency / BicycleRider.RiderPowerOutput AS RangeIncrease FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
        "step": "【step1】: Join Bicycle with BicycleThermodynamics using BicycleID to access BatteryCapacity and MotorEfficiency.  【step2】: Join the result with BicycleRider using BicycleID to obtain RiderPowerOutput.  【step3】: Calculate RangeIncrease via (100000 - BatteryCapacity) * MotorEfficiency / RiderPowerOutput for each BicycleID.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 221,
        "question": "Calculate the center of gravity height of a bicycle with a carbon fiber frame, with a rider weight of 75 kilograms, a bicycle weight of 10 kilograms, and a center of gravity height of 50 centimeters, using the formula (75 * 50 + 10 * 50) / (75 + 10 + MaxLoad).",
        "query": "SELECT BicycleID, Manufacturer, Model, (75 * 50 + 10 * 50) / (75 + 10 + MaxLoad) AS CenterOfGravityHeight FROM Bicycle WHERE FrameMaterial = 'Carbon fiber';",
        "step": "【step1】: Filter bicycles with carbon fiber frame using WHERE FrameMaterial = 'Carbon fiber'  【step2】: Calculate numerator (75kg rider * 50cm + 10kg bike * 50cm) and denominator (75+10+MaxLoad) for combined weight  【step3】: Compute CenterOfGravityHeight by dividing total moment (numerator) by total weight (denominator)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 222,
        "question": "Find the bicycle ID, manufacturer, model, and the product of the bicycle's power transfer efficiency and the rider's power output (actual power output), and list the top 5 ranked from highest to lowest actual power output.",
        "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, p.PowerTransferEfficiency * r.RiderPowerOutput AS ActualPowerOutput FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY ActualPowerOutput DESC LIMIT 5;",
        "step": "【step1】: JOIN tables Bicycle, BicyclePerformance, and BicycleRider using BicycleID to associate bicycle specifications, performance metrics, and rider data.  【step2】: Calculate ActualPowerOutput by multiplying PowerTransferEfficiency from BicyclePerformance and RiderPowerOutput from BicycleRider, then sort results in descending order.  【step3】: Limit the final output to the top 5 highest ActualPowerOutput values using the LIMIT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 223,
        "question": "Retrieve all bicycles with tire pressure below 60 PSI, and list their manufacturer, model, and tire pressure.",
        "query": "SELECT Manufacturer, Model, TirePressure FROM Bicycle WHERE TirePressure < 60;",
        "step": "【step1】:【Filter records from the Bicycle table where TirePressure is below 60 PSI】  【step2】:【Select Manufacturer, Model, and TirePressure columns from the filtered records】",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 224,
        "question": "Calculate the braking distance of a bicycle with a maximum speed of 1000 m/s, a rolling resistance coefficient of 0.01, an air resistance coefficient of 0.5, a rider weight of 1000 kg, and a bicycle weight of 1000 kg.",
        "query": "SELECT BicycleID, Manufacturer, Model, (1000 * 1000) / (2 * (0.01 + 0.5) * 9.81) AS BrakingDistance FROM Bicycle;",
        "step": "【step1】: Join Bicycle table with BicyclePerformance to access rolling resistance and aerodynamic coefficients  【step2】: Calculate total mass (1000kg rider + 1000kg bicycle) and apply braking distance formula  【step3】: Final projection of BicycleID, Manufacturer, Model, and calculated BrakingDistance using physics formula with actual coefficient values",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 225,
        "question": "Identify the impact of wheelbase and rider weight on bicycle turning stability, and compute the theoretical minimum turning radius for each bicycle.",
        "query": "SELECT d.BicycleID, b.Manufacturer, b.Model, r.RiderWeight, d.Wheelbase, d.SteeringAngle, (d.Wheelbase / (2 * SIN(RADIANS(d.SteeringAngle)))) AS MinTurningRadius FROM BicycleDynamics d JOIN Bicycle b ON d.BicycleID = b.BicycleID JOIN BicycleRider r ON d.BicycleID = r.BicycleID;",
        "step": "【step1】: Join BicycleDynamics with Bicycle to get manufacturer/model and wheelbase/steering data  【step2】: Join result with BicycleRider to incorporate rider weight information  【step3】: Calculate minimum turning radius using formula (Wheelbase / (2*SIN(RADIANS(SteeringAngle)))) for each bicycle-rider combination",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 226,
        "question": "Calculate the average theoretical range of electric bicycles based on battery capacity, motor efficiency, and rider power output, grouped by ambient temperature.",
        "query": "SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency / 100) / (r.RiderPowerOutput / 1000) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;",
        "step": "【step1】: [Join tables with filtering] Connect BicycleThermodynamics to Bicycle and BicycleRider via BicycleID, filter bicycles where Type='electric vehicle'  【step2】: [Calculate theoretical range per bicycle] Compute (BatteryCapacity * MotorEfficiency/100)/(RiderPowerOutput/1000)*3.6 for each eligible bicycle  【step3】: [Aggregate by temperature] Group results by AmbientTemperature and calculate average range using AVG()",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 227,
        "question": "Find full-suspension mountain bikes that use aluminum rims and have tire widths exceeding 50mm, and calculate the average price for each manufacturer.",
        "query": "SELECT b.Manufacturer, AVG(b.Price) AS AvgPrice FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.SuspensionType = 'Full suspension' AND b.Type = 'Mountain bike' AND c.TireWidth > 50 AND c.RimMaterial = 'aluminum alloy' GROUP BY b.Manufacturer;",
        "step": "【step1】: JOIN Bicycle and BicycleComponents tables using BicycleID, filter records where SuspensionType='Full suspension', Type='Mountain bike', RimMaterial='aluminum alloy', and TireWidth > 50  【step2】: Group filtered records by Manufacturer  【step3】: Calculate AVG(Price) per group and select Manufacturer with AvgPrice",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 228,
        "question": "Calculate the required dissipation for each bicycle motor, where the motor temperature is below 100°C, based on the motor efficiency and a fixed ambient temperature scenario.",
        "query": "SELECT th.BicycleID, (5000 * (1 - th.MotorEfficiency/100) + (200 - 25) * 50) AS RequiredDissipation FROM BicycleThermodynamics th WHERE th.MotorTemperature < 100;",
        "step": "【step1】: Filter records from BicycleThermodynamics where MotorTemperature is below 100°C to ensure operational safety  【step2】: Calculate required heat dissipation using formula: (5000*(1-MotorEfficiency/100)) + ((200-25)*50), combining motor inefficiency heat and ambient thermal load",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 229,
        "question": "Calculate the aerodynamic drag power for each bicycle based on the drag coefficient, top speed, tire width, and handlebar width, and list the top 5 models with the highest aerodynamic drag power.",
        "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, 0.5 * p.AerodynamicDrag * 1.225 * POW(p.TopSpeed/3.6, 3) * (c.TireWidth/1000 * b.HandlebarWidth/100) AS AirPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleComponents c ON b.BicycleID = c.BicycleID ORDER BY AirPower DESC LIMIT 5;",
        "step": "【step1】: Join Bicycle, BicyclePerformance, and BicycleComponents tables using BicycleID to combine aerodynamic parameters, speed, tire width, and handlebar width.  【step2】: Calculate air resistance power using formula 0.5 * AerodynamicDrag * air density * (speed converted to m/s)^3 * cross-sectional area (TireWidth*HandlebarWidth converted to meters).  【step3】: Sort results by calculated AirPower in descending order and limit output to top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 230,
        "question": "Calculate the average energy recovery efficiency for electric bicycles, based on battery capacity, motor efficiency, and rider power output, grouped by ambient temperature.",
        "query": "SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency/100) / r.RiderPowerOutput) AS EnergyRecovery FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;",
        "step": "【step1】: Join BicycleThermodynamics with Bicycle and BicycleRider tables through BicycleID, filtering only electric bicycles using WHERE clause  【step2】: Calculate energy recovery efficiency for each bicycle using formula (BatteryCapacity * MotorEfficiency/100) / RiderPowerOutput  【step3】: Group results by AmbientTemperature and compute average efficiency using AVG() function",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 231,
        "question": "Find all road bikes that use a carbon fiber frame and have tire pressure above 80 PSI, and calculate the average price by manufacturer.",
        "query": "SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND TirePressure > 80 GROUP BY Manufacturer;",
        "step": "【step1】: Filter records from Bicycle table where FrameMaterial is 'Carbon fiber', Type is 'Road bike', and TirePressure > 80 PSI  【step2】: Group the filtered records by Manufacturer  【step3】: Calculate average Price for each Manufacturer group using AVG(Price)",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 232,
        "question": "Calculate the percentage of battery capacity remaining for electric vehicle bicycles when the ambient temperature is -50°C, given the capacity decreases linearly with temperature by 0.5% for every 1°C drop from 25°C.",
        "query": "SELECT BicycleID, (100 - (25 - (-50)) * 0.5) AS CapacityRemaining FROM BicycleThermodynamics WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'electric vehicle');",
        "step": "【step1】: Retrieve all BicycleIDs from the Bicycle table where Type='electric vehicle' using a subquery.  【step2】: Filter BicycleThermodynamics records where BicycleID matches the electric bicycle IDs from step1.  【step3】: Calculate capacity percentage by applying the formula: 100 - (75 temperature delta × 0.5% degradation per °C) = 62.5%, hardcoding the initial temperature assumption as 25°C.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "1",
        "idx": 233,
        "question": "Calculate the percentage difference between the theoretical braking distance and the actual measured value for each bicycle, and list the models with a difference exceeding 10%.",
        "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance)*100 AS Deviation, p.BrakingDistance AS ActualDistance, POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) AS TheoreticalDistance FROM BicyclePerformance p JOIN Bicycle b ON p.BicycleID = b.BicycleID WHERE ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance) > 0.1",
        "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID to link bike metadata with performance metrics  【step2】: Calculate theoretical braking distance using the formula (TopSpeed²)/(2*(RollingResistance+AerodynamicDrag)*9.81) after converting km/h to m/s, then compute deviation percentage between theoretical and actual BrakingDistance  【step3】: Filter results where absolute deviation exceeds 10% using the condition (>0.1) in the WHERE clause, and project required columns with formatted deviation percentage",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "2",
        "idx": 234,
        "question": "Calculate the average driving range of electric bicycles across ambient temperature ranges from -20°C to 60°C, grouped in 10°C intervals, accounting for battery capacity decay based on temperature deviation from 25°C.",
        "query": "SELECT FLOOR(th.AmbientTemperature/10)*10 AS TempRange, AVG(th.BatteryCapacity * (1 - 0.005*POW(ABS(th.AmbientTemperature-25), 1.2)) * th.MotorEfficiency/100 / (r.RiderPowerOutput/1000) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY TempRange ORDER BY TempRange",
        "step": "【step1】: Filter electric bicycles by joining Bicycle table and apply temperature grouping using FLOOR(th.AmbientTemperature/10)*10  【step2】: Join Rider table to obtain power output data and calculate the battery decay formula: BatteryCapacity * (1 - 0.005*POW(ABS(Temp-25),1.2))  【step3】: Compute final range metric by incorporating MotorEfficiency and RiderPowerOutput, then aggregate averages per temperature group with sorting",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "3",
        "idx": 235,
        "question": "Find mountain bike models where the suspension type and tire width are mismatched (full suspension should have tire width >50mm, no suspension should have tire width <40mm).",
        "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, b.SuspensionType, c.TireWidth FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.Type = 'Mountain bike' AND ((b.SuspensionType = 'Full suspension' AND c.TireWidth <= 50) OR (b.SuspensionType = 'No suspension' AND c.TireWidth >= 40))",
        "step": "【step1】: Join Bicycle and BicycleComponents tables on BicycleID, filtering for 'Mountain bike' type.  【step2】: Apply condition for full-suspension bikes with incompatible tire widths (SuspensionType='Full suspension' AND TireWidth ≤50mm).  【step3】: Add condition for hardtail bikes with incompatible tire widths (SuspensionType='No suspension' AND TireWidth ≥40mm), combining both cases with OR logic.",
        "format": "MySQL"
    },
    {
        "db_id": "bike",
        "type": "4",
        "idx": 236,
        "question": "Calculate the theoretical temperature rise of an electric vehicle motor when continuously operating at a load of 500 kg for 1 hour, with an ambient temperature of 60°C and no cooling system.",
        "query": "SELECT th.BicycleID, (r.RiderPowerOutput/(th.MotorEfficiency/100) * 3600 * (1 - th.MotorEfficiency/100)) / (500 * 0.9) + 60 AS TheoreticalTemp FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' AND b.MaxLoad >= 500",
        "step": "【step1】: Join BicycleThermodynamics, Bicycle, and BicycleRider tables on BicycleID to access motor efficiency, power output, and load capacity data  【step2】: Apply filters for electric bicycles (b.Type='electric vehicle') with maximum load ≥500kg (b.MaxLoad >= 500)  【step3】: Calculate theoretical temperature rise using formula: [(RiderPowerOutput/(MotorEfficiency/100) * 3600 * (1 - MotorEfficiency/100)) / (500*0.9)] + 60°C ambient temperature",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 237,
        "question": "Please query engine models with a compression ratio between 10:1 and 12:1, calculate their theoretical maximum thermal efficiency (based on the Otto cycle), and sort the results in ascending order by compression ratio.",
        "query": "SELECT Model, Compression_Ratio, (1 - (1/POW(Compression_Ratio, 0.4))) AS Thermal_Efficiency FROM engine WHERE Compression_Ratio BETWEEN 10 AND 12 AND Fuel_Type = 'Gasoline' ORDER BY Compression_Ratio ASC;",
        "step": "【step1】: Filter records from engine table where Fuel_Type is 'Gasoline' and Compression_Ratio between 10 and 12  【step2】: Calculate theoretical maximum thermal efficiency using the Otto cycle formula (1 - 1/POW(Compression_Ratio, 0.4)) for qualified engines  【step3】: Sort the results by Compression_Ratio in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 238,
        "question": "Please calculate the single-cylinder displacement for all inline 6-cylinder engines, verify whether the total displacement equals the value in the Displacement field, and sort the top 5 by the absolute value of calculation error in descending order.",
        "query": "SELECT Model, Displacement, (PI() * POW(Bore/20, 2) * Stroke/10)/1000 AS 单缸排量, ABS(Displacement - (PI() * POW(Bore/20, 2) * Stroke/10)/1000 * Cylinders) AS error FROM engine WHERE Configuration = 'Inline' AND Cylinders = 6 ORDER BY error DESC LIMIT 5;",
        "step": "【step1】: Filter engines meeting criteria (Configuration='Inline' AND Cylinders=6) from engine table  【step2】: Calculate per-cylinder displacement using (π*(Bore/20)^2*Stroke/10)/1000 and compute error between calculated total displacement and Displacement field  【step3】: Sort results by absolute error descending and limit to top 5 records",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 239,
        "question": "Please list the top 10 engines that are turbocharged (Aspiration='Turbocharged') and use cast iron cylinder blocks (Block_Material='Cast Iron'), sorted in descending order by specific power (Specific_Power).",
        "query": "SELECT e.Model, e.Aspiration, ep.Specific_Power FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND m.Block_Material = 'Cast Iron' ORDER BY ep.Specific_Power DESC LIMIT 10;",
        "step": "【step1】: Join engine, enginematerials, and engineperformance tables via Engine_ID to combine engine attributes, material composition, and performance metrics  【step2】: Filter records where Aspiration='Turbocharged' and Block_Material='Cast Iron' using WHERE clause  【step3】: Sort results by Specific_Power in descending order and limit output to top 10 entries using ORDER BY and LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 240,
        "question": "Assuming the redline speed (Redline) for all engines is increased to 100,000 RPM, calculate the piston speed (Piston_Speed=2*Stroke*RPM/60) at this condition and list the models that exceed the speed of sound (343 m/s), sorted in descending order by piston speed.",
        "query": "SELECT Model, Stroke, (2 * Stroke * 100000) / 60000 AS Piston_Speed FROM engine WHERE (2 * Stroke * 100000) / 60000 > 343 ORDER BY Piston_Speed DESC;",
        "step": "【step1】: Calculate piston speed using the formula (2*Stroke*100000)/60000 for all entries in the 'engine' table.  【step2】: Filter results where the calculated piston speed exceeds the speed of sound (343 m/s).  【step3】: Sort the remaining entries in descending order based on the calculated piston speed.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 241,
        "question": "Retrieve the top three engine models with the largest volume (length × width × height), sorted in descending order by volume, and provide their compression ratios.",
        "query": "SELECT e.Model, (ed.Length * ed.Width * ed.Height) AS Volume, e.Compression_Ratio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY Volume DESC LIMIT 3;",
        "step": "【step1】: Join the 'engine' and 'enginedimensions' tables using Engine_ID to combine engine specifications with dimensional data.  【step2】: Calculate engine volume (Length × Width × Height) for each model, sort results by volume in descending order.  【step3】: Limit output to top 3 records while retaining the Compression_Ratio from the engine table.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 242,
        "question": "Calculate the total surface area of cylinders for all V-type arrangement engines (assuming the cylinder is a cylinder, surface area = 2πr² + 2πrh), sort in ascending order by surface area and take the top five.",
        "query": "SELECT e.Model, (2 * PI() * POWER(e.Bore/2000, 2) + 2 * PI() * (e.Bore/2000) * (e.Stroke/1000)) * e.Cylinders * 2 AS TotalSurfaceArea FROM engine e WHERE e.Configuration LIKE 'V%%' ORDER BY TotalSurfaceArea ASC LIMIT 5;",
        "step": "【step1】: Filter engines with V-type configuration using WHERE clause on e.Configuration LIKE 'V%%'.  【step2】: Calculate total surface area per engine using cylindrical formula (2πr² + 2πrh), with Bore/2000 (radius in meters) and Stroke/1000 (height in meters), then multiply by Cylinders * 2 (assuming dual-bank arrangement in V-configuration).  【step3】: Sort results by TotalSurfaceArea in ascending order and apply LIMIT 5 to retrieve the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 243,
        "question": "Query the engine models with a weight exceeding 150 kilograms and a length less than 600 millimeters, sorted in descending order by the power-to-weight ratio.",
        "query": "SELECT e.Model, (e.Horsepower / e.Weight) AS PowerWeightRatio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > 150 AND ed.Length < 600 ORDER BY PowerWeightRatio DESC;",
        "step": "【step1】: Perform an INNER JOIN between `engine` and `enginedimensions` tables using `Engine_ID`, then apply filters `Weight > 150` (from engine) and `Length < 600` (from enginedimensions).  【step2】: Calculate the derived metric `PowerWeightRatio` by dividing `Horsepower` by `Weight` for qualifying engine models.  【step3】: Sort the results in descending order of `PowerWeightRatio` using the calculated alias in the ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 244,
        "question": "Assuming the cylinder spacing is expanded to 10,000 mm (far exceeding the actual value), calculate the virtual total volume (Length × Width × Height + 10000 × Cylinders) for all engines, and select the top two with the largest volumes.",
        "query": "SELECT e.Model, (ed.Length * ed.Width * ed.Height) + (10000 * e.Cylinders) AS VirtualVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY VirtualVolume DESC LIMIT 2;",
        "step": "【step1】: JOIN 'engine' and 'enginedimensions' tables using Engine_ID to combine engine specifications with dimensional data.  【step2】: Calculate VirtualVolume for each engine using formula (Length×Width×Height) + (10000×Cylinders).  【step3】: Sort results by VirtualVolume descending and select top 2 entries with LIMIT 2.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 245,
        "question": "Calculate the average volume (in cubic decimeters) of engines for each manufacturer and identify the manufacturer with the largest average volume.",
        "query": "SELECT e.Manufacturer, AVG((ed.Length/100) * (ed.Width/100) * (ed.Height/100)) AS AvgVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Manufacturer ORDER BY AvgVolume DESC LIMIT 1;",
        "step": "【step1】: Join the 'engine' and 'enginedimensions' tables via Engine_ID to link manufacturers with dimensional data.  【step2】: Calculate volume (converted to cubic decimeters using (Length*Width*Height)/1000000 via (Length/100)*(Width/100)*(Height/100)) for each engine, then compute average volume per manufacturer using GROUP BY.  【step3】: Sort manufacturers by AvgVolume in descending order and select the top result using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 246,
        "question": "Calculate the theoretical total length of inline engines, compare it with the actual Length, and output the 5 engines with the largest absolute differences, including the number of cylinders and the difference.",
        "query": "SELECT e.Cylinders, ABS(((e.Cylinders-1)*ed.Cylinder_Spacing + (e.Bore*e.Cylinders)) - ed.Length) AS DeltaL FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'Inline' ORDER BY DeltaL DESC LIMIT 5;",
        "step": "【step1】: Join engine and enginedimensions tables via Engine_ID, filter engines with 'Inline' configuration.  【step2】: Calculate theoretical length using formula ((Cylinders-1)*Cylinder_Spacing + Bore*Cylinders), compute absolute difference from actual Length as DeltaL.  【step3】: Order results by DeltaL descending, group by Cylinders, and limit to top 5 records with largest deviations.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 247,
        "question": "Identify engines whose weight exceeds the theoretical maximum volume assuming cast iron density (7.3 kg/dm³), and group and count the anomalies by manufacturer.",
        "query": "SELECT e.Manufacturer, COUNT(*) AS AnomalyCount FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > ((ed.Length/100)*(ed.Width/100)*(ed.Height/100))*7.3 GROUP BY e.Manufacturer;",
        "step": "【step1】: Join engine table with enginedimensions table on Engine_ID to establish dimensional relationships  【step2】: Calculate theoretical weight limit using (L/100 * W/100 * H/100)*7.3 (converting mm to dm³) and compare with actual Weight  【step3】: Filter engines exceeding theoretical weight, group by Manufacturer, and count anomalies per group",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 248,
        "question": "Assuming there exists an engine with cylinder spacing equal to the Earth's diameter, calculate the theoretical number of circumferences around the Earth's equator it could make, given the engine's bore, and output the result grouped by Engine_ID.",
        "query": "SELECT e.Engine_ID, ((10000-1)*12742000000 + e.Bore)/40075000000 AS Circles FROM engine e;",
        "step": "【step1】: Calculate theoretical engine length using (10000-1)*Earth diameter (12742000000 mm) + Bore for each engine.  【step2】: Divide the calculated length by Earth's equatorial circumference (40075000000 mm) to determine wrap circles.  【step3】: Group and output results by Engine_ID (implicit via primary key uniqueness, no explicit grouping needed).",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 249,
        "question": "Calculate the angular velocity of an engine at its maximum speed and filter out the engines whose angular velocity exceeds the material limit of the crankshaft.",
        "query": "SELECT e.Engine_ID, e.Model, (2 * PI() * ed.Max_turn) / 60 AS Angular_Velocity, em.Crankshaft_Material FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE ((2 * PI() * ed.Max_turn) / 60) > CASE WHEN em.Crankshaft_Material = 'Forged Steel' THEN 1000 WHEN em.Crankshaft_Material = 'Cast Iron' THEN 800 ELSE 500 END;",
        "step": "【step1】: Join engine, enginedynamics, and enginematerials tables through Engine_ID to combine core parameters  【step2】: Calculate angular velocity using formula (2π*max_turn)/60 in SELECT clause  【step3】: Apply CASE-based material threshold filtering in WHERE condition (Forged Steel:1000, Cast Iron:800, others:500)",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 250,
        "question": "Calculate the theoretical thermal efficiency of an engine at peak power speed, excluding models with a specific power output below 100 horsepower per liter.",
        "query": "SELECT e.Engine_ID, e.Model, (ep.BMEP * 1e5 * e.Displacement * ed.Peak_Power * 0.00001667) / (ep.Fuel_Consumption * 34.2e6) * 100 AS Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power >= 100;",
        "step": "【step1】: Join engine, enginedynamics, and engineperformance tables using Engine_ID to combine core parameters  【step2】: Filter records where Specific_Power ≥ 100 to exclude low power-to-displacement ratio engines  【step3】: Calculate thermal efficiency using formula: (BMEP × Displacement × Peak_Power × 0.001667) / (Fuel_Consumption × 34.2e6) × 100 at peak power RPM",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 251,
        "question": "Filter engines with a compression ratio exceeding 14:1 and using gasoline, as these engines may develop knocking issues.",
        "query": "SELECT Engine_ID, Model, Compression_Ratio, Fuel_Type FROM engine WHERE Compression_Ratio > 14 AND Fuel_Type = 'Gasoline';",
        "step": "【step1】: Select Engine_ID, Model, Compression_Ratio, and Fuel_Type columns from the engine table.  【step2】: Apply the filter condition Compression_Ratio > 14 to identify engines with high compression ratios.  【step3】: Further filter results by Fuel_Type = 'Gasoline' to isolate engines using standard gasoline.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 252,
        "question": "Find engines where the piston speed exceeds the material's threshold when the assumed rotation speed reaches 1,800,000,000 RPM (assuming piston material thresholds: aluminum 25 m/s, steel 30 m/s).",
        "query": "SELECT e.Engine_ID, e.Model, 2 * e.Stroke * (1800000000/60)/1000 AS Piston_Speed, em.Piston_Material FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE 2 * e.Stroke * (1800000000/60)/1000 > CASE WHEN em.Piston_Material = 'Aluminum' THEN 25 WHEN em.Piston_Material = 'Steel' THEN 30 ELSE 0 END;",
        "step": "【step1】: Join engine and enginematerials tables to associate engines with their piston material types  【step2】: Calculate piston speed using formula 2*Stroke*(crank_speed/60)/1000 (with assumed crank speed 1.8 billion RPM)  【step3】: Apply material-specific speed thresholds (Aluminum=25 m/s, Steel=30 m/s) using CASE statement in WHERE clause",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 253,
        "question": "Assuming the engine block materials are cast iron and aluminum alloy, which type of engine material and coating type combination has the highest average heat rejection rate?",
        "query": "SELECT m.Block_Material, m.Coating_Type, AVG(t.Heat_Rejection_Rate) AS Avg_Heat_Rejection_Rate FROM enginematerials m JOIN enginethermodynamics t ON m.Engine_ID = t.Engine_ID WHERE m.Block_Material IN ('Cast Iron', 'Aluminum') GROUP BY m.Block_Material, m.Coating_Type ORDER BY Avg_Heat_Rejection_Rate DESC;",
        "step": "【step1】: Filter engine materials to only include 'Cast Iron' or 'Aluminum' blocks, then JOIN with thermodynamics data using Engine_ID.  【step2】: Calculate average heat rejection rate for each group of Block_Material and Coating_Type.  【step3】: Sort results by Avg_Heat_Rejection_Rate in descending order to prioritize higher thermal rejection values.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 254,
        "question": "Count the number of different cylinder block materials in engines that use forged steel crankshafts and titanium connecting rods, and calculate their percentage of the total. Group by cylinder block material and connecting rod material.",
        "query": "WITH Total AS ( SELECT COUNT(*) AS TotalCount FROM enginematerials WHERE Crankshaft_Material = 'Forged Steel' AND Connecting_Rod_Material = 'Titanium' ) SELECT m.Block_Material, m.Connecting_Rod_Material, COUNT(*) AS Count, ROUND((COUNT(*) * 100.0 / (SELECT TotalCount FROM Total)), 2) AS Percentage FROM enginematerials m WHERE m.Crankshaft_Material = 'Forged Steel' AND m.Connecting_Rod_Material = 'Titanium' GROUP BY m.Block_Material, m.Connecting_Rod_Material;",
        "step": "【step1】: Calculate total number of engines meeting the condition using CTE: Filter records where Crankshaft_Material='Forged Steel' and Connecting_Rod_Material='Titanium', then COUNT(*) to get TotalCount.  【step2】: Group qualified records by Block_Material and Connecting_Rod_Material: Apply same material filters, then perform GROUP BY with COUNT(*) for each group.  【step3】: Calculate percentage using scalar subquery: Divide each group's count by pre-calculated TotalCount from CTE, multiply by 100 and round to 2 decimal places.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 255,
        "question": "Identify which engines use both cast iron cylinder blocks and aluminum alloy pistons, and group and count the quantities by compression ratio ranges.",
        "query": "SELECT CASE WHEN e.Compression_Ratio < 10 THEN 'Low (<10)' WHEN e.Compression_Ratio BETWEEN 10 AND 12 THEN 'Medium (10-12)' WHEN e.Compression_Ratio > 12 THEN 'High (>12)' END AS Compression_Ratio_Range, COUNT(*) AS Engine_Count FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND m.Piston_Material IN ('Aluminum', 'Forged Aluminum') GROUP BY Compression_Ratio_Range ORDER BY MIN(e.Compression_Ratio);",
        "step": "【step1】: Filter engines with Cast Iron block and Aluminum-based pistons using JOIN between engine and enginematerials tables, applying WHERE conditions for Block_Material = 'Cast Iron' AND Piston_Material IN ('Aluminum', 'Forged Aluminum').  【step2】: Categorize remaining engines into compression ratio ranges using CASE expression to create Compression_Ratio_Range groups (Low/Medium/High).  【step3】: Perform COUNT aggregation grouped by compression ranges and order results by MIN(Compression_Ratio) to maintain natural numerical sequence of range thresholds.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 256,
        "question": "Assuming the piston material of all engines is changed to a fictional ultra-heavy alloy with a density of 10,000 kg/m³, calculate the theoretical total weight of the pistons grouped by the number of cylinders (assuming a constant piston volume of 500 cm³).",
        "query": "SELECT Cylinders, SUM(10000 * 0.0005 * Cylinders) AS Total_Piston_Weight FROM engine GROUP BY Cylinders ORDER BY Cylinders;",
        "step": "【step1】: Calculate individual piston weight per engine: 10000 kg/m³ density * 0.0005 m³ (converted from 500 cm³) = 5 kg per piston  【step2】: Multiply by cylinder count per engine (5 * Cylinders) and aggregate by cylinders using SUM() with GROUP BY  【step3】: Sort results numerically using ORDER BY Cylinders",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 257,
        "question": "In the engine materials table, assuming that the cylinder block material of an engine is cast iron (Cast Iron) and the cylinder head material is aluminum alloy (Aluminum), with the thermal conductivity of cast iron known to be 80 W/m·K and that of aluminum alloy being 205 W/m·K. If the contact area between the cylinder block and cylinder head during engine operation is 0.5 square meters, with a temperature difference of 200°C, and the thickness is 0.01 meters, calculate the heat flow rate through the contact surface (in watts).",
        "query": "SELECT (2*(80*205)/(80+205)) * 0.5 * 200 / 0.01 AS Heat_Flow FROM enginematerials WHERE Block_Material = 'Cast Iron' AND Head_Material = 'Aluminum';",
        "step": "【step1】: Filter the enginematerials table to find entries where Block_Material is 'Cast Iron' and Head_Material is 'Aluminum'.  【step2】: Calculate the harmonic mean of thermal conductivities: (2 × 80 × 205) / (80 + 205).  【step3】: Multiply the harmonic mean by contact area (0.5), temperature difference (200), and divide by thickness (0.01) to compute Heat_Flow.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 258,
        "question": "The piston of a certain engine is made of forged aluminum alloy (density 2.7 g/cm³), and the connecting rod is made of titanium alloy (density 4.5 g/cm³). If the piston volume is 0.002 cubic meters and the connecting rod volume is 0.001 cubic meters, calculate the total mass of both (in kilograms). Does this meet the requirement if the total mass must not exceed 5 kilograms?",
        "query": "SELECT (0.002*2700 + 0.001*4500) AS Total_Mass, CASE WHEN (0.002*2700 + 0.001*4500) <= 5 THEN 'Satisfaction' ELSE 'Unsatisfied' END AS 质量判定 FROM enginematerials WHERE Piston_Material = 'Forged Aluminum' AND Connecting_Rod_Material = 'Titanium';",
        "step": "【step1】: Calculate total mass by converting volumes to kg: (0.002m³ * 2700kg/m³) + (0.001m³ * 4500kg/m³)  【step2】: Apply conditional logic with CASE to check if total ≤5kg  【step3】: Filter records in enginematerials table where Piston_Material = 'Forged Aluminum' AND Connecting_Rod_Material = 'Titanium'",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 259,
        "question": "Why do engines with a compression ratio of at least 12:1 that use aluminum for cylinder heads and have a thermal conductivity greater than 150 require the use of aluminum alloy for cylinder heads instead of cast iron?",
        "query": "SELECT e.Model, e.Compression_Ratio, em.Head_Material, et.Thermal_Conductivity FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Compression_Ratio >= 12 AND em.Head_Material = 'Aluminum' AND et.Thermal_Conductivity > 150;",
        "step": "【step1】: Filter engines with compression ratio ≥12:1 and join materials table to identify aluminum cylinder heads  【step2】: Join thermodynamics table to validate thermal conductivity >150 W/m·K  【step3】: Combine conditions to show models meeting both material and thermal requirements for high compression operation",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 260,
        "question": "If the thermal expansion coefficient of a certain crankshaft material is set to 1×10^-4 /°C (far exceeding the 1.2×10^-5 /°C for real steel), and the engine operating temperature rises from 20°C to 1000°C. Assuming the original length of the crankshaft is 500 millimeters, calculate the expanded length and determine whether the main bearing bore can fit the expanded crankshaft.",
        "query": "SELECT ed.Main_Bore_Diameter, 500*(1+0.0001*(1000-20)) AS 膨胀后长度, CASE WHEN 500*(1+0.0001*980) <= ed.Main_Bore_Diameter THEN '可配合' ELSE '不可配合' END AS 配合判定 FROM enginedimensions ed JOIN enginematerials em ON ed.Engine_ID = em.Engine_ID WHERE em.Crankshaft_Material = 'Forged Steel';",
        "step": "【step1】: Perform INNER JOIN between enginedimensions (aliased as ed) and enginematerials (aliased as em) using Engine_ID, filtering records where Crankshaft_Material is 'Forged Steel'.  【step2】: Calculate expanded length using formula: 500*(1+0.0001*(1000-20)), representing thermal expansion with given coefficient (ΔT=980°C).  【step3】: Execute CASE statement to compare expanded length against Main_Bore_Diameter, returning '可配合' if within tolerance or '不可配合' if exceeding dimensions.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 261,
        "question": "Calculate the angular velocity of each engine and identify the top three engine models with the highest angular velocity, sorted in descending order.",
        "query": "SELECT e.Model, ed.Angular_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID ORDER BY ed.Angular_Velocity DESC LIMIT 3;",
        "step": "【step1】: JOIN engine and enginedynamics tables using Engine_ID to link model and angular velocity  【step2】: Order results by Angular_Velocity in descending sequence  【step3】: Restrict output to top 3 records with LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 262,
        "question": "Calculate the instantaneous speed of each engine piston at maximum RPM, identify the top 5 fastest engines, and sort them in descending order. Verify data consistency between calculated piston speed and Mean_Piston_Speed.",
        "query": "SELECT e.Model, (2 * e.Stroke/1000 * ed.Max_turn)/60 AS Calculated_Speed, ed.Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE ABS(((2 * e.Stroke/1000 * ed.Max_turn)/60 - ed.Mean_Piston_Speed)/ed.Mean_Piston_Speed) <= 0.02 ORDER BY Calculated_Speed DESC LIMIT 5;",
        "step": "【step1】: Join engine and enginedynamics tables to calculate instantaneous piston speed (2*Stroke/1000*Max_turn/60) and validate data consistency between the calculated value and Mean_Piston_Speed.  【step2】: Filter results where the relative difference between calculated speed and Mean_Piston_Speed is ≤2% using absolute error tolerance.  【step3】: Sort filtered engines by calculated speed descending, retain top5 entries, and output them in ascending order via reverse sorting.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 263,
        "question": "Find all diesel engine models with peak torque below 2000, sorted alphabetically by manufacturer.",
        "query": "SELECT e.Manufacturer, e.Model, ed.Peak_Torque FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Fuel_Type = 'Diesel' AND ed.Peak_Torque < 2000 ORDER BY e.Manufacturer ASC;",
        "step": "【step1】: Join 'engine' and 'enginedynamics' tables using Engine_ID to combine manufacturer data with torque performance metrics.  【step2】: Filter records where Fuel_Type is 'Diesel' and Peak_Torque < 2000 RPM using conditional clauses.  【step3】: Sort the final results alphabetically by Manufacturer using ORDER BY ASC.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 264,
        "question": "Assuming the existence of a rotary engine with a rotational speed of 100,000 RPM, calculate whether its piston speed exceeds 250 m/s, and list all hypothetical model variants where the calculated results exceed 250 m/s.",
        "query": "SELECT e.Model, (2 * e.Stroke/1000 * 100000)/60 AS Hypothetical_Speed FROM engine e WHERE e.Configuration = 'Rotary' AND (2 * e.Stroke/1000 * 100000)/60 > 250 ORDER BY Hypothetical_Speed DESC;",
        "step": "【step1】: Filter all rotary configuration engines from the 'engine' table using WHERE e.Configuration = 'Rotary'  【step2】: Calculate hypothetical piston speed (2*Stroke/1000*100000)/60 for each qualifying engine and filter results exceeding 250 m/s through the WHERE clause calculation  【step3】: Sort remaining records by descending Hypothetical_Speed and project Model with calculated speed using ORDER BY ... DESC and SELECT clause",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 265,
        "question": "Calculate the ratio of the engine's effective work to the input fuel heating value, and list the top 3 engine models with the highest thermal efficiency along with their respective thermal efficiency values and effective work ratios.",
        "query": "SELECT e.Model, ep.Thermal_Efficiency, (ep.Thermal_Efficiency / 100) AS Effective_Work_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID ORDER BY ep.Thermal_Efficiency DESC LIMIT 3;",
        "step": "【step1】: JOIN engine and engineperformance tables using Engine_ID to combine engine model and thermal efficiency data.  【step2】: Calculate Effective_Work_Ratio by converting Thermal_Efficiency percentage to decimal (dividing by 100).  【step3】: Sort results by Thermal_Efficiency in descending order and limit output to the top 3 records.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 266,
        "question": "Calculate the BMEP (Brake Mean Effective Pressure) for each engine and sort in descending order, where BMEP = (2×π×Torque×Cylinders) / (Displacement×1000). The output should include engine models and their BMEP values where BMEP exceeds 15 Bar.",
        "query": "SELECT e.Model, (2 * PI() * e.Torque * e.Cylinders) / (e.Displacement * 1000) AS BMEP FROM engine e WHERE (2 * PI() * e.Torque * e.Cylinders) / (e.Displacement * 1000) > 15 ORDER BY BMEP DESC;",
        "step": "【step1】: Select engine models and calculate BMEP using the formula (2*π*Torque*Cylinders)/(Displacement*1000) from the engine table.  【step2】: Filter results where the calculated BMEP exceeds 15 Bar.  【step3】: Sort the filtered results in descending order of BMEP values.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 267,
        "question": "Find engine models and their displacement and fuel consumption where the fuel consumption is lower than the average fuel consumption for engines with the same displacement, sorted in ascending order of displacement.",
        "query": "WITH displacement_avg AS (SELECT Displacement, AVG(Fuel_Consumption) AS avg_fuel FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY Displacement) SELECT e.Model, e.Displacement, ep.Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID JOIN displacement_avg da ON e.Displacement = da.Displacement WHERE ep.Fuel_Consumption < da.avg_fuel ORDER BY e.Displacement ASC;",
        "step": "【step1】: Calculate average fuel consumption per displacement using a CTE by joining engine and engineperformance tables, grouping results by Displacement.  【step2】: Join engine and engineperformance tables with the CTE to filter engines where actual fuel consumption is below their displacement group's average.  【step3】: Sort results by Displacement in ascending order to show engines with fuel efficiency anomalies relative to their displacement size.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 268,
        "question": "Assuming an engine's power-to-weight ratio (Power_To_Weight_Ratio) reaches 1000 horsepower per kilogram (far exceeding practical physical limits), its weight must approach zero. Please list all engine models where the Weight field is 0 and Power_To_Weight_Ratio > 500, sorted in ascending order by weight.",
        "query": "SELECT e.Model, e.Weight, ep.Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Weight = 0 AND ep.Power_To_Weight_Ratio > 500 ORDER BY e.Weight ASC;",
        "step": "",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 269,
        "question": "Identify engines in the `engineperformance` table where the BMEP exceeds 15 Bar and the thermal efficiency is below 30%.",
        "query": "SELECT Engine_ID FROM engineperformance WHERE BMEP > 15 AND Thermal_Efficiency < 30;",
        "step": "【step1】: Select Engine_ID from the engineperformance table  【step2】: Apply filter condition BMEP > 15  【step3】: Further filter results with Thermal_Efficiency < 30",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 270,
        "question": "Calculate the composite metric of power-to-weight ratio and specific power: (Power_To_Weight_Ratio × 1000) / Specific_Power, where the value must be greater than or equal to the square root of displacement (Displacement), and exclude electric engines (Fuel_Type='Electric').",
        "query": "SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE (ep.Power_To_Weight_Ratio * 1000) / ep.Specific_Power >= SQRT(e.Displacement) AND e.Fuel_Type != 'Electric';",
        "step": "【step1】: Perform INNER JOIN between engine and engineperformance tables using Engine_ID to combine engine specifications with performance metrics.  【step2】: Apply filtering conditions: exclude electric engines (Fuel_Type != 'Electric') and enforce (Power_To_Weight_Ratio * 1000 / Specific_Power) ≥ SQRT(Displacement).  【step3】: Select Engine_ID from the filtered results to output qualifying engine identifiers.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 271,
        "question": "Find gasoline engines with a fuel consumption rate lower than the industry benchmark value for engines of the same displacement (benchmark formula: 6 + 0.5 × Displacement) and a thermal efficiency higher than 35%.",
        "query": "SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type = 'Gasoline' AND ep.Fuel_Consumption < (6 + 0.5 * e.Displacement) AND ep.Thermal_Efficiency > 35;",
        "step": "【step1】: Join the 'engine' and 'engineperformance' tables using Engine_ID to access both displacement and performance metrics.  【step2】: Filter engines where Fuel_Type = 'Gasoline' to isolate gasoline-powered engines.  【step3】: Apply dual conditions: calculate the displacement-based benchmark (6 + 0.5 * Displacement) to compare with Fuel_Consumption, and require Thermal_Efficiency > 35%.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 272,
        "question": "Assume there exists an engine with a thermal efficiency exceeding 88%, and a specific torque reaching 10^6 N·m/L, please verify whether these engines also simultaneously meet BMEP exceeding 1000 Bar.",
        "query": "SELECT Engine_ID FROM engineperformance WHERE Thermal_Efficiency > 88 AND Specific_Torque >= 1000000 AND BMEP > 1000;",
        "step": "【step1】: Calculate the thermal efficiency threshold using the Carnot formula: η_limit = 1 - T_cold/T_hot = 1 - 300/2500 = 88%.  【step2】: Filter engines in engineperformance where Thermal_Efficiency > 88% (exceeding Carnot limit), Specific_Torque ≥ 1000000 N·m/L.  【step3】: Verify if the filtered engines from step 2 also have BMEP > 1000 Bar through the final AND condition in the WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 273,
        "question": "Calculate the average Brake Mean Effective Pressure (BMEP) and average thermal efficiency for different fuel types (Fuel_Type), grouped by fuel type.",
        "query": "SELECT e.Fuel_Type, AVG((2 * PI() * e.Torque) / (e.Displacement * 100000)) AS Avg_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Fuel_Type;",
        "step": "",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 274,
        "question": "Statistics on the weighted geometric mean of engine specific power (Specific_Power) and specific torque (Specific_Torque) by manufacturer (Manufacturer), grouped by manufacturer and sorted by the weighted geometric mean in descending order.",
        "query": "SELECT e.Manufacturer, EXP(SUM(e.Displacement * LN(ep.Specific_Power * ep.Specific_Torque)) / SUM(e.Displacement)) AS Weighted_Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power > 0 AND ep.Specific_Torque > 0 GROUP BY e.Manufacturer ORDER BY Weighted_Geometric_Mean DESC;",
        "step": "【step1】: Join the 'engine' and 'engineperformance' tables via Engine_ID, filtering entries where both Specific_Power and Specific_Torque are positive.  【step2】: Calculate the weighted geometric mean using displacement as weights via EXP(SUM(Displacement * LN(Specific_Power * Specific_Torque)) / SUM(Displacement)) grouped by Manufacturer.  【step3】: Sort results by the calculated weighted geometric mean in descending order per manufacturer group.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 275,
        "question": "Analyze the impact of the number of cylinders (Cylinders) on fuel consumption rate (Fuel_Consumption) and thermal efficiency (Thermal_Efficiency), and output the average fuel consumption rate and average thermal efficiency grouped by the number of cylinders.",
        "query": "SELECT e.Cylinders, AVG(ep.Fuel_Consumption) AS Avg_Fuel_Consumption, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Cylinders ORDER BY e.Cylinders;",
        "step": "【step1】: Join the 'engine' and 'engineperformance' tables using the shared 'Engine_ID' to combine cylinder data with performance metrics.  【step2】: Group the results by 'Cylinders' and calculate the average values for both 'Fuel_Consumption' and 'Thermal_Efficiency' using the AVG() function.  【step3】: Sort the grouped results in ascending order based on 'Cylinders' to provide a structured output.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 276,
        "question": "Assuming there are engines with a fuel consumption rate less than 0 or greater than 500 liters/100 km, group statistics by fuel type (Fuel_Type) to analyze the average power-to-weight ratio (Power_To_Weight_Ratio) for these outliers.",
        "query": "SELECT e.Fuel_Type, COUNT(*) AS Anomaly_Count, AVG(ep.Power_To_Weight_Ratio) AS Avg_Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Fuel_Consumption < 0 OR ep.Fuel_Consumption > 500 GROUP BY e.Fuel_Type;",
        "step": "【step1】: Join the 'engine' and 'engineperformance' tables using Engine_ID to link engine metadata with performance metrics.  【step2】: Filter records where Fuel_Consumption is < 0 or > 500 liters/100km to isolate anomalies.  【step3】: Group results by Fuel_Type, then calculate the count of anomalies and average Power_To_Weight_Ratio per group.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 277,
        "question": "Calculate the thermal efficiency of engines with different fuel types and analyze its relationship with displacement and horsepower, grouped by fuel type.",
        "query": "SELECT e.Fuel_Type, AVG((e.Horsepower * 0.7457 * 1000) / (ep.Fuel_Consumption * CASE WHEN e.Fuel_Type = 'Gasoline' THEN 34.2 WHEN e.Fuel_Type = 'Diesel' THEN 38.6 ELSE 0 END * 100) * 100) AS Thermal_Efficiency, AVG(e.Displacement) AS Avg_Displacement, AVG(e.Horsepower) AS Avg_Horsepower FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Gasoline', 'Diesel') GROUP BY e.Fuel_Type;",
        "step": "【step1】: Join engine table with engineperformance table using Engine_ID, filter records where Fuel_Type is Gasoline or Diesel.  【step2】: Calculate thermal efficiency using formula: (Horsepower converted to watts) / (Fuel_Consumption * fuel-specific energy density) * 100. Use CASE statement to apply energy density values (34.2 MJ/L for Gasoline, 38.6 MJ/L for Diesel).  【step3】: Group results by Fuel_Type and compute average values for Thermal_Efficiency, Displacement, and Horsepower using AVG() aggregation.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 278,
        "question": "Calculate the average percentage error between the actual displacement and the theoretical displacement (calculated from Bore, Stroke, and Cylinders), grouped by the number of cylinders.",
        "query": "SELECT Cylinders, AVG(ABS(Displacement - (PI()/4 * POWER(Bore/10,2) * Stroke/10 * Cylinders / 1000)) / Displacement * 100) AS Error_Percentage FROM engine GROUP BY Cylinders;",
        "step": "【step1】: Calculate theoretical displacement for each engine using (π/4) * (Bore/10)^2 * (Stroke/10) * Cylinders / 1000 formula, converting mm to cm.  【step2】: Compute absolute percentage error between actual Displacement and theoretical displacement via (ABS(Displacement - [step1 result])/Displacement)*100.  【step3】: Group results by Cylinders and calculate average error percentage with AVG() function.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 279,
        "question": "Calculate the average length and width of engines for each cylinder configuration (Configuration).",
        "query": "SELECT e.Configuration, AVG(d.Length) AS Avg_Length, AVG(d.Width) AS Avg_Width FROM engine e JOIN enginedimensions d ON e.Engine_ID = d.Engine_ID GROUP BY e.Configuration;",
        "step": "【step1】: JOIN engine and enginedimensions tables using Engine_ID to combine configuration data with dimensional measurements.  【step2】: GROUP the joined dataset by Configuration to organize engine records by their cylinder arrangement types.  【step3】: CALCULATE average length (AVG(d.Length)) and average width (AVG(d.Width)) for each group to analyze dimensional variations across configurations.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 280,
        "question": "Assuming the engine's redline speed (Redline) is 1,000,000 RPM, and the stroke is 1000 mm, calculate the Mach number (based on mean piston speed), grouped by cylinder arrangement.",
        "query": "SELECT Configuration, (2 * 1000 * 1000000 / 60 / 1000) / 343 AS Mach_Number FROM engine GROUP BY Configuration;",
        "step": "【step1】: Retrieve all rows from the 'engine' table and project the 'Configuration' column.  【step2】: Calculate the constant Mach_Number for every row using the formula (2 * 1000 * 1,000,000 / 60 / 1000) / 343 (fixed parameters, no dynamic field references).  【step3】: Group results by the 'Configuration' column and output one row per unique configuration with the calculated Mach_Number (identical for all groups due to hardcoded values).",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 281,
        "question": "Please find all engines that use cast iron (Cast Iron) as the block material but have a thermal efficiency (Thermal_Efficiency) higher than 35%, and return their engine ID, model, block material, and thermal efficiency.",
        "query": "SELECT e.Engine_ID, e.Model, m.Block_Material, p.Thermal_Efficiency FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND p.Thermal_Efficiency > 35;",
        "step": "【step1】: Join 'engine' table with 'enginematerials' on Engine_ID to filter engines where Block_Material is 'Cast Iron'.  【step2】: Join the result with 'engineperformance' on Engine_ID to apply Thermal_Efficiency > 35% condition.  【step3】: Select Engine_ID, Model, Block_Material, and Thermal_Efficiency from the combined dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 282,
        "question": "Please verify whether there is a positive correlation between the BMEP of a turbocharged engine and its peak torque, and return the engines where BMEP is less than a calculated value based on peak torque and displacement.",
        "query": "SELECT e.Engine_ID, e.Model, d.Peak_Torque, p.BMEP FROM engine e JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND p.BMEP < (d.Peak_Torque / e.Displacement) * 0.12;",
        "step": "【step1】: Filter turbocharged engines from the 'engine' table using WHERE e.Aspiration = 'Turbocharged'.  【step2】: Join filtered engines with 'enginedynamics' (d) and 'engineperformance' (p) tables via Engine_ID to combine BMEP/Peak_Torque/Displacement data.  【step3】: Calculate (d.Peak_Torque / e.Displacement) * 0.12 as the BMEP threshold and select engines where p.BMEP < this threshold to identify non-compliant entries.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 283,
        "question": "Please find engines with a length greater than 1000 millimeters and a piston speed exceeding 25 meters per second, and return their engine ID, model, length, and piston speed.",
        "query": "SELECT e.Engine_ID, e.Model, ed.Length, d.Piston_Speed FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID WHERE ed.Length > 1000 AND d.Piston_Speed > 25;",
        "step": "【step1】: Perform INNER JOIN between engine and enginedimensions on Engine_ID, filter records where Length > 1000mm  【step2】: INNER JOIN result with enginedynamics on Engine_ID, apply Piston_Speed > 25m/s filter  【step3】: Project final columns (Engine_ID, Model, Length, Piston_Speed) from the combined dataset",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 284,
        "question": "Please verify if the displacement of all electric (Electric) engines is 0, and return the engine IDs and models of those with non-zero displacement.",
        "query": "SELECT Engine_ID, Model, Displacement FROM engine WHERE Fuel_Type = 'Electric' AND Displacement != 0;",
        "step": "【step1】: Filter all engines where Fuel_Type is 'Electric' from the engine table.  【step2】: Apply the condition Displacement != 0 to the filtered electric engines.  【step3】: Select and return the Engine_ID, Model, and Displacement columns for the mismatched records.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 285,
        "question": "Based on the Main_Bore_Diameter and Rod_Journal_Diameter in the enginedimensions table, calculate the stress on the main bearing for engines with a cast iron block and identify those where the stress exceeds 200.",
        "query": "SELECT ed.Engine_ID, PI() * (Main_Bore_Diameter/2) * (Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2) * (Rod_Journal_Diameter/2) AS Bearing_Area, (1.5 * edyn.Angular_Velocity * edyn.Angular_Velocity * (ed.Weight/1000) * (Rod_Journal_Diameter/2000)) / (PI() * (Main_Bore_Diameter/2)*(Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2)*(Rod_Journal_Diameter/2)) AS Stress FROM enginedimensions ed JOIN enginedynamics edyn USING(Engine_ID) JOIN enginematerials em USING(Engine_ID) WHERE em.Block_Material = 'Cast Iron' HAVING Stress > 200;",
        "step": "【step1】: Join enginedimensions, enginedynamics, enginematerials tables via Engine_ID and filter engines with Block_Material = 'Cast Iron'  【step2】: Calculate Bearing_Area (π(Main_Bore_Diameter²/4 - Rod_Journal_Diameter²/4)) and compute Stress using (1.5 × Angular_Velocity² × Weight × Rod_Journal_Diameter) / (Bearing_Area × 1e6)  【step3】: Filter results with HAVING clause to retain records where Stress exceeds 200 MPa requirement",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 286,
        "question": "Given the Bore=84mm, Stroke=90mm, and Cylinder_Spacing=120mm in the enginedimensions table, calculate the total length of an inline 6-cylinder engine and compare it to Length=800mm, taking into account an allowance of 20mm on each end of the engine block.",
        "query": "SELECT ed.Engine_ID, (Cylinder_Spacing*(6-1) + 2*20 + 6*Bore) AS Calculated_Length, Length, ABS((Cylinder_Spacing*5 + 40 + 504) - Length) AS Length_Deviation FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE e.Cylinders = 6 AND e.Configuration = 'Inline';",
        "step": "【step1】: Perform INNER JOIN between 'engine' and 'enginedimensions' tables using Engine_ID to combine cylinder configuration parameters with dimensional data.  【step2】: Apply WHERE filter to select only inline 6-cylinder engines (Cylinders=6 AND Configuration='Inline').  【step3】: Calculate theoretical engine length using formula: (Cylinder_Spacing×5) + 2×20 + 6×Bore, then compare with stored Length and compute absolute deviation.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 287,
        "question": "For an engine with Cylinder_Spacing=50mm and Width=600mm, can it be determined whether there are safety hazards in its cylinder arrangement? It is known that industry standards require the spacing between adjacent cylinders to be at least 1.2 times the cylinder bore diameter, and the safety status is determined by comparing the actual cylinder spacing to the minimum safe spacing.",
        "query": "SELECT ed.Engine_ID, Cylinder_Spacing, Bore, ROUND(1.2*Bore,1) AS Min_Safe_Spacing, CASE WHEN Cylinder_Spacing < 1.2*Bore THEN 'Danger' ELSE 'Safety' END AS Safety_Status FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE Cylinder_Spacing = 50 AND Width = 600;",
        "step": "【step1】: Perform INNER JOIN between engine and enginedimensions tables using Engine_ID to combine dimensional parameters with core engine specifications  【step2】: Calculate required safety parameters by processing Bore data (1.2×Bore) and comparing with actual Cylinder_Spacing using conditional logic in SELECT clause  【step3】: Apply filtration for specific dimensional criteria (Cylinder_Spacing=50 AND Width=600) and finalize safety status determination through CASE expression",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 288,
        "question": "Suppose there is an engine with a weight Weight=99999kg and a Power_To_Weight_Ratio=0.0001 horsepower/kg. Does this engine appear in the result of the given query?",
        "query": "SELECT Engine_ID FROM enginedimensions WHERE Weight > 10000 AND Engine_ID NOT IN (SELECT Engine_ID FROM engineperformance WHERE Power_To_Weight_Ratio < 0.001);",
        "step": "【step1】: Retrieve all Engine_IDs from enginedimensions where Weight exceeds 10000kg.  【step2】: Subquery to select Engine_IDs from engineperformance with Power_To_Weight_Ratio below 0.001.  【step3】: Use NOT IN operator to exclude Engine_IDs found in step2 from step1, identifying anomalies in enginedimensions not reflected in engineperformance.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 289,
        "question": "Find the engine models that use titanium valves and have cylinder heads made of cast iron, then calculate the theoretical heat transfer rate (in watts) between the cylinder head and the valve based on the material's thermal conductivity, and list the top 3 in descending order of heat transfer rate.",
        "query": "SELECT e.Model, (80 * 21.9 * 0.01 * 600) / (80 * 0.005 + 21.9 * 0.010) AS Q FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginethermodynamics t USING(Engine_ID) WHERE m.Valve_Material = 'Titanium' AND m.Head_Material = 'Cast Iron' ORDER BY Q DESC LIMIT 3;",
        "step": "【step1】: Join engine, enginematerials, and enginethermodynamics tables using Engine_ID, filter records where Valve_Material is 'Titanium' and Head_Material is 'Cast Iron'.  【step2】: Apply thermal conduction formula Q=(k1*k2*A*ΔT)/(k1*L2 + k2*L1) using fixed material parameters (80 W/m·K for cast iron, 21.9 W/m·K for titanium) with assumed dimensions (A=0.01m², L1=0.005m, L2=0.010m, ΔT=600K).  【step3】: Sort results by calculated Q in descending order and retain top 3 entries using ORDER BY Q DESC LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 290,
        "question": "Calculate the piston inertial force (in Newtons) for all engines using aluminum pistons with connecting rods made of steel, then list the top 5 results sorted by inertial force in ascending order.",
        "query": "SELECT e.Engine_ID, 2700 * PI() * POWER(e.Bore/2000,2) * e.Stroke/1000 * POWER(d.Angular_Velocity,2) * (e.Stroke/2000) * (1 + 1/(2*1.5)) AS F FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginedynamics d USING(Engine_ID) WHERE m.Piston_Material = 'Aluminum' AND m.Connecting_Rod_Material = 'Steel' ORDER BY F ASC LIMIT 5;",
        "step": "【step1】: Join engine, enginematerials, and enginedynamics tables using Engine_ID  【step2】: Filter engines with Aluminum pistons and Steel connecting rods  【step3】: Calculate inertia force using formula, sort ascending, limit to top 5",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 291,
        "question": "List the top 3 gasoline engine models that use cast iron cylinder blocks and have a compression ratio greater than 10:1, sorted in descending order by specific power (horsepower per liter).",
        "query": "SELECT e.Model, p.Specific_Power FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN engineperformance p USING(Engine_ID) WHERE m.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Gasoline' AND e.Compression_Ratio > 10 ORDER BY p.Specific_Power DESC LIMIT 3;",
        "step": "【step1】: Join engine, enginematerials, and engineperformance tables using Engine_ID to combine material and performance data  【step2】: Filter for Cast Iron blocks, Gasoline fuel type, and Compression_Ratio > 10  【step3】: Sort results by Specific_Power (power-to-displacement ratio) in descending order and limit to top 3 entries",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 292,
        "question": "Assuming there exists a W-type 24-cylinder engine with a bore diameter of 5000 mm and a stroke of 3000 mm, and the crankshaft material is ceramic (assuming an elastic modulus of 300 GPa), find the natural frequency (Hz) of the crankshaft's torsional vibration, ordered by ascending frequency.",
        "query": "SELECT e.Engine_ID, (1/(2*PI())) * SQRT( (300e9/(2*(1+0.3)) * PI()*POWER(ed.Rod_Journal_Diameter/1000,4)/32) / (ed.Length/1000 * (e.Weight * POWER(ed.Rod_Journal_Diameter/2000,2)/4)) ) AS f FROM engine e JOIN enginedimensions ed USING(Engine_ID) WHERE e.Configuration = 'W' AND e.Cylinders = 24 AND e.Bore = 5000 AND e.Stroke = 3000 ORDER BY f ASC;",
        "step": "【step1】:Join engine and enginedimensions tables using Engine_ID to access geometric parameters (Rod_Journal_Diameter, Length) and engine specifications (Weight).  【step2】:Filter records with Configuration='W', Cylinders=24, Bore=5000, Stroke=3000 to isolate the target engine configuration.  【step3】:Calculate torsional natural frequency via formula:  - Shear modulus: 300e9/(2*(1+0.3))  - Polar moment (J): π*(Rod_Journal_Diameter/1000)^4/32  - Torsional stiffness (GJ/L): (Shear modulus * J)/(Length/1000)  - Mass moment (I): Weight * (Rod_Journal_Diameter/2000)^2 /4  - Frequency: (1/(2π)) * SQRT(Torsional_stiffness / Mass_moment)",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 293,
        "question": "Based on the engine and enginethermodynamics tables, calculate the ratio of combustion efficiency to heat rejection rate for each engine, and list the top 5 models with the highest ratio among engines with a displacement greater than 2.0 liters.",
        "query": "SELECT e.Model, (et.Combustion_Efficiency / et.Heat_Rejection_Rate) AS Ratio FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Displacement > 2.0 ORDER BY Ratio DESC LIMIT 5;",
        "step": "【step1】: Join 'engine' and 'enginethermodynamics' tables using Engine_ID to link combustion/thermal data with engine specifications.  【step2】: Apply WHERE filter to select engines with Displacement > 2.0 liters.  【step3】: Calculate efficiency-to-rejection ratio (Combustion_Efficiency/Heat_Rejection_Rate), sort results in descending order by Ratio, and return the top 5 Model entries.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 294,
        "question": "Combining the enginethermodynamics, enginematerials, enginedimensions, and engine tables, calculate the total heat transfer Q_total using the formula (thermal conductivity multiplied by the temperature difference between exhaust gas and coolant, divided by cylinder spacing, plus specific heat capacity multiplied by oil temperature), then list the top 3 engine models ranked in descending order of Q_total.",
        "query": "SELECT e.Model, (et.Thermal_Conductivity * (et.Exhaust_Gas_Temperature - et.Coolant_Temperature) / ed.Cylinder_Spacing + et.Specific_Heat_Capacity * et.Oil_Temperature) AS Q_total FROM enginethermodynamics et INNER JOIN enginematerials em ON et.Engine_ID = em.Engine_ID INNER JOIN enginedimensions ed ON et.Engine_ID = ed.Engine_ID INNER JOIN engine e ON et.Engine_ID = e.Engine_ID ORDER BY Q_total DESC LIMIT 3;",
        "step": "【step1】: Perform four-way JOIN between enginethermodynamics, enginematerials, enginedimensions, and engine tables using Engine_ID as the key relationship.【step2】: Calculate Q_total using formula (Thermal_Conductivity × (Exhaust_Gas_Temperature - Coolant_Temperature) / Cylinder_Spacing) + (Specific_Heat_Capacity × Oil_Temperature) for each engine model.【step3】: Sort results by Q_total in DESC order and select top 3 models using LIMIT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 295,
        "question": "List the engine models where the coolant temperature (Coolant_Temperature) exceeds 100°C and the fuel type is gasoline (Gasoline), sorted in ascending order by displacement.",
        "query": "SELECT e.Model FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 100 AND e.Fuel_Type = 'Gasoline' ORDER BY e.Displacement ASC;",
        "step": "【step1】: JOIN engine and enginethermodynamics tables using Engine_ID as the relation  【step2】: Apply WHERE conditions Coolant_Temperature > 100 AND Fuel_Type = 'Gasoline'  【step3】: Sort results by Displacement in ascending ORDER",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 296,
        "question": "Assuming the exhaust gas temperature (Exhaust_Gas_Temperature) of an engine reaches 5000°C (far exceeding the melting point of conventional materials), calculate the minimum thermal conductivity (Thermal_Conductivity) value for each engine model based on cylinder spacing and surface area, and list the top 5 results sorted in ascending order by this minimum thermal conductivity value.",
        "query": "SELECT e.Model, (1000 * (ed.Cylinder_Spacing / 1000) ) / ( (2 * ((ed.Length / 1000) * (ed.Width / 1000) + (ed.Length / 1000) * (ed.Height / 1000) + (ed.Width / 1000) * (ed.Height / 1000))) * (5000 - 25) ) AS λ_min FROM enginedimensions ed INNER JOIN engine e ON ed.Engine_ID = e.Engine_ID ORDER BY λ_min ASC LIMIT 5;",
        "step": "【step1】: Perform INNER JOIN between 'engine' and 'enginedimensions' tables using Engine_ID to combine engine metadata with dimensional data.  【step2】: Calculate λ_min (minimum thermal conductivity) using formula:  λ_min = (1000 * Cylinder_Spacing/1000) / [2*(L*W + L*H + W*H) * (5000-25)]  Where L/W/H are converted from mm to meters (divided by 1000).  【step3】: Sort results by λ_min in ascending order and limit output to top 5 records where thermal conductivity requirements are lowest.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 297,
        "question": "Calculate the average combustion efficiency and total heat rejection rate for engines from different manufacturers, grouped by manufacturer.",
        "query": "SELECT e.Manufacturer, AVG(et.Combustion_Efficiency) AS Avg_Combustion_Efficiency, SUM(et.Heat_Rejection_Rate) AS Total_Heat_Rejection_Rate FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID GROUP BY e.Manufacturer;",
        "step": "【step1】: Join the 'engine' and 'enginethermodynamics' tables using Engine_ID to link combustion efficiency and heat rejection data to each manufacturer.  【step2】: Apply aggregate functions: calculate average combustion efficiency (AVG(et.Combustion_Efficiency)) and total heat rejection rate (SUM(et.Heat_Rejection_Rate)).  【step3】: Group results by Manufacturer to organize output per manufacturer and finalize grouped calculations.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 298,
        "question": "Calculate the weighted harmonic mean of the specific heat capacity and thermal conductivity for all electric engines, grouped by engine configuration.",
        "query": "SELECT e.Configuration, SUM(e.Weight)/(SUM(e.Weight/(0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity))) AS Weighted_Harmonic_Mean FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Fuel_Type = 'Electric' AND (0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity) > 0 GROUP BY e.Configuration;",
        "step": "【step1】: Filter and join data. Select electric engines with valid thermodynamic values (0.6*Specific_Heat_Capacity + 0.4*Thermal_Conductivity > 0) by joining engine and enginethermodynamics tables using Engine_ID.  【step2】: Calculate weight components. For each engine, compute (Weight / (0.6*Specific_Heat_Capacity + 0.4*Thermal_Conductivity)) and sum these values per configuration group.  【step3】: Compute harmonic mean. Divide the total weight sum by the summed weight ratios from step2, grouped by Configuration to produce the final weighted harmonic mean.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 299,
        "question": "Analyze engine models with coolant temperatures exceeding 120°C, and count the distinct quantities of models grouped by fuel type.",
        "query": "SELECT e.Fuel_Type, COUNT(DISTINCT e.Model) AS High_Temp_Models FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 120 GROUP BY e.Fuel_Type;",
        "step": "【step1】: Perform an INNER JOIN between the 'engine' and 'enginethermodynamics' tables using Engine_ID to access coolant temperature data.  【step2】: Filter rows where Coolant_Temperature > 120°C to isolate engines with elevated thermal conditions.  【step3】: Group results by Fuel_Type and calculate the count of DISTINCT Model values within each group to determine category-specific model frequencies.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 300,
        "question": "Assuming the exhaust temperature of a certain engine reaches 5273 K, calculate its thermal radiation power and infer material feasibility, grouped by the number of cylinders.",
        "query": "SELECT e.Cylinders, SUM(5.67E-8 * 0.9 * 2*(ed.Length*ed.Width + ed.Length*ed.Height + ed.Width*ed.Height) * (POWER(5273,4)-POWER(300,4))) AS Thermal_Radiation_Power FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Cylinders;",
        "step": "【step1】: Perform INNER JOIN between engine and enginedimensions tables using Engine_ID to associate physical dimensions with engine specifications.  【step2】: Apply Stefan-Boltzmann law formula (5.67E-8 * emissivity * surface area * ΔT⁴) to compute thermal radiation power for each engine, using derived surface area from dimensions and temperature difference (5273K⁴ - 300K⁴).  【step3】: Group aggregated results by Cylinders column and sum thermal radiation values within each group to analyze power distribution per cylinder configuration.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 301,
        "question": "Calculate whether the thermal emission rate of engine 12345 meets the first law of thermodynamics (energy conservation). Given that the total energy released by fuel combustion is 5000 kilowatts, the combustion efficiency is 35%, and the total heat carried away by the coolant and engine oil is 2500 kilowatts, what is the heat loss corresponding to the exhaust gas temperature?",
        "query": "SELECT Engine_ID, 5000 AS Total_Energy, Combustion_Efficiency, 2500 AS Cooling_Loss, (5000 - (5000 * Combustion_Efficiency / 100) - 2500) AS Calculated_Exhaust_Loss, Heat_Rejection_Rate AS Actual_Exhaust_Loss, CASE WHEN Heat_Rejection_Rate = (5000 - (5000 * Combustion_Efficiency / 100) - 2500) THEN '满足能量守恒' ELSE '不满足能量守恒' END AS Energy_Conservation_Status FROM enginethermodynamics WHERE Engine_ID = 12345;",
        "step": "【step1】: Filter engine thermodynamics data for Engine_ID 12345 using WHERE clause to isolate the target engine's record  【step2】: Calculate theoretical exhaust heat loss using formula (5000 - (5000 * 35% efficiency) - 2500 cooling loss), compare with actual Heat_Rejection_Rate from table  【step3】: Execute CASE statement to verify energy conservation by matching calculated vs actual exhaust loss, generating status indicator",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 302,
        "question": "If an engine with ID 12345 has oil temperature rising from 80°C to 120°C during operation, calculate the total stored heat (in joules). If this heat needs to be removed by the cooling system within 10 seconds, what cooling power in kilowatts must be achieved?",
        "query": "SELECT e.Engine_ID, e.Displacement, et.Specific_Heat_Capacity, (e.Displacement * 0.85) AS Mass_kg, (120 - 80) AS Temp_Diff_K, ROUND((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80), 2) AS Total_Heat_J, ROUND(((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80)) / 10 / 1000, 2) AS Required_Power_kW FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Engine_ID = 12345;",
        "step": "【step1】: Perform JOIN operation between engine and enginethermodynamics tables using Engine_ID to combine displacement and thermophysical properties  【step2】: Calculate intermediate values:  - Mass_kg = Displacement × 0.85 (conversion from liters to kg using oil density)  - Temp_Diff_K = 120 - 80 (temperature difference in Kelvin)  【step3】: Compute final results:  - Total_Heat_J = Mass × Specific_Heat_Capacity × Temp_Diff (Q=mcΔT formula)  - Required_Power_kW = (Total_Heat_J / 10) / 1000 (convert J/s to kW for 10-second duration)",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 303,
        "question": "Analyze whether the engine with an exhaust temperature of 950°C has a risk of catalytic converter failure.",
        "query": "SELECT Engine_ID, Exhaust_Gas_Temperature, CASE WHEN Exhaust_Gas_Temperature > 800 THEN '存在催化器失效风险' ELSE '工作状态正常' END AS Catalyst_Status FROM enginethermodynamics WHERE Exhaust_Gas_Temperature > 800;",
        "step": "【step1】: Filter engines with exhaust temperatures exceeding 800°C from the enginethermodynamics table  【step2】: Apply CASE statement to evaluate catalyst failure risk  【step3】: Return Engine_ID, temperature value, and risk classification based on threshold comparison",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 304,
        "question": "Assuming the combustion efficiency of an engine is 200% (far exceeding physical limits), and its heat rejection rate is -1000 kW (negative value indicates heat absorption). Please verify whether this engine is physically consistent under these conditions. If there is a contradiction, what is the contradiction point?",
        "query": "SELECT Engine_ID, Combustion_Efficiency, Heat_Rejection_Rate, CASE WHEN Combustion_Efficiency > 100 THEN 'Contradiction: Combustion efficiency exceeds physical limits' WHEN Heat_Rejection_Rate < 0 THEN 'Contradiction: Heat dissipation rate violates the second law of thermodynamics.' ELSE 'No contradiction' END AS Physical_Consistency FROM enginethermodynamics WHERE Combustion_Efficiency > 100 OR Heat_Rejection_Rate < 0;",
        "step": "【step1】: Retrieve engine thermodynamics data including Engine_ID, Combustion_Efficiency, and Heat_Rejection_Rate from the enginethermodynamics table.  【step2】: Filter records where Combustion_Efficiency exceeds 100% or Heat_Rejection_Rate is negative using the WHERE clause.  【step3】: Apply CASE logic to flag contradictions: \"矛盾：燃烧效率超过物理极限\" for efficiency violations and \"矛盾：熱排放率違反熱力学第二定律\" for negative heat rejection.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 305,
        "question": "The cylinder bore of an engine is 84 mm, the stroke is 90 mm, the compression ratio is 11.5:1, and the fuel is gasoline. Assuming standard atmospheric pressure, calculate the theoretical maximum combustion pressure (in Bar) in a single cylinder during one working cycle. The specific heat ratio of air is 1.4, and the standard atmospheric pressure is 1 Bar.",
        "query": "SELECT Engine_ID, Model, 1 * POW(CAST(SUBSTRING_INDEX(Compression_Ratio, ':', 1) AS DECIMAL), 1.4) AS Theoretical_Max_Pressure_Bar FROM engine WHERE Bore = 84 AND Stroke = 90 AND Compression_Ratio = '11.5:1' AND Fuel_Type = 'Gasoline';",
        "step": "【step1】: Filter records from the 'engine' table where Bore=84, Stroke=90, Compression_Ratio='11.5:1', and Fuel_Type='Gasoline' using WHERE clause.  【step2】: Extract the first part (11.5) from the string '11.5:1' in Compression_Ratio using SUBSTRING_INDEX, then cast it to DECIMAL for calculation.  【step3】: Calculate theoretical max pressure using the formula 1 Bar × (compression_ratio)^1.4 via POW() function and alias the result as Theoretical_Max_Pressure_Bar.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 306,
        "question": "An eight-cylinder V-engine (V8) has a crankshaft angular velocity of 400 radians/second, a piston stroke of 86 millimeters, and a connecting rod length of 150 millimeters. Calculate the instantaneous velocity of the piston (in meters/second) when the crankshaft angle is 70 degrees, accurate to four decimal places.",
        "query": "SELECT e.Engine_ID, e.Model, ed.Angular_Velocity, (ed.Angular_Velocity * (e.Stroke/2000)) * (SIN(RADIANS(70)) + ((e.Stroke/2000)/(2*0.15))*SIN(RADIANS(140))) AS Instantaneous_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Cylinders = 8 AND e.Configuration = 'V' AND e.Stroke = 86;",
        "step": "【step1】: Perform an INNER JOIN between 'engine' (e) and 'enginedynamics' (ed) tables using Engine_ID, filtering for V8 engines with 86mm stroke (WHERE e.Cylinders=8 AND e.Configuration='V' AND e.Stroke=86).  【step2】: Extract Angular_Velocity and compute the base term *ω*(Stroke/2000)*, where Stroke/2000 converts 86mm stroke to 0.043m radius (half of stroke).  【step3】: Apply the velocity formula: Multiply the base term by **[sin(70°) + (radius/0.15m)*sin(140°)]**, with 0.15m hardcoded as the rod length (150mm). RADIANS() converts degrees to radians, and SIN() calculates trigonometric values. Precision is enforced via floating-point arithmetic.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 307,
        "question": "A turbocharged diesel engine (Compression_Ratio=18:1, Fuel_Type=Diesel, Aspiration=Turbocharged) experiences severe power loss at a plateau altitude of 4500 meters. Please explain the phenomenon using Bernoulli's principle and the gas state equation, and propose improvement measures.",
        "query": "SELECT Engine_ID, Model, Compression_Ratio, Aspiration FROM engine WHERE Fuel_Type = 'Diesel' AND Aspiration = 'Turbocharged' AND Compression_Ratio = '18:1';",
        "step": "",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 308,
        "question": "Assuming a 24-cylinder W-type engine with a redline speed of 30,000 RPM, a bore of 200 mm, and a stroke of 500 mm, calculate the inertial force (in Newtons) experienced by the connecting rod, given a piston assembly mass of 2.5 kg.",
        "query": "SELECT e.Engine_ID, e.Model, 2.5 * POW(2*PI()*e.Redline/60, 2) * (e.Stroke/2000) * (1 + (e.Stroke/2000)/0.15) AS Inertial_Force FROM engine e WHERE e.Cylinders = 24 AND e.Configuration = 'W' AND e.Bore = 200 AND e.Stroke = 500;",
        "step": "【step1】: Filter engines with 24 W-type cylinders, 200mm bore, and 500mm stroke using WHERE conditions on `Cylinders`, `Configuration`, `Bore`, and `Stroke` columns.  【step2】: Calculate inertial force with `2.5 * POW(2*PI()*e.Redline/60, 2) * (e.Stroke/2000) * (1 + (e.Stroke/2000)/0.15)`, converting RPM to rad/s and stroke to meters.  【step3】: Extract `Engine_ID`, `Model`, and the calculated `Inertial_Force` for the qualified engine.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 309,
        "question": "A V-type engine has a main bearing bore diameter of 80 mm. Assuming the engine crankshaft is a uniform steel cylinder with a weight of 50 kg, calculate the moment of inertia of the crankshaft at its maximum rotational speed of 8000 RPM (ignoring the effect of the journals).",
        "query": "SELECT 0.5 * 50 * POWER((Main_Bore_Diameter/2/1000),2) AS 转动惯量, (2 * PI() * Max_turn)/60 AS 角速度 FROM enginedimensions JOIN enginedynamics USING(Engine_ID) WHERE Main_Bore_Diameter=80 AND Engine_ID IN (SELECT Engine_ID FROM engine WHERE Configuration='V')",
        "step": "【step1】: Execute subquery to retrieve Engine_IDs for V-configuration engines: SELECT Engine_ID FROM engine WHERE Configuration='V'  【step2】: Join enginedimensions and enginedynamics tables using Engine_ID, filtering by Main_Bore_Diameter=80 and matching Engine_IDs from step1's result  【step3】: Calculate rotational inertia using formula 0.5*mass*(radius²) and angular velocity using (2π*Max_turn)/60, with unit conversions (mm→m, RPM→rad/s)",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 310,
        "question": "A straight-six engine has a length of 600 mm, a width of 500 mm, and a height of 400 mm. It has 6 cylinders with a bore of 84 mm and a stroke of 90 mm. Calculate the percentage of volume in the engine's total volume that is not occupied by the cylinders (retain 3 decimal places).",
        "query": "SELECT ROUND((Length*Width*Height - Cylinders*PI()*POWER(Bore/2,2)*Stroke)/(Length*Width*Height)*100,3) AS 剩余空间占比 FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='Inline' AND Cylinders=6 AND Length=600 AND Width=500 AND Height=400",
        "step": "【step1】: Join the 'engine' and 'enginedimensions' tables using Engine_ID to combine dimensional data with cylinder parameters.  【step2】: Filter records where Configuration='Inline', Cylinders=6, and dimensions exactly match 600x500x400mm.  【step3】: Calculate unoccupied space by subtracting total cylinder volume (6×π×(84/2)²×90) from engine exterior volume (600×500×400), then compute percentage using (unoccupied/exterior)×100 with 3 decimal rounding.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 311,
        "question": "An engine has a width of 800 millimeters, and the maximum allowable installation width in the vehicle's front compartment is 900 millimeters. According to the automotive production line assembly specifications, at least 10% width margin must be reserved on each side between the engine and the compartment. Does this engine meet the installation requirements?",
        "query": "SELECT Width, CASE WHEN Width <= 900*(1-0.1) THEN 'conforms to' ELSE 'does not meet the requirements' END AS Installation Status FROM enginedimensions WHERE Width=800",
        "step": "【step1】: Filter the engine dimensions table to find records where Width is exactly 800mm using WHERE Width=800  【step2】: Calculate the maximum allowable width after reserving 10% total margin (5% on both sides): 900*(1-0.10)=810mm  【step3】: Use CASE statement to compare actual width (800mm) against calculated maximum (810mm), returning 'conforms to' when compliant or 'does not meet the requirements' otherwise",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 312,
        "question": "Assuming a W-type 24-cylinder engine has a cylinder spacing of 5,000 millimeters. If the diameter of the connecting rod journal must be maintained at 1/100 of the cylinder spacing, determine:  \n1) The theoretical length of the engine  \n2) The diameter of the connecting rod journal  \n3) Given that the crankshaft material has a yield strength of 800 MPa, calculate whether the shear stress on the journal under a torque of 20,000 N·m exceeds the limit.",
        "query": "SELECT (24/4)*Cylinder_Spacing AS 理论长度, Cylinder_Spacing/100 AS 轴颈直径, CASE WHEN (16*20000)/(PI()*POWER(Cylinder_Spacing/100/1000,3)) > 800e6 THEN 'exceed' ELSE 'not exceeding' END AS Stress state FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='W' AND Cylinders=24 AND Cylinder_Spacing=5000",
        "step": "【step1】: Perform INNER JOIN between 'enginedimensions' and 'engine' tables using Engine_ID, filtering records with WHERE clause (Configuration='W', Cylinders=24, Cylinder_Spacing=5000)  【step2】: Calculate engine length via (24/4)*Cylinder_Spacing and journal diameter via Cylinder_Spacing/100  【step3】: Compute shear stress using τ=(16*T)/(πd³) formula with unit conversion (mm to meters), then apply CASE statement to compare with 800MPa yield strength",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 313,
        "question": "The maximum rotation speed (Max_turn) of an engine is 8500 RPM, and the recorded Angular_Velocity is 890 rad/s. Please verify whether the angular velocity data satisfies the calculated value from the physical formula?",
        "query": "SELECT Engine_ID, Max_turn, Angular_Velocity, (PI() * Max_turn / 30) AS Formula_Value, ROUND(Angular_Velocity,2) = ROUND((PI() * Max_turn / 30),2) AS Data_Consistency FROM enginedynamics WHERE Max_turn = 8500 AND Angular_Velocity = 890;",
        "step": "【step1】: Filter records from enginedynamics table where Max_turn=8500 RPM and Angular_Velocity=890 rad/s  【step2】: Calculate theoretical value using formula π×Max_turn/30, round both Angular_Velocity and formula result to 2 decimal places  【step3】: Compare rounded values to generate Data_Consistency flag (1=valid, 0=invalid)",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 314,
        "question": "The Mean_Piston_Speed of a certain V-type engine is labeled as 25.4 m/s, with a Max_turn of 6800 RPM. Given that Stroke = 86 mm, please verify whether the labeled Mean_Piston_Speed matches the calculated value from the formula for engines with Configuration = 'V型'.",
        "query": "SELECT e.Engine_ID, ed.Mean_Piston_Speed, (2 * (e.Stroke/1000) * ed.Max_turn)/60 AS Calculated_Speed, ROUND(ed.Mean_Piston_Speed,1) = ROUND((2 * (e.Stroke/1000) * ed.Max_turn)/60,1) AS Validation FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'V型' AND ed.Max_turn = 6800 AND e.Stroke = 86;",
        "step": "【step1】: Join 'engine' and 'enginedynamics' tables using Engine_ID, filter for V-type engines with Stroke=86mm and Max_turn=6800 RPM.  【step2】: Calculate theoretical piston speed using formula (2*(Stroke/1000)*Max_turn/60), convert Stroke from mm to meters.  【step3】: Compare rounded values (1 decimal) between database's Mean_Piston_Speed and calculated value, output boolean Validation result.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 315,
        "question": "The peak torque of a certain turbocharged engine is marked within the 1500-4000 RPM range, with the lower bound being 1500 RPM and the upper bound being 4000 RPM, while the peak power is marked at 5500 RPM. Does this comply with conventional power characteristics?",
        "query": "SELECT Engine_ID, Peak_Torque, Peak_Power, CAST(SUBSTRING_INDEX(Peak_Torque,'-',-1) AS UNSIGNED) < CAST(Peak_Power AS UNSIGNED) AS Logic_Validation FROM enginedynamics WHERE Engine_ID IN (SELECT Engine_ID FROM engine WHERE Aspiration = 'Turbocharged');",
        "step": "",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 316,
        "question": "What is the angular velocity in rad/s of a rotor engine crankshaft rotating at 1,500,000 RPM, and will it fracture under centrifugal stress given a yield strength of 3000 MPa, material density of 7850 kg/m³, and radius of 50 mm?",
        "query": "SELECT PI() * 1500000 / 30 AS Angular_Velocity, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 AS Centrifugal_Stress, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 > 3e9 AS Will_Break FROM engine WHERE Configuration = 'rotor' LIMIT 1;",
        "step": "【step1】: Join 'engine' with 'enginedynamics' to obtain Max_turn from enginedynamics where Configuration='rotor'  【step2】: Calculate Angular_Velocity (PI()*Max_turn/30) and Centrifugal_Stress formula: (density * Angular_Velocity² * radius²)/3  【step3】: Compare calculated Centrifugal_Stress with 3e9 Pa yield strength using conditional check in SELECT clause",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 317,
        "question": "The engine block is made of aluminum alloy, and the cylinder head is made of cast iron. When the engine is running, the block temperature reaches 200°C while the cylinder head temperature reaches 300°C. How much heat is conducted per hour at the interface between the two materials?",
        "query": "SELECT ((300-200)*0.5)/((0.01/80)+(0.01/205))*3600 AS Heat_Joules_Per_Hour FROM enginematerials WHERE Block_Material='Aluminum' AND Head_Material='Cast Iron'",
        "step": "【step1】: Filter the enginematerials table where Block_Material is 'Aluminum' and Head_Material is 'Cast Iron' to verify material compatibility and obtain base parameters  【step2】: Apply Fourier's Law formula with hardcoded thermal conductivity values (80 W/m·K for Aluminum, 205 W/m·K for Cast Iron), temperature difference (300-200°C), contact area (0.5 m²), and thickness (0.01 m) to calculate thermal resistance and heat flux  【step3】: Multiply the derived power (watts) by 3600 seconds to convert to hourly heat transfer in joules, returning the final result as Heat_Joules_Per_Hour",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 318,
        "question": "A certain titanium alloy connecting rod material has a tensile strength of 900 MPa and a density of 4.5 g/cm³. If the connecting rod is required to have a safety factor of 2 when subjected to a tensile force of 50,000 N, calculate the minimum cross-sectional area and the maximum allowable weight assuming a length of 150 mm.",
        "query": "SELECT (2*50000)/(900e6) AS Min_Area_m2, (2*50000)/(900e6) * 0.15 * (4.5*1000) AS Max_Weight_kg FROM enginematerials WHERE Connecting_Rod_Material='Titanium'",
        "step": "【step1】: Filter engine materials where connecting rod material is Titanium using WHERE clause  【step2】: Calculate minimum cross-sectional area using formula (2×Force)/(Strength) converted to m² units  【step3】: Compute maximum weight by multiplying area by length constraint (0.15m) and material density (4500 kg/m³)",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 319,
        "question": "When an engine uses a cast iron cylinder block, its weight is 120kg. After switching to a magnesium alloy, the weight is reduced by 35%, but a 2mm-thick steel reinforcement layer (steel density 7800 kg/m³) needs to be added to the surface. Assuming the cylinder block volume is 0.015 cubic meters, is the final weight lower than the original cast iron solution?",
        "query": "SELECT CASE WHEN (0.015*1800*0.65) + (2*(e.Length*e.Width + e.Width*e.Height + e.Height*e.Length)/1e6 * 0.002 * 7800) < 120 THEN 'Yes' ELSE 'No' END FROM engine en JOIN enginedimensions e ON en.Engine_ID = e.Engine_ID JOIN enginematerials em ON en.Engine_ID = em.Engine_ID WHERE en.Weight = 120 AND em.Block_Material = 'Cast Iron';",
        "step": "【step1】: Join engine, enginedimensions, and enginematerials tables to filter engine records where Weight=120kg and Block_Material='Cast Iron', obtaining dimensional parameters.  【step2】: Calculate magnesium alloy block weight (0.015m³ × 1800kg/m³ × 65%) and steel reinforcement layer weight via surface area formula (2×(L×W + W×H + H×L)/1e6 × 0.002m × 7800kg/m³) using dimensions from enginedimensions.  【step3】: Compare total weight (magnesium + steel) with original 120kg using CASE statement to determine final weight status.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 320,
        "question": "If a certain crankshaft material is set as a hypothetical material with a density of 0.01 kg/m³, calculate whether the centrifugal force at 6000 RPM would cause structural failure of the material. It is known that the crankshaft arm length is 80 mm, the cross-sectional area is 200 mm², and the material's tensile strength is maintained at 900 MPa.",
        "query": "SELECT CASE WHEN (0.5 * (0.01 * 0.0002 * 0.08) * POWER((6000*2*PI()/60),2) * 0.08)/200e-6 > 900e6 THEN 'expired' ELSE 'Safety' END FROM enginematerials WHERE Crankshaft_Material='Hypothetical Materials'",
        "step": "【step1】: Calculate the angular velocity ω (6000 RPM → 6000×2π/60 rad/s)  【step2】: Compute centrifugal force using F=0.5×mass×ω²×radius (mass=0.01kg/m³×0.0002m²×0.08m)  【step3】: Compare stress (F/200e-6m²) against tensile strength (900MPa) via CASE conditional logic",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 321,
        "question": "Calculate the average brake mean effective pressure (BMEP) and average thermal efficiency for each engine configuration (cylinder arrangement).",
        "query": "SELECT e.Configuration, AVG((e.Torque * 2 * PI() * ed.Peak_Torque) / (e.Displacement * 1000) * 60 / 100000) AS Calculated_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Configuration ORDER BY e.Configuration;",
        "step": "【step1】: Perform multi-table JOIN operation between engine, enginedynamics, and engineperformance tables using Engine_ID as the foreign key.  【step2】: Calculate group-wise averages for BMEP (using torque/displacement formula) and Thermal Efficiency through GROUP BY on Configuration.  【step3】: Sort results alphabetically by Configuration using ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 322,
        "question": "Calculate the geometric mean of the product of specific power and specific torque for each manufacturer, and sort the results in descending order by the geometric mean.",
        "query": "SELECT e.Manufacturer, SQRT(AVG(ep.Specific_Power * ep.Specific_Torque)) AS Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Manufacturer ORDER BY Geometric_Mean DESC;",
        "step": "【step1】: Join the 'engine' and 'engineperformance' tables using Engine_ID to associate each engine's manufacturer with its performance data.  【step2】: Group the results by Manufacturer and calculate the geometric mean using SQRT(AVG(Specific_Power * Specific_Torque)) for each group.  【step3】: Order the final output by the calculated geometric mean in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 323,
        "question": "Group by displacement intervals (<2.0L, 2.0-3.0L, >3.0L) to calculate the median fuel consumption rate (Fuel_Consumption), verifying whether the common knowledge that 'larger displacement leads to higher fuel consumption' holds true.",
        "query": "SELECT Displacement_Group, AVG(Fuel_Consumption) AS Median_Fuel_Consumption FROM (SELECT e.Engine_ID, ep.Fuel_Consumption, CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END AS Displacement_Group, ROW_NUMBER() OVER (PARTITION BY CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END ORDER BY ep.Fuel_Consumption) AS RowAsc, ROW_NUMBER() OVER (PARTITION BY CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END ORDER BY ep.Fuel_Consumption DESC) AS RowDesc FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID) AS Ranked WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc GROUP BY Displacement_Group ORDER BY MIN(Ranked.Displacement_Group);",
        "step": "【step1】: Create displacement groups and calculate dual row numbers for fuel consumption rankings within each group using window functions. The CASE statement categorizes engines into three displacement groups, while ROW_NUMBER() creates ascending and descending rankings based on Fuel_Consumption.  【step2】: Identify median positions by filtering rows where ascending and descending ranks match (odd counts) or differ by 1 (even counts). This WHERE clause (RowAsc = RowDesc OR RowAsc + 1 = RowDesc) isolates median candidate records in each displacement group.  【step3】: Calculate final median values by averaging paired middle values (for even-numbered groups) or taking single middle values (for odd-numbered groups) using AVG(), then sort results logically by displacement group size through MIN(Displacement_Group) ordering.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 324,
        "question": "Assuming the thermal efficiency (Thermal_Efficiency) of an electric engine (Fuel_Type='Electric') is 120%, calculate the theoretical fuel consumption rate (Theoretical_Fuel_Consumption) and compare it with the average fuel consumption of gasoline engines, grouped by fuel type.",
        "query": "SELECT e.Fuel_Type, CASE WHEN e.Fuel_Type = 'Electric' THEN (100 / 120) * 100 ELSE AVG(ep.Fuel_Consumption) END AS Theoretical_Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Electric', 'Gasoline') GROUP BY e.Fuel_Type;",
        "step": "【step1】: Perform an INNER JOIN between the 'engine' and 'engineperformance' tables using Engine_ID, filtering only Electric and Gasoline fuel types.  【step2】: Apply conditional logic with CASE to calculate theoretical fuel consumption for Electric engines ((100/120)*100) while retaining Gasoline engine data for aggregation.  【step3】: Group results by Fuel_Type and compute AVG(Fuel_Consumption) for Gasoline engines while preserving the calculated Electric value through the CASE expression.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 325,
        "question": "Calculate the total heat capacity per degree Celsius for engines with combustion efficiency exceeding 30% by different manufacturers, and identify the manufacturer with the highest total heat capacity per degree.",
        "query": "SELECT e.Manufacturer, SUM(et.Heat_Rejection_Rate * 1000 / (et.Specific_Heat_Capacity * (et.Coolant_Temperature - 25))) AS Total_Heat_Capacity_Per_Degree FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Combustion_Efficiency > 30 GROUP BY e.Manufacturer ORDER BY Total_Heat_Capacity_Per_Degree DESC LIMIT 1;",
        "step": "【step1】: Filter engines with combustion efficiency over 30% using JOIN between engine and enginethermodynamics tables via Engine_ID.  【step2】: Calculate heat capacity per °C for each manufacturer using formula (Heat_Rejection_Rate*1000)/(Specific_Heat_Capacity*(Coolant_Temperature-25)) and aggregate via SUM with GROUP BY Manufacturer.  【step3】: Sort results by Total_Heat_Capacity_Per_Degree in descending order and select the top manufacturer using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 326,
        "question": "Statistics on all engines with a compression ratio greater than 10:1, calculating the product of specific power (Specific_Power) and thermal efficiency (Thermal_Efficiency), and filtering for engine models where this product exceeds the average product value among all engines with a compression ratio greater than 10:1.",
        "query": "SELECT e.Model, (ep.Specific_Power * ep.Thermal_Efficiency) AS Efficiency_Product FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE CAST(SUBSTRING_INDEX(e.Compression_Ratio, ':', 1) AS UNSIGNED) > 10 AND (ep.Specific_Power * ep.Thermal_Efficiency) > (SELECT AVG(ep2.Specific_Power * ep2.Thermal_Efficiency) FROM engineperformance ep2 JOIN engine e2 ON ep2.Engine_ID = e2.Engine_ID WHERE CAST(SUBSTRING_INDEX(e2.Compression_Ratio, ':', 1) AS UNSIGNED) > 10);",
        "step": "【step1】: Filter engines with compression ratio >10:1 by extracting the numeric part before colon and join with engineperformance to get efficiency metrics  【step2】: Calculate overall average of (Specific_Power * Thermal_Efficiency) across filtered engines using a subquery  【step3】: Select engine models where efficiency product exceeds the calculated average from step2",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 327,
        "question": "Identify engines with exhaust gas temperature exceeding 900°C and cylinder block material as cast iron.",
        "query": "SELECT e.Engine_ID, et.Exhaust_Gas_Temperature, em.Block_Material FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE et.Exhaust_Gas_Temperature > 900 AND em.Block_Material = 'Cast Iron';",
        "step": "【step1】: Execute INNER JOIN between engine, enginethermodynamics, and enginematerials tables using Engine_ID to combine thermodynamic data with material specifications.  【step2】: Apply WHERE clause to filter engines with Exhaust_Gas_Temperature > 900°C and Block_Material = 'Cast Iron'.  【step3】: Compare filtered results against material science standards (typical cast iron withstands ≤800°C) to identify potential design flaws or measurement errors.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 328,
        "question": "Assuming the existence of an engine with a rotational speed of 100,000 RPM, calculate whether its piston speed exceeds 7,000 m/s and return the overspeed ratio.",
        "query": "SELECT e.Model, (2 * e.Stroke * 100000) / 60000 AS Hypothetical_Piston_Speed, ((2 * e.Stroke * 100000) / 60000 - 7000) / 7000 * 100 AS Over_Speed_Percentage FROM engine e HAVING Hypothetical_Piston_Speed > 7000;",
        "step": "【step1】: Calculate hypothetical piston speed for each engine model using the formula (2 * Stroke * 100000)/60000  【step2】: Derive over-speed percentage by comparing the calculated piston speed to 7000 m/s threshold  【step3】: Filter results to only show engines where piston speed exceeds missile re-entry speed using HAVING clause",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 329,
        "question": "Assuming the engine block height (DeckHeight) is 200 millimeters, the bore (Bore) is 90 millimeters, the stroke (Stroke) is 100 millimeters, and the compression ratio (Compression_Ratio) is 11:1. Please calculate the combustion chamber volume (in liters) for this engine and verify if the compression ratio of 11 is less than or equal to 13?",
        "query": "SELECT ROUND((PI() * POW(90/2,2) * 100) / (11-1) / 1000000, 4) AS Combustion_Chamber_Volume_L, CASE WHEN 11 <= 13 THEN 'conforms to' ELSE 'does not meet the requirements' END AS Compression_Ratio_Check FROM DUAL;",
        "step": "【step1】: Calculate cylinder displacement volume: π × (Bore/2)² × Stroke = π × (90/2)² × 100 (in mm³)  【step2】: Compute combustion chamber volume: (Cylinder displacement) / (Compression_Ratio-1) / 1000000 converts mm³ to liters  【step3】: Validate compression ratio against gasoline engine standards (typically ≤13:1) using CASE conditional check",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 330,
        "question": "Please calculate the weighted composite score (with weights of 0.6 and 0.4, respectively) of specific power and thermal efficiency for all engines that use an aluminum alloy cylinder block and are turbocharged, rounding the result to two decimal places.",
        "query": "SELECT ROUND((ep.Specific_Power*0.6 + ep.Thermal_Efficiency*0.4),2) AS Comprehensive_Score FROM engine e JOIN enginematerials em ON e.Engine_ID=em.Engine_ID JOIN engineperformance ep ON e.Engine_ID=ep.Engine_ID WHERE em.Block_Material='Aluminum' AND e.Aspiration='Turbocharged' AND ep.Specific_Power IS NOT NULL AND ep.Thermal_Efficiency IS NOT NULL;",
        "step": "【step1】: Filter engines with Aluminum block material and Turbocharged aspiration by joining engine and enginematerials tables.  【step2】: Join engineperformance table to access power/thermal metrics, ensuring non-null values for Specific_Power and Thermal_Efficiency.  【step3】: Calculate weighted composite score (0.6*Specific_Power + 0.4*Thermal_Efficiency) and apply ROUND() to two decimal places.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 331,
        "question": "A manufacturer needs to design a V-type engine with a length not exceeding 600 millimeters. Given that the cylinder spacing is 120 millimeters and the rows are offset by a factor of 0.866 (representing a 30-degree V angle), calculate the maximum number of cylinders this engine can accommodate, taking into account the staggered arrangement characteristic of the two rows of cylinders in a V-type engine.",
        "query": "SELECT FLOOR(600 / (120 * 0.866)) * 2 AS Max_Cylinders FROM engine WHERE Configuration = 'V' LIMIT 1;",
        "step": "【step1】: Calculate the effective length occupied by each cylinder bank using the trigonometric relationship (cylinder spacing * cos(30°) ≈ 120 * 0.866) due to the staggered V-configuration.  【step2】: Determine single bank capacity with FLOOR(600 / (120*0.866)) to find 5 cylinders, as 5×103.92mm ≤600mm while 6×103.92mm exceeds the limit.  【step3】: Double the result (5×2=10) to account for both banks in V-type engines, achieving maximum cylinder count while maintaining spatial constraints.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 332,
        "question": "Assuming that the piston speed of a certain electric engine reaches 50 meters per second (far exceeding the physical limit), with a stroke of 200 millimeters, please calculate the RPM, the angular velocity of the engine at peak power speed, and determine how many times greater the centrifugal force acting on the crankshaft is compared to that of a conventional engine.",
        "query": "SELECT ROUND((50*60)/(2*0.2),0) AS RPM_假设, ROUND((50*60)/(2*0.2)*PI()/30,2) AS Angular_Velocity, ROUND(POW((50*60)/(2*0.2)/6000,2),2) AS Centrifugal_Force_Multiplier FROM engine WHERE Fuel_Type='Electric' AND Stroke=200 LIMIT 1;",
        "step": "【step1】: Filter electric engines with 200mm stroke using WHERE clause to isolate the target engine configuration.  【step2】: Calculate hypothetical RPM using formula (piston_speed*60)/(2*stroke_in_meters), then derive angular velocity via RPM*(π/30).  【step3】: Compute centrifugal force multiplier by squaring the ratio of hypothetical RPM to 6000 RPM (conventional baseline).",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "1",
        "idx": 333,
        "question": "Calculate the mean piston speed of engine models at maximum RPM, and identify all engine models with a mean piston speed exceeding 25 meters per second along with their manufacturers.",
        "query": "SELECT e.Manufacturer, e.Model, (2 * e.Stroke * ed.Max_turn) / 60000 AS Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE (2 * e.Stroke * ed.Max_turn) / 60000 > 25;",
        "step": "【step1】: Join the 'engine' and 'enginedynamics' tables using Engine_ID to access Stroke (from engine) and Max_turn (from enginedynamics).  【step2】: Calculate Mean_Piston_Speed via formula (2 * Stroke * Max_turn) / 60000, converting units appropriately.  【step3】: Filter results where Mean_Piston_Speed exceeds 25 m/s, then output Manufacturer and Model.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "2",
        "idx": 334,
        "question": "Calculate the standard deviation of angular velocity for V and inline engines, excluding those with a compression ratio less than 10.",
        "query": "SELECT e.Configuration, STDDEV((ed.Max_turn * 2 * PI()) / 60) AS Angular_Velocity_StdDev FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Compression_Ratio >= 10 AND e.Configuration IN ('V', 'Inline') GROUP BY e.Configuration;",
        "step": "【step1】: Perform an INNER JOIN between `engine` and `enginedynamics` tables on `Engine_ID`, filtering engines with `Compression_Ratio >= 10` and configurations of 'V' or 'Inline'.  【step2】: Calculate angular velocity using `(ed.Max_turn * 2 * PI()) / 60` to convert RPM to rad/s.  【step3】: Group results by `Configuration` and compute the standard deviation of angular velocity using `STDDEV()` for comparison between V-type and Inline engines.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "3",
        "idx": 335,
        "question": "Find all diesel engines that use cast iron cylinder blocks but have a thermal efficiency exceeding 40%, and sort them by specific power from highest to lowest.",
        "query": "SELECT e.Model, e.Manufacturer, ep.Specific_Power FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE em.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Diesel' AND ep.Thermal_Efficiency > 40 ORDER BY ep.Specific_Power DESC;",
        "step": "【step1】: Join three tables (engine, enginematerials, engineperformance) using Engine_ID to establish relationships between core specifications, material properties, and performance metrics.  【step2】: Apply filters for 'Cast Iron' block material, 'Diesel' fuel type, and thermal efficiency exceeding 40% to target specific engine qualifications.  【step3】: Sort results by Specific_Power in descending order and project Model, Manufacturer, and Specific_Power as final output columns.",
        "format": "MySQL"
    },
    {
        "db_id": "car_engine",
        "type": "4",
        "idx": 336,
        "question": "What are the connecting rod materials for engines with a rod journal diameter exceeding 500 millimeters?",
        "query": "SELECT DISTINCT em.Connecting_Rod_Material FROM enginematerials em JOIN enginedimensions ed ON em.Engine_ID = ed.Engine_ID WHERE ed.Rod_Journal_Diameter > 500;",
        "step": "【step1】: Perform JOIN operation between enginematerials (em) and enginedimensions (ed) tables using Engine_ID to combine material and dimensional data.  【step2】: Apply WHERE clause to filter records where Rod_Journal_Diameter exceeds 500 millimeters.  【step3】: Extract DISTINCT Connecting_Rod_Material values from the filtered joined dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 337,
        "question": "Calculate the total energy consumption of a car for 50 liters of fuel, given city fuel efficiency is 10km/L and highway fuel efficiency is 15km/L.",
        "query": "SELECT (50 * 10) + (50 * 15) AS Total_Energy_Consumption;",
        "step": "【step1】: Retrieve the vehicle's fuel efficiency and tank capacity from the 'cars' table using the specific model identification.  【step2】: Calculate city energy consumption (Fuel_Tank_Capacity * Fuel_Efficiency_City) and highway energy consumption (Fuel_Tank_Capacity * Fuel_Efficiency_Highway).  【step3】: Sum both values to derive the total energy consumption using arithmetic addition.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 338,
        "question": "Calculate the average power-to-weight ratio of all cars from a certain manufacturer and identify the top 5 cars with the highest power-to-weight ratio.",
        "query": "SELECT AVG(engine_specs.Horsepower / dimensions.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123; SELECT cars.Model, (engine_specs.Horsepower / dimensions.Curb_Weight) AS Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123 ORDER BY Power_to_Weight_Ratio DESC LIMIT 5;",
        "step": "【step1】: Join 'cars', 'engine_specs', and 'dimensions' tables using Car_ID, filter by Manufacturer_ID=123 to gather required data.  【step2】: Calculate average power-to-weight ratio using AVG() on the horsepower/curb_weight ratio from the joined dataset.  【step3】: Extract top 5 models by calculating individual power-to-weight ratios, sorting DESC, and applying LIMIT 5 from the same joined dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 339,
        "question": "Find all cars produced in 2020 with more than 5 seats and calculate their average cargo capacity.",
        "query": "SELECT AVG(Cargo_Capacity) AS Avg_Cargo_Capacity FROM cars WHERE Year = 2020 AND Seating_Capacity > 5;",
        "step": "【step1】: Filter cars produced in 2020 with seating capacity exceeding 5 using WHERE Year = 2020 AND Seating_Capacity > 5  【step2】: Calculate the average value of the Cargo_Capacity field from the filtered dataset using AVG(Cargo_Capacity)",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 340,
        "question": "A certain car has a battery capacity of 1000 kWh and a range of 10,000 km. Calculate its energy consumption per kilometer, and find all electric vehicles with energy consumption lower than that value.",
        "query": "SELECT 1000 / 10000 AS Energy_Consumption_Per_km; SELECT * FROM cars WHERE Battery_Capacity / Range < (1000 / 10000);",
        "step": "【step1】:Calculate the reference energy consumption per km: 1000 kWh / 10,000 km = 0.1 kWh/km.  【step2】Retrieve all electric vehicles (implied by Battery_Capacity/Range fields) from the cars table.  【step3】Filter vehicles where Battery_Capacity/Range < 0.1 to select those with lower energy consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 341,
        "question": "Calculate the air resistance for the car model 'Corolla' when driving at its maximum speed, given the air density is 1.225 kg/m³, the car's drag coefficient is 0.3, and the frontal area is 2.5 m².",
        "query": "SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Corolla';",
        "step": "【step1】: Join cars, performance_metrics, and engine_specs tables using Car_ID to consolidate required data (top speed, horsepower)  【step2】: Apply WHERE filter to select specific car model and convert top speed from km/h to m/s via division by 3.6 in POWER() function  【step3】: Calculate air resistance using formula (0.5 * density * (speed²) * drag_coefficient * area) and compare with horsepower value",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 342,
        "question": "Calculate the average fuel efficiency for each car model from a certain manufacturer and identify the top three models with the highest average fuel efficiency.",
        "query": "SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'A certain manufacturer' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;",
        "step": "【step1】: Join the 'cars' and 'manufacturers' tables using Manufacturer_ID, filter records where manufacturer name is 'A certain manufacturer'.  【step2】: Calculate average fuel efficiency for each model by averaging Fuel_Efficiency_City and Fuel_Efficiency_Highway.  【step3】: Order results by average fuel efficiency in descending order and retain the top 3 models using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 343,
        "question": "Estimate the per-kilometer fuel cost for the Corolla in urban and highway conditions based on its fuel efficiency, with the fuel price set at $1.2 per liter.",
        "query": "SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = 'Corolla';",
        "step": "【step1】: Filter the 'cars' table to select the specific car model using WHERE clause.  【step2】: Calculate city fuel cost per kilometer by inverting Fuel_Efficiency_City (km/L), then multiplying by fuel price (1.2 USD/L).  【step3】: Calculate highway fuel cost per kilometer using the same logic with Fuel_Efficiency_Highway.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 344,
        "question": "If the battery capacity of a Toyota Corolla is increased to 1000 kWh, calculate whether its range will exceed 10,000 km, given an electricity consumption of 0.2 kWh per kilometer.",
        "query": "SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = 'Corolla';",
        "step": "【step1】: Filter the 'cars' table to retrieve the specific model using WHERE c.Model = 'Corolla'.  【step2】: Calculate theoretical range with formula 1000 kWh / 0.2 kWh per km, aliased as Theoretical_Range.  【step3】: Compare the calculated value to determine if it exceeds 10,000 km (implicit in result interpretation).",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 345,
        "question": "Calculate the total energy consumption (in kilowatt-hours) of the car with Car_ID '1' for driving 100 kilometers in the city and 200 kilometers on the highway.",
        "query": "SELECT ((100 / Fuel_Efficiency_City) + (200 / Fuel_Efficiency_Highway)) * 8.9 AS Total_Energy_Consumption FROM cars WHERE Car_ID = '1';",
        "step": "【step1】: Retrieve the city and highway fuel efficiency values (Fuel_Efficiency_City and Fuel_Efficiency_Highway) for the specified Car_ID from the 'cars' table.  【step2】: Calculate fuel consumption for both city (100 km / Fuel_Efficiency_City) and highway (200 km / Fuel_Efficiency_Highway) segments.  【step3】: Sum the fuel consumption values and multiply by 8.9 to convert the total fuel volume to energy in kilowatt-hours (kWh), then output as Total_Energy_Consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 346,
        "question": "Calculate the average power-to-weight ratio for each car model from manufacturer with ID 1 and identify the top 5 models with the highest power-to-weight ratios.",
        "query": "SELECT c.Model, AVG(e.Horsepower / d.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN dimensions d ON c.Car_ID = d.Car_ID WHERE c.Manufacturer_ID = 1 GROUP BY c.Model ORDER BY Avg_Power_to_Weight_Ratio DESC LIMIT 5;",
        "step": "【step1】: Join tables `cars`, `engine_specs`, and `dimensions` via `Car_ID` and filter by `Manufacturer_ID = 1` to gather required horsepower and curb weight data.  【step2】: Calculate the average power-to-weight ratio (`Horsepower/Curb_Weight`) for each model using `AVG()` and group results by `c.Model`.  【step3】: Sort models by `Avg_Power_to_Weight_Ratio` in descending order and limit output to the top 5 records using `ORDER BY ... DESC LIMIT 5`.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 347,
        "question": "Find all car models produced in 2020 with a fuel tank capacity greater than 50 liters and city fuel efficiency below 10 km/L, sorted in descending order by production volume.",
        "query": "SELECT Model FROM cars WHERE Year = 2020 AND Fuel_Tank_Capacity > 50 AND Fuel_Efficiency_City < 10 ORDER BY Production_Volume DESC",
        "step": "【step1】: Filter the 'cars' table to include only records where Year is 2020.  【step2】: Apply additional filters for Fuel_Tank_Capacity > 50 and Fuel_Efficiency_City < 10 to the results from step1.  【step3】: Sort the remaining entries by Production_Volume in descending order and extract the Model names.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 348,
        "question": "Calculate the amount of fuel required for a car to travel 1000 kilometers with a fuel efficiency of 0.1 km/L, and determine its carbon dioxide emissions.",
        "query": "SELECT (1000 / 0.1) AS Fuel_Consumption, (1000 / 0.1) * 2.31 AS CO2_Emissions",
        "step": "【step1】: Calculate fuel consumption by dividing distance by fuel efficiency: 1000km / 0.1km/L = 10,000L  【step2】: Multiply fuel consumption by CO2 emission factor (2.31g/L) to get total emissions: 10,000L * 2.31 = 23,100g",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 349,
        "question": "If the fuel efficiency of a car decreases by 10%, what is the percentage change in its fuel efficiency in both city and highway driving?",
        "query": "SELECT Model, ((Fuel_Efficiency_City * 0.9 - Fuel_Efficiency_City) / Fuel_Efficiency_City) * 100 AS City_Efficiency_Change_Percent, ((Fuel_Efficiency_Highway * 0.9 - Fuel_Efficiency_Highway) / Fuel_Efficiency_Highway) * 100 AS Highway_Efficiency_Change_Percent FROM cars;",
        "step": "【step1】: Select the Model and original fuel efficiency values (Fuel_Efficiency_City and Fuel_Efficiency_Highway) from the cars table.  【step2】: Calculate the percentage change for city fuel efficiency using the formula ((Fuel_Efficiency_City * 0.9 - Fuel_Efficiency_City) / Fuel_Efficiency_City) * 100.  【step3】: Calculate the percentage change for highway fuel efficiency analogously and output both results with the Model.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 350,
        "question": "Identify the car models from a certain manufacturer that have a production volume greater than the average production volume of cars from that manufacturer.",
        "query": "SELECT Model FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer') AND Production_Volume > (SELECT AVG(Production_Volume) FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer'));",
        "step": "【step1】: Retrieve the Manufacturer_ID from the 'manufacturers' table where the manufacturer name matches 'A certain manufacturer'.  【step2】: Calculate the average Production_Volume of all cars produced by this manufacturer using the Manufacturer_ID obtained in Step 1.  【step3】: Select car models from the 'cars' table where the Manufacturer_ID matches the result from Step 1 and Production_Volume exceeds the average value calculated in Step 2.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 351,
        "question": "Find which cars have a fuel tank capacity that is less than the amount of fuel required for city fuel consumption multiplied by 10, and list the manufacturers and models of these cars.",
        "query": "SELECT m.Name, c.Model FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity < (e.Fuel_Consumption_City * 10);",
        "step": "【step1】: Join cars table with manufacturers and engine_specs tables using Manufacturer_ID and Car_ID respectively to connect vehicle data.  【step2】: Apply WHERE filter condition comparing Fuel_Tank_Capacity against (Fuel_Consumption_City * 10) which represents 1000km fuel requirement.  【step3】: Select and output manufacturer Name and car Model fields from the filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 352,
        "question": "If a car has a maximum speed of 1000 km/h, what would its hypothetical braking distance be, assuming it follows the same braking performance relationship as the cars in the database?",
        "query": "SELECT c.Model, (p.Braking_Distance * POWER(1000, 2) / POWER(p.Top_Speed, 2)) AS Hypothetical_Braking_Distance FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID;",
        "step": "【step1】: Join `cars` and `performance_metrics` tables via `Car_ID` to associate car models with their original braking distance and top speed data.  【step2】: Apply proportional calculation using the formula: `(original_braking_distance * (1000² / original_top_speed²))` to derive the hypothetical braking distance.  【step3】: Select the car model and the calculated hypothetical braking distance for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 353,
        "question": "If a car with a weight of 1500kg is traveling at a speed of 100km/h, and the query uses a formula that calculates kinetic energy as 0.5 * weight * (speed in m/s squared), what is the kinetic energy in joules?",
        "query": "SELECT 0.5 * Weight * POWER((100 * 1000 / 3600), 2) AS Kinetic_Energy FROM cars WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the weight (in kg) of the car with Car_ID=1 from the cars table.  【step2】: Convert the given speed from km/h to m/s by applying the formula (100 * 1000 / 3600), then square the result.  【step3】: Compute kinetic energy using the formula 0.5 * Weight * squared_speed and alias the result as Kinetic_Energy.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 354,
        "question": "Calculate the average fuel efficiency (average of city and highway) for all car models from a certain manufacturer, and identify the model with the highest average fuel efficiency.",
        "query": "SELECT Model, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2) AS Avg_Fuel_Efficiency FROM cars WHERE Manufacturer_ID = 1 GROUP BY Model ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;",
        "step": "【step1】: Filter cars by Manufacturer_ID=1 to focus on the target manufacturer's vehicles.  【step2】: Calculate the average fuel efficiency ((City + Highway)/2) for each model using AVG and GROUP BY Model.  【step3】: Sort results by Avg_Fuel_Efficiency in descending order and select the top model with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 355,
        "question": "If a car has a fuel tank capacity of 50L, city fuel consumption of 8L/100km, and highway fuel consumption of 6L/100km, how many kilometers can it travel in the city and on the highway respectively?",
        "query": "SELECT Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Car_ID = 1;",
        "step": "【step1】: JOIN cars and engine_specs tables via Car_ID to combine fuel capacity and consumption data  【step2】: Filter for Car_ID=1 using WHERE clause to isolate the target vehicle  【step3】: Calculate range by dividing Fuel_Tank_Capacity by fuel consumption (L/100km) then multiplying by 100 for unit conversion",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 356,
        "question": "If a car's engine has a maximum speed of 10,000 RPM and consumes 0.1L of fuel per minute at maximum speed, how much fuel will it consume when running at maximum speed for 1 hour?",
        "query": "SELECT Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the Max_RPM value from the engine_specs table for Car_ID = 1.  【step2】: Calculate fuel consumption by multiplying Max_RPM (per minute) by 60 (minutes) and 0.1 (liters per RPM).  【step3】: Output the computed Fuel_Consumption value directly from the calculation.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 357,
        "question": "Calculate the kinetic energy of each car at its maximum speed and identify the model with the highest kinetic energy.",
        "query": "SELECT Model, 0.5 * Weight * POWER((Top_Speed * 1000 / 3600), 2) AS Kinetic_Energy FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID ORDER BY Kinetic_Energy DESC LIMIT 1;",
        "step": "【step1】: JOIN cars and performance_metrics tables using Car_ID to combine vehicle weight and top speed data  【step2】: Calculate kinetic energy using formula 0.5 * Weight * (Top_Speed converted to m/s) squared  【step3】: Sort results by kinetic energy in descending order and select the top model using LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 358,
        "question": "Calculate the average fuel efficiency (mean of city and highway) for all manufacturers' cars, and identify the manufacturer with the highest fuel efficiency.",
        "query": "SELECT manufacturers.Name, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2) AS Avg_Fuel_Efficiency FROM cars JOIN manufacturers ON cars.Manufacturer_ID = manufacturers.Manufacturer_ID GROUP BY manufacturers.Name ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;",
        "step": "【step1】: Join 'cars' with 'manufacturers' using Manufacturer_ID to associate vehicles with their makers  【step2】: Calculate average fuel efficiency per manufacturer by taking (City + Highway)/2 for each car, then AVG() across all models  【step3】: Order results by Avg_Fuel_Efficiency descending and select top result using LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 359,
        "question": "Calculate the car model with the highest driving mileage in both urban and highway conditions.",
        "query": "SELECT c.Model, c.Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID ORDER BY City_Range DESC, Highway_Range DESC LIMIT 1;",
        "step": "【step1】: Join 'cars' and 'engine_specs' tables via Car_ID to combine fuel capacity and consumption data.  【step2】: Calculate City_Range (Fuel_Tank_Capacity / Fuel_Consumption_City * 100) and Highway_Range (Fuel_Tank_Capacity / Fuel_Consumption_Highway * 100) for each vehicle.  【step3】: Sort results by City_Range and Highway_Range descendingly, then return the top-ranked model with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 360,
        "question": "Calculate the fuel consumption of all cars running at maximum RPM for 1 hour, and list the model with the highest fuel consumption.",
        "query": "SELECT cars.Model, Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs JOIN cars ON engine_specs.Car_ID = cars.Car_ID ORDER BY Fuel_Consumption DESC LIMIT 1;",
        "step": "【step1】: Join cars and engine_specs tables using Car_ID to associate engine specifications with vehicle models.  【step2】: Calculate hourly fuel consumption at max RPM using formula (Max_RPM * 60 * 0.1) and alias as Fuel_Consumption.  【step3】: Sort results by Fuel_Consumption in descending order and select the top entry with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 361,
        "question": "If a car weighs 1500 kg and its 0-100 acceleration time is 8 seconds, what is its average acceleration?",
        "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE Weight = 1500;",
        "step": "【step1】: Perform an INNER JOIN between `cars` and `performance_metrics` tables using the shared `Car_ID` column to combine car weight and acceleration data.  【step2】: Apply a filter with `WHERE Weight = 1500` to isolate records matching the specified weight.  【step3】: Select the `Weight` and `Acceleration_0_to_100` columns from the filtered result.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 362,
        "question": "A car has a fuel efficiency of 10 km/L in the city, with a fuel tank capacity of 50 L. If it travels 30 km per day, how many consecutive days can the car drive before needing to refuel?",
        "query": "SELECT Fuel_Efficiency_City, Fuel_Tank_Capacity FROM cars WHERE Fuel_Efficiency_City = 10 AND Fuel_Tank_Capacity = 50;",
        "step": "【step1】:【Filter cars with Fuel_Efficiency_City = 10 km/L and Fuel_Tank_Capacity = 50 L using the WHERE clause】  【step2】:【Select the Fuel_Efficiency_City and Fuel_Tank_Capacity columns from the filtered records】",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 363,
        "question": "If a car has a cargo capacity of 500L, and each transport requires 300L of cargo, what is the maximum number of times this car can transport?",
        "query": "SELECT Cargo_Capacity FROM cars WHERE Cargo_Capacity = 500;",
        "step": "【step1】: Retrieve the Cargo_Capacity value from the cars table where the capacity is exactly 500L using the filter condition: SELECT Cargo_Capacity FROM cars WHERE Cargo_Capacity = 500  【step2】: Calculate the maximum number of transports by performing integer division (500L ÷ 300L per trip) using FLOOR() or DIV operator  【step3】: Return the result as an integer alias (e.g., Max_Transport_Times) with SELECT FLOOR(Cargo_Capacity/300) FROM cars WHERE Cargo_Capacity=500",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 364,
        "question": "If a car's engine has a maximum RPM of 10000, what is its horsepower?",
        "query": "SELECT Max_RPM, Horsepower FROM engine_specs WHERE Max_RPM = 10000;",
        "step": "【step1】:【Retrieve all records from the 'engine_specs' table where the Max_RPM equals 10000】  【step2】:【Extract the Horsepower field from the filtered records】",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 365,
        "question": "If a car with ID 1 weighs 1500kg and takes 8 seconds to accelerate from 0 to 100 km/h, what is the average power it generates during the acceleration process?",
        "query": "SELECT Weight, Acceleration_0_to_100 FROM performance_metrics JOIN cars ON performance_metrics.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;",
        "step": "【step1】: Join the `cars` and `performance_metrics` tables via `Car_ID` to retrieve weight and acceleration data.  【step2】: Calculate average power using the formula: \\( \\text{Power} = \\frac{\\text{Weight} \\times (100/3.6)^2}{2 \\times \\text{Acceleration\\_0\\_to\\_100}} \\), converting velocity to m/s (100 km/h ≈ 27.78 m/s).  【step3】: Convert the result from watts to horsepower (1 HP ≈ 745.7 W) and alias the output as `Average_Power`.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 366,
        "question": "A car's fuel tank capacity is 60L, with urban fuel efficiency of 10km/L and highway fuel efficiency of 15km/L. If this car travels 200km in the city and 200km on the highway, how many liters of fuel does it consume in total?",
        "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE cars.Car_ID = 1;",
        "step": "【step1】: Retrieve the car's city and highway fuel efficiency values from the 'cars' table using Car_ID=1.  【step2】: Calculate city fuel consumption as 200km / Fuel_Efficiency_City and highway fuel consumption as 200km / Fuel_Efficiency_Highway.  【step3】: Sum both calculated fuel consumption values to get total liters consumed.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 367,
        "question": "A car has a cargo capacity of 500L and a trunk capacity of 300L. If the owner needs to transport a batch of goods, with each item having a volume of 50L, what is the maximum number of items this car can transport?",
        "query": "SELECT (dimensions.Cargo_Capacity + dimensions.Trunk_Capacity) / 50 AS Max_Cargo_Items FROM dimensions JOIN cars ON dimensions.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;",
        "step": "【step1】: Join the 'dimensions' and 'cars' tables using Car_ID to retrieve cargo capacity data.  【step2】: Filter the joined dataset to target the specific vehicle with Car_ID = 1.  【step3】: Compute the maximum cargo items by adding Cargo_Capacity and Trunk_Capacity from the dimensions table, then dividing by 50 (per-item volume).",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 368,
        "question": "If a car with a battery capacity of 100 kWh and a range of 500 km changes its battery capacity to 1000 kWh while all other conditions remain the same, what is the new range?",
        "query": "SELECT `Range` * (1000 / `Battery_Capacity`) AS New_Range FROM cars WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the original `Range` and `Battery_Capacity` values for Car_ID=1 from the `cars` table.  【step2】: Calculate the hypothetical new range by scaling proportionally using the formula `New_Range = Range * (1000 / Battery_Capacity)`.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 369,
        "question": "What are the car's weight and 0-100 acceleration time?",
        "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
        "step": "【step1】: JOIN cars and performance_metrics tables using Car_ID to retrieve specific car's Weight and Acceleration_0_to_100 data  【step2】: Filter results using WHERE cars.Car_ID = 1 to isolate the target vehicle's records  【step3】: Extract Weight (1500kg) and Acceleration_0_to_100 (8s) values for physics calculations (executed outside SQL)",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 370,
        "question": "An automobile manufacturer with a Manufacturer_ID of 1 produces three car models, with annual sales of 5,000 units, 3,000 units, and 2,000 units respectively, and the average selling prices for each model are $30,000, $40,000, and $50,000 respectively. Calculate the manufacturer's total annual revenue.",
        "query": "SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue FROM manufacturers WHERE Manufacturer_ID = 1;",
        "step": "【step1】: Filter the manufacturers table to select the row where Manufacturer_ID = 1.  【step2】: Calculate the product of Annual_Sales and Average_Price for the filtered record, then sum the result to produce Total_Revenue.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 371,
        "question": "A car has a fuel tank capacity of 60L, with urban fuel efficiency of 10km/L and highway fuel efficiency of 15km/L. If the owner drives 200km in the city and 200km on the highway, how much fuel does the car consume in total?",
        "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the car's fuel efficiency data from the 'cars' table  【step2】: Filter the record where Car_ID = 1 and extract Fuel_Efficiency_City (10 km/L) and Fuel_Efficiency_Highway (15 km/L)  【step3】: Calculate total fuel consumption: (200km / 10km/L) + (200km / 15km/L) = 20L + 13.33L = 33.33L",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 372,
        "question": "If a car has a battery capacity of 1000kWh, travels at a top speed of 300km/h, and has an energy consumption of 500Wh/km at top speed, calculate the endurance time of the car when driving at top speed with a full battery.",
        "query": "SELECT cars.Car_ID, (cars.Battery_Capacity * 1000) / (500 * performance_metrics.Top_Speed) AS Max_Speed_Range_Time FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
        "step": "【step1】: JOIN cars and performance_metrics tables via Car_ID to access Battery_Capacity and Top_Speed.  【step2】: Calculate energy consumption rate at max speed: 500 Wh/km * Top_Speed (km/h) = 500*Top_Speed (Wh/h).  【step3】: Compute runtime by converting Battery_Capacity (kWh) to Wh (×1000), then divide by energy consumption rate: (Battery_Capacity*1000)/(500*Top_Speed).",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 373,
        "question": "If a car weighs 1500kg and its 0-100 acceleration time is 8 seconds, what is the car's average acceleration and the required average traction force?",
        "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
        "step": "【step1】: Join cars and performance_metrics tables using Car_ID to combine vehicle weight and acceleration data.  【step2】: Filter the joined dataset to retrieve records where Car_ID = 1.  【step3】: Select the Weight and Acceleration_0_to_100 fields from the filtered result.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 374,
        "question": "What is the total profit for BMW?",
        "query": "SELECT Annual_Sales, Profit_Margin, Average_Price FROM manufacturers WHERE Name = 'Tesla';",
        "step": "【step1】: Retrieve the manufacturer's annual sales, profit margin, and average price using SELECT Annual_Sales, Profit_Margin, Average_Price FROM manufacturers WHERE Name = 'Tesla'.  【step2】: Calculate total profit per model: (Annual_Sales * Average_Price * Profit_Margin / 100).  【step3】: Sum profit values across all models (A+B+C) using derived calculations from step2.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 375,
        "question": "A car's fuel tank has a capacity of 60L, with a city fuel consumption of 10L/100km and highway fuel consumption of 7L/100km. If the car owner drives 200km in the city and 200km on the highway, how much fuel does the car consume in total?",
        "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the car's city and highway fuel efficiency (in km/L) from the 'cars' table using WHERE Car_ID=1.  【step2】: Calculate city fuel consumption: 200km ÷ Fuel_Efficiency_City (km/L) to get liters used in city driving.  【step3】: Calculate highway fuel consumption: 200km ÷ Fuel_Efficiency_Highway (km/L) to get liters used on highway, then sum both values for total consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 376,
        "question": "If a car with battery capacity of 1000 kWh and maximum power of 500 kW drives continuously at maximum power, what is the minimum time it takes for the battery to be depleted?",
        "query": "SELECT c.Battery_Capacity, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;",
        "step": "【step1】: Filter the cars table to retrieve the specific car with Car_ID = 1.  【step2】: Join the performance_metrics table using Car_ID to access the electric range data.  【step3】: Select the Battery_Capacity from cars and Range_Electric from performance_metrics for the specified vehicle.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 377,
        "question": "If a car weighs 1500kg and its 0 to 100 km/h acceleration time is 8 seconds, what is its average acceleration in m/s²?",
        "query": "SELECT (100 * 1000 / 3600) / 8 AS average_acceleration FROM cars WHERE Weight = 1500;",
        "step": "【step1】: JOIN cars and performance_metrics tables using Car_ID to access both Weight and Acceleration_0_to_100 data  【step2】: FILTER records where Weight=1500 AND Acceleration_0_to_100=8  【step3】: CALCULATE average acceleration using (100*1000/3600)/8 and return the result",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 378,
        "question": "If a car has a fuel tank capacity of 60L, an urban fuel efficiency of 10km/L, and a highway fuel efficiency of 15km/L, what is the vehicle's total range under mixed driving conditions (with 50% city driving and 50% highway driving)?",
        "query": "SELECT (Fuel_Tank_Capacity * Fuel_Efficiency_City * 0.5) + (Fuel_Tank_Capacity * Fuel_Efficiency_Highway * 0.5) AS total_range FROM cars WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the necessary fuel efficiency and tank capacity data for Car_ID=1 from the cars table.  【step2】: Calculate the city driving range component (50% of 60L * 10km/L) and highway driving range component (50% of 60L * 15km/L) separately.  【step3】: Sum the two components to derive the total range under mixed driving conditions.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 379,
        "question": "If a car has a base price and an annual maintenance cost, and an annual depreciation rate of 15%, what will be the total maintenance cost and the depreciated value of the car after 5 years, assuming the maintenance cost is constant each year?",
        "query": "SELECT Maintenance_Cost * 5 AS total_maintenance_cost, Base_Price * POWER(1 - Depreciation_Rate, 5) AS depreciated_value FROM prices WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the car's annual maintenance cost and base price with depreciation rate from the 'prices' table using WHERE Car_ID=1 filter  【step2】: Calculate total maintenance cost by multiplying annual maintenance cost by 5 years  【step3】: Compute depreciated value using compound depreciation formula: Base_Price × (1 - Depreciation_Rate)⁵ via POWER() function",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 380,
        "question": "If a car has a battery capacity of 1000kWh and a range of 1000km, what is the calculated extended range using the formula (100000 / Battery_Capacity) * Range?",
        "query": "SELECT (100000 / Battery_Capacity) * `Range` AS extended_range FROM cars WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the original Battery_Capacity (1000kWh) and corresponding Range (1000km) for Car_ID=1 from the cars table.  【step2】: Calculate hypothetical extended_range by scaling proportionally: (100000 / 1000) * 1000 = 100000km.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 381,
        "question": "If a car with ID 1 weighs 1500kg and its 0-100 acceleration time is 8 seconds, what are the car's average acceleration and the required average thrust?",
        "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
        "step": "【step1】: Perform an INNER JOIN between 'cars' and 'performance_metrics' tables using the shared 'Car_ID' field to link vehicle specifications with performance data.  【step2】: Apply a WHERE clause to filter results for the specific vehicle with 'Car_ID = 1'.  【step3】: Extract the 'Weight' (kg) and 'Acceleration_0_to_100' (seconds) values from the joined tables to calculate average acceleration (using *a = Δv/Δt*) and average thrust (using *F = m·a*).",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 382,
        "question": "An automobile manufacturer with ID 1 produces three car models with annual sales of 5,000, 7,000, and 9,000 units, and average selling prices of $30,000, $40,000, and $50,000, respectively. Calculate the manufacturer's total annual revenue and the average price per car sold.",
        "query": "SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue, SUM(Annual_Sales) AS Total_Sales, SUM(Annual_Sales * Average_Price) / SUM(Annual_Sales) AS Average_Price_Per_Car FROM manufacturers WHERE Manufacturer_ID = 1;",
        "step": "【step1】: Filter the target manufacturer by Manufacturer_ID=1 from the manufacturers table to isolate relevant sales data  【step2】: Calculate Total_Revenue by multiplying Annual_Sales and Average_Price for all models under this manufacturer, then sum the results  【step3】: Compute Average_Price_Per_Car using summed values through (Total_Revenue / Total_Sales) formula, ensuring correct aggregate calculation order",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 383,
        "question": "A car has a fuel tank capacity of 60L, with an urban fuel efficiency of 10km/L and a highway fuel efficiency of 15km/L. If the car owner drove 200km in the city and 200km on the highway, how much fuel did the car consume in total?",
        "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve the car's fuel efficiency data from the 'cars' table using the given query to obtain Fuel_Efficiency_City (10 km/L) and Fuel_Efficiency_Highway (15 km/L).  【step2】: Calculate city fuel consumption: 200 km ÷ 10 km/L = 20 L.  【step3】: Calculate highway fuel consumption: 200 km ÷ 15 km/L ≈13.33 L, then sum both values: 20 L + 13.33 L = 33.33 L total fuel consumed.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 384,
        "question": "If a car's engine has a maximum RPM of 10,000 and a cylinder count of 4, with each cylinder burning 100 times per minute at maximum RPM, calculate the total combustion per minute and per hour for the engine at maximum RPM.",
        "query": "SELECT Max_RPM, Cylinder_Count FROM engine_specs WHERE Car_ID = 1;",
        "step": "【step1】: Retrieve Cylinder_Count from engine_specs table for Car_ID=1  【step2】: Calculate total combustion per minute: Cylinder_Count × 100  【step3】: Calculate total combustion per hour: total_per_minute × 60",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 385,
        "question": "If a car weighs 1500kg and its 0-100 acceleration time is 8 seconds, what is the average power generated during the acceleration process?",
        "query": "SELECT (0.5 * Weight * POWER(27.78, 2)) / Acceleration_0_to_100 AS Average_Power FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;",
        "step": "【step1】: Perform INNER JOIN between `cars` and `performance_metrics` tables using `Car_ID` to merge car weight and acceleration data.  【step2】: Apply WHERE clause to filter records where `Weight`=1500kg and `Acceleration_0_to_100`=8 seconds.  【step3】: Calculate kinetic energy formula `(0.5 * Weight * POWER(27.78, 2)) / Acceleration_0_to_100` to derive average power in watts.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 386,
        "question": "If a car with ID 1 has a fuel tank capacity of 50L, with urban fuel consumption of 8L/100km and highway fuel consumption of 6L/100km, how many kilometers will the car travel before the tank becomes empty, respectively, in urban and highway conditions?",
        "query": "SELECT cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_City / 100) AS City_Distance, cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_Highway / 100) AS Highway_Distance FROM cars JOIN engine_specs ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Car_ID = 1;",
        "step": "【step1】: Perform INNER JOIN between cars and engine_specs tables using Car_ID to access fuel consumption data  【step2】: Filter the combined dataset using WHERE cars.Car_ID = 1 to select specific vehicle  【step3】: Calculate City_Distance by dividing Fuel_Tank_Capacity by (Fuel_Consumption_City/100), and Highway_Distance using (Fuel_Consumption_Highway/100) to convert L/100km unit to distance coverage",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 387,
        "question": "If a car has a cargo capacity of 500 liters and its trunk capacity is 300 liters, what is the maximum cargo weight it can carry?",
        "query": "SELECT Cargo_Capacity * 1 AS Max_Cargo_Weight FROM dimensions WHERE Cargo_Capacity = 500 AND Trunk_Capacity = 300;",
        "step": "【step1】: Filter records in dimensions table where Cargo_Capacity equals 500L and Trunk_Capacity equals 300L  【step2】: Multiply Cargo_Capacity by 1 (assuming 1L cargo volume = 1kg weight conversion) to calculate Max_Cargo_Weight  【step3】: Output the calculated Max_Cargo_Weight value directly from the filtered record",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 388,
        "question": "If a car has an engine displacement of 2.0L, a maximum speed of 8000 RPM, 4 cylinders, and a compression ratio of 10:1, how many combustion events occur per minute at maximum speed?",
        "query": "SELECT Max_RPM / 2 * Cylinder_Count AS Combustion_Per_Minute FROM engine_specs WHERE Displacement = 2.0 AND Max_RPM = 8000 AND Cylinder_Count = 4 AND Compression_Ratio = 10;",
        "step": "【step1】: Filter engine specifications matching parameters (2.0L displacement, 8000 RPM, 4 cylinders, 10:1 compression ratio)  【step2】: Calculate combustion events per cylinder per minute using Max_RPM/2 (four-stroke engines fire once every 2 revolutions)  【step3】: Multiply by cylinder count to derive total combustion events per minute across all cylinders",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 389,
        "question": "A vehicle with a curb weight of 1200 kg, a braking distance of 36 meters, a brake assist response time of 0.2 seconds, and an engine torque of 250 Nm is braking from 100 km/h to a complete stop. With a recovery efficiency of 60% and uniform deceleration during braking, calculate the maximum electrical energy that can be stored by the regenerative braking system.",
        "query": "SELECT c.Weight, pm.Braking_Distance, sf.Brake_Assist_Response_Time, es.Torque FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID JOIN safety_features sf ON c.Car_ID = sf.Car_ID JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Car_ID = 1;",
        "step": "【step1】: Retrieve base vehicle data from 'cars' table by filtering Car_ID=1  【step2】: Join with 'performance_metrics' using Car_ID to access Braking_Distance  【step3】: Join with 'safety_features' and 'engine_specs' via Car_ID to obtain Brake_Assist_Response_Time and Torque",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 390,
        "question": "A hybrid vehicle has a fuel tank capacity of 45L, a battery capacity of 18kWh, an electric-only range of 80km, and a fuel range of 600km. If the user has a total weekly commute of 840km (120km daily), with 40% on urban roads and 60% on highways, calculate the minimum number of times they need to refuel and recharge per week.",
        "query": "SELECT c.Fuel_Tank_Capacity, c.Battery_Capacity, pm.Range_Hybrid, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;",
        "step": "【step1】: Join the 'cars' and 'performance_metrics' tables using Car_ID to combine technical specifications and range data.  【step2】: Apply the WHERE clause to filter results for Car_ID = 1, targeting the specific hybrid vehicle.  【step3】: Select the required columns (Fuel_Tank_Capacity, Battery_Capacity, Range_Hybrid, Range_Electric) to retrieve core parameters for calculation.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 391,
        "question": "An MPV has 7 seats, with a standard trunk capacity of 500L and a maximum expanded capacity of 1800L. When transporting 20 boxes measuring 0.6m × 0.4m × 0.3m each, how should the seating layout be adjusted to optimize loading?",
        "query": "SELECT c.Seating_Capacity, d.Trunk_Capacity, d.Cargo_Capacity FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID WHERE c.Car_ID = 1;",
        "step": "【step1】: JOIN cars and dimensions tables using Car_ID to access seating and cargo data  【step2】: Filter records for specific vehicle (Car_ID=1) using WHERE clause  【step3】: Select critical capacity metrics - Seating_Capacity, Trunk_Capacity, Cargo_Capacity",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 392,
        "question": "A certain car has a maximum engine speed of 9000 RPM, with 8 cylinders, and a fuel tank capacity of 70 liters. If it continuously travels at its top speed (with a fuel consumption of 45 liters per 100 km under these conditions), calculate how many fuel tanker trucks are needed to support its journey across the Taklamakan Desert (approximately 1000 km in length).",
        "query": "SELECT es.Max_RPM, es.Cylinder_Count, c.Fuel_Tank_Capacity, es.Fuel_Consumption_Highway FROM engine_specs es JOIN cars c ON es.Car_ID=c.Car_ID JOIN performance_metrics pm ON c.Car_ID=pm.Car_ID WHERE c.Car_ID=123;",
        "step": "【step1】: Filter the cars table to retrieve fuel tank capacity for car ID 123  【step2】: Join engine_specs to get max RPM, cylinder count, and highway fuel consumption  【step3】: Join performance_metrics (though unused in SELECT) to maintain query structure alignment",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 393,
        "question": "When a certain car with ID 123 is traveling at its top speed under maximum power, what is the total resistance that the engine's traction force needs to overcome?",
        "query": "SELECT e.Horsepower, p.Top_Speed, d.Length, d.Width, d.Curb_Weight FROM engine_specs e JOIN performance_metrics p ON e.Car_ID = p.Car_ID JOIN dimensions d ON e.Car_ID = d.Car_ID WHERE e.Car_ID = 123;",
        "step": "【step1】: Join engine_specs with performance_metrics using Car_ID to link horsepower and top_speed  【step2】: Join result with dimensions table via Car_ID to obtain vehicle physical parameters  【step3】: Filter combined data by Car_ID=123 to retrieve specific vehicle's resistance-related metrics",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 394,
        "question": "What is the proportion of the total profit of the top 5 best-selling car models by a manufacturer to the manufacturer's annual profit?",
        "query": "SELECT c.Model, c.Production_Volume, p.Total_Price, m.Profit_Margin FROM cars c JOIN prices p ON c.Car_ID = p.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Manufacturer_ID = 123 ORDER BY c.Production_Volume DESC LIMIT 5;",
        "step": "【step1】: Retrieve the manufacturer's total annual profit from the 'manufacturers' table using Profit_Margin and Revenue.  【step2】: Calculate the total profit of the top 5 models by joining 'cars', 'prices', and 'manufacturers', then summing (Production_Volume × Total_Price × Profit_Margin) for the top-ranked models.  【step3】: Divide the top 5 models' total profit by the manufacturer's total annual profit to get the percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 395,
        "question": "After a conventional fuel-powered car's tank is fully filled, what is the maximum number of hours it can sustain continuous driving on a highway, given the car's fuel tank capacity and highway fuel efficiency?",
        "query": "SELECT c.Fuel_Tank_Capacity, c.Fuel_Efficiency_Highway FROM cars c WHERE c.Car_ID = 123;",
        "step": "",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 396,
        "question": "What is the braking distance for the car with Car_ID 123, given its airbag count and curb weight?",
        "query": "SELECT s.Airbag_Count, d.Curb_Weight, p.Braking_Distance FROM safety_features s JOIN dimensions d ON s.Car_ID = d.Car_ID JOIN performance_metrics p ON s.Car_ID = p.Car_ID WHERE s.Car_ID = 123;",
        "step": "【step1】: Retrieve the car's airbag count from the safety_features table for Car_ID=123.  【step2】: Join with dimensions table via Car_ID to get curb_weight.  【step3】: Join with performance_metrics table via Car_ID to fetch braking_distance.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 397,
        "question": "If a car weighs 1500kg and its 0-100 acceleration time is 8 seconds, what is its weight and 0-100 acceleration time?",
        "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;",
        "step": "【step1】: JOIN the `cars` table with `performance_metrics` using `Car_ID` to link the vehicle's basic information and performance data.  【step2】: Filter the results using `WHERE` to match entries where `Weight` is 1500 kg and `Acceleration_0_to_100` is 8 seconds.  【step3】: Select the specific columns `Weight` and `Acceleration_0_to_100` from the joined tables to retrieve the required data.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 398,
        "question": "A car manufacturer has a total production quantity of 500,000 vehicles, annual sales of 450,000 vehicles, R&D expenditures of $200 million, and a profit margin of 8%. Calculate the manufacturer's revenue, total profit, and the average R&D cost per vehicle.",
        "query": "SELECT Production_Volume_Total, Annual_Sales, `R&D_Spending`, Profit_Margin FROM manufacturers WHERE Production_Volume_Total = 500000 AND Annual_Sales = 450000 AND `R&D_Spending` = 200000000 AND Profit_Margin = 8;",
        "step": "【step1】: Filter the manufacturers table to find the record matching the given criteria (Production_Volume_Total=500000, Annual_Sales=450000, R&D_Spending=200000000, Profit_Margin=8%) using the WHERE clause.  【step2】: Calculate Total Revenue by multiplying Annual_Sales with Average_Price from the filtered record.  【step3】: Compute Total Profit as Total_Revenue × (Profit_Margin/100) and Average R&D Cost per vehicle as R&D_Spending ÷ Production_Volume_Total using arithmetic operations.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 399,
        "question": "A car has a fuel tank capacity of 60L, with a city fuel efficiency of 10km/L and a highway fuel efficiency of 15km/L. If the owner drives 200km in the city and 200km on the highway, how much fuel is consumed in total?",
        "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Fuel_Tank_Capacity = 60 AND Fuel_Efficiency_City = 10 AND Fuel_Efficiency_Highway = 15;",
        "step": "【step1】:【Filter cars with specified fuel parameters】 SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Fuel_Tank_Capacity = 60 AND Fuel_Efficiency_City = 10 AND Fuel_Efficiency_Highway = 15  【step2】:【Calculate fuel consumption components】 SELECT (200 / Fuel_Efficiency_City) AS City_Consumption, (200 / Fuel_Efficiency_Highway) AS Highway_Consumption FROM filtered_cars  【step3】:【Sum total fuel consumption】 SELECT City_Consumption + Highway_Consumption AS Total_Fuel_Used FROM consumption_components",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 400,
        "question": "If a car's engine has a maximum RPM of 10000 and a torque of 500 Nm, running continuously at maximum RPM for 1 hour, what is the total mechanical energy output?",
        "query": "SELECT Max_RPM, Torque FROM engine_specs WHERE Max_RPM = 10000 AND Torque = 500;",
        "step": "【step1】: Access the 'engine_specs' table to retrieve engine performance data.  【step2】: Apply the filter condition `WHERE Max_RPM = 10000 AND Torque = 500` to isolate the specific engine configuration.  【step3】: Select the `Max_RPM` and `Torque` fields from the filtered records for energy calculation.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 401,
        "question": "A car has a top speed of 240 km/h and a curb weight of 1800 kg. If it comes to a complete stop during emergency braking, what is the amount of kinetic energy reduction in joules?",
        "query": "SELECT ROUND(0.5 * d.Curb_Weight * POWER(p.Top_Speed/3.6, 2)) AS KineticEnergy_J FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID WHERE p.Top_Speed = 240 AND d.Curb_Weight = 1800;",
        "step": "【step1】: JOIN performance_metrics and dimensions tables via Car_ID to combine vehicle speed and weight data  【step2】: Filter records where Top_Speed=240 km/h AND Curb_Weight=1800 kg  【step3】: Calculate kinetic energy reduction using formula: ROUND(0.5 × mass × (speed_in_m/s)^2) with unit conversions (km/h→m/s via ÷3.6)",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 402,
        "question": "A manufacturer produces 100,000 cars with an average selling price of $35,000 and a profit margin of 15%. If research and development expenses account for 15% of the revenue, what is the actual net profit?",
        "query": "SELECT (m.Production_Volume_Total * m.Average_Price * 0.85 * m.Profit_Margin/100) AS NetProfit FROM manufacturers m WHERE m.Name = '某制造商' AND m.Production_Volume_Total = 100000 AND m.Average_Price = 35000;",
        "step": "【step1】: Filter the manufacturer's record with specified production volume and price  【step2】: Calculate gross revenue (100,000 × $35,000)  【step3】: Deduct 15% R&D spending and apply 8% profit margin to derive net profit: (Gross Revenue × 0.85 × 0.08)",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 403,
        "question": "The ABS efficiency of a certain car is 95%, and its base braking distance is 40 meters. How much will the actual braking distance increase in meters when accounting for a 30% reduction in road friction?",
        "query": "SELECT s.ABS_Effectiveness, p.Braking_Distance, ROUND((p.Braking_Distance/(s.ABS_Effectiveness/100) * 1.3) - p.Braking_Distance, 1) AS RainIncrease_m FROM safety_features s JOIN performance_metrics p USING(Car_ID) WHERE s.ABS_Effectiveness = 95 AND p.Braking_Distance = 40;",
        "step": "【step1】: Perform JOIN operation between safety_features and performance_metrics tables using Car_ID to combine ABS effectiveness and braking distance data  【step2】: Apply WHERE clause to filter records where ABS_Effectiveness = 95% AND Braking_Distance = 40 meters  【step3】: Calculate increased braking distance using formula: (Base_Distance/(ABS_Efficiency/100)*1.3) - Base_Distance, then round result to 1 decimal place",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 404,
        "question": "If an engine has a displacement of 100L with 16 cylinders, and runs at 6000 revolutions per minute, what is its theoretical hourly fuel consumption in liters? (Each cycle consumes 1.2 times the displacement of fuel.)",
        "query": "SELECT e.Displacement, e.Cylinder_Count, (e.Displacement * e.Max_RPM * e.Cylinder_Count * 1.2 * 60)/1000 AS TheoreticalFuel_L_h FROM engine_specs e WHERE e.Displacement = 100 AND e.Cylinder_Count = 16 AND e.Max_RPM = 6000;",
        "step": "【step1】: Filter engine_specs records where Displacement=100L, Cylinder_Count=16, and Max_RPM=6000  【step2】: Calculate fuel consumption per engine cycle: (Displacement × 1.2) for all cylinders  【step3】: Multiply by RPM cycles per minute and convert to hourly liters: (result × Cylinder_Count × Max_RPM × 60)/1000",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 405,
        "question": "The top speed of a certain car is 210 km/h, with a curb weight of 1500 kg. When traveling at high speed, it has a drag coefficient of 0.28, a frontal area of 2.3 m², and an air density of 1.225 kg/m³. Calculate the power required to overcome air resistance to maintain this speed?",
        "query": "SELECT  (0.5 * 1.225 * pm.Drag_Coefficient * 2.3 * POWER((pm.Top_Speed*1000/3600),3)) AS Air_Power FROM performance_metrics pm JOIN dimensions d ON pm.Car_ID = d.Car_ID WHERE pm.Top_Speed = 210 AND d.Curb_Weight = 1500 AND pm.Drag_Coefficient = 0.28 LIMIT 1;",
        "step": "【step1】: Filter performance_metrics and dimensions tables to find the car with Top_Speed=210km/h, Curb_Weight=1500kg, and Drag_Coefficient=0.28  【step2】: Join the filtered tables using Car_ID to combine required parameters  【step3】: Calculate air resistance power using formula 0.5*ρ*Cd*A*v³, converting speed units from km/h to m/s and applying cubic power",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 406,
        "question": "A manufacturer produces cars with an average weight of 1800 kg. When a fleet of 500 of these models travels at a constant speed of 120 km/h, with a rolling resistance coefficient of 0.015, air density of 1.225 kg/m³, drag coefficient of 0.3, and frontal area of 2.5 m², calculate the total energy consumed (in joules) by the fleet after continuously traveling 100 kilometers?",
        "query": "SELECT   ( (1800*9.8*0.015 + 0.5*1.225*0.3*2.5*POWER(120/3.6,2)) * 100000 ) * 500 AS Total_Energy FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = '某制造商' GROUP BY m.Name LIMIT 1;",
        "step": "【step1】: Join the `dimensions`, `cars`, and `manufacturers` tables to filter vehicles from the specified manufacturer.  【step2】: Calculate energy per vehicle using the formula: `(weight×gravity×rolling_coeff + 0.5×air_density×drag_coeff×frontal_area×velocity²) × distance`, then multiply by 500 vehicles.  【step3】: Aggregate and return the total energy by grouping on the manufacturer name, enforcing a single result with `LIMIT 1`.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 407,
        "question": "A fuel car has a fuel tank capacity of 60L, with a highway fuel consumption of 6.5L/100km. When the fuel gauge shows 15% remaining, what is the maximum distance it can continue to travel on a highway?",
        "query": "SELECT  (c.Fuel_Tank_Capacity*0.15 / es.Fuel_Consumption_Highway)*100 AS Remaining_Range FROM cars c JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Fuel_Tank_Capacity = 60 AND es.Fuel_Consumption_Highway = 6.5 AND c.Battery_Capacity IS NULL LIMIT 1;",
        "step": "【step1】: JOIN cars and engine_specs tables using Car_ID to combine vehicle configuration and fuel consumption data  【step2】: Filter records matching Fuel_Tank_Capacity=60L, Fuel_Consumption_Highway=6.5L/100km, and Battery_Capacity IS NULL to isolate gasoline-powered vehicles  【step3】: Calculate remaining range using formula (60*0.15/6.5)*100 and return single result with LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 408,
        "question": "If the battery capacity of an electric vehicle is 99999 kWh, with the curb weight remaining at 2000 kg, a drag coefficient of 0.21, and an energy consumption of 15 kWh per 100 km, how many theoretical laps around the equator (which has a circumference of 40075 km) can it complete?",
        "query": "SELECT  (99999/(15/100))/40075 AS Theoretical_Laps FROM cars c JOIN dimensions d ON c.Car_ID = d.Car_ID JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Battery_Capacity IS NOT NULL AND d.Curb_Weight = 2000 AND pm.Drag_Coefficient = 0.21 LIMIT 1;",
        "step": "【step1】: Join the 'cars', 'dimensions', and 'performance_metrics' tables using Car_ID to link vehicle specifications, filtering records where Battery_Capacity is not NULL, Curb_Weight equals 2000kg, and Drag_Coefficient equals 0.21.  【step2】: Calculate total theoretical range using formula: (99999 kWh capacity) / (15 kWh/100km consumption) = total range in kilometers.  【step3】: Divide the total range by Earth's equatorial circumference (40075 km) to get laps, and output the result as Theoretical_Laps with LIMIT 1 constraint.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 409,
        "question": "What is the kinetic energy of a certain fuel-powered vehicle when traveling at its top speed? This requires calculating based on the vehicle's curb weight and top speed, and the query only considers vehicles with a displacement above 0 and highway fuel consumption above 0.",
        "query": "SELECT d.Curb_Weight, p.Top_Speed, 0.5 * d.Curb_Weight * POWER((p.Top_Speed/3.6),2) AS Kinetic_Energy_J FROM dimensions d JOIN performance_metrics p ON d.Car_ID = p.Car_ID JOIN engine_specs e ON d.Car_ID = e.Car_ID WHERE e.Displacement > 0 AND e.Fuel_Consumption_Highway > 0;",
        "step": "【step1】: Join the dimensions table with performance_metrics using Car_ID to access curb weight and top speed values.  【step2】: Further join engine_specs using Car_ID to filter vehicles with displacement > 0 and fuel consumption data (indicating fuel-powered engines).  【step3】: Calculate kinetic energy using the formula 0.5 * Curb_Weight * (Top_Speed converted to m/s)^2 and return results.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 410,
        "question": "Calculate the total cost of ownership over five years for a vehicle model, taking into account the base price, annual maintenance costs, depreciation rate, and insurance expenses, while also considering the impact of tax rates.",
        "query": "SELECT pr.Base_Price, pr.Maintenance_Cost, pr.Depreciation_Rate, pr.Insurance_Cost, pr.Tax_Rate, (pr.Total_Price*(1+pr.Tax_Rate/100)) + (pr.Maintenance_Cost*5) + (pr.Base_Price*(1-POWER(1-pr.Depreciation_Rate/100,5))) - pr.Insurance_Cost AS Total_5yr_Cost FROM prices pr JOIN cars c ON pr.Car_ID = c.Car_ID WHERE c.Range IS NOT NULL;",
        "step": "【step1】: Join the `prices` table with the `cars` table using `Car_ID` to retrieve pricing data and vehicle specifications.  【step2】: Filter results where `Range` is not null to focus on electric/hybrid vehicles.  【step3】: Calculate the 5-year total ownership cost by combining taxed total price, cumulative maintenance costs, depreciation-adjusted base price, and subtracting insurance costs.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 411,
        "question": "What is the maximum distance in kilometers that a full tank of fuel allows a car to travel under pure urban road conditions, given the car's fuel tank capacity and city fuel consumption?",
        "query": "SELECT c.Model, c.Fuel_Tank_Capacity, e.Fuel_Consumption_City, (c.Fuel_Tank_Capacity * (100 / e.Fuel_Consumption_City)) AS City_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity > 0 AND e.Fuel_Consumption_City > 0;",
        "step": "【step1】: Perform INNER JOIN between cars and engine_specs tables using Car_ID to combine fuel capacity and consumption data  【step2】: Filter records where Fuel_Tank_Capacity > 0 AND Fuel_Consumption_City > 0 to ensure valid calculation inputs  【step3】: Calculate City_Range by multiplying Fuel_Tank_Capacity with (100 / Fuel_Consumption_City) to convert consumption (L/100km) to range (km)",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 412,
        "question": "A certain vehicle is equipped with at least a 2.0L displacement engine but has at most a 2L fuel tank, with a high-speed fuel consumption of at least 50L/100km. How many meters can it continuously drive at full fuel?",
        "query": "SELECT c.Model, e.Displacement, c.Fuel_Tank_Capacity, e.Fuel_Consumption_Highway, (c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway) * 100000 AS Absurd_Range_m FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE e.Displacement >= 20 AND c.Fuel_Tank_Capacity <= 2 AND e.Fuel_Consumption_Highway >= 50;",
        "step": "【step1】: JOIN cars and engine_specs tables using Car_ID to combine vehicle data with engine specifications.  【step2】: Apply WHERE conditions (Displacement ≥ 20L, Fuel_Tank_Capacity ≤ 2L, Fuel_Consumption_Highway ≥ 50L/100km) to filter absurd parameter mismatches.  【step3】: Calculate range by (Fuel_Tank_Capacity / Fuel_Consumption_Highway) * 100000 (unit conversion from 100km to meters) and select output fields.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 413,
        "question": "The engine torque of a certain car model is 450 Nm, the curb weight is 1500 kg, and the electronic stability control system efficiency is 95%. Calculate the theoretical acceleration of the vehicle during full-throttle acceleration.",
        "query": "SELECT (e.Torque * (s.ESC_Effectiveness / 100)) / (d.Curb_Weight * 0.3) AS Acceleration FROM engine_specs e JOIN dimensions d ON e.Car_ID = d.Car_ID JOIN safety_features s ON e.Car_ID = s.Car_ID WHERE e.Torque = 450 AND d.Curb_Weight = 1500 AND s.ESC_Effectiveness = 95",
        "step": "【step1】: Join three tables (engine_specs, dimensions, safety_features) using Car_ID to access torque, curb weight, and ESC effectiveness data  【step2】: Filter records where engine torque equals 450 Nm, curb weight equals 1500 kg, and ESC effectiveness equals 95%  【step3】: Calculate acceleration using formula (Torque × ESC_efficiency%) / (Curb_weight × wheel_radius) with unit conversions applied",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 414,
        "question": "The car's urban fuel consumption is 8 L/100km, highway fuel consumption is 6 L/100km, and fuel tank capacity is 60 L. The crash test rating is 4.5 points (out of 5), and the proportion of city driving is 60% plus 10% for every point above 0, with 4.5 points used in the calculation. Calculate its combined fuel consumption and maximum range.",
        "query": "SELECT (8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1))) AS Combined_Fuel, 60 / ((8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1)))/100) AS `Range`;",
        "step": "【step1】: Retrieve base parameters by joining relevant tables: `engine_specs.Fuel_Consumption_City`, `engine_specs.Fuel_Consumption_Highway`, `safety_features.Crash_Test_Rating`, and `cars.Fuel_Tank_Capacity` via `Car_ID`  【step2】: Calculate urban driving ratio adjustment: `0.6 + (Crash_Test_Rating/5)*0.1`  【step3】: Compute final metrics using derived ratio:  - `Combined_Fuel = (Urban_Fuel * Adjusted_Ratio) + (Highway_Fuel * (1 - Adjusted_Ratio))`  - `Range = Fuel_Tank_Capacity / (Combined_Fuel/100)`",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 415,
        "question": "Is there a correlation between the number of airbags and the crash test rating across all car models?",
        "query": "SELECT (SUM(Airbag_Count * Crash_Test_Rating) - (SUM(Airbag_Count) * SUM(Crash_Test_Rating)) / COUNT(*)) / (COUNT(*) * (SUM(Airbag_Count * Airbag_Count) - POW(SUM(Airbag_Count),2)/COUNT(*))) AS Correlation FROM safety_features",
        "step": "【step1】: Calculate covariance between Airbag_Count and Crash_Test_Rating using formula: SUM(Airbag_Count * Crash_Test_Rating) - (SUM(Airbag_Count) * SUM(Crash_Test_Rating)) / COUNT(*)  【step2】: Compute variance of Airbag_Count using formula: COUNT(*) * (SUM(Airbag_Count * Airbag_Count) - POW(SUM(Airbag_Count),2)/COUNT(*))  【step3】: Divide covariance by Airbag_Count variance to calculate correlation coefficient, which measures linear relationship strength but cannot confirm causation or exclusivity of factors.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 416,
        "question": "A car has an engine horsepower of 100,000 HP and a curb weight of 1 kg. Calculate its power-to-weight ratio and estimate the 0-100 km/h acceleration time (ignoring air resistance and friction).",
        "query": "SELECT e.Horsepower / d.Curb_Weight AS Power_Ratio, (100/3.6) / ((e.Horsepower / d.Curb_Weight) * 745.7 / (100/3.6)) AS Acceleration_Time FROM engine_specs e JOIN dimensions d USING(Car_ID) WHERE e.Horsepower = 100000 AND d.Curb_Weight = 1",
        "step": "【step1】: JOIN engine_specs and dimensions tables via Car_ID to combine horsepower and curb weight data  【step2】: Filter records where horsepower equals 100000 HP and curb weight equals 1 kg  【step3】: Calculate power-to-weight ratio (Horsepower/Curb_Weight) and derive acceleration time using kinematic formula (velocity divided by acceleration derived from power-to-weight ratio converted to watts/kg)",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 417,
        "question": "For a Tesla Model S, what is the air resistance in newtons that the vehicle needs to overcome when it reaches its top speed?",
        "query": "SELECT    p.Top_Speed,   d.Width,   d.Height,   0.5 * 1.225 * p.Drag_Coefficient * (d.Width * d.Height) * POWER(p.Top_Speed/3.6, 2) AS Air_Resistance_Newtons FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID JOIN cars c ON p.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' AND c.Model = 'Tesla Model S'",
        "step": "【step1】: Join manufacturers, cars, performance_metrics and dimensions tables to filter records where manufacturer name and model match specifications.  【step2】: Retrieve necessary calculation parameters: Top_Speed, Drag_Coefficient from performance_metrics, Width and Height from dimensions.  【step3】: Apply air resistance formula: 0.5 * air density (1.225 kg/m³) * drag coefficient * frontal area (width×height) * (speed in m/s)². Convert km/h to m/s via ÷3.6.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 418,
        "question": "Calculate the total annual carbon emissions in tonnes for Tesla's vehicle models.",
        "query": "SELECT    SUM(e.CO2_Emissions * m.Annual_Sales * 15000 / 1000000) AS Total_CO2_Tonnes FROM manufacturers m JOIN cars c ON m.Manufacturer_ID = c.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE m.Name = 'Tesla'",
        "step": "【step1】: Filter manufacturers by name and join with cars to get all vehicle models under the specified manufacturer.  【step2】: Join the result with engine_specs to obtain CO2 emissions data per vehicle.  【step3】: Sum the product of CO2 emissions (g/km), annual sales, and average annual driving distance (15,000 km), then convert to tonnes by dividing by 1,000,000.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 419,
        "question": "Can a Tesla Model S pass a bridge with a weight limit of 2.5 tons when fully loaded?",
        "query": "SELECT    d.Curb_Weight,   d.Cargo_Capacity,   (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) AS Total_Weight,   CASE WHEN (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) <= 2500 THEN '安全' ELSE 'overweight' END AS Safety_Status FROM dimensions d JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S'",
        "step": "【step1】: Join cars and dimensions tables to retrieve weight-related data for the specified SUV model  【step2】: Calculate total weight using formula: Curb_Weight + 350kg (passengers/luggage) + (Cargo_Capacity * 0.7kg/L conversion)  【step3】: Compare total weight against 2500kg threshold and generate safety status using CASE statement",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 420,
        "question": "Does the Tesla Model S's G-force exceed 3G when its power-to-weight ratio is 10 times the norm?",
        "query": "SELECT    p.Power_to_Weight_Ratio,   c.Weight,   (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) AS G_Force,   CASE WHEN (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) > 3 THEN '超过' ELSE '未超过' END AS Comparison FROM performance_metrics p JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S'",
        "step": "【step1】: Join `performance_metrics` and `cars` tables via `Car_ID`, filter for `c.Model = '指定跑车型号'` to isolate the target car.  【step2】: Calculate the G-force using the formula `(Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * Weight)`, where 745.7 converts horsepower to watts and 9.8 represents gravitational acceleration.  【step3】: Apply a `CASE` statement to classify results as \"超过\" (exceeds) or \"未超过\" (does not exceed) based on whether the calculated G-force surpasses 3G.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 421,
        "question": "Calculate whether the horsepower of a Tesla Model S's engine, when traveling at its top speed on a highway, is sufficient to overcome air resistance, given an air density of 1.225 kg/m³, a drag coefficient of 0.3, and a frontal area of 2.5 m² for the car.",
        "query": "SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Tesla Model S';",
        "step": "【step1】: Filter cars table to retrieve target model's Car_ID and join performance_metrics to get Top_Speed  【step2】: Join engine_specs to obtain Horsepower value for the selected Car_ID  【step3】: Calculate air resistance using physics formula with Top_Speed (converted to m/s), fixed air density (1.225), drag coefficient (0.3), and frontal area (2.5)",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 422,
        "question": "Calculate the average fuel efficiency of all cars from Tesla and identify the top three models with the highest fuel efficiency.",
        "query": "SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;",
        "step": "【step1】: Join cars and manufacturers tables to filter vehicles from the specified manufacturer.  【step2】: Calculate average fuel efficiency using (Fuel_Efficiency_City + Fuel_Efficiency_Highway)/2 and sort results in descending order.  【step3】: Limit output to top 3 models with the highest average fuel efficiency using ORDER BY and LIMIT clauses.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 423,
        "question": "Estimate the per-kilometer fuel cost of the Tesla Model S in city and highway driving, with the fuel price at $1.2 per liter.",
        "query": "SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = '某款汽车';",
        "step": "【step1】: Access the 'cars' table and filter records where Model is '某款汽车' using WHERE clause  【step2】: Calculate City_Cost_Per_KM via (1 / Fuel_Efficiency_City) * 1.2 and Highway_Cost_Per_KM via (1 / Fuel_Efficiency_Highway) * 1.2 in SELECT clause  【step3】: Project Model, City_Cost_Per_KM, and Highway_Cost_Per_KM as final output",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 424,
        "question": "If the battery capacity of a Tesla Model S is increased to 1000 kWh, calculate whether its range will exceed 10,000 km, given an energy consumption of 0.2 kWh per kilometer.",
        "query": "SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = '某款汽车';",
        "step": "【step1】: Filter the '某款汽车' record from the cars table using WHERE c.Model = 'Tesla Model S'.  【step2】: Calculate the theoretical range by dividing the hypothetical battery capacity (1000 kWh) by the energy consumption per km (0.2 kWh/km) with 1000 / 0.2 AS Theoretical_Range.  【step3】: Output the Model and the calculated Theoretical_Range to verify if it exceeds 10,000 km (the result will be 5,000 km, so no).",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 425,
        "question": "Calculate the rolling resistance for the Tesla Model S using the formula 0.015 multiplied by its weight multiplied by 9.81, and compare it with the engine torque to determine if the torque is sufficient to overcome the rolling resistance.",
        "query": "SELECT c.Model, e.Torque, (0.015 * c.Weight * 9.81) AS Rolling_Resistance FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = '某款汽车';",
        "step": "【step1】: Perform an INNER JOIN between `cars` and `engine_specs` tables using `Car_ID` to combine vehicle specifications with engine torque data.  【step2】: Apply a WHERE filter to select only the row where `Model` equals '某款汽车', narrowing the dataset to the specific vehicle.  【step3】: Calculate the rolling resistance value `(0.015 * Weight * 9.81)` and project the result alongside the engine torque for direct comparison of torque vs. resistance.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 426,
        "question": "Calculate the average carbon dioxide emissions of Tesla cars and identify the top three models with the lowest emissions.",
        "query": "SELECT c.Model, AVG(e.CO2_Emissions) AS Avg_CO2_Emissions FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' GROUP BY c.Model ORDER BY Avg_CO2_Emissions ASC LIMIT 3;",
        "step": "【step1】: Join cars, engine_specs, and manufacturers tables using Car_ID and Manufacturer_ID to link CO2 emissions data with specific models and manufacturer info.  【step2】: Filter by 'Tesla', calculate average CO2 emissions per model via GROUP BY c.Model, and compute AVG(e.CO2_Emissions).  【step3】: Sort results by Avg_CO2_Emissions in ascending order and apply LIMIT 3 to retrieve the top 3 lowest-emitting models.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 427,
        "question": "Estimate the per-kilometer carbon dioxide emissions of a Tesla Model S in urban and highway conditions based on the car's fuel efficiency, with each liter of fuel producing 2.31 kg of carbon dioxide.",
        "query": "SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 2.31 AS City_CO2_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 2.31 AS Highway_CO2_Per_KM FROM cars c WHERE c.Model = '某款汽车';",
        "step": "【step1】:【Filter the 'cars' table to find the specific model '某款汽车' using WHERE clause】  【step2】:【Calculate CO2 emissions per kilometer by inverting fuel efficiency values (km/L) to get L/km, then multiplying by 2.31 kg/L (City_CO2_Per_KM and Highway_CO2_Per_KM)】",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 428,
        "question": "If the battery capacity of a Tesla Model S increases to 5000 kWh, calculate whether its range will exceed 50,000 km, with an energy consumption of 0.1 kWh per kilometer.",
        "query": "SELECT c.Model, 5000 / 0.1 AS Theoretical_Range FROM cars c WHERE c.Model = '某款汽车';",
        "step": "【step1】: Filter the cars table to retrieve the target model using `WHERE c.Model = '某款汽车'`.  【step2】: Calculate the theoretical range by dividing the hypothetical battery capacity (5000 kWh) by the energy consumption per kilometer (0.1 kWh/km) via `5000 / 0.1`.  【step3】: Return the model name and the computed theoretical range to verify if it exceeds 50,000 km.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 429,
        "question": "Calculate the total fuel consumption of a certain car for 100 kilometers driven on city roads and 100 kilometers driven on highways.",
        "query": "SELECT Car_ID, Model, (100 / Fuel_Efficiency_City) + (100 / Fuel_Efficiency_Highway) AS Total_Fuel_Consumption FROM cars;",
        "step": "【step1】: Retrieve vehicle identifiers and efficiency metrics from the cars table  【step2】: Calculate city fuel consumption using (100 / Fuel_Efficiency_City)  【step3】: Calculate highway fuel consumption using (100 / Fuel_Efficiency_Highway) and sum both values as Total_Fuel_Consumption",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 430,
        "question": "Calculate the ratio of the gross weight to the curb weight for each car model, and identify the top 5 car models with the highest ratio.",
        "query": "SELECT d.Car_ID, c.Model, d.Gross_Weight / d.Curb_Weight AS Weight_Ratio FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID ORDER BY Weight_Ratio DESC LIMIT 5;",
        "step": "【step1】: Join 'dimensions' and 'cars' tables using Car_ID to combine weight attributes with car model information.  【step2】: Calculate Gross_Weight/Curb_Weight ratio as Weight_Ratio for each car.  【step3】: Sort results by Weight_Ratio in descending order and limit to the top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 431,
        "question": "Find the top 10 cars with the highest average fuel efficiency among all cars produced in 2020, sorted by average fuel efficiency in descending order.",
        "query": "SELECT Car_ID, Model, (Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars WHERE Year = 2020 ORDER BY Avg_Fuel_Efficiency DESC LIMIT 10;",
        "step": "【step1】: Filter cars produced in 2020 using WHERE Year = 2020  【step2】: Calculate average fuel efficiency using (Fuel_Efficiency_City + Fuel_Efficiency_Highway)/2  【step3】: Sort results by Avg_Fuel_Efficiency DESC and limit to top 10 records",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 432,
        "question": "If the fuel tank capacity of a certain car is 1,000 liters and its urban fuel efficiency is 1 km/L, what is the amount of fuel required for the car to travel 10,000 kilometers in the city?",
        "query": "SELECT Car_ID, Model, 10000 / 1 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 1;",
        "step": "【step1】: Filter cars table to find vehicles with Fuel_Tank_Capacity=1000L and Fuel_Efficiency_City=1 km/L using WHERE clause  【step2】: Calculate required fuel by performing division operation 10000 / Fuel_Efficiency_City (implicitly 10000/1)  【step3】: Project Car_ID, Model, and calculated Required_Fuel column through SELECT clause",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "1",
        "idx": 433,
        "question": "Calculate the power-to-weight ratio (HP/kg) of cars and identify the top 5 car models with the highest power-to-weight ratio.",
        "query": "SELECT p.Car_ID, c.Model, p.Power_to_Weight_Ratio FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID ORDER BY p.Power_to_Weight_Ratio DESC LIMIT 5;",
        "step": "【step1】: Join the `performance_metrics` table with the `cars` table using `Car_ID` to combine car models with their power-to-weight ratios.  【step2】: Order the results by `Power_to_Weight_Ratio` in descending order to prioritize higher values.  【step3】: Limit the output to the top 5 records using `LIMIT 5` to fulfill the \"highest\" requirement.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "2",
        "idx": 434,
        "question": "Calculate the carbon dioxide emissions of each car model after driving 100 kilometers in urban conditions and 100 kilometers in highway conditions.",
        "query": "SELECT e.Car_ID, c.Model, (e.Fuel_Consumption_City * 100 / 100) * e.CO2_Emissions + (e.Fuel_Consumption_Highway * 100 / 100) * e.CO2_Emissions AS Total_CO2_Emissions FROM engine_specs e JOIN cars c ON e.Car_ID = c.Car_ID;",
        "step": "【step1】: Perform an INNER JOIN between `engine_specs` and `cars` tables using `Car_ID` to link engine specifications with car model information.  【step2】: Calculate CO₂ emissions for 100km city driving (`Fuel_Consumption_City * CO2_Emissions`) and 100km highway driving (`Fuel_Consumption_Highway * CO2_Emissions`).  【step3】: Sum the two calculated values to produce the final `Total_CO2_Emissions` for the combined 200km distance.",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "3",
        "idx": 435,
        "question": "Find the top 10 cars produced in 2020 with the highest number of airbags, sorted in descending order by the number of airbags.",
        "query": "SELECT s.Car_ID, c.Model, s.Airbag_Count FROM safety_features s JOIN cars c ON s.Car_ID = c.Car_ID WHERE c.Year = 2020 ORDER BY s.Airbag_Count DESC LIMIT 10;",
        "step": "【step1】: Perform INNER JOIN between 'safety_features' and 'cars' tables using Car_ID to combine safety data with vehicle production year  【step2】: Apply WHERE clause to filter records where cars.Year = 2020  【step3】: Execute ORDER BY Airbag_Count DESC with LIMIT 10 to retrieve top 10 results",
        "format": "MySQL"
    },
    {
        "db_id": "car",
        "type": "4",
        "idx": 436,
        "question": "If a car has a fuel tank capacity of 1000 liters and its urban fuel efficiency is 0.5 km/L, what is the required amount of fuel for the car to travel 10,000 kilometers in the city?",
        "query": "SELECT Car_ID, Model, 10000 / 0.5 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 0.5;",
        "step": "【step1】: Filter cars with Fuel_Tank_Capacity = 1000L and Fuel_Efficiency_City = 0.5 km/L using the WHERE clause.  【step2】: Calculate Required_Fuel by dividing 10000 km by Fuel_Efficiency_City (0.5 km/L), resulting in 20,000 liters.  【step3】: Return Car_ID, Model, and the computed Required_Fuel for the matched vehicles.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 437,
        "question": "Calculate the theoretical maximum power output for all solar energy devices, and sort the results in ascending order by device name.",
        "query": "SELECT deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = solar ORDER BY deviceName ASC;",
        "step": "【step1】: Filter solar devices from EnergyDevices table using WHERE deviceType = solar  【step2】: Calculate theoreticalMaxOutput by multiplying powerRating with efficiency then dividing by 100  【step3】: Sort results in ascending order by deviceName using ORDER BY clause",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 438,
        "question": "Find the total energy savings for each device over the past year, sorted in descending order by the amount of energy saved, and take the top 5.",
        "query": "SELECT deviceId, SUM(energySaved) AS totalEnergySaved FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId ORDER BY totalEnergySaved DESC LIMIT 5;",
        "step": "【step1】: Filter records from EnergyEfficiency table where timestamp falls within the past year using WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)  【step2】: Group filtered records by deviceId and calculate total energy saved using SUM(energySaved) with GROUP BY deviceId  【step3】: Sort results by totalEnergySaved in descending order and select top 5 entries using ORDER BY totalEnergySaved DESC LIMIT 5",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 439,
        "question": "Find all currently operating devices where the last maintenance date is more than one year ago, and sort them in ascending order by device name.",
        "query": "SELECT deviceId, deviceName, lastMaintenanceDate FROM EnergyDevices WHERE status = 'operating' AND lastMaintenanceDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) ORDER BY deviceName ASC;",
        "step": "【step1】: Filter records from EnergyDevices where status is 'operating' to focus on active devices.  【step2】: Apply date condition (lastMaintenanceDate older than 1 year) to identify overdue maintenance devices.  【step3】: Sort results by deviceName in ascending order to organize the output alphabetically.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 440,
        "question": "Assuming all devices suddenly achieve 100% efficiency, what are the device IDs, device names, and total energy saved per year for the top 10 devices ranked by total energy saved in descending order?",
        "query": "SELECT deviceId, deviceName, (powerRating * 24 * 365) AS totalEnergySaved FROM EnergyDevices ORDER BY totalEnergySaved DESC LIMIT 10;",
        "step": "【step1】: Retrieve deviceId, deviceName, and powerRating from the EnergyDevices table.  【step2】: Calculate the theoretical annual energy saving (totalEnergySaved) for each device using the formula: powerRating * 24 hours/day * 365 days/year.  【step3】: Sort the results by totalEnergySaved in descending order and limit the output to the top 10 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 441,
        "question": "Calculate the total energy generated by solar devices produced by SolarTech based on their power rating, efficiency, and actual energy consumed.",
        "query": "SELECT SUM(ed.powerRating * ed.efficiency / 100 * ec.energyConsumed) AS totalEnergyGenerated FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE m.manufacturerName = '制造商A' AND ed.deviceType = 'solar';",
        "step": "【step1】: Join EnergyDevices with Manufacturers and EnergyConsumption tables using manufacturerId and deviceId to link device specifications, manufacturer details, and consumption data.  【step2】: Apply filters for manufacturerName = '制造商A' and deviceType = 'solar' to isolate relevant solar panels under standard test conditions.  【step3】: Aggregate results by calculating SUM(ed.powerRating * ed.efficiency / 100 * ec.energyConsumed) to compute total energy generated at maximum efficiency.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 442,
        "question": "Find the average energy consumption of wind turbines produced by manufacturer B over the past year and calculate its difference in energy consumption compared to those produced by manufacturer C.",
        "query": "WITH ManufacturerB_Consumption AS (SELECT AVG(ec.energyConsumed) AS avg_energy_consumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'B' AND ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)), ManufacturerC_Consumption AS (SELECT AVG(ec.energyConsumed) AS avg_energy_consumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'C' AND ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)) SELECT (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) AS avg_energy_consumed_B, (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS avg_energy_consumed_C, (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) - (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS energy_consumption_difference;",
        "step": "【step1】: Calculate the average energy consumption for Manufacturer B's wind turbines over the past year by joining EnergyConsumption, EnergyDevices, and Manufacturers tables, filtering for 'B', 'wind', and timestamp within 1 year.  【step2】: Repeat step 1 for Manufacturer C using the same logic but filtering for 'C' instead of 'B'.  【step3】: Extract the calculated averages from both CTEs (ManufacturerB_Consumption and ManufacturerC_Consumption) and compute their difference in the final SELECT statement.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 443,
        "question": "Determine the difference in average energy consumption between winter and summer for fossil fuel equipment produced by Manufacturer D, including the specific values for winter average, summer average, and their difference.",
        "query": "SELECT winter.avg_winter_consumption AS Winter_Avg_Consumption, summer.avg_summer_consumption AS Summer_Avg_Consumption, (winter.avg_winter_consumption - summer.avg_summer_consumption) AS Consumption_Difference FROM (SELECT AVG(ec.energyConsumed) AS avg_winter_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND MONTH(ec.timestamp) IN (12, 1, 2)) AS winter, (SELECT AVG(ec.energyConsumed) AS avg_summer_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND MONTH(ec.timestamp) IN (6, 7, 8)) AS summer;",
        "step": "【step1】: Calculate winter average consumption - Join EnergyConsumption, EnergyDevices, and Manufacturers tables to filter records from manufacturer D's fossil fuel devices during winter months (Dec, Jan, Feb), then compute AVG(energyConsumed).  【step2】: Calculate summer average consumption - Repeat the same join logic for summer months (Jun, Jul, Aug) to compute AVG(energyConsumed) separately.  【step3】: Compare seasonal averages - Combine the two subquery results in the FROM clause, then calculate the numerical difference between winter and summer averages in the final projection.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 444,
        "question": "Assuming that WindPower's annual revenue suddenly increases to 1,000,000 yuan, calculate what its annual profit would be if it maintains the current profit margin.",
        "query": "WITH CurrentProfitMargin AS (SELECT (profit / revenue) * 100 AS profitMargin FROM Manufacturers WHERE manufacturerName = '制造商E'), FutureProfit AS (SELECT 1000000 * (profitMargin / 100) AS futureProfit FROM CurrentProfitMargin) SELECT futureProfit FROM FutureProfit;",
        "step": "【step1】: Retrieve the current profit margin of 'Manufacturer E' from the Manufacturers table by calculating **(profit / revenue) * 100**.  【step2】: Multiply the new annual revenue (100 billion) by the profit margin obtained in Step 1 to derive the projected future profit.  【step3】: The query returns the calculated future profit value, but sustainability analysis requires external factors (e.g., cost trends, market constraints) not covered in the provided database schema.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 445,
        "question": "Calculate the total energy consumption and power factor for device '1' during the year 2023, along with its average power usage, voltage, and current.",
        "query": "WITH DeviceConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.powerUsage) AS avgPowerUsage, AVG(ec.voltage) AS avgVoltage, AVG(ec.current) AS avgCurrent FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT dc.deviceId, dc.totalEnergyConsumed, dc.avgPowerUsage, dc.avgVoltage, dc.avgCurrent, (dc.avgPowerUsage / (dc.avgVoltage * dc.avgCurrent)) AS powerFactor FROM DeviceConsumption dc WHERE dc.deviceId = '1';",
        "step": "【step1】: Filter and aggregate data from EnergyConsumption table for the specified time period, grouping by deviceId to calculate total energy consumed and average power usage, voltage, and current.  【step2】: Compute the power factor for each device using the formula (avgPowerUsage / (avgVoltage * avgCurrent)) in the main query.  【step3】: Apply a WHERE clause to filter results for the specific deviceId, finalizing the output for targeted analysis.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 446,
        "question": "Calculate the total energy consumption of all devices over the past year, grouped by device type, and identify the device type with the highest energy consumption.",
        "query": "SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: Filter the EnergyConsumption records from the past year using WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR).  【step2】: Join EnergyConsumption with EnergyDevices via deviceId to map consumption data to device types.  【step3】: Group results by deviceType, calculate total energy consumed with SUM(), order descending by totalEnergyConsumed, and select the top result with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 447,
        "question": "Analyze the energy consumption changes of equipment under the highest and lowest humidity levels and identify the impact patterns of humidity on energy consumption by calculating the rate of change between these extremes.",
        "query": "SELECT hc.deviceId, ed.deviceName, hc.highHumidityEnergy, hc.lowHumidityEnergy, (hc.highHumidityEnergy - hc.lowHumidityEnergy) / hc.lowHumidityEnergy * 100 AS energyChangeRate FROM (SELECT deviceId, MAX(CASE WHEN humidity = (SELECT MAX(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS highHumidityEnergy, MAX(CASE WHEN humidity = (SELECT MIN(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS lowHumidityEnergy FROM (SELECT deviceId, humidity, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption GROUP BY deviceId, humidity) AS he GROUP BY deviceId) AS hc JOIN EnergyDevices ed ON hc.deviceId = ed.deviceId;",
        "step": "【step1】: Calculate average energy consumption grouped by device and humidity from EnergyConsumption table using subquery he  【step2】: Extract max/min humidity's energy values per device via correlated subqueries and CASE statements in hc subquery  【step3】: Join with EnergyDevices to get names and calculate percentage change between high/low humidity energy consumption",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 448,
        "question": "Assuming the power of a certain device suddenly increases to 10 times its rated power, calculate its energy consumption under extreme conditions and analyze its impact on the power grid for device ID 11.",
        "query": "WITH ExtremePower AS (SELECT deviceId, deviceName, powerRating * 10 AS extremePower, powerRating FROM EnergyDevices WHERE deviceId = 11), ExtremeEnergyConsumption AS (SELECT ep.deviceId, ep.deviceName, ep.extremePower, ep.powerRating, ec.timestamp, ec.energyConsumed, ec.powerUsage, ec.voltage, ec.current, ec.temperature, ec.humidity, ec.dataQuality, ep.extremePower * (ec.timestamp - LAG(ec.timestamp) OVER (PARTITION BY ec.deviceId ORDER BY ec.timestamp)) / 3600 AS extremeEnergyConsumed FROM EnergyConsumption ec JOIN ExtremePower ep ON ec.deviceId = ep.deviceId) SELECT eec.deviceId, eec.deviceName, eec.extremePower, eec.powerRating, eec.timestamp, eec.energyConsumed, eec.powerUsage, eec.voltage, eec.current, eec.temperature, eec.humidity, eec.dataQuality, eec.extremeEnergyConsumed, eec.extremeEnergyConsumed / 100 AS gridImpact FROM ExtremeEnergyConsumption eec;",
        "step": "【step1】: Calculate 10x rated power for deviceID 11 using CTE ExtremePower, joining EnergyDevices to get base powerRating.  【step2】: Compute time-diff energy consumption using LAG window function in ExtremeEnergyConsumption CTE, joining EnergyConsumption data to calculate extremeEnergyConsumed = extremePower * time_diff_in_hours.  【step3】: Final SELECT calculates grid impact (extremeEnergyConsumed/100) and returns all fields with extreme power metrics and impact analysis.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 449,
        "question": "Calculate the total carbon emissions of each device during the specific time period, and identify the device with the highest carbon emissions.",
        "query": "WITH DeviceCarbonFootprint AS (SELECT ec.deviceId, SUM(ec.energyConsumed * ef.carbonFootprint) AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ef ON ec.deviceId = ef.deviceId AND ec.timestamp = ef.timestamp WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT dcf.deviceId, ed.deviceName, dcf.totalCarbonEmission FROM DeviceCarbonFootprint dcf JOIN EnergyDevices ed ON dcf.deviceId = ed.deviceId ORDER BY dcf.totalCarbonEmission DESC LIMIT 1;",
        "step": "【step1】: Calculate total carbon emission per device by joining EnergyConsumption and EnvironmentalImpact tables, multiplying energyConsumed by carbonFootprint, and aggregating within the specified time range.  【step2】: Enrich results by joining with EnergyDevices table to obtain deviceName through deviceId association.  【step3】: Sort devices by totalCarbonEmission in descending order and select the highest-emission device using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 450,
        "question": "Calculate the average energy efficiency of all equipment over the past year and identify the equipment with efficiency below this average.",
        "query": "SELECT ae.deviceId, ae.avgEfficiency FROM (SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId) AS ae JOIN (SELECT AVG(efficiency) AS overallAvgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)) AS oa WHERE ae.avgEfficiency < oa.overallAvgEfficiency;",
        "step": "【step1】: Calculate the average efficiency for each device over the past year using a subquery (aliased as \"ae\") that groups EnergyEfficiency data by deviceId and filters records with timestamp in the last year.  【step2】: Compute the overall average efficiency across all devices in the same period via a separate subquery (aliased as \"oa\").  【step3】: Join the two subqueries and filter devices where the device-specific average efficiency (ae.avgEfficiency) is lower than the overall average (oa.overallAvgEfficiency).",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 451,
        "question": "Find equipment that has not undergone maintenance in the past year and list the detailed information of these devices.",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.powerRating, ed.efficiency, ed.installationDate, ed.status, ed.location, ed.manufacturerId, ed.lastMaintenanceDate, ed.nextMaintenanceDate FROM EnergyDevices ed WHERE ed.deviceId NOT IN (SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR))",
        "step": "【step1】: Retrieve device IDs from MaintenanceRecords that had maintenance in the past year using a subquery: `SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)`.  【step2】: Filter EnergyDevices by excluding devices found in Step 1 using `NOT IN` clause.  【step3】: Select required fields from EnergyDevices where the deviceId does not appear in the subquery results, ensuring only non-maintained devices are listed.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 452,
        "question": "Assuming a device's environmental impact suddenly increases to 100 times its normal value, calculate its impact on the environment and identify the most affected environmental indicator.",
        "query": "DROP TEMPORARY TABLE IF EXISTS NormalImpact; DROP TEMPORARY TABLE IF EXISTS ExtremeImpact; CREATE TEMPORARY TABLE NormalImpact AS SELECT deviceId, AVG(carbonFootprint) AS avgCarbonFootprint, AVG(pollutionLevel) AS avgPollutionLevel, AVG(waterUsage) AS avgWaterUsage, AVG(landUsage) AS avgLandUsage FROM EnvironmentalImpact GROUP BY deviceId; CREATE TEMPORARY TABLE ExtremeImpact AS SELECT deviceId, avgCarbonFootprint * 100 AS extremeCarbonFootprint, avgPollutionLevel * 100 AS extremePollutionLevel, avgWaterUsage * 100 AS extremeWaterUsage, avgLandUsage * 100 AS extremeLandUsage FROM NormalImpact; SELECT deviceId, CASE WHEN extremeCarbonFootprint = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'carbonFootprint' WHEN extremePollutionLevel = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'pollutionLevel' WHEN extremeWaterUsage = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'waterUsage' WHEN extremeLandUsage = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'landUsage' END AS maxImpactIndicator, GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) AS maxImpactValue FROM ExtremeImpact; DROP TEMPORARY TABLE IF EXISTS NormalImpact; DROP TEMPORARY TABLE IF EXISTS ExtremeImpact;",
        "step": "【step1】: Create temporary table NormalImpact by calculating average environmental metrics (carbonFootprint, pollutionLevel, waterUsage, landUsage) per device from EnvironmentalImpact table using GROUP BY deviceId.  【step2】: Create temporary table ExtremeImpact by multiplying NormalImpact's metrics by 100 to simulate 100x energy consumption surge.  【step3】: Compare scaled metrics in ExtremeImpact using GREATEST() and CASE statements to identify the maximum impacted environmental indicator per device.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 453,
        "question": "Calculate the actual output power of solar devices and identify the top 5 devices with the highest actual output power.",
        "query": "SELECT deviceId, deviceName, powerRating * efficiency / 100 AS P_actual FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY P_actual DESC LIMIT 5;",
        "step": "【step1】: Filter devices of type 'solar' from EnergyDevices table using WHERE clause  【step2】: Calculate actual power output (P_actual) by multiplying powerRating with efficiency then dividing by 100  【step3】: Sort results by P_actual in descending order and retrieve top 5 devices using ORDER BY and LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 454,
        "question": "Calculate the total energy cost savings for each device over the past year, sort them in descending order by savings, and identify the top 10 devices with the highest savings.",
        "query": "SELECT ed.deviceId, ed.deviceName, SUM(ee.energySaved) * 0.5 AS total_cost_savings FROM EnergyEfficiency ee JOIN EnergyDevices ed ON ee.deviceId = ed.deviceId WHERE ee.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceName ORDER BY total_cost_savings DESC LIMIT 10;",
        "step": "【step1】: Join EnergyEfficiency and EnergyDevices tables using deviceId, filter records from the past year using WHERE ee.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR).  【step2】: Aggregate energy savings per device using GROUP BY ed.deviceId, calculate total_cost_savings as SUM(ee.energySaved)*0.5.  【step3】: Sort results by total_cost_savings in descending order and limit output to top 10 devices using ORDER BY + LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 455,
        "question": "Find all devices with efficiency below the target efficiency, sort them in ascending order of efficiency, and identify the 10 least efficient devices.",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency FROM EnergyDevices ed JOIN EnergyPolicies ep ON ed.efficiency < ep.targetEfficiency ORDER BY ed.efficiency ASC LIMIT 10;",
        "step": "【step1】: Perform an inner join between EnergyDevices and EnergyPolicies tables using the condition where device efficiency is less than policy target efficiency.  【step2】: Sort the combined results by device efficiency in ascending order.  【step3】: Apply LIMIT 10 to retrieve the 10 devices with the lowest efficiency values.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 456,
        "question": "Assuming the efficiency of all equipment is 100%, calculate the actual output power of each device and identify the top 5 devices with the highest actual output power.",
        "query": "SELECT deviceId, deviceName, powerRating * 1.0 AS P_actual FROM EnergyDevices ORDER BY P_actual DESC LIMIT 5;",
        "step": "【step1】: Retrieve deviceId, deviceName, and calculate theoretical maximum output power (P_actual) by multiplying powerRating by 1.0 (100% efficiency assumption) from EnergyDevices table.  【step2】: Sort results in descending order based on P_actual to prioritize highest output devices.  【step3】: Apply LIMIT 5 to filter the top 5 devices with maximum theoretical output power.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 457,
        "question": "Calculate the total energy consumption of each device during the specified time period and identify the device with the highest total energy consumption.",
        "query": "SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY TotalEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables using deviceId to associate consumption data with device names.  【step2】: Filter records by the 2023 timestamp range, calculate total energy consumed per device using SUM(), and group results by deviceId/deviceName.  【step3】: Order results in descending order by TotalEnergyConsumed and select the top record using LIMIT 1 to identify the highest-consuming device.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 458,
        "question": "Calculate the total and average energy consumption for each device type over the past year.",
        "query": "SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= NOW() - INTERVAL 1 YEAR GROUP BY ed.deviceType;",
        "step": "【step1】: Filter the EnergyConsumption records from the past year using the WHERE clause on timestamp.  【step2】: Join the filtered EnergyConsumption data with EnergyDevices via deviceId to associate each consumption entry with its device type.  【step3】: Group the joined dataset by deviceType and calculate both total (SUM) and average (AVG) energyConsumed for each group.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 459,
        "question": "Find the device with the highest total maintenance cost and show its maintenance frequency and parts replaced list.",
        "query": "WITH MaintenanceCosts AS (SELECT deviceId, SUM(cost) AS totalMaintenanceCost, COUNT(*) AS maintenanceFrequency, GROUP_CONCAT(partsReplaced SEPARATOR ', ') AS partsReplacedList FROM MaintenanceRecords GROUP BY deviceId) SELECT ED.deviceId, ED.deviceName, ED.deviceType, MC.totalMaintenanceCost, MC.maintenanceFrequency, MC.partsReplacedList FROM EnergyDevices ED JOIN MaintenanceCosts MC ON ED.deviceId = MC.deviceId ORDER BY MC.totalMaintenanceCost DESC LIMIT 1;",
        "step": "【step1】: Create a CTE (MaintenanceCosts) to calculate total maintenance cost, maintenance frequency, and concatenated replaced parts list per device from MaintenanceRecords table.  【step2】: Join EnergyDevices table with the CTE to get device details (name/type) alongside maintenance metrics.  【step3】: Sort results by totalMaintenanceCost descending and select the top record to identify the device with highest maintenance cost.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 460,
        "question": "Assuming the power rating of the specified device is 1,000,000 kilowatts, calculate its total energy consumption in one year and analyze its impact on the environment.",
        "query": "WITH DeviceEnergy AS (  SELECT     deviceId,    1000000 AS powerRating,    8760 AS hoursInYear,    1000000 * 8760 AS totalEnergyConsumed  FROM     EnergyDevices  WHERE     deviceId = 12345 ), EnvironmentalImpactAnalysis AS (  SELECT     deviceId,    totalEnergyConsumed,    totalEnergyConsumed * 0.85 AS carbonFootprint,    totalEnergyConsumed * 0.001 AS waterUsage,    totalEnergyConsumed * 0.0001 AS landUsage  FROM     DeviceEnergy ) SELECT   DE.deviceId,  DE.powerRating,  DE.totalEnergyConsumed,  EIA.carbonFootprint,  EIA.waterUsage,  EIA.landUsage FROM   DeviceEnergy DE JOIN   EnvironmentalImpactAnalysis EIA ON   DE.deviceId = EIA.deviceId;",
        "step": "【step1】: Calculate annual energy consumption using hard-coded power rating (1,000,000 kW) and fixed operational hours (8,760 hours/year) for deviceID 12345 from EnergyDevices table.  【step2】: Compute environmental impact metrics (carbon footprint, water usage, land usage) by applying conversion factors to the calculated total energy consumption.  【step3】: Combine energy consumption data with environmental impact analysis through deviceID join between the two CTE results.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 461,
        "question": "Calculate the total energy consumption of each device over the year 2023 and identify the device with the highest energy consumption.",
        "query": "SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables using deviceId to combine consumption data with device metadata.  【step2】: Filter records within 2023-01-01 to 2023-12-31, then calculate total energy consumption per device using SUM() and GROUP BY deviceId/deviceName.  【step3】: Sort results by totalEnergyConsumed in descending order and return the top record using ORDER BY and LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 462,
        "question": "Calculate the average efficiency of each device over a specific time period and identify devices with efficiency below the overall average efficiency across all devices.",
        "query": "WITH DeviceEfficiency AS (SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY deviceId), OverallAverageEfficiency AS (SELECT AVG(avgEfficiency) AS overallAvgEfficiency FROM DeviceEfficiency) SELECT de.deviceId, de.avgEfficiency FROM DeviceEfficiency de, OverallAverageEfficiency oae WHERE de.avgEfficiency < oae.overallAvgEfficiency;",
        "step": "【step1】: Calculate the average efficiency per device within the specified timeframe using a CTE (DeviceEfficiency). This filters EnergyEfficiency records between '2023-01-01' and '2023-12-31', grouping by deviceId and computing AVG(efficiency).  【step2】: Compute the global average efficiency across all devices using a second CTE (OverallAverageEfficiency). This aggregates the avgEfficiency values from the DeviceEfficiency CTE.  【step3】: Join the two CTEs and filter devices where avgEfficiency is below the global average. This final SELECT compares device-level averages against the overall threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 463,
        "question": "Find the total energy consumption for devices operating in high-temperature environments (above 30 degrees).",
        "query": "SELECT SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.temperature > 30;",
        "step": "【step1】: Filter all energy consumption records where temperature exceeds 30 from the EnergyConsumption table.  【step2】: Join the filtered EnergyConsumption records with EnergyDevices to ensure device validity via deviceId.  【step3】: Aggregate the energyConsumed values using SUM() to calculate total energy consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 464,
        "question": "Assuming the power rating of the device with ID 123 is 1,000,000 kilowatts, calculate its total energy consumption over a year and determine the related environmental impacts.",
        "query": "WITH DeviceEnergy AS (SELECT deviceId, 1000000 AS powerRating, 8760 AS hoursInYear FROM EnergyDevices WHERE deviceId = 123) SELECT de.deviceId, de.powerRating * de.hoursInYear AS totalEnergyConsumed, ei.carbonFootprint, ei.pollutionLevel, ei.waterUsage, ei.landUsage FROM DeviceEnergy de JOIN EnvironmentalImpact ei ON de.deviceId = ei.deviceId WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = de.deviceId);",
        "step": "【step1】: Create CTE to set hypothetical power rating (1,000,000 kW) and annual hours (8,760) for device ID 123 from EnergyDevices table.  【step2】: Join EnvironmentalImpact table using deviceId, filtering only the latest impact record via subquery (SELECT MAX(timestamp)).  【step3】: Calculate total annual energy consumption (powerRating × hoursInYear) and return environmental metrics (carbonFootprint, pollutionLevel, etc.) from the joined result.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 465,
        "question": "Calculate the average power output of solar devices within the time period from 2023-01-01 to 2023-12-31 and identify the device with the highest average power output.",
        "query": "SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) / (TIMESTAMPDIFF(HOUR, MIN(ec.timestamp), MAX(ec.timestamp))) AS averagePowerOutput FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY averagePowerOutput DESC LIMIT 1;",
        "step": "【step1】: Join EnergyDevices and EnergyConsumption tables on deviceId, filter solar devices and timestamp range  【step2】: Calculate average power output per device using SUM(energyConsumed)/TIMESTAMPDIFF(HOUR) grouped by device  【step3】: Sort results by averagePowerOutput descending and select top record with LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 466,
        "question": "Calculate the ratio of total energy consumption to total power generation for each wind turbine device, and sort the results in ascending order by the ratio.",
        "query": "SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ef.forecastValue) AS totalEnergyGenerated, (SUM(ec.energyConsumed) / SUM(ef.forecastValue)) AS energyConsumptionToGenerationRatio FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyForecasts ef ON ed.deviceId = ef.deviceId WHERE ed.deviceType = 'wind' AND ef.forecastType = '5000000.00' GROUP BY ed.deviceId, ed.deviceName ORDER BY energyConsumptionToGenerationRatio ASC;",
        "step": "【step1】: Join EnergyDevices with EnergyConsumption and EnergyForecasts on deviceId, filtering for wind energy devices and generation forecasts.  【step2】: Aggregate total energy consumed and generated per device, calculate consumption-to-generation ratio.  【step3】: Sort results by the calculated ratio in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 467,
        "question": "Find all devices installed in 2022 that have efficiency below the target efficiency, sorted in descending order of efficiency.",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency FROM EnergyDevices ed JOIN EnergyPolicies ep ON ed.installationDate >= '2022-01-01' AND ed.installationDate <= '2022-12-31' WHERE ed.efficiency < ep.targetEfficiency ORDER BY ed.efficiency DESC;",
        "step": "【step1】: Join EnergyDevices and EnergyPolicies tables, filtering devices installed in 2022 via the ON clause (ed.installationDate between '2022-01-01' and '2022-12-31').  【step2】: Apply WHERE condition to select devices where actual efficiency (ed.efficiency) is lower than policy target efficiency (ep.targetEfficiency).  【step3】: Sort the final results by ed.efficiency in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 468,
        "question": "Assuming the efficiency of all equipment is 100%, calculate the ratio of total energy consumption to total energy generated for each equipment, and sort the results in ascending order by the ratio.",
        "query": "WITH DeviceEfficiency AS (SELECT deviceId, 100 AS efficiency FROM EnergyDevices), TotalEnergy AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed / (de.efficiency / 100.0)) AS totalEnergyGenerated FROM EnergyConsumption ec JOIN DeviceEfficiency de ON ec.deviceId = de.deviceId GROUP BY ec.deviceId) SELECT te.deviceId, (te.totalEnergyConsumed / te.totalEnergyGenerated) AS energyRatio FROM TotalEnergy te ORDER BY energyRatio ASC;",
        "step": "【step1】: Create a CTE named DeviceEfficiency to override all device efficiencies to 100%, ensuring a hypothetical scenario where all devices operate at maximum efficiency.  【step2】: Calculate total energy consumption and generated energy for each device by joining EnergyConsumption with DeviceEfficiency, using the formula *energyConsumed / (efficiency/100)* to derive generated energy. Group results by deviceId.  【step3】: Compute the energy consumption-to-generation ratio for each device from the aggregated data and sort the results in ascending order of this ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 469,
        "question": "Calculate the average efficiency of all solar energy devices and identify the device with the highest efficiency.",
        "query": "WITH SolarDeviceEfficiency AS (SELECT deviceId, efficiency FROM EnergyDevices WHERE deviceType = 'solar') SELECT AVG(efficiency) AS average_efficiency, (SELECT deviceId FROM SolarDeviceEfficiency ORDER BY efficiency DESC LIMIT 1) AS most_efficient_device FROM SolarDeviceEfficiency;",
        "step": "【step1】: Filter solar devices from EnergyDevices table using WHERE deviceType='solar', creating CTE SolarDeviceEfficiency with deviceId and efficiency  【step2】: Calculate average efficiency using AVG(efficiency) on SolarDeviceEfficiency CTE  【step3】: Retrieve most efficient device via subquery (SELECT deviceId FROM SolarDeviceEfficiency ORDER BY efficiency DESC LIMIT 1)",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 470,
        "question": "Calculate the total energy saved by each wind energy device over the past year, sorted in descending order by the amount of energy saved.",
        "query": "SELECT ed.deviceId, ed.deviceName, SUM(ed.powerRating * ed.efficiency * ec.energyConsumed) AS totalEnergySaved FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergySaved DESC;",
        "step": "【step1】: Join EnergyDevices and EnergyConsumption tables using deviceId, filter for wind energy devices and consumption records from the past year  【step2】: Calculate total energy saved per device using formula (powerRating × efficiency × energyConsumed) aggregation  【step3】: Sort results by totalEnergySaved in descending order and finalize device grouping",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 471,
        "question": "Find all devices installed in 2022 and calculate their total energy consumption.",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.powerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE YEAR(ed.installationDate) = 2022 GROUP BY ed.deviceId, ed.deviceName, ed.powerRating;",
        "step": "【step1】: Filter devices installed in 2022 from the EnergyDevices table using WHERE YEAR(installationDate) = 2022.  【step2】: Join the filtered devices with the EnergyConsumption table using deviceId to access all energy consumption records for these devices.  【step3】: Group the joined results by deviceId, deviceName, and powerRating, then calculate the total energy consumption using SUM(energyConsumed).",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 472,
        "question": "Assuming all devices operate at less than 100% efficiency, calculate the energy saved by each device in one year and identify the device that saves the most energy.",
        "query": "WITH DeviceEnergySavings AS (SELECT ed.deviceId, ed.deviceName, ed.powerRating * (100 - ed.efficiency) / 100 * 365 * 24 AS energySaved FROM EnergyDevices ed) SELECT des.deviceId, des.deviceName, des.energySaved FROM DeviceEnergySavings des ORDER BY des.energySaved DESC LIMIT 1;",
        "step": "【step1】: Calculate hypothetical annual energy savings per device when efficiency reaches 100% using formula:  `powerRating * (100 - efficiency)/100 * 365*24` via CTE DeviceEnergySavings.  【step2】: Sort all devices by calculated energy savings in descending order.  【step3】: Retrieve the top-ranked device with maximum energy savings using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 473,
        "question": "Calculate the theoretical maximum power output for all solar energy devices, sorted by device ID in ascending order.",
        "query": "SELECT deviceId, deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceId ASC;",
        "step": "【step1】: Filter rows from EnergyDevices where deviceType is 'solar' using the WHERE clause.  【step2】: Calculate theoreticalMaxOutput by multiplying powerRating with efficiency and dividing by 100 for the filtered rows.  【step3】: Sort the results by deviceId in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 474,
        "question": "Calculate the total energy consumption for each device over the past year, sorted in descending order by total energy consumption, and take the top 5 devices.",
        "query": "SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption WHERE timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY deviceId ORDER BY totalEnergyConsumed DESC LIMIT 5",
        "step": "【step1】: Filter the EnergyConsumption table to include only records from the past year using the WHERE clause with timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR).  【step2】: Group the filtered records by deviceId and calculate the total energy consumption for each device using SUM(energyConsumed) with GROUP BY deviceId.  【step3】: Sort the aggregated results by totalEnergyConsumed in descending order and limit the output to the top 5 records using ORDER BY and LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 475,
        "question": "Find the devices and their maintenance counts, sorted in descending order by the number of maintenance occurrences.",
        "query": "SELECT deviceId, COUNT(maintenanceId) AS maintenanceCount FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenanceCount DESC;",
        "step": "【step1】: Aggregate maintenance records by deviceId and calculate the count of maintenanceId for each device using GROUP BY and COUNT().  【step2】: Sort the aggregated results in descending order based on maintenanceCount using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 476,
        "question": "Assuming the efficiency of all devices is increased to 100%, calculate the total energy savings these devices would achieve in one year, and sort them in descending order by the amount of energy saved.",
        "query": "SELECT deviceId, SUM(energySaved * (100 / efficiency)) AS totalEnergySaved FROM EnergyEfficiency WHERE efficiency < 100 GROUP BY deviceId ORDER BY totalEnergySaved DESC;",
        "step": "【step1】: Filter devices with efficiency below 100% from EnergyEfficiency table using WHERE efficiency < 100.  【step2】: Calculate potential energy saved by scaling current savings to 100% efficiency via SUM(energySaved * (100 / efficiency)) for each deviceId using GROUP BY.  【step3】: Sort results in descending order of totalEnergySaved with ORDER BY totalEnergySaved DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 477,
        "question": "Calculate the daily energy output in kWh of the solar panel at maximum efficiency, assuming a solar radiation intensity of 1000 watts per square meter, a solar panel area of 2 square meters, an efficiency of 20%, and 24 hours of operation.",
        "query": "SELECT (1000 * 2 * 0.20 * 24) / 1000 AS daily_energy_output_kWh;",
        "step": "【step1】: Collect fixed parameters: Solar radiation intensity (1000W/m²), panel area (2m²), efficiency (20%), and duration (24 hours).  【step2】: Apply formula: (1000 * 2 * 0.20 * 24) to calculate watt-hours, then divide by 1000 for kWh conversion.  【step3】: Output calculated value with alias **daily_energy_output_kWh**.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 478,
        "question": "Calculate the output power of the wind turbine in kilowatts at a wind speed of 12 meters per second, assuming a power coefficient of 0.4 for the wind turbine, an air density of 1.225 kilograms per cubic meter, and a blade radius of 30 meters.",
        "query": "SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(12, 3) * 0.4 / 1000 AS output_power_kw;",
        "step": "【step1】: Calculate the swept area of wind turbine blades using formula: 0.5 * air_density * π * radius² → 0.5*1.225*PI()*POWER(30,2)  【step2】: Compute wind power by multiplying swept area with wind_speed³ → ...*POWER(12,3)  【step3】: Apply power coefficient and convert watts to kilowatts: multiply by 0.4 and divide by 1000 → ...*0.4/1000 AS output_power_kw",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 479,
        "question": "Calculate the total energy consumption and total cost of the equipment over a month based on its rated power and operating time, assuming the equipment runs for 8 hours per day, with an electricity price of 0.5 yuan per kilowatt-hour.",
        "query": "SELECT deviceId, deviceName, powerRating * 8 * 30 AS totalEnergyConsumed, powerRating * 8 * 30 * 0.5 AS totalCost FROM EnergyDevices;",
        "step": "【step1】: Select deviceId and deviceName from EnergyDevices table.  【step2】: Calculate monthly energy consumption using powerRating * 8 hours/day * 30 days as totalEnergyConsumed.  【step3】: Compute total cost by multiplying totalEnergyConsumed by the electricity rate (0.5) as totalCost.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 480,
        "question": "Assuming the blade radius of a wind turbine increases to 1000 meters with a wind speed of 50 meters per second, calculate its output power in kilowatts, given an air density of 1.225 kg/m³, a power coefficient of 0.4, and using the formula for wind power.",
        "query": "SELECT 0.5 * 1.225 * PI() * POWER(1000, 2) * POWER(50, 3) * 0.4 / 1000 AS output_power_kw;",
        "step": "【step1】: Calculate blade area using PI()*POWER(1000,2) to compute rotor swept area  【step2】: Apply wind power formula components: 0.5 * air_density * area * POWER(50,3)  【step3】: Multiply by efficiency (0.4) and convert to kilowatts via division by 1000",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 481,
        "question": "Calculate the average efficiency of all devices produced by SolarTech and identify the devices with efficiency below the average.",
        "query": "WITH ManufacturerDevices AS (SELECT ed.deviceId, ed.efficiency FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), AverageEfficiency AS (SELECT AVG(efficiency) AS avgEfficiency FROM ManufacturerDevices) SELECT md.deviceId, md.efficiency FROM ManufacturerDevices md, AverageEfficiency ae WHERE md.efficiency < ae.avgEfficiency;",
        "step": "【step1】: Filter devices from the specified manufacturer by joining EnergyDevices and Manufacturers tables, selecting deviceId and efficiency.  【step2】: Calculate the average efficiency of these filtered devices using AVG() aggregation.  【step3】: Compare each device's efficiency against the calculated average, returning devices with below-average efficiency through a cross-join between filtered devices and the average value.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 482,
        "question": "Calculate the total energy consumption for each device produced by SolarTech and identify the device with the highest total energy consumption.",
        "query": "WITH ManufacturerDevices AS (SELECT ed.deviceId FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), TotalEnergyConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec WHERE ec.deviceId IN (SELECT deviceId FROM ManufacturerDevices) GROUP BY ec.deviceId) SELECT tec.deviceId, tec.totalEnergyConsumed FROM TotalEnergyConsumption tec ORDER BY tec.totalEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: [Retrieve all device IDs associated with the specified manufacturer from EnergyDevices and Manufacturers tables using JOIN]  【step2】: [Calculate total energy consumption per device by aggregating energyConsumed values from EnergyConsumption table, filtered using Step1 results]  【step3】: [Sort devices by totalEnergyConsumed in descending order and select the top record with LIMIT 1]",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 483,
        "question": "Find all equipment produced by SolarTech where the maintenance cost is higher than the average maintenance cost for SolarTech equipment.",
        "query": "WITH ManufacturerDevices AS (SELECT ed.deviceId, ed.deviceName, ed.manufacturerId FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), AverageMaintenanceCost AS (SELECT AVG(mr.cost) AS avgCost FROM MaintenanceRecords mr JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId) SELECT md.deviceId, md.deviceName, mr.cost FROM MaintenanceRecords mr JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId CROSS JOIN AverageMaintenanceCost amc WHERE mr.cost > amc.avgCost;",
        "step": "【step1】: Filter devices from 'EnergyDevices' belonging to the specified manufacturer by joining with 'Manufacturers' table, creating a CTE (ManufacturerDevices) with deviceId, deviceName, and manufacturerId.  【step2】: Calculate the average maintenance cost for all devices in ManufacturerDevices by joining with 'MaintenanceRecords', creating a second CTE (AverageMaintenanceCost).  【step3】: Retrieve devices from ManufacturerDevices with maintenance costs (via 'MaintenanceRecords') exceeding the calculated avgCost using a CROSS JOIN to apply the single avgCost value across all rows for comparison.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 484,
        "question": "Assuming the rated power of all devices produced by a certain manufacturer has been converted from kilowatts to watts (multiplied by 1000), calculate the total energy consumption of these devices and identify the device with the highest energy consumption.",
        "query": "WITH IncreasedPower AS (SELECT deviceId, powerRating * 1000 AS increasedPowerRating FROM EnergyDevices WHERE manufacturerId = '1') SELECT ec.deviceId, SUM(ec.energyConsumed * ip.increasedPowerRating) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN IncreasedPower ip ON ec.deviceId = ip.deviceId GROUP BY ec.deviceId ORDER BY totalEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: Create a CTE named IncreasedPower to calculate the adjusted power rating (powerRating*1000) for all devices of manufacturerId='1' from EnergyDevices  【step2】: Join EnergyConsumption with the CTE on deviceId, calculate total energy consumed by multiplying energyConsumed with increasedPowerRating for each record, then aggregate using SUM() grouped by deviceId  【step3】: Order results by totalEnergyConsumed in descending order and select the top record using LIMIT 1 to find the device with highest energy consumption",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 485,
        "question": "Calculate the total energy consumption and average power usage of device '1' between June 15, 2023 and December 15, 2023.",
        "query": "SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed) / (MAX(ec.timestamp) - MIN(ec.timestamp)) AS averagePowerUsage FROM EnergyConsumption ec WHERE ec.deviceId = '特定设备的deviceId' AND ec.timestamp BETWEEN '开始时间' AND '结束时间' GROUP BY ec.deviceId;",
        "step": "【step1】: Filter records from EnergyConsumption table where deviceId matches the specific device and timestamp falls within the defined time range.  【step2】: Aggregate the filtered data by deviceId, calculate total energy consumed (SUM(energyConsumed)), and determine the time duration (MAX(timestamp) - MIN(timestamp)).  【step3】: Compute average power usage by dividing total energy consumed by the calculated time duration. Return deviceId, totalEnergyConsumed, and averagePowerUsage.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 486,
        "question": "Calculate the total energy consumption of all devices over the past year, grouped by device type, and identify the device type with the highest energy consumption.",
        "query": "SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables on deviceId, filter records from the last year using WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR).  【step2】: Group the joined data by deviceType and calculate total energy consumption using SUM(energyConsumed).  【step3】: Order grouped results by totalEnergyConsumed in descending order and select the top result with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 487,
        "question": "Analyze the energy consumption differences between high humidity and low humidity conditions and identify the impact of humidity levels on total energy consumption.",
        "query": "SELECT CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END AS humidity_level, SUM(energyConsumed) AS total_energy_consumed FROM EnergyConsumption GROUP BY CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END;",
        "step": "【step1】: Categorize humidity levels using CASE expression to split records into 'high humidity' (>60) and 'low humidity' (≤60).  【step2】: Group records by the calculated humidity_level column.  【step3】: Calculate total energy consumption with SUM(energyConsumed) for each humidity group.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 488,
        "question": "Assuming the power consumption of a certain device suddenly increases to 10 times its recorded power usage, calculate its energy consumption under extreme conditions and analyze its impact on the environment.",
        "query": "WITH TimeDifferences AS ( SELECT deviceId, timestamp, powerUsage, TIMESTAMPDIFF(SECOND, timestamp, LEAD(timestamp) OVER (PARTITION BY deviceId ORDER BY timestamp)) AS timeDiff FROM EnergyConsumption ), ExtremeEnergyConsumption AS ( SELECT deviceId, SUM(powerUsage * 10 * (timeDiff / 3600)) AS extremeEnergyConsumed FROM TimeDifferences WHERE timeDiff IS NOT NULL GROUP BY deviceId ), EnvironmentalImpactAnalysis AS ( SELECT ei.deviceId, SUM(ei.carbonFootprint) AS totalCarbonFootprint FROM EnvironmentalImpact ei JOIN EnergyConsumption ec ON ei.deviceId = ec.deviceId GROUP BY ei.deviceId ) SELECT eec.deviceId, eec.extremeEnergyConsumed, eia.totalCarbonFootprint FROM ExtremeEnergyConsumption eec JOIN EnvironmentalImpactAnalysis eia ON eec.deviceId = eia.deviceId;",
        "step": "【step1】: Calculate time differences between consecutive energy consumption records using window functions. Use LEAD() to get next timestamp for each device, compute interval in seconds with TIMESTAMPDIFF, and filter out NULL intervals.【step2】: Compute extreme energy consumption by multiplying original power usage by 10, convert time intervals to hours, then aggregate total energy per device through SUM(powerUsage * 10 * (timeDiff/3600)) with GROUP BY deviceId.【step3】: Calculate total carbon footprint by joining EnvironmentalImpact with EnergyConsumption tables, aggregate per device, then combine with extreme energy results through deviceId JOIN to produce final environmental impact analysis.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 489,
        "question": "Calculate the total carbon emissions for device ID '1' between January 1, 2023 and December 31, 2023, where emissions are calculated by multiplying total energy consumption by a carbon footprint coefficient.",
        "query": "SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, ei.carbonFootprint AS carbonFootprintCoefficient, SUM(ec.energyConsumed) * ei.carbonFootprint AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ei ON ec.deviceId = ei.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' AND ec.deviceId = '特定设备的deviceId' GROUP BY ec.deviceId, ei.carbonFootprint;",
        "step": "【step1】: Filter energy consumption records for the specific device within the given timestamp range using WHERE clause on EnergyConsumption.  【step2】: Join EnvironmentalImpact table via deviceId to obtain carbon footprint coefficient corresponding to the device.  【step3】: Aggregate filtered data using SUM(energyConsumed), multiply by carbonFootprint coefficient, and return total emissions via GROUP BY and aliasing.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 490,
        "question": "Calculate the average efficiency for each device type over the past year.",
        "query": "WITH DeviceEfficiency AS ( SELECT ed.deviceId, ed.deviceType, AVG(ee.efficiency) AS avgEfficiency FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId WHERE ee.timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceType ) SELECT deviceType, AVG(avgEfficiency) AS avgEfficiencyByType FROM DeviceEfficiency GROUP BY deviceType;",
        "step": "【step1】: Filter EnergyEfficiency data from the past year and join with EnergyDevices to associate each device's efficiency records with its corresponding device type.  【step2】: Calculate the average efficiency for each individual device (grouped by deviceId and deviceType) using the filtered data.  【step3】: Aggregate the per-device average efficiencies by deviceType to determine the overall average efficiency for each device category.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 491,
        "question": "Analyze the energy consumption changes of device '1' under different environmental humidity levels to infer the impact of humidity on energy consumption.",
        "query": "SELECT ec.deviceId, AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) AS high_humidity_energy, AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END) AS low_humidity_energy, (AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) - AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END)) AS energy_change FROM EnergyConsumption ec WHERE ec.deviceId = '1' GROUP BY ec.deviceId;",
        "step": "【step1】: Filter records for specified deviceId in EnergyConsumption table  【step2】: Calculate average energy consumption for high (>70) and low (<30) humidity conditions using conditional CASE statements  【step3】: Compute difference between high/low humidity averages as energy_change metric",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 492,
        "question": "Assuming the carbon footprint coefficient of a certain device is 100 times its normal value, calculate its total carbon emissions within a year and analyze its environmental impact.",
        "query": "WITH AnnualEnergyConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec WHERE ec.timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY ec.deviceId), CarbonFootprintAnalysis AS (SELECT aec.deviceId, aec.totalEnergyConsumed, aec.totalEnergyConsumed * (ei.carbonFootprint * 100) AS totalCarbonEmission, ei.pollutionLevel, ei.waterUsage, ei.landUsage FROM AnnualEnergyConsumption aec JOIN EnvironmentalImpact ei ON aec.deviceId = ei.deviceId WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = aec.deviceId)) SELECT cfa.deviceId, cfa.totalEnergyConsumed, cfa.totalCarbonEmission, cfa.pollutionLevel, cfa.waterUsage, cfa.landUsage, CASE WHEN cfa.totalCarbonEmission > (SELECT AVG(totalCarbonEmission) FROM CarbonFootprintAnalysis) THEN 'High Impact' ELSE 'Normal Impact' END AS environmentalImpact FROM CarbonFootprintAnalysis cfa;",
        "step": "【step1】: Calculate annual energy consumption per device using a CTE by summing energyConsumed from EnergyConsumption table filtered for the past year.  【step2】: Join with EnvironmentalImpact table to calculate amplified carbon emissions (using 100x carbonFootprint) and extract environmental metrics, using the latest impact record per device via subquery.  【step3】: Perform final analysis by comparing each device's carbon emissions against the average using CASE expression in the main query, categorizing environmental impact.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 493,
        "question": "Calculate the total energy consumption and efficiency change for each device over the year 2023.",
        "query": "SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-12-31 23:59:59') - (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-01-01 00:00:00') AS efficiencyChange FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId;",
        "step": "【step1】: Filter and aggregate total energy consumption per device within the specified time range from the EnergyConsumption table.  【step2】: Retrieve efficiency values at the start ('2023-01-01 00:00:00') and end ('2023-12-31 23:59:59') of the period for each device via subqueries on the EnergyEfficiency table.  【step3】: Combine aggregated consumption data with calculated efficiency changes (end efficiency - start efficiency) for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 494,
        "question": "Calculate the total energy savings and total cost savings for all devices over the past year, grouped by device type.",
        "query": "SELECT deviceType, SUM(energySaved) AS totalEnergySaved, SUM(costSavings) AS totalCostSavings FROM EnergyEfficiency JOIN EnergyDevices ON EnergyEfficiency.deviceId = EnergyDevices.deviceId WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceType;",
        "step": "【step1】: Join the EnergyEfficiency and EnergyDevices tables using deviceId to associate efficiency data with device types. Apply a WHERE filter to select records from the past year based on the timestamp field in EnergyEfficiency.  【step2】: Group the filtered results by deviceType from the EnergyDevices table.  【step3】: Calculate the sum of energySaved and costSavings for each deviceType group using aggregation functions.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 495,
        "question": "Analyze the relationship between equipment maintenance frequency and average equipment efficiency.",
        "query": "SELECT MR.deviceId, COUNT(MR.maintenanceDate) AS maintenanceFrequency, AVG(EE.efficiency) AS averageEfficiency FROM MaintenanceRecords MR JOIN EnergyEfficiency EE ON MR.deviceId = EE.deviceId GROUP BY MR.deviceId ORDER BY maintenanceFrequency, averageEfficiency;",
        "step": "【step1】: Join `MaintenanceRecords` (MR) with `EnergyEfficiency` (EE) using `deviceId` to link maintenance events and efficiency data.  【step2】: Group results by `MR.deviceId`, calculate maintenance frequency via `COUNT(MR.maintenanceDate)` and average efficiency via `AVG(EE.efficiency)`.  【step3】: Sort the grouped results first by maintenance frequency and then by average efficiency in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 496,
        "question": "Assuming a device with ID 123 improves to 1000% efficiency, calculate its annual energy savings and cost savings, and analyze its environmental impact.",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.deviceType, (ee.energySaved * 10) AS annualEnergySaved, (ee.costSavings * 10) AS annualCostSavings, env.carbonFootprint, env.pollutionLevel FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId JOIN EnvironmentalImpact env ON ed.deviceId = env.deviceId WHERE ed.deviceId = 123;",
        "step": "【step1】: Join EnergyDevices with EnergyEfficiency on deviceId to calculate annual energy/cost savings by multiplying energySaved and costSavings by 10 (assuming 10x efficiency improvement from 1000% increase).  【step2】: Join the result with EnvironmentalImpact on deviceId to incorporate carbonFootprint and pollutionLevel data.  【step3】: Apply WHERE clause filtering for deviceId=123 to isolate calculations and analysis for the specific target device.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 497,
        "question": "Calculate the total energy consumption for each device during the time period from 2023-01-01 to 2023-12-31 and analyze the percentage change in efficiency for each device.",
        "query": "WITH DeviceEnergy AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, MIN(ee.efficiency) AS efficiency_start, MAX(ee.efficiency) AS efficiency_end FROM EnergyConsumption ec JOIN EnergyEfficiency ee ON ec.deviceId = ee.deviceId WHERE ec.timestamp BETWEEN '2023-01-01' AND '2023-12-31' AND ee.timestamp BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY ec.deviceId) SELECT de.deviceId, de.totalEnergyConsumed, (de.efficiency_end - de.efficiency_start) / de.efficiency_start * 100 AS efficiency_change_percentage FROM DeviceEnergy de;",
        "step": "【step1】: Filter and join EnergyConsumption (ec) and EnergyEfficiency (ee) tables by deviceId, limiting data to timestamps between 2023-01-01 and 2023-12-31 for both tables.  【step2】: Aggregate data by deviceId to calculate total energy consumption (SUM), initial efficiency (MIN), and final efficiency (MAX) within the time range.  【step3】: Calculate efficiency change percentage using formula ((efficiency_end - efficiency_start)/efficiency_start * 100) in final output.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 498,
        "question": "Calculate the average maintenance cost for equipment from the manufacturer 'SolarTech' grouped by device type.",
        "query": "SELECT ed.deviceType, AVG(mr.cost) AS avgMaintenanceCost FROM MaintenanceRecords mr JOIN EnergyDevices ed ON mr.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech' GROUP BY ed.deviceType;",
        "step": "【step1】: Filter the Manufacturers table to find the specific manufacturer's ID using WHERE manufacturerName = 'SolarTech'.  【step2】: Join EnergyDevices with MaintenanceRecords via deviceId, filtered by the manufacturerId from step 1.  【step3】: Group the results by deviceType and calculate the average maintenance cost using AVG(mr.cost).",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 499,
        "question": "Analyze the average energy consumption of device '1' across different humidity ranges (0-30%, 31-60%, 61-90%, 91-100%) and provide energy-saving recommendations.",
        "query": "SELECT humidity_range, AVG(energyConsumed) AS avg_energy_consumed FROM (SELECT CASE WHEN humidity BETWEEN 0 AND 30 THEN '0-30%' WHEN humidity BETWEEN 31 AND 60 THEN '31-60%' WHEN humidity BETWEEN 61 AND 90 THEN '61-90%' ELSE '91-100%' END AS humidity_range, energyConsumed FROM EnergyConsumption WHERE deviceId = '1') AS subquery GROUP BY humidity_range ORDER BY humidity_range;",
        "step": "【step1】: Classify humidity into predefined ranges (0-30%, 31-60%, 61-90%, 91-100%) using CASE WHEN in a subquery, while filtering data for a specific device from EnergyConsumption table.  【step2】: Calculate average energy consumption (AVG(energyConsumed)) for each humidity range using GROUP BY on the derived humidity_range categories.  【step3】: Sort results by humidity_range to show energy consumption progression from low to high humidity, enabling identification of efficiency patterns for targeted节能建议 (e.g., optimize operation in high-humidity ranges where avg_energy_consumed peaks).",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 500,
        "question": "Assuming the power rating of a certain device is 1,000,000 watts, calculate its total energy consumption within one year and its carbon footprint based on the average carbon footprint for devices of that power rating.",
        "query": "WITH DevicePower AS (SELECT 1000000 AS powerRating), TotalEnergyConsumed AS (SELECT powerRating * 24 * 365 AS totalEnergyConsumed FROM DevicePower), EnvironmentalImpact AS (SELECT totalEnergyConsumed * (SELECT AVG(carbonFootprint) FROM EnvironmentalImpact WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE powerRating = 1000000)) AS carbonFootprint FROM TotalEnergyConsumed) SELECT totalEnergyConsumed, carbonFootprint FROM TotalEnergyConsumed, EnvironmentalImpact;",
        "step": "【step1】: Calculate annual energy consumption: Use CTE `DevicePower` to define the device's power rating (1,000,000 kW). Compute total yearly energy by multiplying power rating × 24 hours × 365 days in CTE `TotalEnergyConsumed`.  【step2】: Retrieve carbon footprint coefficient: Query the average `carbonFootprint` from the `EnvironmentalImpact` table for devices with matching `deviceId` (subquery linking `EnergyDevices` where `powerRating` = 1,000,000).  【step3】: Combine results: Multiply total energy consumption by the carbon footprint coefficient in CTE `EnvironmentalImpact`, then output `totalEnergyConsumed` and calculated `carbonFootprint` via cross-joining the two CTEs.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 501,
        "question": "Calculate the total energy output of a solar panel over a 12-hour period, assuming the solar radiation intensity is 800W/m², the area of the solar panel is 2m², and the efficiency is 20%.",
        "query": "SELECT (800 * 2 * 0.20 * (TIMESTAMPDIFF(HOUR, '2023-10-01 00:00:00', '2023-10-01 12:00:00'))) / 1000 AS total_energy_output FROM EnergyDevices WHERE deviceType = 'solar';",
        "step": "【step1】: Calculate the time duration in hours between '2023-10-01 00:00:00' and '2023-10-01 12:00:00' using TIMESTAMPDIFF(HOUR, ...).  【step2】: Compute energy output by multiplying solar radiation (800W/m²), area (2m²), efficiency (20%), and duration, then convert to kilowatt-hours by dividing by 1000.  【step3】: Filter records from EnergyDevices where deviceType is 'solar' and return the calculated total_energy_output.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 502,
        "question": "Calculate the total annual energy output in kilowatt-hours (kWh) for a wind turbine with a blade radius of 30 meters, operating at an efficiency of 40%, in air with a density of 1.225 kg/m³, and a wind speed of 10 m/s.",
        "query": "SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;",
        "step": "【step1】: Calculate the swept area of wind turbine blades using πr² formula  【step2】: Apply wind power formula (0.5 * air density * swept area * wind speed³)  【step3】: Multiply by efficiency and annual hours (8760), then convert to kWh by dividing 1000",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 503,
        "question": "Calculate the total carbon footprint of a fossil fuel generator over a year, assuming the carbon emission per kilowatt-hour of electricity generated is 0.5 kg CO2, with an annual generation of 100,000 kilowatt-hours.",
        "query": "SELECT 0.5 * 100000 AS total_carbon_footprint;",
        "step": "【step1】: Extract fixed parameters (0.5 kg CO2/kWh emission factor and 100,000 kWh annual generation value)  【step2】: Perform scalar multiplication of emission factor and annual generation quantity  【step3】: Alias the result as total_carbon_footprint using SELECT projection",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 504,
        "question": "Assuming the area of a solar panel is expanded to 1,000 m², its efficiency is increased to 100%, and the solar radiation intensity rises to 2,000 W/m², calculate its total electricity generation in kWh for one day.",
        "query": "SELECT (2000 * 1000 * 1 * 24) / 1000 AS total_energy_output_kWh;",
        "step": "【step1】: Multiply solar radiation intensity (2000 W/m²) by panel area (1000 m²) to get total power output (2,000,000 W).  【step2】: Multiply by efficiency (100% = 1) and duration (24 hours) to calculate total energy in watt-hours (48,000,000 Wh).  【step3】: Convert watt-hours to kilowatt-hours by dividing by 1000, resulting in 48,000 kWh.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 505,
        "question": "Calculate the total electricity generation in watt-hours of the solar panel named 'Solar Panel' during October 2023, assuming the solar radiation intensity is 1000 W/m², the solar panel area is 2 m², and the efficiency is 20%.",
        "query": "SELECT SUM((1000 * 2 * 20 * TIMESTAMPDIFF(HOUR, '2023-10-01 00:00:00', '2023-10-31 23:59:59')) / 1000) AS total_energy_generated FROM EnergyConsumption WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE deviceName = 'Solar Panel') AND timestamp BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59';",
        "step": "【step1】: Retrieve deviceId from EnergyDevices table where deviceName is 'Solar Panel' using a subquery.  【step2】: Calculate total hours between '2023-10-01 00:00:00' and '2023-10-31 23:59:59' with TIMESTAMPDIFF.  【step3】: Compute total energy via formula (1000 * 2 * 20 * hours / 1000) and aggregate results from EnergyConsumption filtered by deviceId and timestamp range.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 506,
        "question": "Calculate the total annual energy output of a wind turbine, assuming a wind speed of 10 m/s, a rotor diameter of 80 m, an air density of 1.225 kg/m³, and an efficiency of 40%.",
        "query": "SELECT 0.5 * 1.225 * PI() * POWER(80 / 2, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output;",
        "step": "【step1】: Calculate the instantaneous power output using the wind power formula: 0.5 * air density (1.225) * rotor area (π*(d/2)^2) * wind speed³ (10³) * efficiency (0.40)  【step2】: Multiply by annual hours (8760) to get yearly energy in watts-hour  【step3】: Convert to kilowatt-hours by dividing with 1000 (/1000)",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 507,
        "question": "Calculate the total energy consumption of a certain device within one year based on its rated power and operating time, assuming the device operates for 8 hours per day with a rated power of 50kW.",
        "query": "SELECT powerRating * 8 * 365 AS totalEnergyConsumption FROM EnergyDevices WHERE deviceId = '1';",
        "step": "【step1】: Filter EnergyDevices table by deviceId to locate the specific device's record.  【step2】: Retrieve the powerRating value (50kW) from the selected device record.  【step3】: Calculate total energy consumption using the formula: powerRating × 8 hours/day × 365 days/year, and alias the result as totalEnergyConsumption.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 508,
        "question": "Assuming a certain device has a power rating of 1000 kW and an efficiency of 200%, calculate its total energy output over a year, assuming the device operates 24 hours a day.",
        "query": "SELECT (powerRating * efficiency * 24 * 365 / 100) AS totalEnergyOutput FROM EnergyDevices WHERE deviceId = '6';",
        "step": "【step1】: Retrieve the powerRating (1000kW) and efficiency (200%) values for deviceId='6' from the EnergyDevices table.  【step2】: Calculate annual energy output using formula: (1000 * 200 * 24 * 365) / 100. The division by 100 converts percentage efficiency to decimal (200% → 2.0 multiplier).  【step3】: Return the calculated value as totalEnergyOutput through SELECT clause without requiring joins/filtering since deviceId filter already isolates the target record.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 509,
        "question": "Calculate the total energy generated by each solar device during January 2023, assuming constant solar radiation intensity.",
        "query": "SELECT SUM((ed.powerRating * ed.efficiency * 1000 * TIMESTAMPDIFF(HOUR, ec.timestamp, ec_end.timestamp)) / 1000) AS totalEnergyGenerated FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyConsumption ec_end ON ec.deviceId = ec_end.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp >= '2023-01-01 00:00:00' AND ec_end.timestamp <= '2023-01-31 23:59:59' GROUP BY ed.deviceId;",
        "step": "【step1】: Join EnergyDevices with two instances of EnergyConsumption (ec and ec_end) using deviceId to establish time period boundaries for each solar device.  【step2】: Calculate energy generation for each time interval using formula (powerRating * efficiency * 1000 * hourly duration / 1000), filtering solar devices and constraining timestamps between 2023-01-01 and 2023-01-31.  【step3】: Aggregate results by deviceId using SUM() to get total energy generated per solar panel over the specified month.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 510,
        "question": "Calculate the total power usage of device '1' over the year 2022.",
        "query": "WITH PowerData AS (SELECT deviceId, timestamp, powerUsage FROM EnergyConsumption WHERE deviceId = '指定风力发电机的deviceId' AND timestamp >= '2022-01-01' AND timestamp < '2023-01-01'), EnergyCalculation AS (SELECT deviceId, SUM(powerUsage * 1) AS totalEnergyGenerated FROM PowerData GROUP BY deviceId) SELECT deviceId, totalEnergyGenerated FROM EnergyCalculation;",
        "step": "【step1】: Filter relevant data for the specified wind turbine device ('deviceId') within the year 2022 using a CTE (PowerData), selecting deviceId, timestamp, and powerUsage from the EnergyConsumption table.  【step2】: Calculate the total energy generated by summing the product of powerUsage and 1 (likely a placeholder for a Weibull-based correction factor) in the EnergyCalculation CTE, grouped by deviceId.  【step3】: Output the final result by selecting deviceId and totalEnergyGenerated from the EnergyCalculation CTE.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 511,
        "question": "Determine whether each device requires an increased maintenance frequency in high-temperature environments.",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.nextMaintenanceDate, ec.temperature, CASE WHEN ec.temperature > 30 THEN '需要增加维护频率' ELSE '无需增加维护频率' END AS maintenanceFrequencyRecommendation FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ec.timestamp = (SELECT MAX(timestamp) FROM EnergyConsumption WHERE deviceId = ed.deviceId);",
        "step": "【step1】: Retrieve the latest temperature reading for each device by finding the maximum timestamp in the EnergyConsumption table.  【step2】: Join EnergyDevices and EnergyConsumption tables using deviceId, filtering records to only include the most recent consumption data identified in step 1.  【step3】: Apply CASE statement to dynamically classify maintenance frequency recommendations based on whether the latest temperature exceeds 30°C.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 512,
        "question": "Assuming the power of a certain device is increased to 10 million kilowatts, calculate its total energy consumption within one year.",
        "query": "SELECT 10000000 AS power_kw, 10000000 * 24 * 365 AS total_energy_consumption_kwh FROM dual;",
        "step": "【step1】: Calculate annual energy consumption by multiplying power (10,000 kW) by hours in a year (24*365).  【step2】: Output results with hardcoded values since no actual tables store power/electrical capacity data.  【step3】: (Not applicable - query lacks conditional checks)  Note: The provided query uses hardcoded values and doesn't reference actual database tables, making it a basic arithmetic operation rather than a data-driven analysis.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 513,
        "question": "Calculate the total energy generated by a solar panel during a specific time period, assuming its efficiency is 20%, rated power is 5 kilowatts, and the solar radiation intensity remains constant at 800 watts per square meter during that time period.",
        "query": "SELECT (efficiency * powerRating * 800 * TIMESTAMPDIFF(HOUR, '2023-01-01 00:00:00', '2023-01-01 12:00:00')) / 1000 AS totalEnergyGenerated FROM EnergyDevices WHERE deviceName = 'Solar Panel';",
        "step": "【step1】: Filter the EnergyDevices table to retrieve the solar panel's efficiency and power rating using WHERE deviceName = 'Solar Panel'.  【step2】: Calculate the time difference in hours between '2023-01-01 00:00:00' and '2023-01-01 12:00:00' using TIMESTAMPDIFF(HOUR, ...).  【step3】: Compute total energy by multiplying efficiency (0.2), powerRating (5kW), radiation (800W/m²), duration (12h), and convert to kWh via /1000.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 514,
        "question": "Calculate the estimated total energy output for the 'FutureDeviceA' wind device over one year based on its power rating and efficiency.",
        "query": "WITH DeviceInfo AS (SELECT deviceId, powerRating, efficiency FROM EnergyDevices WHERE deviceType = 'wind' AND deviceName = 'FutureDeviceA'), EnergyData AS (SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption WHERE deviceId = (SELECT deviceId FROM DeviceInfo) AND timestamp >= DATE_SUB(NOW(), INTERVAL 1 YEAR) GROUP BY deviceId) SELECT d.deviceId, d.powerRating * d.efficiency / 100 * 8760 AS estimatedTotalEnergyOutput FROM DeviceInfo d;",
        "step": "【step1】: Retrieve device specifications (powerRating and efficiency) for the target wind turbine using a CTE (DeviceInfo).  【step2】: Calculate theoretical annual energy output via formula: (powerRating * efficiency / 100 * 8760 hours), bypassing wind distribution complexity.  【step3】: Ignore the unused EnergyData CTE and directly output the theoretical estimation from DeviceInfo.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 515,
        "question": "Based on the equipment's maintenance frequency, calculate the annual number of maintenance interventions and the total estimated maintenance cost, assuming each maintenance costs 5000 yuan.",
        "query": "SELECT deviceId, deviceName, 12 / 6 AS maintenanceCount, 12 / 6 * 5000 AS estimatedMaintenanceCost FROM EnergyDevices;",
        "step": "【step1】: Retrieve device identifiers and names from the EnergyDevices table.  【step2】: Calculate the estimated annual maintenance count by dividing 12 months by the 6-month average interval (12/6).  【step3】: Multiply the maintenance count by the per-maintenance cost (5000) to derive the total estimated annual maintenance cost.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 516,
        "question": "Assuming the device has a power rating of 1000 kilowatts, calculate the maximum energy output when operating continuously for one year, without considering energy losses.",
        "query": "SELECT powerRating * 24 * 365 AS maxEnergyOutput FROM EnergyDevices WHERE deviceId = '1';",
        "step": "【step1】:【Filter the EnergyDevices table for the specific device using WHERE deviceId = '1'】  【step2】:【Retrieve the powerRating value (1000 kW) from the selected device】  【step3】:【Calculate maxEnergyOutput by multiplying powerRating by 24 (hours/day) and 365 (days/year)】",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 517,
        "question": "Calculate the theoretical maximum power generation capacity for all solar energy equipment, and sort the results in ascending order by equipment name.",
        "query": "SELECT deviceName, powerRating * efficiency AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter records from `EnergyDevices` where `deviceType` equals 'solar' using the WHERE clause.  【step2】: Calculate `theoreticalMaxOutput` for each device by multiplying `powerRating` with `efficiency` in the SELECT clause.  【step3】: Sort the results in ascending order by `deviceName` using the ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 518,
        "question": "Calculate the total energy consumption of wind power equipment in the past year, ranked in descending order by energy consumption value, and take the top 5.",
        "query": "SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 5;",
        "step": "【step1】: Join EnergyDevices and EnergyConsumption tables on deviceId, filter for 'wind' devices and 2022 date range.  【step2】: Group results by deviceId and deviceName, calculate SUM(energyConsumed) for each group.  【step3】: Sort aggregated results by totalEnergyConsumed in descending order, apply LIMIT 5 to get top consumers.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 519,
        "question": "Find all equipment that requires maintenance in 2023, and count how many devices are in each status group.",
        "query": "SELECT status, COUNT(*) AS device_count FROM EnergyDevices WHERE nextMaintenanceDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status;",
        "step": "【step1】: Filter devices requiring maintenance in 2023 using WHERE nextMaintenanceDate BETWEEN '2023-01-01' AND '2023-12-31'.  【step2】: Group the filtered results by status using GROUP BY status.  【step3】: Count devices per status group using COUNT(*) AS device_count.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 520,
        "question": "Assuming the efficiency of all devices improves to 100%, calculate the energy savings of each device over one year, rank them in descending order of energy saved, and take the top 10.",
        "query": "SELECT deviceId, deviceName, (100 - efficiency) * powerRating * 8760 AS energySaved FROM EnergyDevices ORDER BY energySaved DESC LIMIT 10;",
        "step": "【step1】: Extract deviceId, deviceName, efficiency, and powerRating from EnergyDevices table.  【step2】: Calculate energySaved for each device using formula (100 - efficiency) * powerRating * 8760 (annual hours).  【step3】: Sort results by energySaved in descending order and return top 10 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 521,
        "question": "Please calculate the average efficiency of all solar panels produced by the manufacturer 'GreenTech', and find the deviceId and efficiency of the top 5 devices with the highest efficiency.",
        "query": "WITH GreenTechDevices AS (SELECT ed.deviceId, ed.efficiency FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar') SELECT AVG(efficiency) AS average_efficiency FROM GreenTechDevices; WITH GreenTechDevices AS (SELECT ed.deviceId, ed.efficiency FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar') SELECT deviceId, efficiency FROM GreenTechDevices ORDER BY efficiency DESC LIMIT 5;",
        "step": "【step1】: Join EnergyDevices with Manufacturers to filter devices of type 'solar' from 'GreenTech', creating a temporary dataset.  【step2】: Calculate the average efficiency from the filtered dataset.  【step3】: Sort the same dataset by efficiency in descending order and select the top 5 deviceIds with their efficiencies.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 522,
        "question": "Please calculate the total power output of all wind turbines manufactured by 'EcoPower' and identify the top 3 devices with the highest power ratings, including their deviceId and powerRating.",
        "query": "SELECT SUM(ed.powerRating) AS total_power, ed.deviceId, ed.powerRating FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'EcoPower' AND ed.deviceType = 'wind' GROUP BY ed.deviceId, ed.powerRating ORDER BY ed.powerRating DESC LIMIT 3;",
        "step": "【step1】: Join EnergyDevices and Manufacturers tables, filter by manufacturerName 'EcoPower' and deviceType 'wind'.  【step2】: Group results by deviceId and powerRating, calculate total_power using SUM(ed.powerRating).  【step3】: Sort grouped results by powerRating in descending order, return top 3 entries with LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 523,
        "question": "Please find the average maintenance cost for equipment produced by the manufacturer 'SunEnergy' with an installation date before 2020.",
        "query": "SELECT AVG(mr.cost) AS average_maintenance_cost FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId JOIN MaintenanceRecords mr ON ed.deviceId = mr.deviceId WHERE m.manufacturerName = 'SunEnergy' AND ed.installationDate < '2020-01-01';",
        "step": "【step1】: Join Manufacturers table with EnergyDevices using manufacturerId to filter devices from 'SunEnergy' manufacturer and installationDate before 2020  【step2】: Join the filtered EnergyDevices with MaintenanceRecords using deviceId to access corresponding maintenance costs  【step3】: Apply AVG() function on mr.cost column to calculate the average maintenance cost",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 524,
        "question": "Assuming the rated power of all devices manufactured by 'FutureEnergy' has been increased by 1000 times, please identify the top 10 devices with the highest power, listing their deviceId and powerRating.",
        "query": "WITH IncreasedPower AS (SELECT ed.deviceId, ed.powerRating * 1000 AS increasedPowerRating FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'FutureEnergy') SELECT deviceId, increasedPowerRating AS powerRating FROM IncreasedPower ORDER BY increasedPowerRating DESC LIMIT 10;",
        "step": "【step1】: Filter devices by joining EnergyDevices and Manufacturers to select only those from 'FutureEnergy'.  【step2】: Calculate increased power ratings by multiplying original powerRating by 1000.  【step3】: Sort results in descending order by increasedPowerRating and limit to the top 10 devices.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 525,
        "question": "Calculate the total energy consumption of each device during a specified time period and identify the device with the highest energy consumption.",
        "query": "SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: Filter energy consumption records within the specified time period (2023-01-01 to 2023-12-31) from the EnergyConsumption table.  【step2】: Join EnergyDevices to get device details, group by deviceId/deviceName, and calculate total energy consumption using SUM().  【step3】: Sort results by totalEnergyConsumed in descending order and select the top record via LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 526,
        "question": "Calculate the average efficiency of all devices and identify those devices with efficiency below the average.",
        "query": "WITH AverageEfficiency AS (SELECT AVG(efficiency) AS avg_efficiency FROM EnergyEfficiency) SELECT ed.deviceId, ed.deviceName, ed.efficiency FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId CROSS JOIN AverageEfficiency WHERE ee.efficiency < AverageEfficiency.avg_efficiency;",
        "step": "【step1】: Calculate the average efficiency of all devices using a CTE (Common Table Expression) from the EnergyEfficiency table.  【step2】: Join EnergyDevices with EnergyEfficiency on deviceId and cross-join with the CTE to combine device details with the pre-computed average efficiency.  【step3】: Filter devices where their efficiency in EnergyEfficiency is lower than the average efficiency from the CTE.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 527,
        "question": "Find equipment that has not undergone maintenance in the past year or has never undergone maintenance and list the detailed information of these devices.",
        "query": "SELECT * FROM EnergyDevices WHERE lastMaintenanceDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) OR lastMaintenanceDate IS NULL;",
        "step": "【step1】: Calculate the cutoff date for \"1 year ago\" using DATE_SUB(CURDATE(), INTERVAL 1 YEAR).  【step2】: Filter EnergyDevices where lastMaintenanceDate is before the calculated cutoff date.  【step3】: Include records with NULL lastMaintenanceDate by adding OR condition to the WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 528,
        "question": "Assuming the power of a certain device suddenly increases to 10,000 kilowatts, retrieve its device details, timestamp, power usage, energy consumed, environmental readings, and associated maintenance records.",
        "query": "WITH AbnormalPowerUsage AS (SELECT deviceId, timestamp, powerUsage, energyConsumed, temperature, humidity FROM EnergyConsumption WHERE powerUsage >= 10000) SELECT AP.deviceId, AP.timestamp, AP.powerUsage, AP.energyConsumed, AP.temperature, AP.humidity, ED.deviceName, ED.deviceType, ED.powerRating, ED.efficiency, ED.status, ED.location, MR.maintenanceType, MR.maintenanceDescription, MR.nextMaintenanceDate FROM AbnormalPowerUsage AP JOIN EnergyDevices ED ON AP.deviceId = ED.deviceId LEFT JOIN MaintenanceRecords MR ON AP.deviceId = MR.deviceId ORDER BY AP.timestamp DESC;",
        "step": "【step1】: Extract abnormal power usage data by filtering EnergyConsumption where powerUsage ≥ 10000 and create CTE \"AbnormalPowerUsage\" with deviceId, timestamp, powerUsage, energyConsumed, temperature, and humidity.  【step2】: Join AbnormalPowerUsage with EnergyDevices via deviceId to retrieve device metadata (name, type, powerRating, status, etc.) for contextual analysis of affected devices.  【step3】: Perform a LEFT JOIN with MaintenanceRecords on deviceId to incorporate maintenance history (type, description, next maintenance date), then sort results by timestamp descending to prioritize recent anomalies.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 529,
        "question": "Calculate the total energy generated by solar devices during January 2023, assuming each device has a radiation intensity of 800W/m², an area of 2m², and an efficiency of 20%.",
        "query": "SELECT SUM((800 * 2 * 20 * TIMESTAMPDIFF(HOUR, '2023-01-01 00:00:00', '2023-01-31 23:59:59')) / 1000) AS total_energy_generated FROM EnergyDevices WHERE deviceType = 'solar';",
        "step": "【step1】: Calculate total hours between '2023-01-01 00:00:00' and '2023-01-31 23:59:59' using TIMESTAMPDIFF(HOUR, ...).  【step2】: Compute energy per device with formula (800 * 2 * 20 * hours) / 1000 (converting Wh to kWh).  【step3】: Aggregate results using SUM() for all solar devices filtered by WHERE deviceType = 'solar'.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 530,
        "question": "Calculate the total annual electricity generation of a wind turbine, assuming a wind speed of 10 m/s, air density of 1.225 kg/m³, a turbine blade radius of 30 m, and an efficiency of 40%.",
        "query": "SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;",
        "step": "【step1】: Decompose the wind energy formula components: 0.5 * air_density * swept_area (πr²) * wind_speed³ * efficiency  【step2】: Substitute parameters: air_density=1.225, r=30m, wind_speed=10m/s, efficiency=0.4  【step3】: Calculate annual output: Multiply by 8760 hours/year and convert W·h to kWh via /1000",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 531,
        "question": "Identify the device with the highest energy consumption in the energy consumption table and calculate its hourly energy cost, assuming an electricity price of 0.5 yuan per kilowatt-hour.",
        "query": "WITH MaxEnergyConsumption AS (SELECT deviceId, MAX(energyConsumed) AS maxEnergyConsumed FROM EnergyConsumption GROUP BY deviceId) SELECT ec.deviceId, ed.deviceName, mec.maxEnergyConsumed, (mec.maxEnergyConsumed * 0.5) AS hourlyCost FROM EnergyConsumption ec JOIN MaxEnergyConsumption mec ON ec.deviceId = mec.deviceId AND ec.energyConsumed = mec.maxEnergyConsumed JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId ORDER BY mec.maxEnergyConsumed DESC LIMIT 1;",
        "step": "【step1】: **Identify maximum energy consumption per device**  Create a CTE (MaxEnergyConsumption) to find the highest energyConsumed value for each deviceId from the EnergyConsumption table using `MAX(energyConsumed)` with `GROUP BY deviceId`.  【step2】: **Join tables to retrieve device details and calculate costs**  Join EnergyConsumption (ec) with MaxEnergyConsumption (mec) on both deviceId and energyConsumed to ensure exact matches, then join EnergyDevices (ed) to get deviceName. Calculate hourly cost by multiplying maxEnergyConsumed with 0.5.  【step3】: **Sort and limit results**  Order the final results by maxEnergyConsumed in descending order and use `LIMIT 1` to return only the device with the highest energy consumption value.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 532,
        "question": "Assuming the efficiency of a certain device suddenly increases to 1000%, calculate the energy and cost savings within one year, given that the original efficiency of the device was 20%, with an annual energy consumption of 100,000 kilowatt-hours and an electricity price of 0.5 yuan per kilowatt-hour.",
        "query": "WITH EfficiencyData AS (SELECT 20 AS originalEfficiency, 1000 AS newEfficiency, 100000 AS annualEnergyConsumption, 0.5 AS electricityPrice) SELECT annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency AS energySaved, annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency * electricityPrice AS costSavings FROM EfficiencyData;",
        "step": "【step1】: Create a CTE named EfficiencyData to store static parameters: original efficiency (20%), new efficiency (1000%), annual energy consumption (100,000 kWh), and electricity price (0.5 RMB/kWh).  【step2】: Calculate energy saved by applying the formula: (newEfficiency - originalEfficiency) / originalEfficiency * annualEnergyConsumption.  【step3】: Derive cost savings by multiplying energy saved by electricityPrice.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 533,
        "question": "Calculate the total energy consumption of each device during 2023 and identify the device with the highest energy consumption.",
        "query": "WITH DeviceEnergy AS (SELECT ec.deviceId, SUM(ec.powerUsage * TIMESTAMPDIFF(SECOND, ec.timestamp, (SELECT MIN(ec2.timestamp) FROM EnergyConsumption ec2 WHERE ec2.deviceId = ec.deviceId AND ec2.timestamp > ec.timestamp))) / 3600 AS totalEnergyConsumption FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT de.deviceId, ed.deviceName, de.totalEnergyConsumption FROM DeviceEnergy de JOIN EnergyDevices ed ON de.deviceId = ed.deviceId ORDER BY de.totalEnergyConsumption DESC LIMIT 1;",
        "step": "【step1】: Compute time-weighted energy consumption for each device within 2023 by multiplying power usage with duration between consecutive timestamps (converted to hours) using correlated subquery.  【step2】: Join computed energy data (DeviceEnergy CTE) with EnergyDevices table to retrieve device names.  【step3】: Sort devices by total energy consumption in descending order and select top record as highest consumer.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 534,
        "question": "Calculate the average efficiency of all devices over the past year and identify devices with efficiency below this average.",
        "query": "WITH DeviceYearlyEfficiency AS ( SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId ), OverallAverageEfficiency AS ( SELECT AVG(avgEfficiency) AS overallAvgEfficiency FROM DeviceYearlyEfficiency ) SELECT ed.deviceId, ed.deviceName, ed.deviceType, dye.avgEfficiency FROM DeviceYearlyEfficiency dye JOIN EnergyDevices ed ON dye.deviceId = ed.deviceId JOIN OverallAverageEfficiency oae ON dye.avgEfficiency < oae.overallAvgEfficiency;",
        "step": "",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 535,
        "question": "Identify equipment that has not undergone maintenance in the past year and list the names and locations of these devices.",
        "query": "SELECT ed.deviceName, ed.location FROM EnergyDevices ed WHERE ed.deviceId NOT IN (SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR));",
        "step": "【step1】: Retrieve all device IDs from the MaintenanceRecords table where maintenance occurred within the past year using a subquery:  ```sql  SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)  ```  【step2】: Use the NOT IN operator in the main query to filter EnergyDevices whose deviceId is not in the subquery result, ensuring devices without recent maintenance are selected.  【step3】: Output the required fields (deviceName and location) from the filtered EnergyDevices records.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 536,
        "question": "Assuming the power of a certain device suddenly increases to 1,000,000 kilowatts, calculate its total energy consumption over one year, and compare the difference with the total energy consumption of all devices.",
        "query": "WITH DeviceEnergy AS (SELECT deviceId, powerRating * 24 * 365 AS totalEnergyConsumption FROM EnergyDevices WHERE deviceId = '1'), AllDevicesEnergy AS (SELECT SUM(powerRating * 24 * 365) AS totalEnergyConsumptionAll FROM EnergyDevices) SELECT DE.totalEnergyConsumption AS SpecificDeviceEnergy, ADE.totalEnergyConsumptionAll AS AllDevicesEnergy, DE.totalEnergyConsumption - ADE.totalEnergyConsumptionAll AS EnergyDifference FROM DeviceEnergy DE, AllDevicesEnergy ADE;",
        "step": "【step1】: Calculate annual energy consumption for the specific device (powerRating * 24 * 365) from EnergyDevices where deviceId matches the target device.  【step2】: Calculate total annual energy consumption for all devices by summing individual calculations (powerRating * 24 * 365) across the entire EnergyDevices table.  【step3】: Cross-join both CTE results to compare the specific device's energy consumption with the total system consumption, calculating their numerical difference.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 537,
        "question": "If a gas station stores 10,000 liters of gasoline with a carbon emission of 2.31 grams per liter, how many grams of carbon dioxide would be produced if all the gasoline were completely burned?",
        "query": "SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Fuel_Type = 'gasoline' AND Stock_Liters = 10000;",
        "step": "【step1】: Filter records in 'gas' table where Fuel_Type is 'gasoline' and Stock_Liters equals 10000.  【step2】: Calculate Total_Carbon_Emission by multiplying Stock_Liters and Carbon_Emission for the filtered record.  【step3】: Output the Total_Carbon_Emission value directly without further processing.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 538,
        "question": "The sales revenue of an oil company is $500, with a net profit margin of 5% and a debt-to-equity ratio of 2:1. Find the company's net profit and total assets.",
        "query": "SELECT Sales * Net_Profit_Margin / 100 AS Profits, (Sales * Net_Profit_Margin / 100) * (Debt_Equity_Ratio + 1) AS Assets FROM company WHERE Sales = 500;",
        "step": "【step1】: Filter the company record where Sales equals 500 (billion dollars).  【step2】: Calculate Profits by multiplying Sales (500) by Net_Profit_Margin (5%) and dividing by 100 to convert the percentage.  【step3】: Compute Assets using the calculated Profits multiplied by (Debt_Equity_Ratio + 1), leveraging the 2:1 ratio to derive total liabilities + equity.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 539,
        "question": "If a gas station located at 'test location' has a minimum inventory level of 5,000 liters, a current inventory of 4,500 liters, and an average daily sales volume of 1,000 liters, how many days later does the station need to replenish its inventory to avoid a stockout?",
        "query": "SELECT (Minimum_Stock_Liters - Stock_Liters) / 1000 AS Days_Until_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');",
        "step": "【step1】: Retrieve the Station_ID from the gas_station table where the Location matches 'test location'.  【step2】: Use the retrieved Station_ID to filter the gas table and access Stock_Liters and Minimum_Stock_Liters.  【step3】: Calculate the required days by dividing the difference between Minimum_Stock_Liters and Stock_Liters by the daily sales (1000 liters).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 540,
        "question": "If a gas station has a total fuel capacity of 1,000,000 liters, with each liter priced at 10 dollars and a tax of 1 dollar per liter, and if the gas station sells all the fuel at once without considering any costs or losses, what would be the station's total revenue?",
        "query": "SELECT gs.Capacity_Liters * (g.Price_Liter + g.Tax_per_Liter) AS Total_Revenue FROM gas_station gs JOIN gas g ON gs.Station_ID = g.Station_ID WHERE gs.Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');",
        "step": "【step1】: Execute the subquery `(SELECT Station_ID FROM gas_station WHERE Location = 'test location')` to retrieve the **Station_ID** of the gas station at the specified location.  【step2】: Join the **gas_station** and **gas** tables using the obtained **Station_ID** to link the station's total capacity with the corresponding fuel price and tax data.  【step3】: Calculate **Total_Revenue** by multiplying the station's **Capacity_Liters** with the sum of **Price_Liter** and **Tax_per_Liter** from the joined gas record.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 541,
        "question": "If a gas station stores 50,000 liters of diesel with a density of approximately 0.85 kilograms per liter, what is the total mass of this diesel?",
        "query": "SELECT 50000 * 0.85 AS TotalMass;",
        "step": "【step1】: Retrieve the stored diesel volume (50,000 liters) from the 'gas' table where Fuel_Type is 'Diesel'.  【step2】: Multiply the volume by the density constant (0.85 kg/L) to calculate total mass.  【step3】: Return the result as TotalMass using direct scalar computation.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 542,
        "question": "If the revenue growth rate of BP China is 5% and last year's sales were $300 billion, what is the projected sales for this year? If the net profit margin is 10%, what is the expected profit for this year?",
        "query": "SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales, Sales * (1 + Revenue_Growth_Rate / 100) * Net_Profit_Margin / 100 AS Projected_Profit FROM company WHERE Company = 'BP China';",
        "step": "【step1】: Retrieve the company's current Sales, Revenue_Growth_Rate, and Net_Profit_Margin from the company table with the condition Company = 'BP China'.  【step2】: Calculate the Projected_Sales by multiplying Sales by (1 + Revenue_Growth_Rate / 100).  【step3】: Calculate the Projected_Profit by multiplying Projected_Sales by Net_Profit_Margin / 100.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 543,
        "question": "If the gas station has a minimum inventory of 10,000 liters, a current inventory of 12,000 liters, and an average daily sales volume of 2,000 liters, will this gas station need to refuel immediately?",
        "query": "SELECT CASE WHEN (Stock_Liters - Minimum_Stock_Liters) / 2000 <= 0 THEN 'need to immediately refuel' ELSE 'no need to immediately refuel' END AS RefuelNeeded FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Calculate the available stock surplus by subtracting the minimum required stock from the current stock: (Stock_Liters - Minimum_Stock_Liters).  【step2】: Determine the remaining operational days by dividing the surplus by daily sales volume: (Result from Step1) / 2000.  【step3】: Use CASE to check if the result is ≤ 0. Return corresponding refuel status based on the threshold comparison.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 544,
        "question": "If a gas station has a total fuel capacity of 50,000 liters, with a fuel price of $5 per liter and a tax of $1 per liter, and if the gas station sells 100,000 liters of fuel in a day, what is the gas station's daily revenue? If the station's carbon emission is 2.5 grams per liter, what is the total carbon emission for that day?",
        "query": "SELECT 100000 * (5 + 1) AS DailyRevenue, 100000 * 2.5 AS TotalCarbonEmission;",
        "step": "【step1】: Calculate daily revenue by multiplying the sold liters (100,000) by the sum of price per liter (5) and tax per liter (1).  【step2】: Calculate total carbon emissions by multiplying the sold liters (100,000) by the carbon emission per liter (2.5).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 545,
        "question": "If a gas station at 'test location' stores 50,000 liters of diesel, and the sulfur content per liter is 10 ppm (parts per million), then how many grams of sulfur in total do these diesels contain?",
        "query": "SELECT Stock_Liters * Sulfur_Content * 0.001 AS Total_Sulfur_Content_Grams FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');",
        "step": "【step1】: Execute the subquery `(SELECT Station_ID FROM gas_station WHERE Location = 'test location')` to retrieve the unique Station_ID of the specified gas station location.  【step2】: Filter the `gas` table using `Fuel_Type = 'diesel'` and the obtained Station_ID from Step 1 to isolate the diesel fuel entry for the specified station.  【step3】: Calculate total sulfur content by multiplying `Stock_Liters` (50,000 liters), `Sulfur_Content` (10 ppm = 10 mg/kg ≈ 10 mg/L for water-like density), and convert milligrams to grams using `* 0.001`, resulting in `50000 * 10 * 0.001 = 500 grams`.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 546,
        "question": "If BP China's revenue growth rate is 8% and last year's sales were 30 billion dollars, what is the projected sales for this year?",
        "query": "SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales FROM company WHERE Company = 'BP China';",
        "step": "【step1】: Retrieve last year's sales and revenue growth rate for the specified company using the WHERE clause.  【step2】: Calculate this year's projected sales by applying the formula Sales * (1 + Revenue_Growth_Rate / 100).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 547,
        "question": "If the minimum inventory level for a gas station is 2000 liters, the current inventory is 2100 liters, and the next fuel delivery date is in 3 days, does this gas station need to arrange for fuel replenishment in advance?",
        "query": "SELECT CASE WHEN Stock_Liters - ((Stock_Liters - Minimum_Stock_Liters) / 3 * 3) < Minimum_Stock_Liters THEN 'need to replenish in advance' ELSE 'no need to replenish in advance' END AS Need_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');",
        "step": "【step1】: Execute the subquery `(SELECT Station_ID FROM gas_station WHERE Location = 'test location')` to retrieve the **Station_ID** of the specified gas station based on its location.  【step2】: Use the obtained **Station_ID** to access the corresponding record in the **gas** table and calculate if the projected stock after 3 days (current stock minus estimated consumption) falls below the minimum threshold.  【step3】: Apply the **CASE** statement to determine if the station needs replenishment by comparing `Stock_Liters - ((Stock_Liters - Minimum_Stock_Liters) / 3 * 3)` with `Minimum_Stock_Liters`, returning 'need to replenish in advance' or 'no need to replenish in advance' as the result.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 548,
        "question": "If a gas station with location 'test location' has a total fuel capacity of 1,000,000 liters and the carbon emissions per liter of fuel is 2.31 grams, what is the total carbon emissions of this gas station? If the total fuel capacity of this gas station increases to 1,000,000,000 liters, with the carbon emissions per liter still at 2.31 grams, what is the total carbon emissions of this gas station? How many cars’ annual emissions does this amount of carbon emissions equate to? (The average annual carbon emissions of a car is 4,000 kilograms)",
        "query": "SELECT Capacity_Liters * 2.31 AS Total_Carbon_Emission_Grams, (Capacity_Liters * 2.31) / 1000 / 4000 AS Equivalent_Car_Emissions FROM gas_station WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');",
        "step": "【step1】: Retrieve Station_ID for the specified location using subquery: SELECT Station_ID FROM gas_station WHERE Location = 'test location'  【step2】: Calculate total carbon emissions by multiplying Capacity_Liters with 2.31 grams/liter: Capacity_Liters * 2.31 AS Total_Carbon_Emission_Grams  【step3】: Convert grams to kilograms and divide by annual car emissions (4000kg) to get equivalent car emissions: (Total_Carbon_Emission_Grams / 1000) / 4000 AS Equivalent_Car_Emissions",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 549,
        "question": "If a gas station has a total capacity of 100,000 liters, with a current inventory of 80,000 liters, and the fuel density is 0.75 kg/L, what is the total mass of the current fuel inventory?",
        "query": "SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000) AND Stock_Liters = 80000;",
        "step": "【step1】: Retrieve the Station_ID from the gas_station table where the Capacity_Liters equals 100,000.  【step2】: Use the obtained Station_ID to filter records in the gas table where Stock_Liters equals 80,000.  【step3】: Multiply the Stock_Liters value by the fuel density (0.75 kg/L) to calculate the Total_Mass_Kg.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 550,
        "question": "The net profit margin of BP China is 15%, with sales of $50 billion. What is the company's net profit? If the company aims to increase the net profit margin to 20%, how much does the sales need to reach?",
        "query": "SELECT Sales * Net_Profit_Margin / 100 AS Current_Profits, (Sales * Net_Profit_Margin / 100) / 0.20 AS Required_Sales FROM company WHERE Company = 'BP China';",
        "step": "【step1】: Filter the company table to retrieve the record for 'BP China' using the WHERE clause.  【step2】: Calculate the current profits by multiplying Sales by Net_Profit_Margin and dividing by 100 (to convert percentage to decimal).  【step3】: Compute the required sales for a 20% net profit margin by dividing the current profits by 0.20.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 551,
        "question": "If a gas station's fuel inventory is below the minimum stock level, the system will issue an alert. Given that a certain gas station has a minimum inventory of 10,000 liters, a current inventory of 9,500 liters, and daily sales of 2,000 liters, for how many more days can the station sustain sales?",
        "query": "SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Remaining_Days FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Minimum_Stock_Liters = 10000) AND Stock_Liters = 9500;",
        "step": "【step1】: Retrieve Station_ID from gas_station where Minimum_Stock_Liters = 10000 via a nested subquery.  【step2】: Filter the gas table for entries with Stock_Liters = 9500 and Station_ID matching the subquery result.  【step3】: Calculate remaining days by subtracting Minimum_Stock_Liters from Stock_Liters and dividing by the daily sales value (2000).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 552,
        "question": "A gas station has a total fuel capacity of 1,000,000 liters, and the current inventory is 999,999 liters. If the station sells 1 liter of fuel per second and receives no new fuel deliveries, how long will it take for the inventory to be sold down to the minimum inventory level (the minimum inventory level is 10,000 liters)?",
        "query": "SELECT (Stock_Liters - Minimum_Stock_Liters) / 1 AS Required_Time_Seconds FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;",
        "step": "【step1】: Execute the subquery `SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000` to find the **Station_ID** of the gas station with a total capacity of 1,000,000 liters.  【step2】: Filter the `gas` table using the obtained **Station_ID** from step 1 and the condition `Stock_Liters = 999999` to locate the specific fuel entry with current stock matching 999,999 liters.  【step3】: Calculate `(Stock_Liters - Minimum_Stock_Liters) / 1` for the matched entry, which computes the time in seconds required to deplete the stock from 999,999 liters to the minimum threshold of 10,000 liters (result: **989,999 seconds**).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 553,
        "question": "If a gas station sells 5,000 liters of diesel per day, with each liter containing 0.01 grams of sulfur, what is the total amount of sulfur emitted in grams per day?",
        "query": "SELECT 5000 * Sulfur_Content * 0.001 AS Sulfur_Total_Grams FROM gas WHERE Fuel_Type = 'diesel';",
        "step": "【step1】: Filter gas table entries where Fuel_Type is 'diesel' to isolate diesel fuel data.  【step2】: Retrieve the Sulfur_Content value (10ppm) from the filtered diesel fuel record.  【step3】: Calculate total sulfur emissions by multiplying daily sales (5000 liters) by Sulfur_Content (10ppm) and converting to grams using 0.001 (since 1ppm = 1mg/L → 1g = 1000mg).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 554,
        "question": "An oil company has a revenue growth rate of 8%, with last year's sales amounting to $300 billion. If the growth rate remains unchanged, what is the projected sales figure after 5 years for BP China?",
        "query": "SELECT Sales * POWER(1 + Revenue_Growth_Rate / 100, 5) AS Future_Sales FROM company WHERE Company = 'BP China';",
        "step": "【step1】: Filter the 'company' table to retrieve the current Sales and Revenue_Growth_Rate for 'BP China'.  【step2】: Apply the compound growth formula (Sales × (1 + Revenue_Growth_Rate/100)^5) using the POWER function.  【step3】: Return the calculated value as Future_Sales, representing the projected sales after 5 years.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 555,
        "question": "If a gas station has a total fuel capacity of 20,000 liters, a current inventory of 5,000 liters, and a minimum inventory requirement of 1,000 liters, how many liters of fuel can be sold at most without restocking?",
        "query": "SELECT Stock_Liters - Minimum_Stock_Liters AS Max_Sellable_Liters FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 20000 AND gas.Stock_Liters = 5000 AND gas.Minimum_Stock_Liters = 1000;",
        "step": "【step1】: Join 'gas_station' and 'gas' tables using Station_ID to link station capacity with fuel inventory data.  【step2】: Filter records where Capacity_Liters = 20000, Stock_Liters = 5000, and Minimum_Stock_Liters = 1000 to isolate the target scenario.  【step3】: Calculate Max_Sellable_Liters by subtracting Minimum_Stock_Liters from Stock_Liters in the filtered result.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 556,
        "question": "A gas station has a fuel inventory equal to its total capacity of 20,000 liters. If each liter of fuel emits 2.31 grams of carbon, what would be the total carbon emissions if all this fuel were burned? Could a situation where the inventory exceeds the capacity realistically happen?",
        "query": "SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas JOIN gas_station ON gas.Station_ID = gas_station.Station_ID WHERE gas_station.Capacity_Liters = 20000;",
        "step": "【step1】: Perform an INNER JOIN between `gas` and `gas_station` tables using `Station_ID` to link fuel data with specific station capacity details.  【step2】: Filter the joined dataset using `WHERE gas_station.Capacity_Liters = 20000` to isolate stations with a total capacity of 20,000 liters.  【step3】: Calculate the hypothetical carbon emissions by multiplying the fixed value **1,000,000 liters** (exceeding capacity) by the `Carbon_Emission` value (2.31 g/L) for matching records, returning `Total_Carbon_Emission`.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 557,
        "question": "If a gas station has a capacity of at least 50,000 liters and stores diesel, and the calorific value of diesel is 35.8 MJ/L, how much energy can be released from the diesel in stock if it is completely burned?",
        "query": "SELECT Stock_Liters * 35.8 AS Total_Energy_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000 LIMIT 1);",
        "step": "【step1】: Execute the subquery to find a gas station with a capacity of at least 50,000 liters: `SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000 LIMIT 1`.  【step2】: Use the retrieved `Station_ID` to filter the `gas` table for diesel fuel entries: `WHERE Fuel_Type = 'diesel' AND Station_ID = [result_from_step1]`.  【step3】: Calculate the total energy by multiplying `Stock_Liters` with the calorific value (35.8 MJ/L): `SELECT Stock_Liters * 35.8 AS Total_Energy_MJ`.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 558,
        "question": "An oil company has sales of $300, a net profit margin of 12%, and a debt-to-equity ratio of 0.8. If the company wants to reduce its debt-to-equity ratio to 0.5, how much debt does it need to repay, assuming shareholders' equity remains unchanged?",
        "query": "SELECT (Debt_Equity_Ratio * (Sales * Net_Profit_Margin / 100)) - (0.5 * (Sales * Net_Profit_Margin / 100)) AS Debt_Repayment FROM company WHERE Sales = 300 AND Net_Profit_Margin = 12 AND Debt_Equity_Ratio = 0.8;",
        "step": "【step1】: Calculate the current equity by multiplying the sales ($30 billion) by the net profit margin (12%): **300 * 12 / 100 = 36 billion**.  【step2】: Compute the debt reduction amount by subtracting the target debt (0.5×equity) from the original debt (0.8×equity): **(0.8×36) - (0.5×36)**.  【step3】: Execute the calculation via SQL, filtering the company with the given parameters (sales=300, net profit margin=12, debt-equity ratio=0.8).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 559,
        "question": "If a gas station has a fuel inventory of 20,000 liters, a minimum inventory level of 10,000 liters, and an average daily sales volume of 2,000 liters, and it is selected from those with a capacity of at least 20,000 liters, how many days can the gas station maintain its fuel inventory without replenishment?",
        "query": "SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Days_Remaining FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 20000 LIMIT 1);",
        "step": "【step1】: Retrieve the Station_ID of a gas station with a capacity of at least 20,000 liters using a subquery: `SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 20000 LIMIT 1`.  【step2】: Use the retrieved Station_ID to filter the relevant gas entry in the gas table.  【step3】: Calculate the days remaining by subtracting the minimum stock from current stock and dividing by daily sales: `(Stock_Liters - Minimum_Stock_Liters) / 2000`.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 560,
        "question": "If a gas station has a current inventory of 999,999 liters, with each liter of fuel emitting 2.5 grams of carbon per liter, how much carbon emissions will be generated if the station sells and burns all the fuel at once? If all gas stations worldwide (there are 1,000,000 of them) perform this operation simultaneously, by how much will global carbon emissions increase?",
        "query": "SELECT (Stock_Liters * Carbon_Emission) AS Single_Station_Emissions, (Stock_Liters * Carbon_Emission * 1000000) AS Global_Emissions FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000 LIMIT 1);",
        "step": "【step1】: Execute the subquery `(SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000 LIMIT 1)` to retrieve a gas station with a total capacity of 1,000,000 liters.  【step2】: Fetch the `Stock_Liters` and `Carbon_Emission` values from the `gas` table for the Station_ID obtained in Step 1.  【step3】: Calculate `Single_Station_Emissions` (Stock_Liters × Carbon_Emission) and `Global_Emissions` (Single_Station_Emissions × 1,000,000) for all hypothetical global stations.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 561,
        "question": "If a gas station stores 50,000 liters of liquefied natural gas (LNG) with a density of 0.45 kg/liter and the LNG has a calorific value of 50 MJ/kg, how much energy can be generated by burning all of it? If this energy is entirely converted into electricity with a conversion efficiency of 40%, how much electrical energy in MJ can be generated?",
        "query": "SELECT (50000 * 0.45) AS total_mass_kg, (50000 * 0.45 * 50) AS total_energy_MJ, (50000 * 0.45 * 50 * 0.4) AS electrical_energy_MJ FROM gas WHERE Fuel_Type = 'liquefied natural gas' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000);",
        "step": "【step1】: Execute the subquery to retrieve Station_ID(s) from gas_station where Capacity_Liters ≥ 50,000, ensuring the station can hold the specified LNG volume.  【step2】: Filter the gas table by Fuel_Type = 'liquefied natural gas' and the Station_ID(s) from step1, then calculate total mass (50,000L × 0.45kg/L), total energy (mass × 50MJ/kg), and electrical energy (total energy × 40% efficiency).  【step3】: Output results with calculated fields (total_mass_kg, total_energy_MJ, electrical_energy_MJ) for the matched gas records.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 562,
        "question": "An oil company has a debt-to-equity ratio of 2:1. If the company's total assets are $800, what are the company's debt and shareholder equity? If the company plans to adjust the debt-to-equity ratio to 1:1 while keeping total assets unchanged, how much debt does it need to repay?",
        "query": "SELECT (Assets * (2 / 3)) AS Debt, (Assets * (1 / 3)) AS Equity, (Assets * (2 / 3) - (Assets / 2)) AS Debt_Repayment FROM company WHERE Assets = 800;",
        "step": "【step1】: Calculate the current Debt and Equity using the 2:1 ratio. Debt is (2/3)*Assets and Equity is (1/3)*Assets.  【step2】: Determine the target Debt after adjusting to a 1:1 ratio. In this case, Debt and Equity would each be (1/2)*Assets.  【step3】: Compute Debt_Repayment by subtracting the target Debt from the initial Debt: (2/3)*Assets - (1/2)*Assets.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 563,
        "question": "If a gas station has a fuel inventory of 30,000 liters, a minimum stock level of 10,000 liters, sells 1,500 liters of fuel daily, and replenishes its stock every 3 days with 20,000 liters each time, will the gas station experience a shortage? If so, how long will the shortage last?",
        "query": "WITH daily_consumption AS (SELECT 1500 AS daily_sales, 20000 AS replenishment_amount, 3 AS replenishment_interval), inventory_trend AS (SELECT 30000 AS current_stock, 10000 AS minimum_stock, (1500 - (20000 / 3)) AS net_daily_consumption, (30000 - 10000 + (20000 * (FLOOR((30000 - 10000) / (1500 - (20000 / 3))) / 3))) AS inventory_change FROM daily_consumption) SELECT CASE WHEN inventory_change < 0 THEN 'Yes' ELSE 'No' END AS shortage_occurrence, CASE WHEN inventory_change < 0 THEN ABS(inventory_change) / net_daily_consumption ELSE 0 END AS shortage_duration_days FROM inventory_trend;",
        "step": "【step1】: Calculate daily net consumption by subtracting average daily replenishment (20,000/3 ≈6,666.67 liters) from daily sales (1,500 liters), resulting in negative net consumption (-5,166.67 liters/day) indicating inventory growth.  【step2】: Compute total inventory change before reaching minimum stock: Initial stock (30,000) - minimum stock (10,000) = 20,000 buffer. Divide buffer by |net_daily_consumption| (5,166.67) to get days until buffer depletion: ≈3.86 days.  【step3】: Determine shortage occurrence (No) because negative net consumption increases inventory indefinitely. Query wrongly assumes positive consumption due to flawed formula (1500 - (20000/3)) instead of (1500*3 - 20000)/3 cycle-based calculation.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 564,
        "question": "An oil company's gas station sells 50,000,000 liters of gasoline daily, with each liter emitting 2.31 kg of carbon. The company plans to offset its carbon emissions through tree planting. Given that one tree can absorb 20 kg of carbon dioxide annually, how many trees must the company plant to fully offset its carbon emissions for one year? If each tree requires 10 square meters of land, how many square kilometers of land are needed to plant these trees?",
        "query": "WITH carbon_data AS (SELECT 50000000 AS daily_sales_liters, 2.31 AS carbon_emission_per_liter_kg, 20 AS carbon_absorption_per_tree_kg, 10 AS land_area_per_tree_sqm), total_emission AS (SELECT (daily_sales_liters * carbon_emission_per_liter_kg * 365) AS total_carbon_emission_kg FROM carbon_data), trees_needed AS (SELECT (total_carbon_emission_kg / carbon_absorption_per_tree_kg) AS trees_required FROM total_emission, carbon_data), land_required AS (SELECT (trees_required * land_area_per_tree_sqm / 1000000) AS land_area_sqkm FROM trees_needed, carbon_data) SELECT trees_required, land_area_sqkm FROM trees_needed, land_required;",
        "step": "【step1】: Calculate annual carbon emissions by multiplying daily sales (50,000,000 liters) with emission factor (2.31 kg/L) and 365 days  【step2】: Determine total trees required by dividing annual carbon emissions (from step1) by tree absorption capacity (20 kg/tree/year)  【step3】: Convert land requirement from square meters to square kilometers by multiplying total trees (from step2) with 10 sqm/tree and dividing by 1,000,000 m²/km²",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 565,
        "question": "If the gas station has stored gasoline with a density of 0.75 kg/liter and a total capacity of 100,000 liters, what is the total mass of the gasoline stored at the station? If all this gasoline is completely burned, how much energy is produced (the heating value of gasoline is 45 MJ/kg)?",
        "query": "SELECT Capacity_Liters * 0.75 AS Total_Mass_Kg, (Capacity_Liters * 0.75) * 45 AS Total_Energy_MJ FROM gas_station WHERE Station_ID = '1';",
        "step": "【step1】: Filter the gas_station record for the specified Station_ID to retrieve Capacity_Liters.  【step2】: Calculate Total_Mass_Kg by multiplying Capacity_Liters with the gasoline density (0.75 kg/L).  【step3】: Calculate Total_Energy_MJ by multiplying Total_Mass_Kg with the calorific value (45 MJ/kg).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 566,
        "question": "A petroleum company owns 5,000 gas stations across the country, with each station selling an average of 5,000 liters of diesel per day. If the net profit from diesel is $0.5 per liter and the company's operating costs account for 30% of the total profit, what is the company's annual net profit?",
        "query": "SELECT (5000 * 5000 * 365 * 0.5) * (1 - 0.3) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';",
        "step": "【step1】: Calculate total annual diesel sales volume: (5000 stations * 5000 liters/day * 365 days)  【step2】: Compute gross profit by multiplying total volume with per-liter net profit: (result_from_step1 * 0.5)  【step3】: Deduct 30% operational costs to obtain final net profit: (result_from_step2 * (1 - 0.3))",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 567,
        "question": "A gas station has a fuel inventory of `Stock_Liters` liters, with a minimum inventory level of 5,000 liters. If the station sells 2,000 liters of fuel per day and the supplier replenishes the inventory every 7 days, what is the minimum amount of fuel that needs to be replenished each time to prevent stock shortages for a station with a Station_ID of '1'?",
        "query": "SELECT (2000 * 7) + (5000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Retrieve the current stock level (Stock_Liters) from the gas table for the specified Station_ID.  【step2】: Calculate the total fuel consumption during the 7-day period (2000 liters/day × 7 days = 14,000 liters).  【step3】: Compute the minimum required refill by summing the 7-day consumption and the deficit needed to restore the stock to the minimum threshold (14,000 + (5,000 - Stock_Liters)).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 568,
        "question": "A gas station owned by a certain oil company sells 1,000,000 liters of gasoline daily, with each liter emitting 2.31 kilograms of carbon. If the company operates 10,000 such gas stations globally and all stations run without downtime throughout the year, what is the total annual carbon emissions generated by the company from gasoline sales in kilograms? If the global annual carbon emission limit is 10,000,000,000 kilograms, what percentage of the global carbon emissions does this company account for?",
        "query": "SELECT (1000000 * 2.31 * 10000 * 365) AS Total_Carbon_Emission_Kg, ((1000000 * 2.31 * 10000 * 365) / 10000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';",
        "step": "【step1】: Retrieve the company's basic information from the 'company' table using WHERE Company_ID = 'specified_company_ID' to ensure the company exists.  【step2】: Calculate Total_Carbon_Emission_Kg by hardcoding the formula (1000000 * 2.31 * 10000 * 365), bypassing actual table joins due to missing explicit data dependencies (e.g., number of stations or daily sales stored in tables).  【step3】: Compute Carbon_Emission_Percentage using the derived Total_Carbon_Emission_Kg divided by 10000000000 and multiply by 100, ignoring normalization to database schemas (fixed values used instead of querying dynamic data).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 569,
        "question": "A gas station with Station_ID '1' has a fuel inventory measured in Stock_Liters. If the fuel has a density of 0.8 kilograms per liter and a heat value of 42 MJ per kilogram, what is the total energy released when all the fuel stored at this station is completely burned?",
        "query": "SELECT Stock_Liters * 0.8 AS Total_Mass_Kg, (Stock_Liters * 0.8) * 42 AS Total_Energy_MJ FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Filter the 'gas' table by Station_ID to retrieve the Stock_Liters for the specified gas station.  【step2】: Calculate the total mass of the fuel (Stock_Liters × 0.8 kg/L) as Total_Mass_Kg.  【step3】: Multiply the total mass by the heat value per kilogram (42 MJ/kg) to compute Total_Energy_MJ.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 570,
        "question": "A certain oil company owns 8,000 gas stations across the country, with each station selling an average of 4,000 liters of diesel per day. If the gross profit per liter of diesel is $0.40 and the company's operating costs account for 20% of total gross profits, what is the company's annual net profit after accounting for operating costs?",
        "query": "SELECT (8000 * 4000 * 365 * 0.4) * (1 - 0.2) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';",
        "step": "【step1】: Calculate total diesel sales volume per year: 8,000 stations × 4,000 liters/day × 365 days = Total liters sold annually  【step2】: Compute gross profit: Total liters × $0.4/liter net profit = Gross profit before operational costs  【step3】: Deduct 20% operational costs: Gross profit × (1 - 0.2) = Final annual net profit",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 571,
        "question": "The gas station has an initial fuel inventory of 30,000 liters and a minimum stock level of 10,000 liters. It sells 3,000 liters per day and is replenished every 5 days. What is the required refill amount in liters for Station ID '1'?",
        "query": "SELECT (3000 * 5) + (10000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Calculate the total fuel consumption during the 5-day period between supplier replenishments: 3,000 liters/day * 5 days = 15,000 liters.  【step2】: Determine the minimum replenishment requirement by adding the 5-day consumption (15,000L) to the deficit between the current stock and the minimum safety stock (10,000L - Stock_Liters).  【step3】: Retrieve the specific gas station's current stock level from the gas table and compute the final replenishment amount using the formula: (15,000 + (10,000 - Stock_Liters)).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 572,
        "question": "A gas station owned by an oil company sells 2,000,000 liters of gasoline daily, with each liter emitting 2.5 kilograms of carbon. If the company operates 20,000 such gas stations globally, all running non-stop throughout the year, what is the total annual carbon emissions generated by the company from gasoline sales? If the global annual carbon emission limit is 20,000,000,000 kilograms, what percentage of global emissions does this company account for?",
        "query": "SELECT (2000000 * 2.5 * 20000 * 365) AS Total_Carbon_Emission_Kg, ((2000000 * 2.5 * 20000 * 365) / 20000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';",
        "step": "【step1】: Retrieve company information from the 'company' table using Company_ID to verify the existence and ensure correct association with gasoline sales data.  【step2】: Calculate total daily emission per station (2,000,000 liters × 2.5 kg/liter) and multiply by global stations (20,000) and annual days (365). Compute percentage by comparing with 20,000,000,000 kg limit.  【step3】: Join 'station_company' to validate station-company relationships and confirm emission parameters from 'gas' table (e.g., Carbon_Emission field) align with the fixed 2.5 kg/liter value.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 573,
        "question": "If a gas station has a fuel inventory of 50,000 liters and the carbon emissions of the fuel are 2.5 grams per liter, what is the total carbon emissions of the fuel currently in the station's inventory?",
        "query": "SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 50000 AND Carbon_Emission = 2.5;",
        "step": "【step1】: Filter records in the 'gas' table where Stock_Liters equals 50,000 liters and Carbon_Emission equals 2.5 grams per liter.  【step2】: Calculate the total carbon emission by multiplying the Stock_Liters and Carbon_Emission values for the filtered records.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 574,
        "question": "The net profit margin of an oil company is 8%, with sales of $500 billion. Calculate the company's net profit. If the company wants to increase its net profit to $50 billion, how much should the sales reach?",
        "query": "SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, 50 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 500 AND Net_Profit_Margin = 8;",
        "step": "【step1】: Filter the 'company' table where Sales = 500 (billion) and Net_Profit_Margin = 8% to isolate the target company's data.  【step2】: Calculate the current Net_Profit using the formula: **Sales × (Net_Profit_Margin / 100)**.  【step3】: Compute the Required_Sales to achieve a 50 billion profit by rearranging the formula: **Target_Profit / (Net_Profit_Margin / 100)**.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 575,
        "question": "The minimum inventory alert for a certain gas station is 10,000 liters, and the current inventory is 15,000 liters with a daily average sales volume of 2,000 liters. How many more days can the gas station operate normally?",
        "query": "SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Operational_Days FROM gas WHERE Stock_Liters = 15000 AND Minimum_Stock_Liters = 10000;",
        "step": "【step1】: Access the 'gas' table to retrieve inventory data (Stock_Liters, Minimum_Stock_Liters).  【step2】: Filter records using WHERE clause to match Stock_Liters=15000 and Minimum_Stock_Liters=10000.  【step3】: Calculate operational days with (Stock_Liters - Minimum_Stock_Liters)/2000 and output as Operational_Days.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 576,
        "question": "A gas station has a total fuel capacity of 1,000,000 liters, with a current inventory of 999,999 liters. The price per liter of fuel is $1.5. If the gas station suddenly receives an order requesting a one-time purchase of 1,000,000 liters of fuel, can the transaction be completed? If not, what is the maximum amount of fuel (in liters) that can be sold?",
        "query": "SELECT LEAST(1000000, Stock_Liters) AS Available_Stock FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;",
        "step": "【step1】: Retrieve the Station_ID from the gas_station table where the total capacity is 1,000,000 liters using a subquery.  【step2】: Filter the gas table entries that match the retrieved Station_ID and have a current stock of 999,999 liters.  【step3】: Calculate the maximum available stock for sale using LEAST(1000000, Stock_Liters), which returns 999,999 liters (since 999,999 < 1,000,000).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 577,
        "question": "A gas station has a fuel inventory of 80,000 liters, with a fuel density of 0.85 kg/liter and a calorific value of 45 MJ/kg. Calculate the total energy released when the current fuel inventory at the gas station is completely burned.",
        "query": "SELECT Stock_Liters * 0.85 * 45 AS Total_Energy FROM gas WHERE Stock_Liters = 80000;",
        "step": "【step1】: Filter the 'gas' table where Stock_Liters equals 80,000 to isolate the specific fuel inventory record.  【step2】: Calculate Total_Energy by multiplying Stock_Liters (80,000) by density (0.85 kg/L) and combustion heat value (45 MJ/kg).  【step3】: Output the result using SELECT without additional joins since the calculation depends solely on the filtered 'gas' table row.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 578,
        "question": "A petroleum company has sales of $75 billion, a net profit margin of 12%, and total assets of $200 billion. Calculate the company's net profit and return on assets (ROA). If the company aims to increase its net profit to $10 billion, how much sales will it need to achieve?",
        "query": "SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, 100 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 750 AND Net_Profit_Margin = 12 AND Assets = 2000;",
        "step": "【step1】: Filter the company table where Sales=75 (since Sales is in billions), Net_Profit_Margin=12, and Assets=200. Calculate Net_Profit via Sales*(Net_Profit_Margin/100).  【step2】: Compute ROA by dividing the Net_Profit (from Step 1) by Assets.  【step3】: Derive Required_Sales by dividing the target profit (100 billion) by (Net_Profit_Margin/100) to determine the needed sales.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 579,
        "question": "The minimum inventory warning for a gas station is 15,000 liters, the current inventory is 25,000 liters, and the average daily sales volume is 3,000 liters. If the next fuel delivery is expected to arrive in 7 days, will the gas station trigger an inventory warning?",
        "query": "SELECT CASE WHEN (Stock_Liters - (3000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning FROM gas WHERE Stock_Liters = 25000 AND Minimum_Stock_Liters = 15000;",
        "step": "【step1】: Calculate the remaining fuel after 7 days: Stock_Liters (25,000) minus daily sales (3,000) multiplied by 7 days, resulting in 25,000 - 21,000 = 4,000 liters.  【step2】: Apply conditional logic using CASE to check if the remaining fuel (4,000) is below Minimum_Stock_Liters (15,000).  【step3】: Retrieve the comparison result directly from the \"gas\" table using hardcoded values (Stock_Liters=25000, Minimum_Stock_Liters=15000) to output 'Yes' or 'No'.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 580,
        "question": "A gas station has a total fuel capacity of 1,500,000 liters, with a current inventory of 1,499,999 liters. The price per liter of fuel is $2. If the station suddenly receives an order requesting a one-time purchase of 1,500,001 liters of fuel, can the transaction be completed? If not, what is the maximum number of liters that can be sold?",
        "query": "SELECT CASE WHEN 1500001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete, LEAST(1500001, Stock_Liters) AS Max_Sellable FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1500000) AND Stock_Liters = 1499999;",
        "step": "【step1】: Retrieve the Station_ID from gas_station where Capacity_Liters matches the given total capacity (1,500,000) to identify the specific gas station.  【step2】: Check if the requested quantity (1,500,001) exceeds the current Stock_Liters (1,499,999) for the identified station in the gas table, determining \"Can_Complete\" via CASE.  【step3】: Calculate Max_Sellable using LEAST to return the smaller value between the requested quantity and Stock_Liters, ensuring the result does not exceed available stock.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 581,
        "question": "A gas station's fuel inventory is 120,000 liters, with a fuel combustion efficiency of 85%. Each liter of fuel releases 35 megajoules of energy upon combustion. Calculate the total actual usable energy available after completely burning the current fuel inventory at the gas station.",
        "query": "SELECT Stock_Liters * 35 * 0.85 AS Available_Energy FROM gas WHERE Stock_Liters = 120000;",
        "step": "【step1】: Filter the 'gas' table to retrieve the row where Stock_Liters is 120,000.  【step2】: Calculate the available energy by multiplying Stock_Liters (120,000) by 35 MJ/L (energy per liter) and 0.85 (combustion efficiency).  【step3】: Alias the calculated result as Available_Energy for clarity.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 582,
        "question": "An oil company has sales of $90 billion, a net profit margin of 15%, total assets of $300 billion, and debt of $120 billion. Calculate the company's net profit, return on assets (ROA), and debt-to-equity ratio. If the company aims to increase its net profit to $150 billion, how much must its sales reach?",
        "query": "SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 150 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 900 AND Net_Profit_Margin = 15 AND Assets = 3000 AND Debt_Equity_Ratio = 1200;",
        "step": "【step1】: Filter the company table to find the row matching the given criteria (Sales=900, Net_Profit_Margin=15, Assets=3000, Debt_Equity_Ratio=1200).  【step2】: Calculate Net_Profit (Sales * Net_Profit_Margin / 100), ROA (Net_Profit / Assets), and Required_Sales (150 / (Net_Profit_Margin / 100)).  【step3】: Return the pre-stored Debt_Equity_Ratio value as the Debt-to-Equity Ratio and all calculated metrics directly from the filtered row.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 583,
        "question": "The minimum inventory alert for a certain gas station is 25,000 liters, with the current inventory at 40,000 liters and an average daily sales volume of 5,000 liters. If the next fuel delivery is expected to arrive in 6 days, will the gas station trigger an inventory alert? If so, how many days in advance should the inventory be replenished to avoid the alert?",
        "query": "SELECT CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 5000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 40000 AND Minimum_Stock_Liters = 25000;",
        "step": "【step1】: Calculate the remaining fuel after 6 days: 40,000L - (5,000L/day * 6 days) = 10,000L. Compare with minimum threshold (25,000L). Since 10,000L < 25,000L, the warning triggers.  【step2】: Determine \"safe days\" before reaching minimum threshold: (40,000L - 25,000L) / 5,000L/day = 3 days.  【step3】: Calculate required advance time: Delivery schedule (6 days) exceeds safe period (3 days), thus needing 6 - 3 = 3 days earlier replenishment.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 584,
        "question": "The total fuel capacity of a gas station is 3,000,000 liters, with a current inventory of 2,999,999 liters. If the gas station suddenly receives an order requesting a one-time purchase of 3,000,001 liters of fuel, can the transaction be completed? If not, what is the maximum amount that can be sold? If the order requests a purchase of 5,000,000 liters of fuel, can the transaction be completed?",
        "query": "SELECT CASE WHEN 3000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(3000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 5000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 3000000) AND Stock_Liters = 2999999;",
        "step": "【step1】: Execute subquery to retrieve Station_ID from gas_station where capacity matches 3,000,000 liters  【step2】: Filter gas table for records matching the retrieved Station_ID and exact stock of 2,999,999 liters  【step3】: Apply CASE logic to check order fulfillment against stock (3,000,001L/5,000,000L vs 2,999,999L) and calculate LEAST values",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 585,
        "question": "The gasoline station has a fuel inventory of 200,000 liters, with a combustion efficiency of 90%. Each liter of fuel releases 38 megajoules of energy upon combustion. Calculate the total actual usable energy available when the current inventory of fuel at the gasoline station is completely burned.",
        "query": "SELECT Stock_Liters * 38 * 0.9 AS Available_Energy FROM gas WHERE Stock_Liters = 200000;",
        "step": "【step1】: Filter the 'gas' table to retrieve the record where the stock is exactly 200,000 liters using **WHERE Stock_Liters = 200000**.  【step2】: Calculate the available energy by multiplying the stock liters (200,000) by the energy per liter (38 MJ) and combustion efficiency (90%), resulting in **Stock_Liters * 38 * 0.9**.  【step3】: Return the final value with the alias **Available_Energy** to explicitly label the calculated total energy.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 586,
        "question": "An oil company has sales of $1500 billion, a net profit margin of 20%, total assets of $5000 billion, and debt of $2000 billion. Calculate the company's net profit, return on assets (ROA), and return on equity (ROE). If the company aims to increase its net profit to $300 billion, how much sales would be required?",
        "query": "SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 300 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 1500 AND Net_Profit_Margin = 20 AND Assets = 5000 AND Debt_Equity_Ratio = 2000;",
        "step": "【step1】: Filter the 'company' table to retrieve the specific record where Sales=1500, Net_Profit_Margin=20, Assets=5000, and Debt_Equity_Ratio=2000.  【step2】: Compute **Net_Profit** by multiplying Sales (1500) with Net_Profit_Margin (20/100). Calculate **ROA** by dividing Net_Profit by Assets (5000).  【step3】: Derive **ROE** by dividing Net_Profit by (Assets - (Assets * (Debt_Equity_Ratio/(Debt_Equity_Ratio+1)))), and calculate **Required_Sales** using 300/(Net_Profit_Margin/100). Return all calculated fields.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 587,
        "question": "A gas station has a minimum inventory warning threshold of 30,000 liters, with a current inventory of 50,000 liters and an average daily sales volume of 6,000 liters. If the next fuel delivery is expected to arrive in 7 days, will this gas station trigger the inventory warning? If so, how many days earlier than the scheduled delivery should they place the order to avoid the warning?",
        "query": "SELECT CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 6000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 50000 AND Minimum_Stock_Liters = 30000;",
        "step": "【step1】: Calculate the projected fuel stock after 7 days: 50,000 - (6,000 * 7) = 8,000 liters, which is below the minimum threshold of 30,000 liters.  【step2】: Determine the \"buffer days\" before the stock hits the minimum threshold: (50,000 - 30,000) / 6,000 ≈ 3.33 days. This represents how long the excess stock (above the minimum) can last.  【step3】: Return \"Yes\" for the warning trigger and 3.33 days as the required advance notice to replenish before depletion.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 588,
        "question": "A gas station has a current inventory of 4,999,999 liters. If the gas station receives an order requesting a one-time purchase of 5,000,001 liters of fuel, can the transaction be completed? If not, what is the maximum number of liters that can be sold? If the order requests the purchase of 10,000,000 liters of fuel, can the transaction be completed?",
        "query": "SELECT CASE WHEN 5000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(5000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 10000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 5000000) AND Stock_Liters = 4999999;",
        "step": "【step1】: Retrieve the Station_ID from gas_station where Capacity_Liters matches 5,000,000 liters.  【step2】: Filter gas table records where Station_ID matches the result from step1 and Stock_Liters is exactly 4,999,999 liters.  【step3】: Evaluate conditional logic (CASE/LEAST) to determine transaction feasibility and maximum sellable quantities for both order requests (5,000,001L and 10,000,000L).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 589,
        "question": "The fuel inventory at a gas station is 300,000 liters, with a combustion efficiency of 88%. Each liter of fuel releases 42 megajoules of energy when burned. Calculate the total actual usable energy if the current fuel inventory is completely burned.",
        "query": "SELECT Stock_Liters * 42 * 0.88 AS Available_Energy FROM gas WHERE Stock_Liters = 300000;",
        "step": "【step1】: Filter the gas table to retrieve the record with Stock_Liters = 300000.  【step2】: Calculate Available_Energy by multiplying Stock_Liters (300000) by 42 (energy per liter) and 0.88 (combustion efficiency).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 590,
        "question": "An oil company has sales of $2000 billion, a net profit margin of 25%, total assets of $6000 billion, and a debt-to-equity ratio of 2500. Calculate the company's net profit, return on assets (ROA), and return on equity (ROE). If the company wants to increase its net profit to $500 billion, how much must its sales reach?",
        "query": "SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 500 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 2000 AND Net_Profit_Margin = 25 AND Assets = 6000 AND Debt_Equity_Ratio = 2500;",
        "step": "【step1】: Filter the company table to retrieve the specific company's data with Sales=2000, Net_Profit_Margin=25, Assets=6000, and Debt_Equity_Ratio=2500.  【step2】: Calculate Net_Profit (Sales × Net_Profit_Margin%) and ROA (Net_Profit / Assets) using the filtered data.  【step3】: Derive ROE by dividing Net_Profit by Shareholder Equity (formula: Assets - (Assets × Debt_Equity_Ratio / (Debt_Equity_Ratio +1))) and compute Required_Sales for $50B Net_Profit (500 / Net_Profit_Margin%).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 591,
        "question": "A gas station has a minimum inventory warning threshold of 40,000 liters, with the current inventory at 70,000 liters and an average daily sales volume of 8,000 liters. If the next fuel delivery is expected to arrive in 10 days, will this gas station trigger the inventory warning? If so, how many days in advance does the inventory need to be replenished to avoid the warning?",
        "query": "SELECT CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 8000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 70000 AND Minimum_Stock_Liters = 40000;",
        "step": "【step1】: Calculate remaining inventory after 10 days: 70,000 - (8,000 * 10) = -10,000 liters. Compare with minimum threshold (40,000 liters). Since -10,000 < 40,000, this triggers the warning (CASE returns 'Yes').  【step2】: Calculate required advance days: (70,000 - 40,000) / 8,000 = 3.75 days. This determines how many days before stock reaches minimum threshold when consuming 8,000L daily.  【step3】: Filter records matching input parameters (Stock_Liters=70000 AND Minimum_Stock_Liters=40000) from gas table to apply these calculations specifically to the target gas station's data.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 592,
        "question": "The total fuel capacity of a gas station is 10,000,000 liters, with a current inventory of 9,999,999 liters. If the gas station suddenly receives an order requesting a one-time purchase of 10,000,001 liters of fuel, can the transaction be completed? If not, what is the maximum amount that can be sold? If the order requests a purchase of 20,000,000 liters of fuel, can the transaction be completed?",
        "query": "SELECT CASE WHEN 10000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(10000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 20000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 10000000) AND Stock_Liters = 9999999;",
        "step": "【step1】: Execute the subquery to find Station_ID from gas_station where Capacity_Liters matches the given total capacity (10,000,000 liters).  【step2】: Filter gas table records where Station_ID matches the subquery result and Stock_Liters equals 9,999,999 liters.  【step3】: Calculate results using CASE and LEAST functions to check order feasibility (10,000,001L vs. 20,000,000L) against Stock_Liters.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 593,
        "question": "A gas station has a fuel inventory of 500,000 liters, with a combustion efficiency of 92%. Each liter of fuel releases 46 megajoules of energy upon combustion. Calculate the total actually available energy if all the fuel in the current inventory is completely burned, and calculate the total carbon emissions if the carbon emission of the fuel is 2.8 grams per liter.",
        "query": "SELECT Stock_Liters * 46 * 0.92 AS Available_Energy, Stock_Liters * 2.8 AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 500000;",
        "step": "【step1】: Filter the gas table where Stock_Liters equals 500,000 liters to isolate the target record.  【step2】: Calculate Available_Energy via (Stock_Liters × 46 × 0.92) and Total_Carbon_Emission via (Stock_Liters × 2.8).  【step3】: (Not required - no joins/nested logic/sorting)",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 594,
        "question": "An oil company has sales of $4000 billion, a net profit margin of 28%, total assets of $10000 billion, and a debt-to-equity ratio of 4000. Calculate the company's net profit, return on assets (ROA), return on equity (ROE), and debt-to-equity ratio. If the company wants to increase its net profit to $1200 billion, how much must sales reach?",
        "query": "SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 1200 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 4000 AND Net_Profit_Margin = 28 AND Assets = 10000 AND Debt_Equity_Ratio = 4000;",
        "step": "【step1】: Filter the 'company' table using WHERE conditions (Sales=4000, Net_Profit_Margin=28, Assets=10000, Debt_Equity_Ratio=4000) to isolate the target company's data.  【step2】: Calculate **Net_Profit** (`Sales * Net_Profit_Margin / 100`), **ROA** (`Net_Profit / Assets`), and **Required_Sales** (`1200 / (Net_Profit_Margin / 100)`) using direct arithmetic operations.  【step3】: Derive **ROE** by computing shareholder equity (`Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))`) and dividing Net_Profit by this value, while directly selecting **Debt_to_Equity_Ratio** from the table.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 595,
        "question": "A gas station has a minimum inventory warning threshold of 80,000 liters, with a current inventory of 150,000 liters and a daily average sales volume of 15,000 liters. If the next fuel delivery is expected to arrive in 12 days, will the gas station trigger the inventory warning? If so, how many days in advance should the inventory be replenished to avoid the warning? What would happen if the daily sales volume increased to 20,000 liters?",
        "query": "SELECT CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 15000 ELSE 0 END AS Days_To_Advance, CASE WHEN (Stock_Liters - (20000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_New_Sales FROM gas WHERE Stock_Liters = 150000 AND Minimum_Stock_Liters = 80000;",
        "step": "【step1】: Filter the gas table to retrieve the specific record where Stock_Liters is 150,000 and Minimum_Stock_Liters is 80,000.  【step2】: Calculate remaining fuel after 12 days with 15,000 L/day sales: 150,000 - (15,000×12) = -30,000 L. Compare to minimum stock (80,000 L) using CASE to determine Trigger_Warning. Compute Days_To_Advance via (150,000 - 80,000)/15,000 ≈ 4.67 days.  【step3】: Repeat calculations for increased sales (20,000 L/day): 150,000 - (20,000×12) = -90,000 L. Compare to minimum stock again via CASE to determine Trigger_Warning_New_Sales.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 596,
        "question": "A gas station has a total fuel capacity of 20,000,000 liters, with a current inventory of 19,999,999 liters, and the price per liter of fuel is $6. If the gas station suddenly receives an order requesting a one-time purchase of 20,000,001 liters of fuel, can the transaction be completed? If not, what is the maximum amount that can be sold? If the order requests the purchase of 50,000,000 liters of fuel, can the transaction be completed? If the fuel price suddenly rises to $10 per liter for the 50,000,000 liter order, what would be the total amount of the order?",
        "query": "SELECT CASE WHEN 20000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(20000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 50000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2, 50000000 * 10 AS Order_Total_Amount FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 20000000) AND Stock_Liters = 19999999;",
        "step": "【step1】: Execute the subquery `(SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 20000000)` to find the gas station with total capacity of 20,000,000 liters.  【step2】: Check if the stock (19,999,999 liters) in the `gas` table meets the first order quantity (20,000,001L) using `CASE WHEN 20000001 <= Stock_Liters`. Calculate maximum sellable amount via `LEAST(20000001, Stock_Liters)`, and check second order (50,000,000L) fulfillment similarly.  【step3】: Calculate the order total amount for 50,000,000L using the updated price (10 USD/L) with direct multiplication `50000000 * 10`, independent of stock verification.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 597,
        "question": "A gas station has a fuel inventory of 600,000 liters, with the fuel having a density of 0.83 kg/liter and a calorific value of 47 MJ/kg. Calculate the total energy released when the current fuel inventory is completely combusted. If the sulfur content of the fuel is 50 mg/kg, calculate the total sulfur content.",
        "query": "SELECT Stock_Liters * 0.83 * 47 AS Total_Energy, Stock_Liters * 50 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Filter records in the gas table where Station_ID matches the specified ID to retrieve Stock_Liters.  【step2】: Calculate Total_Energy by multiplying Stock_Liters with density (0.83 kg/L) and combustion heat value (47 MJ/kg).  【step3】: Calculate Total_Sulfur_Content by multiplying Stock_Liters with sulfur concentration (50 ppm).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 598,
        "question": "An oil company has sales of $550 billion, a net profit margin of 32%, total assets of $1,300 billion, and debt of $550 billion. Calculate the company's net profit, return on assets (ROA), return on equity (ROE), and debt-to-equity ratio. If the company wants to increase its net profit to $180 billion, how much must sales reach?",
        "query": "SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 550) AS ROE, 550 / (Assets - 550) AS Debt_to_Equity_Ratio, 1800 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';",
        "step": "【step1】: Filter the company table based on the specified Company_ID to retrieve the relevant financial data (Sales, Net_Profit_Margin, Assets).  【step2】: Calculate Net_Profit (Sales * Net_Profit_Margin / 100), ROA (Net_Profit / Assets), ROE (Net_Profit / (Assets - Debt)), and Debt-to-Equity Ratio (Debt / (Assets - Debt)) using the retrieved values.  【step3】: Derive Required_Sales by reversing the Net_Profit formula: Required_Sales = Target_Net_Profit / (Net_Profit_Margin / 100).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 599,
        "question": "A gas station has a minimum inventory alert threshold of Minimum_Stock_Liters, with its current inventory at Stock_Liters and a daily average sales volume of 20,000 liters. If the next fuel delivery is expected to arrive in 15 days, will the gas station trigger the inventory alert? If so, how many days in advance should inventory be replenished to avoid the alert? How would the situation change if the daily sales volume increases to 25,000 liters?",
        "query": "SELECT CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 20000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (25000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Calculate remaining stock after 15 days with 20,000L/day sales: 200,000 - (20,000×15) = -100,000L (<100,000L). Returns 'Yes' for Trigger_Warning.  【step2】: Compute days to advance inventory: (200,000 - 100,000)/20,000 = 5 days. Returns 5 in Days_To_Advance.  【step3】: Calculate remaining stock with 25,000L/day sales: 200,000 - (25,000×15) = -175,000L (<100,000L). Returns 'Yes' for Trigger_Warning_Increase.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 600,
        "question": "A gas station (Station_ID = '2001') has a current fuel inventory of Stock_Liters liters. If the station receives an order requesting a one-time purchase of 30,000,001 liters of fuel, can the transaction be completed? If not, what is the maximum number of liters that can be sold? If the order requests 60,000,000 liters of fuel, can the transaction be completed? If the fuel price is $12 per liter, what would the total order amount be for a 60,000,000 liter purchase?",
        "query": "SELECT CASE WHEN 30000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, LEAST(30000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 60000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 60000000 * 12 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Analyze stock availability for 30,000,001L order using CASE/LEAST to compare ordered_quantity (30,000,001) with Stock_Liters (29,999,999). Returns 'No' with max sellable = 29,999,999L.  【step2】: Check 60,000,000L order validity (always 'No' since 60M > 30M capacity). Calculate Total_Order_Amount using static price $12/L regardless of actual Price_Liter.  【step3】: Validate price calculation logic: Query hardcodes $12/L instead of referencing Price_Liter. Results show 60M*12=$720,000,012 despite insufficient stock.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 601,
        "question": "A certain gas station with Station_ID '2001' has a fuel inventory of 500,000 liters, with a fuel density of 0.85 kg/liter and a calorific value of 45 MJ/kg. Calculate the total energy released when the current inventory of fuel at the gas station is completely burned. If the sulfur content of the fuel is 40 parts per million, calculate the total sulfur content.",
        "query": "SELECT Stock_Liters * 0.85 * 45 AS Total_Energy, Stock_Liters * 40 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Retrieve `Stock_Liters` from the `gas` table for the specified `Station_ID` to determine fuel volume.  【step2】: Multiply `Stock_Liters` by fuel density (0.85 kg/L) and combustion heat value (45 MJ/kg) to calculate `Total_Energy`.  【step3】: Multiply `Stock_Liters` by sulfur content (40 ppm) to derive `Total_Sulfur_Content`.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 602,
        "question": "An oil company with a net profit margin of 30%, total assets of $1,400 billion, and debt of $600 billion. Calculate the company's net profit, return on assets (ROA), return on equity (ROE), and debt-to-equity ratio. If the company wants to increase its net profit to $200 billion, how much must its sales reach?",
        "query": "SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 600) AS ROE, 600 / (Assets - 600) AS Debt_to_Equity_Ratio, 2000 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';",
        "step": "【step1】: Calculate Net_Profit by multiplying Sales with Net_Profit_Margin and dividing by 100.  【step2】: Compute ROA (Net_Profit / Assets), ROE (Net_Profit / (Assets - 600)), and Debt_to_Equity_Ratio (600 / (Assets - 600)) using the derived Net_Profit.  【step3】: Determine Required_Sales by dividing the target profit (2000) by (Net_Profit_Margin / 100).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 603,
        "question": "A gas station has a minimum inventory alert threshold of 150,000 liters, with a current inventory of 300,000 liters and a daily average sales volume of 25,000 liters. If the next fuel delivery is expected to arrive in 20 days, will the gas station trigger the inventory alert? If yes, how many days in advance should the inventory be replenished to avoid the alert? How would the situation change if the daily sales volume increases to 30,000 liters?",
        "query": "SELECT CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 25000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (30000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Calculate remaining stock after 20 days with 25k daily sales: 300,000 - (25,000×20) = 200,000L. Compare with minimum 150,000L (200,000 > 150,000) → return 'No' for Trigger_Warning.  【step2】: Since warning isn't triggered, Days_To_Advance remains 0 by formula (no conditional calculation needed).  【step3】: Recalculate with 30k daily sales: 300,000 - (30,000×20) = 180,000L - 150,000L = 30,000L surplus. Compare again (180,000 > 150,000) → return 'No' for Trigger_Warning_Increase.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 604,
        "question": "The gas station has a current inventory of 49,999,999 liters and a fuel price of $10 per liter. If it receives an order request to purchase 50,000,001 liters of fuel at once, can the transaction be completed? If not, what is the maximum amount that can be sold? If the order requests the purchase of 100,000,000 liters of fuel, can the transaction be completed? If the fuel price suddenly rises to $15 per liter, what would be the total amount of the order?",
        "query": "SELECT CASE WHEN 50000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, LEAST(50000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 100000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 100000000 * 15 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Check if the first order (50,000,001L) can be fulfilled by comparing Stock_Liters (49,999,999L) with the requested quantity. Return \"No\" in Can_Complete_Transaction and set Max_Sellable_Liters to 49,999,999 using LEAST().  【step2】: Verify the larger order (100,000,000L) by comparing with Stock_Liters. Return \"No\" in Can_Complete_Large_Transaction as stock remains insufficient.  【step3】: Calculate Total_Order_Amount for the hypothetical 100M liter order using the new price (15 USD/L) with 100000000 * 15, regardless of stock availability.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 605,
        "question": "A gas station with Station_ID '2001' has a fuel inventory with a density of 0.86 kg/liter and a calorific value of 49 megajoules/kg. Calculate the total energy released when the current fuel inventory is completely burned. If the sulfur content of the fuel is 60 mg/kg, calculate the total sulfur content.",
        "query": "SELECT Stock_Liters * 0.86 * 49 AS Total_Energy, Stock_Liters * 60 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Filter the gas table by Station_ID to retrieve the Stock_Liters value for the specified gas station.  【step2】: Calculate Total_Energy by multiplying Stock_Liters with density (0.86 kg/L) and combustion heat value (49 MJ/kg), and compute Total_Sulfur_Content by multiplying Stock_Liters with sulfur concentration (60 ppm).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 606,
        "question": "An oil company has sales of $900 billion, a net profit margin of 22%, total assets of $1,700 billion, and debt of $900 billion. Calculate the company's net profit, return on assets (ROA), return on equity (ROE), and debt-to-equity ratio. If the company wants to increase its net profit to $350 billion, what must its sales reach?",
        "query": "SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 900) AS ROE, 900 / (Assets - 900) AS Debt_to_Equity_Ratio, 3500 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';",
        "step": "【step1】: Filter company records by Company_ID to retrieve Sales, Net_Profit_Margin, and Assets.  【step2】: Calculate Net_Profit using Sales * Net_Profit_Margin / 100 and Required_Sales via 3500 / (Net_Profit_Margin / 100).  【step3】: Derive ROA (Net_Profit / Assets), ROE (Net_Profit / (Assets - 900)), and Debt_to_Equity_Ratio (900 / (Assets - 900)) from the results.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 607,
        "question": "The minimum inventory alert threshold for a gas station is 140,000 liters, with the current inventory at 280,000 liters and an average daily sales volume of 24,000 liters. If the next fuel delivery is expected to arrive in 21 days, will the gas station trigger the inventory alert? If it will, how many days in advance should the inventory be replenished to avoid the alert? What would change if the daily sales volume increases to 29,000 liters?",
        "query": "SELECT CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 24000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (29000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Calculate remaining stock after 21 days with standard sales: 280,000 - (24,000*21) = 280,000 - 504,000 = -224,000 (<140,000 threshold). Compare with minimum stock using first CASE statement to determine warning trigger.  【step2】: For early replenishment calculation: (280,000 - 140,000)/24,000 = 5.83 days when remaining stock would reach minimum threshold. This is handled in the second CASE expression using arithmetic operations.  【step3】: Evaluate increased sales scenario: Calculate 280,000 - (29,000*21) = -329,000. Use third CASE statement to check against minimum stock again with updated sales parameter, showing identical warning logic with different consumption rate.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 608,
        "question": "A gas station has a total fuel capacity of 80,000,000 liters, with a current inventory of 79,999,999 liters. The price per liter of fuel is $13. If the gas station suddenly receives an order requesting a one-time purchase of 80,000,001 liters of fuel, can the transaction be completed? If not, what is the maximum number of liters that can be sold? If the order requests the purchase of 160,000,000 liters of fuel, can the transaction be completed? If the fuel price suddenly rises to $25 per liter, what would be the total amount of the order for 160,000,000 liters?",
        "query": "SELECT CASE WHEN 80000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, LEAST(80000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 160000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 160000000 * 25 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';",
        "step": "【step1】: Filter the gas table to retrieve the specific station's Stock_Liters using WHERE Station_ID = '2001'.  【step2】: Evaluate the first transaction request: Use CASE to check if 80,000,001L ≤ Stock_Liters (79,999,999L) and calculate Max_Sellable_Liters via LEAST(80,000,001, Stock_Liters).  【step3】: Analyze the second transaction: Check 160,000,000L feasibility with CASE, then compute Total_Order_Amount = 160,000,000 * 25 independently of stock constraints.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 609,
        "question": "If a gas station has a total capacity of 100,000 liters, with a current inventory of 80,000 liters, and the fuel density is 0.75 kg/L, what is the total mass of the current fuel inventory?",
        "query": "SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000 AND Stock_Liters = 80000);",
        "step": "【step1】: Execute a subquery to find the Station_ID from the gas_station table where the Capacity_Liters is 100,000 and Stock_Liters is 80,000.  【step2】: Use the retrieved Station_ID in the main query to select the corresponding Stock_Liters from the gas table.  【step3】: Multiply the Stock_Liters by the fuel density (0.75) to calculate the total mass in kilograms.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 610,
        "question": "If an oil company has a net profit margin of 15% and sales of $500, what is its net profit? If the company wants to increase its net profit to $10 billion, what level of sales would be required?",
        "query": "SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit FROM company WHERE Sales = 500 AND Net_Profit_Margin = 15;",
        "step": "【step1】: Execute the SELECT statement to calculate net profit: Multiply Sales (500) by Net_Profit_Margin (15%) divided by 100. This retrieves Net_Profit = 500 * 0.15 = 75 (billion USD).  【step2】: To find required Sales for 100 billion USD net profit: Rearrange the formula to Sales = Target_Net_Profit / (Net_Profit_Margin / 100). Use SELECT 100 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Net_Profit_Margin = 15. This returns 666.67 (billion USD).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 611,
        "question": "What are the station IDs and manager names of gas stations where the fuel inventory falls below the minimum stock level and the next fuel delivery is scheduled in more than a week?",
        "query": "SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters AND Next_Delivery_Date > DATE_ADD(CURDATE(), INTERVAL 7 DAY));",
        "step": "【step1】: Execute the subquery to find all Gas Station IDs (Station_ID) in the **gas** table where current stock (Stock_Liters) is below the minimum required (Minimum_Stock_Liters) and the next delivery date (Next_Delivery_Date) is more than 7 days from the current date.  【step2】: Use the retrieved Station_IDs from the subquery to filter records in the **gas_station** table.  【step3】: Select the Station_ID and Manager_Name from the filtered gas_station records to identify stations requiring immediate action.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 612,
        "question": "If a gas station has 1,000,000,000 liters of fuel in stock and the carbon emission per liter is 2.5 grams, what is the total carbon emission from this gas station?",
        "query": "SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 1000000000 AND Carbon_Emission = 2.5;",
        "step": "【step1】: Filter the 'gas' table to find entries where the stock is exactly 1,000,000,000 liters and the carbon emission per liter is 2.5 grams using **WHERE Stock_Liters = 1000000000 AND Carbon_Emission = 2.5**.  【step2】: Calculate the total carbon emission for the matched entries by multiplying **Stock_Liters** and **Carbon_Emission** using **SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission**.  【step3】: (Hypothetical extension for global calculation) Use the result from Step 2, multiply by the total number of global gas stations (not included in the current query) to estimate the global carbon increase.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 613,
        "question": "If a gas station has a fuel capacity of 150,000 liters, a current inventory of 120,000 liters, and a fuel calorific value of 35 MJ/L, what is the total energy of the current fuel inventory?",
        "query": "SELECT Stock_Liters * 35 AS Total_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 150000 AND Stock_Liters = 120000);",
        "step": "【step1】: Execute subquery to retrieve Station_ID from gas_station where Capacity_Liters = 150000 and Stock_Liters = 120000.  【step2】: Use the retrieved Station_ID to filter the gas table.  【step3】: Calculate Total_Energy_MJ by multiplying Stock_Liters (120,000) with heat value (35 MJ/L).  **Note**: The original query contains a schema inconsistency (gas_station lacks the Stock_Liters field). A valid implementation would require joining gas and gas_station tables.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 614,
        "question": "If a petroleum company has total assets of $1500 and a debt-to-equity ratio of 0.6, what is its total liabilities? If the company wishes to reduce its total liabilities to $500, to what level does the debt-to-equity ratio need to be adjusted?",
        "query": "SELECT Assets * (Debt_Equity_Ratio / (1 + Debt_Equity_Ratio)) AS Total_Liabilities FROM company WHERE Assets = 1500 AND Debt_Equity_Ratio = 0.6;",
        "step": "【step1】: The formula Debt/(Debt + Equity) = 0.6/(1+0.6) is used to calculate liabilities proportion. Since Assets = Liabilities + Equity, liabilities can be derived as Assets × (Debt_Equity_Ratio / (1 + Debt_Equity_Ratio)).  【step2】: The query filters records where Assets=1500 (in $B) and Debt_Equity_Ratio=0.6, then calculates Total_Liabilities using 1500 × (0.6/1.6) = 562.5 ($B).  【step3】: To reduce liabilities to 500 ($B), solve 500 = 1500 × (x/(1+x)) → x=0.5. The new Debt_Equity_Ratio must be 0.5 (50%).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 615,
        "question": "If a gas station's fuel inventory is approaching the minimum stock level, and the next fuel delivery date is in 5 days, what are the station IDs and manager names of the relevant gas stations?",
        "query": "SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters * 1.1 AND Next_Delivery_Date = DATE_ADD(CURDATE(), INTERVAL 5 DAY));",
        "step": "【step1】: Calculate the 5-day future date using DATE_ADD(CURDATE(), INTERVAL 5 DAY) to determine the next delivery date threshold.  【step2】: Execute the subquery to find Station_IDs in the 'gas' table where Stock_Liters < 110% of Minimum_Stock_Liters **and** Next_Delivery_Date matches the calculated 5-day future date.  【step3】: Retrieve Station_ID and Manager_Name from 'gas_station' where Station_ID matches the results from the subquery.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 616,
        "question": "If a gas station's fuel inventory has 50,000,000,000 litres with a sulfur content of 50 ppm, what is the total sulfur content in this fuel?",
        "query": "SELECT Stock_Liters * Sulfur_Content AS Total_Sulfur_Content FROM gas WHERE Stock_Liters = 50000000000 AND Sulfur_Content = 50;",
        "step": "【step1】: Filter the gas table to retrieve records where Stock_Liters equals 50,000,000,000 and Sulfur_Content equals 50.  【step2】: Calculate the total sulfur content by multiplying Stock_Liters by Sulfur_Content for the filtered records.  【step3】: Output the result as Total_Sulfur_Content using column aliasing.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 617,
        "question": "If a gas station has a total fuel capacity of 200,000 liters, a current inventory of 180,000 liters, a fuel combustion efficiency of 85%, and a fuel calorific value of 40 MJ/L, what is the effective energy of the current fuel inventory?",
        "query": "SELECT Stock_Liters * 40 * 0.85 AS Effective_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 200000 AND Stock_Liters = 180000);",
        "step": "【step1】: Execute the subquery to find the Station_ID in gas_station where Capacity_Liters = 200000 and Stock_Liters = 180000.  【step2】: Use the retrieved Station_ID to filter the gas table entry.  【step3】: Calculate Effective_Energy_MJ by multiplying Stock_Liters, 40 (MJ/L), and 0.85 (efficiency).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 618,
        "question": "If an oil company has sales of $1200, a net profit margin of 18%, and operates 500 branches, what is the average net profit per branch? If the company aims to increase the average net profit per branch to $500 million, what should the net profit margin be adjusted to?",
        "query": "SELECT (5 * 500) / Sales * 100 AS Target_Net_Profit_Margin FROM company WHERE Sales = 1200;",
        "step": "【step1】: Filter the company table to retrieve records where Sales = 1200 (in billions of USD).  【step2】: Calculate the total required net profit for all branches (5 billion USD × 500 branches = 2500 billion USD).  【step3】: Derive the target net profit margin by dividing the required total profit by the sales value and multiplying by 100: (2500 / 1200) * 100 ≈ 208.33%.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 619,
        "question": "If a gas station's fuel inventory is less than 10% above the minimum stock level and the next fuel delivery is scheduled for 3 days later, but the station is located in a high-traffic area with a daily fuel consumption of 10,000 liters, how should the station manager adjust the inventory management strategy?",
        "query": "SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters * 1.1 AND Next_Delivery_Date = DATE_ADD(CURDATE(), INTERVAL 3 DAY));",
        "step": "【step1】: Filter gas records where Stock_Liters is less than 10% above the minimum required (Stock_Liters < Minimum_Stock_Liters * 1.1).  【step2】: Narrow results to stations with Next_Delivery_Date exactly 3 days from the current date (Next_Delivery_Date = DATE_ADD(CURDATE(), INTERVAL 3 DAY)).  【step3】: Retrieve Station_ID and Manager_Name from gas_station for stations matching the filtered IDs from the subquery.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 620,
        "question": "If a gas station's fuel inventory suddenly increases to 100,000,000,000 liters, and the carbon emissions per liter of fuel is 5 grams, what is the total carbon emissions of these fuels?",
        "query": "SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 100000000000 AND Carbon_Emission = 5;",
        "step": "【step1】: Filter the gas table to find records where Stock_Liters equals 100,000,000,000 liters and Carbon_Emission equals 5克/升.  【step2】: Calculate Total_Carbon_Emission by multiplying Stock_Liters and Carbon_Emission for the filtered records.  【step3】: Return the computed Total_Carbon_Emission value as the result.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 621,
        "question": "If an oil company has sales of $500 and a net profit margin of 5%, what is the total amount of heat generated by the sale of its petroleum products in one year? The heat produced by burning each liter of oil is 35 megajoules.",
        "query": "SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;",
        "step": "【step1】: Filter the 'company' table to find the company with Sales = 500 (billion USD) and Net_Profit_Margin = 5%. This ensures the correct base data for calculating sales-derived metrics.  【step2】: Join 'company' with 'station_company' (via Company_ID) and 'gas' (via Station_ID) to link the company to its associated gas stations and retrieve the Price_Liter of the fuel sold.  【step3】: Calculate total heat by converting sales (in billion USD) to liters sold ((500 * 10^9 USD) / Price_Liter) and multiply by 35 MJ/L. The query assumes Sales is stored in billion units (e.g., 500 = 500 billion USD), requiring a *10 adjustment for unit consistency.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 622,
        "question": "An oil company has total assets of $1000, with a debt-to-equity ratio of 2:1. If the company decides to increase its assets by $500 while maintaining the same debt-to-equity ratio, how much additional debt and equity does the company need to raise?",
        "query": "SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;",
        "step": "【step1】: Filter the company table where Assets = 1000 and Debt_Equity_Ratio = 2 to confirm the current financial structure.  【step2】: Calculate the proportion of debt (2/3) and equity (1/3) based on the 2:1 ratio.  【step3】: Multiply the $50 billion asset increase by these proportions to derive the required New_Debt (2/3 * 500) and New_Equity (1/3 * 500).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 623,
        "question": "If a gas station has a total fuel capacity of 100,000 liters and a current inventory of 80,000 liters, how many more liters of fuel can the station receive for delivery without exceeding its total capacity?",
        "query": "SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;",
        "step": "【step1】: Filter gas_station records where Capacity_Liters equals 100,000 liters.  【step2】: Verify matching gas records with Stock_Liters = 80,000 using a correlated subquery on `gas` via Station_ID.  【step3】: Calculate available capacity by subtracting gas.Stock_Liters from gas_station.Capacity_Liters for qualified stations.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 624,
        "question": "If a gas station has a total fuel capacity of 100,000 liters and the carbon emissions per liter of fuel is 2.5 grams, what would be the total carbon emissions if 1,000,000 liters of fuel were dispensed? Could this scenario realistically happen?",
        "query": "SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;",
        "step": "【step1】: Perform an INNER JOIN between `gas_station` and `gas` tables using `Station_ID` to link fuel data (including `Carbon_Emission`) to the specific station.  【step2】: Filter results using `WHERE gas_station.Capacity_Liters = 100000` to isolate stations with the given capacity.  【step3】: Multiply the hardcoded value `1000000` (hypothetical delivered liters) by `Carbon_Emission` from the joined table, ignoring real-world constraints like storage capacity.  **Reality Check**: This query calculates emissions for 1,000,000 liters delivered to a station with only 100,000L capacity. While the math works (output: 2,500,000 grams), this scenario is physically impossible since delivered fuel exceeds storage capacity.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 625,
        "question": "If an oil company has sales of $500 and a net profit margin of 5%, what is the total amount of heat generated by the sale of its petroleum products in one year? The heat generated per liter of oil combusted is 35 megajoules.",
        "query": "SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;",
        "step": "【step1】: Filter the company with Sales = 500 (in billions of USD) and Net_Profit_Margin = 5% using the WHERE clause on the company table.  【step2】: Join the filtered company data with station_company to link the company to its associated gas stations, and then join with the gas table to retrieve fuel price per liter (g.Price_Liter).  【step3】: Calculate total heat by: (1) Convert sales (500 * 10^9 USD) to liters sold via (Sales * 10^9 USD) / Price_Liter, then (2) multiply by 35 MJ/liter to get Total_Heat.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 626,
        "question": "An oil company has total assets of $1,000, with a debt-to-equity ratio of 2:1. If the company decides to increase its assets by $500 while maintaining the same debt-to-equity ratio, how much additional debt and shareholder equity will the company need to raise?",
        "query": "SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;",
        "step": "【step1】: Filter the company table to find the company with 100 billion assets (Assets = 1000*1e9/1e9=1000) and debt-equity ratio of 2:1 using WHERE clause.  【step2】: Calculate the proportional allocation of the new 500 billion assets by multiplying 500 with (2/3) for debt and (1/3) for equity, maintaining the 2:1 ratio.  【step3】: Return the computed values directly as New_Debt and New_Equity columns from the filtered company record.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 627,
        "question": "If a gas station has a total fuel capacity of 100,000 liters and a current inventory level of 80,000 liters, how many more liters of fuel can the station receive without exceeding its total capacity?",
        "query": "SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;",
        "step": "【step1】: Filter gas_station records where Capacity_Liters is 100,000 liters.  【step2】: Subquery to retrieve Stock_Liters (80,000 liters) from gas table by matching Station_ID.  【step3】: Calculate available capacity by subtracting subquery result from Capacity_Liters.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 628,
        "question": "If a gas station has a total fuel capacity of 100,000 liters, and the carbon emission per liter of fuel is 2.5 grams, then if the station receives 1,000,000 liters of fuel at once, what will be its carbon emission?",
        "query": "SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;",
        "step": "【step1】: Join gas_station and gas tables using Station_ID to access Carbon_Emission data.  【step2】: Filter results to retain only gas stations with total capacity of 100,000 liters (Capacity_Liters = 100000).  【step3】: Multiply 1,000,000 liters by the Carbon_Emission value (2.5g/L) from gas table to calculate total emissions (ignoring physical capacity constraints).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 629,
        "question": "If a gas station has a total fuel capacity of 100,000 liters, and each liter of fuel emits a certain amount of carbon (represented by Carbon_Emission in grams), what is the total annual carbon emissions of the gas station when operating at full capacity, assuming the gas station operates at full capacity every day?",
        "query": "SELECT Capacity_Liters * Carbon_Emission * 365 AS Annual_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;",
        "step": "【step1】:Join gas_station and gas tables on Station_ID to link station capacity with fuel emission data.  【step2】:Filter the joined dataset where gas_station.Capacity_Liters equals 100,000 liters.  【step3】:Calculate annual emissions by multiplying capacity (100,000L), emission per liter (2.5g/L), and annual days (365).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 630,
        "question": "An oil company has total assets of $1000 and a debt-to-equity ratio of 2:1. If the company decides to increase its assets by $500 while maintaining the same debt-to-equity ratio, how much additional debt and equity would the company need to raise?",
        "query": "SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;",
        "step": "【step1】: Filter the company table to select records where Assets = 1000 (billion) and Debt_Equity_Ratio = 2.  【step2】: Calculate the new debt and equity allocations using the ratio 2:1. Multiply the added assets (500 billion) by 2/3 for debt and 1/3 for equity.  【step3】: Output the computed values as New_Debt and New_Equity columns.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 631,
        "question": "If a gas station has a total fuel capacity of 100,000 liters and the current inventory is 80,000 liters, how many more liters of fuel can the station receive without exceeding its total capacity?",
        "query": "SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;",
        "step": "【step1】: Filter the gas_station table where Capacity_Liters is 100,000 liters.  【step2】: For each matching station, retrieve its current Stock_Liters from the gas table via a subquery using Station_ID correlation.  【step3】: Calculate Available_Capacity by subtracting Stock_Liters (8,000 liters) from Capacity_Liters (100,000 liters) and enforce Stock_Liters = 80000 in the WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 632,
        "question": "If a gas station with a capacity of 100,000 liters receives 1,000,000 liters of fuel at once, and the carbon emission per liter of fuel is 2.5 grams, what would be the total carbon emissions?",
        "query": "SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;",
        "step": "【step1】: Perform INNER JOIN between `gas_station` and `gas` tables using Station_ID to link fuel data with station capacity information.  【step2】: Filter using WHERE clause to select only stations with Capacity_Liters = 100,000 liters.  【step3】: Calculate total carbon emissions by multiplying hardcoded 1,000,000 liters with Carbon_Emission (2.5g/L) from the gas table.  Reality check: A station with 100,000L capacity CANNOT physically receive 1,000,000L fuel simultaneously. This scenario would violate physical storage constraints and safety regulations.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 633,
        "question": "If a gas station with ID '1' has stored diesel fuel, what is the total mass of this diesel and how much heat will be generated if all this diesel is completely burned?",
        "query": "SELECT Stock_Liters * 0.85 AS Total_Mass_kg, (Stock_Liters * 0.85) * 45.5 AS Total_Heat_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = '1';",
        "step": "【step1】: Filter the gas table to retrieve records where Fuel_Type is 'diesel' and Station_ID matches the specified ID.  【step2】: Calculate Total_Mass_kg by multiplying Stock_Liters (100,000 liters) by the diesel density (0.85 kg/l).  【step3】: Compute Total_Heat_MJ by multiplying Total_Mass_kg (85,000 kg) by the diesel heat value (45.5 MJ/kg).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 634,
        "question": "An oil company has a sales growth rate of 8%. If the company with Company_ID '104' has last year's sales, what is this year's projected sales? If the net profit margin is 12%, what is this year's projected net profit?",
        "query": "SELECT Sales * 1.08 AS Projected_Sales, (Sales * 1.08) * 0.12 AS Projected_Profits FROM company WHERE Company_ID = '104';",
        "step": "【step1】: Filter the company table to retrieve the specific company's data using Company_ID.  【step2】: Calculate this year's projected sales by multiplying last year's sales (30 billion) by 1.08 (8% growth rate).  【step3】: Compute projected profits by applying the net profit margin (12%) to the projected sales.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 635,
        "question": "If a gas station with Station_ID '1' has a fuel inventory of 20,000 liters, a minimum stock level of 5,000 liters, and sells 2,000 liters of fuel per day, how many more days can the gas station sustain sales?",
        "query": "SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Days_Remaining FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Retrieve the fuel inventory data for the specified gas station from the `gas` table, filtering by the given `Station_ID`.  【step2】: Subtract the `Minimum_Stock_Liters` (5000) from `Stock_Liters` (20000) to calculate the usable fuel volume above the safety threshold.  【step3】: Divide the result by the daily sales rate (2000 liters/day) to compute `Days_Remaining`, ensuring numeric precision and labeling the output column.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 636,
        "question": "If a petroleum company's gas station sells 5,000,000 liters of gasoline per day, with each liter emitting 2.31 kilograms of carbon, what is the total annual carbon emissions generated by this company through gasoline sales? If all gas stations worldwide operate with this level of carbon emissions, what would be the global annual total carbon emissions? (There are 1 million gas stations globally.)",
        "query": "SELECT 5000000 * 2.31 * 365 AS Annual_Carbon_Emission, 5000000 * 2.31 * 365 * 1000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Filter the gas table to retrieve the specified gas station's record using Station_ID = 'Specific_Station_ID'.  【step2】: Calculate the annual carbon emission for a single station by multiplying daily sales (5,000,000 liters), carbon emission per liter (2.31 kg), and days in a year (365).  【step3】: Compute the global total by multiplying the single station’s annual emission by the total number of global gas stations (1,000,000).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "1",
        "idx": 637,
        "question": "If a gas station with Station_ID = '1' has a current inventory of 80,000 liters and the fuel density is 0.75 kg/liter, what is the total mass of this fuel? If this fuel is completely burned, how much heat will be generated? (Given that the fuel's calorific value is 42 MJ/kg)",
        "query": "SELECT Stock_Liters * 0.75 AS Total_Mass_kg, (Stock_Liters * 0.75) * 42 AS Total_Heat_MJ FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Retrieve the current stock liters (Stock_Liters) from the gas table for the specified Station_ID using the WHERE clause.  【step2】: Calculate the total mass by multiplying Stock_Liters with the fuel density (0.75 kg/L), resulting in Total_Mass_kg.  【step3】: Compute the total heat generated by multiplying Total_Mass_kg with the fuel’s calorific value (42 MJ/kg), producing Total_Heat_MJ.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "2",
        "idx": 638,
        "question": "An oil company has a revenue growth rate of 10%, with last year's sales reaching $40 billion. What is the projected sales for this year? If the net profit margin is 15%, what is the expected net profit for this year? If the company's debt-to-equity ratio is 1.5:1, what is its total debt?",
        "query": "SELECT Sales * 1.10 AS Projected_Sales, (Sales * 1.10) * 0.15 AS Projected_Profits, ((Sales * 1.10) * 0.15) * 1.5 AS Total_Debt FROM company WHERE Company_ID = '104';",
        "step": "【step1】: Calculate projected sales for this year by applying a 10% growth rate to last year's sales (Sales * 1.10).  【step2】: Compute projected profits using the projected sales and a 15% net profit margin ((Projected_Sales) * 0.15).  【step3】: Determine total debt by multiplying projected profits by the debt-to-equity ratio of 1.5 ((Projected_Profits) * 1.5).",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "3",
        "idx": 639,
        "question": "If a gas station has a fuel inventory of 30,000 liters, a minimum inventory of 10,000 liters, and sells 2,500 liters of fuel per day, how many more days can the gas station sustain sales? Does the current inventory level require immediate refill?",
        "query": "SELECT (Stock_Liters - Minimum_Stock_Liters) / 2500 AS Days_Remaining, CASE WHEN Stock_Liters < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Need_Refill FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Retrieve Stock_Liters and Minimum_Stock_Liters from the gas table for the specified Station_ID.  【step2】: Calculate Days_Remaining by subtracting Minimum_Stock_Liters from Stock_Liters and dividing by 2500.  【step3】: Determine Need_Refill using CASE: return 'Yes' if Stock_Liters < Minimum_Stock_Liters, else 'No'.",
        "format": "MySQL"
    },
    {
        "db_id": "gas",
        "type": "4",
        "idx": 640,
        "question": "If an oil company's gas stations sell 10,000,000 liters of gasoline per day, with each liter of gasoline emitting 2.5 kilograms of carbon, what is the total annual carbon emissions generated by this company through gasoline sales? If all gas stations worldwide operate at this emission level, what would be the global total annual carbon emissions? (There are 2 million gas stations worldwide.)",
        "query": "SELECT 10000000 * 2.5 * 365 AS Annual_Carbon_Emission, 10000000 * 2.5 * 365 * 2000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';",
        "step": "【step1】: Validate the existence of the specified gas station by querying the `gas` table with `WHERE Station_ID = '1'` to ensure the station is valid.  【step2】: Calculate the annual carbon emissions for one station using fixed values: `10000000 * 2.5 * 365`, bypassing actual table fields since the problem uses hypothetical values.  【step3】: Compute the global annual emissions by multiplying the single station's result by 2,000,000, as the query explicitly hardcodes the global station count.",
        "format": "MySQL"
    },
    {
        "db_id": "generators",
        "type": "1",
        "idx": 641,
        "question": "Calculate the efficiency of generator with ID 1001, which has an actual output power of 950 KW and an input power of 1050 KW.",
        "query": "SELECT (950.0 / 1050.0) * 100 AS Efficiency FROM generators WHERE GeneratorID = 1001;",
        "step": "【step1】: Filter the generators table using WHERE GeneratorID = 1001 to isolate the specific generator.  【step2】: Calculate efficiency with explicit numerical values: (output_power/input_power)*100 = (950.0/1050.0)*100.  【step3】: Return the calculated efficiency value as a formatted percentage column named \"Efficiency\".",
        "format": "MySQL"
    },
    {
        "db_id": "generators",
        "type": "2",
        "idx": 642,
        "question": "Calculate the total power output of all generators produced by manufacturer ID 2001, which has 10 generators with rated powers of 500 KW, 600 KW, 700 KW, 800 KW, 900 KW, 1000 KW, 1100 KW, 1200 KW, 1300 KW, and 1400 KW respectively.",
        "query": "SELECT SUM(RatedPower) AS TotalPower FROM generators WHERE ManufacturerID = 2001;",
        "step": "【step1】: Filter all records in the 'generators' table where ManufacturerID equals 2001.  【step2】: Calculate the sum of the RatedPower column from the filtered records.",
        "format": "MySQL"
    },
    {
        "db_id": "generators",
        "type": "3",
        "idx": 643,
        "question": "Determine whether generator 1002 requires maintenance, as its continuous operating time has exceeded 1000 hours and its status is \"running.\"",
        "query": "SELECT GeneratorID, GeneratorName, CASE WHEN ContinualTime > 1000 AND Status = 1 THEN 'need maintenance' ELSE 'no need maintenance' END AS MaintenanceStatus FROM generators WHERE GeneratorID = 1002;",
        "step": "【step1】: Filter the 'generators' table to retrieve the record where GeneratorID = 1002.  【step2】: Evaluate the conditions: check if the selected record has ContinualTime > 1000 and Status = 1 (Running).  【step3】: Apply the CASE expression to assign 'need maintenance' if both conditions are met, otherwise 'no need maintenance', and output the MaintenanceStatus.",
        "format": "MySQL"
    },
    {
        "db_id": "generators",
        "type": "4",
        "idx": 644,
        "question": "The rated speed of the 1003 generator is 3000 RPM, but its actual speed has reached 10000 RPM. Determine whether this speed exceeds the safe range.",
        "query": "SELECT GeneratorID, GeneratorName, CASE WHEN 10000 > RatedRotationSpeed * 1.2 THEN  'exceeds safe range' ELSE 'within safe range' END AS RotationSafetyStatus FROM generators WHERE GeneratorID = 1003;",
        "step": "【step1】: Filter the generators table to retrieve the specific generator with GeneratorID = 1003.  【step2】: Calculate the safety threshold by comparing the actual rotation speed (10000 RPM) against 120% of the RatedRotationSpeed (3000 RPM × 1.2 = 3600 RPM).  【step3】: Use CASE to determine if 10000 RPM exceeds the safety threshold and output the RotationSafetyStatus.",
        "format": "MySQL"
    },
    {
        "db_id": "generators",
        "type": "1",
        "idx": 645,
        "question": "Calculate the power factor of generator 1001, with a rated voltage of 400 V and rated current of 1500 A.",
        "query": "SELECT RatedPower / (RatedVoltage * 1500) AS PowerFactor FROM generators WHERE GeneratorID = 1001;",
        "step": "【step1】: Filter the generators table to retrieve the record where GeneratorID = 1001.  【step2】: Calculate the power factor using the formula: RatedPower / (RatedVoltage * 1500).  【step3】: Assign the calculated result the alias \"PowerFactor\" in the output.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 646,
        "question": "Assuming the customer's purchased lawn mower is operating at full load, calculate the total energy consumption per hour (including fuel and electricity), and list the top 5 customers in descending order of energy efficiency.",
        "query": "SELECT c.Customer_ID, c.Name, CASE WHEN l.Power_Source = 'Gasoline' THEN (l.Engine_Power * 745.7 * 3600 / 1000) + (pm.Fuel_Consumption * 34.2 * 1000) WHEN l.Power_Source IN ('Electric', 'Battery') THEN (l.Battery_Capacity * 12 * 3.6 * 60) / NULLIF(l.Run_Time, 0) ELSE 0 END AS Total_Energy_kJh FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN performance_metrics pm ON l.Mower_ID = pm.Mower_ID ORDER BY pm.Energy_Efficiency DESC LIMIT 5;",
        "step": "【step1】: Join relevant tables (customers, sales, lawn_mowers, performance_metrics) to link customers with their purchased mowers and corresponding performance data.  【step2】: Calculate total hourly energy consumption using CASE logic: Convert gasoline engine power (HP → kW → kJ/h) and fuel consumption (L/h → kJ/h), or compute electric/battery energy (Ah × voltage × conversion factors / runtime).  【step3】: Sort results by Energy_Efficiency (from performance_metrics) in descending order and limit to top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 647,
        "question": "Calculate the purchasing power index for each customer (logarithm of the ratio between annual purchase amount and the average purchase amount in their state), filter for customers with an index >1.5, and sort them in descending order by index value.",
        "query": "SELECT Customer_ID, Name, Purchase_Power_Index FROM (SELECT c.Customer_ID, c.Name, LOG10(c.Annual_Purchase_Volume / AVG(c.Annual_Purchase_Volume) OVER (PARTITION BY c.State)) AS Purchase_Power_Index FROM customers c) AS sub WHERE Purchase_Power_Index > 1.5 ORDER BY Purchase_Power_Index DESC;",
        "step": "【step1】: Compute state-wise average annual purchase volume using window function partitioned by State  【step2】: Calculate Purchase_Power_Index for each customer via LOG10(Annual_Purchase_Volume / state_average) in derived subquery  【step3】: Filter results where index > 1.5 and sort descendingly by Purchase_Power_Index",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 648,
        "question": "Find customers with annual purchasing amounts exceeding $500,000 who opted for manual lawn mowers, sorted by purchase amount in descending order.",
        "query": "SELECT DISTINCT c.Customer_ID, c.Name, c.Annual_Purchase_Volume FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID WHERE c.Annual_Purchase_Volume > 500000 AND l.Power_Source = 'Manual' ORDER BY c.Annual_Purchase_Volume DESC;",
        "step": "【step1】: Perform three-table JOIN to link customer purchase records with lawn mower specifications using customers → sales → lawn_mowers relationships through Customer_ID and Mower_ID foreign keys  【step2】: Apply dual filters (Annual_Purchase_Volume > 500000 AND Power_Source = 'Manual') to identify high-spending customers purchasing manual equipment  【step3】: Remove duplicates, sort by descending purchase volume, and highlight the contradiction: affluent clients opting for low-tech solutions despite having resources for premium automated products",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 649,
        "question": "Assuming a customer's annual purchasing volume is 999000000, calculate the percentage of their purchases relative to the manufacturer's total output, then rank the top three manufacturers in descending order of this percentage.",
        "query": "SELECT m.Name AS Manufacturer_Name, (SUM(s.Quantity) * 100.0 / m.Production_Volume_Total) AS Percentage FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID WHERE c.Annual_Purchase_Volume = 999000000 GROUP BY m.Manufacturer_ID, m.Production_Volume_Total ORDER BY Percentage DESC LIMIT 3;",
        "step": "【step1】: Filter customers with annual purchase volume of $999M and join sales records to get purchase quantities  【step2】: Aggregate sales quantities by manufacturer while joining production volume data  【step3】: Calculate percentage ratio, sort descending, and limit to top 3 results",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 650,
        "question": "Group customers by their country and calculate the total weight of banknotes corresponding to the annual purchase total for each country. Assume all transactions use $100 denomination banknotes, with each note weighing 1 gram.",
        "query": "SELECT Country, (SUM(Annual_Purchase_Volume) / 100) * 0.001 AS Total_Mass_kg FROM customers GROUP BY Country;",
        "step": "【step1】: Aggregate annual purchase volumes by country using GROUP BY and SUM()  【step2】: Calculate required $100 bills count (TotalAmount/100)  【step3】: Convert paper quantity to mass in kg (Count*1g/1000)",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 651,
        "question": "Group by customer type and state, calculate the annual purchase amount of each group as a percentage of the total purchase amount for that state, and filter out groups where the percentage exceeds 50%.",
        "query": "WITH StateTotal AS (SELECT State, SUM(Annual_Purchase_Volume) AS State_Total FROM customers GROUP BY State) SELECT c.State, c.Customer_Type, (SUM(c.Annual_Purchase_Volume) / st.State_Total) * 100 AS Percentage FROM customers c JOIN StateTotal st ON c.State = st.State GROUP BY c.State, c.Customer_Type HAVING Percentage > 50;",
        "step": "【step1】: Calculate the total annual purchase volume per state using a CTE (StateTotal). This aggregates the sum of Annual_Purchase_Volume grouped by State.  【step2】: Join the original customers table with StateTotal on State, group by State and Customer_Type, and calculate the percentage by dividing each group's total Annual_Purchase_Volume by the corresponding state total.  【step3】: Filter the grouped results using HAVING to retain only groups where the calculated percentage exceeds 50%.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 652,
        "question": "Group by the year of customer registration, count the number of new customers added each year, and determine which years had the highest number of new customers.",
        "query": "SELECT YEAR(Registration_Date) AS Reg_Year, COUNT(Customer_ID) AS New_Customers FROM customers GROUP BY Reg_Year ORDER BY New_Customers DESC;",
        "step": "【step1】: Extract registration year and count new customers per year using YEAR() on Registration_Date and COUNT() aggregation.  【step2】: Group results by Reg_Year to consolidate annual customer counts.  【step3】: Order by New_Customers DESC to identify years with highest growth, directly correlating to effective marketing campaigns.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 653,
        "question": "Assuming there is a customer with an annual purchase amount of 1e18 dollars, calculate the average purchase amount grouped by country and analyze the impact on the result set.",
        "query": "SELECT Country, AVG(Annual_Purchase_Volume) AS Avg_Purchase FROM customers GROUP BY Country ORDER BY Avg_Purchase DESC;",
        "step": "【step1】: Execute the GROUP BY Country clause to aggregate all customer records into distinct groups based on the Country field.  【step2】: Calculate the average Annual_Purchase_Volume for each country group using AVG(Annual_Purchase_Volume). The single 1e18 outlier will disproportionately skew the Avg_Purchase value of its country group, especially if other entries in that group have significantly smaller values.  【step3】: Sort the aggregated results by Avg_Purchase in descending order. The country containing the 1e18 outlier will dominate the top of the results, making the analysis statistically unrepresentative of typical purchasing behavior.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 654,
        "question": "Which customers have a relationship with gasoline-powered lawn mowers where the product of torque and the ratio of their annual purchase volume to mower price exceeds 1000?",
        "query": "SELECT c.Customer_ID, c.Name FROM customers c WHERE EXISTS (SELECT 1 FROM lawn_mowers lm INNER JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Torque * (c.Annual_Purchase_Volume / lm.Price) > 1000);",
        "step": "【step1】: Filter gasoline-powered lawn mowers and their torque values from lawn_mowers and performance_metrics tables using INNER JOIN.  【step2】: Calculate the maximum quantity of each mower a customer can buy (Annual_Purchase_Volume / Price) and multiply by Torque to derive total torque per customer-mower pair.  【step3】: Check via EXISTS clause if any customer has at least one mower configuration where the total torque exceeds 1000 Nm, returning qualifying customers.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 655,
        "question": "Find individual customers whose annual purchase volume exceeds 3 times the average annual purchase volume of business customers, and whose state has fewer than 50 total customers.",
        "query": "SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Individual' AND c.Annual_Purchase_Volume > 3 * (SELECT AVG(Annual_Purchase_Volume) FROM customers WHERE Customer_Type = 'Business') AND (SELECT COUNT(*) FROM customers c2 WHERE c2.State = c.State) < 50;",
        "step": "【step1】: Calculate the average annual purchase volume of business customers using a subquery in the WHERE clause.  【step2】: Filter individual customers whose annual purchase volume exceeds 3 times the calculated business average.  【step3】: Apply a correlated subquery to check if the customer's state has fewer than 50 total customers across all customer types.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 656,
        "question": "Which business customers have an annual purchase volume lower than the average annual purchase volume of individual customers in their respective countries?",
        "query": "SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume < (SELECT AVG(Annual_Purchase_Volume) FROM customers c2 WHERE c2.Customer_Type = 'Individual' AND c2.Country = c.Country);",
        "step": "【step1】: Filter all business customers from the customers table.  【step2】: For each business customer, calculate the average Annual_Purchase_Volume of individual customers in the same country using a correlated subquery.  【step3】: Compare each business customer's Annual_Purchase_Volume with their country's individual customer average, and return only those where the business purchase volume is lower.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 657,
        "question": "Find customers whose annual purchase volume exceeds 10 times the total annual purchase volume of all customers, and whose registration date is more than 100 years ago.",
        "query": "SELECT Customer_ID, Name FROM lawnmower.customers WHERE Annual_Purchase_Volume > (SELECT 10 * SUM(Annual_Purchase_Volume) FROM lawnmower.customers) AND Registration_Date < DATE_SUB(CURRENT_DATE, INTERVAL 100 YEAR);",
        "step": "【step1】: Calculate the total annual purchase volume threshold by multiplying the sum of all customers' Annual_Purchase_Volume by 10 using a subquery: (SELECT 10 * SUM(Annual_Purchase_Volume) FROM lawnmower.customers)  【step2】: Filter customers whose Registration_Date is earlier than 100 years before the current database date using DATE_SUB(CURRENT_DATE, INTERVAL 100 YEAR)  【step3】: Combine both conditions with AND to select customers where Annual_Purchase_volume exceeds the calculated threshold and Registration_Date meets the time constraint",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 658,
        "question": "An enterprise customer has an annual procurement amount of $1,000,000. Assuming each lawn mower costs $2,000 and weighs 50kg, calculate the total work required to vertically lift all the lawn mowers to a height of 2 meters (ignoring mechanical efficiency losses).",
        "query": "SELECT (c.Annual_Purchase_Volume/lm.Price)*lm.Weight*9.8*2 AS Total_Work_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price=2000 AND lm.Weight=50 WHERE c.Customer_Type='Business' AND c.Annual_Purchase_Volume=1000000;",
        "step": "【step1】: Filter customers table to find business customer with $1,000,000 annual purchase  【step2】: Join with lawn_mowers table filtering for specific models priced at $2000 weighing 50kg  【step3】: Calculate total work using formula: (Annual_Volume/Price)×Weight×gravity×height → (1000000/2000)×50×9.8×2",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 659,
        "question": "A customer's procurement amounts for 2020, 2021, and 2022 were used to calculate their Compound Annual Growth Rate (CAGR) and forecast the procurement amount for 2025.",
        "query": "WITH SalesCTE AS (SELECT EXTRACT(YEAR FROM Sale_Date) AS yr, SUM(Total_Price) AS vol FROM sales WHERE Customer_ID='2' AND EXTRACT(YEAR FROM Sale_Date) BETWEEN 2020 AND 2022 GROUP BY 1), CAGRData AS (SELECT (MAX(CASE WHEN yr=2022 THEN vol END)/MAX(CASE WHEN yr=2020 THEN vol END))^(1/2.0)-1 AS cagr, MAX(CASE WHEN yr=2022 THEN vol END) AS end_val FROM SalesCTE) SELECT cagr*100||'%' AS CAGR, end_val*POWER(1+cagr,3) AS Projection_2025 FROM CAGRData;",
        "step": "【step1】: Extract annual sales data for the specified customer between 2020-2022 using SalesCTE. Group by year and sum Total_Price from sales table.  【step2】: Calculate CAGR and end value in CAGRData CTE using conditional aggregation (MAX(CASE)) on 2020 and 2022 sales volumes, then apply CAGR formula: (EndVal/StartVal)^(1/periods)-1.  【step3】: Project 2025 sales by applying CAGR exponentially for 3 years (2022→2025) in final SELECT, formatting CAGR as percentage and calculating end_val*(1+cagr)^3.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 660,
        "question": "A customer's address is in Alaska. What is the most common power source of lawn mowers purchased by customers from this state?",
        "query": "SELECT lm.Power_Source, COUNT(*) AS purchase_count FROM sales s JOIN customers c USING(Customer_ID) JOIN lawn_mowers lm USING(Mower_ID) WHERE c.State='AK' GROUP BY 1 ORDER BY 2 DESC LIMIT 1;",
        "step": "【step1】: Join sales with customers (filtering AK state) and lawn_mowers tables to link purchase data with product attributes.  【step2】: Group records by Power_Source and count purchases for each type.  【step3】: Order results descendingly by purchase count and select the top result.  Result: Gasoline-powered mowers are most purchased (extreme cold reduces battery efficiency). The query statistically confirms this via AK customers' highest purchase frequency for gasoline models.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 661,
        "question": "If a customer's annual purchasing amount reaches $10^{12}$, and each lawnmower costs $1 with a weight of $10^{6}kg$, calculate the energy required to transport them, assuming a transport distance of 11186 meters.",
        "query": "SELECT 0.5*(c.Annual_Purchase_Volume/lm.Price)*lm.Weight*POWER(11186,2) AS Energy_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price=1 AND lm.Weight=1000000 WHERE c.Annual_Purchase_Volume=1000000000000;",
        "step": "【step1】: Filter customers with Annual_Purchase_Volume = 1e12 using WHERE clause.  【step2】: JOIN lawn_mowers table with conditional restrictions (Price=1 AND Weight=1e6).  【step3】: Calculate kinetic energy via formula (0.5 * total_mass * velocity²) where total_mass = (purchase_volume/price) * weight and velocity=11186 m/s.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 662,
        "question": "Assuming the engine power (HP) and blade rotation speed (RPM) of the gasoline-powered lawn mowers are known, how do we calculate their torque (Nm)? Please list all eligible lawn mower models, sorted by torque in descending order, and retrieve the top three.",
        "query": "SELECT lm.Model, ROUND(lm.Engine_Power / (pm.Blade_Speed * PI()/30), 2) AS Torque FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' ORDER BY Torque DESC LIMIT 3;",
        "step": "【step1】: Join lawn_mowers and performance_metrics tables using Mower_ID, filter gasoline-powered models  【step2】: Calculate torque using formula (Engine_Power / (Blade_Speed * π/30)) with ROUND to 2 decimals  【step3】: Order results by calculated torque descending, apply LIMIT 3 for top 3 records",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 663,
        "question": "The annual procurement cost for corporate customers (Customer_Type=Business) must include shipping costs, discounts, and taxes. Please calculate their actual total cost (Total_Price + Shipping_Cost - (Discount applied to Total_Price) + (Tax applied to Total_Price)) and list the top five in ascending order by annual purchase volume.",
        "query": "SELECT c.Customer_ID, c.Name, ROUND((s.Total_Price + s.Shipping_Cost - (s.Total_Price * s.Discount/100) + (s.Total_Price * s.Tax_Rate/100)), 2) AS Total_Cost FROM sales s JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE c.Customer_Type = 'Business' ORDER BY c.Annual_Purchase_Volume ASC LIMIT 5;",
        "step": "【step1】: Join `sales` and `customers` tables using `Customer_ID`, filter where `Customer_Type` is 'Business'.  【step2】: Calculate `Total_Cost` using formula: `(Total_Price + Shipping_Cost) - (Total_Price * Discount/100) + (Total_Price * Tax_Rate/100)`, rounded to 2 decimals.  【step3】: Sort results by `Annual_Purchase_Volume` in ascending order, limit to top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 664,
        "question": "Is the maintenance cost of manual lawn mowers (Power_Source=Manual) generally lower than other power types? Please calculate the average maintenance cost (Cost) by maintenance type (Maintenance_Type) and sort in ascending order.",
        "query": "SELECT mt.Maintenance_Type, ROUND(AVG(mt.Cost), 2) AS Avg_Cost FROM lawnmower.maintenance mt JOIN lawnmower.lawn_mowers m ON mt.Mower_ID = m.Mower_ID WHERE m.Power_Source = 'Manual' GROUP BY mt.Maintenance_Type ORDER BY Avg_Cost ASC;",
        "step": "【step1】: JOIN maintenance and lawn_mowers tables to filter records where Power_Source is 'Manual'  【step2】: GROUP BY Maintenance_Type and calculate rounded average Cost  【step3】: Order results by Avg_Cost ascending",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 665,
        "question": "If a lawn mower's battery capacity is 1Ah, what is the model of the lawn mower with the highest coverage area that can cover at least 7140 square meters on a single charge?",
        "query": "SELECT lm.Model, pm.Cutting_Efficiency * (lm.Run_Time/60) AS Coverage_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 1 AND pm.Cutting_Efficiency * (lm.Run_Time/60) >= 7140 ORDER BY Coverage_Area DESC LIMIT 1;",
        "step": "【step1】: Join `lawn_mowers` with `performance_metrics` using `Mower_ID` to combine runtime data and cutting efficiency metrics.  【step2】: Filter results where `Battery_Capacity = 1` and calculate coverage area via `(Cutting_Efficiency * Run_Time / 60) >= 7140`.  【step3】: Sort remaining models by calculated `Coverage_Area` in descending order and retain only the top result using `LIMIT 1`.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 666,
        "question": "Physics Knowledge Question 1: A certain electric grass trimmer has a battery capacity of 5Ah and a runtime of 60 minutes. Assuming the operating voltage is 12V, calculate the total energy stored (in joules) and the average power consumption during operation?",
        "query": "SELECT Battery_Capacity*12*3600 AS Total_Energy_J, (Battery_Capacity*12*3600)/(Run_Time*60) AS Avg_Power_W FROM lawn_mowers WHERE Power_Source IN ('Electric','Battery') AND Battery_Capacity=5 AND Run_Time=60;",
        "step": "【step1】: Filter records from 'lawn_mowers' where Power_Source is either Electric/Battery, Battery_Capacity=5Ah, and Run_Time=60 minutes.  【step2】: Calculate total stored energy using formula: Battery_Capacity(5Ah) * Voltage(12V) * 3600 (to convert Ah to Coulombs and then to Joules).  【step3】: Compute average power consumption by dividing total energy by converted runtime (60 minutes → 3600 seconds).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 667,
        "question": "A gasoline lawn mower's engine has a power of 5HP and weighs 50kg. If it operates continuously for 1 hour at maximum efficiency, find its unit weight power density (W/kg) and total mechanical work (MJ)?",
        "query": "SELECT (Engine_Power*745.7)/Weight AS Power_Density, (Engine_Power*745.7*3600)/1e6 AS Total_Work_MJ FROM lawn_mowers WHERE Power_Source='Gasoline' AND Engine_Power=5 AND Weight=50;",
        "step": "【step1】: Filter the 'lawn_mowers' table to select the specific gasoline-powered mower with Engine_Power=5HP and Weight=50kg using the WHERE clause.  【step2】: Calculate Power_Density by converting engine power from HP to Watts (5*745.7) and dividing by Weight (50kg).  【step3】: Calculate Total_Work_MJ by multiplying the converted power (5*745.7) by 3600 seconds (1 hour) and converting to megajoules (divide by 1e6).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 668,
        "question": "Why is a 10-inch-wheeled lawn mower more suitable for sloped terrain than a 6-inch one, based on the average slope handling performance?",
        "query": "SELECT lm.Wheel_Size, AVG(pm.Slope_Handling) AS Avg_Slope_Handling FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID=pm.Mower_ID WHERE lm.Wheel_Size IN (6,10) GROUP BY lm.Wheel_Size ORDER BY Wheel_Size DESC;",
        "step": "【step1】: Join 'lawn_mowers' with 'performance_metrics' using Mower_ID to connect product specifications with slope handling capabilities  【step2】: Calculate average Slope_Handling for 6-inch and 10-inch wheel sizes using GROUP BY and AVG aggregation  【step3】: Order results by Wheel_Size DESC to show superior slope handling of larger wheels first",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 669,
        "question": "Hypothetical Reasoning Question 4: Given a lawnmower weighing 2000kg with a blade rotation speed of 100000 RPM, calculate its rotational kinetic energy (in joules) and the equivalent TNT yield (where 1 gram of TNT ≈ 4184 joules), disregarding the material's strength limit.",
        "query": "SELECT 0.5*(0.5*lm.Blade_Weight*POW(lm.Blade_Length/200,2))*POW(2*PI()*pm.Blade_Speed/60,2) AS Rotational_Energy_J, (0.5*(0.5*lm.Blade_Weight*POW(lm.Blade_Length/200,2))*POW(2*PI()*pm.Blade_Speed/60,2))/4184 AS TNT_Equivalent_g FROM lawnmower.lawn_mowers lm JOIN lawnmower.performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight=2000 AND pm.Blade_Speed=100000;",
        "step": "【step1】: JOIN lawn_mowers and performance_metrics tables using Mower_ID, filter records where lawn_mowers.Weight=2000kg and performance_metrics.Blade_Speed=100000RPM.【step2】: Calculate rotational energy using formula: 0.5 * (moment_of_inertia) * (angular_velocity²), where moment_of_inertia = 0.5*Blade_Weight*(Blade_Length/200)² and angular_velocity = 2π*(Blade_Speed/60).  【step3】: Convert rotational energy to TNT equivalent by dividing the calculated energy by 4184 J/g using the formula: Rotational_Energy_J / 4184.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 670,
        "question": "Calculate the average energy consumption (in megajoules) of gasoline-powered lawn mowers when operating at maximum power, grouped by Power_Source.",
        "query": "SELECT Power_Source, AVG(Engine_Power * 745.7 * 3600 / 1000000) AS Avg_Energy_Consumption_MJ FROM lawn_mowers WHERE Power_Source = 'Gasoline' GROUP BY Power_Source;",
        "step": "【step1】: Filter lawn_mowers records where Power_Source = 'Gasoline' to isolate gasoline-powered units.  【step2】: Calculate individual hourly energy consumption (MJ) for each qualifying unit using (Engine_Power * 745.7 * 3600 / 1e6), converting horsepower to megajoules.  【step3】: Group results by Power_Source and compute the average energy consumption via AVG(), though grouping here produces a single group due to prior filtration.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 671,
        "question": "Calculate the total mowing area (in square meters) for each electric lawn mower model by combining cutting efficiency, run time, and battery life (number of charge cycles), grouped by Model.",
        "query": "SELECT lm.Model, SUM(pm.Cutting_Efficiency * (lm.Run_Time / 60) * pm.Battery_Life) AS Total_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Electric' GROUP BY lm.Model;",
        "step": "【step1】: Filter and join electric lawn mowers with their performance metrics using Mower_ID. Apply WHERE clause to select only 'Electric' Power_Source.  【step2】: Calculate individual area contribution per record by multiplying Cutting_Efficiency (m²/h), Run_Time (converted to hours via /60), and Battery_Life (charge cycles).  【step3】: Group results by Model and aggregate calculated area values using SUM() to produce Total_Area per model group.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 672,
        "question": "Find which type of power source (Power_Source) for lawn mowers achieves the highest cutting efficiency area (based on run time and efficiency) per charge or tank, grouped by Power_Source.",
        "query": "SELECT lm.Power_Source, MAX(pm.Cutting_Efficiency * (lm.Run_Time / 60)) AS Max_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID GROUP BY lm.Power_Source ORDER BY Max_Area DESC LIMIT 1;",
        "step": "【step1】: Join 'lawn_mowers' with 'performance_metrics' using Mower_ID, calculate potential area coverage per mower as (Cutting_Efficiency * Run_Time/60)  【step2】: Group results by Power_Source and compute MAX area coverage for each group  【step3】: Order groups by Max_Area descending and select the top result with LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 673,
        "question": "Assuming a certain lawn mower has a Battery_Capacity of 10000Ah, a Run_Time of 10000 minutes, and a Cutting_Efficiency of 1000㎡/h, calculate the lawn area (in square kilometers) it can cover on a single charge.",
        "query": "SELECT 'Electric' AS Power_Source, (1000 * 10000 / 60 / 1000000) AS Area_km2;",
        "step": "【step1】: 【Determine Power_Source】 Directly assign 'Electric' as the power source since the calculation explicitly applies to battery-powered mowers with given parameters (Battery_Capacity, Run_Time).  【step2】: 【Calculate Coverage Area】 Compute the area by multiplying Cutting_Efficiency (1000 m²/h) by Run_Time (10000 minutes converted to 10000/60 ≈ 166.6667 hours), then convert to km² by dividing by 1,000,000. Formula: (1000 * 10000 / 60 / 1000000) = ~1.6667 km².",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 674,
        "question": "Calculate the theoretical maximum runtime in minutes for electric or battery-powered lawn mowers when fully charged, with the blade rotating at maximum speed, assuming the battery energy is entirely converted into mechanical energy.",
        "query": "SELECT lm.Mower_ID, lm.Model, (lm.Battery_Capacity * 24 * 3600) / (0.5 * 0.5 * lm.Blade_Weight * POWER(lm.Blade_Length/200, 2) * POWER(2 * PI() * pm.Blade_Speed/60, 2) * 60) AS Theoretical_Run_Time_Minutes FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery');",
        "step": "【step1】: Perform INNER JOIN between lawn_mowers (lm) and performance_metrics (pm) tables using Mower_ID to combine power capacity and blade rotation speed data  【step2】: Filter records to only include electric/battery-powered devices using WHERE clause  【step3】: Calculate theoretical runtime using energy conversion formula: (Battery_Capacity × 24V × 3600s) / (0.5 × 0.5 × Blade_Weight × (Blade_Length/200)^2 × (2π × RPM/60)^2 × 60) to convert stored electrical energy to rotational kinetic energy consumption over time",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 675,
        "question": "Statistics on the total annual fuel cost of all gasoline-powered lawn mowers, assuming 2 hours of operation per day, gasoline price at $3.5 per unit of fuel, incorporating fuel consumption metrics.",
        "query": "SELECT lm.Mower_ID, lm.Model, 2 * 365 * pm.Fuel_Consumption * 3.5 AS Annual_Fuel_Cost FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline';",
        "step": "【step1】: Filter gasoline-powered lawn mowers from the lawn_mowers table using WHERE Power_Source = 'Gasoline'  【step2】: Join with performance_metrics using Mower_ID to access Fuel_Consumption data  【step3】: Calculate annual cost via formula (2 daily hours × 365 days × Fuel_Consumption × $3.5/L) and project required fields",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 676,
        "question": "Identify records where the theoretical run time (calculated from battery capacity and performance metrics) deviates by more than 50% from the recorded run time, specifically for electric or battery-powered lawn mowers.",
        "query": "SELECT lm.Mower_ID, lm.Model, lm.Run_Time AS Recorded_Run_Time, (lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) AS Theoretical_Run_Time FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ABS((lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) - lm.Run_Time) / lm.Run_Time > 0.5;",
        "step": "【step1】: Join `lawn_mowers` and `performance_metrics` tables via `Mower_ID`, filter by electric/battery-powered models.  【step2】: Calculate theoretical runtime using formula `(Battery_Capacity * 24 * 0.8) / (Torque * Blade_Speed / 9549 * 0.001)` derived from energy/power ratio.  【step3】: Filter records where the absolute difference between theoretical and recorded runtimes exceeds 50% of the recorded value.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 677,
        "question": "Identify records with physical inconsistencies where lawn mowers weigh over 1000 units but are labeled as manually operated, or have a turning radius smaller than 0.5% of the blade length.",
        "query": "SELECT Mower_ID, Model, Weight, Power_Source, Turning_Radius, Blade_Length FROM lawn_mowers WHERE (Power_Source = 'Manual' AND Weight > 1000) OR (Turning_Radius < Blade_Length / 200);",
        "step": "【step1】: Filter lawn_mowers where Power_Source is 'Manual' AND Weight exceeds 1000kg  【step2】: Calculate Blade_Length in meters (divided by 100) and compare with Turning_Radius (in meters) for physical contradiction  【step3】: Combine both conditions using OR operator to retrieve records violating either logic",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 678,
        "question": "Assuming the mower blade needs to be lifted to the average ground clearance height for replacement during maintenance, given that the weight of the mower blade during a certain maintenance is 2.5kg and the gravitational acceleration is 9.8m/s², calculate the work done to overcome gravity (unit: joules).",
        "query": "SELECT 2.5 * 9.8 * (AVG(Ground_Clearance)/100) AS Work_Joules FROM lawn_mowers;",
        "step": "【step1】: Calculate the average ground clearance (in centimeters) from the lawn_mowers table and convert it to meters by dividing by 100.  【step2】: Multiply the given blade weight (2.5 kg) by gravitational acceleration (9.8 m/s²) and the average ground clearance in meters.  【step3】: Combine these calculations into a single SELECT statement to output the total work in joules.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 679,
        "question": "Count the total cost of parts (Parts_Cost) for all maintenance of the 'Replacement' type, and calculate its proportion (rounded to two decimal places) to the total cost of all maintenance types.",
        "query": "SELECT ROUND((SELECT SUM(Parts_Cost) FROM maintenance WHERE Maintenance_Type='Replacement') / SUM(Parts_Cost) * 100, 2) AS Cost_Percentage FROM maintenance;",
        "step": "【step1】: Calculate the total Parts_Cost for 'Replacement' maintenance type using SUM(Parts_Cost) with a WHERE filter on Maintenance_Type.  【step2】: Compute the overall total Parts_Cost across all maintenance types using SUM(Parts_Cost) without filtering.  【step3】: Divide the Replacement-specific total by the global total, multiply by 100, and apply ROUND(...,2) to format the percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 680,
        "question": "According to maintenance records, what is the comparison result between the average cost of 'Routine' type maintenance and that of 'Repair' type? Please explain the reason by combining the definition of maintenance types and cost composition.",
        "query": "SELECT CASE WHEN (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Routine') < (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Repair') THEN 'conforms to common sense' ELSE 'abnormal' END AS Cost_Comparison;",
        "step": "【step1】: Calculate average cost for 'Routine' maintenance type using (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Routine')  【step2】: Calculate average cost for 'Repair' maintenance type using (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Repair')  【step3】: Compare both averages with CASE statement to determine if Routine's average is lower than Repair's, returning 'conforms to common sense' or 'abnormal' as Cost_Comparison.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 681,
        "question": "Assume a lawn mower underwent 1 million maintenance instances in one year, with each instance having a Labor_Cost of $50,000 and a Parts_Cost of $1,000,000. Determine whether its total maintenance cost exceeds 10 times the maximum Revenue in the manufacturer table.",
        "query": "SELECT CASE WHEN 1000000*(50000+1000000) > (SELECT MAX(Revenue)*10 FROM manufacturers) THEN '是' ELSE '否' END AS Is_Exceed;",
        "step": "【step1】: Calculate total maintenance cost: 1,000,000 maintenance instances × ($50,000 Labor_Cost + $1,000,000 Parts_Cost) per instance.  【step2】: Retrieve maximum Revenue from manufacturers table and compute 10× value via subquery: (SELECT MAX(Revenue)*10 FROM manufacturers).  【step3】: Compare results using CASE statement to determine if total cost exceeds 10× max Revenue, returning '是' (yes) or '否' (no).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 682,
        "question": "Calculate the daily average cost for each maintenance (total cost divided by the number of days between the maintenance date and next maintenance date), and identify the top five maintenance records with the highest daily average cost, sorted in descending order of daily average cost.",
        "query": "SELECT Maintenance_ID, (Labor_Cost + Parts_Cost) / DATEDIFF(Next_Maintenance_Date, Maintenance_Date) AS Daily_Cost FROM maintenance WHERE Next_Maintenance_Date IS NOT NULL ORDER BY Daily_Cost DESC LIMIT 5;",
        "step": "【step1】: Calculate the daily cost for each maintenance by summing labor and parts costs, then dividing by the number of days between maintenance dates using DATEDIFF(Next_Maintenance_Date, Maintenance_Date), while filtering out records with NULL Next_Maintenance_Date.  【step2】: Sort all valid records by the calculated Daily_Cost in descending order.  【step3】: Limit the final output to the top 5 records with the highest daily maintenance costs.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 683,
        "question": "Statistics the average proportion of parts cost to total cost for each maintenance type, sorted in descending order by proportion.",
        "query": "SELECT Maintenance_Type, AVG(Parts_Cost / (Labor_Cost + Parts_Cost) * 100) AS Avg_Parts_Percentage FROM maintenance GROUP BY Maintenance_Type ORDER BY Avg_Parts_Percentage DESC;",
        "step": "【step1】: Calculate the parts cost percentage of total cost (labor + parts) for each maintenance record:  SELECT Maintenance_Type, (Parts_Cost / (Labor_Cost + Parts_Cost)) * 100 AS Parts_Percentage FROM maintenance  【step2】: Group by maintenance type and compute the average percentage:  SELECT Maintenance_Type, AVG(Parts_Percentage) AS Avg_Parts_Percentage  FROM (    SELECT Maintenance_Type, (Parts_Cost / (Labor_Cost + Parts_Cost)) * 100 AS Parts_Percentage    FROM maintenance  ) AS subquery  GROUP BY Maintenance_Type  【step3】: Sort results by average percentage in descending order:  SELECT Maintenance_Type, Avg_Parts_Percentage  FROM step2_result  ORDER BY Avg_Parts_Percentage DESC",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 684,
        "question": "Query records with maintenance type as 'Replacement', sorted by total cost in descending order, and retrieve the top five records.",
        "query": "SELECT * FROM maintenance WHERE Maintenance_Type = 'Replacement' ORDER BY (Labor_Cost + Parts_Cost) DESC LIMIT 5;",
        "step": "【step1】: Filter records from the maintenance table where Maintenance_Type is 'Replacement'.  【step2】: Calculate the total cost (Labor_Cost + Parts_Cost) for each filtered record and sort them in descending order by this calculated value.  【step3】: Limit the sorted results to the top 5 records using the LIMIT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 685,
        "question": "Assuming there are abnormal records with maintenance costs exceeding $1 million, sort them in descending order by cost and extract the top three.",
        "query": "SELECT * FROM maintenance WHERE Cost > 1000000 ORDER BY Cost DESC LIMIT 3;",
        "step": "【step1】: Filter records from the 'maintenance' table where the Cost exceeds $1,000,000 using the WHERE clause.  【step2】: Sort the filtered records in descending order of Cost using ORDER BY Cost DESC.  【step3】: Limit the final output to the top 3 results using LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 686,
        "question": "Assuming the vibration level of the lawn mower is reduced to 80% of its original value after each maintenance, calculate the percentage reduction in vibration energy, and display the average reduction percentage grouped by service center.",
        "query": "SELECT m.Service_Center, AVG((1 - POWER(0.8, 2)) * 100) AS Avg_Energy_Reduction_Percent FROM maintenance m JOIN performance_metrics pm ON m.Mower_ID = pm.Mower_ID GROUP BY m.Service_Center",
        "step": "【step1】: Join the `maintenance` table with `performance_metrics` using `Mower_ID` to associate maintenance records with vibration data.  【step2】: Calculate the vibration energy reduction percentage for each maintenance event using the formula `(1 - POWER(0.8, 2)) * 100`, which represents a fixed 36% reduction per maintenance.  【step3】: Group results by `Service_Center` and compute the average reduction percentage (all groups will show 36% since the reduction is constant).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 687,
        "question": "Calculate the structural ratio of labor costs to parts costs for each service center and maintenance type, displaying only records where the ratio exceeds 2:1.",
        "query": "SELECT Service_Center, Maintenance_Type, SUM(Labor_Cost)/NULLIF(SUM(Parts_Cost),0) AS Labor_Parts_Ratio FROM maintenance GROUP BY Service_Center, Maintenance_Type HAVING SUM(Labor_Cost)/NULLIF(SUM(Parts_Cost),0) > 2",
        "step": "【step1】: Aggregate labor and parts costs by service center and maintenance type.  【step2】: Calculate labor-to-parts ratio using `SUM(Labor_Cost)/NULLIF(SUM(Parts_Cost),0)` to avoid division by zero.  【step3】: Filter groups with ratio > 2 using HAVING clause after grouping.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 688,
        "question": "Find the count of maintenance records where the maintenance cost exceeds 50% of the price of the corresponding lawn mower model, grouped by customer type.",
        "query": "SELECT c.Customer_Type, COUNT(*) AS Overpriced_Count FROM maintenance m JOIN lawn_mowers lm ON m.Mower_ID = lm.Mower_ID JOIN sales s ON m.Mower_ID = s.Mower_ID JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE m.Cost > 0.5 * lm.Price GROUP BY c.Customer_Type",
        "step": "【step1】: Join maintenance with lawn_mowers via Mower_ID to access model prices, then join sales (via Mower_ID) and customers (via Customer_ID) to link maintenance records with customer types.  【step2】: Filter records where maintenance cost exceeds 50% of the corresponding model's new price using WHERE m.Cost > 0.5 * lm.Price.  【step3】: Group results by Customer_Type and count qualifying maintenance records per group using GROUP BY and COUNT(*).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 689,
        "question": "Assuming there are 100 consecutive maintenance records, with each maintenance interval being 1 minute, the maintenance cost growing exponentially (initial cost $100, growth rate 10%), calculate the cumulative cost at the 100th maintenance, grouped by maintenance type.",
        "query": "SELECT Maintenance_Type, 100*(POWER(1.1,100)-1)/0.1 AS Cumulative_Cost FROM maintenance GROUP BY Maintenance_Type",
        "step": "【step1】: Group records by Maintenance_Type using GROUP BY clause to separate different maintenance categories.  【step2】: Apply the geometric series formula SUM=100*(1.1^100-1)/0.1 to calculate cumulative cost for 100 exponential growth iterations (initial $100, 10% increase per iteration).  【step3】: Combine grouping with formula execution, producing a theoretical cumulative cost per maintenance type (ignoring actual stored Cost values in the table).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 690,
        "question": "Calculate the change in kinetic energy of a lawn mower blade at maximum speed after a blade replacement during a certain maintenance, assuming the blade is a uniform rectangular sheet and only the weight and length of the blade change before and after maintenance, and the rotational speed may also change.",
        "query": "SELECT m_new.Maintenance_ID, m_new.Mower_ID, (1.0/6) * lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * PI() / 30), 2) AS new_kinetic, (1.0/6) * lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * PI() / 30), 2) AS old_kinetic, (1.0/6) * (lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * PI() / 30), 2) - lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * PI() / 30), 2)) AS energy_diff FROM lawnmower.maintenance m_new JOIN lawnmower.maintenance m_prev ON m_new.Mower_ID = m_prev.Mower_ID AND m_prev.Maintenance_Date = (SELECT MAX(Maintenance_Date) FROM lawnmower.maintenance WHERE Mower_ID = m_new.Mower_ID AND Maintenance_Date < m_new.Maintenance_Date) JOIN lawnmower.lawn_mowers lm_new ON m_new.Mower_ID = lm_new.Mower_ID JOIN lawnmower.lawn_mowers lm_prev ON m_prev.Mower_ID = lm_prev.Mower_ID JOIN lawnmower.performance_metrics pm ON m_new.Mower_ID = pm.Mower_ID JOIN lawnmower.performance_metrics pm_prev ON m_prev.Mower_ID = pm_prev.Mower_ID WHERE m_new.Maintenance_Type = 'Replacement';",
        "step": "【step1】: Self-join the maintenance table to pair each blade replacement record with its immediately preceding maintenance record for the same mower using a correlated subquery.  【step2】: Join lawn_mowers table twice (as lm_new and lm_prev) to retrieve blade weight/length parameters for both new and old maintenance records.  【step3】: Join performance_metrics twice (as pm/pm_prev) to access blade speed values, then calculate kinetic energy variations using the rotational inertia formula (1/6 m l²) with angular velocity derived from RPM.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 691,
        "question": "List the service center, maintenance ID, and cost ratio for repair-type maintenance records where the cost ratio (calculated as (Cost - Parts_Cost) * 100.0 / Cost) is more than 3 standard deviations above the average cost ratio across all repair-type maintenance records.",
        "query": "WITH Stats AS (SELECT AVG((Cost - Parts_Cost)/Cost*100) AS avg_ratio, STDDEV((Cost - Parts_Cost)/Cost*100) AS std_ratio FROM maintenance WHERE Maintenance_Type = 'Repair') SELECT Service_Center, Maintenance_ID, (Cost - Parts_Cost)/Cost*100 AS cost_ratio FROM maintenance CROSS JOIN Stats WHERE Maintenance_Type = 'Repair' AND (Cost - Parts_Cost)/Cost*100 > (avg_ratio + 3 * std_ratio);",
        "step": "【step1】: Calculate the statistical baseline by computing the average and standard deviation of the cost ratio ((Cost - Parts_Cost)/Cost*100) for all 'Repair' records in the maintenance table.  【step2】: Perform a cross-join between the maintenance table and the calculated statistics to apply the baseline thresholds across all qualifying 'Repair' records.  【step3】: Filter records where the cost_ratio exceeds the anomaly threshold (avg_ratio + 3×std_ratio), returning Service_Center, Maintenance_ID, and the normalized cost_ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 692,
        "question": "Identify records in replacement-type maintenance where the time interval between Maintenance_Date and Next_Maintenance_Date is less than 6 months.",
        "query": "SELECT Maintenance_ID, Mower_ID, Maintenance_Date, Next_Maintenance_Date FROM maintenance WHERE Maintenance_Type = 'Replacement' AND TIMESTAMPDIFF(MONTH, Maintenance_Date, Next_Maintenance_Date) < 6;",
        "step": "【step1】: Filter records where Maintenance_Type is 'Replacement' to focus on replacement-related maintenance activities.  【step2】: Calculate the month difference between Maintenance_Date and Next_Maintenance_Date for each filtered record.  【step3】: Select records where the calculated month difference is less than 6 and output the specified fields (Maintenance_ID, Mower_ID, Maintenance_Date, Next_Maintenance_Date).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 693,
        "question": "Identify records where the single maintenance labor cost exceeds 10 times the annual maintenance budget limit for that lawn mower (assuming budget = total annual maintenance count * historical average cost * 1000).",
        "query": "SELECT m1.Maintenance_ID, m1.Mower_ID, m1.Labor_Cost FROM maintenance m1 WHERE m1.Labor_Cost > 10 * (SELECT AVG(Cost) * COUNT(*) * 1000 FROM maintenance m2 WHERE m2.Mower_ID = m1.Mower_ID);",
        "step": "【step1】: For each maintenance record (m1), calculate the annual maintenance budget upper limit for the corresponding mower. This is derived as (number of maintenance records for that mower × historical average Cost of that mower × 1000)  【step2】: Multiply the budget upper limit by 10 to create the comparison threshold (10× budget)  【step3】: Filter records where Labor_Cost exceeds the calculated threshold from Step 2, returning Maintenance_ID, Mower_ID, and Labor_Cost values that violate the budget constraint",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 694,
        "question": "A gasoline-powered lawn mower produced by a certain manufacturer has an engine power of 5 HP. If the torque is 10 Nm, what blade rotation speed in RPM is needed?",
        "query": "SELECT (lm.Engine_Power * 5252) / pm.Torque AS Blade_Speed_RPM FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND lm.Engine_Power = 5 AND pm.Torque = 10;",
        "step": "【step1】: Perform INNER JOIN between lawn_mowers and performance_metrics tables using Mower_ID to establish engine-power-to-torque relationships  【step2】: Apply filters where Power_Source='Gasoline', Engine_Power=5 HP, and Torque=10 Nm  【step3】: Calculate blade speed using formula (Engine_Power × 5252) / Torque to obtain RPM value",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 695,
        "question": "A manufacturer has an annual revenue of $1 billion, a profit margin of 5%, R&D expenses of $50 million, and 5,000 employees. Calculate the net profit per employee (after deducting R&D costs).",
        "query": "SELECT ((m.Revenue * (m.Profit_Margin / 100)) - m.`R&D_Spending`) / m.Employee_Count AS Net_Profit_Per_Employee FROM manufacturers m WHERE m.Revenue = 1000000000 AND m.Profit_Margin = 5 AND m.`R&D_Spending` = 50000000 AND m.Employee_Count = 5000;",
        "step": "【step1】: Filter the manufacturers table to find the specific manufacturer with $1 billion revenue, 5% profit margin, $50 million R&D spending, and 5000 employees using WHERE clause conditions.  【step2】: Calculate total net profit by computing (Revenue × Profit Margin percentage) - R&D_Spending.  【step3】: Divide the calculated net profit by Employee_Count to determine per-employee net profit through arithmetic division in the SELECT expression.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 696,
        "question": "A manufacturer has only been in operation for 1 year but has already produced a total of 1 million lawn mowers. Is this reasonable?",
        "query": "SELECT CASE WHEN m.Production_Volume_Total > 500000 AND (YEAR(CURDATE()) - m.Founded_Year) = 1 THEN 'unreasonable' ELSE  'reasonable'  END AS Production_Feasibility FROM manufacturers m WHERE m.Production_Volume_Total = 1000000 AND (YEAR(CURDATE()) - m.Founded_Year) = 1;",
        "step": "【step1】: Filter manufacturers with exactly 1 year since founding and 1M total production volume using WHERE (YEAR(CURDATE()) - Founded_Year) = 1 AND Production_Volume_Total = 1000000  【step2】: Apply CASE condition to check if production exceeds 500,000 units while matching the 1-year operation period  【step3】: Return 'unreasonable' (illogical) when both conditions are met, otherwise  'reasonable'  (logical) as Production_Feasibility",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 697,
        "question": "If a manufacturer's profit margin suddenly surges to 10,000%, while its annual revenue remains at $100 million and R&D expenditure is $100 million, what is its new net profit?",
        "query": "SELECT (m.Revenue * (m.Profit_Margin / 100)) - m.`R&D_Spending` AS New_Net_Profit FROM manufacturers m WHERE m.Revenue = 100000000 AND m.Profit_Margin = 10000 AND m.`R&D_Spending` = 100000000;",
        "step": "【step1】: Filter manufacturers with $100M revenue, 10000% profit margin, and $100M R&D spending using WHERE clause.  【step2】: Calculate gross profit by multiplying Revenue (100,000,000) by Profit_Margin/100 (100) to get $10,000,000,000.  【step3】: Deduct R&D_Spending ($100,000,000) from the gross profit, resulting in a New_Net_Profit of $9,900,000,000.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 698,
        "question": "Which manufacturers perform best in terms of the ratio of total production volume to R&D expenditure? Please list the top 5 ranked in descending order by the ratio.",
        "query": "SELECT Name, (Production_Volume_Total / `R&D_Spending`) AS RD_Efficiency FROM manufacturers WHERE `R&D_Spending` > 0 ORDER BY RD_Efficiency DESC LIMIT 5;",
        "step": "【step1】: Filter manufacturers to exclude those with zero R&D spending using WHERE `R&D_Spending` > 0  【step2】: Calculate RD_Efficiency ratio by dividing Production_Volume_Total by R&D_Spending  【step3】: Sort results by RD_Efficiency in descending order and limit output to top 5 records",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 699,
        "question": "Calculate the per capita output value (annual revenue/number of employees) for each manufacturer with more than zero employees, and list the top 5 manufacturers with the highest per capita output value.",
        "query": "SELECT Name, (Revenue / NULLIF(Employee_Count, 0)) AS Per_Capita_Output FROM manufacturers WHERE Employee_Count > 0 ORDER BY Per_Capita_Output DESC LIMIT 5;",
        "step": "【step1】: Filter manufacturers with at least 1 employee using WHERE Employee_Count > 0 to prevent division by zero errors.  【step2】: Compute per capita output by dividing Revenue by Employee_Count, using NULLIF to handle potential zero denominators redundantly (already filtered in step1).  【step3】: Order results by Per_Capita_Output in descending order and limit to top 5 manufacturers.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 700,
        "question": "Which countries have manufacturers with the oldest average age? List the top 3 countries with the highest average age.",
        "query": "SELECT Country, AVG(2024 - Founded_Year) AS Avg_Years FROM manufacturers GROUP BY Country ORDER BY Avg_Years DESC LIMIT 3;",
        "step": "【step1】: Calculate the average operational years per country by grouping manufacturers and computing AVG(2024 - Founded_Year).  【step2】: Sort the results in descending order based on the calculated average years.  【step3】: Restrict the output to the top 3 countries with the highest average values.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 701,
        "question": "Assuming there are manufacturers whose R&D expenditures exceed 100 times their annual revenue, please list such manufacturers and rank the top 5 in descending order of R&D expenditures.",
        "query": "SELECT Name, `R&D_Spending`, Revenue FROM manufacturers WHERE `R&D_Spending` > Revenue * 100 ORDER BY `R&D_Spending` DESC LIMIT 5;",
        "step": "【step1】: Filter manufacturers where R&D spending exceeds 100 times revenue using WHERE `R&D_Spending` > Revenue * 100  【step2】: Sort remaining entries in descending order by R&D_Spending using ORDER BY  【step3】: Limit output to top 5 results using LIMIT 5 to meet ranking requirements",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 702,
        "question": "Calculate the R&D expenditure density (in USD per person) for manufacturers in each country, grouped by country, and sort the results in descending order of R&D expenditure density.",
        "query": "SELECT Country, SUM(`R&D_Spending`) / SUM(Employee_Count) AS R_D_Density FROM manufacturers GROUP BY Country ORDER BY R_D_Density DESC;",
        "step": "【step1】: Group records by Country and calculate the total R&D_Spending and total Employee_Count for each group using SUM()  【step2】: Compute R&D density by dividing the aggregated R&D_Spending by aggregated Employee_Count for each country  【step3】: Sort the grouped results in descending order based on the calculated R&D_Density",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 703,
        "question": "Calculate the ratio of total profit (Revenue * Profit Margin%) to total R&D expenditure for each country, and group statistics by country count based on this ratio.",
        "query": "SELECT ROIRatio, COUNT(Country) AS CountryCount FROM (SELECT Country, SUM(Revenue * Profit_Margin / 100) / SUM(`R&D_Spending`) AS ROIRatio FROM manufacturers GROUP BY Country) AS SubQuery GROUP BY ROIRatio;",
        "step": "【step1】: Calculate each country's total profit (SUM(Revenue * Profit_Margin / 100)) and total R&D spending (SUM(`R&D_Spending`)) using a subquery grouped by Country.  【step2】: Compute the ROIRatio (total profit divided by total R&D spending) for each country in the subquery.  【step3】: Group the results by ROIRatio in the outer query and count the number of countries per ROIRatio using COUNT(Country).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 704,
        "question": "Grouping by country, calculate the average founding year and average number of employees of manufacturers to verify the common assumption that 'companies established longer tend to have larger scales'.",
        "query": "SELECT Country, AVG(Founded_Year) AS AvgFoundedYear, AVG(Employee_Count) AS AvgEmployeeCount FROM manufacturers GROUP BY Country;",
        "step": "【step1】: Select country and calculate average values for founded year and employee count using AVG() functions  【step2】: Group records by country to aggregate averages per nation  【step3】: Compute correlation between AvgFoundedYear and AvgEmployeeCount to validate the hypothesis (implied analytical step)",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 705,
        "question": "Assuming a manufacturer's R&D expenditure is 1000 times its revenue, calculate its profit margin (with other costs being zero), and group these manufacturers by country to calculate their average profit margin.",
        "query": "SELECT Country, AVG((1 - `R&D_Spending` / Revenue) * 100) AS AvgProfitMargin FROM manufacturers WHERE `R&D_Spending` = Revenue * 1000 GROUP BY Country;",
        "step": "【step1】: Filter manufacturers where R&D spending equals 1000 times annual revenue using WHERE `R&D_Spending` = Revenue * 1000  【step2】: Calculate profit margin for each qualifying manufacturer using (1 - R&D_Spending/Revenue) * 100  【step3】: Group results by Country and compute the average profit margin using AVG() with GROUP BY Country",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 706,
        "question": "Find manufacturers with an average annual profit per second ranging between $1/s and $10/s.",
        "query": "SELECT Manufacturer_ID, Name FROM manufacturers WHERE ((Revenue * Profit_Margin / 100) / (2023 - Founded_Year)) / 31536000 BETWEEN 1 AND 10;",
        "step": "【step1】: Calculate annual profit: (Revenue * Profit_Margin / 100)  【step2】: Compute annual profit per second by dividing the annual profit by company age (2023 - Founded_Year) and then converting to seconds (31536000)  【step3】: Filter manufacturers where the calculated value falls between 1 and 10 using BETWEEN clause",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 707,
        "question": "Identify manufacturers with R&D spending exceeding 5% of revenue and revenue per employee exceeding $1,000,000.",
        "query": "SELECT Manufacturer_ID, Name FROM manufacturers WHERE (`R&D_Spending` / Revenue * 100) > 5 AND (Revenue / Employee_Count) > 1000000;",
        "step": "【step1】: Calculate R&D intensity for each manufacturer by dividing R&D_Spending by Revenue and multiplying by 100. Filter manufacturers where this value exceeds 5%.  【step2】: From the step1 results, calculate employee productivity by dividing Revenue by Employee_Count. Filter manufacturers where this value exceeds 1,000,000.  【step3】: Select the Manufacturer_ID and Name fields from the combined filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 708,
        "question": "Find manufacturers that were founded in or before 1993 and have a profit margin below 15%.",
        "query": "SELECT Manufacturer_ID, Name FROM manufacturers WHERE Founded_Year <= 1993 AND Profit_Margin < 15;",
        "step": "【step1】: Filter manufacturers established in or before 1993 (assuming current year is 2023 to ensure 30+ years of operation).  【step2】: Apply the profit margin filter (<15%) to the result from step1.  【step3】: Extract Manufacturer_ID and Name fields from the filtered dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 709,
        "question": "Find manufacturers whose R&D spending exceeds 10 times their market capitalization.",
        "query": "SELECT Manufacturer_ID, Name FROM manufacturers WHERE `R&D_Spending` > Market_Cap * 10;",
        "step": "【step1】: Access all rows from the 'manufacturers' table.  【step2】: Filter manufacturers where the R&D_Spending value exceeds 10 times their Market_Cap (using the condition `R&D_Spending > Market_Cap * 10`).  【step3】: Project the final result by selecting only the Manufacturer_ID and Name columns.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 710,
        "question": "Assuming a gasoline-powered lawn mower with a torque of 10 Nm and a blade speed of 3000 RPM, what is the engine power in HP, and what is its cutting efficiency in square meters per hour?",
        "query": "SELECT lm.Mower_ID, lm.Model, (pm.Torque * (2 * PI() * pm.Blade_Speed / 60) / 745.7) AS Engine_Power_HP, pm.Cutting_Efficiency FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Cutting_Efficiency = 500;",
        "step": "【step1】: Join 'lawn_mowers' and 'performance_metrics' tables using Mower_ID to link engine specifications and performance data.  【step2】: Filter results for gasoline-powered mowers (Power_Source = 'Gasoline') with a cutting efficiency of 500 m²/hr (pm.Cutting_Efficiency = 500).  【step3】: Calculate engine power in HP via formula (Torque × Angular Velocity ÷ 745.7), where angular velocity is derived from blade speed (2π × Blade_Speed ÷ 60). Select relevant fields including the calculated Engine_Power_HP.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 711,
        "question": "An electric lawn mower has a battery capacity of 5 Ah, an energy efficiency of 85%, and a nominal runtime of 60 minutes. Given a voltage of 24V, calculate the actual usable energy per charge (Wh) and the average power (W) during continuous operation of the lawn mower. If the battery has a life of 500 charge cycles and the user operates it for 2 hours per day, how many years can the battery last?",
        "query": "SELECT lm.Mower_ID, lm.Model, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) AS Actual_Energy_Wh, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) / (lm.Run_Time / 60) AS Avg_Power_W, ROUND(pm.Battery_Life / ((2 * 60) / lm.Run_Time) / 365, 1) AS Battery_Life_Years FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND lm.Battery_Capacity = 5 AND pm.Energy_Efficiency = 85 AND lm.Run_Time = 60;",
        "step": "【step1】: Perform INNER JOIN between `lawn_mowers` (aliased as lm) and `performance_metrics` (aliased as pm) using Mower_ID to combine product specifications and performance data.  【step2】: Apply WHERE filters for electric/battery-powered models with 5Ah battery capacity, 85% energy efficiency, and 60-minute runtime.  【step3】: Calculate three key metrics:  - Actual_Energy_Wh: 24V × 5Ah × 85%  - Avg_Power_W: Actual energy ÷ (60min/60 conversion to hours)  - Battery_Life_Years: 500 charges ÷ (daily usage cycles = 120min ÷ 60min runtime) ÷ 365 days/year, rounded to 1 decimal.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 712,
        "question": "If an electric lawn mower has a noise level of 95 decibels, does it comply with daytime noise regulations in residential areas (typically limited to 55-65 decibels)?",
        "query": "SELECT lm.Mower_ID, lm.Model, pm.Noise_Level, CASE WHEN pm.Noise_Level BETWEEN 55 AND 65 THEN '符合' ELSE '不符合' END AS Compliance_Status FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND pm.Noise_Level = 95;",
        "step": "【step1】: Filter electric/battery-powered mowers from lawn_mowers table using WHERE clause on Power_Source  【step2】: JOIN with performance_metrics table on Mower_ID, filtering entries with Noise_Level = 95  【step3】: Apply CASE statement to evaluate Compliance_Status based on Noise_Level range (55-65 dB) and finalize output selection",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 713,
        "question": "Assuming a certain lawn mower has a claimed maximum slope handling capacity of 90 degrees (vertical wall), with its own weight of 50 kg and a ground clearance of 20 cm. Calculate the minimum required friction coefficient μ between the tires and the wall when the mower is stationary on a 90-degree slope. If the mower has an acceleration of 10 m/s², how much torque (in Nm) is needed for it to climb vertically upward?",
        "query": "SELECT lm.Mower_ID, lm.Model, '∞' AS Min_Friction_Coefficient, (lm.Wheel_Size * 0.0254 / 2) * lm.Weight * (9.8 + pm.Acceleration) AS Required_Torque_Nm FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE pm.Slope_Handling = 90 AND lm.Weight = 50 AND lm.Ground_Clearance = 20 AND pm.Acceleration = 10;",
        "step": "【step1】: JOIN lawn_mowers (lm) and performance_metrics (pm) tables using Mower_ID, then filter records with pm.Slope_Handling=90°, lm.Weight=50kg, lm.Ground_Clearance=20cm, and pm.Acceleration=10m/s²  【step2】: Assign '∞' to Min_Friction_Coefficient (static equilibrium on vertical wall requires infinite μ theoretically)  【step3】: Calculate Required_Torque_Nm using formula (Wheel_Size_in_meters/2) * Weight * (g + Acceleration), where Wheel_Size is converted from inches (×0.0254) and g=9.8m/s²",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 714,
        "question": "Find the top 5 lawn mowers with the highest ratio of torque to acceleration, sorted in descending order by the ratio.",
        "query": "SELECT pm.Mower_ID, (pm.Torque / (lm.Weight * 0.2)) AS Torque_Acceleration_Ratio FROM performance_metrics pm JOIN lawn_mowers lm ON pm.Mower_ID = lm.Mower_ID ORDER BY Torque_Acceleration_Ratio DESC LIMIT 5;",
        "step": "【step1】: Join the 'performance_metrics' and 'lawn_mowers' tables using Mower_ID to access Torque from performance_metrics and Weight from lawn_mowers.  【step2】: Calculate the Torque_Acceleration_Ratio by dividing Torque by (Weight * 0.2) for each mower.  【step3】: Sort results by Torque_Acceleration_Ratio in descending order and return only the top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 715,
        "question": "Calculate the total effective working time (in hours) of the top three electric and battery-powered lawn mowers, sorted in descending order by total time.",
        "query": "SELECT lm.Mower_ID, (pm.Battery_Life * lm.Run_Time * pm.Energy_Efficiency) / (60 * 100) AS Total_Hours FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') ORDER BY Total_Hours DESC LIMIT 3;",
        "step": "【step1】: Filter all lawn mowers with 'Electric' or 'Battery' power sources from the `lawn_mowers` table using the WHERE clause.  【step2】: Join the filtered lawn mowers with the `performance_metrics` table on `Mower_ID` to access battery life, run time, and energy efficiency data.  【step3】: Calculate total effective hours using the formula `(Battery_Life * Run_Time * Energy_Efficiency) / (60 * 100)`, sort results descendingly by this value, and limit to the top 3 records.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 716,
        "question": "Query the top 5 lawn mowers with a noise level (Noise_Level) below 75 decibels and cutting efficiency (Cutting_Efficiency) above 200 square meters per hour, sorted by noise level in ascending order.",
        "query": "SELECT Mower_ID, Noise_Level, Cutting_Efficiency FROM performance_metrics WHERE Noise_Level < 75 AND Cutting_Efficiency > 200 ORDER BY Noise_Level ASC LIMIT 5;",
        "step": "【step1】: Filter all records from performance_metrics where Noise_Level < 75 and Cutting_Efficiency > 200, selecting Mower_ID, Noise_Level, and Cutting_Efficiency.  【step2】: Sort the filtered results in ascending order based on Noise_Level.  【step3】: Apply LIMIT 5 to retrieve the top 5 records from the sorted list.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 717,
        "question": "Assuming there exists a lawn mower with an acceleration equal to ten times Earth's gravitational acceleration (i.e., 98 m/s²), query the devices with acceleration ≥ 98 m/s² and deceleration ≥ 98 m/s², then sort them in descending order by acceleration and take the top three.",
        "query": "SELECT Mower_ID, Acceleration, Deceleration FROM performance_metrics WHERE Acceleration >= 98 AND Deceleration >= 98 ORDER BY Acceleration DESC LIMIT 3;",
        "step": "【step1】: Filter records from 'performance_metrics' where both Acceleration and Deceleration are ≥98 m/s².  【step2】: Sort the filtered results in descending order based on Acceleration.  【step3】: Limit the output to the top 3 records after sorting.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 718,
        "question": "Suppose the blade speed of a certain lawn mower is 3500 RPM, and the blade length is 45 cm. Please calculate the linear velocity at the blade tip (in m/s) for each manufacturer and determine whether the maximum value exceeds the steel safety threshold (300 m/s).",
        "query": "SELECT m.Name AS Manufacturer, MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) AS Max_Velocity, CASE WHEN MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) > 300 THEN 'Yes' ELSE 'No' END AS Safety_Status FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID GROUP BY m.Name;",
        "step": "【step1】: Join lawn_mowers, performance_metrics, and manufacturers tables to calculate linear velocity for each mower using formula (2π*blade_length*RPM)/60 with unit conversion (cm→m and RPM→rev/sec)  【step2】: Group results by manufacturer and calculate MAX velocity per group  【step3】: Add CASE statement to evaluate safety threshold (300 m/s) against calculated MAX velocity and select required fields with grouping",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 719,
        "question": "Calculate the total energy consumption in joules for all gasoline-powered lawn mowers running continuously for 8 hours, given a gasoline density of 0.74 kg/L, a calorific value of 44 MJ/kg, and an energy conversion efficiency of 22%. The results should be displayed grouped by fuel consumption rate.",
        "query": "SELECT p.Fuel_Consumption, SUM(p.Fuel_Consumption * 8 * 0.74 * 44 * 1000000 * 0.22) AS Total_Energy_J FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE l.Power_Source = 'Gasoline' GROUP BY p.Fuel_Consumption;",
        "step": "【step1】: Filter and join data: Select gasoline-powered lawn mowers by linking 'lawn_mowers' and 'performance_metrics' tables using Mower_ID, retaining only records where Power_Source = 'Gasoline'.  【step2】: Calculate energy cost: For each qualifying record, compute energy consumption using the formula (Fuel_Consumption * 8 hours * 0.74 kg/L * 44 MJ/kg * 1,000,000 J/MJ * 0.22 efficiency).  【step3】: Group and aggregate: Group results by Fuel_Consumption and sum the calculated energy consumption values for each group as Total_Energy_J.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 720,
        "question": "Find the count of lawn mowers with a noise level exceeding 75 decibels and mulching capability, grouped by power source.",
        "query": "SELECT l.Power_Source, COUNT(*) AS Machine_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE p.Noise_Level > 75 AND p.Mulching_Capability = 1 GROUP BY l.Power_Source;",
        "step": "【step1】: Join the 'lawn_mowers' and 'performance_metrics' tables using Mower_ID to link relevant performance data to each mower.  【step2】: Filter records where Noise_Level exceeds 75 dB and Mulching_Capability equals 1 (indicating supported functionality).  【step3】: Group results by Power_Source and count the number of qualifying machines per group.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 721,
        "question": "Assuming a lawn mower has an acceleration reaching 1000 m/s², a self-weight of 200 kg, and blades weighing 50 kg, calculate whether the inertial force of the blades during an emergency stop exceeds the yield strength of titanium alloy (880 MPa), given the cross-sectional area of the blades is 5 cm². Present the count of cases grouped by acceleration ranges and safety status.",
        "query": "SELECT CASE WHEN p.Acceleration <= 500 THEN '0-500 m/s²' WHEN p.Acceleration <= 1000 THEN '501-1000 m/s²' ELSE '>1000 m/s²' END AS Acceleration_Range, CASE WHEN (l.Blade_Weight * p.Acceleration) / (5 * 0.0001) > 880000000 THEN 'Exceeded' ELSE 'Safe' END AS Strength_Status, COUNT(*) AS Case_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID GROUP BY Acceleration_Range, Strength_Status;",
        "step": "【step1】: Join lawn_mowers and performance_metrics tables using Mower_ID to access Blade_Weight and Acceleration data.  【step2】: Calculate acceleration ranges (0-500/501-1000/>1000 m/s²) and determine Strength_Status by comparing (Blade_Weight * Acceleration)/(5*0.0001) with 880 MPa threshold.  【step3】: Group results by Acceleration_Range and Strength_Status, then count cases in each group.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 722,
        "question": "Calculate the kinetic energy of electric or battery-powered lawn mowers and filter out the models where the kinetic energy exceeds 1000 joules but the energy efficiency is below 80%.",
        "query": "SELECT lm.Mower_ID, lm.Model, 0.5 * lm.Blade_Weight * POW((lm.Blade_Length/100 * PI() * pm.Blade_Speed/60), 2) AS Kinetic_Energy FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND 0.5 * lm.Blade_Weight * POW((lm.Blade_Length/100 * PI() * pm.Blade_Speed/60), 2) > 1000 AND pm.Energy_Efficiency < 80;",
        "step": "【step1】: Join lawn_mowers and performance_metrics tables on Mower_ID, filter by electric/battery power sources  【step2】: Calculate kinetic energy using formula 0.5*Blade_Weight*(blade tip speed)^2 (converting Blade_Length to meters and Blade_Speed to RPS)  【step3】: Apply final filters for kinetic energy >1000 Joules AND energy_efficiency <80%",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 723,
        "question": "Find models with a total energy output over the battery's lifecycle that exceeds the total energy output of a gasoline engine over 10 years, comparing the energy conversion efficiency between electric and gasoline models.",
        "query": "SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ((pm.Battery_Life * lm.Battery_Capacity * lm.Run_Time / 60 * 48 / 1000) * (pm.Energy_Efficiency / 100) > (SELECT MAX(pm_gas.Fuel_Consumption * 10 * 200 * 34.2 * 0.3) FROM performance_metrics pm_gas JOIN lawn_mowers lm_gas ON pm_gas.Mower_ID = lm_gas.Mower_ID WHERE lm_gas.Power_Source = 'Gasoline'));",
        "step": "【step1】: Filter electric/battery models and join with performance data to access battery metrics.  【step2】: Calculate electric models' total energy output: (Battery_Life × Battery_Capacity × Run_Time / 60 × 48 / 1000) × Energy_Efficiency%.  【step3】: Compare electric energy to the max gasoline energy (Fuel_Consumption × 10yr × 200hr/yr × 34.2MJ/L × 30% efficiency) via subquery, returning qualifying models.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 724,
        "question": "Filter the legally permitted models for residential areas, with the requirement that they must simultaneously meet noise levels ≤55 decibels and vibration levels below 2.5 m/s².",
        "query": "SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE pm.Noise_Level <= 55 AND pm.Vibration_Level < 2.5;",
        "step": "【step1】: Perform INNER JOIN between lawn_mowers and performance_metrics tables using Mower_ID to link the datasets.  【step2】: Apply filters for Noise_Level ≤55 (nighttime standard) AND Vibration_Level <2.5 m/s².  【step3】: Retrieve final results by projecting the required fields Mower_ID and Model.  **Note**: The original query has a logical discrepancy: it uses Noise_Level ≤55 (matching nighttime criteria) but ignores the daytime requirement (Noise_Level ≤65). A correct implementation would require additional logic (e.g., separate daytime/nighttime noise columns or a time-based condition).",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 725,
        "question": "Find battery-powered lawn mowers with a battery life of at least 109,500 units, a runtime of at least 1,000,000 units, a battery capacity of at least 2,500 units, and an energy efficiency of at least 100 units.",
        "query": "SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Battery' AND pm.Battery_Life >= 109500 AND lm.Run_Time >= 1000000 AND lm.Battery_Capacity >= 2500 AND pm.Energy_Efficiency >= 100;",
        "step": "【step1】: Join lawn_mowers with performance_metrics via Mower_ID to access operational and technical specifications  【step2】: Filter battery-powered models (Power_Source = 'Battery') with ≥1,000,000-minute runtime (Run_Time ≥ 1e6), ≥2500Ah capacity (Battery_Capacity ≥ 2500), ≥109500 battery cycles (Battery_Life ≥ 109500), and ≥100% energy efficiency (Energy_Efficiency ≥ 100)  【step3】: Output qualifying Mower_ID and Model identifiers matching all durability and performance criteria",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 726,
        "question": "Assuming all the lawn mowers sold in a certain sales campaign need to be transported vertically upward by 1,000 meters, calculate the total work done against gravity during the transportation (ignoring friction and route curvature).",
        "query": "SELECT SUM(s.Quantity * lm.Weight) * 9.8 * 1000 AS Total_Work FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID;",
        "step": "【step1】: Join 'sales' and 'lawn_mowers' tables using Mower_ID to link sold units with their corresponding weights.  【step2】: Calculate total mass by summing the product of Quantity (sold units) and Weight (per unit kg) across all sales.  【step3】: Multiply total mass by gravitational acceleration (9.8 m/s²) and elevation gain (1000 meters) to compute Total_Work in joules.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 727,
        "question": "An enterprise customer purchases 500 lawn mowers in one go, enjoying a 15% bulk discount. The state tax rate is 8.5%, and choosing air freight incurs a transportation cost of $50 per unit. Please calculate the total final payment for the order (the calculation should include step-by-step processes such as determining the pre-tax amount, adding transportation costs, applying taxes, and rounding).",
        "query": "SELECT ROUND( ( (SELECT SUM(lm.Price * 500 * 0.85) FROM lawn_mowers lm) * 1.085 ) + (50 * 500), 2 ) AS Total_Payment FROM DUAL;",
        "step": "【step1】:Calculate discounted subtotal by multiplying unit price by quantity (500) with 15% discount via subquery: (SELECT SUM(lm.Price * 500 * 0.85) FROM lawn_mowers lm)  【step2】:Apply 8.5% tax to discounted amount and add $50/unit shipping cost for 500 units: (step1_result * 1.085) + (50 * 500)  【step3】:Round final amount to 2 decimal places using ROUND() function and display as Total_Payment",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 728,
        "question": "A customer purchases 3 lawn mowers priced at $500 each, enjoys a 10% promotional discount, with a local sales tax rate of 6%. What is the total amount the customer should actually pay after these adjustments?",
        "query": "SELECT ROUND( (500 * 3 * 0.9 * 1.06), 2 ) AS Actual_Payment FROM DUAL;",
        "step": "【step1】: Calculate base amount: 3 units * $500 = $1500  【step2】: Apply 10% discount: $1500 * 0.9 = $1350  【step3】: Add 6% tax and round: ROUND($1350 * 1.06, 2) = $1431.00",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 729,
        "question": "Assuming a transaction involves selling 1,000,000 units with a discount rate of 120%, a tax rate of 250%, and a shipping cost of $0.01 per unit. Calculate the theoretically generated Total_Price by the system (negative values are allowed), using the price of the first lawn mower from the lawn_mowers table.",
        "query": "SELECT ( ( (SELECT lm.Price FROM lawn_mowers lm LIMIT 1) * 1000000 * (1 - 120/100) ) * (1 + 250/100) ) + (0.01 * 1000000) AS Theoretical_Total_Price FROM DUAL;",
        "step": "【step1】: Retrieve base price value from lawn_mowers table using subquery (SELECT lm.Price ... LIMIT 1)  【step2】: Calculate discounted subtotal: (price × 1,000,000) × (1 - 120/100) = negative base amount  【step3】: Apply tax multiplier (1 + 250/100) = 3.5× and add $10,000 transportation cost: (negative_base × 3.5) + 10,000",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 730,
        "question": "Please list the top 5 sales records with the highest total kinetic energy, where the kinetic energy calculation is based on the lawn mower blade length, blade weight, blade rotation speed, and quantity sold, and sort them in descending order by kinetic energy.",
        "query": "SELECT s.Sale_ID, 0.5 * 0.5 * lm.Blade_Weight * POWER((lm.Blade_Length/200),2) * POWER(2*PI()*pm.Blade_Speed/60,2) * s.Quantity AS Kinetic_Energy FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID ORDER BY Kinetic_Energy DESC LIMIT 5",
        "step": "【step1】: JOIN sales with lawn_mowers and performance_metrics using Mower_ID to access blade weight and speed data  【step2】: Calculate kinetic energy using formula: 0.5 * 0.5 * Blade_Weight * (Blade_Length/200)^2 * (2π*Blade_Speed/60)^2 * Quantity  【step3】: Sort results by calculated kinetic energy in descending order and limit to top 5 records",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 731,
        "question": "Calculate the total payment amount for each customer (taking into account discounts, taxes, shipping costs) and list the top 10 customers with the highest total payment amounts.",
        "query": "SELECT Customer_ID, SUM( (Sale_Price * Quantity * (1 - Discount/100) * (1 + Tax_Rate/100)) + Shipping_Cost ) AS Total_Payment FROM sales GROUP BY Customer_ID ORDER BY Total_Payment DESC LIMIT 10",
        "step": "【step1】: Calculate individual payment per sale record with formula: (Sale_Price * Quantity * (1 - Discount/100) * (1 + Tax_Rate/100)) + Shipping_Cost  【step2】: Aggregate total payments by Customer_ID using GROUP BY and SUM() function  【step3】: Order results in descending order of Total_Payment and select top 10 records using LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 732,
        "question": "Find the top 3 best-selling lawn mower models and verify whether their prices are below 80% of their manufacturer's average price.",
        "query": "WITH Manufacturer_Avg AS ( SELECT Manufacturer_ID, AVG(Price) * 0.8 AS Threshold FROM lawn_mowers GROUP BY Manufacturer_ID ) SELECT lm.Model, SUM(s.Quantity) AS Total_Sales, CASE WHEN lm.Price < ma.Threshold THEN '符合' ELSE '不符合' END AS Price_Status FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN Manufacturer_Avg ma ON lm.Manufacturer_ID = ma.Manufacturer_ID GROUP BY lm.Model, lm.Price, ma.Threshold ORDER BY Total_Sales DESC LIMIT 3",
        "step": "【step1】: Calculate manufacturer-specific 80% average price thresholds using a CTE (Common Table Expression) grouped by Manufacturer_ID from lawn_mowers table.  【step2】: Join sales data with lawn_mowers and calculated thresholds, aggregate total sales quantities per model.  【step3】: Compare each model's price to its manufacturer threshold, sort by total sales descending, and limit to top 3 results while applying price validation logic.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 733,
        "question": "Assuming the purchase quantity of all sales records increases by 10,000 times and the shipping cost grows proportionally, find the top 5 sales records where the scaled shipping cost (shipping cost multiplied by 10,000) exceeds the manufacturer's market cap.",
        "query": "SELECT s.Sale_ID, s.Shipping_Cost * 10000 AS Scaled_Shipping, m.Market_Cap FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers m ON lm.Manufacturer_ID = m.Manufacturer_ID WHERE s.Shipping_Cost * 10000 > m.Market_Cap ORDER BY Scaled_Shipping DESC LIMIT 5",
        "step": "【step1】: Join 'sales' with 'lawn_mowers' via Mower_ID, then link to 'manufacturers' via Manufacturer_ID to access market cap data.  【step2】: Filter records where scaled shipping cost (original ×10000) exceeds the manufacturer's market cap.  【step3】: Sort results by scaled shipping cost in descending order and return the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 734,
        "question": "Calculate the work in joules required to lift the total weight of lawn mowers purchased by each customer vertically by 1 meter (grouped by customer).",
        "query": "SELECT s.Customer_ID, SUM(s.Quantity * lm.Weight) * 9.8 * 1 AS Work_Joules FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID GROUP BY s.Customer_ID",
        "step": "【step1】: Join 'sales' with 'lawn_mowers' using Mower_ID to link product quantities with their weights  【step2】: Calculate total weight per customer by multiplying Quantity and Weight, then sum the results grouped by Customer_ID  【step3】: Compute vertical lifting work using formula (total_weight * 9.8 * 1) and alias as Work_Joules in the final output",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 735,
        "question": "Calculate the gross profit margin for each payment method (grouped by payment method).",
        "query": "SELECT Payment_Method, (SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) - SUM(sale_price * quantity * 0.6)) / SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) * 100 AS Gross_Profit_Margin FROM sales GROUP BY Payment_Method",
        "step": "【step1】: Calculate the total revenue and total cost for each sale record. Revenue is computed as sale_price * quantity adjusted by discount and tax_rate, while cost is 60% of sale_price * quantity.  【step2】: Aggregate the summed revenue and cost by Payment_Method using GROUP BY.  【step3】: Compute the gross profit margin for each group using the formula: (Total_Revenue - Total_Cost) / Total_Revenue * 100.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 736,
        "question": "Identify irrational transactions (grouped by customer) where shipping costs exceed 10% of the sale price multiplied by quantity",
        "query": "SELECT Customer_ID, COUNT(Sale_ID) AS Abnormal_Transactions FROM sales WHERE shipping_cost > (sale_price * quantity * 0.1) GROUP BY Customer_ID",
        "step": "【step1】: Filter transactions where shipping cost exceeds 10% of total machine price (sale_price × quantity × 0.1) using WHERE clause  【step2】: Group filtered results by Customer_ID to aggregate abnormal transactions per client  【step3】: Count the number of abnormal transactions per customer using COUNT(Sale_ID) with GROUP BY",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 737,
        "question": "Assuming the enterprise customer's purchase quantity reaches the maximum value representable by a 32-bit signed integer (2147483647), verify whether the system can correctly calculate the total sale price including tax for business customers.",
        "query": "SELECT Sale_Price * 2147483647 * (1 + Tax_Rate/100) AS Total_Price_Validation FROM sales WHERE Customer_ID IN (SELECT Customer_ID FROM customers WHERE Customer_Type = 'Business') LIMIT 1",
        "step": "【step1】: Execute subquery to retrieve Business customer IDs: `SELECT Customer_ID FROM customers WHERE Customer_Type = 'Business'`  【step2】: Filter sales records for Business customers using IN clause and multiply Sale_Price by INT max (2147483647)  【step3】: Calculate tax-inclusive total price with `(1 + Tax_Rate/100)` and return one validation result via LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 738,
        "question": "Find all sales records of gasoline-powered lawn mowers where the total energy output (calculated from engine power over runtime) is greater than or equal to 1000 joules, and these lawn mowers do not have vibration levels exceeding 5 m/s² recorded in the performance metrics table.",
        "query": "SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND (lm.Engine_Power * 745.7) * (lm.Run_Time * 60) >= 1000 AND NOT EXISTS (SELECT 1 FROM performance_metrics pm WHERE pm.Mower_ID = lm.Mower_ID AND pm.Vibration_Level > 5);",
        "step": "【step1】: Join sales and lawn_mowers tables to filter gasoline-powered mowers. Use INNER JOIN on Mower_ID and apply Power_Source='Gasoline' condition.  【step2】: Calculate kinetic energy using (Engine_Power*745.7)*(Run_Time*60) to convert HP/minutes to joules. Apply >=1000 condition.  【step3】: Filter results with NOT EXISTS subquery against performance_metrics, ensuring no linked mower has Vibration_Level >5. Correlate via pm.Mower_ID=lm.Mower_ID.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 739,
        "question": "Calculate the maintenance cost ratio (maintenance cost divided by total sales price) for each business customer with annual purchase volume exceeding $50,000, considering only maintenance performed during the warranty period, and filter out customers with a ratio below 15%.",
        "query": "SELECT c.Customer_ID, (SUM(m.Cost)/SUM(s.Total_Price))*100 AS maintenance_percentage FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN maintenance m ON s.Mower_ID = m.Mower_ID WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume > 50000 AND m.Maintenance_Date BETWEEN s.Sale_Date AND DATE_ADD(s.Sale_Date, INTERVAL s.Warranty_Period MONTH) GROUP BY c.Customer_ID HAVING maintenance_percentage < 15;",
        "step": "【step1】: Join customers, sales, and maintenance tables to filter business customers with annual purchase over $50,000 and maintenance within warranty period  【step2】: Calculate maintenance cost percentage per customer by dividing total maintenance costs by total sales price and multiplying by 100  【step3】: Group results by Customer_ID and filter groups where maintenance_percentage < 15 using HAVING clause",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 740,
        "question": "Filter all sales records of manually powered lawn mowers with blade angles greater than 35 degrees and mechanical grass-cutting height adjustment mechanisms, but only for orders where customer addresses are located in Seattle.",
        "query": "SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE lm.Power_Source = 'Manual' AND lm.Blade_Angle > 35 AND lm.Cutting_Height_Adjustment = 'Mechanical' AND c.City = 'Seattle';",
        "step": "【step1】: Join `sales` with `lawn_mowers` to filter manual-powered mowers with blade angle >35° and mechanical height adjustment.  【step2】: Join the result with `customers` to restrict records where the customer's city is 'Seattle'.  【step3】: Select all fields from the joined dataset to retrieve the final filtered sales records.",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 741,
        "question": "Identify extreme anomalous transaction records where the sales quantity exceeds 500% of the manufacturer's total production volume, and the shipping cost is lower than 0.1% of the product price.",
        "query": "SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers mf ON lm.Manufacturer_ID = mf.Manufacturer_ID WHERE s.Quantity > mf.Production_Volume_Total *5 AND s.Shipping_Cost < lm.Price *0.001;",
        "step": "【step1】: Join sales with lawn_mowers and manufacturers through Mower_ID and Manufacturer_ID to link product specifications and production data  【step2】: Apply condition s.Quantity > mf.Production_Volume_Total*5 to find orders exceeding 500% of total production  【step3】: Add filter s.Shipping_Cost < lm.Price*0.001 to identify abnormally low shipping costs relative to product price",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "1",
        "idx": 742,
        "question": "Assuming an electric lawn mower has a battery capacity of 10Ah, an energy efficiency of 85%, a blade speed of 3000 RPM, a torque of 15 Nm, and the user needs to work continuously for 3 hours, how many batteries of the same specifications are required?",
        "query": "SELECT CEIL( (pm.Torque * pm.Blade_Speed * 3) / ((pm.Energy_Efficiency / 100) * 9549) / (lm.Battery_Capacity * 12) ) AS Batteries_Needed FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 10 AND pm.Energy_Efficiency = 85 AND pm.Blade_Speed = 3000 AND pm.Torque = 15;",
        "step": "【step1】: Join lawn_mowers and performance_metrics tables using Mower_ID to access battery capacity and energy efficiency parameters  【step2】: Calculate total energy consumption for 3 hours using formula (Torque × Blade_Speed × 3) / (Energy_Efficiency% × 9549)  【step3】: Divide total energy by single battery output (Battery_Capacity × 12V) then apply CEIL() to round up to integer battery count",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "2",
        "idx": 743,
        "question": "Compute the average profit margin for lawn mowers produced by each manufacturer in 2023, including only manufacturers whose R&D expenditure accounts for more than 5% of total revenue and counting only companies with annual revenues exceeding $100 million.",
        "query": "SELECT m.Manufacturer_ID, m.Name, SUM(s.Total_Price * (m.Profit_Margin / 100)) / SUM(s.Total_Price) AS Avg_Profit_Margin FROM manufacturers m JOIN lawn_mowers lm ON m.Manufacturer_ID = lm.Manufacturer_ID JOIN sales s ON lm.Mower_ID = s.Mower_ID WHERE m.`R&D_Spending`/ m.Revenue > 0.05 AND m.Revenue > 100000000 AND YEAR(s.Sale_Date) = 2023 GROUP BY m.Manufacturer_ID, m.Name;",
        "step": "【step1】: Filter manufacturers with R&D spending over 5% of revenue and annual revenue exceeding $100M  【step2】: Join with lawn_mowers and sales tables, filtering sales records from 2023  【step3】: Calculate weighted average profit margin using (Total_Price × Profit_Margin%) / Total_Price aggregates grouped by manufacturer",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "3",
        "idx": 744,
        "question": "A gasoline-powered weed trimmer is labeled with a fuel consumption rate of 1.5L/hour. The user operates it 4 times a week, for 2 hours each time. Based on the current gasoline price (1.2 USD/L), is it possible for the quarterly (13 weeks) fuel cost to exceed 200 USD?",
        "query": "SELECT CASE WHEN (1.5 * 2 * 4 * 13 * 1.2) > 200 THEN 'Yes' ELSE 'No' END AS Exceeds_200;",
        "step": "【step1】: Calculate total fuel consumption per quarter: 1.5L/hour * 2 hours/use * 4 uses/week * 13 weeks = 156L  【step2】: Compute fuel cost: 156L * $1.2/L = $187.2, then compare with $200 threshold  【step3】: Apply CASE statement to return boolean result: 'Yes' when $187.2 > $200, 'No' otherwise",
        "format": "MySQL"
    },
    {
        "db_id": "lawnmower",
        "type": "4",
        "idx": 745,
        "question": "If a lawn mower weighs 1000 kg and has wheels of only 2 inches in size, when operating on a slope with a handling capability of at least 30 degrees, does the ground pressure it exerts exceed the standard load-bearing capacity of building foundations (typically ≥200 kPa)?",
        "query": "SELECT CASE WHEN (lm.Weight * 9.8) / (4 * PI() * POWER((lm.Wheel_Size * 0.0254 / 2), 2)) > 200000 THEN 'Yes' ELSE 'No' END AS Exceeds_Pressure FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight = 1000 AND lm.Wheel_Size = 2 AND pm.Slope_Handling >= 30;",
        "step": "【step1】: Filter lawn_mowers where Weight=1000kg and Wheel_Size=2 inches, then JOIN with performance_metrics requiring Slope_Handling ≥30 degrees  【step2】: Calculate contact area using wheel radius (Wheel_Size converted from inches to meters, divided by 2) and formula 4×π×r²  【step3】: Compute pressure via (Weight×9.8)/contact_area, compare against 200kPa threshold (200000 Pa) using CASE statement to return 'Yes'/'No'",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 746,
        "question": "Calculate the total energy efficiency ((total movement distance × weight)/(total energy/1000)) for each wireless mouse model, and return the models with efficiency <5 meters/kJ and weight >100g.",
        "query": "SELECT m.Model FROM mice m JOIN (SELECT Mouse_ID, SUM(Distance_Moved_Meters) AS total_dist, SUM(Energy_Consumed_Joules) AS total_energy FROM usage_records GROUP BY Mouse_ID) u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND (u.total_dist * m.Weight_Grams)/(u.total_energy/1000) < 5 AND m.Weight_Grams > 100;",
        "step": "【step1】: Aggregate usage_records to calculate total distance moved and total energy consumed per mouse, grouped by Mouse_ID.  【step2】: Join mice table with aggregated usage data to access wireless status and weight, then compute energy efficiency using formula (total_dist * Weight_Grams)/(total_energy/1000).  【step3】: Filter results to include only wireless mice where efficiency < 5 and weight > 100g, returning qualifying models.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 747,
        "question": "Identify sensors with frequent calibrations (interval between adjacent calibrations < 30 days) occurring more than 5 times, and return the mouse model and manufacturer market share for these sensors.",
        "query": "WITH CalibrationData AS (SELECT Sensor_Id, Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date FROM sensor_data) SELECT m.Model, ma.Market_Share_Percent FROM CalibrationData cd JOIN sensor_data sd ON cd.Sensor_Id = sd.Sensor_Id JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE DATEDIFF(cd.Last_Calibration_Date, cd.prev_date) < 30 GROUP BY m.Model, ma.Market_Share_Percent HAVING COUNT(*) > 5;",
        "step": "【step1】: Use window function LAG to calculate previous calibration date for each sensor's calibration records.  【step2】: Filter records with adjacent calibration intervals <30 days, then join sensor_data, mice, and manufacturers tables to retrieve model and market share.  【step3】: Group by model and market share, apply HAVING COUNT(*) >5 to identify sensors exceeding the high-frequency calibration threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 748,
        "question": "Find records with maximum DPI > 16,000 and duration of use > 120 minutes, return user ID and mouse weight",
        "query": "SELECT u.User_ID, m.Weight_Grams FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id WHERE u.Max_Dpi > 16000 AND u.Usage_Duration_Minutes > 120;",
        "step": "【step1】: Filter usage_records where Max_Dpi > 16000 AND Usage_Duration_Minutes > 120  【step2】: Join filtered usage_records with mice table via Mouse_ID  【step3】: Select User_ID and Weight_Grams from the joined result",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 749,
        "question": "Assuming the G502 HERO (with an acceleration of 40G) is used on the surface of Jupiter (gravity 24.79 m/s²), calculate the theoretical clicking force (coefficient of friction μ=0.62).",
        "query": "SELECT 0.62 * (Weight_Grams/1000) * (24.79 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'G502 HERO';",
        "step": "【step1】: Filter the 'mice' table to retrieve the G502 HERO model's Weight_Grams and Acceleration_G values.  【step2】: Calculate Force_Newtons using the formula 0.62 * (Weight_Grams/1000) * (24.79 + (Acceleration_G * 9.81)), incorporating unit conversions (grams to kg, G-force to m/s²).  【step3】: Return the computed force value as a single-column result (no joins/nested queries required for this direct calculation).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 750,
        "question": "Calculate the energy efficiency attenuation rate ((normal efficiency - extreme efficiency) / normal efficiency × 100%) for each wireless mouse in extreme usage scenarios (acceleration >50G), and return models with an attenuation rate >30% and weight >100g. Formula: The normal efficiency is the average value of records with acceleration <10G.",
        "query": "WITH EfficiencyData AS (SELECT m.Mouse_Id, m.Model, m.Weight_Grams, AVG((u.Distance_Moved_Meters * m.Weight_Grams)/(u.Energy_Consumed_Joules/1000)) AS normal_efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND m.Acceleration_G < 10 GROUP BY m.Mouse_Id, m.Model, m.Weight_Grams), ExtremeEfficiency AS (SELECT m.Mouse_Id, (u.Distance_Moved_Meters * m.Weight_Grams)/(u.Energy_Consumed_Joules/1000) AS extreme_efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND m.Acceleration_G > 50) SELECT e.Model FROM EfficiencyData e JOIN ExtremeEfficiency ex ON e.Mouse_Id = ex.Mouse_Id WHERE (e.normal_efficiency - ex.extreme_efficiency) / e.normal_efficiency * 100 > 30 AND e.Weight_Grams > 100;",
        "step": "【step1】: Compute normal efficiency for each wireless mouse under low acceleration (Acceleration_G < 10G) by joining mice and usage_records, grouping by Mouse_Id and calculating AVG((Distance_Moved_Meters * Weight_Grams)/(Energy_Consumed_Joules/1000)).  【step2】: Extract extreme efficiency values for each mouse under high acceleration (Acceleration_G > 50G) by joining mice and usage_records, computing (Distance_Moved_Meters * Weight_Grams)/(Energy_Consumed_Joules/1000) per record.  【step3】: Join normal and extreme efficiency data, calculate efficiency decay rate ((normal_efficiency - extreme_efficiency)/normal_efficiency * 100), then filter results where decay rate > 30% and Weight_Grams > 100.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 751,
        "question": "Identify users exhibiting 'abnormal click patterns' (click frequency > 600 clicks per hour sustained for over 5 minutes), return the IDs of these users along with their mouse models. Window functions must be used to calculate cumulative clicks and duration per user and mouse.",
        "query": "WITH ClickFrequency AS (SELECT User_ID, Mouse_ID, Clicks, Usage_Duration_Minutes, Clicks / (Usage_Duration_Minutes / 60) AS click_freq, SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_clicks, SUM(Usage_Duration_Minutes) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_duration FROM usage_records) SELECT DISTINCT cf.User_ID, m.Model FROM ClickFrequency cf JOIN mice m ON cf.Mouse_ID = m.Mouse_Id WHERE cf.click_freq > 600 AND cf.total_duration > 5;",
        "step": "【step1】: [Create CTE with window functions] Calculate cumulative clicks and duration per user/mouse using SUM() OVER() ordered by start time, partitioning by User_ID and Mouse_ID  【step2】: [Filter abnormal patterns] Select records where click frequency exceeds 600 clicks/min (10/sec) AND total accumulated duration exceeds 5 minutes  【step3】: [Join and deduplicate] Link mouse table to retrieve model information and apply DISTINCT on user-model pairs",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 752,
        "question": "Find records where the sensor has a calibration interval of less than 7 days and is part of a mouse with high energy consumption (over 45 Joules per hour) and a CMOS sensor type. Return the mouse models and manufacturer profits for these records.",
        "query": "WITH CalibrationIntervals AS (SELECT Sensor_Id, Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date FROM sensor_data) SELECT m.Model, ma.Profit_Usd FROM CalibrationIntervals ci JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE DATEDIFF(ci.Last_Calibration_Date, ci.prev_date) < 7;",
        "step": "【step1】: Calculate calibration intervals using LAG window function to get previous calibration date per sensor.  【step2】: Join sensor_data, mice, and manufacturers tables to link sensors with mouse models and manufacturer profits.  【step3】: Filter records where calibration interval <7 days and return mouse model with corresponding profit.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 753,
        "question": "Assuming the use of DeathAdder V2 (acceleration 50G), calculate the theoretical click force in Newtons using the formula: F = μ × m × (g + a), where μ=0.0001, g=274 m/s², and a=50G.",
        "query": "SELECT 0.0001 * (Weight_Grams/1000) * (274 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'DeathAdder V2';",
        "step": "【step1】: Filter the 'mice' table to retrieve the DeathAdder V2's Weight_Grams and Acceleration_G using WHERE Model = 'DeathAdder V2'  【step2】: Convert units: Divide Weight_Grams by 1000 to get kilograms, multiply Acceleration_G by 9.81 to convert G to m/s²  【step3】: Calculate force using formula 0.0001 × (mass_kg) × (274 + acceleration_mss) with derived values from step2",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 754,
        "question": "Calculate the dynamic energy efficiency (effective movement energy/total energy consumption) of each wireless mouse during high-speed movement (Tracking_Speed_Ips > 400), returning the models with efficiency <60% and polling rate >1000Hz. Formula: effective energy = Distance_Moved_Meters × Weight_Grams × 9.8, total energy consumption = Energy_Consumed_Joules.",
        "query": "SELECT m.Model FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Tracking_Speed_Ips > 400 AND m.Polling_Rate_Hz > 1000 AND (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules * 100 < 60;",
        "step": "【step1】: Filter mice with Tracking_Speed_Ips > 400 and Polling_Rate_Hz > 1000 from the 'mice' table.  【step2】: Join with 'usage_records' using Mouse_Id to access movement and energy consumption data.  【step3】: Calculate dynamic energy efficiency using (Distance_Moved_Meters × Weight_Grams × 9.8 / Energy_Consumed_Joules × 100) and filter results with efficiency < 60%. Return qualifying models.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 755,
        "question": "Identify users exhibiting the 'instant high-frequency click' pattern (peaking at over 1200 clicks per minute and lasting for 3 consecutive cycles), returning their user IDs and mouse acceleration. Use window functions to calculate the sliding window click frequency.",
        "query": "WITH ClickFrequency AS (SELECT User_ID, Mouse_ID, Start_Time, Clicks, SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) / 5 AS window_freq FROM usage_records), ConsecutiveHighFreq AS (SELECT User_ID, Mouse_ID, window_freq, LAG(window_freq, 1) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq1, LAG(window_freq, 2) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq2 FROM ClickFrequency WHERE window_freq > 1200) SELECT DISTINCT chf.User_ID, m.Acceleration_G FROM ConsecutiveHighFreq chf JOIN mice m ON chf.Mouse_ID = m.Mouse_Id WHERE chf.window_freq > 1200 AND chf.prev_freq1 > 1200 AND chf.prev_freq2 > 1200;",
        "step": "【step1】: Calculate sliding window click frequency using window function (5-minute window averages) partitioned by user and mouse.  【step2】: Identify consecutive high-frequency periods by checking previous two window frequencies through LAG() functions.  【step3】: Join with mice table to retrieve acceleration and filter records with 3 consecutive qualifying periods.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 756,
        "question": "Find mice with lift-off distance <1.5mm and DPI >18000 (common sense: low lift-off distance + high DPI can easily cause cursor jitter), and return the model along with the manufacturer's founding year. Based on the cursor stability requirements of ISO 9241-411 standard.",
        "query": "SELECT m.Model, ma.Founded_year FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE sd.Lift_Off_Distance_Mm < 1.5 AND sd.Max_Dpi > 18000;",
        "step": "【step1】: Filter sensor_data records where Lift_Off_Distance_Mm < 1.5 AND Max_Dpi > 18000  【step2】: Join filtered sensor_data with mice table via Mouse_Id to get manufacturer relationships  【step3】: Join result with manufacturers via Manufacturer_Id to retrieve Founded_year, then select Model and Founded_year",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 757,
        "question": "Assuming the Dark Core RGB Pro is used at the Mercury terminator (diurnal temperature variation ±300°C, gravity 0.38g), calculate the sensor's precision error under extreme thermal expansion and contraction (assuming material thermal expansion coefficient α=2.3e-5/°C, Δt=600°C). Formula: ΔL=α×L0×Δt, precision error=ΔL/(Sensor_Area)^0.5×100%.",
        "query": "SELECT (2.3e-5 * 10 * 600) / SQRT(10 * 5) * 100 AS precision_error FROM mice WHERE Model = 'Dark Core RGB Pro';",
        "step": "【step1】: Filter the mice table where Model = 'Dark Core RGB Pro' to retrieve the target device's base parameters  【step2】: Compute ΔL = α × L0 × Δt (using hardcoded L0=10cm implied by Sensor_Area=10*5)  【step3】: Calculate final precision error by dividing ΔL by sqrt(Sensor_Area) and scaling to percentage",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 758,
        "question": "Calculate the effective mechanical power (effective work/time) for each mouse under dynamic acceleration, returning models with power >10W and an efficiency ratio <40%. Formula: Effective work = Distance_Moved × Weight × a_avg (average acceleration), a_avg = Δv/Δt, Δv = Tracking_Speed × Distance_Moved/1000, and efficiency ratio = (effective work / energy consumed) × 100.",
        "query": "SELECT m.Model FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE ( (u.Distance_Moved_Meters * m.Weight_Grams * POWER((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Distance_Moved_Meters / 1000) ) / (u.Usage_Duration_Minutes * 60) > 10 AND (u.Distance_Moved_Meters * m.Weight_Grams * POWER((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Energy_Consumed_Joules * 1000) * 100 < 40;",
        "step": "【step1】: Join mice and usage_records tables via Mouse_Id to access technical specifications and usage data.  【step2】: Calculate mechanical power using (Distance_Moved × Weight × (Tracking_Speed² × 0.0254²) × 1000) / (Usage_Duration × 60) and efficiency ratio via (Effective_Work / (Energy_Consumed × 1000)) × 100.  【step3】: Apply filters to select models where mechanical power > 10W and efficiency ratio < 40%.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 759,
        "question": "Identify users exhibiting 'quantized clicking' anomalies where the click count follows a 2^n distribution, return their user IDs and mouse polling rates.",
        "query": "WITH ClickPatterns AS (SELECT User_ID, Mouse_ID, Clicks, (LOG2(Clicks)) AS log2_clicks FROM usage_records WHERE Clicks > 0 AND MOD(LOG2(Clicks), 1) = 0) SELECT cp.User_ID, m.Polling_Rate_Hz FROM ClickPatterns cp JOIN mice m ON cp.Mouse_ID = m.Mouse_Id;",
        "step": "【step1】: [Filter usage_records for quantum click patterns] Calculate LOG2(Clicks) and filter records where clicks are positive powers of two (Clicks > 0 AND MOD(LOG2(Clicks), 1) = 0), creating CTE ClickPatterns with User_ID, Mouse_ID, and log2_clicks.  【step2】: [Join with mice table] Link filtered ClickPatterns to mice table via Mouse_ID to retrieve corresponding Polling_Rate_Hz values.  【step3】: [Missing FFT analysis] The original query lacks implementation of time interval standard deviation (<0.1s) and FFT-based frequency analysis, which would require additional window functions/signal processing extensions not present in standard SQL.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 760,
        "question": "Find records where the weight is greater than 150 grams and the weekly usage is greater than 8 hours per day on average, returning the user ID and the manufacturer's market share percent.",
        "query": "SELECT u.User_ID, ma.Market_Share_Percent FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE m.Weight_Grams > 150 AND (u.Usage_Duration_Minutes / 60) / 7 > 8;",
        "step": "【step1】: Join usage_records with mice table via Mouse_ID and manufacturers table via Manufacturer_Id to establish relationships between usage data, product specs, and manufacturer info.  【step2】: Filter records with mice weighing >150g (m.Weight_Grams > 150) and daily average usage >8 hours using ((u.Usage_Duration_Minutes/60)/7 > 8) to apply ergonomic risk thresholds.  【step3】: Select target fields User_ID and Market_Share_Percent from the joined dataset to identify at-risk users and quantify manufacturer exposure in high-risk usage cases.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 761,
        "question": "Assuming the use of a wireless mouse on the surface of a neutron star (gravity 1e12g, temperature 1e8K), calculate the energy required to maintain a 1mm displacement (assuming the friction coefficient μ = ħ/(2m√(2mΦ)) due to quantum tunneling effects, with Φ = 1eV potential barrier). Formula: E = μ × m × g_neutron × d × 1e-3.",
        "query": "SELECT (6.626e-34 / (2 * (Weight_Grams/1000) * SQRT(2 * (Weight_Grams/1000) * 1.6e-19))) * (Weight_Grams/1000) * 9.8e12 * 0.001 AS Energy_Joules FROM mice WHERE Is_Wireless = 1;",
        "step": "【step1】: Filter wireless mice records using WHERE Is_Wireless = 1  【step2】: Convert Weight_Grams to kilograms (divide by 1000) and calculate μ using the quantum tunneling formula:  μ = 6.626e-34 / (2 * kg_weight * SQRT(2 * kg_weight * 1.6e-19))  【step3】: Multiply μ by kg_weight, neutron star gravity (9.8e12 m/s²), and displacement (0.001m) to compute Energy_Joules",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 762,
        "question": "Calculate the rate of momentum change (Δp/Δt) for each mouse during high-speed sudden stops (Acceleration_G > 80), and return the models with a change rate >1 kg·m/s². Formula: Δp = Weight_Grams/1000 × Tracking_Speed_Ips × 0.0254, Δt = 1/Polling_Rate_Hz.",
        "query": "SELECT m.Model FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Acceleration_G > 80 AND ( (m.Weight_Grams / 1000) * (m.Tracking_Speed_Ips * 0.0254) * m.Polling_Rate_Hz ) > 1;",
        "step": "【step1】: Filter mice with Acceleration_G >80  【step2】: Join sensor_data to enforce sensor linkage (though no sensor_data fields are used in calculations)  【step3】: Calculate Δp/Δt using formula and apply threshold (>1 kg·m/s²)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 763,
        "question": "Identify users where the proportion of consecutive clicks with no change exceeds 50%, returning their user IDs and associated mouse sensor lifespan.",
        "query": "WITH ClickSequences AS (SELECT User_ID, Mouse_ID, Start_Time, Clicks, LAG(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_clicks FROM usage_records), TransitionMatrix AS (SELECT User_ID, Mouse_ID, COUNT(*) AS total_transitions, SUM(CASE WHEN Clicks = prev_clicks THEN 1 ELSE 0 END) AS same_state_count FROM ClickSequences GROUP BY User_ID, Mouse_ID) SELECT tm.User_ID, sd.Sensor_Life_Hours FROM TransitionMatrix tm JOIN sensor_data sd ON tm.Mouse_ID = sd.Mouse_Id WHERE (same_state_count / total_transitions) > 0.5;",
        "step": "【step1】: Create ClickSequences CTE to capture user click sequences with lagged values using window functions (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time). This establishes temporal continuity for state transition analysis.  【step2】: Build TransitionMatrix CTE by calculating state persistence metrics - count same-state transitions (Clicks = prev_clicks) vs total transitions per user-device group. Filters implicit through conditional aggregation.  【step3】: Join TransitionMatrix with sensor_data using Mouse_ID, apply entropy threshold (>0.5 state persistence), and project final User_ID/Sensor_Life_Hours. Structural assumption: 6-period requirement is implicitly satisfied through continuous Start_Time ordering in Step1 windowing.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 764,
        "question": "Find records of wireless mice used in environments with excessive electromagnetic radiation (assuming the sensor_data has a new EMI_Level field >30dBμV/m) and with a calibration interval of less than 3 days, returning the model and the manufacturer's founding year. Based on FCC Part 15B electromagnetic compatibility standards.",
        "query": "WITH CalibrationIntervals AS (SELECT Sensor_Id, Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date FROM sensor_data) SELECT m.Model, ma.Founded_year FROM CalibrationIntervals ci JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE DATEDIFF(ci.Last_Calibration_Date, ci.prev_date) < 3;",
        "step": "【step1】: Use a CTE (CalibrationIntervals) with the LAG window function to calculate the previous calibration date (prev_date) for each sensor, partitioned by Sensor_Id and ordered by Last_Calibration_Date.  【step2】: Join CalibrationIntervals with sensor_data, mice, and manufacturers tables to link sensor calibration data to mouse models and their manufacturers.  【step3】: Filter results where the difference between consecutive calibration dates (Last_Calibration_Date and prev_date) is less than 3 days using DATEDIFF.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 765,
        "question": "Assuming the use of a wireless mouse with a photon propulsion force of 2 million newtons, calculate the required radiation pressure in pascals to maintain cursor movement, given surface albedo 0.8, laser wavelength 500nm, and formula: F= (2E/c)×(1+cosθ), E=P×t×A×R/λ.",
        "query": "SELECT (2 * 1e8 * 0.01) AS Photon_Force_N FROM mice WHERE Is_Wireless = 1;",
        "step": "【step1】: Filter wireless mice records from mice table using WHERE Is_Wireless = 1  【step2】: Calculate photon propulsion force using formula F=(2*1e8*0.01) through scalar computation  【step3】: Return result column aliased as Photon_Force_N",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 766,
        "question": "Calculate the energy loss rate (ineffective energy consumption / total energy consumption) for each wireless mouse during dynamic DPI switching (ΔDPI > 8000), returning models with a loss rate > 25% and acceleration > 50G. Formula: energy loss rate = (1 - (distance moved × weight × 9.8) / energy consumed) × 100%. The query needs to join the mice, sensor_data, and usage_records tables.",
        "query": "WITH EnergyAnalysis AS (SELECT m.Mouse_Id, m.Model, m.Acceleration_G, m.Weight_Grams, u.Energy_Consumed_Joules, u.Distance_Moved_Meters FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE ABS(u.Max_Dpi - u.Average_Dpi) > 8000) SELECT ea.Model FROM EnergyAnalysis ea WHERE (1 - ( (ea.Distance_Moved_Meters * ea.Weight_Grams * 9.8) / ea.Energy_Consumed_Joules )) * 100 > 25 AND ea.Acceleration_G > 50;",
        "step": "【step1】: Join mice, usage_records, and sensor_data tables with ΔDPI>8000 filtering.  【step2】: Calculate energy loss rate using formula: (1 - ((Distance*Weight*9.8)/Energy_Consumed)/Sensor_Efficiency)*100.  【step3】: Filter results where energy loss rate >25% and acceleration >50G.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 767,
        "question": "Identify users exhibiting 'fractal click patterns' (Hurst exponent > 0.8 for click intervals persisting over 10 cycles), returning user IDs and manufacturer market share. The Hurst exponent must be calculated using the rescaled range method, with persistence verified via window functions.",
        "query": "WITH ClickIntervals AS (SELECT User_ID, Mouse_ID, Start_Time, LAG(Start_Time) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_time FROM usage_records), RS_Analysis AS (SELECT User_ID, Mouse_ID, LOG(MAX(Start_Time) - MIN(Start_Time)) / LOG(COUNT(*)) AS Hurst_Index FROM ClickIntervals GROUP BY User_ID, Mouse_ID) SELECT rs.User_ID, ma.Market_Share_Percent FROM RS_Analysis rs JOIN mice m ON rs.Mouse_ID = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE rs.Hurst_Index > 0.8;",
        "step": "【step1】: Calculate click intervals using LAG() window function to find time differences between consecutive usage records per user-mouse combination.  【step2】: Compute Hurst Index via R/S method by grouping on User_ID and Mouse_ID, using (log(max_time - min_time) / log(count)) as the approximation formula.  【step3】: Join with manufacturers via mouse-manufacturer relationship, filter Hurst_Index > 0.8, and output User_ID with corresponding Market_Share_Percent.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 768,
        "question": "Retrieve wireless mouse models and their manufacturers' complaint rates where the actual battery usage is less than 50% of the nominal battery life.",
        "query": "SELECT m.Model, ma.Founded_year FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE (u.Usage_Duration_Minutes / 60) / m.Battery_Life_Hours < 0.5 AND m.Is_Wireless = 1;",
        "step": "【step1】: Join 'mice' with 'usage_records' to filter wireless mice (Is_Wireless=1) where actual battery usage (Usage_Duration_Minutes/60 divided by Battery_Life_Hours) is below 50% of the nominal capacity.  【step2】: Join the result with 'manufacturers' to access the manufacturer's details, including the newly added Complaint_Rate field (assumed to exist per the problem statement).  【step3】: Apply implicit altitude constraint (no explicit altitude data in DB; assumed handled externally via IP geolocation) and finalize selection of Model and Complaint_Rate (replace Founded_year with Complaint_Rate to match the problem requirements).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 769,
        "question": "Assuming the use of a laser sensor mouse (Sensor_Type='Laser'), calculate the required thickness of the electromagnetic shielding layer to maintain cursor positioning accuracy, given that the shielding effectiveness SE of μ-metal is SE=20*log10(f/1e6)+50, where f=pulsar radiation frequency 160 Hz. Formula: Thickness = (SE - 10*log10(σ/(2*π*f*μ))) / (4*π*sqrt(π*f*μ*σ)), where σ=1.6e6 S/m and μ=1e-4 H/m.",
        "query": "SELECT ( (20 * LOG10(160 / 1e6) + 50) - 10 * LOG10(1.6e6 / (2 * PI() * 160 * 1e-4)) ) / (4 * PI() * SQRT(PI() * 160 * 1e-4 * 1.6e6)) AS Shield_Thickness_m FROM mice WHERE Sensor_Type = 'Laser';",
        "step": "【step1】: Filter records from the 'mice' table where Sensor_Type is 'Laser' to isolate the relevant laser sensor mice.  【step2】: Calculate the numerator of the thickness formula: subtract the logarithmic term (10*LOG10(σ/(2πfμ))) from the shielding effectiveness SE (20*LOG10(f/1e6)+50).  【step3】: Compute the final thickness by dividing the numerator by the denominator (4π√(πfμσ)), using the constants σ=1.6e6 and μ=1e-4 with f=160Hz.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 770,
        "question": "Calculate the kinetic energy generated by the Corsair Dark Core RGB Pro mouse at 40G acceleration when used by user 103 (assuming the mouse mass is 0.133kg, initial velocity is 0, and usage time is 2 hours).",
        "query": "SELECT 0.5 * 0.133 * POWER((40 * 9.8 * 7200), 2) AS Kinetic_Energy_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;",
        "step": "【step1】: Join mice and usage_records tables via Mouse_Id to link mouse specifications with usage data.  【step2】: Filter records where m.Model = 'Dark Core RGB Pro' and u.User_ID = 103 to isolate the target device and user.  【step3】: Apply the kinetic energy formula (0.5 * mass * velocity²) using hardcoded parameters (0.133kg mass, 40G acceleration converted to m/s² via 9.8, 7200s duration) to calculate the result.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 771,
        "question": "Calculate the ratio of the average price of wireless mice to the average price of wired mice for each manufacturer, then sort the results in descending order by this ratio and take the top 5.",
        "query": "SELECT ma.Manufacturer_Name, AVG(CASE WHEN m.Is_Wireless = 1 THEN m.Price_Usd END) / AVG(CASE WHEN m.Is_Wireless = 0 THEN m.Price_Usd END) AS Wireless_Wired_Ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name ORDER BY Wireless_Wired_Ratio DESC LIMIT 5;",
        "step": "【step1】: Join mice and manufacturers tables to associate each mouse with its manufacturer  【step2】: Calculate average wireless prices (Is_Wireless=1) and average wired prices (Is_Wireless=0) per manufacturer using conditional aggregation  【step3】: Compute ratio, sort manufacturers by descending Wireless_Wired_Ratio, and limit to top 5 results",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 772,
        "question": "Identify which mice have a tracking speed (IPS) that is greater than 90% of their sensor's tracking speed, and flag them as high-risk devices.",
        "query": "SELECT DISTINCT m.Model, 'High Risk' AS Risk_Level FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Tracking_Speed_Ips > 0.9 * sd.Tracking_Speed_Ips;",
        "step": "【step1】: Join the 'mice' and 'sensor_data' tables using Mouse_Id to align mouse models with their corresponding sensor specifications.  【step2】: Apply the condition to filter mice where Tracking_Speed_Ips exceeds 90% of the sensor's maximum Tracking_Speed_Ips.  【step3】: Select distinct mouse models and assign the 'High Risk' label through calculated column Risk_Level.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 773,
        "question": "Assuming a user continuously uses the Logitech G502 HERO mouse at a speed of 1000 DPI for 100 years, calculate the total DPI data generated (assuming 8 hours of use per day).",
        "query": "SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'G502 HERO';",
        "step": "【step1】: Retrieve Dpi value for G502 HERO from mice table using model filter  【step2】: Calculate total usage time in seconds (100 years × 365 days × 8 hours × 3600 seconds)  【step3】: Multiply IPS(1000), Dpi, and total seconds to compute Total_DPI_Data",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 774,
        "question": "Calculate the power generated by the Razer DeathAdder V2 mouse under 50 m/s² acceleration when used by user 102, assuming a usage time of 150 minutes.",
        "query": "SELECT m.Weight_Grams / 1000 * (50 * 9.8) * (50 * 9.8 * 150 * 60) AS Power_W FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'DeathAdder V2' AND u.User_ID = 102;",
        "step": "【step1】: Join the 'mice' and 'usage_records' tables using Mouse_Id to link the specific mouse model with its usage data.  【step2】: Filter the combined data to retain only records where the model is 'DeathAdder V2' and the User_ID is 102.  【step3】: Calculate the power using the formula: convert weight to kilograms, multiply by acceleration (50G converted to m/s² via 50*9.8), then multiply by the total acceleration-derived distance (acceleration * time in seconds).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 775,
        "question": "Identify the top 3 models from manufacturers with annual revenue exceeding $1 billion and market share greater than 10%, where the ratio of price to DPI (USD/DPI) is the lowest for their produced mice.",
        "query": "SELECT m.Model, (m.Price_Usd / m.Dpi) AS Usd_Per_Dpi FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE ma.Revenue_Usd > 1000000000 AND ma.Market_Share_Percent > 10 ORDER BY Usd_Per_Dpi ASC LIMIT 3;",
        "step": "【step1】: Filter manufacturers with annual revenue over $1 billion and market share over 10% using WHERE clause on manufacturers table.  【step2】: Join filtered manufacturers with mice table, calculate USD/DPI ratio (Price_Usd/Dpi) for each mouse model.  【step3】: Sort results by USD/DPI ratio in ascending order and select top 3 models using ORDER BY and LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 776,
        "question": "Identify which wireless mice have a battery life shorter than the usage duration recorded, and calculate the shortage ratio as the proportion of the usage duration that exceeds the battery life.",
        "query": "SELECT m.Model, (u.Usage_Duration_Minutes - m.Battery_Life_Hours * 60) / u.Usage_Duration_Minutes AS Shortage_Ratio FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND u.Usage_Duration_Minutes > m.Battery_Life_Hours * 60;",
        "step": "【step1】: Join the mice table with the usage_records table using Mouse_Id to correlate device specifications with user behavior data.  【step2】: Filter wireless mice (Is_Wireless = 1) and identify records where battery life (converted to minutes) is shorter than usage duration.  【step3】: Calculate the shortage ratio using the formula (Usage_Duration_Minutes - Battery_Life_Converted) / Usage_Duration_Minutes, ensuring numerical validity through arithmetic operations.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 777,
        "question": "Assuming a user continuously uses the Corsair Dark Core RGB Pro mouse at a speed of 1000 DPI for 100 years, calculate the total amount of DPI data generated (assuming 8 hours of usage per day).",
        "query": "SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'Dark Core RGB Pro';",
        "step": "【step1】: Filter the 'mice' table to find the record where Model = 'Dark Core RGB Pro'  【step2】: Retrieve the Dpi value from the filtered mouse record  【step3】: Calculate Total_DPI_Data by multiplying 1000 IPS × Dpi × (100 years × 365 days/year × 8 hours/day × 3600 seconds/hour)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 778,
        "question": "Calculate the mechanical work generated by the Corsair Dark Core RGB Pro mouse during user 103's usage, combining movement distance and acceleration with the actual weight data.",
        "query": "SELECT (m.Weight_Grams / 1000) * (m.Acceleration_G * 9.8) * u.Distance_Moved_Meters AS Mechanical_Work_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;",
        "step": "【step1】: Join mice and usage_records tables via Mouse_Id to link product specifications with usage data  【step2】: Filter records where model is 'Dark Core RGB Pro' AND User_ID=103 to isolate target device and user  【step3】: Calculate (Weight_kg × 40G×9.8) × Distance_Moved using unit conversions and physics formula for mechanical work",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 779,
        "question": "Identify the manufacturer with the highest profit per employee ratio (profit/number of employees) among the top 3 countries by market share, and calculate the square of DPI divided by price (DPI²/USD) for the mice it produces.",
        "query": "WITH MarketShare AS (SELECT Country, SUM(Market_Share_Percent) AS Total_Market_Share FROM manufacturers GROUP BY Country ORDER BY Total_Market_Share DESC LIMIT 3), TopManufacturers AS (SELECT ma.Manufacturer_Id, ma.Manufacturer_Name FROM manufacturers ma JOIN MarketShare ms ON ma.Country = ms.Country ORDER BY (ma.Profit_Usd / ma.Employees) DESC LIMIT 1) SELECT m.Model, POWER(m.Dpi, 2)/m.Price_Usd AS Dpi2_Per_Usd FROM mice m JOIN TopManufacturers tm ON m.Manufacturer_Id = tm.Manufacturer_Id;",
        "step": "【step1】: Identify top 3 countries by total market share using CTE `MarketShare`:  - **Aggregate** manufacturers' `Market_Share_Percent` by `Country`  - **Sort** descendingly and **limit** to 3 countries  【step2】: Find manufacturer with highest profit-per-employee in those countries via CTE `TopManufacturers`:  - **Join** manufacturers with `MarketShare` results on `Country`  - **Calculate** `Profit_Usd/Employees` ratio  - **Sort** descendingly and **select** top 1 manufacturer  【step3】: Calculate DPI²/USD ratio for mice from the selected manufacturer:  - **Join** mice table with filtered `TopManufacturers` via `Manufacturer_Id`  - **Compute** `POWER(Dpi, 2)/Price_Usd` for each mouse model",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 780,
        "question": "Identify which mouse models have sensor calibration intervals exceeding 30 days and have average daily clicks more than two standard deviations above the mean of all mouse models.",
        "query": "WITH CalibrationIntervals AS (SELECT Sensor_Id, DATEDIFF(Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date)) AS Calibration_Interval FROM sensor_data), ClickStats AS (SELECT Mouse_ID, AVG(Clicks / DATEDIFF(End_Time, Start_Time)) AS Avg_Clicks_Per_Day, STDDEV(Clicks / DATEDIFF(End_Time, Start_Time)) AS Std_Clicks_Per_Day FROM usage_records GROUP BY Mouse_ID) SELECT m.Model FROM mice m JOIN CalibrationIntervals ci ON m.Mouse_Id = ci.Sensor_Id JOIN ClickStats cs ON m.Mouse_Id = cs.Mouse_ID WHERE ci.Calibration_Interval > 30 AND (cs.Avg_Clicks_Per_Day > (SELECT AVG(Avg_Clicks_Per_Day) + 2 * STDDEV(Avg_Clicks_Per_Day) FROM ClickStats));",
        "step": "【step1】: Calculate calibration intervals between successive calibrations for each sensor using LAG window function  【step2】: Compute mouse-specific daily click averages and standard deviations from usage records  【step3】: Join results with mice table and apply dual filters: interval >30 days and average clicks exceeding 2σ above population mean",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 781,
        "question": "Assuming a competitive gamer uses a Logitech G502 HERO (tracking speed 400 IPS, polling rate 1000 Hz), calculate the number of interrupts per second.",
        "query": "SELECT Tracking_Speed_Ips * Polling_Rate_Hz AS Interrupts_Per_Second FROM mice WHERE Model = 'G502 HERO';",
        "step": "【step1】: Filter the 'mice' table to locate the specific record where Model = 'G502 HERO' using the WHERE clause.  【step2】: Extract the 'Tracking_Speed_Ips' (400 IPS) and 'Polling_Rate_Hz' (1000 Hz) values from the filtered record.  【step3】: Multiply the two retrieved values to compute the interrupt requests per second (400 * 1000 = 400,000).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 782,
        "question": "Calculate the energy conversion efficiency (ratio of actual mechanical work to consumed electrical energy) of the Logitech G502 HERO mouse during usage by user101.",
        "query": "SELECT ((m.Weight_Grams / 1000) * m.Acceleration_G * 9.8 * u.Distance_Moved_Meters) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;",
        "step": "【step1】: Perform an INNER JOIN between 'mice' and 'usage_records' tables using Mouse_Id to combine mouse specifications with usage data.  【step2】: Filter records where mouse model is 'G502 HERO' (via m.Model) and user ID is 101 (via u.User_ID).  【step3】: Calculate energy efficiency using the formula: ((convert grams to kg) × g-force × 9.8 × distance) / energy_consumed. Unit conversions and physics constants are applied during computation.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 783,
        "question": "Calculate the composite metric of each manufacturer's market share and profit per employee (Market_Share_Percent * (Profit_Usd/Employees)), filter out manufacturers with a metric value greater than 100 and established for more than 20 years, and select the top 5 ranked by the metric value in descending order.",
        "query": "SELECT Manufacturer_Name, Market_Share_Percent * (Profit_Usd / Employees) AS Composite_Index FROM manufacturers WHERE Market_Share_Percent * (Profit_Usd / Employees) > 100 AND Founded_year < YEAR(CURDATE()) - 20 ORDER BY Composite_Index DESC LIMIT 5;",
        "step": "【step1】: Select manufacturer names and compute the composite index (Market_Share_Percent * (Profit_Usd / Employees)) from the manufacturers table.  【step2】: Filter results where the composite index exceeds 100 and the manufacturer's founding year is more than 20 years ago (using Founded_year < YEAR(CURDATE()) - 20).  【step3】: Sort the filtered records by the composite index in descending order and retain only the top 5 entries using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 784,
        "question": "Identify wireless mice with battery life shorter than the average daily usage duration, and calculate their theoretical maximum usage days (accurate to two decimal places).",
        "query": "SELECT m.Model, ROUND(m.Battery_Life_Hours / (AVG(u.Usage_Duration_Minutes) / 60), 2) AS Max_Usage_Days FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Battery_Life_Hours HAVING m.Battery_Life_Hours < AVG(u.Usage_Duration_Minutes) / 60;",
        "step": "【step1】: Join 'mice' and 'usage_records' tables to filter wireless mice and calculate daily usage hours.  【step2】: Calculate average daily usage duration per mouse model and check battery life against it.  【step3】: Compute maximum usage days with rounding, then filter results where battery life is insufficient for daily usage.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 785,
        "question": "Assuming a laboratory operates a mouse continuously at a maximum acceleration of 50G and a polling rate of 2000Hz, calculate the number of data packets generated per second.",
        "query": "SELECT Polling_Rate_Hz * Acceleration_G AS Packets_Per_Second FROM mice WHERE Polling_Rate_Hz = 2000 AND Acceleration_G = 50;",
        "step": "【step1】: Filter records from the 'mice' table where Polling_Rate_Hz is 2000 and Acceleration_G is 50.  【step2】: Calculate the product of Polling_Rate_Hz and Acceleration_G for the filtered record(s) to determine the number of packets per second.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 786,
        "question": "Based on the Lift_Off_Distance_Mm field from the sensor_data table and the Distance_Moved_Meters field from the usage_records table, calculate the total sensor hovering energy loss in Joules for the Logitech G502 HERO mouse during usage by user 101 (assuming each millimeter of lift-off distance consumes 0.5 mJ of energy).",
        "query": "SELECT (u.Distance_Moved_Meters / (sd.Lift_Off_Distance_Mm / 1000)) * 0.5 * POWER(10, -3) AS Total_Energy_Loss_J FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;",
        "step": "【step1】: Join mice, sensor_data, and usage_records tables via Mouse_Id to associate device specifications with user usage data  【step2】: Filter records for 'G502 HERO' model (m.Model) and User_ID=101 (u.User_ID) to isolate specific device/user context  【step3】: Calculate energy loss: (Total Distance / Lift-Off-Distance-in-Meters) × 0.5mJ → convert to joules via ×10⁻³, accounting for millimeter-to-meter conversion in lift-off distance denominator",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 787,
        "question": "Calculate the covariance between the price variation coefficient (standard deviation/mean) of wireless mouse product lines and market share for each manufacturer established for over 25 years, sorted in descending order by the absolute value of covariance.",
        "query": "WITH ManufacturerStats AS (SELECT ma.Manufacturer_Id, STDDEV(m.Price_Usd) / AVG(m.Price_Usd) AS Price_CV, ma.Market_Share_Percent FROM manufacturers ma JOIN mice m ON ma.Manufacturer_Id = m.Manufacturer_Id WHERE YEAR(CURDATE()) - ma.Founded_year > 25 AND m.Is_Wireless = 1 GROUP BY ma.Manufacturer_Id, ma.Market_Share_Percent) SELECT Manufacturer_Id, (SUM(Price_CV * Market_Share_Percent) - SUM(Price_CV) * SUM(Market_Share_Percent) / COUNT(*)) / COUNT(*) AS Covariance FROM ManufacturerStats GROUP BY Manufacturer_Id ORDER BY ABS(Covariance) DESC;",
        "step": "【step1】: Filter manufacturers established over 25 years ago and calculate the price coefficient of variation (STDDEV/AVG) for their wireless mice. Join the `manufacturers` and `mice` tables, apply conditions `YEAR(CURDATE()) - Founded_year > 25` and `Is_Wireless = 1`, then group by `Manufacturer_Id` and `Market_Share_Percent`.  【step2】: Compute the covariance between `Price_CV` and `Market_Share_Percent` using the formula:  ```(SUM(xy) - SUM(x)SUM(y)/n) / n```  Aggregate results by `Manufacturer_Id` for final covariance values.  【step3】: Order results by the absolute value of covariance (`ABS(Covariance)`) in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 788,
        "question": "Identify wired mouse models that violate industrial design standards (weight >100 grams and cable length <1.5 meters), and calculate their click efficiency (sum of clicks divided by sum of minutes of usage) for each model.",
        "query": "SELECT m.Model, SUM(u.Clicks) / SUM(u.Usage_Duration_Minutes) AS Click_Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 0 AND m.Weight_Grams > 100 AND m.Cable_Length_Meters < 1.5 GROUP BY m.Model;",
        "step": "【step1】: Filter wired mice violating industrial specs (Is_Wireless=0, Weight_Grams>100, Cable_Length_Meters<1.5) from mice table  【step2】: Join filtered mice with usage_records via Mouse_Id to access click/usage data  【step3】: Group by Model and calculate Click_Efficiency using SUM(Clicks)/SUM(Usage_Duration_Minutes)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 789,
        "question": "Assuming a quantum computer polls the mouse position at intervals of Planck time (5.39×10^{-44} seconds), calculate the universe-scale data volume generated per second by the Dark Core RGB Pro at its maximum 18000 DPI (1 YB = 10^{24} bytes).",
        "query": "SELECT (1 / 5.39e-44) * (18000 / 25.4) * 8 / POWER(10, 24) AS Data_Volume_YB FROM mice WHERE Model = 'Dark Core RGB Pro';",
        "step": "【step1】: Calculate polling frequency per second by dividing 1 by Planck time (5.39e-44 seconds)  【step2】: Compute per-point data by converting 18000 DPI to dots per millimeter (18000/25.4) and multiplying by 8 bytes  【step3】: Calculate total YB by multiplying polling frequency and per-point data, then dividing by 1e24 for unit conversion",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 790,
        "question": "Calculate the energy efficiency (effective movement energy / total energy consumption) of the Logitech G502 HERO mouse when used by user 101, formula: efficiency = (distance × weight × 9.8) / energy consumption",
        "query": "SELECT (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;",
        "step": "【step1】:JOIN 'mice' and 'usage_records' tables using Mouse_Id to link mouse specifications with usage data  【step2】:FILTER records where mouse model is 'G502 HERO' (m.Model) and user is 101 (u.User_ID)  【step3】:CALCULATE energy efficiency using formula (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 791,
        "question": "Find manufacturers that have been in operation for more than 20 years (current year is 2023) with a profit per employee (profit/number of employees) exceeding $200,000, and calculate the average DPI-to-price ratio of their mice.",
        "query": "SELECT ma.Manufacturer_Name, AVG(m.Dpi/m.Price_Usd) AS Dpi_Per_Usd FROM manufacturers ma JOIN mice m ON ma.Manufacturer_Id = m.Manufacturer_Id WHERE 2023 - ma.Founded_year > 20 AND (ma.Profit_Usd/ma.Employees) > 200000 GROUP BY ma.Manufacturer_Name;",
        "step": "【step1】: Filter manufacturers established over 20 years ago (2023 - Founded_year > 20) with profit per employee exceeding $200,000 (Profit_Usd/Employees > 200000)  【step2】: Join filtered manufacturers with mice table using Manufacturer_Id to access mouse models  【step3】: Calculate average DPI-to-Price ratio (AVG(m.Dpi/m.Price_Usd)) per manufacturer and group results by Manufacturer_Name",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 792,
        "question": "Identify wireless mouse models with a daily average of more than 8,000 clicks and weight > 120g, marking the risk level according to WHO occupational health standards.",
        "query": "SELECT m.Model, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS Daily_Clicks, CASE WHEN SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) > 8000 AND m.Weight_Grams > 120 THEN '高危' ELSE '正常' END AS Risk_Level FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Weight_Grams;",
        "step": "【step1】: Join the 'mice' and 'usage_records' tables using Mouse_Id, filter wireless mice (Is_Wireless = 1)  【step2】: Calculate daily average clicks (SUM(Clicks)/COUNT(DISTINCT DATE(Start_Time))) and group results by Model and Weight_Grams  【step3】: Apply CASE expression to assign '高危' for models with daily clicks >8000 and weight >120g, otherwise '正常', then project final columns",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 793,
        "question": "Assuming the Dark Core RGB Pro is operating at 100% load (tracking speed = maximum sensor speed), calculate its theoretical maximum data generation rate (coordinates per second = IPS × DPI).",
        "query": "SELECT sd.Tracking_Speed_Ips * sd.Max_Dpi AS Data_Points_Per_Second FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro';",
        "step": "【step1】:Join mice and sensor_data tables using Mouse_Id to associate the mouse model with its sensor specifications.  【step2】:Filter the joined data to select only the 'Dark Core RGB Pro' model using WHERE m.Model = 'Dark Core RGB Pro'.  【step3】:Calculate the product of Tracking_Speed_Ips and Max_Dpi from the filtered result to obtain the theoretical maximum data points per second.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 794,
        "question": "Based on the Polling_Rate_Hz and Acceleration_G values from the sensor_data table, calculate the inertial force for the Logitech G502 HERO mouse while being used by user 101 (incorporating Weight_Grams).",
        "query": "SELECT (m.Weight_Grams/1000.0) * POWER(2 * PI() * sd.Polling_Rate_Hz, 2) * (sd.Acceleration_G * 9.8 / SQRT(2)) AS Inertial_Force FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Model = 'G502 HERO' AND ur.User_ID = 101 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');",
        "step": "【step1】: Retrieve Logitech's Manufacturer_Id and join mice with sensor_data, filtering for G502 HERO model  【step2】: Join usage_records to enforce User_ID=101 constraint and validate device ownership  【step3】: Calculate inertial force using formula: (kg_weight) × (2π·polling_rate)² × (accel_g×9.8/√2)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 795,
        "question": "Calculate the Pearson correlation coefficient between the Herfindahl-Hirschman Index (HHI = Σ(Market_Share_Percent²)) of manufacturers and the entropy value of their mouse DPI parameters (-Σ(p_i log p_i), where p_i is the proportion of each DPI model).",
        "query": "WITH Market_HHI AS (SELECT SUM(POWER(Market_Share_Percent, 2)) AS HHI FROM manufacturers), Manufacturer_DPI AS (SELECT Manufacturer_Id, Dpi, COUNT(*) / SUM(COUNT(*)) OVER(PARTITION BY Manufacturer_Id) AS ratio FROM mice GROUP BY Manufacturer_Id, Dpi), Entropy_Calc AS (SELECT Manufacturer_Id, -SUM(ratio * LN(ratio)) AS entropy FROM Manufacturer_DPI GROUP BY Manufacturer_Id) SELECT (AVG(mh.HHI * ec.entropy) - AVG(mh.HHI) * AVG(ec.entropy)) / (STDDEV(mh.HHI) * STDDEV(ec.entropy)) AS Pearson_Correlation FROM Market_HHI mh, Entropy_Calc ec;",
        "step": "【step1】: Compute the overall Herfindahl-Hirschman Index (HHI) by summing the squares of all manufacturers' market shares from the manufacturers table.  【step2】: Calculate the DPI ratio distribution per manufacturer from the mice table and compute the entropy value for each manufacturer using the formula -Σ(ratio * ln(ratio)).  【step3】: Compute the Pearson correlation coefficient between the single HHI value (repeated for all manufacturers) and each manufacturer's entropy using covariance and standard deviations.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 796,
        "question": "Identify mouse models that violate the ISO 9241-411 ergonomic standards (weight >100g and buttons <6) and calculate their user operation efficiency degradation rate (Δ efficiency = MAX(click efficiency) - current click efficiency).",
        "query": "WITH Efficiency_Data AS (SELECT m.Model, ur.Clicks/ur.Usage_Duration_Minutes AS current_efficiency, MAX(ur.Clicks/ur.Usage_Duration_Minutes) OVER() AS max_efficiency FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Weight_Grams > 100 AND m.Buttons < 6) SELECT Model, ROUND(max_efficiency - current_efficiency, 4) AS efficiency_decay FROM Efficiency_Data;",
        "step": "【step1】: Filter mice violating ISO 9241-411 (Weight_Grams > 100 AND Buttons < 6) and join with usage_records to calculate current_efficiency (Clicks/Usage_Duration_Minutes) per model  【step2】: Compute global max_efficiency using MAX() OVER() window function across all qualified records  【step3】: Calculate efficiency decay (max_efficiency - current_efficiency) and round to 4 decimal places for final output",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 797,
        "question": "Assuming the use of a Razer DeathAdder V2 near the event horizon of a Kerr black hole (angular velocity Ω=ac/(2r_+), r_+=M+√(M^2-a^2)), calculate the DPI measurement error caused by relativistic Doppler effects (with black hole parameter a=0.9M).",
        "query": "WITH constants AS ( SELECT 6.67430e-11 AS G, 1.989e30 AS M, 299792458 AS c, 0.9 AS factor ),sqrt_part AS ( SELECT SQRT( POWER( M, 2 ) - POWER( factor * M, 2 )) AS sqrt_value FROM constants ),numerator AS (SELECT 1 - SQRT(1 - ( 2 * G * M ) / (POWER( c, 2 ) * ( M + sqrt_value )))AS num FROM constants,sqrt_part ),denominator AS (SELECT 1 + (factor * c * POWER( M + sqrt_value, 3 )) / POWER( c, 3 ) AS denom FROM constants,sqrt_part ) SELECT m.Dpi * ( num / denom ) AS DPI_Error FROM mice m,numerator,denominator WHERE m.Model = 'DeathAdder V2'  AND m.Manufacturer_Id = ( SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer' );",
        "step": "【step1】: Calculate constants and intermediate values (r_+ and sqrt component) using the 'constants' and 'sqrt_part' CTEs.  【step2】: Compute relativistic Doppler factors in 'numerator' (gravitational time dilation term) and 'denominator' (frame-dragging angular velocity term) CTEs using results from step 1.  【step3】: Join mouse data (filtering for Razer DeathAdder V2 via subquery) with calculated Doppler factors to compute final DPI_Error via relativistic formula (m.Dpi * num/denom).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 798,
        "question": "Based on the Clicks from the usage_records table and the Weight_Grams from the mice table, calculate the total energy (in Joules) for the Razer DeathAdder V2 mouse when used by user 102, considering both the base click energy and the additional energy from lifting the mouse weight.",
        "query": "SELECT (ur.Clicks * 0.0002) + (m.Weight_Grams/1000 * 9.8 * 0.003 * ur.Clicks) AS Total_Energy_J FROM usage_records ur JOIN mice m ON ur.Mouse_Id = m.Mouse_Id JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'DeathAdder V2' AND ur.User_ID = 102 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');",
        "step": "【step1】: Retrieve Razer's Manufacturer_Id from manufacturers table to ensure the mouse is produced by the correct manufacturer.  【step2】: Join usage_records, mice, and sensor_data via Mouse_Id, filtering for 'DeathAdder V2' model, User_ID 102, and Razer manufacturer.  【step3】: Calculate total energy loss using formula: (Clicks × 0.0002) + (Weight_Grams/1000 × 9.8 × 0.003 × Clicks), combining click energy and gravitational potential energy from lift-off.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 799,
        "question": "Calculate the Kullback-Leibler divergence between the transition probabilities of manufacturers' market share changes over the past three years and the entropy of mouse DPI distributions for each manufacturer.",
        "query": "WITH YearSeries AS (SELECT 0 AS year UNION SELECT 1 UNION SELECT 2), MarketData AS ( SELECT m.Manufacturer_Id, YEAR(CURDATE()) - ys.year AS Year, COALESCE(m.Market_Share_Percent,0) AS Share FROM manufacturers m CROSS JOIN YearSeries ys WHERE m.Founded_year <= YEAR(CURDATE()) - ys.year ), TransProb AS ( SELECT curr.Manufacturer_Id, (curr.Share - prev.Share)/NULLIF(prev.Share,0) AS Prob FROM MarketData curr JOIN MarketData prev ON curr.Manufacturer_Id = prev.Manufacturer_Id AND curr.Year = prev.Year + 1 ), Entropy AS ( SELECT Manufacturer_Id, -SUM((cnt/total)*LN(NULLIF(cnt/total,0))) AS entropy FROM ( SELECT Manufacturer_Id, Dpi, COUNT(*) AS cnt, SUM(COUNT(*)) OVER (PARTITION BY Manufacturer_Id) AS total FROM mice GROUP BY Manufacturer_Id, Dpi ) t GROUP BY Manufacturer_Id ) SELECT t.Manufacturer_Id, SUM(t.Prob * LN(NULLIF(t.Prob/e.entropy,0))) AS KL_Divergence FROM TransProb t JOIN Entropy e ON t.Manufacturer_Id = e.Manufacturer_Id GROUP BY t.Manufacturer_Id;",
        "step": "【step1】: Generate 3-year market share timeline using recursive YearSeries (0-2) cross-joined with manufacturers, ensuring valid years via Founded_year filter.  【step2】: Calculate annual transition probabilities (prev→curr share delta) for manufacturers and compute DPI distribution entropy per manufacturer using mice data.  【step3】: Compute KL divergence between transition probabilities and entropy distribution through SUM(Prob * ln(Prob/entropy)) aggregation per manufacturer.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 800,
        "question": "Identify mouse models that violate the EN 60950 safety standard (weight >150g when cable length <1m) and calculate their user fatigue factor (scrolls per minute × weight²/cable length).",
        "query": "SELECT m.Model, (ur.Scrolls/ur.Usage_Duration_Minutes) * POW(m.Weight_Grams/1000,2)/NULLIF(m.Cable_Length_Meters,0) AS Fatigue_Factor FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Cable_Length_Meters < 1 AND m.Weight_Grams > 150;",
        "step": "【step1】: Filter mice records where cable length <1m and weight >150g using WHERE clause  【step2】: Join filtered mice with usage_records via Mouse_Id to access scroll/usage data  【step3】: Calculate fatigue factor using (scrolls/duration) × (kg_weight²/cable_length) with NULLIF for zero-length protection",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 801,
        "question": "Assuming operating a Logitech G502 HERO at the Planck scale (time quantum Δt=1e-43 seconds, space quantum Δx=1e-35 meters), calculate its effective DPI under the quantum Zeno effect (measurement collapse frequency f=1e43 Hz).",
        "query": "SELECT m.Dpi * (1.0 * 1e43*1e-43)/1.32934 AS Effective_DPI FROM mice m WHERE m.Model = 'G502 HERO' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');",
        "step": "【step1】: Execute the subquery to retrieve the Manufacturer_Id for 'Logitech' from the manufacturers table by matching Manufacturer_Name.  【step2】: Filter the mice table using the obtained Manufacturer_Id and Model 'G502 HERO' to access the base Dpi value.  【step3】: Calculate the effective DPI by applying the quantum Zeno effect formula: multiply the base Dpi by the ratio (1e43·1e-43)/1.32934 (equivalent to 1/1.32934) to simulate measurement collapse frequency scaling.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 802,
        "question": "Based on the Weight_Grams, Cable_Length_Meters, and Acceleration_G columns from the sensor_data and mice tables, calculate the Joule heat power generated by the Corsair Dark Core RGB Pro mouse under full load operation (incorporating a thermal conductivity coefficient of 0.2 W/m·K).",
        "query": "SELECT (m.Weight_Grams/1000 * POWER(sd.Acceleration_G * 9.8, 2)) / 3000 * (m.Cable_Length_Meters / (0.2 * PI() * POWER(0.001, 2))) AS Thermal_Power_W FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Corsair');",
        "step": "【step1】: Subquery retrieves Corsair's Manufacturer_Id from manufacturers table to establish device origin.  【step2】: JOIN mice and sensor_data by Mouse_Id, filtering for \"Dark Core RGB Pro\" model linked to Corsair.  【step3】: Calculate thermal power using physics formula integrating weight (kg), acceleration (m/s²), cable length, and thermal conductivity constant.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 803,
        "question": "Establish a grey prediction GM(1,1) model for manufacturer market share and perform canonical correlation analysis (CCA) with the singular value decomposition (SVD) results of the mouse parameter matrix (Dpi, Price, Weight), calculating the first 3 canonical correlation coefficients.",
        "query": "WITH Market_Share_Data AS (SELECT Manufacturer_Id, Market_Share_Percent, ROW_NUMBER() OVER (PARTITION BY Manufacturer_Id ORDER BY Founded_year) AS rn FROM manufacturers), GM_Model AS (SELECT Manufacturer_Id, (FIRST_VALUE(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id ORDER BY rn) - (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) / COUNT(*) OVER (PARTITION BY Manufacturer_Id))) * EXP(-0.5 * (rn-1)) + (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) / COUNT(*) OVER (PARTITION BY Manufacturer_Id)) AS Predicted_Share FROM Market_Share_Data), Mouse_Matrix AS (SELECT Manufacturer_Id, AVG(Dpi) AS avg_dpi, AVG(Price_Usd) AS avg_price, AVG(Weight_Grams) AS avg_weight FROM mice GROUP BY Manufacturer_Id), SVD_Decomp AS (SELECT Manufacturer_Id, avg_dpi/SQRT(POWER(avg_dpi,2)+POWER(avg_price,2)+POWER(avg_weight,2)) AS u1, avg_price/SQRT(POWER(avg_dpi,2)+POWER(avg_price,2)+POWER(avg_weight,2)) AS u2, avg_weight/SQRT(POWER(avg_dpi,2)+POWER(avg_price,2)+POWER(avg_weight,2)) AS u3 FROM Mouse_Matrix), Covariance_Matrix AS (SELECT gm.Manufacturer_Id, gm.Predicted_Share * svd.u1 AS cov1, gm.Predicted_Share * svd.u2 AS cov2, gm.Predicted_Share * svd.u3 AS cov3 FROM GM_Model gm JOIN SVD_Decomp svd ON gm.Manufacturer_Id = svd.Manufacturer_Id) SELECT AVG(cov1)/SQRT(AVG(POWER(gm.Predicted_Share,2)) * AVG(POWER(svd.u1,2))) AS rho1, AVG(cov2)/SQRT(AVG(POWER(gm.Predicted_Share,2)) * AVG(POWER(svd.u2,2))) AS rho2, AVG(cov3)/SQRT(AVG(POWER(gm.Predicted_Share,2)) * AVG(POWER(svd.u3,2))) AS rho3 FROM Covariance_Matrix cm JOIN GM_Model gm ON cm.Manufacturer_Id = gm.Manufacturer_Id JOIN SVD_Decomp svd ON cm.Manufacturer_Id = svd.Manufacturer_Id;",
        "step": "【step1】:【Prepare temporal market share data and mouse parameter matrix】  Extract manufacturer's historical market share with row numbers ordered by founding year (Market_Share_Data). Compute averaged mouse parameters (Dpi, Price, Weight) per manufacturer (Mouse_Matrix).  【step2】:【Apply GM(1,1) model and normalize mouse parameters】  Calculate predicted market shares using exponential smoothing and window functions (GM_Model). Normalize mouse parameters via L2-normalization to simulate SVD preprocessing (SVD_Decomp).  【step3】:【Compute covariance terms and derive canonical correlations】  Calculate cross-covariances between GM predictions and normalized mouse parameters (Covariance_Matrix). Finalize first 3 canonical correlation coefficients by scaling covariances with standard deviation products.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 804,
        "question": "Identify wireless mouse models with battery life efficiency below 80% that support sensors with max DPI over 16000, and calculate their efficiency percentage (battery life hours * 3.7) / (price USD * 0.8) * 100.",
        "query": "SELECT m.Model, (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 AS Efficiency_Percent FROM mice m WHERE m.Is_Wireless = 1 AND EXISTS (SELECT 1 FROM sensor_data sd WHERE sd.Mouse_Id = m.Mouse_Id AND sd.Max_Dpi > 16000) AND (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 < 80;",
        "step": "【step1】: Filter wireless mice with EXISTS subquery to verify sensor performance (Max_Dpi >16000)  【step2】: Calculate energy efficiency ratio using formula (Battery_Life_Hours*3.7)/(Price_Usd*0.8)*100  【step3】: Apply final filter to select models where calculated efficiency <80% and return Model with efficiency percentage  Note: The original query lacks explicit PD3.0 protocol check and charging current validation due to missing fields in schema. Actual USB-IF compliance verification would require additional hardware specification columns not present in provided database structure.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 805,
        "question": "Assuming the use of a Razer DeathAdder V2 while moving at the cosmic expansion rate (H0=70km/s/Mpc) within the observable universe's horizon (Hubble radius of 4.4e26 meters), calculate the effective DPI in a quantum entangled state (with the Planck length of 1.6e-35 meters as the minimum displacement unit), where the natural logarithm of the ratio of the Planck length to itself is used.",
        "query": "SELECT m.Dpi * (1 + 1100) / (70 * 4.4e26 / 3.086e19) * LN(1.6e-35/1.6e-35) AS Effective_DPI FROM mice m WHERE m.Model = 'DeathAdder V2' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');",
        "step": "【step1】: Execute the subquery to retrieve Razer's Manufacturer_Id from the manufacturers table using WHERE Manufacturer_Name = 'Razer'.  【step2】: Filter the mice table for rows where Model = 'DeathAdder V2' and Manufacturer_Id matches the subquery result from Step 1.  【step3】: Calculate Effective_DPI using the formula: Dpi multiplied by (1+1100), divided by (70*Hubble_radius/conversion_factor), then multiplied by LN(Planck_length/Planck_length) (which equals 0, making the result invalid).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 806,
        "question": "Based on the Friis transmission formula for wireless mice in the 2.4GHz frequency band (using a 2dBi antenna gain and 1m transmission distance), calculate the free space path loss.",
        "query": "SELECT 20*(LOG(10, 4*PI()*1*(2.4e9/3e8)))/LOG(10) - 2 - 2 AS Path_Loss_dB FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Is_Wireless = 1;",
        "step": "【step1】: Perform INNER JOIN between `mice` and `sensor_data` tables using `Mouse_Id` to combine wireless mouse records with corresponding sensor specifications.  【step2】: Filter results using `WHERE m.Is_Wireless = 1` to retain only wireless mice.  【step3】: Calculate free-space path loss using the Friis formula expression `20*(LOG(10, 4*PI()*1*(2.4e9/3e8)))/LOG(10) - 2 - 2`, which accounts for frequency conversion (2.4GHz), transmission distance (1m), and antenna gains (2dBi each).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 807,
        "question": "Based on mouse parameters (Dpi, Price_Usd) to predict market share (Market_Share_Percent), establish a multiple linear regression model and calculate the coefficient of determination R².",
        "query": "CREATE TEMPORARY TABLE BaseData AS SELECT mf.Market_Share_Percent AS Y, md.Dpi AS X1, md.Price_Usd AS X2 FROM mice md JOIN manufacturers mf ON md.Manufacturer_Id = mf.Manufacturer_Id; CREATE TEMPORARY TABLE Stats AS SELECT AVG(Y) AS y_bar, AVG(X1) AS x1_bar, AVG(X2) AS x2_bar, AVG(Y * X1) - AVG(Y) * AVG(X1) AS cov_yx1, AVG(Y * X2) - AVG(Y) * AVG(X2) AS cov_yx2, AVG(X1 * X1) - AVG(X1) * AVG(X1) AS var_x1, AVG(X2 * X2) - AVG(X2) * AVG(X2) AS var_x2, AVG(X1 * X2) - AVG(X1) * AVG(X2) AS cov_x1x2 FROM BaseData; CREATE TEMPORARY TABLE Coefficients AS SELECT (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) AS beta1, (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) AS beta2, y_bar - ( (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) ) * x1_bar - ( (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) ) * x2_bar AS beta0 FROM Stats; CREATE TEMPORARY TABLE Predicted AS SELECT b.Y, c.beta0 + c.beta1 * b.X1 + c.beta2 * b.X2 AS Y_hat FROM BaseData b CROSS JOIN Coefficients c; SELECT 1 - SUM(POWER(Y - Y_hat, 2)) / SUM(POWER(Y - (SELECT y_bar FROM Stats), 2)) AS R_squared FROM Predicted;",
        "step": "【step1】: Create BaseData table by joining manufacturers and mice tables to gather market share (Y), Dpi (X1), and Price_Usd (X2)  【step2】: Calculate statistical aggregates (means, covariances, variances) from BaseData to populate Stats table  【step3】: Compute regression coefficients using matrix algebra, generate predictions, then derive R² via residual and total sum of squares",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 808,
        "question": "Identify wireless mouse models that violate the EU ErP directive (standby power consumption >0.5W) and calculate their annual CO2 emissions in kg (based on a grid emission factor of 0.85kg CO₂/kWh and 18 hours of daily standby time).",
        "query": "SELECT m.Model, (ur.Energy_Consumed_Joules/(3600*1000)) * 18 * 365 * 0.85 AS Annual_CO2_kg FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Is_Wireless = 1 AND (ur.Energy_Consumed_Joules/(3600*ur.Usage_Duration_Minutes*60)) > 0.5;",
        "step": "【step1】: Join the 'mice' and 'usage_records' tables using Mouse_Id to associate wireless mouse models with their energy consumption data.  【step2】: Filter results to include only wireless mice (Is_Wireless = 1) and calculate standby power (Energy_Consumed_Joules / (3600 * Usage_Duration_Minutes * 60)) to enforce the ErP directive violation condition (>0.5W).  【step3】: Compute annual CO2 emissions by converting energy to kWh, scaling for daily 18-hour standby over 365 days, and applying the 0.85kg/kWh emission factor, while projecting the Model and Annual_CO2_kg.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 809,
        "question": "Assuming the use of a Logitech G502 HERO in a Bose-Einstein condensate (temperature 1e-7K), calculate the DPI error caused by quantum vortices (using the vortex spacing formula a=√(h/(mω)), with trap frequency ω=100Hz), where the error is calculated as DPI * (a/1e-6)^2 * ln(1e-4/(π*a^2)).",
        "query": "SELECT m.Dpi * POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000 * 100))/(1e-6), 2) * LN(1e-4/(PI()*POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000 * 100)),2))) AS DPI_Error FROM mice m WHERE m.Model = 'G502 HERO';",
        "step": "【step1】: Filter mice records for model 'G502 HERO' using WHERE clause  【step2】: Calculate quantum vortex spacing (a) using formula SQRT(1.0545718e-34/(m.Weight_Grams/1000*100))  【step3】: Compute DPI error via formula m.Dpi * POWER(a/1e-6,2) * LN(1e-4/(PI()*POW(a,2))) with unit conversions (μm scale and density parameter)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 810,
        "question": "Based on the **Weight_Grams** from the **mice** table, the **Tracking_Speed_Ips** from the **sensor_data** table, the **Distance_Moved_Meters** and **Usage_Duration_Minutes** from the **usage_records** table, calculate the kinetic energy change produced by the **Corsair Dark Core RGB Pro** during usage by user **103** (assuming a friction coefficient μ=0.2 and a movement angle θ=15° relative to the horizontal plane).",
        "query": "SELECT ROUND( (0.5 * (m.Weight_Grams / 1000) * POWER(s.Tracking_Speed_Ips * 0.0254, 2) - 0.2 * (m.Weight_Grams / 1000) * 9.8 * u.Distance_Moved_Meters * SIN(RADIANS(15))) / (u.Usage_Duration_Minutes * 60), 6 ) AS Kinetic_Energy_Change FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103",
        "step": "【step1】: Join tables (usage_records, mice, sensor_data) via Mouse_ID to consolidate weight, sensor data, and usage metrics.  【step2】: Apply filters for specific model ('Dark Core RGB Pro') and user (ID=103).  【step3】: Calculate kinetic energy change using physics formula: (0.5mv² - μmgd·sinθ)/(time), with unit conversions (grams→kg, inches→m, minutes→seconds) and precision rounding.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 811,
        "question": "Compute the coefficient of variation (standard deviation/mean) for the price-to-weight ratio (Price_Usd/Weight_Grams) of mice by manufacturer, and assign a segment indicator (1 if market share > 25%, else 0).",
        "query": "WITH PriceWeightRatio AS ( SELECT man.Manufacturer_Name, m.Price_Usd / m.Weight_Grams AS Ratio, man.Market_Share_Percent FROM mice m JOIN manufacturers man ON m.Manufacturer_Id = man.Manufacturer_Id ), Stats AS ( SELECT Manufacturer_Name, STDDEV(Ratio) AS StdDev, AVG(Ratio) AS Mean, Market_Share_Percent FROM PriceWeightRatio GROUP BY Manufacturer_Name, Market_Share_Percent ) SELECT Manufacturer_Name, ROUND(StdDev / Mean, 4) AS CV, CASE WHEN Market_Share_Percent > 25 THEN 1 ELSE 0 END AS Segment FROM Stats ORDER BY CV DESC",
        "step": "【step1】: Join `mice` and `manufacturers` to compute price/weight ratio per product and attach market share.  【step2】: Calculate standard deviation and mean of the ratio per manufacturer, grouping by manufacturer and market share.  【step3】: Compute coefficient of variation (CV), segment market share at 25% threshold, and sort results by CV descending.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 812,
        "question": "Identify mouse models where the cumulative usage hours (based on usage duration minutes converted to hours) exceed 90% of the sensor's lifespan, assuming 8 hours of daily use.",
        "query": "SELECT DISTINCT m.Model FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE (u.Usage_Duration_Minutes / 60) / 8 / s.Sensor_Life_Hours > 0.9",
        "step": "【step1】: Join 'usage_records', 'mice', and 'sensor_data' tables via Mouse_ID to consolidate usage duration, sensor life, and model information.  【step2】: Calculate total operational days (Usage_Duration_Minutes/60/8) and compare it to 90% of Sensor_Life_Hours by formula: (operational_days) / Sensor_Life_Hours > 0.9.  【step3】: Filter distinct mouse models meeting the threshold condition from the joined dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 813,
        "question": "Assuming the use of a Logitech G502 HERO mouse in a strong magnetic field environment with magnetic flux density B=10 T, calculate the trajectory offset caused by the Lorentz force assuming movement speed v=2 m/s, charge accumulation Q=1e-12 C, and mouse weight in grams.",
        "query": "SELECT ROUND(0.5 * (1e-12 * 2 * 10 / (m.Weight_Grams / 1000)) * POWER(1 / 1000, 2), 12) AS Trajectory_Offset FROM mice m WHERE m.Model = 'G502 HERO'",
        "step": "【step1】: Retrieve weight data for G502 HERO from mice table using WHERE filter on Model  【step2】: Calculate Lorentz force trajectory offset using formula (0.5 * (Q*v*B/mass) * time²) with mass conversion from grams to kg  【step3】: Apply ROUND() to format result to 12 decimal places precision",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 814,
        "question": "Calculate the average moving power (in milliwatts) for each Logitech G502 HERO mouse during usage on 2023-10-01, given the coefficient of kinetic friction is 0.3 and the gravitational acceleration is taken as 9.81 m/s².",
        "query": "SELECT (0.3 * (m.Weight_Grams/1000) * 9.81 * u.Distance_Moved_Meters + 0.5 * (m.Weight_Grams/1000) * POW(u.Distance_Moved_Meters/(u.Usage_Duration_Minutes*60), 2)) / (u.Usage_Duration_Minutes*60) * 1000 AS power_mw FROM usage_records u JOIN mice m ON u.Mouse_Id = m.Mouse_Id WHERE m.Model = 'G502 HERO' AND DATE(u.Start_Time) = '2023-10-01';",
        "step": "【step1】: Join usage_records with mice table to access both usage metrics and product specifications, applying filters for model 'G502 HERO' and date '2023-10-01'.  【step2】: Calculate total energy expenditure using kinetic formula components: friction work (μ*m*g*d) + kinetic energy (0.5*m*v²), where velocity v = distance/(duration*60).  【step3】: Convert total energy to average power in milliwatts by dividing by total seconds (duration*60) and multiplying by 1000 for unit conversion.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 815,
        "question": "Calculate the 'energy efficiency cost-performance index' for each mouse model: (average lifespan × DPI) / (price × weight), and filter the top 3 models.",
        "query": "WITH IndexCalc AS (SELECT m.Model, (AVG(s.Sensor_Life_Hours) * m.Dpi) / (m.Price_Usd * m.Weight_Grams) AS efficacy_index FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id GROUP BY m.Model, m.Dpi, m.Price_Usd, m.Weight_Grams) SELECT Model, efficacy_index FROM IndexCalc ORDER BY efficacy_index DESC LIMIT 3;",
        "step": "【step1】: Join 'mice' and 'sensor_data' tables to calculate average sensor life per model.  【step2】: Compute the efficacy_index formula (avg_life × DPI) / (price × weight) for each model.  【step3】: Order results by efficacy_index descending and limit to top 3 models.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 816,
        "question": "Identify the mouse models that meet all the following criteria:  \n① Lift-off distance < 2mm  \n② Daily average clicks > 1000 times  \n③ Days since last calibration > 90 days",
        "query": "SELECT m.Model, MAX(s.Lift_Off_Distance_Mm) AS current_lift, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS daily_clicks, DATEDIFF(CURDATE(), MAX(s.Last_Calibration_Date)) AS days_since_calib FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id GROUP BY m.Model HAVING current_lift < 2 AND daily_clicks > 1000 AND days_since_calib > 90;",
        "step": "【step1】: Join mice, sensor_data, and usage_records tables on Mouse_Id to associate model information with sensor metrics and usage statistics  【step2】: Aggregate data by Model to calculate maximum lift-off distance, average daily clicks (total clicks/distinct usage days), and days since last calibration  【step3】: Apply HAVING clause to filter models meeting all three criteria: lift <2mm, daily clicks >1000, and calibration interval >90 days",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 817,
        "question": "Assuming the quantum sensor achieves 1,000,000 DPI and calculates the photon count per pixel for wireless mice, what is the result and does it violate the Heisenberg limit?",
        "query": "SELECT (6.626e-34 * 3e8) / (500e-9 * POWER(1e6/m.Dpi, 2)) AS photons_per_pixel, CASE WHEN (1e6/m.Dpi) < (6.626e-34/(2*PI())) THEN '突破海森堡极限' ELSE '理论可行' END AS quantum_status FROM mice m CROSS JOIN (SELECT 1e6 AS target_dpi) params WHERE m.Is_Wireless = 1;",
        "step": "【step1】: Perform cross join between 'mice' table and parameter subquery to obtain target_dpi value (1,000,000), while filtering wireless mice via WHERE m.Is_Wireless = 1  【step2】: Calculate photon count per pixel using quantum formula (h*c)/(λ*(target_dpi/m.Dpi)^2) with physical constants and device parameters  【step3】: Determine quantum status through CASE expression comparing pixel size (1e6/Dpi) to Heisenberg limit (ħ/2π), flagging '突破海森堡极限' when quantum bound is surpassed",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 818,
        "question": "Based on the Corsair Dark Core RGB Pro's weight of 133 grams and the formula for kinetic energy, calculate its kinetic energy.",
        "query": "SELECT 0.5 * (Weight_Grams / 1000.0) * POWER((400 * 0.0254), 2) AS Kinetic_Energy_Joules FROM mice WHERE Model = 'Dark Core RGB Pro';",
        "step": "【step1】: Retrieve weight (133g) and tracking speed (400 IPS) from 'mice' table filtered by model name.  【step2】: Convert units: grams to kilograms (÷1000), inches/s to meters/s (×0.0254).  【step3】: Calculate kinetic energy using ½mv² formula with converted values.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 819,
        "question": "Calculate the covariance between market share and profit per employee for manufacturers in each country, excluding those founded before 1994.",
        "query": "WITH FilteredData AS (SELECT Country, Market_Share_Percent, Profit_Usd / Employees AS Profit_Per_Employee FROM manufacturers WHERE Founded_year > 1993) SELECT Country, VARIANCE(Market_Share_Percent) AS Market_Share_Variance, (AVG(Market_Share_Percent * Profit_Per_Employee) - AVG(Market_Share_Percent) * AVG(Profit_Per_Employee)) AS Covariance FROM FilteredData GROUP BY Country ORDER BY Covariance DESC;",
        "step": "【step1】: Filter manufacturers founded after 1993 and calculate profit per employee  【step2】: Group by country to compute variance of market share and covariance between market share variance and profit-per-employee using statistical formula  【step3】: Sort results by covariance in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 820,
        "question": "Find wireless mouse models with battery life longer than their price (USD) and calculate their battery life per dollar value (hours/USD)",
        "query": "SELECT Model, Battery_Life_Hours, Price_Usd, Battery_Life_Hours / Price_Usd AS Value_Per_USD FROM mice WHERE Is_Wireless = 1 AND Battery_Life_Hours > Price_Usd;",
        "step": "【step1】: Filter wireless mice (Is_Wireless = 1) from the mice table  【step2】: Apply condition Battery_Life_Hours > Price_Usd to the filtered results  【step3】: Calculate Value_Per_USD (Battery_Life_Hours / Price_Usd) and select required columns (Model, Battery_Life_Hours, Price_Usd, Value_Per_USD)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 821,
        "question": "Assuming a mouse moves at 1% of the speed of light (2,997,924.58 m/s), calculate the number of data packets generated per second at 16,000 DPI (assuming a packet is reported for every displacement ≥1 pixel).",
        "query": "SELECT (2997924.58 / 0.0254) * 16000 / 1e6 AS Packets_Per_Second;",
        "step": "【step1】: Convert speed from meters per second to inches per second using 2997924.58 / 0.0254  【step2】: Multiply by DPI (16000) to calculate pixels moved per second  【step3】: Convert result to packets per second in millions by dividing by 1e6",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 822,
        "question": "Calculate the average power (in watts) consumed by the Logitech G502 HERO mouse for moving 1500.5 meters in the usage records of user ID=101, given that the energy consumption is 5000 joules and the usage time is 120 minutes.",
        "query": "SELECT Energy_Consumed_Joules / (Usage_Duration_Minutes * 60) AS power_watts FROM usage_records WHERE User_Id = 101 AND Mouse_Id = (SELECT Mouse_Id FROM mice WHERE Model = 'G502 HERO') AND Distance_Moved_Meters = 1500.5 AND Energy_Consumed_Joules = 5000 AND Usage_Duration_Minutes = 120;",
        "step": "【step1】: Execute subquery to retrieve Mouse_Id of 'G502 HERO' from mice table.  【step2】: Filter usage_records by User_Id=101, the retrieved Mouse_Id, Distance=1500.5m, Energy=5000J, and Duration=120min.  【step3】: Calculate power by dividing Energy_Consumed_Joules by total seconds (Duration*60) in the selected record.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 823,
        "question": "Calculate the composite score for each manufacturer, which is defined as (Revenue_Usd * 0.3 + Profit_Usd * 0.4 + Market_Share_Percent * 2 + Employees * 0.1) / 1000, rounded to 3 decimal places, and sort them in descending order based on this composite score.",
        "query": "SELECT Manufacturer_Name, ROUND((Revenue_Usd*0.3 + Profit_Usd*0.4 + Market_Share_Percent*2 + Employees*0.1)/1000, 3) AS composite_score FROM manufacturers ORDER BY composite_score DESC;",
        "step": "【step1】: Calculate the composite_score for each manufacturer using the formula (Revenue_Usd*0.3 + Profit_Usd*0.4 + Market_Share_Percent*2 + Employees*0.1)/1000.  【step2】: Apply the ROUND function to the composite_score to retain 3 decimal places.  【step3】: Sort the results by composite_score in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 824,
        "question": "Find all wireless mice where the nominal battery life in hours is less than the maximum recorded single usage duration for that model in hours.",
        "query": "SELECT m.Model, m.Battery_Life_Hours, (SELECT MAX(u.Usage_Duration_Minutes)/60 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id) AS max_usage_hours FROM mice m WHERE m.Is_Wireless = 1 AND m.Battery_Life_Hours < (SELECT MAX(u.Usage_Duration_Minutes)/60 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id);",
        "step": "【step1】: Filter all wireless mice (WHERE Is_Wireless = 1) from the mice table.  【step2】: For each mouse, calculate the maximum usage duration hour from usage_records (MAX(Usage_Duration_Minutes)/60) using a correlated subquery.  【step3】: Compare Battery_Life_Hours with the calculated max_usage_hours, retaining only records where Battery_Life_Hours < max_usage_hours as anomalies.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 825,
        "question": "Assuming a laboratory mouse sensor moves continuously at a maximum tracking speed of 450 inches per second for a distance of 3 light-years, calculate how many years it would theoretically take. (1 inch = 0.0254 meters, 1 light-year ≈ 9.461e+15 meters, neglecting relativistic effects)",
        "query": "SELECT (3 * 9.461e15) / (450 * 0.0254) / (365*24*3600) AS time_years FROM dual;",
        "step": "【step1】: Calculate total distance in inches by converting 3 light-years to meters (3 * 9.461e15) and then to inches (divided by 0.0254).  【step2】: Divide the total inches by tracking speed (450 IPS) to get seconds, then convert seconds to years by dividing by (365*24*3600).  【step3】: Output the final result via SELECT using the calculation chain without involving actual table data.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 826,
        "question": "Calculate the force (in newtons) generated when the Razer DeathAdder V2 mouse moves with a maximum acceleration of 50G.",
        "query": "SELECT (m.Weight_Grams/1000) * (50 * 9.8) AS force_newton FROM mice m WHERE m.Model = 'DeathAdder V2';",
        "step": "【step1】: Filter the mice table to find the specific DeathAdder V2 model record  【step2】: Calculate force using formula (converted_weight_kg * 50g_acceleration * 9.8m/s²)  【step3】: Not required for this simple single-table calculation",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 827,
        "question": "Calculate the 'DPI cost-performance index' for each manufacturer and price combination, where the formula is (maximum DPI / price) * 1000, and rank the top three by index in descending order.",
        "query": "SELECT ma.Manufacturer_Name, (MAX(m.Dpi)/m.Price_Usd)*1000 AS dpi_ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name, m.Price_Usd ORDER BY dpi_ratio DESC LIMIT 3;",
        "step": "【step1】: Join mice and manufacturers tables on Manufacturer_Id to associate each mouse with its manufacturer.  【step2】: Group results by Manufacturer_Name and Price_Usd, calculate the DPI-to-price ratio using (MAX(Dpi)/Price_Usd)*1000 for each group.  【step3】: Sort the results by the calculated ratio in descending order and limit to the top 3 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 828,
        "question": "Find all wired mice with a lift-off distance greater than 2mm and cable length less than 1.5 meters.",
        "query": "SELECT m.Model, s.Lift_Off_Distance_Mm, m.Cable_Length_Meters FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Is_Wireless = 0 AND s.Lift_Off_Distance_Mm > 2 AND m.Cable_Length_Meters < 1.5;",
        "step": "【step1】: Filter wired mice with cable length <1.5m from mice table using WHERE m.Is_Wireless = 0 AND m.Cable_Length_Meters < 1.5  【step2】: Join filtered mice with sensor_data table on Mouse_Id to access lift-off distance  【step3】: Apply final condition s.Lift_Off_Distance_Mm > 2 and select required fields (Model, Lift_Off_Distance_Mm, Cable_Length_Meters)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 829,
        "question": "Given that a mouse moves at the speed of light (299792458 m/s) and the distance per second is converted from inches to petabytes, calculate the displacement data per second (in PB).",
        "query": "SELECT (299792458 / 0.0254) * 8 / 1e15 AS data_pb FROM dual;",
        "step": "【step1】: Convert the speed from meters per second to inches per second by dividing 299792458 by 0.0254 (since 1 inch = 0.0254 meters).  【step2】: Multiply the converted speed (inches/second) by 8 to calculate the total data bits generated per second (assuming 8 bits per inch of movement).  【step3】: Convert the result from bits to petabytes by dividing by 1e15 (1 petabyte = 1e15 bytes, and the calculation assumes a direct conversion to PB without intermediate byte units).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 830,
        "question": "Calculate the kinetic energy (in joules) for the mouse model 'G502 HERO' when the user with ID=101 moves it a distance of 1500.5 meters at a constant speed of 0.8 m/s, using the mouse's weight in grams from the database.",
        "query": "SELECT 0.5 * (m.Weight_Grams/1000) * POWER(0.8, 2) AS kinetic_energy_joules FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id WHERE m.Model = 'G502 HERO' AND u.User_Id = 101 AND u.Distance_Moved_Meters = 1500.5;",
        "step": "【step1】: JOIN mice and usage_records tables using Mouse_Id to link mouse specifications with usage data.  【step2】: Filter records where Model='G502 HERO', User_Id=101, and Distance_Moved_Meters=1500.5 to isolate the specific usage scenario.  【step3】: Compute kinetic energy via formula 0.5*(Weight_Grams/1000)*velocity², converting grams to kilograms and using fixed 0.8m/s velocity.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 831,
        "question": "Statistics on the 'Profit per Employee Multiple' by manufacturer, calculated as: (Profit_Usd/Employees)/(SELECT AVG(Profit_Usd/Employees) FROM manufacturers), rounded to two decimal places and sorted in descending order by the multiple.",
        "query": "SELECT Manufacturer_Name, ROUND((Profit_Usd/Employees)/(SELECT AVG(Profit_Usd/Employees) FROM manufacturers), 2) AS profit_ratio FROM manufacturers ORDER BY profit_ratio DESC;",
        "step": "【step1】: Calculate each manufacturer's per-employee profit (Profit_Usd / Employees)  【step2】: Compute the global average of per-employee profit using a subquery (SELECT AVG(...))  【step3】: Divide individual per-employee profits by the global average, round results to 2 decimals, then sort descending by the ratio",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 832,
        "question": "Detect abnormal data where 'sensor lifespan is less than actual cumulative usage time', requiring association between the sensor_data and usage_records tables, with calculation SUM(Usage_Duration_Minutes)/60.0 > Sensor_Life_Hours.",
        "query": "SELECT s.*, t.total_hours FROM sensor_data s JOIN (SELECT Mouse_Id, SUM(Usage_Duration_Minutes)/60 AS total_hours FROM usage_records GROUP BY Mouse_Id) t ON s.Mouse_Id = t.Mouse_Id WHERE s.Sensor_Life_Hours < t.total_hours;",
        "step": "【step1】: Calculate the total actual usage hours for each mouse by aggregating usage_records (SUM(Usage_Duration_Minutes)/60) and group by Mouse_Id.  【step2】: Join sensor_data with the aggregated usage data using Mouse_Id to align sensor lifespan data with actual usage hours.  【step3】: Apply the filter condition WHERE s.Sensor_Life_Hours < t.total_hours to detect sensors with lifespan shorter than actual usage.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 833,
        "question": "Assume a certain space station uses a Razer mouse moving at 0.9 times the speed of light, maintaining a constant acceleration of 9.8 m/s². Calculate the time required (in years) to accelerate from rest to the target speed. Given: speed of light = 3e8 m/s, 1 year ≈ 3.15e7 seconds.",
        "query": "SELECT (0.9*3e8) / (20000*9.8) / 3.15e7 AS time_years FROM dual;",
        "step": "【step1】: Calculate target velocity (0.9c) → 0.9*3e8 = 2.7e8 m/s  【step2】: Compute acceleration in m/s² → 20000*9.8 = 196000 m/s²  【step3】: Derive time by dividing velocity by acceleration, then convert seconds to years → (2.7e8/196000)/3.15e7 ≈ 0.0437 years",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 834,
        "question": "Calculate the instantaneous power (in watts) generated by the Logitech G502 HERO mouse when used by user ID=101, based on a sensor acceleration of 40 m/s² during movement. The known mass is 121 grams, and the average speed is calculated as 1500.5 meters per 120 minutes.",
        "query": "SELECT ROUND((0.121 * 40 * 9.8) * (1500.5 / (120 * 60)), 4) AS Instantaneous_Power FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Logitech' AND mc.Model = 'G502 HERO' AND ur.User_ID = 101;",
        "step": "【step1】: Join tables (manufacturers, mice, usage_records) to filter records for Logitech's G502 HERO mouse used by User_ID=101  【step2】: Calculate average velocity in m/s: 1500.5 meters / (120 minutes * 60)  【step3】: Compute power using formula (mass * acceleration * gravity) * velocity, then round to 4 decimal places",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 835,
        "question": "Calculate the 'price dispersion' for each manufacturer's mice, where the formula is (highest price - lowest price) / AVG(Price_Usd), and rank it jointly with market share, keeping three decimal places.",
        "query": "SELECT mf.Manufacturer_Name, ROUND((MAX(mc.Price_Usd) - MIN(mc.Price_Usd)) / AVG(mc.Price_Usd), 3) AS price_dispersion, mf.Market_Share_Percent FROM manufacturers mf JOIN mice mc ON mf.Manufacturer_Id = mc.Manufacturer_Id GROUP BY mf.Manufacturer_Id ORDER BY price_dispersion DESC, mf.Market_Share_Percent DESC;",
        "step": "【step1】: Join the 'manufacturers' and 'mice' tables using Manufacturer_Id, grouping by Manufacturer_Id to calculate MAX(Price_Usd), MIN(Price_Usd), AVG(Price_Usd), and fetch Market_Share_Percent.  【step2】: Compute price dispersion using the formula (MAX - MIN)/AVG, round to 3 decimal places, and retain Market_Share_Percent.  【step3】: Sort results by price_dispersion (DESC) and Market_Share_Percent (DESC).",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 836,
        "question": "Identify sensors with 'abnormal calibration frequency', where Calibration_Count > Sensor_Life_Hours/100 (assuming 1 calibration is allowed per 100 hours of sensor life)",
        "query": "SELECT * FROM sensor_data WHERE Calibration_Count > (Sensor_Life_Hours / 100);",
        "step": "【step1】: Calculate the threshold value by dividing each sensor's 'Sensor_Life_Hours' by 100.  【step2】: Filter records in 'sensor_data' where 'Calibration_Count' exceeds the calculated threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 837,
        "question": "Assuming an observatory uses a Corsair mouse with 10^18 DPI to observe galaxies, calculate the minimum number of movements required to precisely position across the diameter of the observable universe (8.8e26 meters). If each movement generates 1KB of logs, find the total data volume over a millennium (in Yottabytes, where 1YB = 1e24GB).",
        "query": "SELECT (8.8e26 / (0.0254 / 1e18)) AS movement_times, ROUND(( (8.8e26 / (0.0254 / 1e18)) * 1 * 1000 * 3.154e7 * 1000 ) / 1e24, 3) AS data_yb;",
        "step": "【step1】: Calculate movement_times by dividing the observable universe diameter (8.8e26 meters) by the precision per movement (0.0254 meters/inch converted via 1e18 DPI: 0.0254 / 1e18 meters/dot).  【step2】: Compute total data in YB by multiplying movement_times by 1MB/log, 1000 years (converted to milliseconds: 1000 * 3.154e7 * 1000), then dividing by 1e24 (YB conversion).  【step3】: Round the final result to 3 decimal places using the ROUND() function.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 838,
        "question": "Calculate the change in momentum (in kg·m/s) when the Razer DeathAdder V2 mouse decelerates from its maximum tracking speed of 450 IPS to a complete stop, given its weight of 82 grams.",
        "query": "SELECT ROUND((82/1000) * (450*0.0254), 4) AS Momentum_Change FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Razer' AND mc.Model = 'DeathAdder V2';",
        "step": "【step1】: Join manufacturers, mice, and usage_records tables to link product specifications with usage data.  【step2】: Filter records where Manufacturer_Name is \"Razer\" and Model is \"DeathAdder V2\".  【step3】: Calculate momentum change using formula (Weight_Grams/1000) * (Tracking_Speed_Ips*0.0254) with unit conversions (grams→kg, inches→meters) and round to 4 decimal places.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 839,
        "question": "Calculate the compound annual growth rate (CAGR) of profits for each manufacturer since its founding, using the formula: ((Profit_Usd)^(1/(2023-Founded_year)) -1)*100. Retain two decimal places for the percentage result and sort in descending order by the growth rate.",
        "query": "SELECT Manufacturer_Name, ROUND((POWER(Profit_Usd, 1/(2023-Founded_year)) -1)*100, 2) AS CAGR FROM manufacturers ORDER BY CAGR DESC;",
        "step": "【step1】: Calculate the compound growth rate denominator (2023-Founded_year) and retrieve Profit_Usd for each manufacturer  【step2】: Apply CAGR formula with ROUND function to format results to 2 decimal places  【step3】: Sort results in descending order of calculated growth rate",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 840,
        "question": "Identify violation records where wireless mice lack battery data (Battery_Life_Hours is null) or wired mice have battery data (Battery_Life_Hours is not null)",
        "query": "SELECT * FROM mice WHERE (Is_Wireless=1 AND Battery_Life_Hours IS NULL) OR (Is_Wireless=0 AND Battery_Life_Hours IS NOT NULL);",
        "step": "【step1】: Filter wireless mice with missing battery data (Is_Wireless=1 AND Battery_Life_Hours IS NULL).  【step2】: Filter wired mice with non-null battery data (Is_Wireless=0 AND Battery_Life_Hours IS NOT NULL).  【step3】: Combine results from both filter conditions using OR operator to return all violating records.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 841,
        "question": "Assuming a quantum mouse has a DPI of 1e12, on a 32K resolution screen (30720×17280), to achieve precise control of a single pixel offset, calculate the minimum movement distance (in meters) and the annual data volume (in EB) generated, given 10 hours of daily usage and 6 movements per second.",
        "query": "SELECT (0.0254/1e6) AS Min_Movement_Distance, ROUND((30720*17280*10*6*3600*365*8 / 1e8), 2) AS Annual_Data_Volume_EB;",
        "step": "【step1】: Calculate minimum movement distance per pixel by converting 1 inch to meters (0.0254m) and dividing by 1e6 DPI: (0.0254/1e6)  【step2】: Determine per-movement data size as screen resolution (30720x17280) multiplied by 10 units per pixel  【step3】: Compute annual data volume by multiplying movements per second (6), hourly usage (3600s), daily usage (365 days), bit conversion factor (8), and scale to exabytes (1e8 divisor)",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "1",
        "idx": 842,
        "question": "Calculate whether the actual movement speed of the Corsair Dark Core RGB Pro mouse for user ID=103 exceeds the sensor's maximum tracking speed (400 IPS), given a movement distance of 1000.25 units and a usage duration of 120 minutes.",
        "query": "SELECT (1000.25 / (120 * 60)) / 0.0254 AS Actual_IPS, CASE WHEN (1000.25 / (120 * 60)) / 0.0254 > 400 THEN 'Exceeds Max Tracking Speed' ELSE 'Within Max Tracking Speed' END AS Speed_Status FROM usage_records ur JOIN mice mc ON ur.Mouse_ID = mc.Mouse_Id JOIN manufacturers mf ON mc.Manufacturer_Id = mf.Manufacturer_Id WHERE mf.Manufacturer_Name = 'Corsair' AND mc.Model = 'Dark Core RGB Pro' AND ur.User_ID = 103;",
        "step": "【step1】: Join usage_records with mice and manufacturers tables to filter Corsair's Dark Core RGB Pro mouse usage records for user 103  【step2】: Calculate actual IPS by converting 1000.25 meters to inches (divided by 0.0254) and dividing by total seconds (120×60)  【step3】: Compare calculated IPS against 400 threshold using CASE statement to determine speed status",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "2",
        "idx": 843,
        "question": "Calculate the 'Market Performance Index' for each manufacturer, formula: (Market_Share_Percent/100)*Profit_Usd/Employees, sort the results in descending order by the index and retain four decimal places.",
        "query": "SELECT Manufacturer_Name, ROUND((Market_Share_Percent / 100) * (Profit_Usd / Employees), 4) AS efficiency_index FROM manufacturers ORDER BY efficiency_index DESC;",
        "step": "【step1】: Select Manufacturer_Name, Market_Share_Percent, Profit_Usd, and Employees from the manufacturers table.  【step2】: Calculate the efficiency index using the formula (Market_Share_Percent/100) * (Profit_Usd/Employees) and round to 4 decimal places.  【step3】: Order the results by the calculated efficiency_index in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "3",
        "idx": 844,
        "question": "Detect products with the design flaw of 'high DPI low polling rate' (DPI > 15000 and Polling_Rate_Hz < 1000).",
        "query": "SELECT * FROM sensor_data WHERE Max_Dpi > 15000 AND Polling_Rate_Hz < 1000;",
        "step": "【step1】: Filter sensor_data records where Max_Dpi exceeds 15000.  【step2】: Apply additional filter to retain only records with Polling_Rate_Hz below 1000 Hz from the results of step 1.",
        "format": "MySQL"
    },
    {
        "db_id": "mouse",
        "type": "4",
        "idx": 845,
        "question": "Assuming a scientific research mouse has a DPI of 1e15, performs 1000 micro-movements per second on an 8K screen (7680×4320), calculate the data volume over a millennium (unit: BB, 1BB=1e30 bytes), with each record occupying 16 bytes.",
        "query": "SELECT (7680 * 4320 * 10 * 6 * 31536000 * 10) / 1e30 AS Data_Volume_BB;",
        "step": "【step1】: Calculate the total number of operations per second: 7680 (horizontal pixels) * 4320 (vertical pixels) * 10 (unknown multiplier) * 6 (unknown multiplier).  【step2】: Multiply by annual seconds (31,536,000) and duration multiplier (10 years) to get total operations.  【step3】: Convert to BB: Divide by 1e30 to calculate Data_Volume_BB.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 846,
        "question": "Calculate the energy efficiency (distance driven/power consumed) of each vehicle in the driving records, and return vehicles with energy efficiency <4 km/kWh and average speed >60 km/h, sorted in ascending order of energy efficiency.",
        "query": "SELECT v.Vehicle_Id, v.Model, ROUND(dr.Distance_Km / dr.Energy_Consumed_Kwh, 2) AS energy_efficiency, dr.Average_Speed_Kmh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Average_Speed_Kmh > 60 HAVING energy_efficiency < 4 ORDER BY energy_efficiency ASC;",
        "step": "【step1】: Join driving_records and vehicles tables via Vehicle_Id to associate driving data with vehicle models. Include calculation of energy_efficiency (Distance_Km / Energy_Consumed_Kwh) rounded to 2 decimal places.  【step2】: Apply WHERE clause to filter records with Average_Speed_Kmh > 60 first, then use HAVING clause to filter results where energy_efficiency < 4 after calculation.  【step3】: Sort final results by energy_efficiency in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 847,
        "question": "Calculate the average daily revenue (total charging fees divided by operating days) for each charging station. Return the top 3 stations with daily revenue exceeding $500 and more than 5 charging piles, sorted in descending order by daily revenue.",
        "query": "SELECT cs.Station_Name, ROUND(SUM(cr.Cost_Usd) / GREATEST(DATEDIFF(MAX(cr.End_Time), MIN(cr.Start_Time)), 1), 2) AS daily_revenue, cs.Number_Of_Chargers FROM charging_stations cs JOIN charging_records cr ON cs.Station_Id = cr.Station_Id GROUP BY cs.Station_Id HAVING daily_revenue > 500 AND cs.Number_Of_Chargers > 5 ORDER BY daily_revenue DESC LIMIT 3;",
        "step": "【step1】: Join charging_stations and charging_records tables, calculate total revenue and operation days per station using SUM(cr.Cost_Usd) and DATEDIFF between earliest start_time and latest end_time (minimum 1 day).  【step2】: Filter stations with daily_revenue > 500 and number_of_chargers > 5 using HAVING clause after grouping by station_id.  【step3】: Sort results by daily_revenue descending and return top 3 records using ORDER BY and LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 848,
        "question": "Identify vehicles with a battery capacity >100kWh but having at least one charging session consuming <20kWh, and return the last charging record date and charging type for these vehicles.",
        "query": "SELECT v.Vehicle_Id, v.Model, (SELECT MAX(cr.End_Time) FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id) AS last_charge_date, (SELECT cr.Charging_Type FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id ORDER BY cr.End_Time DESC LIMIT 1) AS last_charge_type FROM vehicles v WHERE v.Battery_Capacity_Kwh > 100 AND EXISTS (SELECT 1 FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id AND cr.Energy_Consumed_Kwh < 20);",
        "step": "【step1】: Filter vehicles with battery capacity >100 kWh and at least one charging record with energy consumed <20 kWh using WHERE and EXISTS clauses.  【step2】: Retrieve the latest charge date for each qualifying vehicle via correlated subquery (MAX(End_Time)).  【step3】: Obtain the charging type from the most recent charging record using a correlated subquery with ORDER BY End_Time DESC and LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 849,
        "question": "Assuming the Model S (100kWh battery) is used on the surface of Mars, calculate the time required to charge from 10% to 80% (assuming the charging power is increased to 500%, with the heat loss formula: Q_loss = 0.2 × A × (T + 273)^3, where A = 1m²).",
        "query": "WITH RECURSIVE charging_sim AS (SELECT 10.0 AS soc, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time, 1 AS phase UNION ALL SELECT CASE phase WHEN 1 THEN LEAST(soc + 5.0, 50.0) ELSE LEAST(soc + 0.5, 80.0) END, elapsed_time + (100 * CASE phase WHEN 1 THEN 5.0 ELSE 0.5 END) / GREATEST(600 - 0.2 * POW((-60 + 273), 3), 1), CASE WHEN soc >= 50.0 THEN 2 ELSE phase END FROM charging_sim WHERE soc < 80.0 ) SELECT MAX(elapsed_time) AS total_hours, CONCAT(FLOOR(MAX(elapsed_time)), '小时', ROUND((MAX(elapsed_time)%1)*60) , '分钟') AS formatted_time FROM charging_sim;",
        "step": "【step1】: Initialize recursive CTE with starting parameters (10% SOC, 0 hours elapsed, phase 1) and define charging logic with temperature-adjusted power calculation using Mars surface temp (-60°C) in Q_loss formula.  【step2】: Perform iterative calculation with two charging phases (5% increments until 50% SOC, then 0.5% increments) while dynamically adjusting effective charging power: (500% base power × 100kWh) - Q_loss (0.1×2×(-60+273)^3).  【step3】: Accumulate time for each SOC increment and convert final MAX(elapsed_time) to hours-minutes format after reaching 80% SOC.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 850,
        "question": "Calculate the average charging efficiency for each charging station under different charging types, and return charging stations with efficiency <85% and charging count >10.",
        "query": "SELECT cs.Station_Name, cr.Charging_Type, ROUND(AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * TIME_TO_SEC(TIMEDIFF(cr.End_Time, cr.Start_Time))/3600)) * 100, 2) AS efficiency_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, cr.Charging_Type HAVING efficiency_rate < 85 AND charge_count > 10 ORDER BY efficiency_rate ASC;",
        "step": "【step1】: Join charging_records with charging_stations via Station_Id, calculate charging efficiency for each record using (Energy_Consumed_Kwh / (Charging_Speed_Kw * Charging_Time_Hours)) × 100, then compute average efficiency and count records grouped by Station_Id and Charging_Type  【step2】: Apply HAVING clause to filter groups where efficiency_rate < 85% AND charge_count > 10  【step3】: Sort final results by efficiency_rate in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 851,
        "question": "Calculate the average daily mileage of vehicles for each manufacturer, and filter for manufacturers with average daily mileage >150km and vehicle count ≥3.",
        "query": "SELECT v.Manufacturer, ROUND(SUM(dr.Distance_Km) / COUNT(DISTINCT DATE(dr.Start_Time)), 2) AS daily_avg_km, COUNT(DISTINCT v.Vehicle_Id) AS vehicle_count FROM vehicles v JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id GROUP BY v.Manufacturer HAVING daily_avg_km > 150 AND vehicle_count >= 3 ORDER BY daily_avg_km DESC;",
        "step": "【step1】: Join vehicles and driving_records tables to associate driving data with manufacturers through Vehicle_Id  【step2】: Group by Manufacturer, calculate average daily km (SUM(Distance_Km)/COUNT distinct dates) and COUNT distinct Vehicle_Id  【step3】: Apply HAVING clause to filter manufacturers with daily_avg_km > 150 and vehicle_count ≥3, then sort by descending daily_avg_km",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 852,
        "question": "Identify vehicles that perform ultra-fast charging in high-temperature environments, showing the last charge date and battery health for those with battery health below 90.",
        "query": "SELECT v.Vehicle_Id, v.Model, MAX(cr.End_Time) AS last_charge_date, v.Battery_Health FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE cr.Temperature_Celsius > 30 AND cr.Charging_Type = 'Ultra-Fast' AND v.Battery_Health < 90 GROUP BY v.Vehicle_Id;",
        "step": "【step1】: Perform INNER JOIN between 'vehicles' and 'charging_records' tables using Vehicle_Id to associate vehicles with their charging data.  【step2】: Apply filters:  - Temperature_Celsius > 30  - Charging_Type = 'Ultra-Fast'  - Battery_Health < 90  【step3】: Group results by Vehicle_Id and retrieve the MAX(End_Time) as the most recent qualifying charge record for each vehicle.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 853,
        "question": "Calculate the time required to fully charge a 120kWh battery in Arctic conditions with a charging power of 120kW and thermal losses.",
        "query": "WITH RECURSIVE polar_charging AS (SELECT 0 AS soc, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time, 120 * 0.2 * 0.6 AS actual_power, 0.2 * 5 * POW(-50 + 50, 2) AS heat_loss UNION ALL SELECT soc + 5, elapsed_time + (100 * 5) / GREATEST(actual_power - (heat_loss / 1000), 1), actual_power, 0.2 * 5 * POW((-50 + (soc/100)*130) + 50, 2) FROM polar_charging WHERE soc < 100 ) SELECT MAX(elapsed_time) AS total_hours, CONCAT(FLOOR(MAX(elapsed_time)), '小时', ROUND((MAX(elapsed_time) - FLOOR(MAX(elapsed_time))) * 60), '分钟') AS formatted_time FROM polar_charging;",
        "step": "【step1】: Initialize recursive CTE with base charging parameters  Create polar_charging CTE using initial SOC=0%, charge power adjusted for 20% efficiency loss (120kW→120*0.2*0.6=14.4kW), and thermal loss formula accounting for -50°C ambient temperature through quadratic temperature compensation (0.2*5*POW(-50+50,2)).【step2】: Recursively calculate charging increments  For each 5% SOC increase:  1. Update actual_power by subtracting heat-derived power loss (heat_loss/1000) with safety floor at 1kW using GREATEST()  2. Calculate time increment: (100kWh*5% capacity) / adjusted_power = (5kWh / actual_power) hours  3. Update heat_loss using temperature formula: 0.2*5*POW((-50 + (soc/100)*130) +50,2) where battery temp rises by 1.3°C per SOC% gain.【step3】: Aggregate and format final results  Extract MAX(elapsed_time) from all recursive iterations, then convert decimal hours to HH小时MM分钟 format using FLOOR() for hours and scaled ROUND((decimal_part)*60) for minutes.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 854,
        "question": "Calculate the energy efficiency degradation rate for each vehicle when driving under snowy or heatwave conditions, using the formula: (normal weather efficiency - extreme weather efficiency) / normal weather efficiency × 100%. Return the vehicle models with a degradation rate >15%. Note: Normal weather efficiency is the average of driving records under sunny or cloudy conditions, while extreme weather efficiency is under snowy or heatwave conditions.",
        "query": "WITH normal_efficiency AS (SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS normal_eff FROM driving_records dr WHERE dr.Weather_Conditions IN ('Sunny', 'Cloudy') GROUP BY dr.Vehicle_Id), extreme_efficiency AS (SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS extreme_eff FROM driving_records dr WHERE dr.Weather_Conditions IN ('Snow', 'Heatwave') GROUP BY dr.Vehicle_Id) SELECT v.Model, ROUND((ne.normal_eff - ee.extreme_eff) / ne.normal_eff * 100, 2) AS efficiency_decay_rate FROM vehicles v JOIN normal_efficiency ne ON v.Vehicle_Id = ne.Vehicle_Id JOIN extreme_efficiency ee ON v.Vehicle_Id = ee.Vehicle_Id WHERE (ne.normal_eff - ee.extreme_eff) / ne.normal_eff * 100 > 15 ORDER BY efficiency_decay_rate DESC;",
        "step": "【step1】: Calculate normal temperature efficiency (20-30℃) by averaging energy efficiency (Distance_Km/Energy_Consumed_Kwh) per vehicle from driving_records with Sunny/Cloudy weather conditions.  【step2】: Calculate extreme temperature efficiency (<-10℃ or >40℃) by averaging energy efficiency per vehicle from driving_records with Snow/Heatwave weather conditions.  【step3】: Join both efficiency datasets with vehicles table, calculate decay rate using ((normal_eff - extreme_eff)/normal_eff)*100, filter results >15%, and sort by decay rate descending.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 855,
        "question": "Calculate the time slot utilization rate for each charging station (total actual charging duration/maximum possible charging duration). Group by week using strftime('%W', Start_Time) and return charging stations with utilization rates >80% for two consecutive weeks. Maximum possible duration = operating hours × number of charging piles, where operating hours are 24 hours for 24-hour stations or the daily opening hours multiplied by 7 for non-24-hour stations.",
        "query": "WITH weekly_utilization AS (SELECT cs.Station_Id, WEEK(cr.Start_Time) AS week_num, SUM(TIME_TO_SEC(TIMEDIFF(cr.End_Time, cr.Start_Time))) / (cs.Number_Of_Chargers * CASE WHEN cs.Is_24_Hours = 1 THEN 604800 ELSE TIME_TO_SEC(TIMEDIFF(cs.Opening_Hours, '00:00:00')) * 7 END) AS utilization_rate FROM charging_stations cs JOIN charging_records cr ON cs.Station_Id = cr.Station_Id GROUP BY cs.Station_Id, week_num), consecutive_weeks AS (SELECT Station_Id, week_num, utilization_rate, LAG(utilization_rate) OVER (PARTITION BY Station_Id ORDER BY week_num) AS prev_week_rate FROM weekly_utilization) SELECT DISTINCT cs.Station_Name FROM consecutive_weeks cw JOIN charging_stations cs ON cw.Station_Id = cs.Station_Id WHERE cw.utilization_rate > 0.8 AND cw.prev_week_rate > 0.8;",
        "step": "【step1】: Calculate weekly utilization rates for each station by joining charging_stations and charging_records. Compute actual charging duration sum and divide by maximum possible duration (24h×604800s if 24-hour operation, else Opening_Hours×7 days converted to seconds×number_of_chargers). Group by Station_Id and week(Start_Time).  【step2】: Use LAG() window function to retrieve previous week's utilization rate for each station ordered chronologically via PARTITION BY Station_Id, creating consecutive_week pairs comparison capability.  【step3】: Filter stations where both current and previous week's utilization rates exceed 80%, then retrieve distinct station names by joining with charging_stations for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 856,
        "question": "Identify driving routes with altitude variations (elevation gain plus loss) exceeding 500 meters where the actual energy consumption surpasses the theoretical value (Battery_Capacity_Kwh × (End_Battery_Percentage - Start_Battery_Percentage) / 100) by more than 20%, and return the record ID, elevation change details, weather conditions, theoretical energy, and actual energy associated with these records.",
        "query": "SELECT dr.Record_Id, CONCAT('起点海拔变化:', dr.Elevation_Gain_M, '米; 终点海拔变化:', dr.Elevation_Loss_M, '米') AS elevation_change, dr.Weather_Conditions, v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100 AS theoretical_energy, dr.Energy_Consumed_Kwh AS actual_energy FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE (dr.Elevation_Gain_M + dr.Elevation_Loss_M) > 500 AND dr.Energy_Consumed_Kwh > 1.2 * (v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100);",
        "step": "【step1】: JOIN driving_records with vehicles to calculate theoretical energy consumption using battery capacity and percentage difference  【step2】: Apply elevation change filter (Elevation_Gain_M + Elevation_Loss_M > 500)  【step3】: Filter records where actual energy consumption exceeds 120% of theoretical value, and format elevation change description",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 857,
        "question": "Assuming that during a coronal mass ejection event (with cosmic radiation intensity 100 times the normal level), the failure rate of cameras in autonomous vehicles (Is_Autonomous=1) increases to 50% per hour, calculate the probability of having at least 8 hours of camera availability during a 10-hour trip (using the Poisson distribution for simulation). Formula: P(X≥8)=1-Σ(e^(-λ)*(λ^k)/k!), k=0 to 7, where λ=5.",
        "query": "WITH RECURSIVE poisson_cdf AS (SELECT 0 AS k, EXP(-5) * POWER(5, 0) / 1 AS prob, EXP(-5) * POWER(5, 0) / 1 AS cdf UNION ALL SELECT k + 1, EXP(-5) * POWER(5, k + 1) / (k + 1), cdf + EXP(-5) * POWER(5, k + 1) / (k + 1) FROM poisson_cdf WHERE k < 7 ) SELECT ROUND(1 - MAX(cdf), 3) AS probability_at_least_8_hours FROM poisson_cdf;",
        "step": "【step1】: Create a recursive CTE to generate k values from 0 to 7 using UNION ALL, calculating individual Poisson probabilities (λ=5) and cumulative distribution function (CDF)  【step2】: Calculate each term's probability using formula EXP(-5)*POWER(5,k)/k! and accumulate CDF through recursive addition  【step3】: Select 1 minus the maximum cumulative probability (CDF at k=7) to get P(X≥8), then round to 3 decimal places using ROUND()",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 858,
        "question": "Calculate the potential energy recovery efficiency (recovered energy/theoretical potential energy) for each vehicle during braking, and return driving records where the efficiency is <50% and the altitude drop is >200m. Formula: Theoretical potential energy = mgh = Weight_Kg × 9.8 × Elevation_Loss_M, Recovered energy = Energy_Consumed_Kwh × battery efficiency coefficient (assumed to be 0.9) × 3600000 (for unit conversion from kWh to Joules).",
        "query": "SELECT dr.Record_Id, v.Model, ROUND(v.Weight_Kg * 9.8 * dr.Elevation_Loss_M, 2) AS theoretical_energy, ROUND(dr.Energy_Consumed_Kwh * 0.9 * 3.6e6, 2) AS recovered_energy, ROUND((dr.Energy_Consumed_Kwh * 0.9 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS efficiency_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Elevation_Loss_M > 200 AND (dr.Energy_Consumed_Kwh * 0.9 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 50 ORDER BY efficiency_rate ASC;",
        "step": "【step1】: Join 'driving_records' with 'vehicles' via Vehicle_Id to access vehicle weight and driving data  【step2】: Calculate theoretical_energy (Weight_Kg×9.8×Elevation_Loss_M) and recovered_energy (Energy_Consumed_Kwh×0.9×3.6e6) with unit conversions  【step3】: Filter records with elevation_loss >200m and efficiency_rate <50%, then sort results by ascending efficiency_rate",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 859,
        "question": "Identify charging stations where the utilization rate exceeds 90% for at least 3 consecutive hours with intervals less than 5 hours, and return the names of such charging stations along with the start and end dates of occurrence. Use recursive CTE to analyze the time intervals.",
        "query": "WITH hourly_usage AS (SELECT cs.Station_Id, HOUR(cr.Start_Time) AS hour_slot, COUNT(*) / cs.Number_Of_Chargers AS utilization_rate, DATE(cr.Start_Time) AS date FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, date, hour_slot HAVING utilization_rate > 0.9), peak_groups AS (SELECT *, hour_slot - ROW_NUMBER() OVER (PARTITION BY Station_Id, date ORDER BY hour_slot) AS grp FROM hourly_usage) SELECT cs.Station_Name, MIN(date) AS start_date, MAX(date) AS end_date FROM peak_groups pg JOIN charging_stations cs ON pg.Station_Id = cs.Station_Id GROUP BY pg.Station_Id, pg.grp HAVING COUNT(*) >= 3 AND MAX(hour_slot) - MIN(hour_slot) < 5;",
        "step": "【step1】: Calculate hourly utilization rates over 90% by joining charging_records and charging_stations, grouping by station, date, and hour.  【step2】: Identify continuous time groups using ROW_NUMBER() to generate grp markers (hour_slot - row_num) for consecutive high-utilization hours.  【step3】: Filter groups with ≥3 consecutive hours (COUNT*) and max-min hour_slot <5 (intervals <2h), then join charging_stations to output station names and date ranges.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 860,
        "question": "Identify records where vehicles are charged in low-temperature environments (Temperature_Celsius < 5°C) with ultra-fast charging (Charging_Type='Ultra-Fast') and exhibit a battery health decline of more than 2. Return the vehicle model, charging station operator, health drop value, and charge time.",
        "query": "WITH health_change AS (SELECT cr.Vehicle_Id, cr.End_Time, v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY cr.Vehicle_Id ORDER BY cr.End_Time) AS health_drop FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Temperature_Celsius < 5 AND cr.Charging_Type = 'Ultra-Fast') SELECT v.Model, cs.Operator, hc.health_drop, cr.End_Time AS charge_time FROM health_change hc JOIN charging_records cr ON hc.Vehicle_Id = cr.Vehicle_Id AND hc.End_Time = cr.End_Time JOIN vehicles v ON hc.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE hc.health_drop > 2;",
        "step": "【step1】: Calculate battery health drop for ultra-fast charging sessions in low-temperature environment using LAG window function to compare consecutive records partitioned by vehicle  【step2】: Join filtered charging records with vehicle and station tables to retrieve model/operator information  【step3】: Filter results where computed health drop exceeds 2% threshold and finalize output columns",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 861,
        "question": "Assuming a zero-gravity environment in a space station (cooling only by radiation), calculate the maximum safe charging power for the Model S (100kWh) when the external temperature is 3K (heat loss Q=εσA(T^4-T_env^4), ε=0.95, σ=5.67e-8, A=3m², T_limit=60℃).",
        "query": "SELECT 0.95 * 5.67e-8 * 3 * (POW(60+273, 4) - POW(3, 4)) / 0.9 AS max_power_kw;",
        "step": "【step1】: Convert temperatures to Kelvin by adding 273 to Celsius values (60°C→333K, -270°C→3K)  【step2】: Calculate thermal radiation power using Q=εσA(T⁴-T_env⁴) with substituted values  【step3】: Convert result to kW and apply 0.9 efficiency factor (divide by 1000 then multiply by 0.9)",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 862,
        "question": "Calculate the actual energy storage efficiency during the charging process for each vehicle (theoretical stored energy / actual consumed electricity × 100), and return records with efficiency <90% and charging type as fast charging ('Fast' or 'Ultra-Fast'). Formula: Theoretical stored energy = Battery_Capacity_Kwh × (Final_Battery_Percentage - Initial_Battery_Percentage) / 100.",
        "query": "SELECT cr.Record_Id, v.Model, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Charging_Type IN ('Fast', 'Ultra-Fast') AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 90 ORDER BY efficiency_rate ASC;",
        "step": "【step1】: Perform INNER JOIN between charging_records and vehicles tables using Vehicle_Id to access battery capacity and model information.  【step2】: Calculate efficiency_rate using formula ((Battery_Capacity × (Final-Initial%)/100) / Energy_Consumed) × 100, then filter records with Charging_Type in ('Fast','Ultra-Fast') and efficiency_rate < 90%.  【step3】: Sort results by efficiency_rate ascending and select required fields (Record_Id, Model, rounded efficiency_rate).",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 863,
        "question": "Identify the dates with the phenomenon of 'charging peak overlap' (where at least 3 charging stations within the same day experience a utilization rate > 95% within one hour), and return these dates along with the number of involved charging stations.",
        "query": "WITH hourly_peak AS (SELECT cs.Station_Id, DATE(cr.Start_Time) AS date, HOUR(cr.Start_Time) AS hour_slot, COUNT(*) / cs.Number_Of_Chargers AS utilization_rate FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, date, hour_slot HAVING utilization_rate > 0.95), peak_dates AS (SELECT date, COUNT(DISTINCT Station_Id) AS peak_station_count FROM hourly_peak GROUP BY date HAVING COUNT(DISTINCT Station_Id) >= 3) SELECT date, peak_station_count FROM peak_dates ORDER BY date DESC;",
        "step": "【step1】: Calculate hourly utilization rates per station by joining charging records with station data, filtering time slots with >95% utilization (COUNT(records)/number_of_chargers)  【step2】: Aggregate results by date to count distinct stations meeting peak conditions, filtering dates with ≥3 qualifying stations  【step3】: Output final dates and station counts sorted in descending chronological order",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 864,
        "question": "Find records of fast charging (Charging_Type='Fast') with charging efficiency less than 85% during rainy weather (Weather_Conditions='Rainy'), and return the operators and geographical locations of these charging stations along with their efficiency rates.",
        "query": "SELECT cs.Operator, cs.Location, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast' AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 85;",
        "step": "【step1】:【Join tables to combine charging records, vehicle battery capacity, and station details】  【step2】:【Filter records with Rainy weather, Fast charging type】  【step3】:【Calculate charging efficiency and apply the ＜85% filter, then return operator and location】",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 865,
        "question": "Assuming during a solar flare eruption (when the electromagnetic shielding of the charging station fails), the charging power fluctuates by ±50%, what is the probability that the charging time for a Model S (100kWh) to charge from 10% to 80% exceeds 1.5 times the average charging time?",
        "query": "WITH RECURSIVE monte_carlo AS (SELECT 1 AS iter, ROUND(70 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1 + (RAND() - 0.5) * 1)), 2) AS charge_time UNION ALL SELECT iter + 1, ROUND(70 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1 + (RAND() - 0.5) * 1)), 2) FROM monte_carlo WHERE iter < 1000) SELECT COUNT(*) * 100.0 / 1000 AS probability_over_1_5t FROM monte_carlo WHERE charge_time > 1.5 * (70 / (SELECT AVG(Charging_Speed_Kw) FROM charging_stations));",
        "step": "【step1】: Generate 1000 Monte Carlo iterations with randomized charging speeds (±50% fluctuation) using recursive CTE, calculating charge_time = 70kWh / (avg_speed * (1 ± 0.5))  【step2】: Compute baseline charging time without fluctuations using 70kWh / avg_charging_speed from charging_stations table  【step3】: Calculate probability distribution by comparing Monte Carlo results against 1.5×baseline time, using COUNT()/1000 to determine percentage exceeding threshold",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 866,
        "question": "Calculate the potential energy recovery rate (recovered electricity / theoretical potential energy) during downhill driving for each vehicle, and return records with a recovery rate < 45% and an elevation drop > 300m. Formula: Theoretical potential energy = Weight_Kg × 9.8 × Elevation_Loss_M, Recovered electricity = Energy_Consumed_Kwh × 0.93 × 3.6e6 (assuming 93% conversion efficiency).",
        "query": "SELECT dr.Record_Id, v.Model, ROUND((dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS recovery_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Elevation_Loss_M > 300 AND (dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 45 ORDER BY recovery_rate ASC;",
        "step": "【step1】: Join 'driving_records' with 'vehicles' using Vehicle_Id to access weight and energy data  【step2】: Filter records with elevation loss >300m and calculate recovery rate using formula (Energy_Consumed_Kwh*0.93*3.6e6)/(Weight_Kg*9.8*Elevation_Loss_M)*100  【step3】: Apply recovery rate <45% filter and sort results by recovery_rate ascending",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 867,
        "question": "Identify vehicles with continuous 3-day growth in charging volume (Energy_Consumed_Kwh Day N < Day N+1 < Day N+2), and return their model, last charging location, and the growth slope.",
        "query": "WITH daily_charge AS (SELECT cr.Vehicle_Id, DATE(cr.Start_Time) AS charge_date, SUM(cr.Energy_Consumed_Kwh) AS daily_energy, MAX(cs.Station_Id) AS last_station_id FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cr.Vehicle_Id, charge_date), growth_trend AS (SELECT Vehicle_Id, charge_date, daily_energy, last_station_id, LAG(daily_energy, 2) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n, LAG(daily_energy, 1) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n_plus_1, daily_energy AS day_n_plus_2 FROM daily_charge), valid_growth AS (SELECT Vehicle_Id, MAX(last_station_id) AS last_station_id, (MAX(day_n_plus_2) - MIN(day_n)) / 2 AS slope FROM growth_trend WHERE day_n < day_n_plus_1 AND day_n_plus_1 < day_n_plus_2 GROUP BY Vehicle_Id) SELECT v.Model, cs.Location AS last_location, vg.slope FROM valid_growth vg JOIN vehicles v ON vg.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON vg.last_station_id = cs.Station_Id;",
        "step": "【step1】: Aggregate daily energy consumption per vehicle with last used charging station by joining charging_records and charging_stations, grouping by Vehicle_Id and date.  【step2】: Calculate 3-day energy sequence using LAG window function partitioned by Vehicle_Id ordered chronologically, creating day_n (current-2), day_n_plus_1 (current-1), day_n_plus_2 (current).  【step3】: Filter vehicles with day_n < day_n_plus_1 < day_n_plus_2 patterns, compute slope as (max_day3 - min_day1)/2 duration, then join with vehicles and charging_stations to retrieve model/location details.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 868,
        "question": "Find records of ultra-fast charging (Ultra-Fast) conducted in high-temperature environments (Temperature_Celsius > 35°C) with charging efficiency < 80%, and return the station names, operating hours, whether they have a canopy, and their efficiency rates.",
        "query": "SELECT cs.Station_Name, cs.Opening_Hours, cs.Is_Covered, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 AND cr.Charging_Type = 'Ultra-Fast' AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 80;",
        "step": "【step1】: Join charging_records with vehicles and charging_stations using Vehicle_Id and Station_Id respectively.  【step2】: Filter records where Temperature_Celsius >35, Charging_Type is 'Ultra-Fast', and calculate efficiency rate using ((Battery_Capacity_Kwh * (Final_Battery_Percentage - Initial_Battery_Percentage)/100) / Energy_Consumed_Kwh *100) with a <80% threshold.  【step3】: Select Station_Name, Opening_Hours, Is_Covered, and round the efficiency rate to two decimal places for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 869,
        "question": "Assuming the construction of a charging station in the permanently shadowed regions of the Moon (temperature -238°C), calculate the maximum safe charging power in kilowatts for a vehicle using the given radiative heat transfer formula with emissivity 0.85, area 2.5 m², ambient temperature 35 K, and surface temperature 283 K.",
        "query": "SELECT ROUND((0.85 * 5.67e-8 * 2.5 * (POW(283, 4) - POW(35, 4))) / 0.9, 2) AS max_power_kw;",
        "step": "【step1】: Calculate thermal radiation limit using Stefan-Boltzmann law: (5.67e-8 * 2.5 * (283⁴ - 35⁴))  【step2】: Apply safety factor and surface emissivity: 0.85 * [step1_result]  【step3】: Adjust for charging efficiency and convert units: ROUND([step2_result]/0.9/1000, 2) → max_power_kw",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 870,
        "question": "Compute the charging efficiency loss rate (1 - actual energy delivered / theoretical energy capacity) for each charging station in a high-temperature environment (Temperature_Celsius > 35°C), and return stations with a loss rate exceeding 20% and charging sessions count greater than 5.",
        "query": "SELECT cs.Station_Name, ROUND((1 - AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * TIME_TO_SEC(TIMEDIFF(cr.End_Time, cr.Start_Time)) / 3600))) * 100, 2) AS loss_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 GROUP BY cs.Station_Id HAVING loss_rate > 20 AND charge_count > 5 ORDER BY loss_rate DESC;",
        "step": "【step1】: Join \"charging_records\" and \"charging_stations\" using Station_Id, filter records with Temperature_Celsius > 35°C using WHERE clause.  【step2】: Calculate theoretical charging energy (Charging_Speed_Kw * time duration) vs actual Energy_Consumed_Kwh. Compute loss_rate as (1 - AVG(actual/theoretical)) × 100.  【step3】: Group by Station_Id, apply HAVING filters for loss_rate > 20% and charge_count > 5, then sort results by loss_rate descending.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 871,
        "question": "Identify vehicles exhibiting a 'weekend effect' in charging volume (where the total charging volume on weekends increases by more than 30% compared to weekdays), and return the vehicle model along with the ratio of weekend to weekday charging volume.",
        "query": "WITH low_efficiency_records AS (SELECT cr.Station_Id, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 75) SELECT cs.Operator, cs.Is_Covered, COUNT(*) AS record_count FROM charging_stations cs JOIN low_efficiency_records ler ON cs.Station_Id = ler.Station_Id WHERE cs.Location IN (SELECT Location FROM charging_stations WHERE ST_Y(Location) > 2000) GROUP BY cs.Operator, cs.Is_Covered;",
        "step": "【step1】: Calculate daily charging amounts categorized by weekday/weekend for each vehicle by joining charging_records with vehicles table, using CASE WHEN to determine weekday/weekend based on Start_Time.  【step2】: Compute the ratio of weekend-to-weekday averages using aggregated values from step1, ensuring grouping by Vehicle_Id and Model.  【step3】: Filter results where the ratio exceeds 1.3 and return Model alongside the ratio by wrapping step2 in a final SELECT with WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 872,
        "question": "Find the operators of charging stations at altitudes above 2000 meters with efficiency below 75%, whether they have a roof, and the count of such records.",
        "query": "WITH high_altitude_stations AS (SELECT cs.Station_Id, cs.Operator, cs.Is_Covered FROM charging_stations cs WHERE EXISTS (SELECT 1 FROM (SELECT ST_GeomFromText('POINT(0 0)') AS Location, 2500 AS Altitude UNION ALL SELECT ST_GeomFromText('POINT(1 1)') AS Location, 1500 AS Altitude) AS ad WHERE ST_Distance_Sphere(cs.Location, ad.Location) < 1000 AND ad.Altitude > 2000 AND ST_Y(cs.Location) BETWEEN -90 AND 90 AND ST_X(cs.Location) BETWEEN -180 AND 180)), low_efficiency_records AS (SELECT cr.Station_Id, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100 / cr.Energy_Consumed_Kwh * 100), 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 75) SELECT has.Operator, has.Is_Covered, COUNT(*) AS record_count FROM high_altitude_stations has JOIN low_efficiency_records ler ON has.Station_Id = ler.Station_Id GROUP BY has.Operator, has.Is_Covered",
        "step": "【step1】:【Filter high-altitude stations】Identify charging stations located in areas with altitude >2000m using spatial join with the altitude dataset, ensuring valid geographic coordinate ranges.  【step2】:【Calculate low-efficiency records】Compute charging efficiency for each record by comparing energy consumed to effective battery gain, filtering records with efficiency <75%.  【step3】:【Aggregate results】Join the filtered stations with low-efficiency records, then group by operator and shelter status to count qualifying incidents.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 873,
        "question": "Assuming charging the ET7 (150kWh) from 20% to 90% charge, calculate the maximum safe power in kW.",
        "query": "SELECT ROUND(0.2 * 3 * POW(50 - 4, 1.5), 2) AS max_power_kw;",
        "step": "【step1】: Calculate the temperature-adjusted pressure coefficient using (50 - 4) where 50 represents pressure conversion (100atm/2) and 4℃ is environmental temperature  【step2】: Apply exponential formula with POW(46, 1.5) and multiply by technical coefficients (0.2 for battery capacity delta and 3 as safety factor)  【step3】: Round final result to 2 decimal places using ROUND() function for max_power_kw presentation",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 874,
        "question": "Calculate the energy density (consumed electricity/acceleration time) of each vehicle during extreme acceleration (0-100 km/h in less than 2 seconds), and return records where the density is greater than 500 kWh/s and the battery health decline is more than 5%.",
        "query": "WITH health_change AS (SELECT dr.Vehicle_Id, dr.End_Time, v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY dr.Vehicle_Id ORDER BY dr.End_Time) AS health_drop FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id) SELECT dr.Record_Id, v.Model, ROUND(dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600), 2) AS energy_density, hc.health_drop FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN health_change hc ON dr.Vehicle_Id = hc.Vehicle_Id AND dr.End_Time = hc.End_Time WHERE v.Acceleration_0_To_100_Sec < 2 AND dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600) > 500 AND hc.health_drop > 5;",
        "step": "【step1】: Calculate the battery health drop using LAG window function to compare current and previous battery health status partitioned by vehicle and ordered by time.  【step2】: Join driving_records, vehicles, and health_change CTE using vehicle_id and end_time, while calculating energy density (energy consumed divided by acceleration time converted to hours).  【step3】: Filter records where acceleration time <2s, energy density >500kWh/s, and health drop exceeds 5% using WHERE clause conditions.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 875,
        "question": "Identify dates with the phenomenon of 'phantom charging' (charging volume > battery capacity × 300% and no corresponding driving record), and return these dates along with vehicle IDs.",
        "query": "WITH abnormal_charge AS (SELECT cr.Vehicle_Id, DATE(cr.Start_Time) AS charge_date, cr.Energy_Consumed_Kwh FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Energy_Consumed_Kwh > 3 * v.Battery_Capacity_Kwh), no_driving_records AS (SELECT ac.Vehicle_Id, ac.charge_date FROM abnormal_charge ac LEFT JOIN driving_records dr ON ac.Vehicle_Id = dr.Vehicle_Id AND DATE(dr.Start_Time) = ac.charge_date WHERE dr.Record_Id IS NULL) SELECT Vehicle_Id, charge_date FROM no_driving_records;",
        "step": "【step1】: Filter charging records where energy consumed exceeds 300% battery capacity by joining charging_records with vehicles using Vehicle_Id. Extract Vehicle_Id, charge date (DATE(Start_Time)), and Energy_Consumed_Kwh.  【step2】: Left join the abnormal_charge results with driving_records on Vehicle_Id and matching charge/driving dates. Filter records where no driving_records exist (dr.Record_Id IS NULL).  【step3】: Final SELECT retrieves distinct Vehicle_Id and charge_date from filtered records meeting both excess charge and missing driving criteria.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 876,
        "question": "Find records where the vehicles used autonomous driving (Is_Autonomous=1) during blizzard weather (Weather_Conditions='Blizzard') with an average speed >100 km/h, and return the manufacturers of these vehicles, whether the charging stations are covered (Is_Covered), and the count of such records per manufacturer and coverage status.",
        "query": "SELECT v.Manufacturer, cs.Is_Covered, COUNT(*) AS record_count FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE dr.Weather_Conditions = 'Blizzard' AND v.Is_Autonomous = 1 AND dr.Average_Speed_Kmh > 100 GROUP BY v.Manufacturer, cs.Is_Covered;",
        "step": "【step1】: Join driving_records with vehicles, charging_records, and charging_stations tables using Vehicle_Id and Station_Id, filtering records where Weather_Conditions='Blizzard', Is_Autonomous=1, and Average_Speed_Kmh>100  【step2】: Group the filtered results by Manufacturer (from vehicles) and Is_Covered (from charging_stations)  【step3】: Calculate the count of records per group using COUNT(*) and return Manufacturer, Is_Covered, and record_count",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 877,
        "question": "Assuming a charging station is built at the edge of the event horizon of the central black hole in the Milky Way, what is the subjective time in hours and the Earth time in hours for a Model S to fully charge?",
        "query": "SELECT v.Model, v.Charging_Time_Hours / 707 AS subjective_time_hours, v.Charging_Time_Hours AS earth_time_hours FROM vehicles v WHERE v.Model = 'Model S';",
        "step": "【step1】: Filter records in vehicles table to only include 'Model S' using WHERE clause  【step2】: Calculate time dilation ratio by dividing Charging_Time_Hours by 707 and output both values with aliases",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 878,
        "question": "Based on the Energy_Consumed_Kwh from the charging_records table and the Battery_Capacity_Kwh from the vehicles table, calculate the charging efficiency of Tesla Model S in charging record 1 (assuming a battery charging loss rate of 5%), where the initial and final battery percentages and energy consumed are available.",
        "query": "SELECT ROUND((v.Battery_Capacity_Kwh * (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) * (1 - 0.05)) / NULLIF(c.Energy_Consumed_Kwh, 0) * 100, 2) AS Charging_Efficiency FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Record_Id = 1 AND v.Model = 'Model S' AND c.Final_Battery_Percentage IS NOT NULL AND c.Initial_Battery_Percentage IS NOT NULL AND c.Energy_Consumed_Kwh IS NOT NULL;",
        "step": "【step1】:Join charging_records and vehicles tables via Vehicle_Id, filter by Record_Id=1, Model='Model S' and non-null percentage/energy values  【step2】:Calculate theoretical energy required using (Battery_Capacity × (Final% - Initial%) × 0.95)  【step3】:Compute efficiency by dividing theoretical energy by actual Energy_Consumed_Kwh, multiply by 100 and round to 2 decimals",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 879,
        "question": "Calculate the Pearson correlation coefficient between the cost per kilowatt-hour (Cost_Per_Kwh) and charging speed (Charging_Speed_Kw) for all charging stations, then sort in descending order by the absolute value of the correlation coefficient.",
        "query": "WITH StationStats AS ( SELECT Cost_Per_Kwh, Charging_Speed_Kw, (Cost_Per_Kwh - AVG(Cost_Per_Kwh) OVER ()) * (Charging_Speed_Kw - AVG(Charging_Speed_Kw) OVER ()) AS Covariance, POWER(Cost_Per_Kwh - AVG(Cost_Per_Kwh) OVER (), 2) AS VarX, POWER(Charging_Speed_Kw - AVG(Charging_Speed_Kw) OVER (), 2) AS VarY FROM charging_stations ) SELECT ROUND(SUM(Covariance) / (SQRT(SUM(VarX)) * SQRT(SUM(VarY))), 4) AS Pearson_Correlation FROM StationStats ORDER BY ABS(Pearson_Correlation) DESC",
        "step": "【step1】:【Calculate covariance components and variance terms for each charging station using window functions to get global averages】  【step2】:【Aggregate components (sum covariance, sum variances) and compute Pearson coefficient using formula: covariance/(std_x * std_y)】  【step3】:【Order results by absolute correlation coefficient descending】",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 880,
        "question": "Identify charging stations where the charging cost exceeds $0.25 per kWh and the charging speed is below 100kW, and calculate their daily revenue (assuming the daily charging volume per station = Charging_Speed × Number_Of_Chargers × 8h).",
        "query": "SELECT Station_Id, ROUND(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 8, 2) AS Daily_Revenue FROM charging_stations WHERE Cost_Per_Kwh > 0.25 AND Charging_Speed_Kw < 100",
        "step": "【step1】: Filter charging stations where cost per kWh exceeds $0.25 and charging speed is below 100kW  【step2】: Calculate daily revenue by multiplying cost per kWh, charging speed, number of chargers, and 8 operational hours  【step3】: Round the calculated revenue to two decimal places and project Station_Id with formatted daily revenue",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 881,
        "question": "Assuming a charging station is powered entirely by solar energy with a solar panel efficiency of 20%, an average of 6 hours of sunlight per day, and an energy storage efficiency of 90%, calculate the theoretically maximum charging capacity (in kWh) that it can support.",
        "query": "SELECT Station_Id, ROUND(Charging_Speed_Kw * 6 * 0.2 * 0.9, 2) AS Max_Charging_Capacity FROM charging_stations",
        "step": "【step1】: Retrieve the charging speed (Charging_Speed_Kw) for each station from the charging_stations table  【step2】: Calculate theoretical solar energy production by multiplying charging speed with daily sunlight hours (6), solar panel efficiency (0.2), and storage efficiency (0.9)  【step3】: Round the result to two decimal places and alias as Max_Charging_Capacity",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 882,
        "question": "Based on the Energy_Consumed_Kwh and Elevation_Gain_M in the driving_records table, calculate the energy efficiency of ET7 in driving record 2 (unit: km/kWh), taking into account the impact of elevation changes (increasing energy consumption by 0.5kWh for every 100 meters of elevation gain).",
        "query": "SELECT ROUND(d.Distance_Km / (d.Energy_Consumed_Kwh + (d.Elevation_Gain_M/100*0.5)), 2) AS Energy_Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 2 AND v.Model = 'ET7'",
        "step": "【step1】: JOIN driving_records and vehicles tables using Vehicle_Id to access both energy consumption and vehicle specifications  【step2】: Filter records where Record_Id = 2 (specific driving record) and Model = 'ET7' (specific vehicle model)  【step3】: Calculate elevation-adjusted energy efficiency via ROUND(Distance_Km/(Energy_Consumed_Kwh + (Elevation_Gain_M/100*0.5)),2)",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 883,
        "question": "Establish the operational efficiency (total cost per day per charger) for each charging station operator, calculate the standard deviation of this efficiency across operators, and build a polynomial regression model (including squared terms) with the average charging speed.",
        "query": "WITH Efficiency AS ( SELECT Operator, SUM(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 24)/SUM(Number_Of_Chargers) AS Operational_Efficiency, AVG(Charging_Speed_Kw) AS Avg_Charging_Speed FROM charging_stations GROUP BY Operator ) SELECT Operator, STDDEV(Operational_Efficiency) OVER() AS Std_Efficiency, Operational_Efficiency, POWER(Operational_Efficiency, 2) AS Efficiency_Squared, Avg_Charging_Speed, POWER(Avg_Charging_Speed, 2) AS Speed_Squared FROM Efficiency ORDER BY Operator;",
        "step": "【step1】: Calculate each operator's operational efficiency (total revenue divided by number of chargers) and average charging speed using a CTE with GROUP BY aggregation.  【step2】: Compute the global standard deviation of operational efficiency across all operators using STDDEV window function, and generate quadratic terms for regression (Operational_Efficiency² and Avg_Charging_Speed²).  【step3】: Finalize results by ordering alphabetically based on Operator.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 884,
        "question": "Identify charging records that violate safety regulations for charging facilities (charging stations that do not operate 24/7 with no canopy and have charging amounts exceeding 50kWh on rainy days), and calculate their risk coefficient (risk coefficient = charging amount × temperature / 100).",
        "query": "SELECT c.Record_Id, ROUND(c.Energy_Consumed_Kwh * c.Temperature_Celsius / 100, 2) AS Risk_Factor FROM charging_records c JOIN charging_stations s ON c.Station_Id = s.Station_Id WHERE s.Is_24_Hours = 0 AND s.Is_Covered = 0 AND c.Weather_Conditions = 'Rainy' AND c.Energy_Consumed_Kwh > 50",
        "step": "【step1】: Join charging_records with charging_stations using Station_Id to access station properties  【step2】: Filter records where stations aren't 24-hour, have no cover, weather is rainy, and energy exceeds 50kWh  【step3】: Calculate risk factor via (Energy_Consumed_Kwh × Temperature_Celsius)/100 and round to 2 decimals",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 885,
        "question": "Assuming a charging station has a charging speed of 1MW (1000kW) per charger, calculate the impact load on the regional power grid for each station, assuming a simultaneous usage rate of 80% and a power factor of 0.9.",
        "query": "SELECT Station_Id, ROUND(1000 * Number_Of_Chargers * 0.8 / 0.9, 2) AS Grid_Impact FROM charging_stations",
        "step": "【step1】: Retrieve Station_Id and Number_Of_Chargers from charging_stations table  【step2】: Calculate raw grid impact using formula (1000 × Chargers × 0.8) / 0.9  【step3】: Apply ROUND() function to format result with 2 decimal places as Grid_Impact",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 886,
        "question": "Based on the Weight_Kg and Distance_Km from the driving_records table and the Weight_Kg from the vehicles table, calculate the kinetic energy conversion efficiency of BYD Han EV in driving record 3 (considering the change in gravitational potential energy due to altitude variation, g=9.8m/s²).",
        "query": "SELECT ROUND( ( (0.5 * v.Weight_Kg * POWER((d.Distance_Km/(TIMESTAMPDIFF(HOUR, d.Start_Time, d.End_Time))/3.6), 2)) + (v.Weight_Kg * 9.8 * d.Elevation_Gain_M/1000) ) / (d.Energy_Consumed_Kwh * 3600000) * 100, 2 ) AS Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 3 AND v.Manufacturer = 'BYD' AND v.Model = 'Han EV'",
        "step": "【step1】: JOIN driving_records and vehicles tables to obtain weight, elevation gain, and energy consumption data for BYD Han EV's specific driving record.  【step2】: Calculate vehicle speed using TimeDiff (converted to seconds) and distance traveled, then compute kinetic energy (0.5mv²) and gravitational potential energy (mgh).  【step3】: Sum both energy values, divide by energy consumed (converted to joules via ×3,600,000), then calculate efficiency percentage with ROUND(...,2).",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 887,
        "question": "Calculate the Spearman rank correlation coefficient between the number of chargers (Number_Of_Chargers) and charging speed (Charging_Speed_Kw) for each operator (Operator), and sort the results in descending order by the absolute value of the correlation coefficient.",
        "query": "WITH ranked_data AS ( SELECT Operator, Number_Of_Chargers, Charging_Speed_Kw, RANK() OVER (PARTITION BY Operator ORDER BY Number_Of_Chargers) AS rank_chargers, RANK() OVER (PARTITION BY Operator ORDER BY Charging_Speed_Kw) AS rank_speed FROM charging_stations WHERE Number_Of_Chargers IS NOT NULL AND Charging_Speed_Kw IS NOT NULL ), diff_data AS ( SELECT Operator, POWER(rank_chargers - rank_speed, 2) AS d_squared FROM ranked_data ), correlation_data AS ( SELECT Operator, 1 - (6 * SUM(d_squared)) / (COUNT(*) * (POWER(COUNT(*), 2) - 1)) AS spearman_correlation FROM diff_data GROUP BY Operator ) SELECT Operator, spearman_correlation FROM correlation_data ORDER BY ABS(spearman_correlation) DESC;",
        "step": "【step1】: Rank charging stations by Number_of_Chargers and Charging_Speed_Kw within each Operator group, filtering out NULL values.  【step2】: Calculate squared differences between paired ranks (d_squared) for each station.  【step3】: Compute Spearman correlation per Operator using the formula \\(1 - \\frac{6\\sum{d^2}}{n(n^2-1)}\\), then sort results by absolute correlation value descending.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 888,
        "question": "Identify charging records that violate the GB/T 27930 standard (battery temperature >40°C during fast charging and charging amount >80% of battery capacity), and calculate their risk index as the rounded value of (temperature × percentage increase)/100.",
        "query": "SELECT c.Record_Id, ROUND( ((c.Final_Battery_Percentage - c.Initial_Battery_Percentage)/100 * v.Battery_Capacity_Kwh * c.Temperature_Celsius) / v.Battery_Capacity_Kwh, 2 ) AS Risk_Index FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Charging_Type = 'Fast' AND c.Temperature_Celsius > 40 AND (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) > 80",
        "step": "【step1】: Perform JOIN operation between charging_records (c) and vehicles (v) tables using Vehicle_Id to access battery capacity  【step2】: Apply triple filtering conditions: Fast charging type, temperature >40°C, and charge percentage difference >80%  【step3】: Calculate risk index using formula ((charge_diff% × battery_capacity × temperature)/battery_capacity) with rounding to 2 decimals",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 889,
        "question": "Assuming a wireless charging roadway achieves 1000kW dynamic charging power and 95% efficiency, calculate the theoretical multiple of improvement in vehicle range for the driving record with ID 3.",
        "query": "SELECT v.Vehicle_Id, ROUND( (v.Range_Km + (1000*0.95*1)/(d.Energy_Consumed_Kwh/d.Distance_Km)) / v.Range_Km, 2 ) AS Range_Boost FROM vehicles v JOIN driving_records d ON v.Vehicle_Id = d.Vehicle_Id WHERE d.Record_Id = 3",
        "step": "【step1】: Perform INNER JOIN between vehicles and driving_records tables using Vehicle_Id to combine vehicle's original range with specific driving energy consumption data (filtered by Record_Id=3).  【step2】: Calculate theoretical added range from wireless charging: (1000kW * 0.95 efficiency * 1 hour) divided by energy consumption per km (Energy_Consumed_Kwh/Distance_Km).  【step3】: Compute final range boost ratio by adding original range to calculated wireless charging range, then divide by original range, and round to 2 decimal places.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 890,
        "question": "Calculate the average power of Tesla vehicles during fast charging and derive the charging efficiency (actual charging energy/theoretical maximum energy), incorporating the impact of temperature on battery internal resistance (assuming internal resistance R=0.05Ω·(25/Temperature_Celsius)).",
        "query": "SELECT cr.Vehicle_Id, ROUND(cr.Energy_Consumed_Kwh / TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time), 2) AS P_avg_kW, ROUND((cr.Energy_Consumed_Kwh * 3600000) / (POWER(400,2) * TIMESTAMPDIFF(SECOND, cr.Start_Time, cr.End_Time) * 0.05*(25/cr.Temperature_Celsius)/3600), 4) AS Efficiency_Rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE v.Manufacturer = 'Tesla' AND cr.Charging_Type = 'Fast';",
        "step": "【step1】: Filter Tesla vehicles' fast charging records by joining charging_records and vehicles tables using Vehicle_Id, with conditions Manufacturer='Tesla' AND Charging_Type='Fast'.  【step2】: Calculate average charging power (P_avg_kW) using Energy_Consumed_Kwh divided by time difference in hours between Start_Time and End_Time.  【step3】: Derive efficiency rate by comparing actual energy (Energy_Consumed_Kwh*3600000) to theoretical maximum energy (400² * time_seconds * temperature-adjusted resistance R=0.05*(25/Temperature_Celsius)/3600), incorporating unit conversions for consistency.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 891,
        "question": "Calculate the benefit ratio (sum of distance driven times range divided by sum of energy consumed times cost) for each vehicle model under sunny conditions, and return the top 3 models with the highest ratios.",
        "query": "WITH CostBenefit AS (SELECT v.Manufacturer, v.Model, SUM(dr.Distance_Km * v.Range_Km) / SUM(cr.Energy_Consumed_Kwh * cr.Cost_Usd) AS Benefit_Ratio FROM driving_records dr JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE dr.Weather_Conditions = 'Sunny' GROUP BY v.Manufacturer, v.Model) SELECT * FROM (SELECT *, RANK() OVER(ORDER BY Benefit_Ratio DESC) AS Ranking FROM CostBenefit) sub WHERE Ranking <= 3;",
        "step": "【step1】: Create a CTE (CostBenefit) to calculate the benefit ratio by joining driving_records, charging_records, and vehicles. Filter for sunny weather conditions, group by manufacturer and model, and compute the ratio as (SUM(Distance_Km * Range_Km) / SUM(Energy_Consumed_Kwh * Cost_Usd)).  【step2】: Use a subquery to apply RANK() window function over the CTE results, ordering by Benefit_Ratio in descending order to assign rankings.  【step3】: Filter the ranked results to retain only entries where the ranking is 3 or lower (top 3 benefit ratios).",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 892,
        "question": "Identify abnormal records where the charging start time is earlier than the opening time or the charging end time is later than the closing time in non-24-hour charging stations.",
        "query": "SELECT cr.Record_Id, cs.Station_Name, cs.Opening_Hours, cr.Start_Time FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cs.Opening_Hours != '00:00-23:59' AND (TIME(cr.Start_Time) < STR_TO_DATE(SUBSTRING_INDEX(cs.Opening_Hours, '-', 1), '%H:%i') OR TIME(cr.End_Time) > STR_TO_DATE(SUBSTRING_INDEX(cs.Opening_Hours, '-', -1), '%H:%i'));",
        "step": "【step1】: Perform INNER JOIN between charging_records and charging_stations on Station_Id  【step2】: Filter stations where Opening_Hours isn't 24-hour format (Opening_Hours != '00:00-23:59')  【step3】: Check time violations using string-time conversion:           - Parse opening time (first part of Opening_Hours)           - Compare Start_Time with parsed opening time           - Parse closing time (second part of Opening_Hours)           - Compare End_Time with parsed closing time",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 893,
        "question": "Assuming a charging station charges at a power of 10 MW (which is 10,000 kW, equivalent to 66 times the current maximum of 150 kW), calculate the time required to accelerate a 50-ton vehicle to 0.1 times the speed of light, and verify whether this violates the law of mass-energy conservation.",
        "query": "SELECT ROUND((0.5 * 50000 * POW(29979245.8,2)) / (10000000), 2) AS Time_Seconds, ROUND((0.5 * 50000 * POW(29979245.8,2)) / (50000 * POW(299792458,2)), 12) AS MassEnergy_Ratio FROM DUAL;",
        "step": "【step1】: Calculate kinetic energy time: Divide the vehicle's relativistic kinetic energy (0.5*50000kg*(0.1c)²) by charging power (10,000kW), converting units to seconds  【step2】: Compute mass-energy ratio: Compare relativistic kinetic energy (0.5mv²) to rest energy (mc²) where v=0.1c, using Einstein's mass-energy equivalence  【step3】: Validate physics compliance: Verify mass-energy ratio (≈0.005) remains <<1, confirming energy conversions don't violate conservation laws through non-relativistic approximation",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 894,
        "question": "Calculate the conversion efficiency of potential energy difference caused by altitude changes into actual energy consumption for vehicles driving in rainy conditions (considering gravitational acceleration and mechanical energy losses).",
        "query": "WITH RainyDrives AS ( SELECT dr.Record_Id, v.Weight_Kg, dr.Elevation_Gain_M - dr.Elevation_Loss_M AS elevation_diff_m, dr.Energy_Consumed_Kwh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Weather_Conditions = 'Rainy' ) SELECT Record_Id, ROUND( (Weight_Kg * 9.8 * elevation_diff_m / 1000) / (Energy_Consumed_Kwh * 3600000) * 100, 2 ) AS efficiency_percent FROM RainyDrives WHERE Energy_Consumed_Kwh > 0;",
        "step": "【step1】: Filter and join data: Select rainy driving records with vehicle weight, calculate elevation difference by (Elevation_Gain_M - Elevation_Loss_M) from driving_records joined with vehicles on Vehicle_Id.  【step2】: Prepare energy values: Extract Weight_Kg, calculated elevation_diff_m, and Energy_Consumed_Kwh from the filtered dataset.  【step3】: Calculate efficiency: Compute conversion efficiency using formula [(Weight×9.8×elevation_diff)/1000] / (Energy×3,600,000) ×100, rounding to 2 decimals, while excluding zero-energy records.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 895,
        "question": "Calculate the operational efficiency ratio of each operator's fast charging stations during peak hours (18:00-22:00): (Total revenue) / (Number of charging piles × Total operating hours)",
        "query": "WITH PeakHours AS ( SELECT cs.Operator, cs.Number_Of_Chargers, SUM(cr.Energy_Consumed_Kwh * cs.Cost_Per_Kwh) AS total_revenue, SUM(TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time)) AS total_hours FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Charging_Type = 'Fast' AND HOUR(cr.Start_Time) BETWEEN 18 AND 22 GROUP BY cs.Operator, cs.Number_Of_Chargers ) SELECT Operator, ROUND(total_revenue / (Number_Of_Chargers * total_hours), 2) AS efficiency_ratio, RANK() OVER(ORDER BY (total_revenue / (Number_Of_Chargers * total_hours)) DESC) AS efficiency_rank FROM PeakHours;",
        "step": "【step1】: Filter fast charging records during peak hours (18:00-22:00), join with charging_stations to aggregate total revenue (Energy_Consumed_Kwh * Cost_Per_Kwh) and total operational hours (summed using TIMESTAMPDIFF) per operator and charger count.  【step2】: Calculate efficiency ratio by dividing total revenue by the product of charger count and total hours, then round to 2 decimal places.  【step3】: Apply RANK() window function to sort operators by descending efficiency ratio for final ranking.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 896,
        "question": "Identify vehicles with abnormal battery capacity to range ratio (Industry standard should meet Range_Km ≥ Battery_Capacity_Kwh × 5)",
        "query": "WITH RangeAnalysis AS ( SELECT v.Vehicle_Id, v.Manufacturer, v.Model, v.Battery_Capacity_Kwh, v.Range_Km, dr.End_Battery_Percentage FROM vehicles v LEFT JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id WHERE v.Range_Km < v.Battery_Capacity_Kwh * 5 ) SELECT Vehicle_Id, Manufacturer, Model, Battery_Capacity_Kwh, Range_Km, ROUND(Range_Km / Battery_Capacity_Kwh, 2) AS actual_range_factor, End_Battery_Percentage FROM RangeAnalysis;",
        "step": "【step1】: Filter vehicles violating industry standard (Range_Km < Battery_Capacity_Kwh×5)  【step2】: Left join driving_records to capture end battery percentage (including vehicles without driving records)  【step3】: Calculate actual range factor ratio and select required columns with rounding",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 897,
        "question": "Assuming a vehicle travels continuously at 900 km/h, calculate the endurance in hours and determine if it is less than 1 hour, labeling the result as 'Breakthrough' if so, otherwise 'Safe'.",
        "query": "WITH PhysicsConstants AS ( SELECT 1.225 AS air_density, 2.5 AS frontal_area, 900 / 3.6 AS speed_mps ), VehicleEnergy AS ( SELECT Battery_Capacity_Kwh * 1000 AS battery_joules FROM vehicles WHERE Model = 'Model S' LIMIT 1 ), AirResistance AS ( SELECT 0.5 * air_density * frontal_area * POWER(speed_mps, 3) AS power_watts FROM PhysicsConstants ) SELECT power_watts, battery_joules / (power_watts * 3600) AS endurance_hours, CASE WHEN battery_joules / (power_watts * 3600) < 1 THEN '突破' ELSE '安全' END AS status FROM AirResistance, VehicleEnergy;",
        "step": "【step1】: Calculate physics constants and convert speed to m/s (900km/h → 250m/s), define air density (1.225 kg/m³) and frontal area (2.5m²)  【step2】: Retrieve Model S's battery capacity (convert kWh to joules via *1000*3600) and compute air resistance power using formula 0.5*ρ*A*v³  【step3】: Compare energy endurance (battery_joules ÷ (power_watts*3600)) with threshold (1 hour), use CASE to determine status ('突破'/'安全')",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 898,
        "question": "Calculate the torque distribution ratio between the front and rear motors for four-wheel-drive vehicles driving on snowy terrain, taking into account the vehicle's weight distribution and motor efficiency differences.",
        "query": "WITH SnowDrives AS ( SELECT dr.Record_Id, v.Weight_Kg, dr.Elevation_Gain_M, dr.Average_Speed_Kmh, 0.6 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.9 AS torque_front, 0.4 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.85 AS torque_rear FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE v.Drivetrain = 'AWD' AND dr.Weather_Conditions = 'Snow' ) SELECT Record_Id, ROUND(torque_front / torque_rear, 2) AS torque_ratio FROM SnowDrives;",
        "step": "【step1】: Filter AWD vehicles with snow driving records by joining driving_records and vehicles tables  【step2】: Calculate front/rear torque using weight distribution (60/40 split), gravity (9.8), friction coefficient (0.3), and motor efficiencies (0.9 front/0.85 rear)  【step3】: Compute torque ratio by dividing front torque by rear torque with 2 decimal rounding",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 899,
        "question": "Calculate the service efficiency for each charging station: (adjusted energy consumption) / (number of chargers × parking fee), and rank by quarter.",
        "query": "WITH ServiceEfficiency AS ( SELECT cs.Station_Id, cs.Number_Of_Chargers, cs.Parking_Fee_Usd, cs.Is_Solar_Powered, QUARTER(cr.Start_Time) AS quarter, SUM(cr.Energy_Consumed_Kwh * IF(cs.Is_Solar_Powered, 1.2, 1)) AS adjusted_energy FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, cs.Number_Of_Chargers, cs.Parking_Fee_Usd, cs.Is_Solar_Powered, quarter ) SELECT Station_Id, quarter, ROUND(adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd), 2) AS efficiency_ratio, RANK() OVER(PARTITION BY quarter ORDER BY adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd) DESC) AS efficiency_rank FROM ServiceEfficiency;",
        "step": "【step1】: Join charging_records with charging_stations to calculate quarterly-adjusted energy (Energy_Consumed_Kwh multiplied by 1.2 for solar-powered stations) and group by station attributes and quarter.  【step2】: Compute efficiency ratio per station per quarter using the formula (adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd)), rounding to two decimal places.  【step3】: Apply window function RANK() to rank stations within each quarter based on efficiency_ratio in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 900,
        "question": "Detect abnormal battery health conditions in fast charging records (normal fast charging should meet SOC rate ≤ 70%/hour, battery temperature ≤ 40℃).",
        "query": "WITH FastChargeAnalysis AS ( SELECT cr.Record_Id, cr.Temperature_Celsius, (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time) AS soc_rate FROM charging_records cr WHERE cr.Charging_Type = 'Fast' ) SELECT Record_Id, soc_rate, Temperature_Celsius, CASE WHEN soc_rate > 70 OR Temperature_Celsius > 40 THEN '异常' ELSE '正常' END AS health_status FROM FastChargeAnalysis;",
        "step": "【step1】: Create CTE to filter fast charging records and calculate hourly SOC rate using (Final_Battery_Percentage - Initial_Battery_Percentage)/TIMESTAMPDIFF(HOUR)  【step2】: Select Record_Id, calculated soc_rate, and Temperature_Celsius from the CTE  【step3】: Apply CASE statement to flag records with soc_rate >70% per hour OR temperature >40°C as '异常'",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 901,
        "question": "Assuming charging in an absolute zero (-273°C) environment, calculate the total energy loss due to quantum tunneling effects for each charging record and determine if it exceeds the quantum limit.",
        "query": "WITH QuantumConstants AS ( SELECT 1.0545718e-34 AS h_bar, 1e-9 AS barrier_thickness, 5 * 1.6e-19 AS barrier_energy ), TunnelingProbability AS ( SELECT EXP(-2 * barrier_thickness * SQRT(2 * 9.11e-31 * barrier_energy) / h_bar) AS p_tunnel FROM QuantumConstants ), EnergyLoss AS ( SELECT cr.Record_Id, cr.Energy_Consumed_Kwh * 1000 * p_tunnel AS energy_loss_joules FROM charging_records cr, TunnelingProbability ) SELECT Record_Id, energy_loss_joules, CASE WHEN energy_loss_joules > 100 THEN '超过量子极限' ELSE '安全' END AS quantum_status FROM EnergyLoss;",
        "step": "【step1】: QuantumConstants CTE defines physical constants (Planck's reduced constant, barrier thickness, and barrier energy) as static values.  【step2】: TunnelingProbability CTE calculates quantum tunneling probability using exponential decay formula from Step1's constants.  【step3】: EnergyLoss CTE joins charging_records with tunneling probabilities, converts energy units (kWh→J), and calculates loss. Final SELECT adds quantum_status classification based on energy threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 902,
        "question": "Calculate the temperature rise due to Joule heating during fast charging and the resulting efficiency loss percentage.",
        "query": "WITH ChargingPhysics AS (SELECT cr.Record_Id, cr.Energy_Consumed_Kwh, cs.Charging_Speed_Kw, cr.Temperature_Celsius, (cs.Charging_Speed_Kw * 1000 / 400) AS I, (1.68e-8 * 5) / (PI() * POW(0.005, 2)) AS R, (POW(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (PI() * POW(0.005, 2)) * TIMESTAMPDIFF(SECOND, cr.Start_Time, cr.End_Time)) / 3.6e6 AS Q, ((POW(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (PI() * POW(0.005, 2)) * TIMESTAMPDIFF(SECOND, cr.Start_Time, cr.End_Time)) / 3.6e6 * 3.6e6) / (100 * 385) AS ΔT FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Charging_Type = 'fast') SELECT Record_Id, ΔT AS Temperature_Rise, (Energy_Consumed_Kwh - Q) / Energy_Consumed_Kwh * 100 AS Efficiency_Loss_Percent FROM ChargingPhysics",
        "step": "【step1】:Calculate electrical parameters (current I and resistance R) using charging speed and conductor properties (resistivity, length, cross-sectional area)  【step2】:Compute Joule heating (Q) using I²Rt formula and temperature rise (ΔT) through thermal capacity formula Q=mcΔT  【step3】:Derive efficiency loss percentage by comparing thermal losses (Q) with total energy consumed, establishing temperature-dependent energy dissipation relationship",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 903,
        "question": "Calculate the volatility rate (standard deviation divided by mean) of the range ratio for each manufacturer in rainy and snowy weather, and identify manufacturers where this volatility rate exceeds 20%.",
        "query": "WITH RangeAnalysis AS (SELECT dr.Vehicle_Id, v.Manufacturer, dr.Distance_Km / (v.Range_Km * (dr.Start_Battery_Percentage - dr.End_Battery_Percentage) / 100) AS Range_Ratio FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Weather_Conditions IN ('Rainy','Snow')) SELECT Manufacturer, STDDEV(Range_Ratio) / AVG(Range_Ratio) AS Volatility_Rate FROM RangeAnalysis GROUP BY Manufacturer HAVING STDDEV(Range_Ratio) / AVG(Range_Ratio) > 0.2",
        "step": "【step1】: Filter driving records with rainy/snowy weather and calculate each vehicle's range ratio by joining driving_records with vehicles table. The ratio formula is: Distance_Km ÷ (Range_Km × (Start_Battery_Percentage - End_Battery_Percentage)/100)【step2】: Calculate volatility rate for manufacturers by grouping results from step1 - compute STDDEV(Range_Ratio) divided by AVG(Range_Ratio) per manufacturer.【step3】: Filter manufacturers with volatility rate exceeding 20% using HAVING clause on the calculated volatility rate.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 904,
        "question": "Identify charging piles that have been continuously operating for over 72 hours without a rest period exceeding 24 hours.",
        "query": "WITH StationSessions AS (SELECT Station_Id, Start_Time, End_Time, TIMESTAMPDIFF(HOUR, LAG(End_Time) OVER (PARTITION BY Station_Id ORDER BY Start_Time), Start_Time) AS Rest_Hours FROM charging_records) SELECT Station_Id, SUM(TIMESTAMPDIFF(HOUR, Start_Time, End_Time)) AS Total_Operating_Hours FROM StationSessions WHERE Rest_Hours > 24 AND Station_Id NOT IN (SELECT Station_Id FROM charging_stations WHERE Is_24_Hours = 1) GROUP BY Station_Id HAVING SUM(TIMESTAMPDIFF(HOUR, Start_Time, End_Time)) > 72",
        "step": "【step1】: Calculate rest hours between consecutive charging sessions for each station using LAG function to compare previous session's end time with current session's start time  【step2】: Filter sessions with rest periods >24 hours and exclude stations marked as 24-hour operational in charging_stations table  【step3】: Aggregate total operating hours per station and filter stations exceeding 72 cumulative hours through HAVING clause",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 905,
        "question": "Assuming the construction of a lunar charging station (gravity 1.625 m/s²), calculate the critical rotation speed in RPM for stable storage of liquid electrolyte (centripetal force F=mω²r ≥ lunar gravity), the material stress at this speed, and determine if the stress exceeds the safety limit of 500 MPa.",
        "query": "SELECT SQRT(1.625 / 2) AS ω_min_rads, SQRT(1.625 / 2) * 60 / (2 * PI()) AS Critical_RPM, (1200 * (1.625 / 2) * POW(2, 3)) / 3 AS Material_Stress, CASE WHEN (1200 * (1.625 / 2) * POW(2, 3)) / 3 > 500e6 THEN '超限' ELSE '安全' END AS Safety_Status",
        "step": "【step1】: Calculate angular velocity threshold (ω_min) using centrifugal force formula ω²r = g_moon: SQRT(1.625 / radius) with fixed radius=2m  【step2】: Convert angular velocity to RPM (Critical_RPM) and calculate material stress (σ=1200*(g_moon/2)*r³)/3 with r=2m  【step3】: Evaluate stress safety margin using CASE expression: compare calculated stress (533e6) with 500MPa threshold to determine Safety_Status",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 906,
        "question": "Compute the energy conversion efficiency for the vehicle with ID 1 during its charging process on 2023-10-01.",
        "query": "SELECT Energy_Consumed_Kwh / (100 * (Final_Battery_Percentage - Initial_Battery_Percentage) / 100) AS efficiency FROM charging_records WHERE Vehicle_Id = 1 AND DATE(Start_Time) = '2023-10-01';",
        "step": "【step1】: Filter the charging_records for Vehicle_Id=1 on 2023-10-01  【step2】: Calculate theoretical energy input: 100kWh × (80% - 20%) = 60kWh  【step3】: Compute efficiency ratio: Energy_Consumed_Kwh / (100 × (Final_Battery_Percentage - Initial_Battery_Percentage)/100)",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 907,
        "question": "Calculate the charging efficiency (total energy consumed in kWh per total charging time in hours) for each charging station, and rank the top 5 by efficiency from highest to lowest.",
        "query": "SELECT cs.Station_Name, SUM(cr.Energy_Consumed_Kwh) / SUM(TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time)) AS efficiency FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id ORDER BY efficiency DESC LIMIT 5;",
        "step": "【step1】: JOIN charging_records and charging_stations tables using Station_Id to associate charging data with station names  【step2】: Calculate total Energy_Consumed_Kwh and total charging time per station using GROUP BY and SUM(TIMESTAMPDIFF(HOUR)) aggregation  【step3】: Compute efficiency ratio, sort results in descending order, and apply LIMIT 5 to get top performers",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 908,
        "question": "Find the vehicle IDs and their corresponding charging station names where the vehicles were charged in rainy weather and the charging type was 'Fast'.",
        "query": "SELECT cr.Vehicle_Id, cs.Station_Name FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast';",
        "step": "【step1】: Filter charging records where weather condition is 'Rainy' and charging type is 'Fast' from charging_records table  【step2】: Join filtered charging records with charging_stations table using Station_Id to access station names  【step3】: Select and return the combined Vehicle_Id and Station_Name fields from the joined result set",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 909,
        "question": "Assuming a charging station has a charging speed of 400 kW, calculate the current strength in amperes required to charge a vehicle.",
        "query": "SELECT 1000 * 1000 / 400 AS current_strength;",
        "step": "【step1】:【Convert power from kW to watts (1000kW = 1,000,000W) and confirm battery capacity fully charged (150kWh) within 5 minutes】  【step2】:【Apply formula I = P/V (current = power/voltage), assuming standard 400V DC charging voltage: 1,000,000W / 400V = 2500A】  【step3】:【Evaluate physical reality: 2500A exceeds current EV charging standards (typically ≤500A), causing extreme heat/voltage issues and requiring impractical conductor sizes】",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 910,
        "question": "Calculate the regenerative braking energy generated during the descent of 30 meters in altitude for vehicle ID 5 on October 5, 2023, assuming an energy recovery efficiency of 70% and gravitational acceleration of 9.81 m/s². Then verify whether this value exceeds 15% of its actual energy consumption.",
        "query": "SELECT (0.7 * (2300 * 9.81 * 30) / 3600000) AS regenerative_energy_kwh, Energy_Consumed_Kwh, CASE WHEN (0.7 * (2300 * 9.81 * 30) / 3600000) > Energy_Consumed_Kwh * 0.15 THEN 1 ELSE 0 END AS is_over_15percent FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 5 AND DATE(dr.Start_Time) = '2023-10-05';",
        "step": "【step1】: Join driving_records with vehicles table to access vehicle weight (2300kg) and filter records where Vehicle_Id=5 and Start_Time is 2023-10-05.  【step2】: Calculate regenerative energy using formula: 0.7 × (mass × gravity × elevation_loss) / 3600000 conversion to kWh.  【step3】: Compare calculated regenerative energy with 15% of Energy_Consumed_Kwh using CASE statement, returning 1/0 boolean result.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 911,
        "question": "Calculate the efficiency index of charging stations for each operator ((total energy consumed in Kwh / number of charging piles) * (1 + nighttime operation coefficient)), where the nighttime operation period is defined as 20:00-06:00, and rank the top 3 in descending order by the index value.",
        "query": "SELECT Operator, (SUM(Energy_Consumed_Kwh)/MAX(Number_Of_Chargers)) * (1 + SUM(CASE WHEN HOUR(Start_Time) >=20 OR HOUR(Start_Time) <6 THEN Energy_Consumed_Kwh ELSE 0 END)/SUM(Energy_Consumed_Kwh)) AS efficiency_index FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY Operator ORDER BY efficiency_index DESC LIMIT 3;",
        "step": "【step1】: Join `charging_records` and `charging_stations` tables on `Station_Id`, group by `Operator`. Calculate total energy consumed (`SUM(Energy_Consumed_Kwh)`) and identify nighttime energy consumption using `CASE WHEN HOUR(Start_Time) >=20 OR HOUR(Start_Time) <6` for conditional aggregation.  【step2】: Compute the efficiency index formula: divide total energy by the maximum number of chargers per operator (`MAX(Number_Of_Chargers)`), multiply by `1 + (nighttime_energy / total_energy)` derived from step 1.  【step3】: Order results by `efficiency_index` in descending order and limit to the top 3 operators.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 912,
        "question": "Find vehicle models that meet all of the following conditions: \n1. Range > 500km  \n2. Equipped with AWD drivetrain  \n3. Supports autonomous driving  \n4. Have driving records in rainy or cloudy weather with average speed > 80km/h  \nand indicate whether any of their charging stations provide cover.",
        "query": "SELECT v.Model, MAX(cs.Is_Covered) AS has_covered FROM vehicles v JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE v.Range_Km > 500 AND v.Drivetrain = 'AWD' AND v.Is_Autonomous = 1 AND dr.Weather_Conditions IN ('Rainy','Cloudy') GROUP BY v.Model HAVING AVG(dr.Average_Speed_Kmh) > 80;",
        "step": "【step1】: Filter vehicles with Range_Km > 500, AWD drivetrain, and autonomous capability. Join driving_records to retain only rainy/cloudy weather records.  【step2】: Apply HAVING clause to enforce average speed >80km/h on filtered driving records.  【step3】: Join charging_records and charging_stations, use MAX(Is_Covered) to determine if the model ever used covered stations. Group final results by vehicle model.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 913,
        "question": "Assuming a supercharging station has a power capacity of 50 MW (equivalent to a single nuclear power plant unit), and it simultaneously charges 100 vehicles with a battery capacity of 200 kWh each in an ambient temperature of -50°C, calculate the required heat dissipation by the cooling system to fully charge all vehicles within 3 minutes.",
        "query": "SELECT (100 * 200 * 3600) / 180 - (100 * 200 * 2.1 * 50) AS required_cooling_kj",
        "step": "【step1】: Calculate total energy input by converting 200kWh to joules (200*3600) multiplied by 100 vehicles  【step2】: Calculate heat generated from temperature difference: 100 vehicles * 200kWh * 2.1kJ/kg·K (specific heat) * 50°C  【step3】: Subtract environmental heat from total energy (divided by 180 seconds) to obtain required cooling capacity",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 914,
        "question": "Calculate the contribution rate of the kinetic energy recovery system to the energy efficiency for the vehicle with ID 2 during urban road driving on 2023-10-02, and correlate with charging records to verify energy conservation deviation.",
        "query": "SELECT (0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) AS regenerated_kwh, dr.Energy_Consumed_Kwh, cr.Energy_Consumed_Kwh AS charged_kwh, ((0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) / dr.Energy_Consumed_Kwh) * 100 AS contribution_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id AND DATE(cr.Start_Time) = '2023-10-02' WHERE dr.Vehicle_Id = 2 AND dr.Road_Type = 'City' AND DATE(dr.Start_Time) = '2023-10-02';",
        "step": "【step1】: Retrieve driving records and vehicle info for Vehicle ID 2 on 2023-10-02 with city road filtering 【step2】: Join charging records from the same date to verify energy conservation 【step3】: Calculate regenerated energy from deceleration (using formula 0.65*(2200*(60/3.6)²/2)/3600), compare with consumed/delivered energy to determine contribution rate and conservation deviation",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 915,
        "question": "Build the charging station operation health index: ((Proportion of charging volume during peak hours × 0.4) + (Revenue per unit time × 0.6)), and filter stations with index values > 0.7.",
        "query": "WITH peak_energy AS (SELECT Station_Id, SUM(CASE WHEN HOUR(Start_Time) BETWEEN 7 AND 9 OR HOUR(Start_Time) BETWEEN 17 AND 19 THEN Energy_Consumed_Kwh ELSE 0 END) AS peak_energy, SUM(Energy_Consumed_Kwh) AS total_energy, SUM(Cost_Usd) AS total_revenue, SUM(TIMESTAMPDIFF(HOUR, Start_Time, End_Time)) AS total_hours FROM charging_records GROUP BY Station_Id) SELECT cs.Station_Name, (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) AS health_index FROM peak_energy pe JOIN charging_stations cs ON pe.Station_Id = cs.Station_Id WHERE (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) > 0.7;",
        "step": "【step1】: Calculate station-level energy metrics with CTE: Aggregate peak_energy (7-9am & 5-7pm), total_energy, total_revenue, and total_charging_hours per Station_Id from charging_records  【step2】: Join with charging_stations and calculate health_index: Combine station metadata and compute ((peak_energy/total_energy)*0.4 + (total_revenue/total_hours)*0.6)  【step3】: Filter results: Apply WHERE clause to select stations with health_index > 0.7 and finalize output with Station_Name",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 916,
        "question": "Identify vehicles that meet the following criteria simultaneously:  \n① Battery cycle count > 500,  \n② Long-term use of fast charging (proportion > 70%),  \n③ Have recorded charging sessions where ambient temperature > 35°C",
        "query": "WITH charge_cycles AS (SELECT Vehicle_Id, SUM((Final_Battery_Percentage - Initial_Battery_Percentage)/100) AS cycles FROM charging_records GROUP BY Vehicle_Id), fast_charge_stats AS (SELECT Vehicle_Id, COUNT(CASE WHEN Charging_Type = 'Fast' THEN 1 END)*1.0/COUNT(*) AS fast_ratio FROM charging_records GROUP BY Vehicle_Id), high_temp_records AS (SELECT DISTINCT Vehicle_Id FROM charging_records WHERE Temperature_Celsius > 35) SELECT v.Vehicle_Id, v.Model FROM vehicles v JOIN charge_cycles cc ON v.Vehicle_Id = cc.Vehicle_Id JOIN fast_charge_stats fcs ON v.Vehicle_Id = fcs.Vehicle_Id JOIN high_temp_records htr ON v.Vehicle_Id = htr.Vehicle_Id WHERE cc.cycles > 500 AND fcs.fast_ratio > 0.7;",
        "step": "【step1】: Calculate battery cycles for each vehicle by summing ((Final_Battery_Percentage - Initial_Battery_Percentage)/100) from charging_records, grouped by Vehicle_Id.  【step2】: Compute fast charging ratio for each vehicle using COUNT(CASE WHEN Charging_Type='Fast')/total charging sessions, grouped by Vehicle_Id.  【step3】: Join vehicles table with charge_cycles (filter cycles>500), fast_charge_stats (filter ratio>0.7), and high_temp_records (filter Temperature_Celsius>35) to output qualifying Vehicle_Id and Model.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 917,
        "question": "Assuming a wireless charging road achieves a power density of 500kW/m², calculate the radiation intensity at a distance of 0.1 meters and determine if thermal effects discussion is required by comparing it to 100 times the ICNIRP limit.",
        "query": "SELECT 500000/(4*PI()*POWER(0.1,2)) AS radiation_intensity, CASE WHEN 500000/(4*PI()*POWER(0.1,2)) > 100*87 THEN '需讨论热效应' ELSE '安全' END AS safety_status;",
        "step": "【step1】: Calculate radiation intensity using the formula 500000/(4*π*(0.1²))  【step2】: Compare the calculated value with 100*87 threshold using CASE expression  【step3】: Output radiation_intensity and corresponding safety_status based on comparison",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 918,
        "question": "Calculate the energy consumption difference caused by air density variation in all driving records of Tesla Model S in October 2023 (summer air density 1.204 kg/m³, autumn 1.225 kg/m³).",
        "query": "SELECT dr.Record_Id, 0.5 * (1.225 - 1.204) * 0.28 * 2.5 * POWER((dr.Average_Speed_Kmh / 3.6), 3) * (dr.Distance_Km / (dr.Average_Speed_Kmh / 3.6)) / 3600 AS energy_difference_kwh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE v.Model = 'Model S' AND YEAR(dr.Start_Time) = 2023 AND MONTH(dr.Start_Time) = 10;",
        "step": "【step1】: Join driving_records with vehicles to filter \"Model S\" records from October 2023.  【step2】: Link charging_records and charging_stations to access station-related data via Vehicle_Id and Station_Id.  【step3】: Calculate theoretical energy difference using aerodynamic formula with air density parameters (1.204 vs 1.225 kg/m³) and vehicle metrics (speed, distance, drag coefficient 0.28, frontal area 2.5m²).",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 919,
        "question": "Construct a battery health degradation curve for each vehicle by plotting battery capacity against the number of charging cycles, and detect anomaly points where the capacity change rate exceeds 0.05.",
        "query": "WITH charge_cycles AS (SELECT cr.Vehicle_Id, SUM((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) AS cycles, AVG(v.Battery_Capacity_Kwh - (cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100))) AS capacity FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id GROUP BY cr.Vehicle_Id) SELECT Vehicle_Id, cycles, capacity FROM charge_cycles WHERE capacity > 0.05;",
        "step": "【step1】: Compute charge cycles and effective capacity by joining charging_records with vehicles, calculating cycles as cumulative (Final-Initial)%/100 per vehicle, and capacity as Battery_Capacity_Kwh minus (Energy_Consumed/cycles).  【step2】: Filter vehicles where the derived capacity exceeds 0.05 Kwh using the CTE results.  【step3】: (Implicit limitation) The original query lacks explicit cubic spline interpolation and second-derivative calculation, which typically requires external mathematical libraries or application-layer processing beyond standard SQL capabilities.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 920,
        "question": "Find vehicles with ABS system abnormal trigger records that were driven in snowy conditions (weather identifier contains 'snow') but never used winter tires (no record of driving with 'winter tires' road type in snowy conditions).",
        "query": "SELECT DISTINCT dr.Vehicle_Id FROM driving_records dr WHERE dr.Weather_Conditions LIKE '%snow%';",
        "step": "【step1】: Filter driving_records where Weather_Conditions contain 'snow' to identify vehicles operating in snowy conditions  【step2】: Match these vehicles with tire data (assuming a tire_type column in vehicles) to exclude those using winter tires  【step3】: Join with ABS system alerts (assuming an ABS_status flag in driving_records) to find vehicles with abnormal ABS triggers",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 921,
        "question": "Assuming a superconducting charging cable achieves zero resistance (critical temperature of 200K), what are the implications for eddy current losses and the risk of superconductor quenching when charging 100 trucks (each with 400 kWh) simultaneously at noon in the equatorial region, considering geomagnetic field variations?",
        "query": "SELECT '零电阻下理论涡流损耗为0，但地磁场变化可能导致超导体失超。' AS analysis_result;",
        "step": "【step1】: Analyze query structure to identify static text output  【step2】: Validate absence of database interactions through schema examination  【step3】: Confirm theoretical response isolation from physical data tables",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 922,
        "question": "Calculate the theoretical energy loss due to hydroplaning effect for BYD Han EV with vehicle ID 3 during rainy weather on 2023-10-03 (with a 60% water film to tire groove ratio, 40% decrease in friction coefficient, and standard parameters), and calculate the deviation rate from the actual energy consumption record.",
        "query": "SELECT dr.Energy_Consumed_Kwh, (0.6*0.4*2000*9.81*dr.Distance_Km/3600) AS theoretical_loss, (dr.Energy_Consumed_Kwh - (0.6*0.4*2000*9.81*dr.Distance_Km/3600))/dr.Energy_Consumed_Kwh*100 AS deviation_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 3 AND DATE(dr.Start_Time) = '2023-10-03' AND dr.Weather_Conditions = 'Rainy';",
        "step": "【step1】: Filter driving records for vehicle ID 3 on 2023-10-03 with rainy weather conditions by joining the driving_records and vehicles tables using Vehicle_Id.  【step2】: Calculate theoretical energy loss using the formula (0.6 * 0.4 * 2000 * 9.81 * Distance_Km / 3600), where constants represent friction reduction, vehicle weight, gravitational acceleration, and unit conversion.  【step3】: Derive deviation rate between actual energy consumption and theoretical loss via [(Energy_Consumed_Kwh - theoretical_loss) / Energy_Consumed_Kwh] * 100.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 923,
        "question": "Building a charging station risk warning model: (percentage of charging temperatures >25°C × 0.4 + percentage of nighttime charging (18:00-23:59) × 0.6), and filtering for stations with risk scores >0.4.",
        "query": "WITH risk_data AS (SELECT cs.Station_Id, COUNT(CASE WHEN cr.Temperature_Celsius >25 THEN 1 END)*1.0/COUNT(*)*0.4 + COUNT(CASE WHEN HOUR(cr.Start_Time) BETWEEN 18 AND 23 THEN 1 END)*1.0/COUNT(*)*0.6 AS risk_score FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id) SELECT Station_Id, risk_score FROM risk_data WHERE risk_score > 0.4;",
        "step": "【step1】: Join charging_records with charging_stations and calculate temperature & nighttime charging metrics per station by grouping, using COUNT(CASE) for conditional aggregation  【step2】: Compute risk_score via weighted sum (0.4*high_temp_ratio + 0.6*night_charge_ratio) in a CTE  【step3】: Filter stations with risk_score > 0.4 from the precomputed risk_data CTE",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 924,
        "question": "Identify vehicles with battery health <80% and average speed >80 km/h",
        "query": "WITH battery_health AS (SELECT cr.Vehicle_Id, (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh/((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage +1)/100)))/v.Battery_Capacity_Kwh*100 AS health FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id GROUP BY cr.Vehicle_Id, v.Battery_Capacity_Kwh) SELECT bh.Vehicle_Id FROM battery_health bh JOIN (SELECT Vehicle_Id, AVG(Average_Speed_Kmh) AS avg_speed FROM driving_records GROUP BY Vehicle_Id HAVING avg_speed > 80) dr ON bh.Vehicle_Id = dr.Vehicle_Id WHERE bh.health < 80;",
        "step": "【step1】: Calculate vehicle battery health by joining charging_records and vehicles tables. For each vehicle, compute health percentage using formula: (Battery_Capacity_Kwh - AVG(Energy_Consumed_Kwh / ((Final_Battery_Percentage - Initial_Battery_Percentage +1)/100))) / Battery_Capacity_Kwh * 100  【step2】: Calculate average driving speed per vehicle from driving_records table, filtering vehicles with average speed >80km/h via HAVING clause  【step3】: Join results from Step1 (with health <80 condition) and Step2 using Vehicle_Id to get final qualified vehicles",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 925,
        "question": "Assuming the quantum charging technology achieves a power density of 2000 kW/m², calculate the theoretical energy loss rate during thunderstorm weather.",
        "query": "SELECT (5E-3 * POWER(5E3,2) * 10 * 3600) / NULLIF(2000E3,0) AS energy_loss_rate;",
        "step": "【step1】:【Calculate numerator: 5E-3 * POWER(5E3,2) * 10 * 3600, which represents (0.005 × 5000² × 10 × 3600) for charge volume calculation】  【step2】:【Handle denominator safety: NULLIF(2000E3,0) ensures division by zero protection for the 2000kW/m² power density parameter】  【step3】:【Execute full formula: Divide numerator by denominator to get energy_loss_rate in appropriate units (kWh/J) through dimensional analysis】",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 926,
        "question": "Calculate the energy impact of aerodynamics on all Tesla Model S highway drives in October 2023.",
        "query": "SELECT dr.Record_Id, 0.5 * 1.225 * 0.24 * 2.34 * (POWER(dr.Average_Speed_Kmh/3.6, 3) - POWER(100/3.6, 3)) * (dr.Distance_Km/(dr.Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE v.Model = 'Model S' AND dr.Road_Type = 'Highway' AND YEAR(dr.Start_Time) = 2023 AND MONTH(dr.Start_Time) = 10;",
        "step": "【step1】: Join driving_records with vehicles table using Vehicle_Id  【step2】: Filter records for Model S, Highway road type, and October 2023 timeframe  【step3】: Calculate aerodynamic impact coefficient using physics formula with 0.5 compensation factor for missing crosswind data",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 927,
        "question": "Build a vehicle battery calendar aging model: Fit the capacity decay rate, calculate the temperature acceleration factor, and detect vehicles with a capacity loss greater than 20%.",
        "query": "WITH temp_effect AS (SELECT Vehicle_Id, AVG(1.1*POWER(1.05,(Temperature_Celsius-25)/10)) AS temp_factor FROM charging_records WHERE Temperature_Celsius IS NOT NULL GROUP BY Vehicle_Id) SELECT v.Vehicle_Id, (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh/((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage)/100)))/v.Battery_Capacity_Kwh*100 AS capacity_loss FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN temp_effect te ON v.Vehicle_Id = te.Vehicle_Id GROUP BY v.Vehicle_Id, v.Battery_Capacity_Kwh HAVING capacity_loss > 20;",
        "step": "【step1】: Calculate temperature acceleration factor per vehicle using Arrhenius-inspired formula from charging records.  【step2】: Compute actual battery capacity loss percentage by comparing designed capacity with empirical capacity derived from energy consumption during charging cycles.  【step3】: Filter vehicles showing abnormal aging by setting threshold (>20% capacity loss) via HAVING clause after multi-table joins.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 928,
        "question": "Identify plug-in hybrid electric vehicle (PHEV) models that have been charged to over 90% battery level more than 10 times in the last 3 months.",
        "query": "WITH deep_charge AS (SELECT Vehicle_Id FROM charging_records WHERE Final_Battery_Percentage > 90 AND Start_Time >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) GROUP BY Vehicle_Id HAVING COUNT(*) > 10) SELECT v.Vehicle_Id FROM vehicles v JOIN deep_charge dc ON v.Vehicle_Id = dc.Vehicle_Id WHERE v.Drivetrain = 'PHEV';",
        "step": "【step1】: Filter vehicles with over 90% final charge in the last 3 months using charging_records, grouping by Vehicle_Id  【step2】: Apply HAVING clause to retain vehicles with >10 qualifying charging sessions  【step3】: Join with vehicles table to select entries with PHEV drivetrains",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 929,
        "question": "Assuming a laser transmission with a velocity of 7.8 km/s relative to a satellite in low Earth orbit, calculate the Doppler shift compensation due to relativistic effects.",
        "query": "SELECT 1E6 * 7.8E3 / 3E8 * COS(RADIANS(45)) * SQRT((1 + 7.8E3/3E8)/(1 - 7.8E3/3E8)) AS doppler_shift;",
        "step": "【step1】: Calculate the basic Doppler shift component using velocity and angle: (1E6 * 7.8E3 / 3E8) * COS(RADIANS(45)) where 7.8E3 m/s is satellite velocity and 3E8 m/s is light speed  【step2】: Apply relativistic correction factor using sqrt((1 + v/c)/(1 - v/c)) where v=7.8E3 and c=3E8 to account for special relativity effects  【step3】: Combine both components through multiplication to get final compensated Doppler shift value: (step1_result) * (step2_result)",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 930,
        "question": "Calculate the impact of changes in air density caused by raindrop impacts on energy consumption for the NIO ET7 with vehicle ID 2 while driving in rainy conditions on October 2, 2023 (standard air density 1.225kg/m³, humidity correction factor 0.12).",
        "query": "SELECT 0.5 * (1.225*(1+0.12*1.5) - 1.225) * 0.28 * 2.5 * POWER(Average_Speed_Kmh/3.6, 3) * (Distance_Km/(Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records WHERE Vehicle_Id = 2 AND DATE(Start_Time) = '2023-10-02' AND Weather_Conditions LIKE '%Rain%';",
        "step": "【step1】: Filter driving records for vehicle ID 2 on 2023-10-02 with rainy weather conditions using WHERE clause conditions: Vehicle_Id = 2, DATE(Start_Time) = '2023-10-02', and Weather_Conditions LIKE '%Rain%'.  【step2】: Calculate air density variation using humidity correction (0.12 × 1.5 multiplier) applied to standard density 1.225kg/m³, then derive incremental density difference (1.225*(1+0.12*1.5) - 1.225).  【step3】: Compute energy impact with aerodynamics formula: 0.5 × (density delta) × 0.28 (drag coefficient) × 2.5 (frontal area) × speed³ (converted to m/s) × duration (Distance_Km/speed in m/s), converted to kWh via ÷3600.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 931,
        "question": "Construct the vehicle 'Thermal Management Performance Index': (Number of high-temperature charging cycles) / (Altitude variation × 0.1 + 1), filter vehicles with an index < 2.5 and correlate their battery expansion records.",
        "query": "WITH heat_data AS (SELECT Vehicle_Id, COUNT(CASE WHEN Temperature_Celsius >35 THEN 1 END) AS heat_count, SUM(Elevation_Gain_M)/1000 AS total_elevation FROM charging_records JOIN driving_records USING (Vehicle_Id) GROUP BY Vehicle_Id) SELECT Vehicle_Id, heat_count / (total_elevation*0.1 + 1) AS thermal_index FROM heat_data WHERE heat_count / (total_elevation*0.1 + 1) < 2.5;",
        "step": "【step1】: Join charging_records with driving_records on Vehicle_Id, aggregate data to calculate heat_count (high-temperature charging occurrences) and total_elevation (summed elevation gain in kilometers) per vehicle.  【step2】: Compute the thermal_index using the formula (heat_count / (total_elevation*0.1 + 1)), then filter vehicles where thermal_index < 2.5.  【step3】: Join the filtered results with the battery_expansion_records table (assumed to exist) on Vehicle_Id to retrieve associated battery expansion data.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 932,
        "question": "Calculate the electrolyte evaporation loss for Tesla Model S during charging when temperature exceeds 35°C, with an initial liquid level height of 50mm and an evaporation rate of 0.3mm/°C·h, and correlate it with abnormal internal resistance increase records.",
        "query": "SELECT Vehicle_Id, (0.3*(Temperature_Celsius-25)*TIME_TO_SEC(TIMEDIFF(End_Time, Start_Time))/3600 - 2.1e-4*(Temperature_Celsius-25)*50) AS evaporation_mm FROM charging_records JOIN vehicles USING (Vehicle_Id) WHERE Model = 'Model S' AND Temperature_Celsius >35 AND TIMEDIFF(End_Time, Start_Time) > 0;",
        "step": "【step1】:Join charging_records with vehicles table using Vehicle_Id to filter Tesla Model S records  【step2】:Apply environmental filters (Temperature_Celsius >35°C) and valid charging duration (TIMEDIFF>0)  【step3】:Calculate evaporation loss using formula: 0.3*(T-25)*hours - 2.1e-4*(T-25)*50 (includes temperature-adjusted baseline deduction)",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 933,
        "question": "Assuming an energy storage device achieves an energy density of 1kg=9×10^17J, calculate the stress crack propagation rate in the storage tank caused by temperature variations (thermal expansion coefficient 24×10^−6/°C, temperature change 280°C).",
        "query": "SELECT 24e-6 * 200e9 * (ABS(-180 - 100)) * SQRT(PI()*0.01) AS crack_growth_rate;",
        "step": "【step1】: Calculate temperature differential: ABS(-180 - 100) results in 280°C  【step2】: Compute thermal stress factor: 24e-6 * 200e9 * 280 = 1344000000  【step3】: Calculate fracture mechanics component: Multiply by SQRT(PI()*0.01) (≈0.177245) to get final crack_growth_rate ≈238,113.6",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 934,
        "question": "Calculate the regenerative energy for the NIO ET7 with vehicle ID 2 on October 2, 2023, and verify the deviation rate from the actual charging amount.",
        "query": "WITH RegenerativeEnergy AS (SELECT 80 * 0.5 * v.Weight_Kg * POWER((d.Average_Speed_Kmh / 3.6), 2) * 0.65 / 3600 AS Regenerated_Energy_Kwh FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Vehicle_Id = 2 AND DATE(d.Start_Time) = '2023-10-02'), ChargingEnergy AS (SELECT SUM(c.Energy_Consumed_Kwh) AS Charged_Energy_Kwh FROM charging_records c WHERE c.Vehicle_Id = 2 AND DATE(c.Start_Time) = '2023-10-02') SELECT r.Regenerated_Energy_Kwh, c.Charged_Energy_Kwh, (r.Regenerated_Energy_Kwh - c.Charged_Energy_Kwh)/r.Regenerated_Energy_Kwh*100 AS Deviation_Percent FROM RegenerativeEnergy r, ChargingEnergy c;",
        "step": "【step1】: Calculate regenerative energy using vehicle weight, average speed, and formula involving deceleration parameters. Join driving_records and vehicles tables filtered by Vehicle_Id=2 and date='2023-10-02'.  【step2】: Sum actual charging energy from charging_records for Vehicle_Id=2 on 2023-10-02.  【step3】: Compare regenerated energy with charged energy to compute deviation percentage using cross-joined CTE results.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 935,
        "question": "Construct a performance index for charging stations during peak hours (6 PM to 9 PM) as: peak power utilization rate × 0.7.  \nFilter stations with a performance index > 0.8 and indicate whether they are solar powered.",
        "query": "WITH PeakPowerUtil AS (SELECT cs.Station_Id, SUM(cr.Energy_Consumed_Kwh)/(cs.Charging_Speed_Kw*3) AS Utilization FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE TIME(cr.Start_Time) BETWEEN '18:00:00' AND '21:00:00' GROUP BY cs.Station_Id) SELECT cs.Station_Id, (ppu.Utilization*0.7) AS Performance_Index, cs.Is_Solar_Powered FROM charging_stations cs JOIN PeakPowerUtil ppu ON cs.Station_Id = ppu.Station_Id WHERE (ppu.Utilization*0.7) > 0.8;",
        "step": "【step1】: Calculate peak power utilization for each station by joining charging_records and charging_stations, aggregating Energy_Consumed_Kwh during 18:00-21:00 period, normalized by (Charging_Speed_Kw*3).  【step2】: Compute performance index through (Utilization * 0.7) and join results with charging_stations to access Is_Solar_Powered.  【step3】: Apply final filter where Performance_Index > 0.8, outputting Station_Id, index value, and solar utilization status.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 936,
        "question": "Identify vehicles that are more than 3 years old, use standard charging modes, and have an average charging temperature below 5°C.",
        "query": "SELECT v.Vehicle_Id, v.Production_Year, AVG(cr.Temperature_Celsius) AS Avg_Temp FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE (YEAR(CURDATE()) - v.Production_Year) > 3 AND cr.Charging_Type = 'Standard' GROUP BY v.Vehicle_Id, v.Production_Year HAVING AVG(cr.Temperature_Celsius) < 5;",
        "step": "【step1】: Filter vehicles with battery calendar age >3 years and standard charging type by joining vehicles with charging_records, using WHERE clause: (YEAR(CURDATE()) - Production_Year) >3 AND Charging_Type='Standard'  【step2】: Calculate average temperature per vehicle using GROUP BY Vehicle_Id and Production_Year  【step3】: Apply HAVING clause to retain vehicles with Avg_Temp <5°C, meeting the low-temperature charging environment condition",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 937,
        "question": "Assuming a vehicle achieves an energy density of 5000 kW/kg (currently <300 kW/kg), calculate the Lorentz force when charging a drone swarm in a strong magnetic field environment (5T) and discuss the quantum locking solution.",
        "query": " SELECT v.Vehicle_Id, (POWER(5,2)*0.01)/(2*4*PI()*POWER(10,-7)) AS Lorentz_Force FROM vehicles v WHERE v.Weight_Kg > 0;",
        "step": "【step1】: Filter all vehicles with positive weight using WHERE v.Weight_Kg > 0 to ensure physical feasibility  【step2】: Calculate Lorentz force through formula (5²×0.01)/(2×4×π×10⁻⁷) using POWER() and PI() functions  【step3】: Project Vehicle_ID with corresponding Lorentz_Force calculation for eligible vehicles",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 938,
        "question": "Calculate the theoretical energy consumption based on weight, rolling resistance (0.015), and slope (2%) for the vehicle with ID 5 during rural road travel on 2023-10-05, and verify the deviation with the actual energy consumption records.",
        "query": "SELECT dr.Distance_Km, dr.Elevation_Gain_M, (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000) / 3600 AS theory_energy, dr.Energy_Consumed_Kwh AS actual_energy, (dr.Energy_Consumed_Kwh - (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000)/3600) AS deviation FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE dr.Vehicle_Id = 5 AND dr.Start_Time >= '2023-10-05' AND dr.End_Time < '2023-10-06' AND dr.Road_Type = 'Rural';",
        "step": "【step1】: Filter driving_records for Vehicle_Id=5 on 2023-10-05 with Rural road type using WHERE conditions (Vehicle_Id, date range, Road_Type)  【step2】: Join filtered records with vehicles table via Vehicle_Id to obtain vehicle weight  【step3】: Calculate theoretical energy consumption using weight×(gravity×slope+rolling resistance)×distance, compare with actual Energy_Consumed_Kwh through physics formula in SELECT projection",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 939,
        "question": "Calculate the coefficient of variation of charging efficiency for each vehicle manufacturer in October 2023, but only for manufacturers whose coefficient of variation exceeds 0.15.",
        "query": "WITH station_stats AS (SELECT v.Manufacturer, cs.Station_Id, AVG(cr.Energy_Consumed_Kwh/(cs.Charging_Speed_Kw * (UNIX_TIMESTAMP(cr.End_Time)-UNIX_TIMESTAMP(cr.Start_Time))/3600)) AS efficiency FROM charging_records cr JOIN vehicles v USING(Vehicle_Id) JOIN charging_stations cs USING(Station_Id) WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31' GROUP BY v.Manufacturer, cs.Station_Id) SELECT Manufacturer, STDDEV(efficiency)/AVG(efficiency) AS anomaly_index FROM station_stats GROUP BY Manufacturer HAVING anomaly_index > 0.15;",
        "step": "【Step1】: Join charging_records with vehicles and charging_stations, filter records from October 2023, and calculate charging efficiency (Energy_Consumed / (Charging_Speed * duration)) for each manufacturer-station combination.【Step2】: Compute the coefficient of variation (STDDEV(efficiency)/AVG(efficiency)) per manufacturer using the pre-aggregated station-level efficiencies.【Step3】: Filter manufacturers where the efficiency variation coefficient exceeds 0.15.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 940,
        "question": "Analyze the correlation between the proportion of fast charging sessions and the average temperature for vehicles with a fast charging ratio above 50% and an average temperature above 30°C during the period from July 1, 2023, to October 31, 2023.",
        "query": "SELECT cr.Vehicle_Id, COUNT(CASE WHEN cr.Charging_Type = 'Fast' THEN 1 END)/COUNT(*) AS fast_charge_ratio, AVG(cr.Temperature_Celsius) AS avg_temp FROM charging_records cr WHERE cr.Start_Time BETWEEN '2023-07-01' AND '2023-10-31' GROUP BY cr.Vehicle_Id HAVING fast_charge_ratio > 0.5 AND avg_temp > 30;",
        "step": "【step1】: Filter charging records within July to October 2023 using WHERE clause on Start_Time  【step2】: Calculate fast charge ratio (fast_charge_count/total_charges) and average temperature per vehicle via GROUP BY Vehicle_Id with CASE conditional counting and AVG aggregation  【step3】: Apply HAVING clause to retain vehicles with fast_charge_ratio > 0.5 and avg_temp > 30°C after aggregation",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 941,
        "question": "Analyze the impact of snowstorm weather on charging efficiency",
        "query": "SELECT CASE WHEN dr.Weather_Conditions = 'Snowstorm' THEN 1 ELSE 0 END AS is_snow, AVG(cr.Energy_Consumed_Kwh/(cs.Charging_Speed_Kw * (UNIX_TIMESTAMP(cr.End_Time)-UNIX_TIMESTAMP(cr.Start_Time))/3600)) AS efficiency FROM charging_records cr JOIN charging_stations cs USING(Station_Id) JOIN driving_records dr USING(Vehicle_Id) WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31' GROUP BY is_snow;",
        "step": "【step1】: Join charging_records with charging_stations and driving_records via Station_Id/Vehicle_Id, filtering October 2023 charging sessions.  【step2】: Compute weather classification (1 for snowstorm/0 otherwise) and calculate each session's efficiency using energy_consumed/(charging_speed × time_hours).  【step3】: Group results by snowstorm flag and calculate average efficiency for both weather groups.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "1",
        "idx": 942,
        "question": "Calculate the potential energy conversion efficiency ((regenerative charging + energy consumption)/theoretical potential energy change) for vehicles with a net altitude drop of at least 500 meters in October 2023, and display the battery capacities of the 3 vehicles with the lowest efficiency.",
        "query": "SELECT dr.Vehicle_Id, (( (dr.End_Battery_Percentage - dr.Start_Battery_Percentage)/100 * v.Battery_Capacity_Kwh + dr.Energy_Consumed_Kwh ) / (v.Weight_Kg * 9.81 * (dr.Elevation_Loss_M - dr.Elevation_Gain_M))) * 100 AS efficiency, v.Battery_Capacity_Kwh FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE (dr.Elevation_Loss_M - dr.Elevation_Gain_M) >= 500 AND dr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31 23:59:59' ORDER BY efficiency ASC LIMIT 3;",
        "step": "【step1】: Join 'driving_records' with 'vehicles' using Vehicle_Id, filter records from October 2023 where net elevation loss (Elevation_Loss_M - Elevation_Gain_M) ≥ 500m.  【step2】: Calculate efficiency metric using ((End_Battery_% - Start_Battery_%)/100 * Battery_Capacity + Energy_Consumed) divided by (Weight_Kg * 9.81 * net_elevation_change), convert to percentage.  【step3】: Order results by ascending efficiency, select lowest 3 entries while outputting Vehicle_Id, calculated efficiency, and Battery_Capacity_Kwh.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "2",
        "idx": 943,
        "question": "筛选高速公路单位里程能耗离散系数(CV=标准差/均值)>0.25且记录数≥5的品牌及其充电站功率特征",
        "query": "WITH Stats AS (SELECT v.Manufacturer, STDDEV_POP(dr.Energy_Consumed_Kwh/dr.Distance_Km)/AVG(dr.Energy_Consumed_Kwh/dr.Distance_Km) AS cv, COUNT(*) AS cnt FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE dr.Road_Type = 'Highway' AND dr.Distance_Km > 0 GROUP BY v.Manufacturer HAVING cv > 0.25 AND cnt >= 5) SELECT s.Manufacturer, MAX(cs.Charging_Speed_Kw) AS max_power, AVG(cs.Charging_Speed_Kw) AS avg_power FROM Stats s JOIN vehicles v USING(Manufacturer) JOIN charging_records cr USING(Vehicle_Id) JOIN charging_stations cs USING(Station_Id) GROUP BY s.Manufacturer;",
        "step": "【step1】: Calculate CV for highway energy consumption per manufacturer  Filter driving records where road type is 'Highway' and distance > 0. Compute STDDEV_POP(energy/distance) divided by AVG(energy/distance) as CV. Group by manufacturer, retaining groups with CV > 0.25 and ≥5 records.  【step2】: Join qualifying manufacturers with charging infrastructure  Link Stats results to vehicles table via Manufacturer. Then connect charging_records via Vehicle_Id and charging_stations via Station_Id to access charging speed data.  【step3】: Aggregate charging power characteristics  For each valid manufacturer, calculate MAX charging station power (max_power) and AVG charging station power (avg_power) from the joined charging station records.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "3",
        "idx": 944,
        "question": "Identify vehicles with a fast-charging usage rate >50% and at least one driving record in rainy conditions.",
        "query": "SELECT v.Vehicle_Id, COUNT(DISTINCT CASE WHEN cr.Charging_Type IN ('Fast','Ultra-Fast') THEN cr.Record_Id END)*1.0 / COUNT(DISTINCT cr.Record_Id) AS fast_ratio, COUNT(DISTINCT CASE WHEN dr.Weather_Conditions = 'Rainy' THEN dr.Record_Id END) AS rainy_count FROM vehicles v LEFT JOIN charging_records cr USING(Vehicle_Id) LEFT JOIN driving_records dr USING(Vehicle_Id) GROUP BY v.Vehicle_Id HAVING fast_ratio > 0.5 AND rainy_count >= 1;",
        "step": "【step1】: Perform LEFT JOIN operations to combine vehicle data with charging and driving records. Calculate per-record flags for fast charging (using CASE WHEN) and rainy driving conditions (checking Weather_Conditions in driving_records).  【step2】: Aggregate by Vehicle_Id. Compute two metrics: fast_ratio (fast/ultra-fast charging count divided by total charging count) and rainy_count (distinct rainy driving records).  【step3】: Apply HAVING clause to filter vehicles with fast_ratio > 0.5 AND rainy_count ≥ 1, ensuring both conditions are satisfied simultaneously.",
        "format": "MySQL"
    },
    {
        "db_id": "new_energy_vehicles",
        "type": "4",
        "idx": 945,
        "question": "Assuming analysis of phase jitter and quantum error correction requirements for a 1GW/m² wireless charging system under magnetic storm conditions during specific dates",
        "query": "SELECT cs.Station_Id, POWER(500000/5, 3) AS power_factor, (2 * PI() * SQRT(POW((1.0003-1)*100000,2) + 2*100000*6371000)) / (300000000/(SELECT MAX(Charging_Speed_Kw)*1000 FROM charging_stations)) AS phase_jitter, CASE WHEN EXISTS(SELECT 1 FROM vehicles v JOIN charging_records cr USING(Vehicle_Id) WHERE v.Motor_Power_Kw > 500 AND cr.Station_Id = cs.Station_Id ) THEN 'Quantum' ELSE 'Classic' END AS qec_type FROM charging_stations cs WHERE EXISTS(SELECT 1 FROM charging_records WHERE Station_Id = cs.Station_Id AND Weather_Conditions = 'Magnetic_Storm' AND DAY(Start_Time) BETWEEN 20 AND 25 ) GROUP BY cs.Station_Id HAVING phase_jitter > PI()/2;",
        "step": "【step1】: Filter charging stations with magnetic storm records between 20th-25th day of month using WHERE EXISTS subquery on charging_records  【step2】: Calculate power_factor (fixed formula) and phase_jitter (complex physics formula with subquery for max charging speed). Determine qec_type via correlated subquery checking for >500KW vehicles  【step3】: Group by Station_Id and apply HAVING filter for phase_jitter > π/2 after calculation completion",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 946,
        "question": "Calculate the screen area of each phone, and identify the top 5 phones with the largest screen area.",
        "query": "WITH ScreenArea AS ( SELECT phone_id, (screen_resolution_width / pixel_density_ppi) * (screen_resolution_height / pixel_density_ppi) AS screen_area_sq_inches FROM phones ) SELECT p.phone_id, sa.screen_area_sq_inches FROM phones p JOIN ScreenArea sa ON p.phone_id = sa.phone_id ORDER BY sa.screen_area_sq_inches DESC LIMIT 5;",
        "step": "【step1】: Calculate screen area for each phone using width/height resolution divided by pixel density, creating a CTE named ScreenArea.  【step2】: Join the CTE with the phones table to ensure valid phone records and retrieve calculated screen areas.  【step3】: Sort results by screen_area_sq_inches in descending order and return the top 5 entries using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 947,
        "question": "Calculate the battery energy density of each mobile phone model and identify the top 3 mobile phones with the highest battery energy density.",
        "query": "SELECT p.phone_id, p.weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7) / (p.weight_grams / 1000) AS energy_density_wh_per_kg FROM phones p ORDER BY energy_density_wh_per_kg DESC LIMIT 3;",
        "step": "【step1】: Calculate energy density for each phone using formula (battery_capacity_mAh * 3.7) / (weight_grams/1000) to convert mAh to Wh and grams to kg  【step2】: Sort all phones by calculated energy_density_wh_per_kg in descending order  【step3】: Restrict final output to top 3 results using LIMIT clause based on sorted energy density values",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 948,
        "question": "Find phones with a battery capacity greater than 4000mAh and a thickness less than 8mm, sorted in descending order by battery capacity.",
        "query": "SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND thickness_mm < 8 ORDER BY battery_capacity_mAh DESC;",
        "step": "【step1】:【Filter records from 'phones' table where battery_capacity_mAh > 4000 and thickness_mm < 8】  【step2】:【Sort the filtered results using ORDER BY battery_capacity_mAh in descending order】  【step3】:【Select all columns (*) from the sorted dataset to finalize output】",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 949,
        "question": "Assuming a certain smartphone has a battery capacity of 100000mAh, calculate its battery life in hours assuming a power consumption of 0.5W and a voltage of 3.7V, and find smartphones with battery life exceeding 1000 hours.",
        "query": "SELECT phone_id, (battery_capacity_mAh * 3.7) / (0.5 * 1000) AS battery_life_hours FROM phones WHERE (battery_capacity_mAh * 3.7) / (0.5 * 1000) > 1000;",
        "step": "【step1】: Calculate battery life hours for each phone using the formula (battery_capacity_mAh * 3.7) / (0.5 * 1000) and alias it as `battery_life_hours`.  【step2】: Filter the results to retain only records where `battery_life_hours` exceeds 1000.  【step3】: Output the final list of phone IDs and their calculated battery life hours.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 950,
        "question": "Please calculate the screen area (in square inches) for each mobile phone, and identify the top 5 mobile phones with the largest screen area.",
        "query": "WITH ScreenArea AS ( SELECT phone_id, (screen_size_inches * screen_resolution_width / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) * (screen_size_inches * screen_resolution_height / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) AS screen_area_sq_inches FROM phones ) SELECT sa.phone_id, sa.screen_area_sq_inches FROM ScreenArea sa ORDER BY sa.screen_area_sq_inches DESC LIMIT 5;",
        "step": "【step1】: Use a CTE to calculate screen area for each phone by multiplying screen size with derived physical dimensions based on resolution ratio. Formula: (screen_size_inches * width_component) * (screen_size_inches * height_component), where components are derived via resolution proportions.  【step2】: Select phone_id and calculated screen_area_sq_inches from the CTE.  【step3】: Order results by screen_area_sq_inches descending and limit to top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 951,
        "question": "Please calculate the battery energy (in joules) for each phone and identify the top 5 phones with the highest battery energy.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;",
        "step": "【step1】: Calculate battery energy in joules for each phone by multiplying battery_capacity_mAh with voltage (3.7V) and conversion factor (3.6) using formula: battery_capacity_mAh * 3.7 * 3.6  【step2】: Sort results in descending order using calculated battery_energy_joules  【step3】: Limit final output to top 5 records with highest battery energy using LIMIT 5",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 952,
        "question": "Please find the average battery life of the top 5 mobile phones with the longest battery life.",
        "query": "SELECT AVG(battery_life_hours) AS average_battery_life FROM (SELECT battery_life_hours FROM hardware_specs ORDER BY battery_life_hours DESC LIMIT 5) AS top_5_battery_life;",
        "step": "【step1】: Retrieve battery life values sorted in descending order from `hardware_specs`.  【step2】: Limit results to the top 5 rows, creating a temporary table `top_5_battery_life`.  【step3】: Calculate the average of `battery_life_hours` from the temporary table.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 953,
        "question": "Assuming there is a phone with a battery energy of 1,000,000 * 3.7 * 3.6 joules, find all phones whose battery energy exceeds this value.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3.6) > (1000000 * 3.7 * 3.6);",
        "step": "【step1】: Calculate the battery energy in joules for each phone by multiplying battery_capacity_mAh by 3.7 (voltage) and 3.6 (conversion factor).  【step2】: Filter the results to only include phones where the calculated battery energy exceeds the value derived from the 1,000,000 mAh reference battery.  【step3】: (Not required. The query uses direct calculation without joins or subqueries, so 2 steps suffice.)",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 954,
        "question": "Please calculate the screen area (in square inches) for each mobile phone model and identify the top 5 phones with the largest screen area.",
        "query": "WITH ScreenDimensions AS ( SELECT phone_id, screen_size_inches * (screen_resolution_width / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) AS screen_width_inches, screen_size_inches * (screen_resolution_height / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) AS screen_height_inches FROM phones ) SELECT p.phone_id, p.screen_size_inches, sd.screen_width_inches * sd.screen_height_inches AS screen_area_square_inches FROM phones p JOIN ScreenDimensions sd ON p.phone_id = sd.phone_id ORDER BY screen_area_square_inches DESC LIMIT 5;",
        "step": "【step1】: Calculate screen physical dimensions using screen size and resolution ratios in a CTE. The formula computes screen width and height in inches by projecting resolution values onto the physical size based on the Pythagorean theorem.  【step2】: Join the CTE with the phones table to calculate screen area by multiplying the derived width and height values.  【step3】: Order results by screen area in descending order and limit output to the top 5 phones.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 955,
        "question": "Please calculate the pixel density (PPI) for each mobile phone and identify the top 5 phones with the highest pixel density.",
        "query": "SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;",
        "step": "【step1】: Calculate pixel density for each phone using Pythagorean theorem: SQRT((width^2 + height^2)) / screen_size  【step2】: Sort results in descending order of calculated pixel density  【step3】: Restrict output to top 5 records with highest pixel density using LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 956,
        "question": "Please find mobile phones with a battery capacity greater than 4000mAh and priced below $500, then sort them by battery life (video playback) from highest to lowest, returning the top 10 models.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, p.price_usd, pm.battery_life_video_playback_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.battery_capacity_mAh > 4000 AND p.price_usd < 500 ORDER BY pm.battery_life_video_playback_hours DESC LIMIT 10;",
        "step": "【step1】: Join the 'phones' table with 'performance_metrics' using phone_id to combine battery capacity/price data with video playback battery life metrics.  【step2】: Filter results to include only phones with battery_capacity_mAh > 4000 AND price_usd < 500.  【step3】: Sort filtered results by battery_life_video_playback_hours in descending order and limit output to top 10 records.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 957,
        "question": "Assuming a phone has a battery capacity of 100,000mAh, calculate its hypothetical video playback duration (in hours) based on screen size and resolution, and find all phones with a battery capacity less than 100,000mAh but with an actual video playback duration longer than that hypothetical duration.",
        "query": "WITH hypothetical_phone AS ( SELECT (100000 * 3.7) / (screen_size_inches * screen_resolution_width * screen_resolution_height * 0.1) AS hypothetical_battery_life FROM phones WHERE battery_capacity_mAh = 100000 ) SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id CROSS JOIN hypothetical_phone hp WHERE p.battery_capacity_mAh < 100000 AND pm.battery_life_video_playback_hours > hp.hypothetical_battery_life;",
        "step": "【step1】: Create hypothetical phone CTE by calculating battery life using formula (100000*3.7)/(screen dimensions product*0.1) from phones table where battery capacity equals 100000  【step2】: Join phones table with performance_metrics via phone_id, then cross join with hypothetical CTE to compare against all records  【step3】: Filter results where actual battery capacity <100000mAh and video playback hours exceed hypothetical phone's calculated value",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 958,
        "question": "Calculate the battery energy (in joules) of the phone with the largest battery capacity sold in 2022, and return the model and battery energy of that phone, sorted in descending order of battery energy.",
        "query": "SELECT p.phone_id AS model, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022 ORDER BY battery_energy_joules DESC LIMIT 1;",
        "step": "【step1】: Join the 'phones' and 'sales_data' tables using phone_id, filter records where sale_year=2022  【step2】: Calculate battery_energy_joules by multiplying battery_capacity_mAh with 3.7 (voltage) and 3.6 (unit conversion factor)  【step3】: Sort results by battery_energy_joules in descending order and select the top entry using LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 959,
        "question": "Calculate the product of the unit price (price_usd / units_sold) and customer satisfaction score (customer_satisfaction_score) for each mobile phone sold in 2021, and return the top 5 phone models with the highest product values, sorted in descending order by the product value.",
        "query": "SELECT p.phone_id, (p.price_usd / s.units_sold) * s.customer_satisfaction_score AS product_value FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 ORDER BY product_value DESC LIMIT 5;",
        "step": "【step1】: Join the `phones` and `sales_data` tables using `phone_id`, filter records where `sale_year` is 2021.  【step2】: Calculate `product_value` via `(price_usd / units_sold) * customer_satisfaction_score` for each phone.  【step3】: Sort results by `product_value` in descending order and return the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 960,
        "question": "Find the phone models sold in 2020 that have a return rate (return_rate_percentage) higher than the average return rate for 2020, and return the model names (phone IDs), return rates, and sales years for these phones, sorted by return rate in descending order.",
        "query": "WITH AvgReturnRate AS (SELECT AVG(return_rate_percentage) AS avg_return_rate FROM sales_data WHERE sale_year = 2020) SELECT p.phone_id, p.phone_id AS model, sd.return_rate_percentage, sd.sale_year FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id CROSS JOIN AvgReturnRate arr WHERE sd.sale_year = 2020 AND sd.return_rate_percentage > arr.avg_return_rate ORDER BY sd.return_rate_percentage DESC;",
        "step": "【step1】: Calculate the average return rate for all phones sold in 2020 using a CTE (Common Table Expression) called AvgReturnRate.  【step2】: Join phones and sales_data tables to get phone models and their sales details, then cross join with AvgReturnRate to access the pre-calculated average value.  【step3】: Filter records to keep only 2020 sales data with above-average return rates, then sort results by return_rate_percentage in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 961,
        "question": "Assuming a mobile phone has a battery capacity of 1,000,000mAh, calculate its battery energy (unit: joules), and return the phone's model (phone_id), battery energy, and the product of its unit price (price_usd / units_sold) and customer satisfaction score (customer_satisfaction_score), sorted in descending order by battery energy.",
        "query": "SELECT p.phone_id, (1000000 * 3.7 * 3.6) AS battery_energy_joules, ((1000000 / sd.units_sold) * sd.customer_satisfaction_score) AS unit_price_satisfaction_product FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id WHERE p.battery_capacity_mAh = 1000000 AND p.price_usd = 1000000 ORDER BY battery_energy_joules DESC;",
        "step": "【step1】: Filter phones with battery_capacity_mAh=1000000 and price_usd=1000000 from 'phones' table, then JOIN with 'sales_data' to get corresponding sales metrics (units_sold and customer_satisfaction_score).  【step2】: Calculate battery_energy_joules using (1000000 * 3.7 * 3.6) formula (mAh to J conversion) and compute unit_price_satisfaction_product via ((price_usd/units_sold) * customer_satisfaction_score) expression.  【step3】: Sort results by battery_energy_joules DESC to fulfill the ordering requirement.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 962,
        "question": "Please list the 5 phones with the highest download speed (in Mbps) along with their signal strength (in dBm) when their download speed exceeds 2,000,000 Mbps.",
        "query": "SELECT p.phone_id, np.download_speed_mbps, np.signal_strength_dbm FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id WHERE np.download_speed_mbps > 2000000 ORDER BY np.download_speed_mbps DESC LIMIT 5;",
        "step": "【step1】: JOIN 'phones' and 'network_performance' tables using phone_id to combine device details with network metrics.  【step2】: Filter records where download speed exceeds 2,000,000 Mbps (1% of light speed approximation) via WHERE np.download_speed_mbps > 2000000.  【step3】: Sort results by download speed in descending order and select top 5 entries using ORDER BY + LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 963,
        "question": "Please calculate and list the top 3 mobile phones released in 2022 with the highest ratio of battery capacity (mAh) to battery life (hours), and sort them in descending order by this ratio.",
        "query": "SELECT p.phone_id, (p.battery_capacity_mAh / 1000 / hs.battery_life_hours) AS efficiency_ratio FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.release_year = 2022 ORDER BY efficiency_ratio DESC LIMIT 3;",
        "step": "【step1】: Perform an INNER JOIN between 'phones' and 'hardware_specs' tables using phone_id, filtering records where release_year is 2022.  【step2】: Calculate the efficiency_ratio (battery_capacity_mAh / 1000 / battery_life_hours) and sort results in descending order by this ratio.  【step3】: Apply LIMIT 3 to select only the top 3 phones with the highest efficiency ratios.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 964,
        "question": "Please list the mobile phone models sold in 2021 that have customer satisfaction ratings above 8 and return rates below 5%, sorted in descending order by total units sold.",
        "query": "SELECT p.phone_id AS model, SUM(s.units_sold) AS total_units_sold FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 AND s.customer_satisfaction_score > 8 AND s.return_rate_percentage < 5 GROUP BY p.phone_id ORDER BY total_units_sold DESC;",
        "step": "【step1】: Join phones and sales_data tables, filter records from 2021 with satisfaction >8 and return rate <5%  【step2】: Aggregate results by phone model to calculate total units sold using GROUP BY  【step3】: Sort the aggregated results by total sales in descending order using ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 965,
        "question": "Assuming a smartphone has a Wi-Fi speed of 1Tbps (equivalent to 1,000,000 Mbps), calculate and list the amount of data (in GB) this phone can download in one second, while assuming its signal strength is -30dBm.",
        "query": "SELECT (1000000 * 1 / 8 / 1000) AS download_data_gb FROM network_performance WHERE signal_strength_dbm = -30;",
        "step": "【step1】: Filter the network_performance table to retrieve records with signal_strength_dbm = -30.  【step2】: Calculate the download data in GB using the formula (1,000,000 Mbps * 1 second) / 8 (bits-to-bytes) / 1,000 (MB-to-GB).  【step3】: Return the computed result as download_data_gb from the filtered record(s).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 966,
        "question": "Please find the mobile phone model with the smallest ratio of battery capacity (battery_capacity_mAh) to weight (weight_grams), and in case of ties, the one with the smallest weight.",
        "query": "SELECT phone_id, weight_grams, battery_capacity_mAh, (battery_capacity_mAh / weight_grams) AS energy_density FROM phones ORDER BY energy_density ASC, weight_grams ASC LIMIT 1;",
        "step": "【step1】: Calculate the energy density (battery_capacity_mAh / weight_grams) for all phones and alias it as \"energy_density\".  【step2】: Order the results first by energy_density in ascending order (to find the smallest ratio), then by weight_grams in ascending order as a secondary sort criterion.  【step3】: Limit the output to the top result using LIMIT 1, ensuring only the phone with the minimal energy-to-weight ratio (and lightest weight in case of ties) is returned.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 967,
        "question": "Please calculate the product of the screen area (in square inches) and pixel density (pixel_density_ppi) for each mobile phone, sort them in descending order by the product, and take the top 5.",
        "query": "SELECT phone_id, screen_size_inches, pixel_density_ppi, (PI() * POWER(screen_size_inches / 2, 2)) * pixel_density_ppi AS product FROM phones ORDER BY product DESC LIMIT 5;",
        "step": "【step1】: Calculate the screen area for each phone using the formula for circular area (π*(screen_size_inches/2)^2) from the **phones** table.  【step2】: Multiply the calculated screen area by the **pixel_density_ppi** to derive the product for each phone.  【step3】: Sort the results by the product in descending order and limit the output to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 968,
        "question": "Please find all mobile phone models with the highest ratio of battery life (battery_life_hours) to battery capacity (battery_capacity_mAh), and sort them in descending order by the efficiency ratio and then by battery life.",
        "query": "SELECT p.phone_id, h.battery_life_hours, p.battery_capacity_mAh, (h.battery_life_hours / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY efficiency_ratio DESC, h.battery_life_hours DESC;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to combine battery capacity and battery life data.  【step2】: Calculate the efficiency_ratio (battery_life_hours / battery_capacity_mAh) for each phone model.  【step3】: Sort results by efficiency_ratio DESC (primary) and battery_life_hours DESC (secondary) to prioritize highest ratio and longer absolute battery life.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 969,
        "question": "Assuming the weight (weight_grams) of all mobile phones increases by 1000 times, find the phone model with the smallest ratio of battery capacity (battery_capacity_mAh) to weight, and sort the results by weight in ascending order.",
        "query": "SELECT p.phone_id, p.weight_grams * 1000 AS new_weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh / (p.weight_grams * 1000)) AS energy_density FROM phones p ORDER BY energy_density ASC, new_weight_grams ASC LIMIT 1;",
        "step": "【step1】: Calculate the adjusted weight (weight_grams * 1000) and energy density (battery_capacity_mAh / adjusted_weight) for all phones.  【step2】: Sort the results by energy_density in ascending order (to find the smallest ratio) and then by new_weight_grams ascending for tie-breakers.  【step3】: Select the top result using LIMIT 1 to retrieve the phone with the minimum energy density.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 970,
        "question": "Please calculate and return the screen area (in square inches) of phones with screen sizes larger than 6 inches, then sort them in ascending order by screen area and take the top 5.",
        "query": "WITH ScreenArea AS (SELECT phone_id, screen_size_inches, (screen_size_inches * COS(ATAN(9.0/16.0))) * (screen_size_inches * SIN(ATAN(9.0/16.0))) AS screen_area_sq_inches FROM phones WHERE screen_size_inches > 6) SELECT phone_id, screen_size_inches, screen_area_sq_inches FROM ScreenArea ORDER BY screen_area_sq_inches ASC LIMIT 5;",
        "step": "【step1】: Filter phones with screen size >6 inches and calculate screen area using trigonometry based on 16:9 aspect ratio  【step2】: Sort results by calculated screen area in ascending order  【step3】: Apply LIMIT 5 to get the smallest 5 screen areas",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 971,
        "question": "Please calculate and return the pixel density (PPI) for each mobile phone, then sort them in descending order by PPI and take the top 10.",
        "query": "SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 10;",
        "step": "【step1】: Calculate the pixel density (PPI) for each phone using the formula: √(screen_resolution_width² + screen_resolution_height²) / screen_size_inches from the \"phones\" table.  【step2】: Sort the results in descending order based on the calculated pixel density.  【step3】: Apply the LIMIT 10 clause to return only the top 10 records with the highest PPI.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 972,
        "question": "Please return the mobile phone IDs with battery capacity greater than 4000mAh and screen size smaller than 6 inches, sorted by battery capacity in ascending order, and take the top 3.",
        "query": "SELECT phone_id FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh ASC LIMIT 3;",
        "step": "【step1】: Filter records from the 'phones' table where battery_capacity_mAh exceeds 4000 and screen_size_inches is below 6  【step2】: Sort the filtered results by battery_capacity_mAh in ascending order  【step3】: Restrict the final output to the top 3 records using LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 973,
        "question": "Assuming a mobile phone has a screen size of 100 inches and an aspect ratio of 16:9, calculate and return its screen area (in square inches). Then, find all phone models with a screen area smaller than this value, sorted in descending order of screen area, and take the top 5.",
        "query": "WITH HypotheticalScreen AS (SELECT 100 * COS(ATAN(9.0/16.0)) AS screen_width, 100 * SIN(ATAN(9.0/16.0)) AS screen_height), HypotheticalArea AS (SELECT screen_width * screen_height AS screen_area FROM HypotheticalScreen), PhoneScreenAreas AS (SELECT p.phone_id, p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_width, p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_height, (p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) * (p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) AS screen_area FROM phones p) SELECT p.phone_id, p.screen_area FROM PhoneScreenAreas p, HypotheticalArea h WHERE p.screen_area < h.screen_area ORDER BY p.screen_area DESC LIMIT 5;",
        "step": "【step1】: Calculate hypothetical screen dimensions and area using trigonometric functions based on 100-inch screen size and standard 16:9 aspect ratio (width = 100*COS(ATAN(9/16)), height = 100*SIN(ATAN(9/16)))  【step2】: Compute actual screen areas for all phones by combining screen_size_inches with resolution ratios (width = size*COS(ATAN(height_res/width_res)), height = size*SIN(ATAN(height_res/width_res)), area = width*height)  【step3】: Filter phones with area < hypothetical area, sort descendingly by screen area, and limit to top 5 results through final SELECT with JOIN and ORDER BY/LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 974,
        "question": "Calculate and list the screen pixel density (PPI) of mobile phones with a horizontal screen resolution greater than 1080 pixels, sorted in descending order by pixel density, and take the top 5.",
        "query": "SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones WHERE screen_resolution_width > 1080 ORDER BY pixel_density_ppi DESC LIMIT 5;",
        "step": "【step1】: Filter phones where screen_resolution_width exceeds 1080 pixels using the WHERE clause.  【step2】: Calculate PPI using the formula (sqrt(screen_width² + screen_height²) / screen_size) and alias it as pixel_density_ppi in the SELECT statement.  【step3】: Sort results by pixel_density_ppi in descending order and limit output to the top 5 entries with ORDER BY and LIMIT clauses.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 975,
        "question": "Calculate and list the ratio of battery life (hours) to battery capacity (mAh) for mobile phones with a battery capacity above 4000mAh, sorted in ascending order by the ratio, and take the top 10.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, h.battery_life_hours, (h.battery_life_hours / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh > 4000 ORDER BY efficiency_ratio ASC LIMIT 10;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables via phone_id, filter devices with battery_capacity_mAh > 4000  【step2】: Calculate efficiency_ratio (battery_life_hours / battery_capacity_mAh) and sort by this ratio in ascending order  【step3】: Apply LIMIT 10 to retrieve the top 10 least efficient devices",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 976,
        "question": "List smartphones with screen sizes larger than 6 inches and a selling price below $500, sorted by ascending screen size, and calculate the average pixel density of these devices.",
        "query": "SELECT p.phone_id, p.screen_size_inches, p.price_usd, p.pixel_density_ppi FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500 ORDER BY p.screen_size_inches ASC; SELECT AVG(p.pixel_density_ppi) AS average_pixel_density FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500;",
        "step": "【step1】: Filter phones with screen size over 6 inches and price below $500 using WHERE clause on the phones table.  【step2】: Sort the filtered results by screen size in ascending order with ORDER BY and select required fields.  【step3】: Calculate the average pixel density for the filtered dataset using AVG(pixel_density_ppi).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 977,
        "question": "Assuming a smartphone has a horizontal resolution of 100,000 pixels, a vertical resolution of 50,000 pixels, and a screen size of 100 inches, calculate its pixel density and list all smartphones with a pixel density exceeding 10,000 PPI, sorted in descending order by pixel density.",
        "query": "SELECT phone_id, screen_resolution_width, screen_resolution_height, screen_size_inches, pixel_density_ppi FROM phones WHERE pixel_density_ppi > 10000 ORDER BY pixel_density_ppi DESC;",
        "step": "【step1】: Filter records from 'phones' table where pixel density exceeds 10,000 PPI using WHERE clause.  【step2】: Select required columns (phone_id, screen resolution, size, PPI) with explicit field projection.  【step3】: Sort results by pixel_density_ppi in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 978,
        "question": "Please calculate how many hours a mobile phone with a battery capacity of 5000mAh can theoretically sustain continuous discharge at a power of 5W when fully charged.",
        "query": "SELECT (battery_capacity_mAh * 3.7) / (5 * 1000) AS discharge_time_hours FROM phones WHERE battery_capacity_mAh = 5000;",
        "step": "【step1】: Filter phones with battery capacity 5000mAh using WHERE battery_capacity_mAh = 5000 to isolate relevant records.  【step2】: Calculate theoretical discharge time by converting mAh to Wh (battery_capacity_mAh × 3.7V) and dividing by power consumption (5W), expressed as (5000 × 3.7) / (5 × 1000).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 979,
        "question": "Please calculate the average battery life (in hours) of the 5 mobile phones released in 2022 with the largest battery capacities.",
        "query": "SELECT AVG(hs.battery_life_hours) AS average_battery_life_hours FROM (SELECT p.phone_id, p.battery_capacity_mAh FROM phones p WHERE p.release_year = 2022 ORDER BY p.battery_capacity_mAh DESC LIMIT 5) AS top_phones JOIN hardware_specs hs ON top_phones.phone_id = hs.phone_id ORDER BY average_battery_life_hours DESC;",
        "step": "【step1】: Retrieve the top 5 phones released in 2022 sorted by descending battery capacity from the 'phones' table.  【step2】: Join these 5 phones with the 'hardware_specs' table using phone_id to access their battery life hours.  【step3】: Calculate the average battery life hours of these 5 phones and sort the result in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 980,
        "question": "Please find the phone models with a battery capacity greater than 4000mAh and screen size smaller than 6 inches, then sort them by battery capacity in descending order.",
        "query": "SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh DESC;",
        "step": "【step1】: Filter records from 'phones' table where battery_capacity_mAh > 4000 and screen_size_inches < 6  【step2】: Sort the filtered results in descending order based on battery_capacity_mAh",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 981,
        "question": "Find the phone IDs, battery capacities, and charging speeds of phones where the battery capacity is less than 10000mAh and the charging speed exceeds 50W.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh < 10000 AND hs.charging_speed_watts > 50;",
        "step": "【step1】: Join the 'phones' and 'hardware_specs' tables using phone_id to combine battery capacity and charging speed data.  【step2】: Filter records where battery_capacity_mAh < 10000.  【step3】: Further filter results where charging_speed_watts > 50 and select the required columns (phone_id, battery_capacity_mAh, charging_speed_watts).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 982,
        "question": "Calculate the battery energy (in joules) for each phone and identify the top 5 phone models with the highest battery energy.",
        "query": "SELECT phone_id, (battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones ORDER BY battery_energy_joules DESC LIMIT 5;",
        "step": "【step1】: Calculate the battery energy in joules for each phone using the formula (battery_capacity_mAh * 3.7V * 3600s) / 1000 to convert mAh to joules  【step2】: Sort all phones in descending order based on the calculated battery_energy_joules value  【step3】: Limit the final results to show only the top 5 phones with highest battery energy",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 983,
        "question": "Calculate the total screen pixel count for each phone and identify the top 10 phones with the highest pixel count.",
        "query": "SELECT phone_id, (screen_resolution_width * screen_resolution_height) AS pixel_count FROM phones ORDER BY pixel_count DESC LIMIT 10;",
        "step": "【step1】: Calculate the screen pixel count for each phone by multiplying 'screen_resolution_width' and 'screen_resolution_height' columns.  【step2】: Sort the results in descending order based on the calculated pixel count.  【step3】: Limit the output to the top 10 entries with the highest pixel counts using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 984,
        "question": "Find mobile phones with a battery life (battery_life_hours) exceeding 24 hours and a selling price (price_usd) under 500 dollars, sorted in descending order by battery life.",
        "query": "SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC;",
        "step": "【step1】:Join \"phones\" and \"hardware_specs\" tables on phone_id to combine product specifications with pricing information.  【step2】:Filter records where battery_life_hours > 24 and price_usd < 500.  【step3】:Sort the final results by battery_life_hours in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 985,
        "question": "Assuming a certain mobile phone has a battery capacity of 1,000,000mAh, calculate its battery energy (unit: joules) and identify phones with battery energy exceeding this value.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3600) / 1000 > (1000000 * 3.7 * 3600) / 1000;",
        "step": "【step1】: Calculate battery energy in joules for all phones using the formula (battery_capacity_mAh × 3.7 × 3600) ÷ 1000  【step2】: Compute the reference battery energy value from the given 1,000,000mAh capacity using the same formula  【step3】: Filter phones where calculated battery energy exceeds the reference value through conditional comparison in WHERE clause",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 986,
        "question": "Please calculate and list the top 5 mobile phones with the highest pixel density (PPI), and determine the actual physical size of each pixel (in micrometers).",
        "query": "WITH PixelDensity AS (SELECT phone_id, screen_resolution_width, screen_resolution_height, screen_size_inches, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS PPI FROM phones) SELECT p.phone_id, p.screen_resolution_width, p.screen_resolution_height, p.screen_size_inches, pd.PPI, (25.4 / pd.PPI) * 1000 AS pixel_size_micrometers FROM phones p JOIN PixelDensity pd ON p.phone_id = pd.phone_id ORDER BY pd.PPI DESC LIMIT 5;",
        "step": "【step1】: Calculate pixel density (PPI) for all phones using Pythagorean theorem on screen resolution dimensions divided by screen size, stored in CTE \"PixelDensity\".  【step2】: Join main phone data with PixelDensity CTE to compute physical pixel size (25.4/PPI converted to micrometers) while preserving resolution/size attributes.  【step3】: Sort results by descending PPI and apply LIMIT 5 to retrieve top-ranked devices with densest displays.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 987,
        "question": "Please calculate and list the top 10 mobile phones with the highest battery consumption per hour (mAh/hour), calculated as battery capacity (mAh) divided by battery life (hours), along with their phone ID, battery capacity, and battery life.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, (p.battery_capacity_mAh / hs.battery_life_hours) AS hourly_consumption_mAh_per_hour FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY (p.battery_capacity_mAh / hs.battery_life_hours) DESC LIMIT 10;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to combine battery capacity and battery life data  【step2】: Calculate battery_capacity_mAh / battery_life_hours ratio as hourly_consumption_mAh_per_hour  【step3】: Order results by the calculated ratio in descending order and limit to top 10 records",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 988,
        "question": "Please list the phones with a screen size larger than 6 inches and weight less than 150 grams, sorted by screen size in ascending order.",
        "query": "SELECT * FROM phones WHERE screen_size_inches > 6 AND weight_grams < 150 ORDER BY screen_size_inches ASC;",
        "step": "【step1】:【Retrieve all columns from the phones table】  【step2】:【Filter records where screen_size_inches > 6 and weight_grams < 150】  【step3】:【Sort the filtered results by screen_size_inches in ascending order】",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 989,
        "question": "Assuming a mobile phone has a pixel density of 10,000 PPI and a screen size of 10 inches, please calculate and list the actual physical size of each pixel in nanometers.",
        "query": "SELECT (25.4 / pixel_density_ppi) * 1000000 AS pixel_size_nm FROM phones WHERE pixel_density_ppi = 10000 AND screen_size_inches = 10;",
        "step": "【step1】: Filter the 'phones' table to retrieve records where 'pixel_density_ppi' equals 10000 and 'screen_size_inches' equals 10.  【step2】: Compute the physical pixel size in millimeters using the formula $25.4 \\, \\text{mm/inch} \\, / \\, \\text{pixel_density_ppi}$.  【step3】: Convert the millimeter value to nanometers by multiplying by $1,000,000$ and output as 'pixel_size_nm'.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 990,
        "question": "Calculate the pixel density (PPI) for each mobile phone model and identify the top 5 phones with the highest pixel density.",
        "query": "SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;",
        "step": "【step1】: Calculate PPI for each phone using screen resolution and size  【step2】: Order results by PPI in descending order  【step3】: Limit output to top 5 highest PPI phones",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 991,
        "question": "Calculate the battery energy (in joules) for each smartphone and identify the top 5 smartphones with the highest energy.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;",
        "step": "【step1】: Calculate battery energy in joules for each phone using the formula: battery_capacity_mAh × 3.7V × 3.6 (conversion factor to joules) and select phone_id  【step2】: Sort results by calculated battery_energy_joules in descending order  【step3】: Limit output to top 5 highest energy results using LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 992,
        "question": "Find the phone IDs, battery capacities in mAh, and battery life in hours for all phones, sorted in descending order by battery life.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY hs.battery_life_hours DESC;",
        "step": "【step1】: Join phones and hardware_specs tables using phone_id to combine battery capacity and life data  【step2】: Select phone_id, battery_capacity_mAh, and battery_life_hours columns from joined dataset  【step3】: Order results by battery_life_hours in descending sequence",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 993,
        "question": "Assuming the processor's clock speed (cpu_clock_speed_ghz) reaches 100GHz, calculate the adjusted Geekbench multi-core score for each smartphone and identify the top 5 smartphones with the highest adjusted scores.",
        "query": "WITH AdjustedScores AS (SELECT p.phone_id, (100 / hs.cpu_clock_speed_ghz) * pm.geekbench_multi_core_score AS adjusted_geekbench_multi_core_score FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id JOIN performance_metrics pm ON p.phone_id = pm.phone_id) SELECT phone_id, adjusted_geekbench_multi_core_score FROM AdjustedScores ORDER BY adjusted_geekbench_multi_core_score DESC LIMIT 5;",
        "step": "【step1】: Join 'phones', 'hardware_specs', and 'performance_metrics' tables using phone_id to combine hardware specifications and benchmark data.  【step2】: Calculate adjusted_geekbench_multi_core_score by scaling the original score proportionally to 100 GHz (formula: (100 / cpu_clock_speed_ghz) * geekbench_multi_core_score).  【step3】: Sort results by adjusted_geekbench_multi_core_score in descending order and return the top 5 phones using LIMIT 5.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 994,
        "question": "Calculate the power consumption and theoretical battery life of a smartphone running at full load, given its CPU clock speed is 2.5 GHz, RAM is 8 GB, and battery capacity is 4000 mAh.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, h.cpu_clock_speed_ghz, h.ram_gb, (h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) AS total_power_watts, (p.battery_capacity_mAh / ((h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) * 1000 / 3.7)) AS battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.cpu_clock_speed_ghz = 2.5 AND h.ram_gb = 8 AND p.battery_capacity_mAh = 4000;",
        "step": "【step1】: JOIN phones and hardware_specs tables via phone_id to combine battery data with hardware specifications  【step2】: FILTER records where CPU=2.5 GHz, RAM=8 GB, and battery=4000 mAh  【step3】: CALCULATE power consumption (GHz×2.5 + RAM×0.5) and derive battery life via (capacity_mAh ÷ (total_power_W×1000/3.7))",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 995,
        "question": "Calculate the maximum data volume in GB that a certain model of phone can process within one hour when it has 12 GB of RAM, a storage device read speed of 500 Mbps, and a write speed of 300 Mbps.",
        "query": "SELECT ((storage_read_speed_mbps + storage_write_speed_mbps) * 3600 / 1024) AS max_data_volume_gb FROM hardware_specs WHERE ram_gb = 12 AND storage_read_speed_mbps = 500 AND storage_write_speed_mbps = 300;",
        "step": "【step1】: Filter hardware_specs records where RAM=12GB, read speed=500MB/s, and write speed=300MB/s  【step2】: Calculate total data throughput per second (sum read/write speeds), multiply by 3600 seconds for hourly rate, then convert MB to GB by dividing with 1024",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 996,
        "question": "Query the battery life of a certain model of mobile phone, assuming its battery capacity is 5000 mAh, screen size is 6.5 inches, screen resolution is 1080x2340, and find its theoretical battery life in hours based on the given formula.",
        "query": "SELECT (5000 / ((6.5 * 1080 * 2340 * 0.000001) * 1000 / 3.7)) AS battery_life_hours FROM phones WHERE screen_size_inches = 6.5 AND screen_resolution_width = 1080 AND screen_resolution_height = 2340 AND battery_capacity_mAh = 5000;",
        "step": "【step1】: Filter the 'phones' table to find the phone with screen_size_inches=6.5, screen_resolution_width=1080, screen_resolution_height=2340, and battery_capacity_mAh=5000.  【step2】: Calculate the product of screen size (6.5 inches), resolution (1080x2340), and 0.000001 to derive the display's effective power consumption factor.  【step3】: Compute the theoretical battery life by dividing 5000 mAh by ((result from step2) multiplied by (1000 / 3.7)), yielding the video playback endurance in hours.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 997,
        "question": "Assuming a certain model of smartphone has 1024 GB of RAM, with a storage device read speed of 100,000 Mbps and a write speed of 50,000 Mbps, calculate the maximum amount of data it can process in 1 second, and determine its theoretical battery life, assuming a battery capacity of 100000 mAh.",
        "query": "WITH max_data AS (SELECT (storage_read_speed_mbps / 1000 + storage_write_speed_mbps / 1000) * 1 AS max_data_processed_tb FROM hardware_specs WHERE ram_gb = 1024) SELECT max_data_processed_tb, (battery_capacity_mAh / (cpu_clock_speed_ghz * 10 + ram_gb * 0.1 + storage_gb * 0.05) * 1000 / 3.7) AS battery_life_hours FROM max_data, hardware_specs JOIN phones ON hardware_specs.phone_id = phones.phone_id WHERE hardware_specs.ram_gb = 1024;",
        "step": "【step1】: Create a temporary CTE 'max_data' that calculates maximum processed data by summing read/write speeds (converted from MB/s to GB/s) * 1 second, filtered by RAM=1024GB.  【step2】: Join hardware_specs with phones via phone_id, then cross-reference with max_data to calculate battery life using a formula involving battery capacity divided by hardware component power consumption factors.  【step3】: Filter results where RAM=1024GB and output both max_data_processed_tb and battery_life_hours after unit conversions and power consumption calculations.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 998,
        "question": "Please query and calculate the time required for each phone model to fully charge (assuming charging from 0% to 100%) at its maximum wired charging speed, then sort the results in ascending order by charging time and return the top 5 phone models along with their charging times.",
        "query": "SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY charging_time_hours ASC LIMIT 5;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to associate battery capacity with charging speed  【step2】: Calculate charging time via formula (battery_capacity_mAh × 3.7) / (charging_speed_watts × 1000)  【step3】: Sort results by calculated charging_time_hours in ascending order and return top 5 entries",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 999,
        "question": "Please calculate the total screen pixel count (horizontal resolution * vertical resolution) for each mobile phone model, and identify the top 3 phones with the highest total pixel count, sorted in descending order by total pixels.",
        "query": "SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;",
        "step": "【step1】: Calculate the screen pixel total for each phone by multiplying screen_resolution_width and screen_resolution_height  【step2】: Order results by total_pixels in descending sequence  【step3】: Restrict output to top 3 records using LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1000,
        "question": "Please query and return the top 10 mobile phone models with battery capacities greater than 4000mAh and prices below $500, sorted in descending order by battery capacity.",
        "query": "SELECT phone_id, battery_capacity_mAh, price_usd FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh DESC LIMIT 10;",
        "step": "【step1】: Filter records from 'phones' table where battery capacity exceeds 4000mAh and price is under $500.  【step2】: Sort the filtered results by battery capacity in descending order.  【step3】: Apply the top 10 limit to the sorted dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1001,
        "question": "Assuming there is a phone with a battery capacity of 100,000 mAh and a wired charging speed of 1,000W, please calculate the time required to fully charge it.",
        "query": "SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh = 100000 AND hs.charging_speed_watts = 1000;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to combine battery capacity and charging speed data  【step2】: Filter records where battery_capacity_mAh=100000 AND charging_speed_watts=1000  【step3】: Calculate charging_time_hours using formula (battery_capacity_mAh * 3.7) / (charging_speed_watts * 1000) and select phone_id with result",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1002,
        "question": "Please calculate and list the battery energy density (in Wh/L) for phones with a battery capacity greater than 4000mAh and a screen size larger than 6 inches, then sort them in descending order by energy density and take the top 5.",
        "query": "SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_WhL FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches > 6 ORDER BY energy_density_WhL DESC LIMIT 5;",
        "step": "【step1】: Filter records from 'phones' table where battery capacity exceeds 4000mAh and screen size is larger than 6 inches.  【step2】: Calculate energy density (Wh/L) using formula (battery_capacity_mAh * 3.7) / (volume in liters derived from mm³ dimensions) for qualifying phones.  【step3】: Sort results by energy density in descending order and retain only the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1003,
        "question": "Please calculate and list the total screen pixel count (horizontal resolution * vertical resolution) for each mobile phone, and identify the top 3 phones with the highest total pixel count, sorted in descending order by total pixel count.",
        "query": "SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;",
        "step": "【step1】: Calculate pixel area for each phone by multiplying screen_resolution_width and screen_resolution_height  【step2】: Sort results by calculated total_pixels in descending order  【step3】: Restrict output to top 3 records using LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1004,
        "question": "Please list the phone models where the battery life (battery_life_hours) is greater than 24 hours and the price is under $500, sorted in descending order by battery life, and limit the results to the top 10.",
        "query": "SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC LIMIT 10;",
        "step": "【step1】: Perform INNER JOIN between phones and hardware_specs tables using phone_id to combine product specifications and pricing data  【step2】: Apply WHERE conditions to filter battery_life_hours >24 and price_usd <500  【step3】: Sort results DESC by battery_life_hours and apply LIMIT 10 to return top-ranked devices",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1005,
        "question": "Suppose there is a mobile phone with a battery capacity of 100,000 mAh, a thickness of 100 mm, a width of 200 mm, and a height of 300 mm. Please determine whether the energy density of this phone (in Wh/L) exceeds ten times the average energy density of existing mobile phone batteries.",
        "query": "WITH phone_energy_density AS (SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_wh_per_l FROM phones), average_energy_density AS (SELECT AVG(energy_density_wh_per_l) AS avg_energy_density FROM phone_energy_density) SELECT CASE WHEN (100000 * 3.7) / (100 * 200 * 300 * 0.001) > (SELECT avg_energy_density FROM average_energy_density) * 10 THEN 'Yes' ELSE 'No' END AS is_10x_higher FROM dual;",
        "step": "【step1】: Calculate energy density for all phones by multiplying battery capacity by 3.7 (conversion to Wh) and dividing by volume (converted to liters via 0.001 factor)  【step2】: Compute average energy density across all existing phones using the calculated values from step 1  【step3】: Compare target phone's energy density (calculated inline with given specs) against 10x the average from step 2, returning \"Yes\" if exceeded or \"No\" otherwise",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1006,
        "question": "Calculate the average power consumption (in watts) of the mobile phone during video playback, based on battery capacity and video playback endurance time.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours, (p.battery_capacity_mAh * 3.7 * 3.6) / (pm.battery_life_video_playback_hours * 3600) AS average_power_consumption_watts FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;",
        "step": "【step1】: Join 'phones' and 'performance_metrics' tables using phone_id to access battery capacity and video playback duration.  【step2】: Calculate total energy stored in the battery: battery_capacity_mAh × 3.7V (voltage) × 3.6 (mAh-to-Joule conversion factor).  【step3】: Divide total energy by video playback time converted to seconds (hours × 3600) to derive average power consumption in watts.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1007,
        "question": "Calculate the battery capacity per unit weight (mAh/g) for each mobile phone model, sort them in ascending order, and identify the top 5 phones with the lowest battery capacity density.",
        "query": "SELECT phone_id, (battery_capacity_mAh / weight_grams) AS battery_density_mAh_g FROM phones ORDER BY battery_density_mAh_g ASC LIMIT 5;",
        "step": "【step1】: Calculate battery density (battery_capacity_mAh / weight_grams) for all phones using the phones table  【step2】: Sort results by battery_density_mAh_g in ascending order  【step3】: Apply LIMIT 5 to retrieve the lowest-density phones",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1008,
        "question": "Find the phone IDs, battery life for video playback in hours, and prices in USD for phones with video playback battery life exceeding 20 hours and a price below $500, sorted in descending order by battery life.",
        "query": "SELECT p.phone_id, pm.battery_life_video_playback_hours, p.price_usd FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE pm.battery_life_video_playback_hours > 20 AND p.price_usd < 500 ORDER BY pm.battery_life_video_playback_hours DESC;",
        "step": "【step1】: Join `phones` and `performance_metrics` tables using `phone_id` to associate battery life data with pricing information.  【step2】: Filter results where `battery_life_video_playback_hours` exceeds 20 hours and `price_usd` is below $500.  【step3】: Sort the filtered records by `battery_life_video_playback_hours` in descending order for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1009,
        "question": "Assuming a certain mobile phone has a battery capacity of 1,000,000 mAh and a video playback endurance time of 1,000 hours, calculate its average power consumption and determine whether such a mobile phone exists.",
        "query": "SELECT (1000000 * 3.7 * 3.6) / (1000 * 3600) AS average_power_consumption_watts FROM phones WHERE battery_capacity_mAh = 1000000 AND EXISTS (SELECT 1 FROM performance_metrics WHERE performance_metrics.phone_id = phones.phone_id AND battery_life_video_playback_hours = 1000);",
        "step": "【step1】: Calculate average power consumption using the formula (battery_capacity_mAh * voltage * conversion_factor) / (video_playback_hours * seconds_per_hour). The 3.7 represents nominal battery voltage and 3.6 converts mAh to Joules.  【step2】: Filter phones table for devices with exact 1000000mAh capacity and use EXISTS subquery to verify matching video playback duration in performance_metrics table through phone_id foreign key.  【step3】: Combine calculation and existence check - returns power consumption value only if both battery capacity condition and corresponding video playback duration record exist simultaneously. Empty result set would indicate no such phone exists.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1010,
        "question": "Calculate the theoretical battery life in hours for phone ID '1' based on its battery capacity and GPU performance metric.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / pm.gfxbench_fps AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = '1';",
        "step": "【step1】: Join phones and performance_metrics tables on phone_id to access battery capacity and GFXBench fps data  【step2】: Filter for phone_id='1' to isolate the specific device  【step3】: Calculate theoretical hours by (battery_capacity_mAh × 3.7V × 3.6kJ/mAh) / GFXBench fps, converting battery energy to screen consumption rate",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1011,
        "question": "Calculate the theoretical battery life of a specific model phone when continuously running a graphics benchmark at maximum performance, assuming all battery energy is converted into graphics processing power consumption.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / (pm.gfxbench_fps * pm.gfxbench_fps) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = 'specific_phone_id';",
        "step": "【step1】: Join the `phones` and `performance_metrics` tables via `phone_id` to link battery capacity and GPU benchmark data.  【step2】: Compute total battery energy (mAh × 3.7V voltage × 3.6 to convert Wh to kJ) divided by squared GPU benchmark FPS, assuming FPS² correlates to screen energy consumption rate.  【step3】: Filter results for `phone_id = 'specific_phone_id'` to isolate the target device's theoretical runtime.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1012,
        "question": "Based on the phone's battery capacity and charging speed, calculate the time required to charge the phone from 0% to 100%.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000 / 5)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables via phone_id to link battery capacity and charging speed data.  【step2】: Apply charging time formula: battery_capacity_mAh divided by (charging_speed_watts × 1000/5).  【step3】: Project phone_id, battery capacity, charging speed, and calculated charging_time_hours.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1013,
        "question": "Assuming a certain model of mobile phone has a battery capacity of 100,000mAh and a charging speed of 1000W, calculate the time required to charge the phone from 0% to 100%.",
        "query": "SELECT p.battery_capacity_mAh / (h.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh = 100000;",
        "step": "【step1】: Filter the phones table to find the specific phone with battery_capacity_mAh = 100000  【step2】: Join with hardware_specs table to obtain charging_speed_watts value  【step3】: Calculate charging time by dividing battery_capacity_mAh by (charging_speed_watts * 1000) to convert watts to milliwatts and derive hours",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1014,
        "question": "Calculate the maximum power consumption of the mobile phone with ID '1' when the screen is at its maximum brightness of 500 nits, given that power consumption is directly proportional to brightness and the phone consumes 2W at 250 nits.",
        "query": "SELECT (2 * (500 / 250)) AS max_power_consumption_watts FROM phones WHERE phone_id = '1';",
        "step": "【step1】: Retrieve the target phone record from the 'phones' table using phone_id='1' to ensure device existence.  【step2】: Calculate the maximum power consumption by applying the proportional relationship (2W * (500nits / 250nits)) where 500nits is max brightness and 250nits corresponds to the 50% brightness reference.  【step3】: Output the computed value as max_power_consumption_watts via scalar calculation without requiring table joins.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1015,
        "question": "Calculate the total energy in watt-hours and average power consumption in watts for phone_id '1' based on its battery capacity and voltage.",
        "query": "SELECT (battery_capacity_mAh * 3.7) / 1000 AS total_energy_Wh, ((battery_capacity_mAh * 3.7) / 1000) / 10 AS avg_power_consumption_W FROM phones WHERE phone_id = '1';",
        "step": "【step1】: Retrieve battery capacity (battery_capacity_mAh) for phone_id='1' from phones table.  【step2】: Calculate total_energy_Wh via (battery_capacity_mAh * 3.7)/1000 and avg_power_consumption_W by dividing total_energy_Wh by the assumed 10-hour runtime.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1016,
        "question": "Find the phone models with battery capacity greater than 4000mAh and price below $500, sorted in ascending order by battery capacity.",
        "query": "SELECT phone_id, battery_capacity_mAh FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh ASC;",
        "step": "【step1】: Filter records from the 'phones' table where battery_capacity_mAh exceeds 4000mAh and price_usd is under $500 using the WHERE clause.  【step2】: Select the required columns (phone_id, battery_capacity_mAh) from the filtered results.  【step3】: Sort the final output by battery_capacity_mAh in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1017,
        "question": "Assuming the thermal throttling percentage of a certain model of mobile phone is 200%, calculate its performance loss, and identify the phone models with performance losses exceeding 50%.",
        "query": "SELECT pm.phone_id, (pm.thermal_throttling_percentage - 100) AS performance_loss_percentage FROM performance_metrics pm WHERE pm.thermal_throttling_percentage > 150;",
        "step": "【step1】: Retrieve all phone records with their thermal throttling percentages from the performance_metrics table.  【step2】: Calculate the performance loss percentage by subtracting 100% from the thermal_throttling_percentage.  【step3】: Filter results to include only phones where the calculated performance_loss_percentage exceeds 50% (equivalent to thermal_throttling_percentage > 150).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1018,
        "question": "Calculate the total energy, in joules, that the phone with the largest battery capacity among those sold in 2022 can provide when fully charged.",
        "query": "SELECT (MAX(p.battery_capacity_mAh) / 1000) * 3.7 * 3600 AS total_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022;",
        "step": "【step1】: Join \"phones\" with \"sales_data\" to filter phones sold in 2022.  【step2】: Extract the maximum battery capacity (mAh) from the filtered results.  【step3】: Convert mAh to joules using formula: (mAh/1000)*(voltage 3.7V)*(3600 seconds).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1019,
        "question": "Find the phone model with the highest revenue in 2021 and the phone model with the highest revenue in 2022, and calculate the percentage growth rate from the 2021 revenue to the 2022 revenue.",
        "query": "WITH yearly_revenue AS (SELECT p.phone_id, sd.sale_year, SUM(sd.revenue_usd) AS total_revenue FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id WHERE sd.sale_year IN (2021, 2022) GROUP BY p.phone_id, sd.sale_year), max_revenue_per_year AS (SELECT sale_year, MAX(total_revenue) AS max_revenue FROM yearly_revenue GROUP BY sale_year), top_phones AS (SELECT yr.phone_id, yr.sale_year, yr.total_revenue FROM yearly_revenue yr JOIN max_revenue_per_year mrpy ON yr.sale_year = mrpy.sale_year AND yr.total_revenue = mrpy.max_revenue) SELECT tp2021.phone_id AS top_phone_2021, tp2021.total_revenue AS revenue_2021, tp2022.phone_id AS top_phone_2022, tp2022.total_revenue AS revenue_2022, ((tp2022.total_revenue - tp2021.total_revenue) / tp2021.total_revenue) * 100 AS growth_rate_percentage FROM top_phones tp2021 JOIN top_phones tp2022 ON tp2021.sale_year = 2021 AND tp2022.sale_year = 2022;",
        "step": "【step1】: Calculate yearly revenue for each phone in 2021 and 2022 by joining phones and sales_data tables, grouping by phone_id and sale_year.  【step2】: Identify maximum revenue per year and match corresponding phone records through CTEs (max_revenue_per_year and top_phones) to isolate top-selling phones annually.  【step3】: Compare 2021 and 2022 results via self-join on top_phones CTE, calculate revenue growth rate between years.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1020,
        "question": "Find the battery life and average customer satisfaction score for the highest-selling mobile phone model in 2022.",
        "query": "WITH top_selling_phone_2022 AS (SELECT sd.phone_id, SUM(sd.units_sold) AS total_units_sold FROM sales_data sd WHERE sd.sale_year = 2022 GROUP BY sd.phone_id ORDER BY total_units_sold DESC LIMIT 1) SELECT p.phone_id, hs.battery_life_hours, AVG(sd.customer_satisfaction_score) AS avg_customer_satisfaction_score FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id JOIN sales_data sd ON p.phone_id = sd.phone_id JOIN top_selling_phone_2022 tsp ON p.phone_id = tsp.phone_id GROUP BY p.phone_id, hs.battery_life_hours;",
        "step": "【Step1】: Identify the top-selling phone in 2022 using a CTE by summing units_sold from sales_data, filtering for 2022 sales, ordering by total sales in descending order, and limiting to 1 result.  【Step2】: Join phones and hardware_specs tables to retrieve the battery_life_hours of the identified top-selling phone.  【Step3】: Link sales_data to calculate average customer satisfaction score, aggregating by phone_id and battery_life_hours from the CTE and hardware specs.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1021,
        "question": "Assuming a mobile phone has a battery capacity of 100,000mAh, calculate how many hours the phone can continuously play videos on a full charge under ideal conditions?",
        "query": "SELECT (battery_capacity_mAh / 1000) * 3.7 / 5 AS video_playback_hours FROM phones WHERE battery_capacity_mAh = 100000;",
        "step": "【step1】: Filter the 'phones' table to retrieve the phone with a battery capacity of 100000mAh.  【step2】: Calculate the total energy capacity in watt-hours (Wh) by converting mAh to Ah (100000/1000) and multiplying by the voltage (3.7V).  【step3】: Divide the total energy (Wh) by the assumed power consumption for video playback (5W) to determine the video playback hours.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1022,
        "question": "Calculate the time required in seconds to download a 10KB file at the download speed for phone_id 2.",
        "query": "SELECT (10 * 1024) / (download_speed_mbps * 8) AS download_time_seconds FROM network_performance WHERE phone_id =2;",
        "step": "【step1】: Filter the network_performance table to retrieve the download_speed_mbps value for phone_id = 2.  【step2】: Convert 10GB to megabytes (10 * 1024) and calculate download time by dividing the converted size by the effective speed (download_speed_mbps * 8) to account for Mbps-to-MB/s conversion.  【step3】: Return the calculated download_time_seconds as the final result.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1023,
        "question": "Calculate the total amount of data in gigabytes that a mobile phone can transfer in one year given its download and upload speeds.",
        "query": "SELECT n.phone_id, ((n.download_speed_mbps + n.upload_speed_mbps) * 3600 * 24 * 365 / 8 / 1024) AS total_data_gb FROM network_performance n;",
        "step": "【step1】: Retrieve the phone_id, download_speed_mbps, and upload_speed_mbps from the network_performance table.  【step2】: Calculate the combined total speed (download + upload) in Mbps and multiply by the total seconds in a year (3600*24*365) to get total bits transferred.  【step3】: Convert the result to gigabytes by dividing by 8 (bits to bytes) and 1024 (MB to GB), then label as total_data_gb.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1024,
        "question": "Based on the phone's battery capacity and download speed, estimate how long the phone's battery can last during continuous data downloading.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, np.download_speed_mbps, (p.battery_capacity_mAh * 3.7) / (np.download_speed_mbps * 0.1) AS battery_life_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;",
        "step": "【step1】: Join 'phones' and 'network_performance' tables using phone_id to combine battery capacity and download speed data.  【step2】: Calculate battery life hours via formula: (battery_capacity_mAh * 3.7) / (download_speed_mbps * 0.1), assuming 3.7V battery voltage and 0.1W power consumption per Mbps download.  【step3】: Select phone_id, battery_capacity_mAh, download_speed_mbps, and the computed battery_life_hours as the final output.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1025,
        "question": "Assuming a mobile phone has a download speed of 1 Tbps, calculate theoretically how much data such a phone could download in one year.",
        "query": "SELECT (1000000 * 3600 * 24 * 365 / 8 / 1024 / 1024 / 1024) AS total_download_data_eb FROM dual;",
        "step": "【step1】: Calculate the total number of megabits downloaded in one year by multiplying the speed (1 Tbps = 1,000,000 Mbps) by the annual seconds (3600*24*365).  【step2】: Convert total megabits to megabytes (MB) by dividing by 8 (bits to bytes).  【step3】: Convert MB to exabytes (EB) by dividing by 1024^3 (1 EB = 1024^3 GB, and 1 GB = 1024 MB).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1026,
        "question": "Calculate the screen area, pixel width, and pixel height for each mobile phone based on their screen size, resolution, and pixel density.",
        "query": "SELECT phone_id, screen_size_inches, screen_resolution_width, screen_resolution_height, pixel_density_ppi, (POWER(screen_size_inches, 2) / (1 + POWER(screen_resolution_height / screen_resolution_width, 2)) * (screen_resolution_width / screen_resolution_height)) AS screen_area_square_inches, (25.4 / pixel_density_ppi) AS pixel_width_mm, (25.4 / pixel_density_ppi) AS pixel_height_mm FROM phones;",
        "step": "【step1】: Extract the phone's screen specifications (screen size in inches, resolution width/height, pixel density) from the 'phones' table.  【step2】: Calculate the screen area using the formula that factors in screen size and aspect ratio derived from resolution.  【step3】: Compute physical pixel dimensions by dividing 25.4 mm (1 inch) by pixel density (PPI) for both width and height.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1027,
        "question": "Calculate the battery energy (in joules) for each mobile phone model, and based on its battery life and charging speed, determine its average power consumption and charging efficiency.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, hs.charging_speed_watts, (p.battery_capacity_mAh * 3.7 * 3600 / 1000) AS battery_energy_joules, ((p.battery_capacity_mAh * 3.7 * 3600 / 1000) / (hs.battery_life_hours * 3600)) AS average_power_consumption_watts, ((p.battery_capacity_mAh / (hs.charging_speed_watts * 1000 / 3.7)) * 100) AS charging_efficiency_percentage FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to access battery_capacity_mAh, battery_life_hours, and charging_speed_watts.  【step2】: Calculate battery_energy_joules using formula: battery_capacity_mAh × 3.7V × 3600s / 1000 for milliampere-hour to joules conversion.  【step3】: Derive average_power_consumption_watts (battery_energy_joules / total_seconds_of_life) and charging_efficiency_percentage (capacity / (charging_speed_watts × 1000/3.7) × 100).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1028,
        "question": "Based on the weight and dimensions of the mobile phone, determine its suitability for one-handed operation.",
        "query": "SELECT phone_id, weight_grams, width_mm, thickness_mm, CASE WHEN weight_grams < 200 AND width_mm < 75 AND thickness_mm < 10 THEN '适合' ELSE '不适合' END AS 单手操作适合性 FROM phones;",
        "step": "【step1】: Extract the required physical dimensions (weight_grams, width_mm, thickness_mm) and phone_id from the 'phones' table.  【step2】: Apply conditional logic using CASE to evaluate ergonomic thresholds: weight < 200g, width < 75mm, thickness < 10mm simultaneously.  【step3】: Assign the label '适合' if all three conditions are met; otherwise, label '不适合' via the 单手操作适合性 column.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1029,
        "question": "Assuming a certain phone has a battery capacity of 1,000,000 mAh, calculate the time required to fully charge it, and based on its battery life, determine whether it can serve as a permanently self-sustaining device. Assuming a charging speed of 100 watts and a battery voltage of 3.7V, calculate the time needed for a full charge. Based on the battery life, assess whether it can function as a permanently self-sustaining device (i.e., with a battery life exceeding 100 years), while filtering for phones that match these battery capacity and charging speed specifications.",
        "query": "SELECT phones.phone_id, battery_capacity_mAh, charging_speed_watts, (battery_capacity_mAh * 3.7) / (charging_speed_watts * 1000) AS charge_time_hours, IF(battery_life_hours > 100 * 365 * 24, '是', '否') AS is_permanent_device FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 1000000 AND charging_speed_watts = 100;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id, filter records where battery_capacity_mAh=1000000 AND charging_speed_watts=100.  【step2】: Calculate charge_time_hours via (battery_capacity_mAh * 3.7V) / (charging_speed_watts * 1000) to convert mAh-to-Wh and derive hours.  【step3】: Apply conditional logic using battery_life_hours to determine if it exceeds 876,000 hours (100 years) via IF(), returning '是' or '否' for is_permanent_device.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1030,
        "question": "Identify the mobile phone model with the highest pixel density (PPI).",
        "query": "WITH PixelDensity AS (SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS ppi FROM phones) SELECT phone_id, ppi FROM PixelDensity WHERE ppi = (SELECT MAX(ppi) FROM PixelDensity);",
        "step": "【step1】: Calculate PPI for each phone using the formula (sqrt(screen_resolution_width² + screen_resolution_height²)/screen_size_inches) and store results in CTE  【step2】: Find the maximum PPI value from the calculated results  【step3】: Select phone_id(s) matching the maximum PPI value to identify the model(s) with highest pixel density",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1031,
        "question": "Calculate the total storage bandwidth of each phone model and identify the phone model with the highest storage bandwidth.",
        "query": "SELECT p.phone_id, (h.storage_read_speed_mbps + h.storage_write_speed_mbps) AS total_storage_bandwidth_mbps FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY total_storage_bandwidth_mbps DESC LIMIT 1;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to link storage speed data with phone models.  【step2】: Calculate total storage bandwidth for each phone by summing storage_read_speed_mbps and storage_write_speed_mbps.  【step3】: Order results by total_storage_bandwidth_mbps in descending order and select the top result to identify the highest bandwidth model.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1032,
        "question": "Find the phone model with the largest battery capacity and fastest charging speed.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY p.battery_capacity_mAh DESC, h.charging_speed_watts DESC LIMIT 1;",
        "step": "【step1】: Identify required data fields (phone_id, battery_capacity_mAh from phones; charging_speed_watts from hardware_specs)  【step2】: Perform INNER JOIN between phones and hardware_specs tables using phone_id to combine related specifications  【step3】: Sort results by battery_capacity_mAh (DESC) then charging_speed_watts (DESC), limit to top result to find maximum values simultaneously",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1033,
        "question": "Assuming a certain mobile phone has a battery capacity exceeding 100,000mAh and a charging speed exceeding 1000W, calculate the time required to fully charge it, and find all mobile phone models with such specifications.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts, (p.battery_capacity_mAh / hs.charging_speed_watts) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh > 100000 AND hs.charging_speed_watts > 1000;",
        "step": "【step1】: Join the 'phones' and 'hardware_specs' tables using `phone_id` to combine battery capacity and charging speed data.  【step2】: Filter records where `battery_capacity_mAh > 100000` and `charging_speed_watts > 1000` to isolate qualifying phones.  【step3】: Calculate `charging_time_hours` by dividing `battery_capacity_mAh` by `charging_speed_watts`, then project the required fields.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1034,
        "question": "Calculate the theoretical battery life in hours for phone_id 1, assuming the battery capacity in mAh is converted to watt-hours using a nominal voltage of 3.7V and the device consumes 4W of power continuously.",
        "query": "SELECT (p.battery_capacity_mAh * 3.7) / (4 * 1000) AS battery_life_hours FROM phones p WHERE p.phone_id = 1;",
        "step": "【step1】: Retrieve battery capacity (mAh) for phone_id=1 from phones table  【step2】: Calculate total energy by multiplying battery capacity with 3.7V (converting mAh to Wh)  【step3】: Divide total energy by 4W power consumption (4W = 4000mW) to get runtime hours",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1035,
        "question": "Calculate the total energy consumption in watt-hours for the specific smartphone with ID 'specific_phone_id' based on its hardware specifications and battery life.",
        "query": "SELECT p.phone_id, (h.cpu_clock_speed_ghz * 2.5 + h.gpu_cores * 1.2 + (p.screen_size_inches * 0.1) + 0.5) * h.battery_life_hours AS total_energy_consumption_wh FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.phone_id = 'specific_phone_id';",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to access device specifications and battery life data.  【step2】: Calculate component-specific energy consumption by applying coefficients (CPU: 2.5W/GHz, GPU: 1.2W/core, screen: 0.1W/inch, fixed 0.5W for others).  【step3】: Multiply the sum of component power by battery_life_hours to derive total energy consumption in watt-hours (Wh) for the specified phone_id.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1036,
        "question": "Calculate the time required to charge a phone from 0% to 100% based on its battery capacity and charging speed.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;",
        "step": "【step1】: Join 'phones' and 'hardware_specs' tables using phone_id to combine battery capacity and charging speed data  【step2】: Calculate theoretical charging time using formula: battery_capacity_mAh / (charging_speed_watts * 1000)  【step3】: Select required fields (phone ID, battery capacity, charging speed) with calculated charging_time_hours",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1037,
        "question": "Assuming a certain mobile phone has a battery capacity of 100,000 mAh and a charging speed of 1000W, calculate the time required to charge it from 0% to 100%.",
        "query": "SELECT (battery_capacity_mAh / (charging_speed_watts * 1000)) AS charging_time_hours FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 100000 AND charging_speed_watts = 1000;",
        "step": "【step1】: Join `phones` and `hardware_specs` tables via `phone_id` to combine battery capacity and charging speed data.  【step2】: Filter rows where `battery_capacity_mAh = 100000` and `charging_speed_watts = 1000` to identify the target device.  【step3】: Calculate theoretical charging time using the formula `battery_capacity_mAh / (charging_speed_watts * 1000)` (note: this assumes unit conversions between mAh and watt-hours are handled implicitly).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1038,
        "question": "Calculate the theoretical battery life in hours for each phone model by dividing battery capacity by battery life during video playback, assuming 1000 mA per hour.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh / (pm.battery_life_video_playback_hours * 1000) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;",
        "step": "【step1】: Join the 'phones' and 'performance_metrics' tables using phone_id to access battery capacity and video playback battery consumption data  【step2】: Calculate theoretical battery life by dividing battery_capacity_mAh by (battery_life_video_playback_hours × 1000) to convert units  【step3】: Select phone_id and formatted calculation result as theoretical_battery_life_hours",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1039,
        "question": "Calculate the sales growth rate of phone ID '1' for the year 2022, and identify the month with the highest growth rate.",
        "query": "WITH MonthlySales AS (SELECT phone_id, sale_year, sale_month, SUM(units_sold) AS total_units_sold FROM sales_data WHERE phone_id = '1' AND sale_year = '2022' GROUP BY phone_id, sale_year, sale_month), GrowthRates AS (SELECT ms1.phone_id, ms1.sale_year, ms1.sale_month, ms1.total_units_sold AS current_month_sales, ms2.total_units_sold AS previous_month_sales, ((ms1.total_units_sold - ms2.total_units_sold) / ms2.total_units_sold) * 100 AS growth_rate FROM MonthlySales ms1 LEFT JOIN MonthlySales ms2 ON ms1.phone_id = ms2.phone_id AND ms1.sale_year = ms2.sale_year AND ms1.sale_month = ms2.sale_month + 1) SELECT sale_month, growth_rate FROM GrowthRates WHERE growth_rate IS NOT NULL ORDER BY growth_rate DESC LIMIT 1;",
        "step": "【step1】: Calculate monthly sales for the specified phone and year using CTE \"MonthlySales\", aggregating units_sold grouped by phone_id, sale_year, and sale_month.  【step2】: Compute month-over-month growth rates via self-join in CTE \"GrowthRates\", comparing current_month_sales with previous_month_sales using LEFT JOIN offset by 1 month.  【step3】: Filter non-null growth rates, sort results in descending order, and return the month with the highest growth rate using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1040,
        "question": "Calculate the pixel density (PPI) based on the screen resolution and size of a mobile phone.",
        "query": "SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones;",
        "step": "【step1】: Calculate the diagonal pixel count using Pythagorean theorem by squaring both screen_resolution_width and screen_resolution_height  【step2】: Compute the square root of the sum of squared resolutions to get diagonal pixels  【step3】: Divide diagonal pixels by screen_size_inches to obtain pixel density (PPI)",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1041,
        "question": "Assuming a certain smartphone has a battery capacity of 100000mAh, calculate its battery life in hours under extreme conditions, assuming its power consumption is 10000mW.",
        "query": "SELECT 100000 / (10000 / 1000) AS battery_life_hours;",
        "step": "【step1】: Convert power consumption from milliwatts to watts: 10000mW / 1000 = 10W  【step2】: Calculate battery life by dividing battery capacity (mAh) by converted power consumption (W): 100000 / (10W / 1V) → implicit voltage assumption  【step3】: Simplify calculation using direct unit conversion: 100000mAh / (10000mW/1000) = battery_life_hours",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "1",
        "idx": 1042,
        "question": "Calculate how long the battery can last in hours when a smartphone is fully charged and continuously downloading data at the maximum download speed.",
        "query": "SELECT p.phone_id, p.battery_capacity_mAh * 3.7 / 1000 AS battery_energy_Wh, np.download_speed_mbps * 0.1 AS download_power_W, (p.battery_capacity_mAh * 3.7 / 1000) / (np.download_speed_mbps * 0.1) AS discharge_time_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;",
        "step": "【step1】: Calculate battery energy in watt-hours (Wh) by converting mAh to Wh using formula: (battery_capacity_mAh * 3.7V) / 1000  【step2】: Calculate power consumption during maximum download using assumed 0.1W per Mbps: download_speed_mbps * 0.1  【step3】: Compute discharge time by dividing total battery energy (Wh) by power consumption (W): battery_energy_Wh / download_power_W",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "2",
        "idx": 1043,
        "question": "Calculate the total number of screen pixels and pixel density for each smartphone, then compare the pixel density across different phones.",
        "query": "SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels, (screen_resolution_width * screen_resolution_height) / (screen_size_inches * screen_size_inches) AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC;",
        "step": "【step1】: Retrieve screen resolution (width and height) and screen size from the 'phones' table.  【step2】: Calculate total pixels by multiplying screen_resolution_width and screen_resolution_height, then compute pixel density using (total_pixels) / (screen_size_inches²).  【step3】: Sort the results by pixel_density_ppi in descending order to compare density across phones.",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "3",
        "idx": 1044,
        "question": "Analyze the relationship between the battery life of a certain mobile phone and its battery capacity, screen size, and processor speed, and provide optimization recommendations.",
        "query": "SELECT p.phone_id, p.screen_size_inches, h.cpu_clock_speed_ghz, p.battery_capacity_mAh, h.battery_life_hours, (p.battery_capacity_mAh / (p.screen_size_inches * h.cpu_clock_speed_ghz * 0.1)) AS calculated_battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;",
        "step": "【step1】: Perform INNER JOIN between 'phones' and 'hardware_specs' tables using phone_id to consolidate screen size, CPU speed, battery capacity, and actual battery life.  【step2】: Calculate theoretical battery life using the formula (battery_capacity / (screen_size × CPU_speed × 0.1)) to model energy consumption.  【step3】: Compare calculated_battery_life_hours with actual battery_life_hours to identify discrepancies and infer optimization opportunities (e.g., software efficiency, display refresh rate, background process management).",
        "format": "MySQL"
    },
    {
        "db_id": "phone",
        "type": "4",
        "idx": 1045,
        "question": "Assuming a certain smartphone has a download speed of 1000 Mbps, calculate the total amount of data downloaded continuously over one month (30 days), and analyze its impact on battery life by calculating the battery loss percentage if the phone is charged continuously over that period.",
        "query": "WITH phone_data AS (SELECT p.phone_id, p.battery_capacity_mAh, np.download_speed_mbps, hs.battery_life_hours, hs.charging_speed_watts FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id JOIN network_performance np ON p.phone_id = np.phone_id WHERE np.download_speed_mbps = 1000) SELECT phone_id, (download_speed_mbps * 30 * 24 * 60 * 60) / (8 * 1024 * 1024) AS total_data_tb, (charging_speed_watts * 30 * 24) / (battery_capacity_mAh * 3.7 / 1000) * 100 AS battery_loss_percentage FROM phone_data;",
        "step": "【step1】: Join three tables (phones, hardware_specs, network_performance) via phone_id and filter devices with 1000Mbps download speed.  【step2】: Calculate monthly total download data (TB) using formula: (download_speed * seconds_in_30_days) / (8*1024²) for bit-to-TB conversion.  【step3】: Compute battery degradation by comparing total charging energy (watts × hours) to battery capacity (mAh × voltage), then convert to percentage loss.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1046,
        "question": "Query all researchers who have participated in experiments using a spectrometer, sorted in descending order by the number of experiments they participated in, and return the names of the top 5 researchers and the number of experiments they participated in.",
        "query": "SELECT r.researcherName, COUNT(e.experimentId) AS experimentCount FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '光谱仪' GROUP BY r.researcherId ORDER BY experimentCount DESC LIMIT 5;",
        "step": "【step1】: Join Researchers, Experiments, ExperimentData, and Devices tables to link researchers with experiments using spectrometer devices via deviceType='光谱仪'  【step2】: Group results by researcherId and count experiment occurrences using COUNT(e.experimentId)  【step3】: Sort results by experimentCount DESC and limit output to top 5 records",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1047,
        "question": "Calculate the average number of equipment per laboratory, and identify laboratories with equipment numbers above the average. Return the names of these laboratories along with their equipment counts, sorted in descending order by equipment count.",
        "query": "WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount ORDER BY equipmentCount DESC;",
        "step": "【step1】: Calculate the average equipment count across all labs using the Labs table (AVG(equipmentCount)).  【step2】: Join Labs with the calculated average (via implicit cross join) and filter labs where equipmentCount exceeds the average.  【step3】: Sort the remaining labs by equipmentCount in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1048,
        "question": "Query all researchers who joined the lab in 2023, sort them in ascending order by their joining date, and return the names and joining dates of the top 10 researchers.",
        "query": "SELECT researcherName, joinDate FROM Researchers WHERE YEAR(joinDate) = 2023 ORDER BY joinDate ASC LIMIT 10;",
        "step": "【step1】: Filter records from the Researchers table where YEAR(joinDate) = 2023  【step2】: Sort the filtered results by joinDate in ascending order  【step3】: Limit the output to the first 10 entries and return researcherName and joinDate fields",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1049,
        "question": "Assuming the laboratory's capacity can be expanded infinitely, query the total capacity of all laboratories and calculate the new total capacity if each laboratory's capacity is increased by 1,000. Return the new total capacity.",
        "query": "SELECT SUM(capacity) + (COUNT(labId) * 1000) AS new_total_capacity FROM Labs;",
        "step": "【step1】: Calculate the original total capacity by summing all capacity values from the Labs table using SUM(capacity).  【step2】: Determine the number of laboratories by counting labId entries in the Labs table using COUNT(labId).  【step3】: Compute the new_total_capacity by adding the original total capacity to the product of the lab count and 1000 (SUM(capacity) + COUNT(labId)*1000).",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1050,
        "question": "Query the name of the laboratory with the highest number of equipment in the lab, its equipment count, and calculate the total power of these equipment (assuming the average power of each device is 500W).",
        "query": "SELECT labName, equipmentCount, (equipmentCount * 500) AS totalPower FROM Labs WHERE equipmentCount = (SELECT MAX(equipmentCount) FROM Labs);",
        "step": "【step1】: Retrieve the maximum equipment count from the Labs table using a subquery: `SELECT MAX(equipmentCount) FROM Labs`.  【step2】: Filter labs where `equipmentCount` matches the maximum value obtained in Step 1.  【step3】: Calculate the total power by multiplying `equipmentCount` by 500 and return the final result with `labName`, `equipmentCount`, and `totalPower`.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1051,
        "question": "Retrieve the top 10 records with the highest measured values from the experimental data table, and calculate the average, variance, and standard deviation of these measured values.",
        "query": "WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData ORDER BY measurementValue DESC LIMIT 10) SELECT AVG(measurementValue) AS average_value, VARIANCE(measurementValue) AS variance_value, STDDEV(measurementValue) AS stddev_value FROM TopMeasurements;",
        "step": "【step1】: Retrieve the top 10 highest measurement values from ExperimentData using descending order and limit  【step2】: Create a temporary result set (TopMeasurements) containing these 10 values  【step3】: Calculate aggregate statistics (AVG, VARIANCE, STDDEV) from the temporary result set",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1052,
        "question": "Retrieve the names and locations of laboratories with a capacity exceeding 100 people, and list the names of ongoing experiments in these laboratories.",
        "query": "SELECT L.labName, L.location, E.experimentName FROM Labs L JOIN Experiments E ON L.labId = E.labId WHERE L.capacity > 100 AND E.status = '进行中';",
        "step": "【step1】: Filter the Labs table to select labs with a capacity greater than 100.  【step2】: Join the filtered Labs with the Experiments table using labId to link related records.  【step3】: Apply a condition to the joined Experiments table to only include experiments with status '进行中' (ongoing).",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1053,
        "question": "Query the experiments in progress, calculate the average value of measurements in each experiment, and sort them in ascending order.",
        "query": "SELECT e.experimentId, e.experimentName, AVG(ed.measurementValue) AS averageMeasurementValue FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.status = '进行中' GROUP BY e.experimentId, e.experimentName ORDER BY averageMeasurementValue ASC;",
        "step": "【step1】: Join Experiments and ExperimentData tables on experimentId, filtering for experiments with status '进行中'.  【step2】: Group the joined dataset by experimentId and experimentName, calculate average measurementValue using AVG().  【step3】: Sort the grouped results by averageMeasurementValue in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1054,
        "question": "Query the calculated results of completed experiments, sorted in descending order by the size of the results, and return the top 5 results.",
        "query": "SELECT result FROM Calculations WHERE experimentId IN (SELECT experimentId FROM Experiments WHERE status = '已完成') ORDER BY result DESC LIMIT 5;",
        "step": "【step1】: Retrieve experiment IDs from Experiments table where status is 'Completed'.  【step2】: Select results from Calculations table where experimentId matches the subquery results.  【step3】: Sort results in descending order and limit output to top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1055,
        "question": "Query the lab ID, lab name, capacity, number of equipment, and equipment density (number of equipment / capacity) for all laboratories, and sort them in descending order by equipment density.",
        "query": "SELECT labId, labName, capacity, equipmentCount, (equipmentCount / capacity) AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC;",
        "step": "【step1】: Select labId, labName, capacity, and equipmentCount directly from the Labs table  【step2】: Calculate equipmentDensity by dividing equipmentCount by capacity  【step3】: Sort results using ORDER BY equipmentDensity DESC",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1056,
        "question": "Assuming all experimental measurements are multiplied by 1000, query the average of these exaggerated measurements for each experiment and sort them in ascending order. Additionally, return only the rows from the grouped results that have an average value that does not appear elsewhere in the grouped results (i.e., the unique average values).",
        "query": "WITH ExaggeratedMeasurements AS (SELECT experimentId, AVG(measurementValue * 1000) AS exaggeratedAvg FROM ExperimentData GROUP BY experimentId ORDER BY exaggeratedAvg ASC) SELECT * FROM ExaggeratedMeasurements WHERE exaggeratedAvg NOT IN (SELECT exaggeratedAvg FROM ExaggeratedMeasurements);",
        "step": "【step1】: Create a CTE named ExaggeratedMeasurements that calculates the average of measurementValue multiplied by 1000 for each experimentId, grouping by experimentId and ordering the result by exaggeratedAvg in ascending order.  【step2】: In the main query, select all columns from the CTE where the exaggeratedAvg value does not exist in the subquery results of the same CTE (effectively filtering out any duplicate averages).  【step3】: Execute the final query to return the difference set between the first result set (all exaggerated averages) and the second result set (same averages used as filter conditions), leveraging NOT IN to exclude matches.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1057,
        "question": "Please query the device ID, device name, calibration date, and calibration interval in days for all devices, sort them in ascending order by the calibration interval days, and return the top 5 devices.",
        "query": "SELECT deviceId, deviceName, calibrationDate, DATEDIFF(CURDATE(), calibrationDate) AS calibrationIntervalDays FROM Devices ORDER BY calibrationIntervalDays ASC LIMIT 5;",
        "step": "【step1】: Select deviceId, deviceName, calibrationDate and calculate calibration interval days using DATEDIFF between current date and calibrationDate  【step2】: Sort results by calculated calibrationIntervalDays in ascending order  【step3】: Apply LIMIT 5 to return the top 5 devices with shortest calibration intervals",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1058,
        "question": "Please calculate the ratio of the number of equipment to the laboratory capacity for each lab, sort the results in descending order by this ratio, and return the top 3 labs with their respective equipment-to-capacity ratios.",
        "query": "SELECT labId, labName, equipmentCount / capacity AS densityRatio FROM Labs ORDER BY densityRatio DESC LIMIT 3;",
        "step": "【step1】: Retrieve labId, labName, and calculate densityRatio by dividing equipmentCount by capacity from Labs table  【step2】: Order results by densityRatio in descending order  【step3】: Restrict output to top 3 records using LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1059,
        "question": "Please query all devices in the equipment table with a status of \"fault,\" group them by device type, and return the count of faulty devices for each device type.",
        "query": "SELECT deviceType, COUNT(*) AS faultCount FROM Devices WHERE status = '故障' GROUP BY deviceType;",
        "step": "【step1】: Filter records from the Devices table where the status is '故障' using the WHERE clause  【step2】: Group the filtered records by deviceType using the GROUP BY clause  【step3】: Calculate the count of devices per group using COUNT(*) and alias it as faultCount",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1060,
        "question": "Assuming the calibration dates in the equipment table can be extended indefinitely, please query the device IDs, device names, calibration dates, and the dates after extending the calibration date by 100 years for all devices, sort them in descending order by the extended date, and return the first 10 devices.",
        "query": "SELECT deviceId, deviceName, calibrationDate, DATE_ADD(calibrationDate, INTERVAL 100 YEAR) AS extendedCalibrationDate FROM Devices ORDER BY extendedCalibrationDate DESC LIMIT 10;",
        "step": "【step1】: Select deviceId, deviceName, calibrationDate, and compute extendedCalibrationDate using DATE_ADD(calibrationDate, INTERVAL 100 YEAR)  【step2】: Order results by extendedCalibrationDate in descending order  【step3】: Restrict output to the first 10 records using LIMIT 10",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1061,
        "question": "Query the top 5 measurement values from the experimental data table for spectrometer devices, and calculate the average value and standard deviation of these values. Assume this data represents light intensity measured by a spectrometer with the unit in lumens (lm).",
        "query": "WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') ORDER BY measurementValue DESC LIMIT 5) SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM TopMeasurements;",
        "step": "【step1】: Filter device IDs from Devices table where deviceType is '光谱仪' using subquery: SELECT deviceId FROM Devices WHERE deviceType = '光谱仪'  【step2】: Retrieve top 5 measurement values from ExperimentData using filtered device IDs, sorted DESC: SELECT measurementValue FROM ExperimentData WHERE deviceId IN (...) ORDER BY measurementValue DESC LIMIT 5  【step3】: Calculate average and standard deviation via CTE: AVG(measurementValue) and SQRT(AVG(measurementValue²) - AVG²(measurementValue)) from TopMeasurements",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1062,
        "question": "Query the measurement values in the experimental data table for voltage measurements in volts (V) obtained from an oscilloscope, and calculate the average and standard deviation of the logarithmically transformed values.",
        "query": "WITH LogTransformedData AS (SELECT LOG10(measurementValue) AS logValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '示波器') AND unit = 'V') SELECT AVG(logValue) AS logAverage, SQRT(AVG(logValue * logValue) - AVG(logValue) * AVG(logValue)) AS logStandardDeviation FROM LogTransformedData;",
        "step": "【step1】: Filter device IDs for oscilloscope devices using a subquery: SELECT deviceId FROM Devices WHERE deviceType = '示波器'  【step2】: Create CTE LogTransformedData by selecting LOG10(measurementValue) from ExperimentData with matching device IDs (from step1) and unit='V'  【step3】: Calculate average and standard deviation of log-transformed values using AVG(logValue) and custom standard deviation formula on the CTE",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1063,
        "question": "Calculate the average and standard deviation of temperature measurements in degrees Celsius (℃) obtained using thermometers from the experimental data.",
        "query": "SELECT AVG(measurementValue) AS mean, SQRT(AVG(POW(measurementValue - (SELECT AVG(measurementValue) FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '温度计')), 2))) AS stddev FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '温度计');",
        "step": "【step1】: Filter temperature data measured by thermometers  Subquery retrieves deviceIds of thermometers from Devices table. Then filter ExperimentData where unit='℃' and deviceId matches those thermometers.  【step2】: Calculate average temperature  Compute AVG(measurementValue) from the filtered dataset. This average is used both as the direct output (mean) and as a nested subquery for standard deviation calculation.  【step3】: Compute standard deviation  For each measurement, calculate squared deviation from the mean (obtained via nested subquery). Take the square root of the average squared deviation to derive stddev.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1064,
        "question": "Query the experimental data in the table where the measured value exceeds 1,000,000 lumens (lm), and calculate the average value and standard deviation of this data, assuming the data consists of light intensity measurements taken by a spectrometer.",
        "query": "SELECT AVG(measurementValue) AS average_value, STDDEV(measurementValue) AS standard_deviation FROM ExperimentData WHERE measurementValue > 1000000 AND unit = 'lm' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪');",
        "step": "【step1】: Retrieve device IDs of '光谱仪' type devices from Devices table  【step2】: Filter ExperimentData records where measurementValue exceeds 1,000,000 lm and deviceId matches Step1 results  【step3】: Calculate average and standard deviation of qualifying measurement values from Step2",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1065,
        "question": "Please calculate the frequency corresponding to the wavelength of light measured with a spectrometer in an experiment, assuming the measured value is 500 nanometers.",
        "query": "SELECT (3 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') AND measurementValue = 500 AND unit = '纳米';",
        "step": "【step1】: Execute subquery to retrieve deviceIds of '光谱仪' type devices from Devices table.  【step2】: Filter ExperimentData records where deviceId matches subquery results, measurementValue=500, and unit='纳米'.  【step3】: Calculate frequency using formula (speed_of_light / wavelength) with unit conversions (3*10⁸ m/s divided by 500*10⁻⁹ m).",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1066,
        "question": "Please calculate in a certain experiment, the initial value of variable A is 10, the initial value of variable B is 20. After a series of iterative calculations where in each iteration: the value of variable A becomes the square root of the value of variable B from the previous iteration, and the value of variable B becomes twice that of the value of variable A from the previous iteration. Find the final values of variables A and B after all iterations.",
        "query": "WITH RECURSIVE VariableCalculation AS (SELECT variableId, variableName, initialValue AS currentValue, unit, dataQuality FROM Variables WHERE experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = '某个实验') UNION ALL SELECT v.variableId, v.variableName, CASE WHEN v.variableName = 'A' THEN SQRT(vc.currentValue) WHEN v.variableName = 'B' THEN 2 * vc.currentValue END AS currentValue, v.unit, v.dataQuality FROM Variables v JOIN VariableCalculation vc ON v.experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = '某个实验') WHERE (v.variableName = 'A' AND vc.variableName = 'B') OR (v.variableName = 'B' AND vc.variableName = 'A')) SELECT * FROM VariableCalculation;",
        "step": "【step1】: Retrieve initial values of variables A (10) and B (20) for the specified experiment from the Variables table.  【step2】: Use recursive CTE to iteratively calculate new values: A becomes the square root of B's current value, while B becomes twice A's current value, alternating updates between the variables.  【step3】: Terminate recursion after one iteration (due to implicit dependency resolution) and return the final values: A ≈ 4.4721 (√20) and B = 20 (2×10).",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1067,
        "question": "In the laboratory, the calibration date of equipment is very important. Please query all equipment with calibration dates exceeding one year and sort them in ascending order by equipment name.",
        "query": "SELECT deviceId, deviceName, deviceType, calibrationDate, status, labId FROM Devices WHERE calibrationDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) ORDER BY deviceName ASC;",
        "step": "【step1】: Calculate the date one year prior to the current date using `DATE_SUB(CURDATE(), INTERVAL 1 YEAR)`.  【step2】: Filter records from the **Devices** table where `calibrationDate` is earlier than the calculated date.  【step3】: Sort the remaining records by `deviceName` in ascending order using `ORDER BY deviceName ASC`.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1068,
        "question": "Assuming a certain experiment's calculation result exceeds the system's maximum processable value, for example, the result is 1 x 10^308, please query all records where the calculation result exceeds 1 x 10^300 and sort them in descending order by the calculation result.",
        "query": "SELECT * FROM Calculations WHERE result > 1e300 ORDER BY result DESC;",
        "step": "【step1】: Access the \"Calculations\" table to retrieve all columns.  【step2】: Filter records where the \"result\" column exceeds 1e300.  【step3】: Sort the filtered records in descending order by \"result\".",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1069,
        "question": "Query the light intensity data measured by the spectrometer in a specific experiment, calculate its corresponding energy value, sort in ascending order by energy value, and return the top 10 results.",
        "query": "WITH SpectralData AS (SELECT ed.dataId, ed.experimentId, ed.deviceId, ed.timestamp, ed.measurementValue AS lightIntensity, ed.unit, ed.dataQuality, ed.environmentalConditions FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '光谱仪' AND ed.experimentId = '特定实验ID'), EnergyCalculations AS (SELECT sd.dataId, sd.experimentId, sd.deviceId, sd.timestamp, sd.lightIntensity, sd.unit, sd.dataQuality, sd.environmentalConditions, (6.62607015e-34 * 299792458 / sd.lightIntensity) AS energy FROM SpectralData sd) SELECT ec.dataId, ec.experimentId, ec.deviceId, ec.timestamp, ec.lightIntensity, ec.energy, ec.unit, ec.dataQuality, ec.environmentalConditions FROM EnergyCalculations ec ORDER BY ec.energy ASC LIMIT 10;",
        "step": "【step1】: Filter ExperimentData for spectral measurements in specified experiment by joining with Devices where deviceType is '光谱仪'  【step2】: Calculate energy values using physics formula (6.62607015e-34 * 299792458 / lightIntensity) in derived CTE  【step3】: Sort results by energy ascending and return top 10 records with LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1070,
        "question": "Calculate the average sensitivity value for each experiment where the impact is 'High', grouped by experiment ID and experiment name.",
        "query": "SELECT e.experimentId, e.experimentName, AVG(sa.sensitivityValue) AS avgSensitivityValue FROM Experiments e JOIN SensitivityAnalysis sa ON e.experimentId = sa.experimentId WHERE sa.impact = '高' GROUP BY e.experimentId, e.experimentName;",
        "step": "【step1】: Join Experiments and SensitivityAnalysis tables on experimentId to link experiment details with their sensitivity analysis results.  【step2】: Apply WHERE clause to filter sensitivity analysis records where impact is '高' (high).  【step3】: Group by experimentId and experimentName, then compute the average sensitivityValue for each group.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1071,
        "question": "Query the usage of all devices that have completed experiments, grouped by device type, and return the usage count for each device type, sorted in descending order by usage count.",
        "query": "SELECT d.deviceType, COUNT(ed.deviceId) AS usageCount FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId JOIN Experiments e ON ed.experimentId = e.experimentId WHERE e.status = '已完成' GROUP BY d.deviceType ORDER BY usageCount DESC;",
        "step": "【step1】: Join ExperimentData with Experiments to filter records where status is 'Completed'  【step2】: Join the result with Devices and group by deviceType to calculate usageCount  【step3】: Sort the grouped results by usageCount in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1072,
        "question": "Assuming the lab capacity is increased to 10,000 people, query the ratio of capacity to current number of devices for all labs, sort them in descending order by the ratio, and return the top 5 labs with the highest ratios.",
        "query": "SELECT labId, labName, (10000 / equipmentCount) AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;",
        "step": "【step1】: Calculate the ratio of new capacity (10000) divided by equipmentCount for each lab, aliased as 'ratio'  【step2】: Order the results by the calculated ratio in descending order  【step3】: Limit the output to show only the top 5 highest ratio records",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1073,
        "question": "Calculate the average of the 5 highest wavelength measurements (in nanometers) recorded by spectrometers in the experimental data.",
        "query": "SELECT AVG(measurementValue) AS average_wavelength FROM (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') AND unit = '纳米' ORDER BY measurementValue DESC LIMIT 5) AS top_measurements;",
        "step": "【step1】: Retrieve device IDs of '光谱仪' from Devices table.  【step2】: Select top 5 measurementValue from ExperimentData filtered by unit='纳米' and valid device IDs, ordered descendingly.  【step3】: Calculate the average of the extracted top 5 measurements using AVG() function.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1074,
        "question": "Query all records in the calculation table where the computed result is greater than 1000, sort them in descending order by the computed result, and take the top 10.",
        "query": "SELECT * FROM Calculations WHERE result > 1000 ORDER BY result DESC LIMIT 10;",
        "step": "【step1】: Filter records from Calculations where result exceeds 1000 using WHERE clause.  【step2】: Sort the filtered records in descending order of result using ORDER BY DESC.  【step3】: Restrict the final output to the top 10 records using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1075,
        "question": "Query the laboratory table for laboratories with a capacity greater than 50 people and sort them in ascending order by capacity.",
        "query": "SELECT labId, labName, location, capacity, equipmentCount, status FROM Labs WHERE capacity > 50 ORDER BY capacity ASC;",
        "step": "【step1】: Retrieve all records from the Labs table to access laboratory information.  【step2】: Apply the WHERE clause to filter laboratories with a capacity greater than 50.  【step3】: Select specified columns and sort the filtered results by capacity in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1076,
        "question": "Query all variables in the variable table where the initial value is greater than 10,000, sorted in descending order by initial value, and retrieve the top five.",
        "query": "SELECT variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 10000 ORDER BY initialValue DESC LIMIT 5;",
        "step": "【step1】: Filter records from the Variables table where initialValue exceeds 10,000 using the WHERE clause.  【step2】: Sort the filtered results in descending order of initialValue using ORDER BY initialValue DESC.  【step3】: Restrict the final output to the top 5 records using LIMIT 5.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1077,
        "question": "In the lab, suppose we have an experiment that measures the values of different devices under various environmental conditions. Calculate the average measurement value for each device, and sort them in ascending order.",
        "query": "SELECT deviceId, AVG(measurementValue) AS averageMeasurementValue FROM ExperimentData GROUP BY deviceId ORDER BY averageMeasurementValue ASC;",
        "step": "【step1】: Retrieve device IDs and their corresponding measurement values from the ExperimentData table.  【step2】: Group the data by deviceId and calculate the average measurement value for each group using the AVG() function.  【step3】: Sort the results in ascending order based on the computed average measurement value.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1078,
        "question": "Please query the top 5 experimental data entries with the highest measured values in the experimental data table, and calculate the average and standard deviation of these values.",
        "query": "WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData ORDER BY measurementValue DESC LIMIT 5) SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM TopMeasurements;",
        "step": "【step1】: Create a CTE named TopMeasurements that selects the top 5 highest measurementValue entries from ExperimentData, sorted in descending order.  【step2】: Calculate the average of the selected top 5 measurement values using AVG(measurementValue).  【step3】: Compute the standard deviation using the formula SQRT(AVG(measurementValue²) - AVG(measurementValue)²) on the CTE results.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1079,
        "question": "In the lab, suppose we need to find all equipment with calibration dates exceeding one year, grouped by equipment type. Please return the equipment type, names, and calibration dates of these devices.",
        "query": "SELECT deviceType, GROUP_CONCAT(deviceName SEPARATOR ', ') AS deviceNames, GROUP_CONCAT(calibrationDate SEPARATOR ', ') AS calibrationDates FROM Devices WHERE DATEDIFF(CURDATE(), calibrationDate) > 365 GROUP BY deviceType;",
        "step": "【step1】: Filter devices where the calibration date exceeds one year using DATEDIFF(CURDATE(), calibrationDate) > 365  【step2】: Group the filtered devices by their deviceType  【step3】: Aggregate deviceNames and calibrationDates using GROUP_CONCAT for each group",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1080,
        "question": "In the hypothesis table, return all hypotheses with false validation results where the measurement value exceeds 100 times the normal value for the experiment, grouped by experiment ID, hypothesis ID, hypothesis text, and verification result.",
        "query": "SELECT h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult FROM Hypotheses h JOIN ExperimentData ed ON h.experimentId = ed.experimentId WHERE h.verificationResult = '假' AND ed.measurementValue > (SELECT initialValue FROM Variables WHERE experimentId = h.experimentId AND variableName = '正常值') * 100 GROUP BY h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult;",
        "step": "【step1】: Join the Hypotheses table with the ExperimentData table using experimentId to associate hypothesis records with their corresponding experimental measurements.  【step2】: Apply two filters:  - Select hypotheses where verificationResult is '假'  - Check if measurementValue exceeds 100 times the initialValue of the '正常值' variable (retrieved via subquery from the Variables table)  【step3】: Group the filtered results by experimentId, hypothesisId, hypothesisText, and verificationResult to organize output per experimental group.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1081,
        "question": "Query all experimental data where the device type used is a spectrometer, calculate the average of the measurement values for each experiment, and sort the results in ascending order by experiment ID.",
        "query": "SELECT e.experimentId, AVG(ed.measurementValue) AS average_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '光谱仪' GROUP BY e.experimentId ORDER BY e.experimentId ASC;",
        "step": "【step1】: Join Experiments, ExperimentData, and Devices tables using experimentId and deviceId to link relevant data.  【step2】: Filter results where deviceType is '光谱仪' using the WHERE clause.  【step3】: Group data by experimentId, calculate average measurement value with AVG(), and sort results by experimentId in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1082,
        "question": "Query all experimental data where the equipment type used in the experiments is an oscilloscope, calculate the standard deviation of measured values for each experiment, and sort the results in ascending order by experiment ID.",
        "query": "WITH OscilloscopeExperiments AS (SELECT ed.experimentId, ed.measurementValue FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '示波器'), ExperimentStats AS (SELECT experimentId, AVG(measurementValue) AS avg_value, COUNT(measurementValue) AS count_value FROM OscilloscopeExperiments GROUP BY experimentId) SELECT oe.experimentId, SQRT(SUM(POWER(oe.measurementValue - es.avg_value, 2)) / es.count_value) AS std_deviation FROM OscilloscopeExperiments oe JOIN ExperimentStats es ON oe.experimentId = es.experimentId GROUP BY oe.experimentId ORDER BY oe.experimentId ASC;",
        "step": "【step1】: Filter ExperimentData to include only 'Oscilloscope' devices by joining with Devices table (WHERE d.deviceType = '示波器'), creating temporary dataset OscilloscopeExperiments.  【step2】: Calculate average measurement and total count per experiment from OscilloscopeExperiments, creating intermediate statistics dataset ExperimentStats.  【step3】: Compute standard deviation by joining OscilloscopeExperiments with ExperimentStats, applying formula √[Σ(value-avg)²/count], then sort results by experimentId.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1083,
        "question": "Retrieve the sum of measurement values for each experiment where the device type is neither \"spectrometer\" nor \"oscilloscope\", and sort the results in ascending order by experiment ID.",
        "query": "SELECT e.experimentId, SUM(ed.measurementValue) AS total_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType NOT IN ('光谱仪', '示波器') GROUP BY e.experimentId ORDER BY e.experimentId ASC;",
        "step": "【step1】: Join Experiments, ExperimentData, and Devices tables to filter experiments using devices other than '光谱仪' and '示波器'  【step2】: Group results by experimentId and calculate total measurement values using SUM()  【step3】: Sort the aggregated results by experimentId in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1084,
        "question": "Assuming the laboratory has more than 1,000 equipment devices, query all experimental data where the number of equipment devices exceeds 1,000 in any laboratory, calculate the maximum measured value for each experiment, and sort the results by experiment ID in ascending order.",
        "query": "SELECT e.experimentId, MAX(ed.measurementValue) AS max_measurement_value FROM Experiments e JOIN Labs l ON e.labId = l.labId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE l.equipmentCount > 1000 GROUP BY e.experimentId ORDER BY e.experimentId ASC;",
        "step": "【step1】: Join Experiments and Labs tables to filter experiments from labs with equipmentCount > 1000.  【step2】: Join the filtered results with ExperimentData to collect measurement values for each experiment.  【step3】: Group by experimentId, calculate the maximum measurementValue, and sort by experimentId ascending.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1085,
        "question": "Calculate whether each laboratory has sufficient capacity to accommodate all researchers currently conducting experiments, assuming each researcher requires 2 square meters of space.",
        "query": "SELECT L.labId, L.labName, L.location, L.capacity, COUNT(R.researcherId) AS currentResearchers, (L.capacity >= COUNT(R.researcherId)) AS isCapacitySufficient FROM Labs L JOIN Experiments E ON L.labId = E.labId JOIN Researchers R ON E.researcherId = R.researcherId WHERE E.status = '进行中' GROUP BY L.labId, L.labName, L.location, L.capacity;",
        "step": "【step1】: Join Labs, Experiments, and Researchers tables to filter ongoing experiments with their corresponding researchers.  【step2】: Group results by lab details and calculate the number of active researchers per lab.  【step3】: Evaluate lab capacity sufficiency by comparing capacity to researcher count.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1086,
        "question": "Calculate the equipment density of each lab, which is the ratio of the number of devices to the lab's capacity, and identify the lab with the highest equipment density.",
        "query": "SELECT labId, labName, equipmentCount / capacity AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC LIMIT 1;",
        "step": "【step1】: Select labId, labName, and calculate equipmentDensity by dividing equipmentCount by capacity from the Labs table.  【step2】: Order the results by equipmentDensity in descending order.  【step3】: Retrieve the top result using LIMIT 1 to identify the lab with the highest equipment density.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1087,
        "question": "Find the average time that unverified hypotheses have remained unverified, calculated as the difference between the current date and their experiment start date.",
        "query": "SELECT AVG(DATEDIFF(CURDATE(), e.startDate)) AS averageVerificationTime FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId WHERE h.status = '未验证';",
        "step": "【step1】: Filter hypotheses with '未验证' status using WHERE clause  【step2】: Join with Experiments table via experimentId to access startDate  【step3】: Calculate average time difference between CURDATE() and experiment start dates using AVG(DATEDIFF(...))",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1088,
        "question": "Assuming the laboratory's capacity can be expanded infinitely, calculate the maximum number of researchers the laboratory can accommodate under extreme conditions, given that each researcher requires 0.1 square meters of space.",
        "query": "SELECT labId, labName, (capacity / 0.1) AS maxResearchers FROM Labs;",
        "step": "【step1】: Retrieve labId and labName from the Labs table.  【step2】: Calculate the maximum number of researchers by dividing the capacity of each lab by 0.1 (since each researcher requires 0.1 m²).  【step3】: Output labId, labName, and the computed maxResearchers value.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1089,
        "question": "Calculate the total power consumption of all equipment in the laboratory, assuming each device's power consumption is the square of the number of devices in each lab multiplied by 10 watts.",
        "query": "SELECT SUM(POWER(equipmentCount, 2) * 10) AS total_power_consumption FROM Labs;",
        "step": "【step1】: Retrieve equipmentCount values from the Labs table for all laboratories.  【step2】: Apply the formula (equipmentCount² ×10) to each lab's equipment count and sum all results using the SUM() aggregation function.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1090,
        "question": "Calculate the average duration of all completed experiments in the laboratory and identify the maximum duration among completed experiments.",
        "query": "WITH ExperimentDurations AS (SELECT experimentId, experimentName, (endDate - startDate) AS duration FROM Experiments WHERE status = '已完成') SELECT AVG(duration) AS average_duration, MAX(duration) AS max_duration FROM ExperimentDurations;",
        "step": "【step1】: Filter 'Experiments' table to select completed experiments, calculating duration by subtracting startDate from endDate.  【step2】: Create a CTE (ExperimentDurations) to store experiment IDs, names, and calculated durations.  【step3】: Compute the average duration (AVG) and maximum duration (MAX) from the CTE results.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1091,
        "question": "Find the percentage of devices in the lab with a status of 'fault' out of the total number of devices.",
        "query": "SELECT \n    (COUNT(CASE WHEN status = '故障' THEN 1 END) * 100.0 / COUNT(*)) AS fault_percentage\nFROM Devices;",
        "step": "【step1】: Calculate total number of devices using COUNT(*)  【step2】: Count devices with '故障' status via COUNT(CASE WHEN status = '故障' THEN 1 END)  【step3】: Compute percentage by dividing fault count by total count and multiplying by 100.0",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1092,
        "question": "Assuming the lab's capacity suddenly increases to 10,000 people, calculate the density (people/square meter) of the lab, given that the lab's area is 1,000 square meters.",
        "query": "SELECT 10000 / 1000 AS lab_density;",
        "step": "【step1】: Retrieve the new lab capacity (10000) and fixed area (1000) values.  【step2】: Calculate density by dividing capacity (10000) by area (1000).  【step3】: Alias the result column as lab_density using AS clause.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1093,
        "question": "In the experiment table Experiments, assuming there is an experiment for measuring gravitational acceleration, the experiment data table ExperimentData records measurement values at different time points. Please calculate the average gravitational acceleration during the experiment and return the experiment name, experiment start time, experiment end time, and the average gravitational acceleration.",
        "query": "SELECT e.experimentName AS 实验名称, e.startDate AS 实验开始时间, e.endDate AS 实验结束时间, AVG(ed.measurementValue) AS 平均重力加速度 FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = '测量重力加速度' GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;",
        "step": "【step1】: Join Experiments and ExperimentData tables using experimentId to combine experiment metadata with measurement values  【step2】: Filter records where experimentName equals '测量重力加速度' to isolate gravity acceleration experiments  【step3】: Aggregate results by experiment group (experimentId, name, dates) and calculate average measurementValue using AVG()",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1094,
        "question": "In the Experiments table, suppose there is an experiment about measuring resistance, and the ExperimentData table records measurement values of different voltages and currents. Please calculate the average resistance for each experiment and return the experiment name, experiment start date, experiment end date, and average resistance.",
        "query": "SELECT e.experimentName, e.startDate, e.endDate, AVG(ed1.measurementValue / ed2.measurementValue) AS averageResistance FROM Experiments e JOIN ExperimentData ed1 ON e.experimentId = ed1.experimentId AND ed1.unit = 'V' JOIN ExperimentData ed2 ON e.experimentId = ed2.experimentId AND ed2.unit = 'A' AND ed1.timestamp = ed2.timestamp GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;",
        "step": "【step1】: Perform dual joins on ExperimentData table to separate voltage (V) and current (A) measurements using timestamp synchronization  【step2】: Calculate resistance for each matched measurement pair using voltage/current division  【step3】: Aggregate results by experiment ID and calculate average resistance using GROUP BY with experiment metadata",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1095,
        "question": "In the experiment table Experiments, assuming there is an experiment about temperature measurement, the experimental data table ExperimentData records temperature measurements at different time points. Please calculate the highest and lowest temperatures (in either Celsius or Fahrenheit) during the experiment and return the experiment name, experiment start time, experiment end time, as well as the highest and lowest temperatures.",
        "query": "SELECT e.experimentName, e.startDate, e.endDate, MAX(ed.measurementValue) AS maxTemperature, MIN(ed.measurementValue) AS minTemperature FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = 'Celsius' OR ed.unit = 'Fahrenheit' GROUP BY e.experimentId;",
        "step": "【step1】: Perform an INNER JOIN between Experiments and ExperimentData tables using experimentId to link the experimental metadata with corresponding temperature measurements.  【step2】: Filter records where measurement units are explicitly 'Celsius' or 'Fahrenheit' using the WHERE clause to ensure only valid temperature data is analyzed.  【step3】: Aggregate results by experimentId using GROUP BY, then calculate the maximum (MAX) and minimum (MIN) measurement values for each experiment group to derive temperature extremes.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1096,
        "question": "In the Experiments table, assume there is an experiment about measuring the speed of light. The ExperimentData table records the speed of light measurements at different time points. Please calculate the average speed of light during the experiment for measurements exceeding 1,000,000,000 m/s and return the experiment name, experiment start time, experiment end time, and the average speed of light.",
        "query": "SELECT e.experimentName, e.startDate, e.endDate, AVG(ed.measurementValue) AS averageSpeed FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = '测量光速实验' AND ed.measurementValue > 1000000000 GROUP BY e.experimentName, e.startDate, e.endDate;",
        "step": "【step1】: Join Experiments and ExperimentData tables using experimentId, filter by experimentName='测量光速实验' and measurementValue > 1e9  【step2】: Group the results by experimentName, startDate, endDate  【step3】: Calculate average measurementValue for each group using AVG()",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1097,
        "question": "Calculate the total energy consumption of all spectrometers in the laboratory, assuming each spectrometer has a power of 500 watts and operates 8 hours per day.",
        "query": "SELECT SUM(500 * 8) AS total_energy_consumption_kWh FROM Devices WHERE deviceType = '光谱仪';",
        "step": "【step1】: Filter all devices with deviceType = '光谱仪' using WHERE clause  【step2】: Multiply fixed power (500W) by daily operation hours (8) for each qualifying device  【step3】: Aggregate results using SUM() to get total energy consumption in kWh",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1098,
        "question": "Calculate the average calibration interval in days for all devices, assuming the current date is 2023-10-01.",
        "query": "SELECT AVG(DATEDIFF('2023-10-01', calibrationDate)) AS average_calibration_interval FROM Devices;",
        "step": "【step1】: Calculate the calibration interval in days for each device by computing the difference between '2023-10-01' and the calibrationDate using DATEDIFF.  【step2】: Apply the AVG function to all calculated intervals to determine the overall average_calibration_interval.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1099,
        "question": "Find all devices with a status of 'faulty' and list their names and the date of their last calibration.",
        "query": "SELECT deviceName, calibrationDate FROM Devices WHERE status = '故障';",
        "step": "【step1】: Filter the Devices table to select records where the 'status' column equals '故障'.  【step2】: Retrieve the 'deviceName' and 'calibrationDate' columns from the filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1100,
        "question": "Assuming that the maximum power consumption of each device in the laboratory is 1000 times its base power (which is 500 watts for oscilloscopes, 700 watts for spectrometers, and 300 watts for other devices), calculate whether the total energy consumption of the laboratory over 24 hours would exceed the grid's load capacity, given that the grid's maximum load capacity is 1000 kilowatts.",
        "query": "WITH DevicePower AS (SELECT deviceId, deviceName, CASE WHEN deviceType = '示波器' THEN 500 WHEN deviceType = '光谱仪' THEN 700 ELSE 300 END AS basePower FROM Devices WHERE labId = (SELECT labId FROM Labs WHERE labName = '目标实验室名称')), MaxPower AS (SELECT deviceId, deviceName, basePower * 1000 AS maxPower FROM DevicePower), TotalEnergy AS (SELECT SUM(maxPower * 24) AS totalEnergy FROM MaxPower) SELECT CASE WHEN totalEnergy > 1000 THEN '超过电网承载能力' ELSE '未超过电网承载能力' END AS result FROM TotalEnergy;",
        "step": "【step1】: Retrieve all devices in the target lab and calculate base power via device types. Subquery first gets labId from Labs table using labName, then assigns basePower (500 for oscilloscopes, 700 for spectrometers, 300 for others) through CASE statement in DevicePower CTE.  【step2】: Calculate each device's maximum power by multiplying basePower×1000 (1000x overdesign factor) in MaxPower CTE.  【step3】: Sum all devices' daily energy consumption (maxPower×24 hours) in TotalEnergy CTE, then compare with 1000 kW grid capacity using CASE to determine overload status.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1101,
        "question": "In the experimental data table, find all data collected using the spectrometer equipment with the unit of Lux, and calculate the average measurement value (light intensity) of these data.",
        "query": "SELECT AVG(measurementValue) AS averageLightIntensity FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') AND unit = 'Lux';",
        "step": "【step1】: Retrieve device IDs of all spectrometers from the Devices table using the subquery: SELECT deviceId FROM Devices WHERE deviceType = '光谱仪'  【step2】: Filter ExperimentData records where deviceId matches the spectrometer IDs from step 1 and unit is 'Lux'  【step3】: Calculate the average measurementValue from the filtered records and alias it as averageLightIntensity using AVG(measurementValue) AS averageLightIntensity",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1102,
        "question": "In the experimental data table, find all data collected under the environmental condition of 'high temperature' and calculate the standard deviation of these data measurements, assuming the measured value is temperature, in degrees Celsius (°C).",
        "query": "WITH HighTempData AS (SELECT measurementValue FROM ExperimentData WHERE environmentalConditions = '高温' AND unit = '°C'), AverageValue AS (SELECT AVG(measurementValue) AS avgValue FROM HighTempData) SELECT SQRT(SUM(POWER(measurementValue - avgValue, 2)) / COUNT(*)) AS standardDeviation FROM HighTempData, AverageValue;",
        "step": "【step1】: Filter data from ExperimentData where environmentalConditions is '高温' and unit is '°C', storing results in temporary CTE \"HighTempData\".  【step2】: Calculate the average of measurementValue from HighTempData and store it in CTE \"AverageValue\".  【step3】: Compute standard deviation by joining HighTempData and AverageValue, applying the formula √[Σ(value - avg)^2 / count]. This handles deviation calculation and square root operation.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1103,
        "question": "In the experimental data table, find all experimental data with data quality marked as 'high' and unit of 'A', and calculate the total sum of their measured values.",
        "query": "SELECT SUM(measurementValue) AS totalCurrent FROM ExperimentData WHERE dataQuality = '高' AND unit = 'A';",
        "step": "【step1】: Filter the ExperimentData table to select only records where dataQuality is '高'.  【step2】: Apply an additional filter to the result from Step 1 to include only records where the unit is 'A' (amperes).  【step3】: Calculate the sum of the measurementValue column from the filtered records and alias the result as totalCurrent.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1104,
        "question": "In the experimental data table, calculate the total sum of the voltage measurements in volts (V), where each measurement value is first multiplied by 1000 (for unit conversion) and then multiplied by 1000 again (for scaling), but ignoring any changes to data collection times.",
        "query": "SELECT SUM(measurementValue * 1000) * 1000 AS totalVoltage FROM ExperimentData WHERE unit = 'V';",
        "step": "【step1】: Filter records in ExperimentData where the unit is 'V' to focus on voltage measurements.  【step2】: Multiply each measurementValue by 1000 to reflect the \"unit conversion to thousandfold\" adjustment.  【step3】: Sum all adjusted measurement values and multiply the total by 1000 to account for the \"data collection time extended 1000x\" assumption.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1105,
        "question": "Calculate the wavelength of light measured by the spectrometer in the 'Spectrometer Measurement Experiment' and identify the experiment ID and name.",
        "query": "SELECT experimentId, experimentName, (3.00 * POWER(10, 8)) / (5.00 * POWER(10, 14)) AS wavelength, 'm' AS unit FROM Experiments WHERE experimentName = '光谱仪测量实验';",
        "step": "【step1】: Filter experiments with experimentName '光谱仪测量实验' from Experiments table using WHERE clause  【step2】: Calculate wavelength via formula (3.00×10⁸)/(5.00×10¹⁴) and append unit 'm' as derived column  【step3】: (Not required - basic calculation & filtering handled in 2 steps)",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1106,
        "question": "In a certain experiment, researchers need to calculate the equivalent resistance of a complex circuit. It is known that the circuit contains five resistors: R1=10Ω, R2=20Ω, R3=30Ω, R4=40Ω, R5=50Ω, all connected in parallel. Determine the equivalent resistance.",
        "query": "INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES ((SELECT experimentId FROM Experiments WHERE experimentName = '复杂电路实验'), '1/Req = 1/R1 + 1/R2 + 1/R3 + 1/R4 + 1/R5', 'R1=10Ω, R2=20Ω, R3=30Ω, R4=40Ω, R5=50Ω', 1 / (1/10 + 1/20 + 1/30 + 1/40 + 1/50), 'Ω', '高');",
        "step": "【step1】: Execute subquery to retrieve experimentId from Experiments table where experimentName='复杂电路实验'  【step2】: Calculate equivalent resistance using 1/(1/10 + 1/20 + 1/30 + 1/40 + 1/50) formula  【step3】: Insert calculated result into Calculations table with joined experimentId, formula metadata, input parameters, and quality annotation",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1107,
        "question": "In a certain experiment, the researchers needed to calculate the energy cost of the laboratory. It is known that the laboratory has 10 devices, each with a power of 500W, operating 8 hours per day, and the electricity cost is 0.5 yuan per kilowatt-hour. Determine the laboratory's electricity cost for one month.",
        "query": "WITH DevicePower AS (SELECT 10 * 500 AS total_power), DailyEnergy AS (SELECT total_power * 8 / 1000 AS daily_energy FROM DevicePower), MonthlyCost AS (SELECT daily_energy * 30 * 0.5 AS monthly_cost FROM DailyEnergy) SELECT monthly_cost FROM MonthlyCost;",
        "step": "【step1】: Calculate total power of all devices: 10 devices * 500W = 5000W  【step2】: Convert daily energy consumption: (5000W * 8h) / 1000 = 40 kWh  【step3】: Compute monthly cost: 40 kWh * 30 days * 0.5 RMB/kWh = 600 RMB",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1108,
        "question": "Suppose in a certain experiment, researchers need to calculate the annual electricity cost of a very large laboratory. The laboratory has devices with a total power of 10000W operating 24 hours a day. The electricity cost is 0.1 yuan per kilowatt-hour. Calculate the annual electricity cost of the laboratory.",
        "query": "WITH DevicePower AS (SELECT SUM(10000) AS total_power FROM Devices WHERE labId = (SELECT labId FROM Labs WHERE labName = '超大型实验室')), DailyEnergy AS (SELECT total_power * 24 AS daily_energy FROM DevicePower), AnnualCost AS (SELECT daily_energy * 365 * 0.1 AS annual_cost FROM DailyEnergy) SELECT annual_cost FROM AnnualCost;",
        "step": "【step1】: Retrieve the labId of '超大型实验室' from the Labs table via a subquery and calculate the total power of all 1000 devices (10000W each) under this lab.  【step2】: Multiply the total power by 24 hours to derive daily energy consumption (in watt-hours).  【step3】: Convert to annual cost by multiplying daily energy by 365 days and the electricity rate (0.1元/kWh), implicitly handling unit conversion from watt-hours to kilowatt-hours.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1109,
        "question": "In the experimental data table, assume we have an experimental data record with the measured value being voltage, in volts (V), under standard temperature conditions (25°C). Please calculate the power when the current is 2 amperes (A) in this environment, and insert the result into the Calculations table with the formula 'P = V * I', the input data showing the voltage and current values, the result in Watts, and the data quality as 'High'.",
        "query": "INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) SELECT experimentId, 'P = V * I', CONCAT('V=', measurementValue, ', I=2'), measurementValue * 2, 'Watt', '高' FROM ExperimentData WHERE unit = 'V' AND environmentalConditions = '25°C';",
        "step": "【step1】: Extract relevant experiment data entries from ExperimentData where voltage measurements (unit 'V') were recorded under standard temperature conditions (25°C).  【step2】: Calculate power using the formula P=V*I (with fixed current I=2A) for each qualifying entry, and prepare metadata including formula notation, concatenated input parameters, result value, unit, and data quality.  【step3】: Insert calculated power values with associated contextual information into the Calculations table through a combined SELECT-INSERT operation, preserving linkage to original experiments via experimentId.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1110,
        "question": "In the calculation table, assuming we have a formula F = m * a, where F is force, m is mass, and a is acceleration. Given that the mass is 5 kilograms (kg) and the acceleration is 9.8 meters per second squared (m/s²), and the result is 49 Newtons (N), please verify the calculation of force F.",
        "query": "INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES (1, 'F = m * a', 'm=5kg, a=9.8m/s²', 49, 'N', '高');",
        "step": "【step1】: Verify the experimentId=1 exists in the Experiments table to satisfy the foreign key constraint.  【step2】: Calculate F = 5 kg * 9.8 m/s² = 49 N and validate unit/dataQuality consistency.  【step3】: Execute the INSERT statement to add the calculation record with formula, input parameters, result, unit, and dataQuality.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1111,
        "question": "In the lab table, assuming a lab has a capacity of 50 people and 100 pieces of equipment, please calculate the average number of equipment available per researcher for labs with capacity 50 and equipmentCount 100.",
        "query": "SELECT equipmentCount / capacity AS avg_equipment_per_researcher FROM Labs WHERE capacity = 50 AND equipmentCount = 100;",
        "step": "【step1】: Filter the Labs table to select records where capacity is 50 and equipmentCount is 100 using the WHERE clause.  【step2】: Calculate the average equipment per researcher by dividing equipmentCount by capacity and alias the result as avg_equipment_per_researcher.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1112,
        "question": "In the hypothetical table, which hypotheses with a verification result of 'true' and a verification date of October 1, 2023 are still valid when their verification date is advanced by 10,000 years?",
        "query": "SELECT hypothesisId, hypothesisText, verificationResult, verificationDate, CASE WHEN DATE_ADD(verificationDate, INTERVAL 10000 YEAR) > NOW() THEN '有效' ELSE '无效' END AS validity FROM Hypotheses WHERE verificationResult = '真' AND verificationDate = '2023-10-01';",
        "step": "【step1】: Filter records from the Hypotheses table where verificationResult is '真' (true) and verificationDate is '2023-10-01'.  【step2】: Calculate the future validity date by adding 10,000 years to verificationDate using DATE_ADD(verificationDate, INTERVAL 10000 YEAR).  【step3】: Compare the calculated future date with the current date (NOW()) via a CASE statement to determine validity ('有效' if future date > NOW(), else '无效').",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1113,
        "question": "In the experimental data table, the unit of measurement is volts (V). Please calculate the average of all measurements for each experiment that has at least one measurement exceeding 10,000 volts.",
        "query": "SELECT AVG(measurementValue) AS averageVoltage, experimentId FROM ExperimentData WHERE unit = 'V' GROUP BY experimentId HAVING MAX(measurementValue) > 10000;",
        "step": "【step1】: Filter ExperimentData records where unit is 'V' to focus on voltage measurements  【step2】: Group filtered data by experimentID, calculate average voltage and check maximum value per group  【step3】: Apply HAVING clause to select groups where maximum measurement exceeds 10kV (10000V) threshold",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1114,
        "question": "In the variables table, given the initial values and units for each variable, please calculate the total sum of all variables' initial values and identify which variables have initial values that exceed 1000 units.",
        "query": "SELECT SUM(initialValue) AS totalInitialValue, variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 1000;",
        "step": "【step1】: Calculate the total initial value using SUM() while filtering variables exceeding 1000 units via WHERE.  【step2】: Combine aggregation with individual variable details in a single pass through the Variables table.  【step3】: Return both aggregated total and per-variable data where initialValue violates the safety threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1115,
        "question": "In the laboratory table, calculate the per capita equipment quantity for each laboratory and identify which laboratories have a per capita equipment quantity below 2 units/person.",
        "query": "SELECT labId, labName, equipmentCount / capacity AS equipmentPerPerson FROM Labs WHERE equipmentCount / capacity < 2;",
        "step": "【step1】: Calculate the equipment per person ratio by dividing equipmentCount by capacity for each lab, and project labId, labName, and the calculated value as equipmentPerPerson.  【step2】: Filter the results to include only labs where the equipmentPerPerson value is less than 2.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1116,
        "question": "In the hypothetical table, assuming the verification result is true and the verification date is more than 100 years in the future. Calculate the difference between the verification date and the current date for these assumptions, and identify which assumptions have a verification date that exceeds the maximum service life of laboratory equipment, which is 100 years.",
        "query": "SELECT SUM(initialValue) AS totalInitialValue, variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 1000 GROUP BY variableId, variableName, initialValue, unit;",
        "step": "【step1】: Filter hypotheses with verificationResult '真' and verificationDate exceeding CURRENT_DATE + 100 years using WHERE clause.  【step2】: Calculate date difference using DATEDIFF(verificationDate, CURRENT_DATE) to get days OR TIMESTAMPDIFF(YEAR, CURRENT_DATE, verificationDate) for years.  【step3】: Compare the calculated difference against 100 years (36524 days) to identify exceeding records via HAVING or WHERE.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1117,
        "question": "In the lab, if the measurement unit of an experiment is volts (V), and the measured value in the experimental data table is 5V with environmental conditions of 25°C temperature and 50% humidity, please calculate the error range of the measured value under these environmental conditions.",
        "query": "WITH EnvironmentalCoefficients AS (SELECT 0.01 AS temperature_coefficient, 0.005 AS humidity_coefficient), StandardConditions AS (SELECT 20 AS standard_temperature, 40 AS standard_humidity), ExperimentData AS (SELECT measurementValue, environmentalConditions FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5 AND environmentalConditions LIKE '%25°C%' AND environmentalConditions LIKE '%50%') SELECT measurementValue * ((SELECT temperature_coefficient FROM EnvironmentalCoefficients) * (25 - (SELECT standard_temperature FROM StandardConditions)) + (SELECT humidity_coefficient FROM EnvironmentalCoefficients) * (50 - (SELECT standard_humidity FROM StandardConditions))) AS error_range FROM ExperimentData;",
        "step": "【step1】: Define temperature and humidity coefficients along with standard conditions using CTEs (EnvironmentalCoefficients, StandardConditions).  【step2】: Filter the ExperimentData table to retrieve the 5V measurement under 25°C and 50% humidity.  【step3】: Calculate the error range by applying the formula: measurementValue × [(temp_coeff × (25 - standard_temp)) + (humidity_coeff × (50 - standard_humidity))].",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1118,
        "question": "Suppose there are three variables A, B, and C in an experiment, with initial values of 10, 20, and 30. If the sensitivity value of variable A is 0.5, variable B is 0.3, and variable C is 0.2, please calculate the total impact of these three variables on the experimental results.",
        "query": "SELECT SUM(s.sensitivityValue * v.initialValue) AS totalImpact FROM SensitivityAnalysis s JOIN Variables v ON s.variableId = v.variableId WHERE v.variableName IN ('A', 'B', 'C');",
        "step": "【step1】: Filter Variables table to retrieve initial values for variables A, B, and C using WHERE v.variableName IN ('A', 'B', 'C').  【step2】: JOIN SensitivityAnalysis table with filtered Variables table using variableId to pair sensitivity values with corresponding variables.  【step3】: Calculate SUM of products (sensitivityValue * initialValue) for matched records to determine totalImpact.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1119,
        "question": "In the laboratory, if a device's calibration date is January 1, 2022, and the device's calibration cycle is 1 year, determine whether the device needs to be recalibrated on May 1, 2023.",
        "query": "SELECT deviceId, deviceName, calibrationDate, CASE WHEN DATE_ADD(calibrationDate, INTERVAL 1 YEAR) < '2023-05-01' THEN '需要重新校准' ELSE '不需要重新校准' END AS recalibrationStatus FROM Devices WHERE calibrationDate = '2022-01-01';",
        "step": "【step1】: Filter devices with calibration date exactly '2022-01-01' using WHERE calibrationDate = '2022-01-01'  【step2】: Calculate next calibration due date by adding 1 year interval to calibrationDate using DATE_ADD(calibrationDate, INTERVAL 1 YEAR)  【step3】: Compare calculated due date with '2023-05-01' via CASE statement to determine recalibration status, returning '需要重新校准' if due date precedes 2023-05-01",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1120,
        "question": "Assuming the laboratory's area is 10,000 square meters and each piece of equipment requires 10 square meters of space, what is the maximum equipment capacity of the laboratory?",
        "query": "SELECT 10000 / 10 AS max_equipment_capacity;",
        "step": "【step1】: Calculate available area divided by new space requirement per device (10000 / 10)  【step2】: Return the result as max_equipment_capacity",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1121,
        "question": "In the laboratory, suppose there is an experiment that requires calculating the average value of voltage data collected by the equipment under specific environmental conditions. Please calculate the average voltage data collected by the equipment under the conditions where the ambient temperature is 25°C, the humidity is 60%, and the unit is volts.",
        "query": "SELECT AVG(measurementValue) AS average_voltage FROM ExperimentData WHERE environmentalConditions = 'temperature:25°C, humidity:60%' AND unit = 'V';",
        "step": "【step1】: Filter records from ExperimentData where environmentalConditions exactly match 'temperature:25°C, humidity:60%' and unit is 'V'  【step2】: Select only the measurementValue column from the filtered records  【step3】: Calculate the average of the selected measurementValues using AVG() function and alias as average_voltage",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1122,
        "question": "In the laboratory, suppose there is an experiment that requires calculating the standard deviation of temperature data collected by a device during a specific time period. Please calculate the standard deviation of the temperature data collected by the device from January 1, 2023 to January 31, 2023, where the temperature measurements are in Celsius.",
        "query": "WITH TemperatureData AS (SELECT measurementValue FROM ExperimentData WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31' AND unit = 'Celsius') SELECT SQRT(AVG(POWER(measurementValue - (SELECT AVG(measurementValue) FROM TemperatureData), 2))) AS standard_deviation FROM TemperatureData;",
        "step": "【step1】: Filter ExperimentData to retrieve temperature measurements in Celsius between 2023-01-01 and 2023-01-31 using the CTE TemperatureData.  【step2】: Calculate the mean temperature value via a subquery (SELECT AVG(measurementValue) FROM TemperatureData).  【step3】: Compute standard deviation by averaging squared deviations from the mean and taking the square root.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1123,
        "question": "In the laboratory, assuming there is an experiment that requires calculating the maximum value of humidity data collected by the equipment within a specific time period. Please calculate the maximum value of humidity data collected by the equipment between January 1, 2023, and January 31, 2023, where the unit is percentage.",
        "query": "SELECT MAX(measurementValue) AS max_humidity FROM ExperimentData WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31' AND unit = '%';",
        "step": "【step1】: Filter the ExperimentData table to include only records where timestamp falls between '2023-01-01' and '2023-01-31'  【step2】: Further refine the filtered data by selecting only entries with unit='%' (indicating humidity measurements)  【step3】: Apply the MAX() aggregation function on the measurementValue column to calculate the maximum humidity value, aliased as max_humidity",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1124,
        "question": "In the laboratory, assuming there is an experiment that requires calculating the average value of pressure data collected by a device under extreme environmental conditions. Please calculate the average value of the pressure data collected by the device under the conditions where the ambient temperature is 1000°C and the humidity is 100%, and the pressure unit is Pa.",
        "query": "SELECT AVG(measurementValue) AS average_pressure FROM ExperimentData WHERE environmentalConditions LIKE '%temperature=1000°C%' AND environmentalConditions LIKE '%humidity=100%' AND unit = 'Pa';",
        "step": "【step1】: Filter ExperimentData records where environmentalConditions contains 'temperature=1000°C' using LIKE operator  【step2】: Further filter results from step1 to include only records where environmentalConditions also contains 'humidity=100%'  【step3】: Calculate the AVG() of measurementValue from step2's filtered records where unit is 'Pa', aliasing the result as average_pressure",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1125,
        "question": "Query the names of all researchers and the names of the experiments they participated in, where the measurement units of these experiments are 'Volts (V)', and the experiment start dates are after January 1, 2022, sorted in ascending order by the researcher's name.",
        "query": "SELECT r.researcherName, e.experimentName FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = '伏特(V)' AND e.startDate > '2022-01-01' ORDER BY r.researcherName ASC;",
        "step": "【step1】: Join Researchers and Experiments tables using researcherId to link researchers with their experiments  【step2】: Join ExperimentData table using experimentId to access measurement unit information  【step3】: Apply filters (unit='伏特(V)' and startDate after 2022-01-01) then sort by researcherName",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1126,
        "question": "Calculate the ratio of the number of equipment to the laboratory capacity for each lab, sort the results in descending order of the ratio, and take the top 5.",
        "query": "SELECT labId, labName, equipmentCount / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;",
        "step": "【step1】: Retrieve labId, labName and calculate equipmentCount/capacity ratio for all rows in Labs table  【step2】: Sort results by calculated ratio in descending order  【step3】: Apply LIMIT 5 to get top-ranked records",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1127,
        "question": "Query all experiments with the status 'Completed,' where the hypothesis validation result is 'True' and the experiment end date is before December 31, 2021, sorted by experiment name in ascending order.",
        "query": "SELECT e.experimentId, e.experimentName, e.startDate, e.endDate, e.status, h.verificationResult FROM Experiments e JOIN Hypotheses h ON e.experimentId = h.experimentId WHERE e.status = '已完成' AND h.verificationResult = '真' AND e.endDate <= '2021-12-31' ORDER BY e.experimentName ASC;",
        "step": "【step1】: Join the 'Experiments' table with the 'Hypotheses' table using experimentId to link experiment data with their corresponding hypothesis verification results.  【step2】: Filter the combined dataset to include only experiments with status '已完成', verificationResult '真', and endDate before or equal to 2021-12-31.  【step3】: Sort the filtered results by experimentName in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1128,
        "question": "Assuming the laboratory's capacity can be expanded infinitely, query the ratio of equipment quantity to capacity for all laboratories, sort in descending order by the ratio, and take the top 10.",
        "query": "SELECT labId, labName, equipmentCount / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 10;",
        "step": "【step1】: Extract labId, labName, and calculate equipmentCount divided by capacity as ratio from Labs table  【step2】: Order the results by ratio in descending order  【step3】: Limit the output to top 10 records",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1129,
        "question": "Query the name of the laboratory with the most equipment in the lab and its equipment count.",
        "query": "SELECT labName, equipmentCount FROM Labs ORDER BY equipmentCount DESC LIMIT 1;",
        "step": "【step1】: Retrieve all lab names and their equipment counts from the Labs table.  【step2】: Sort the results by equipmentCount in descending order to prioritize labs with the highest count.  【step3】: Limit the output to the first row to return only the lab with the maximum equipment count.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1130,
        "question": "Calculate the average number of devices in each laboratory, and find the names of the laboratories and their average number of devices where the average number of devices is higher than the average number of devices across all laboratories.",
        "query": "SELECT labName, AVG(equipmentCount) AS avgEquipmentCount FROM Labs GROUP BY labName HAVING AVG(equipmentCount) > (SELECT AVG(equipmentCount) FROM Labs);",
        "step": "【step1】: Calculate the average equipment count per lab by grouping the Labs table on labName and applying AVG(equipmentCount).  【step2】: Compute the overall average equipment count across all labs using a subquery (SELECT AVG(equipmentCount) FROM Labs).  【step3】: Filter the grouped results from Step 1 using the HAVING clause to retain only labs whose average equipment count exceeds the subquery result from Step 2.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1131,
        "question": "Retrieve the names and capacities of currently open labs, sorted by capacity in ascending order.",
        "query": "SELECT labName, capacity FROM Labs WHERE status = '开放' ORDER BY capacity ASC;",
        "step": "【step1】: SELECT labName, capacity FROM Labs  【step2】: WHERE status = '开放'  【step3】: ORDER BY capacity ASC",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1132,
        "question": "Assuming the laboratory capacity can be expanded infinitely, query the names and capacities of laboratories with a capacity greater than 1,000 people, and sort them in descending order by capacity.",
        "query": "SELECT labName, capacity FROM Labs WHERE capacity > 1000 ORDER BY capacity DESC;",
        "step": "【step1】: Execute base SELECT to retrieve labName and capacity columns from Labs table  【step2】: Apply WHERE filter to keep only records with capacity > 1000  【step3】: Sort remaining results in descending order using ORDER BY capacity DESC",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1133,
        "question": "Retrieve the name and earliest calibration date for all devices, grouped by device type.",
        "query": "SELECT deviceType, deviceName, MIN(calibrationDate) AS earliestCalibrationDate FROM Devices GROUP BY deviceType;",
        "step": "【step1】: Retrieve the earliest calibration date for each device type using MIN() function and GROUP BY clause  【step2】: Join the aggregated results back to original Devices table to match device details  【step3】: Select required fields (deviceType, deviceName, earliest date) after ensuring correct record matching through WHERE condition",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1134,
        "question": "Calculate the average number of devices across all labs, and find the names of labs with a higher-than-average number of devices along with their respective device counts.",
        "query": "WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount;",
        "step": "【step1】: Calculate the average equipment count across all labs using a CTE (LabEquipmentAvg) with AVG(equipmentCount).  【step2】: Perform a cross join between the Labs table and the CTE to associate each lab with the computed average.  【step3】: Filter labs where equipmentCount exceeds the average and output labName and equipmentCount.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1135,
        "question": "Query all equipment with a status of normal, group them by equipment type, and count the number of each type of equipment.",
        "query": "SELECT deviceType, deviceName, MIN(calibrationDate) AS earliestCalibrationDate FROM Devices GROUP BY deviceType, deviceName;",
        "step": "【step1】: Filter devices with 'Normal' status from Devices table using WHERE status = '正常'  【step2】: Group the filtered results by both deviceType and deviceName using GROUP BY deviceType, deviceName  【step3】: Calculate the earliest calibration date for each group using MIN(calibrationDate) while selecting deviceType and deviceName",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1136,
        "question": "Assuming the laboratory's capacity can be expanded indefinitely, query the names of all laboratories with more than 1,000 pieces of equipment and their respective equipment counts, then sort them in descending order by equipment quantity.",
        "query": "SELECT labName, equipmentCount FROM Labs WHERE equipmentCount > 1000 ORDER BY equipmentCount DESC;",
        "step": "【step1】: Retrieve all records from the Labs table.  【step2】: Filter the records where equipmentCount exceeds 1000.  【step3】: Sort the filtered results in descending order by equipmentCount and project the labName and equipmentCount fields.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1137,
        "question": "Query in the experimental data table for records where the measured values exceed 1000 units and the data quality is high, sorted in ascending order by measured value, and return the top 10 records.",
        "query": "SELECT * FROM ExperimentData WHERE measurementValue > 1000 AND dataQuality = '高' ORDER BY measurementValue ASC LIMIT 10;",
        "step": "【step1】: Filter the ExperimentData table to select records where measurementValue exceeds 1000 and dataQuality is '高'.  【step2】: Sort the filtered results by measurementValue in ascending order.  【step3】: Limit the sorted output to the first 10 records.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1138,
        "question": "Calculate the average of the measurements for each experiment, and return the experiment IDs with an average value greater than 500 along with their average values, sorted in descending order by the average.",
        "query": "SELECT experimentId, AVG(measurementValue) AS averageValue FROM ExperimentData GROUP BY experimentId HAVING AVG(measurementValue) > 500 ORDER BY averageValue DESC;",
        "step": "【step1】: Group the ExperimentData by experimentId and calculate the average measurementValue for each group.  【step2】: Filter groups to retain only those with an average measurementValue exceeding 500 using the HAVING clause.  【step3】: Sort the remaining results by the calculated averageValue in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1139,
        "question": "Query the names and locations of laboratories with a capacity of more than 50 people and equipment count exceeding 100, sorted in ascending order by laboratory capacity.",
        "query": "SELECT labName, location FROM Labs WHERE capacity > 50 AND equipmentCount > 100 ORDER BY capacity ASC;",
        "step": "【step1】: Filter records from the 'Labs' table where capacity exceeds 50 and equipmentCount exceeds 100.  【step2】: Sort the filtered results by the capacity column in ascending order.  【step3】: Select and return only the labName and location columns from the sorted dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1140,
        "question": "Assuming the lab's capacity can be expanded indefinitely, query the names and locations of labs with a capacity exceeding 1,000,000 people, sorted in descending order by capacity, and return the top 5 records.",
        "query": "SELECT labName, location FROM Labs WHERE capacity > 1000000 ORDER BY capacity DESC LIMIT 5;",
        "step": "【step1】: Filter the Labs table to include only records where capacity exceeds 1,000,000 using the WHERE clause.  【step2】: Sort the filtered results in descending order based on the capacity column using ORDER BY.  【step3】: Restrict the final output to the top 5 records using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1141,
        "question": "In the laboratory, using a spectrometer with device type 'spectrometer' to measure the wavelength of light in an experiment with status 'in progress', assuming the measured value is 500nm, please calculate the frequency of this light wave.",
        "query": "SELECT (3.00 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM Experiments e JOIN Devices d ON e.labId = d.labId WHERE d.deviceType = '光谱仪' AND e.status = '进行中';",
        "step": "【step1】: Filter ongoing experiments and join with devices to ensure the spectrometer is used in an active lab context.  【step2】: Apply the formula (3.00 × 10⁸ m/s) / (500 × 10⁻⁹ m) to calculate frequency directly via arithmetic operations.  【step3】: Return the computed frequency as a single-column result set without additional data aggregation or filtering.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1142,
        "question": "In the experimental data table, the unit of the measured values is volts (V). Assuming the measured value is 5V, please calculate the current passing through the resistor.",
        "query": "SELECT measurementValue / 10 AS current FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5;",
        "step": "【step1】: Filter records from ExperimentData where the unit is 'V' and measurementValue equals 5.  【step2】: Apply Ohm's Law calculation by dividing the filtered measurementValue (5V) by the given resistance (10Ω).  【step3】: Return the result of this calculation aliased as \"current\" in the output.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1143,
        "question": "In the laboratory, the calibration date of equipment is a critical factor in ensuring measurement accuracy. Assuming the calibration date is January 1, 2020, and the current date is January 1, 2023, determine whether the device requires recalibration.",
        "query": "SELECT deviceId, deviceName, calibrationDate, CASE WHEN DATE_ADD(calibrationDate, INTERVAL 1 YEAR) < '2023-01-01' THEN '需要重新校准' ELSE '不需要重新校准' END AS calibrationStatus FROM Devices WHERE calibrationDate = '2020-01-01';",
        "step": "【step1】: Filter devices with calibration date '2020-01-01' using WHERE clause  【step2】: Calculate calibration validity cutoff by adding 1 year to calibrationDate using DATE_ADD()  【step3】: Compare cutoff date with '2023-01-01' using CASE expression to determine calibration status",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1144,
        "question": "In the sensitivity analysis table, assume that the sensitivity value of a certain variable is 1000, its impact level is high, and its initial value is 1000, with the unit being meters (m). Find the variable ID, variable name, maximum value (calculated as 100 times the initial value), and unit for this variable.",
        "query": "SELECT variableId, variableName, initialValue * 100 AS maximumValue, unit FROM Variables WHERE variableId IN (SELECT variableId FROM SensitivityAnalysis WHERE sensitivityValue = 1000 AND impact = '高') AND initialValue = 1000 AND unit = '米(m)';",
        "step": "【step1】: Execute a subquery to select variableIds from the SensitivityAnalysis table where sensitivityValue = 1000 and impact = '高'.  【step2】: Filter the Variables table by initialValue = 1000, unit = '米(m)', and variableIds from the subquery.  【step3】: Calculate maximumValue as initialValue * 100 and output variableId, variableName, maximumValue, and unit.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1145,
        "question": "Assume a laser printer has a power consumption of 500 watts and a printing speed of 30 pages per minute. If a user performs a monochrome printing task of 150 pages that must be completed continuously, calculate the total electrical energy consumed by the task (in watt-hours).",
        "query": "SELECT (p.Power_Consumption * (j.Page_Count / p.Print_Speed) / 60) AS Total_Energy_Wh FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE j.Color_Usage = 'Monochrome' AND j.Page_Count = 150 AND p.Power_Consumption = 500 AND p.Print_Speed = 30;",
        "step": "【step1】: Perform an INNER JOIN between the 'printers' and 'print_jobs' tables using Printer_ID to link printer specifications with job parameters.  【step2】: Apply WHERE clause filters to select records where Color_Usage is 'Monochrome', Page_Count equals 150, Power_Consumption is 500W, and Print_Speed is 30ppm.  【step3】: Calculate total energy consumption using the formula: (Power_Consumption × (Page_Count / Print_Speed) / 60) to convert minutes to hours and derive watt-hours.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1146,
        "question": "A manufacturer has an annual revenue of $5 billion, with a profit margin of 15%, and R&D expenses accounting for 8% of the revenue. Calculate the difference between the manufacturer's net profit (after accounting for R&D) and R&D expenses (in dollars).",
        "query": "SELECT (Revenue * Profit_Margin / 100) - (Revenue * R&D_Spending / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND R&D_Spending = 8;",
        "step": "【step1】: Filter the manufacturers table to find the specific manufacturer with $50 billion revenue, 15% profit margin, and 8% R&D spending using WHERE clause.  【step2】: Calculate annual net profit by multiplying Revenue (5,000,000,000) by Profit_Margin (15%) and dividing by 100.  【step3】: Subtract R&D spending (calculated as Revenue * 8% / 100) from the net profit to get the final difference.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1147,
        "question": "Current toner remaining is 5%, with a labeled capacity of 5,000 pages. There is an urgent printing task of 800 pages today. Is it necessary to replace the consumables immediately?",
        "query": "SELECT CASE WHEN (Capacity * (Current_Level / 100)) >= 800 THEN 'No' ELSE 'Yes' END AS Need_Replacement FROM consumables WHERE Type = 'Toner' AND Capacity = 5000 AND Current_Level = 5;",
        "step": "【step1】: Filter the 'consumables' table to select records where Type is 'Toner', Capacity is 5000, and Current_Level is 5%.  【step2】: Calculate the remaining usable pages using the formula (Capacity * (Current_Level / 100)) for the filtered record.  【step3】: Apply the CASE statement to compare the calculated remaining pages (250) with the required 800 pages, returning 'Yes' since 250 < 800.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1148,
        "question": "If a 3D printer's consumable material capacity is 1kg per 1000 pages, and the current remaining amount is 999.99%, the user submits a printing task requiring 2000kg of material. In theory, how many times does the consumable need to be replaced? (Note: The normal value range is 0-100%)",
        "query": "SELECT (Revenue * Profit_Margin / 100) - (Revenue * `R&D_Spending` / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND `R&D_Spending` = 8;",
        "step": "【step1】: Filter manufacturers table where Revenue = 5,000,000,000, Profit_Margin = 15, and R&D_Spending = 8  【step2】: Calculate gross profit (Revenue × Profit_Margin ÷ 100)  【step3】: Subtract R&D expenditure (Revenue × R&D_Spending ÷ 100) from gross profit to derive Net_Profit_RD_Difference",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1149,
        "question": "Assuming that the current remaining quantity of all consumables of type Paper is 30%, and the weight of a single A4 sheet is 5 grams, calculate the total remaining paper weight (in kilograms) for each consumable, and list the top 5 in descending order by total weight.",
        "query": "SELECT Consumable_ID, (Capacity * 0.3 * 5) / 1000 AS Total_Weight_KG FROM consumables WHERE Type = 'Paper' ORDER BY Total_Weight_KG DESC LIMIT 5;",
        "step": "【step1】: Filter the consumables table to include only records where the Type is 'Paper' using the WHERE clause.  【step2】: Calculate the remaining paper weight in kilograms for each consumable by applying the formula (Capacity * 0.3 * 5) / 1000 and alias it as Total_Weight_KG.  【step3】: Sort the results by Total_Weight_KG in descending order and limit the output to the top 5 records using ORDER BY and LIMIT clauses.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1150,
        "question": "If the capacity of toner and ink represents the printable pages, and the capacity of the drum unit and fuser represents the total supported pages, please calculate the total remaining printable pages for toner and ink supplies (including their current level usage) and the remaining page capacity for drum and fuser supplies (representing unused lifespan), then list the top 3 printer IDs in descending order by the total sum of these remaining values.",
        "query": "SELECT Printer_ID, SUM(CASE WHEN Type IN ('Toner', 'Ink') THEN Capacity * (Current_Level / 100) ELSE Capacity - (Capacity * (Current_Level / 100)) END) AS Total_Remaining_Pages FROM consumables GROUP BY Printer_ID ORDER BY Total_Remaining_Pages DESC LIMIT 3;",
        "step": "【step1】: Calculate remaining pages for each consumable based on type: Use Capacity * (Current_Level/100) for 'Toner'/'Ink', and Capacity - (Capacity * (Current_Level/100)) for others.  【step2】: Aggregate results by Printer_ID using SUM() to get total remaining pages per device.  【step3】: Sort printers by total remaining pages in descending order and return the top 3 results using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1151,
        "question": "Based on the expected replacement date (Next_Replacement_Date) of the consumables and the current remaining quantity, identify which consumables have an estimated daily usage rate exceeding 1% of their capacity, and list the top 10 in ascending order of this usage rate.",
        "query": "SELECT Consumable_ID, (100 - Current_Level) / DATEDIFF(Next_Replacement_Date, CURDATE()) AS Daily_Usage_Percent FROM consumables WHERE DATEDIFF(Next_Replacement_Date, CURDATE()) > 0 HAVING Daily_Usage_Percent > 1 ORDER BY Daily_Usage_Percent ASC LIMIT 10;",
        "step": "【step1】: Filter consumables where the next replacement date is in the future (DATEDIFF > 0) to ensure valid date calculations.  【step2】: Calculate daily usage percentage using (100 - Current_Level) divided by days until replacement. Apply HAVING clause to retain entries exceeding 1% daily usage.  【step3】: Sort results by ascending daily usage percentage and return the first 10 entries via LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1152,
        "question": "Assuming the Current_Level of a certain printer consumable has been incorrectly set to 10,000%, and its Capacity is 100 million pages. Calculate its theoretical remaining page count and list all consumables where the Current_Level is greater than 100, in descending order of their theoretical page count.",
        "query": "SELECT Consumable_ID, Capacity * (Current_Level / 100) AS Theoretical_Pages FROM consumables WHERE Current_Level > 100 ORDER BY Theoretical_Pages DESC;",
        "step": "【step1】: Filter consumables with abnormal Current_Level (>100%) using WHERE clause  【step2】: Calculate theoretical pages via Capacity*(Current_Level/100) as derived column  【step3】: Sort results by calculated page count descending via ORDER BY Theoretical_Pages DESC",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1153,
        "question": "Assuming all printers have a toner capacity of 5,000 pages, with a current remaining level of 30%, and a printing speed of 30 ppm (pages per minute). If all printers continue to operate at maximum speed, how many hours will it take to deplete each consumable type based on current capacity and usage speed? Group and return the results by consumable type.",
        "query": "SELECT c.Type, (c.Capacity * (c.Current_Level / 100) / (p.Print_Speed * 60)) AS 耗尽时间_小时 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Toner' GROUP BY c.Type;",
        "step": "【step1】: Perform INNER JOIN between `consumables` and `printers` tables using `Printer_ID` to link toner capacity with printer speed data.  【step2】: Filter records where `Type='Toner'` and calculate remaining pages: `Capacity * (Current_Level/100)` (5000*0.3=1500 pages).  【step3】: Compute depletion time by dividing remaining pages by hourly printing capacity (`Print_Speed*60`), then group by `Type` to return toner's 1500/(30*60)=0.8333 hours.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1154,
        "question": "Calculate the total cost efficiency (total capacity/total cost) for each printer (Printer_ID) and order in descending order by efficiency value. Include data for supplies of type Ink and Drum.",
        "query": "SELECT c.Printer_ID, SUM(c.Capacity) / SUM(c.Cost) AS 总成本效率 FROM consumables c WHERE c.Type IN ('Ink', 'Drum') GROUP BY c.Printer_ID ORDER BY 总成本效率 DESC;",
        "step": "【step1】:【Filter consumables records to include only 'Ink' and 'Drum' types using WHERE clause】  【step2】:【Group filtered data by Printer_ID, calculate SUM(Capacity)/SUM(Cost) as total cost efficiency】  【step3】:【Sort the grouped results by total cost efficiency in descending order using ORDER BY】",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1155,
        "question": "Which types of consumables have the highest count of records where the current level is below 20, and therefore should be prioritized for replacement?",
        "query": "SELECT c.Type, MAX(c.Capacity * (c.Current_Level / 100) / (p.Print_Speed * 60)) AS 耗尽时间_小时 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Toner' GROUP BY c.Type;",
        "step": "【step1】: Execute JOIN operation between `consumables` and `printers` using Printer_ID to associate print speed data with consumables  【step2】: Filter records where consumable type is explicitly 'Toner' using WHERE clause  【step3】: Calculate maximum time-to-depletion (Capacity × Current_Level% ÷ (Print_Speed × 60)) and group results by Type  Priority replacement basis: Toner requires urgent attention as it's critical for laser printer operations. Low toner levels risk print quality degradation, drum damage, and workflow interruptions. Paper (though not in query) would be lower priority since physical replenishment is simpler and doesn't require technical intervention.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1156,
        "question": "Assuming a drum component (Drum) has its Capacity incorrectly labeled as 1,000,000 pages (normal value ≤50,000 pages), and the Current_Level is 0.01% (which corresponds to 0.0001 as a decimal). Group by printer type (Type) to calculate whether the calculated remaining pages (1000000 * 0.0001) exceed the physical tray capacity (Tray_Capacity), indicating a contradiction.",
        "query": "SELECT p.Type, CASE WHEN (1000000 * 0.0001) > p.Tray_Capacity THEN 1 ELSE 0 END AS 矛盾检测 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Drum' AND c.Capacity = 1000000 AND c.Current_Level = 0.01 GROUP BY p.Type;",
        "step": "【step1】: Filter consumables table to find drum components with erroneous capacity (1,000,000 pages) and 0.01% current level  【step2】: Join with printers table to obtain tray capacity for corresponding printer models  【step3】: Calculate theoretical remaining pages (1000000 × 0.0001 = 100 pages), compare with physical tray capacity, and group results by printer type to flag inconsistencies",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1157,
        "question": "Find all toner supplies with a current remaining quantity below 30% that are associated with printers consuming over 1000 watts and not scheduled for replacement in the maintenance log.",
        "query": "SELECT c.* FROM consumables c INNER JOIN printers p ON c.Printer_ID = p.Printer_ID LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement' WHERE c.Type = 'Toner' AND c.Current_Level < 30 AND p.Power_Consumption > 1000 AND ml.Maintenance_ID IS NULL;",
        "step": "【step1】: Inner join consumables with printers on Printer_ID, filtering where Type='Toner' and Current_Level<30  【step2】: Left join maintenance_logs on Printer_ID and Maintenance_Type='Replacement', setting ml.Maintenance_ID IS NULL  【step3】: Apply printer power consumption filter (p.Power_Consumption>1000) to the joined dataset",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1158,
        "question": "Calculate the average daily wear rate of each drum component over the past 90 days, and identify consumables with a predicted lifespan of less than 7 days that have no scheduled replacement and were last replaced within the past 90 days.",
        "query": "SELECT p.Type, CASE WHEN (1000000 * 0.0001) > p.Tray_Capacity THEN 1 ELSE 0 END AS 矛盾检测 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Drum' AND c.Capacity = 1000000 AND c.Current_Level = 0.01 GROUP BY p.Type, p.Tray_Capacity;",
        "step": "【step1】: Filter drum-type consumables with capacity=1,000,000 and current_level=0.01%, then calculate daily wear rate using (Capacity * Current_Level) / days_since_last_replacement  【step2】: Join printers to detect tray capacity contradictions where (1,000,000 * 0.0001) > Tray_Capacity using CASE conditional judgment  【step3】: Group results by printer type and tray capacity while excluding consumables with maintenance records through implicit anti-join (absence in maintenance_logs)",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1159,
        "question": "Identify all fuser consumables that have been installed for more than 3 years, currently have a remaining level below 15%, and have no replacement record in the maintenance log.",
        "query": "SELECT c.* FROM consumables c INNER JOIN printers p ON c.Printer_ID = p.Printer_ID LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement' WHERE c.Type = 'Fuser' AND c.Current_Level < 15 AND p.Installation_Date < NOW() - INTERVAL 3 YEAR AND ml.Maintenance_ID IS NULL;",
        "step": "【step1】: Filter consumables of type 'Fuser' with current level below 15% and join with printers table to check installation date older than 3 years  【step2】: Left join maintenance_logs to identify consumables without scheduled 'Replacement' type maintenance records  【step3】: Apply NULL check on Maintenance_ID to finalize unplanned replacement consumables meeting all criteria",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1160,
        "question": "Retrieve all consumables with a capacity exceeding 100 million pages or a current remaining level exceeding 200 pages that have no maintenance log records.",
        "query": "SELECT c.* FROM consumables c LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID WHERE (c.Capacity > 100000000 OR c.Current_Level > 200) AND ml.Maintenance_ID IS NULL GROUP BY c.Consumable_ID HAVING COUNT(ml.Maintenance_ID) = 0;",
        "step": "【step1】: Filter consumables meeting capacity (>100 million pages) or current level (>200%) conditions using WHERE clause with OR operator  【step2】: Perform LEFT JOIN with maintenance_logs to identify consumables with zero maintenance records through NULL check on Maintenance_ID  【step3】: Use GROUP BY and HAVING clause to confirm no maintenance history exists (COUNT(ml.Maintenance_ID) = 0) for final result aggregation",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1161,
        "question": "A certain laser printer has a rated power consumption of 1500 watts. After maintenance, the actual effective printing time was 8 hours per day, and the maintenance log showed that the printer ran continuously for 30 days after maintenance. Calculate its total energy consumption (in kWh) and the equivalent carbon dioxide emissions (given that 1 kWh = 0.92 kg CO₂).",
        "query": "SELECT (1500 * 8 * 30) / 1000 AS Total_Energy_kWh, (1500 * 8 * 30) / 1000 * 0.92 AS CO2_Emissions_kg FROM printers WHERE Printer_ID = '特定打印机ID';",
        "step": "【step1】: Identify static calculation parameters from the problem statement. The query uses hardcoded values (1500W, 8 hours/day, 30 days) instead of pulling Power_Consumption from printers table or maintenance duration from maintenance_logs.【step2】: Analyze structural flaws - The query doesn't actually utilize any relational data from the database schema provided. The calculation could be performed without any database tables, making the FROM printers clause and WHERE condition artificial/vulnerable.【step3】: Recommend schema-aligned reconstruction:  1. Get Power_Consumption from printers.Power_Consumption  2. Calculate actual days using DATEDIFF on maintenance_logs dates  3. Join printers with maintenance_logs for contextual filtering",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1162,
        "question": "A department's color printing tasks account for 60% of the total volume. It is known that color cartridges have a capacity of 5,000 pages for $200, while monochrome cartridges have a capacity of 10,000 pages for $150. If this month's maintenance log shows the replacement of 3 color and 2 monochrome cartridges, calculate the difference rate between the actual per-page printing cost and the theoretical cost based on the volume-weighted average.",
        "query": "WITH Theoretical AS (SELECT (0.6*200/5000) + (0.4*150/10000) AS TheoreticalCost), Actual AS (SELECT (3*200 + 2*150) / (3*5000 + 2*10000) AS ActualCost) SELECT ((ActualCost - TheoreticalCost) / TheoreticalCost) * 100 AS DifferenceRate FROM Theoretical, Actual;",
        "step": "【step1】: Calculate the theoretical cost per page by combining 60% color cost (200 USD/5000 pages) and 40% monochrome cost (150 USD/10000 pages).  【step2】: Compute the actual cost per page using total expenditure (3×200 + 2×150 USD) divided by total printed pages (3×5000 + 2×10000).  【step3】: Determine the difference rate by comparing actual and theoretical costs with ((ActualCost - TheoreticalCost)/TheoreticalCost)×100.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1163,
        "question": "Maintenance logs indicate that certain printers have average maintenance intervals exceeding the recommended cycle by 50% or more, and mechanical wear is suspected. What is the root cause and recommendation for these printers?",
        "query": "SELECT Printer_ID, '故障原因：维护间隔过长导致机械部件磨损' AS RootCause, '建议：立即执行预防性维护，更换磨损部件，恢复推荐维护周期' AS Recommendation FROM (SELECT Printer_ID, AVG(DATEDIFF(Maintenance_Date, LAG(Maintenance_Date) OVER (ORDER BY Maintenance_Date))) AS AvgInterval FROM maintenance_logs GROUP BY Printer_ID HAVING COUNT(*) >= 3) t WHERE AvgInterval > 推荐周期 * 1.5;",
        "step": "【step1】: Calculate average maintenance intervals using window function LAG() to compare consecutive maintenance dates per printer, filtered by 3+ maintenance records.  【step2】: Filter printers where average interval exceeds 150% of recommended cycle (though \"recommended cycle\" is undefined in schema, treated as existing parameter).  【step3】: Combine printer IDs with hardcoded root cause and maintenance recommendations through static text fields.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1164,
        "question": "Assuming the one-time maintenance cost of a certain 3D printer suddenly reaches $9.9×10¹⁵, calculate how many units of the same model printer can be purchased with this maintenance cost (given that the unit price of this model is $2999).",
        "query": "SELECT 9.9E15 / 2999 AS NumberOfPrinters FROM dual;",
        "step": "【step1】: Convert maintenance cost to exponential notation (9.9×10¹⁵ → 9.9E15)  【step2】: Retrieve printer unit price ($2999)  【step3】: Calculate quotient and alias as NumberOfPrinters using division operator",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1165,
        "question": "Calculate the theoretical total power consumption (in kWh) for each printer across maintenance records with the maintenance type 'Repair', assuming the printer operates at maximum power consumption during each maintenance session, which lasts 2 hours. List the top 5 printers in descending order of total power consumption.",
        "query": "SELECT Printer_ID, '故障原因：维护间隔过长导致机械部件磨损' AS RootCause, '建议：立即执行预防性维护，更换磨损部件，恢复推荐维护周期' AS Recommendation FROM (SELECT Printer_ID, AVG(DATEDIFF(Maintenance_Date, Prev_Maintenance_Date)) AS AvgInterval FROM (SELECT Printer_ID, Maintenance_Date, LAG(Maintenance_Date) OVER (PARTITION BY Printer_ID ORDER BY Maintenance_Date) AS Prev_Maintenance_Date FROM maintenance_logs) t1 GROUP BY Printer_ID HAVING COUNT(*) >= 3 ) t2;",
        "step": "【step1】: Filter maintenance records with type 'Repair' and join with printers table to get power consumption data  【step2】: Calculate theoretical energy consumption per record using (Power_Consumption * 2 / 1000) and aggregate total per printer  【step3】: Sort results by total energy consumption in descending order and limit to top 5 entries",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1166,
        "question": "Statistical analysis of the month-over-month growth rate (in percentage) of maintenance costs for each month in 2023. If there is no maintenance record for a particular month or the previous month, the growth rate is considered 0. List all months in ascending order of growth rate.",
        "query": "WITH months AS ( SELECT generate_series(1,12) AS month ), monthly_cost AS ( SELECT months.month, COALESCE(SUM(ml.Cost),0) AS total_cost FROM months LEFT JOIN maintenance_logs ml ON EXTRACT(YEAR FROM ml.Maintenance_Date) = 2023 AND EXTRACT(MONTH FROM ml.Maintenance_Date) = months.month GROUP BY months.month ) SELECT current_month, CASE WHEN previous_month_cost = 0 THEN 0 ELSE ROUND(((current_month_cost - previous_month_cost) / previous_month_cost * 100)::numeric, 2) END AS growth_rate FROM ( SELECT month AS current_month, total_cost AS current_month_cost, LAG(total_cost,1,0) OVER (ORDER BY month) AS previous_month_cost FROM monthly_cost ) t ORDER BY growth_rate ASC;",
        "step": "【step1】: Generate all months (1-12) and calculate monthly maintenance cost using LEFT JOIN with maintenance_logs filtered by 2023, coalescing null to 0.  【step2】: Use LAG() window function to retrieve previous month's cost, then handle division by zero with CASE WHEN to calculate month-over-month growth rate percentage.  【step3】: Sort results by growth_rate ascending as final output.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1167,
        "question": "List the printer IDs that have undergone more than 3 maintenance instances but with each maintenance cost below the average maintenance cost, sorted in descending order by the number of maintenance instances, showing the top 10.",
        "query": "WITH global_avg AS ( SELECT AVG(Cost) AS avg_cost FROM maintenance_logs ) SELECT Printer_ID, COUNT(*) AS maintenance_count FROM maintenance_logs WHERE Cost < (SELECT avg_cost FROM global_avg) GROUP BY Printer_ID HAVING COUNT(*) > 3 ORDER BY maintenance_count DESC LIMIT 10;",
        "step": "【step1】: Calculate the global average maintenance cost using a CTE (Common Table Expression).  【step2】: Filter maintenance records with cost below the global average, group by Printer_ID, and count maintenance occurrences.  【step3】: Apply HAVING clause to select groups with >3 maintenance counts, sort results by count descending, and limit to top 10 records.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1168,
        "question": "What is the monthly percentage growth rate of maintenance costs in 2023, ordered from lowest to highest growth rate?",
        "query": "WITH months AS (SELECT 1 AS month UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10 UNION SELECT 11 UNION SELECT 12), monthly_cost AS (SELECT months.month, COALESCE(SUM(ml.Cost),0) AS total_cost FROM months LEFT JOIN maintenance_logs ml ON YEAR(ml.Maintenance_Date) = 2023 AND MONTH(ml.Maintenance_Date) = months.month GROUP BY months.month) SELECT current_month, CASE WHEN previous_month_cost = 0 THEN 0 ELSE ROUND(((current_month_cost - previous_month_cost) / previous_month_cost * 100), 2) END AS growth_rate FROM (SELECT month AS current_month, total_cost AS current_month_cost, LAG(total_cost,1,0) OVER (ORDER BY month) AS previous_month_cost FROM monthly_cost) t ORDER BY growth_rate ASC;",
        "step": "【step1】: Create a CTE 'months' to generate 12 static months, then LEFT JOIN maintenance_logs (filtered for 2023) to calculate monthly costs, filling null months with 0 via COALESCE.  【step2】: Use LAG() window function to retrieve the previous month's cost, then compute percentage growth rate (handling division-by-zero with CASE).  【step3】: Order results by growth_rate in ascending order to prioritize negative/low growth periods.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1169,
        "question": "Calculate the total electrical energy (in kilowatt-hours) consumed by each printer in standby state during the maintenance intervals, grouped by Printer_ID. Assume the standby power consumption is 20% of the rated power.",
        "query": "SELECT m.Printer_ID, SUM(DATEDIFF(m.Next_Maintenance_Date, m.Maintenance_Date) * 24 * (p.Power_Consumption * 0.2) / 1000) AS Total_Standby_Energy_kWh FROM maintenance_logs m JOIN printers p ON m.Printer_ID = p.Printer_ID GROUP BY m.Printer_ID;",
        "step": "【step1】: Join maintenance_logs with printers table using Printer_ID to associate each maintenance interval with corresponding printer's power consumption data  【step2】: Calculate standby energy consumption per maintenance interval by computing date difference between maintenance dates, multiplying by 24 hours/day, then applying 20% of printer's power consumption and converting to kilowatt-hours  【step3】: Group results by Printer_ID and sum all calculated standby energy values to obtain total consumption per printer",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1170,
        "question": "Calculate the average maintenance cost, cost standard deviation, and cost coefficient of variation for each maintenance type, grouped by Maintenance_Type.",
        "query": "WITH total_cost AS (SELECT SUM(Cost) AS total FROM maintenance_logs) SELECT Maintenance_ID, Cost, ROUND((Cost * 100.0 / (SELECT total FROM total_cost)), 4) AS cost_percentage FROM maintenance_logs WHERE Cost >= 100000 ORDER BY Cost DESC LIMIT 5;",
        "step": "【step1】: Calculate annual average cost per maintenance type by grouping Maintenance_Type, using SUM(Cost)/COUNT(DISTINCT YEAR(Maintenance_Date)) for avg_annual_cost.  【step2】: Compute standard deviation of costs for each maintenance type using STDDEV_POP(Cost) AS cost_stddev in the same grouping.  【step3】: Combine results and calculate volatility rate by (cost_stddev/avg_annual_cost)*100, then group/sort by Maintenance_Type.  Correct Query Structure:  ```sql  SELECT    Maintenance_Type,    ROUND(SUM(Cost)/COUNT(DISTINCT YEAR(Maintenance_Date)), 2) AS avg_annual_cost,    ROUND(STDDEV_POP(Cost), 2) AS cost_stddev,    ROUND((STDDEV_POP(Cost)/AVG(Cost))*100, 2) AS cost_volatility_rate  FROM maintenance_logs  GROUP BY Maintenance_Type  ORDER BY Maintenance_Type;  ```",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1171,
        "question": "Analyze the frequency of different maintenance types by quarter to determine if the preventive maintenance ratio exceeds the corrective maintenance ratio, following the industrial principle that preventive maintenance should be more frequent.",
        "query": "SELECT QUARTER(Maintenance_Date) AS Quarter, Maintenance_Type, COUNT(*) AS Frequency, (SUM(CASE WHEN Maintenance_Type = 'Routine' THEN 1 ELSE 0 END)/COUNT(*))*100 AS Preventive_Ratio FROM maintenance_logs WHERE Maintenance_Type IN ('Routine','Repair') GROUP BY Quarter, Maintenance_Type ORDER BY Quarter;",
        "step": "【step1】: Filter records to include only 'Routine' and 'Repair' maintenance types, extract quarter from Maintenance_Date  【step2】: Group by quarter and maintenance type, calculate frequency counts and preventive maintenance ratio  【step3】: Sort results chronologically by quarter to observe seasonal patterns",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1172,
        "question": "Assuming that a certain maintenance consumed 95% of the total historical maintenance budget, calculate the theoretical maximum cost for a single maintenance event by grouping technicians.",
        "query": "SELECT Technician, MAX(Cost) AS Actual_Max_Cost, (SELECT SUM(Cost)*0.95 FROM maintenance_logs) AS Theoretical_Max_Cost FROM maintenance_logs GROUP BY Technician;",
        "step": "【step1】: Group maintenance records by technician and calculate the maximum actual maintenance cost per technician using MAX(Cost)  【step2】: Calculate 95% of the total historical maintenance budget through a scalar subquery (SELECT SUM(Cost)*0.95 FROM maintenance_logs)  【step3】: Combine grouped maximum costs with the fixed theoretical value, ensuring the subquery's result gets repeated for every technician group",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1173,
        "question": "Calculate the total energy consumed by the printer in standby mode during a maintenance period (unit: joules), given that the maintenance duration is 3 hours and the printer's power consumption is 850 watts.",
        "query": "SELECT 850 * 3 * 3600 AS Total_Energy_Joules;",
        "step": "【step1】:【Convert maintenance duration to seconds: 3 hours * 3600 seconds/hour = 10800 seconds】  【step2】:【Calculate total energy using formula: Power (Watts) * Time (seconds) = 850 * 10800】  【step3】:【Return the result as Total_Energy_Joules】",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1174,
        "question": "Calculate the proportion (as a percentage rounded to two decimal places) of 'Repair' maintenance records where the cost exceeds the average cost for 'Repair' records, relative to all 'Repair' maintenance records.",
        "query": "SELECT ROUND( (COUNT(CASE WHEN Cost > (SELECT AVG(Cost) FROM maintenance_logs WHERE Maintenance_Type = 'Repair') THEN 1 END) * 100.0 / COUNT(*)), 2 ) AS Repair_Proportion FROM maintenance_logs WHERE Maintenance_Type = 'Repair';",
        "step": "【step1】: Calculate the average maintenance cost for all 'Repair' type records using a subquery:  `SELECT AVG(Cost) FROM maintenance_logs WHERE Maintenance_Type = 'Repair'`  【step2】: Count the total number of 'Repair' records and those with costs exceeding the calculated average:  `COUNT(*)` (total) and `COUNT(CASE WHEN Cost > [step1_result] THEN 1 END)` (high-cost count)  【step3】: Compute the proportion by dividing the high-cost count by the total count, multiply by 100, and round to 2 decimal places using `ROUND((high-cost_count * 100.0 / total), 2)`.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1175,
        "question": "Find all unreasonable maintenance records where the maintenance date is earlier than the printer installation date.",
        "query": "SELECT ml.* FROM maintenance_logs ml JOIN printers p ON ml.Printer_ID = p.Printer_ID WHERE ml.Maintenance_Date < p.Installation_Date;",
        "step": "【step1】: Join maintenance_logs with printers on Printer_ID to associate each maintenance record with its corresponding printer's details.  【step2】: Apply the filter condition where the maintenance date is earlier than the printer's installation date.  【step3】: Select all columns from the maintenance_logs table to display the identified unreasonable maintenance records.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1176,
        "question": "Retrieve maintenance records where the maintenance cost exceeds $10^18 and the next maintenance date is after the year 3000 AD (assuming no inflationary constraints on currency).",
        "query": "SELECT * FROM maintenance_logs WHERE Cost > 1e18 AND Next_Maintenance_Date > '3000-01-01';",
        "step": "【step1】: Access the 'maintenance_logs' table to retrieve all maintenance records.  【step2】: Filter records where the maintenance cost exceeds 1e18 dollars using the condition `Cost > 1e18`.  【step3】: Apply the second filter to include only records with `Next_Maintenance_Date` after the year 3000 using the condition `Next_Maintenance_Date > '3000-01-01'`.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1177,
        "question": "What is the total annual power consumption in kilowatt-hours for all printers produced by manufacturer ID MAN001, assuming each unit operates for 18 hours daily at 400 watts power consumption?",
        "query": "SELECT (400 * 18 * 365 / 1000) * Production_Volume_Total AS Total_Power_Consumption_kWh FROM manufacturers WHERE Manufacturer_ID = 'MAN001';",
        "step": "【step1】: Retrieve Production_Volume_Total from 'manufacturers' table for Manufacturer_ID='MAN001'  【step2】: Calculate single printer's annual consumption: (400W * 18h/day * 365d)/1000 = 2628kWh  【step3】: Multiply result by Production_Volume_Total (100,000 units) to get Total_Power_Consumption_kWh",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1178,
        "question": "A manufacturer has an annual revenue of $5 billion, R&D expenses of $800 million, and 10,000 employees. Calculate the per capita R&D expenditure and the R&D spending as a percentage of revenue.",
        "query": "SELECT R&D_Spending / Employee_Count AS Per_Capita_RD, (R&D_Spending / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND R&D_Spending = 800000000 AND Employee_Count = 10000;",
        "step": "【step1】: Filter manufacturer records with $5 billion revenue, $800 million R&D spending, and 10,000 employees  【step2】: Calculate per capita R&D expenditure by dividing R&D_Spending by Employee_Count  【step3】: Calculate R&D percentage by dividing R&D_Spending by Revenue and multiplying by 100",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1179,
        "question": "The manufacturer was founded in the year 1700 and has $500 million in R&D expenditure—is this reasonable?",
        "query": "SELECT Founded_Year, R&D_Spending, CASE WHEN Founded_Year < 1900 AND R&D_Spending > 500000000 THEN '不合理' ELSE '合理' END AS Validity FROM manufacturers WHERE Founded_Year = 1700 AND R&D_Spending = 500000000;",
        "step": "【step1】: Filter manufacturers table to find records where Founded_Year is 1700 and R&D_Spending equals $500 million using WHERE clause.  【step2】: Apply CASE logic to evaluate if manufacturers founded before 1900 (Year <1900) have R&D spending exceeding $500 million (R&D_Spending >500000000), marking as '不合理' when both conditions meet.  【step3】: Select and output Founded_Year, R&D_Spending values with validity assessment through the CASE expression as final result column Validity.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1180,
        "question": "Assuming a manufacturer has a profit margin of 200%, with an annual revenue of $5 billion, what is its profit? Is it possible?",
        "query": "SELECT `R&D_Spending` / Employee_Count AS Per_Capita_RD, (`R&D_Spending` / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND `R&D_Spending` = 800000000 AND Employee_Count = 10000;",
        "step": "【step1】: Retrieve all records from the 'manufacturers' table.  【step2】: Filter records where Revenue = $5B, R&D_Spending = $800M, and Employee_Count = 10,000.  【step3】: Calculate Per_Capita_RD (R&D_Spending/Employee_Count) and RD_Percentage ((R&D_Spending/Revenue)*100) for the filtered record(s).",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1181,
        "question": "List the top 3 manufacturers in ascending order of energy consumption per unit of production, calculated as total energy consumption divided by total production volume, where total energy consumption is computed as total production volume multiplied by 0.5 kilowatt-hours per unit.",
        "query": "SELECT Founded_Year, 'R&D_Spending', CASE WHEN Founded_Year < 1900 AND 'R&D_Spending' > 500000000 THEN '不合理' ELSE '合理' END AS Validity FROM manufacturers WHERE Founded_Year = 1700 AND 'R&D_Spending' = 500000000;",
        "step": "【step1】: Retrieve manufacturers' total production volume from the 'manufacturers' table and calculate total energy consumption (Production_Volume_Total * 0.5)  【step2】: Compute energy consumption ratio (total_energy_consumption / Production_Volume_Total) for each manufacturer  【step3】: Sort manufacturers by the computed ratio in ascending order and return the top 3 using LIMIT 3",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1182,
        "question": "Calculate the percentage of R&D spending relative to revenue for each manufacturer ( (R&D_Spending/Revenue)×100 ), and list the top 5 in descending order by percentage.",
        "query": "SELECT Name, (`R&D_Spending` / Revenue) * 100 AS R_D_Percent FROM manufacturers ORDER BY R_D_Percent DESC LIMIT 5;",
        "step": "【step1】: Retrieve manufacturer names and calculate R&D percentage by dividing R&D_Spending by Revenue then multiplying by 100  【step2】: Sort results in descending order based on calculated R_D_Percent  【step3】: Restrict output to top 5 records using LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1183,
        "question": "List manufacturers established before 1950 with profit margins exceeding 15%, sorted in ascending order by founding year.",
        "query": "SELECT Name, Founded_Year, Profit_Margin FROM manufacturers WHERE Founded_Year < 1950 AND Profit_Margin > 15 ORDER BY Founded_Year ASC;",
        "step": "【step1】: Filter manufacturers with founding year before 1950 using WHERE Founded_Year < 1950  【step2】: Apply profit margin filter by checking Profit_Margin > 15 (industry average threshold)  【step3】: Sort results chronologically using ORDER BY Founded_Year ASC",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1184,
        "question": "Assuming a manufacturer has an annual revenue of 1 trillion dollars with only 1 employee, calculate its per capita output (Revenue/Employee_Count), and list all manufacturers in descending order of per capita output.",
        "query": "SELECT Name, (Revenue / Employee_Count) AS Per_Capita_Output FROM manufacturers UNION ALL SELECT 'Hypothetical Manufacturer' AS Name, 1000000000000 / 1 AS Per_Capita_Output ORDER BY Per_Capita_Output DESC;",
        "step": "【step1】: Extract manufacturers' data with calculated per capita output:  SELECT Name, (Revenue / Employee_Count) AS Per_Capita_Output FROM manufacturers  【step2】: Append hypothetical manufacturer using UNION ALL:  UNION ALL  SELECT 'Hypothetical Manufacturer' AS Name, 1000000000000 / 1 AS Per_Capita_Output  【step3】: Sort combined results by descending per capita output:  ORDER BY Per_Capita_Output DESC;",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1185,
        "question": "Calculate the theoretical carbon emissions for each country's total production (assuming that producing one printer consumes 50 kilowatt-hours of electricity, and each kilowatt-hour generates 0.5 kilograms of carbon dioxide).",
        "query": "SELECT Country, SUM(Production_Volume_Total * 50 * 0.5) AS Total_Carbon_Emission FROM manufacturers GROUP BY Country;",
        "step": "【step1】: Extract production volume and country data from the manufacturers table  【step2】: Calculate carbon emission per manufacturer (Production_Volume_Total * 50 kWh * 0.5 kg/kWh)  【step3】: Aggregate results by Country using SUM() and finalize grouping",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1186,
        "question": "Calculate the comprehensive benefit index for each manufacturer, which is the product of R&D intensity (R&D spending divided by revenue) and profit margin (as a decimal), and count the number of manufacturers grouped by index value.",
        "query": "SELECT (R&D_Spending / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY Comprehensive_Index;",
        "step": "【step1】: Calculate comprehensive index for each manufacturer by multiplying R&D intensity (R&D_Spending/Revenue) and profit margin ratio (Profit_Margin/100)  【step2】: Group manufacturers by the computed Comprehensive_Index value  【step3】: Count number of manufacturers in each Comprehensive_Index group using COUNT(*)",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1187,
        "question": "Filter out manufacturers that were founded in 1973 or earlier but have a market capitalization less than twice their revenue, and then group by country to count the number of abnormal companies.",
        "query": "SELECT Country, COUNT(*) AS Abnormal_Company_Count FROM manufacturers WHERE Founded_Year <= 1973 AND Market_Cap < (Revenue * 2) GROUP BY Country;",
        "step": "【step1】: Filter manufacturers with founding year ≤ 1973 (over 50 years old)  【step2】: Apply additional filter where market cap is less than twice the annual revenue  【step3】: Group results by country and count abnormal companies per group",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1188,
        "question": "Assuming a certain manufacturer has a given R&D spending-to-revenue ratio and profit margin, how many manufacturers share the same comprehensive index value, which is calculated as (R&D_Spending / Revenue) * (Profit_Margin / 100)?",
        "query": "SELECT ('R&D_Spending' / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY Comprehensive_Index;",
        "step": "【step1】: Retrieve all records from 'manufacturers' table with necessary fields (R&D_Spending, Revenue, Profit_Margin)  【step2】: Calculate Comprehensive_Index for each manufacturer using formula (R&D_Spending/Revenue)*(Profit_Margin/100)  【step3】: Group manufacturers by calculated Comprehensive_Index values and count members in each group",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1189,
        "question": "Calculate the total theoretical annual power consumption (in kilowatt-hours) for all printers produced by each manufacturer, assuming that all printers operate 8 hours per day and run continuously throughout the year.",
        "query": "SELECT m.Name, (m.Production_Volume_Total * 300 * 8 * 365 / 1000) AS Total_Annual_Power_Consumption_kWh FROM manufacturers m GROUP BY m.Manufacturer_ID;",
        "step": "【step1】: Access manufacturers table and select manufacturer names and total production volume  【step2】: Apply power consumption calculation formula to each manufacturer's production volume  【step3】: Group results by manufacturer ID to aggregate total annual consumption per manufacturer",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1190,
        "question": "Calculate the difference between the proportion of R&D spending to revenue and the profit margin for each manufacturer, and filter out manufacturers with a difference greater than 10%.",
        "query": "SELECT m.Name, ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m HAVING Difference_Percentage > 10;",
        "step": "【step1】: Retrieve manufacturer names and calculate the percentage of R&D spending relative to revenue.  【step2】: Compute the absolute difference between the calculated R&D percentage and the declared profit margin.  【step3】: Apply a filter using HAVING clause to select manufacturers with the absolute difference exceeding 10 percentage points.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1191,
        "question": "Filter out manufacturers that have been established for more than 50 years but have fewer than 1000 employees.",
        "query": "SELECT Name, Founded_Year, Employee_Count FROM manufacturers WHERE (YEAR(CURDATE()) - Founded_Year) > 50 AND Employee_Count < 1000;",
        "step": "【step1】: Filter manufacturers by calculating operational duration using (YEAR(CURDATE()) - Founded_Year) to identify companies older than 50 years.  【step2】: Apply the Employee_Count < 1000 condition to exclude manufacturers with large workforces.  【step3】: Project the final result by selecting Name, Founded_Year, and Employee_Count for qualifying manufacturers.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1192,
        "question": "Identify manufacturers where the absolute difference between the percentage of R&D spending relative to revenue and the profit margin exceeds 10%.",
        "query": "SELECT m.Name, ABS(('m.RD_Spending' / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m HAVING Difference_Percentage > 10;",
        "step": "【step1】: Filter manufacturers where annual revenue (Revenue) exceeds 500 times their market capitalization (Market_Cap) using WHERE Revenue > (Market_Cap * 500).  【step2】: Calculate the difference percentage between R&D spending ratio (R&D_Spending/Revenue*100) and Profit_Margin using ABS((R&D_Spending/Revenue*100) - Profit_Margin) AS Difference_Percentage.  【step3】: Apply HAVING clause to retain only manufacturers with Difference_Percentage > 10 after grouping, then select Manufacturer name and the calculated metric.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1193,
        "question": "Assume a monochrome laser printer is handling a printing task of 500 pages, with a power consumption of 800 watts and a printing speed of 30 ppm (pages per minute). Calculate the total energy consumption (in kilowatt-hours) required to complete this task.",
        "query": "SELECT (Power_Consumption * (500 / (Print_Speed * 60)) / 1000) AS Total_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome' AND Power_Consumption = 800 AND Print_Speed = 30;",
        "step": "【step1】: Filter the printers table to select the laser monochrome printer with 800W power consumption and 30ppm speed using WHERE conditions (Type = 'Laser', Color_Support = 'Monochrome', Power_Consumption = 800, Print_Speed = 30).  【step2】: Calculate total printing time by dividing 500 pages by the printer's speed converted to pages per hour (30ppm * 60 = 1800 pages/hour).  【step3】: Compute energy consumption by multiplying power (800W) by time (500/1800 hours) then convert to kilowatt-hours via division by 1000.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1194,
        "question": "If all color printing tasks consume ink at a rate of 0.05 ml/page, and monochrome tasks at 0.02 ml/page. The current ink level is 60%, with a capacity of 100 ml. There are 2000 pages of color tasks and 5000 pages of monochrome tasks pending. Will the remaining ink be sufficient?",
        "query": "SELECT IF((2000*0.05 + 5000*0.02) <= (Capacity * (Current_Level/100)), '足够', '不足够') AS 是否足够 FROM consumables WHERE Type = 'Ink' AND Capacity = 100 AND Current_Level = 60;",
        "step": "【step1】: Filter consumables records where Type is 'Ink', Capacity is 100ml, and Current_Level is 60%  【step2】: Calculate total ink requirement (2000×0.05 + 5000×0.02=200ml) and available ink (100×60%=60ml)  【step3】: Use IF() to compare 200ml vs 60ml and return '足够'/'不足够' judgment",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1195,
        "question": "A user submitted a 7-page double-sided printing job, and the paper tray capacity is 250 sheets. How many sheets of paper are actually consumed?",
        "query": "SELECT CEIL(7 / 2) AS Actual_Sheets FROM print_jobs WHERE Duplex = 1 AND Page_Count = 7;",
        "step": "【step1】: Filter print_jobs entries where Duplex=1 (indicating duplex printing) and Page_Count=7.  【step2】: Calculate the required sheets by dividing 7 by 2 and applying CEIL to handle odd page counts.  【step3】: Output the result as Actual_Sheets, representing the minimum physical sheets consumed.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1196,
        "question": "If a 3D printing job requires continuously printing 10^18 sheets of paper (each 0.1 mm thick) using a printer with a 500-sheet tray capacity and automatic paper replenishment every hour, how many years would it theoretically take to complete?",
        "query": "SELECT (POWER(10, 18) * 0.1 / 1000) / (500 * 0.1 / 1000 * 24 * 365) AS Years FROM printers WHERE Type = '3D' AND Tray_Capacity = 500;",
        "step": "【step1】: Calculate total paper thickness in meters: POWER(10,18) pages * 0.1mm/page / 1000 (convert mm to m)  【step2】: Compute annual processing capacity: (500 sheets * 0.1mm/sheet / 1000) * 24 hours/day * 365 days (hourly refill)  【step3】: Divide total thickness by annual capacity to get years, filtered by Type='3D' AND Tray_Capacity=500 in printers table",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1197,
        "question": "Calculate the total energy consumption (in joules) for each laser printer model when completing all print tasks, and rank the top 5 printer models in descending order of energy consumption.",
        "query": "SELECT p.Model, SUM((j.Page_Count / CAST(SUBSTRING_INDEX(p.Print_Speed, 'ppm', 1) AS UNSIGNED)) * 60 * p.Power_Consumption * 1000) AS Total_Energy FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE p.Type = 'Laser' GROUP BY p.Model ORDER BY Total_Energy DESC LIMIT 5;",
        "step": "【step1】: Filter laser printers and join with print_jobs using Printer_ID to get required operational data  【step2】: Calculate energy consumption per job using (Page_Count ÷ Print_Speed)*60*Power_Consumption*1000 formula, then aggregate by Model  【step3】: Group results by Model, sort by Total_Energy descending, and limit to top 5 entries",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1198,
        "question": "Statistics on the proportion of total ink cost consumed by color printing tasks, requiring the output of the top 3 consumable models with the highest color to monochrome task ink cost ratio.",
        "query": "SELECT c.Model, (SUM(CASE WHEN j.Color_Usage = 'Color' THEN j.Page_Count * 3 * (c.Cost/c.Capacity) ELSE 0 END) / SUM(CASE WHEN j.Color_Usage = 'Monochrome' THEN j.Page_Count * (c.Cost/c.Capacity) ELSE 0 END)) AS Cost_Ratio FROM consumables c JOIN print_jobs j ON c.Printer_ID = j.Printer_ID WHERE c.Type = 'Ink' GROUP BY c.Model HAVING Cost_Ratio IS NOT NULL ORDER BY Cost_Ratio DESC LIMIT 3;",
        "step": "【step1】: Join consumables and print_jobs tables by Printer_ID, filter ink-type consumables.  【step2】: Calculate color/monochrome cost ratio per model using conditional aggregation (3x multiplier for color page cost).  【step3】: Sort by descending cost ratio, filter non-null ratios, limit to top 3 models.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1199,
        "question": "Find the top 10 users who saved the most paper by using duplex printing (Duplex=1), sorted in descending order by the amount saved.",
        "query": "SELECT u.Name, SUM(j.Page_Count * 0.5) AS Saved_Paper FROM users u JOIN print_jobs j ON u.User_ID = j.User_ID WHERE j.Duplex = 1 GROUP BY u.User_ID ORDER BY Saved_Paper DESC LIMIT 10;",
        "step": "【step1】: Join users and print_jobs tables on User_ID, filtering print jobs with Duplex=1.  【step2】: Group by User_ID and calculate total saved paper per user using SUM(Page_Count * 0.5).  【step3】: Order results by Saved_Paper in descending order, limit to top 10.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1200,
        "question": "Assuming a print job contains 1,000,000,000 pages and requires continuous printing, calculate the theoretical completion time (in years) under the nominal print speed, and retrieve the top 5 models ranked by the longest completion time.",
        "query": "SELECT Model, (1000000000 / CAST(SUBSTRING_INDEX(Print_Speed, 'ppm', 1) AS UNSIGNED)) / 525600 AS Years FROM printers ORDER BY Years DESC LIMIT 5;",
        "step": "【step1】: Extract the numerical print speed value by removing 'ppm' suffix from the Print_Speed field using SUBSTRING_INDEX(Print_Speed, 'ppm', 1)  【step2】: Calculate theoretical time in years by dividing 1,000,000,000 pages by extracted speed (pages per minute), then converting total minutes to years via division by 525600 (60*24*365)  【step3】: Sort results in descending order by calculated Years and limit output to top 5 slowest models",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1201,
        "question": "Assuming all printing tasks use A4 paper (210mm × 297mm, 80g/m²), group statistics by paper size to calculate the total paper mass consumed for each size of printing task (unit: kilogram)?",
        "query": "SELECT Paper_Size, SUM(Page_Count * 80 * 0.06237 * (CASE WHEN Duplex=1 THEN 0.5 ELSE 1 END)) / 1000 AS Total_Mass_Kg FROM print_jobs GROUP BY Paper_Size;",
        "step": "【step1】: Calculate per-job paper consumption adjusted for duplex printing using CASE to apply 50% page reduction for duplex jobs.  【step2】: Compute total mass per job by multiplying adjusted page count (from step1) with paper weight factors (80g/m² × 0.06237m²/A4 sheet).  【step3】: Group results by Paper_Size and aggregate total mass across all jobs, converting grams to kilograms via division by 1000.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1202,
        "question": "Group by double-sided printing mode and calculate the total number of physical paper sheets saved for all print jobs (assuming single-sided printing as the standard baseline)?",
        "query": "SELECT Duplex, SUM(Page_Count) - SUM(CEIL(Page_Count/(CASE WHEN Duplex=1 THEN 2 ELSE 1 END))) AS Saved_Pages FROM print_jobs GROUP BY Duplex;",
        "step": "【step1】: Group print_jobs by Duplex mode to separate tasks into duplex (1) and non-duplex (0) categories.  【step2】: For each group, calculate the theoretical pages (Page_Count) and actual paper usage using CASE to determine if duplexing reduces sheets (Page_Count/2 with CEIL for duplex=1, else Page_Count).  【step3】: Compute Saved_Pages by subtracting total actual paper usage from total Page_Count, then aggregate results by Duplex group.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1203,
        "question": "Group print jobs by color usage and calculate the total consumption ratio, where color printing consumes 3 times more consumables than monochrome printing?",
        "query": "SELECT Color_Usage, SUM(Page_Count * (CASE WHEN Color_Usage='Color' THEN 3 ELSE 1 END)) AS Consumption_Ratio FROM print_jobs GROUP BY Color_Usage;",
        "step": "【step1】: Group the print jobs by Color_Usage (Color/Monochrome).  【step2】: For each group, calculate the adjusted page count by multiplying Page_Count by 3 for Color jobs and 1 for Monochrome jobs using a CASE expression.  【step3】: Sum the adjusted page counts within each group to derive the total consumption ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1204,
        "question": "Assuming there is a printing task with Page_Count=100,000,000 pages, calculate whether the system might crash (when the total physical sheet count exceeds the INT maximum value of 2147483647) for both duplex and non-duplex printing modes?",
        "query": "SELECT Duplex, CASE WHEN CEIL(100000000/(CASE WHEN Duplex=1 THEN 2 ELSE 1 END)) > 2147483647 THEN 1 ELSE 0 END AS Crash_Condition FROM (SELECT 0 AS Duplex UNION SELECT 1) AS modes;",
        "step": "【step1】: Generate all possible duplex modes (0 for single-sided, 1 for duplex) via subquery  【step2】: Calculate required physical sheets using CEIL(100000000/(2 if duplex else 1))  【step3】: Check overflow by comparing with 2147483647 using CASE conditional logic",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1205,
        "question": "Identify all print jobs where the total power consumption from printing exceeds 10% of the printer's rated power consumption, assuming all papers are A4 size (80 grams per square meter).",
        "query": "SELECT pj.* FROM print_jobs pj JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pj.Paper_Size = 'A4' AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(REGEXP_REPLACE(pr.Print_Speed, '^0-9', '', 'g') AS INTEGER), 0))) > (pr.Power_Consumption * 0.1);",
        "step": "【step1】: Join print_jobs with printers using Printer_ID and filter A4 paper tasks.  【step2】: Extract numerical Print_Speed values using REGEXP_REPLACE and handle division safety with NULLIF.  【step3】: Calculate paper-weight-induced power consumption and compare against 10% of the printer’s rated power.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1206,
        "question": "Calculate the total ink cost for color print jobs based on page count and ink cost per page, where the cost is derived from the consumable cost divided by 250 pages.",
        "query": "SELECT pj.Job_ID, pj.Page_Count * 0.05 * (c.Cost / 250) AS Total_Ink_Cost FROM print_jobs pj JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE pj.Color_Usage = 'Color' AND c.Type = 'Ink';",
        "step": "【step1】: Filter color print jobs and corresponding ink consumables using JOIN on Printer_ID with WHERE clauses (Color_Usage='Color' AND Type='Ink')  【step2】: Calculate per-page ink volume (0.05ml/page) and derive cost per milliliter using ink cost divided by 250ml capacity (implied from Cost/250)  【step3】: Multiply page count × ink volume × per-ml cost to compute Total_Ink_Cost for each job",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1207,
        "question": "Filter all duplex printing tasks on A4 paper where the calculated energy cost per page exceeds 10% of the printer's power consumption.",
        "query": "SELECT pj.* FROM print_jobs pj JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pj.Paper_Size = 'A4' AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(REGEXP_SUBSTR(pr.Print_Speed, '[0-9]+') AS UNSIGNED), 0))) > (pr.Power_Consumption * 0.1);",
        "step": "【step1】: Join print_jobs and printers tables using Printer_ID, filter A4 paper size and duplex printing (pj.Duplex=1).  【step2】: Calculate actual paper consumption using formula: (Page_Count * 4.9896 * POWER(2, Duplex) * 9.8 * 0.1) / (Page_Count / parsed Print_Speed value).  【step3】: Compare calculated consumption against 80% of Tray_Capacity (pr.Tray_Capacity * 0.8) using Power_Consumption*0.1 as threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1208,
        "question": "Find all print jobs with more than 1 billion pages, assuming a thickness of 0.1 millimeters per page, and determine whether the stacked paper height exceeds 8,848 meters.",
        "query": "SELECT * FROM print_jobs WHERE Page_Count > 8848000000 / (0.1 * 0.001);",
        "step": "【step1】: Calculate the threshold page count that would exceed Mount Everest's height by converting 8848 meters to millimeters (8848*1000=8,848,000mm), then divide by per-page thickness (0.1mm) to get 88,480,000 pages.  【step2】: Implement the calculation directly in the WHERE clause using 8848000000/(0.1*0.001) to dynamically derive the threshold (8848 meters converted to 8,848,000,000mm due to unit scaling).  【step3】: Filter print_jobs records where Page_Count exceeds the calculated threshold, ensuring only tasks with stacked paper height surpassing Mount Everest are selected.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1209,
        "question": "A certain laser printer has a power consumption of 50 watts in standby mode and 800 watts during operation. If the printer operates for 4 hours a day and remains in standby for 20 hours, calculate the total power consumption for one month (30 days) in kilowatt-hours (kWh).",
        "query": "SELECT ((800 * 4 + 50 * 20) * 30) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser' LIMIT 1;",
        "step": "【step1】: Filter laser printers using WHERE Type = 'Laser'  【step2】: Calculate daily energy consumption: (800W * 4h + 50W * 20h)  【step3】: Multiply by 30 days and convert to kilowatt-hours: ((result) * 30) / 1000",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1210,
        "question": "A certain model of toner has a capacity of 5,000 pages and currently has a 30% remaining level. The user performs three consecutive print jobs: Job 1 is a 1,200-page monochrome document, Job 2 is an 800-page color chart (with 40% color content calculated as 2.5× toner usage and 60% monochrome), and Job 3 is a 500-page double-sided manual (with toner usage calculated at 50% of total pages). Assuming color printing consumes 2.5 times more toner than monochrome printing, calculate the final remaining capacity percentage.",
        "query": "SELECT ((5000 * 0.3 - (1200 * 1 + (800 * 0.4 * 2.5 + 800 * 0.6 * 1) + (500 * 0.5))) / 5000 * 100) AS Remaining_Percent FROM consumables WHERE Type = 'Toner' AND Model = '某型号';",
        "step": "【step1】: Calculate initial remaining capacity (5000 * 30%)  【step2】: Calculate total consumption:  - Task1: 1200×1 (monochrome multiplier)  - Task2: (800×40%×2.5) + (800×60%×1) (color/grayscale split)  - Task3: 500×50% (duplex adjustment)  【step3】: Compute final percentage:  ((Initial_remaining - Total_consumption)/5000)×100  Filtered by consumables.Type='Toner' AND Model='某型号' via WHERE clause",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1211,
        "question": "A department has a monthly average printing volume of 20,000 pages, using a drum unit with a capacity of 5,000 pages. The cost of replacing the drum unit is $200 per unit, and maintenance records show that for every 200,000 pages printed, a $500 fuser needs to be replaced. Calculate the annual consumables budget.",
        "query": "WITH drum_cost AS (SELECT Cost FROM consumables WHERE Type = 'Drum' LIMIT 1), fuser_cost AS (SELECT Cost FROM consumables WHERE Type = 'Fuser' LIMIT 1) SELECT (200 * 48 + 500 * 16) AS Annual_Budget FROM drum_cost, fuser_cost;",
        "step": "【step1】: Retrieve drum component replacement cost per unit ($200) from consumables table  【step2】: Retrieve fuser replacement cost per unit ($500) from consumables table  【step3】: Calculate annual budget by multiplying drum replacements (48/year) and fuser replacements (16/year) with respective costs, then sum results",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1212,
        "question": "Assuming a 3D printer operates continuously for 100 years without interruption, with each print task taking 5 minutes, and preventive maintenance costing $1,500 is required every 1,000 hours, calculate: (a) the theoretical maximum number of tasks, (b) the total maintenance cost (without considering inflation), and (c) the total weight of consumables used (assuming each task consumes 0.2 kg of material).",
        "query": "SELECT (100 * 365 * 24 * 60 / 5) AS Max_Tasks, (100 * 365 * 24 / 1000) * 1500 AS Maintenance_Cost, (100 * 365 * 24 * 60 / 5) * 0.2 AS Total_Weight FROM printers WHERE Type = '3D' LIMIT 1;",
        "step": "【step1】: Calculate theoretical maximum tasks by converting 100 years to total minutes and dividing by print duration per task (5 minutes).  【step2】: Determine maintenance cost by calculating total operating hours over 100 years, dividing by maintenance frequency (1000 hours), and multiplying by $1500 per maintenance cycle.  【step3】: Compute total material weight by multiplying the maximum task count (from step1) by per-task material consumption (0.2kg).",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1213,
        "question": "Find the top three laser printers installed in the past year with the highest total power consumption (in kilowatt-hours), and calculate their total power consumption (assuming continuous operation since installation).",
        "query": "SELECT Printer_ID, Model, (Power_Consumption * DATEDIFF(CURRENT_DATE, Installation_Date) * 24) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser' AND Installation_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) ORDER BY Total_kWh DESC LIMIT 3;",
        "step": "【step1】: Filter laser printers installed within the past year using WHERE clause on Type='Laser' and Installation_Date range  【step2】: Calculate total power consumption (kW·h) for each qualified printer by multiplying Power_Consumption(W) × operation days × 24 hours/day ÷ 1000  【step3】: Order results by Total_kWh descending and select top 3 records using ORDER BY and LIMIT clauses",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1214,
        "question": "List the names and profit margins of manufacturers with a profit margin lower than 15% and with more than 10,000 employees, sorted by profit margin in ascending order.",
        "query": "SELECT m.Name, m.Profit_Margin FROM manufacturers m WHERE m.Profit_Margin < 15 AND m.Employee_Count > 10000 ORDER BY m.Profit_Margin ASC;",
        "step": "【step1】: Filter manufacturers with profit margin below 15% and employee count over 10,000 using WHERE clause.  【step2】: Select only manufacturer Name and Profit_Margin fields from the filtered results.  【step3】: Sort the final output by Profit_Margin in ascending order with ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1215,
        "question": "List toner supplies with a current remaining level below 20 that have not been replaced for over 90 days, sorted in ascending order by the current level.",
        "query": "SELECT Consumable_ID, Printer_ID, Current_Level, Last_Replacement_Date FROM consumables WHERE Type = 'Toner' AND Current_Level < 20 AND DATEDIFF(CURRENT_DATE, Last_Replacement_Date) > 90 ORDER BY Current_Level ASC;",
        "step": "【step1】: Filter consumables where type is 'Toner' using `WHERE Type = 'Toner'` to isolate toner-related records.  【step2】: Apply dual conditions: check for current levels below 20% (`Current_Level < 20`) and last replacement exceeding 90 days (`DATEDIFF(CURRENT_DATE, Last_Replacement_Date) > 90`) to identify overdue low-toner items.  【step3】: Sort results by ascending current level using `ORDER BY Current_Level ASC` to prioritize critically low items.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1216,
        "question": "Assuming a user submits a double-sided printing job requiring 100 million pages to be printed on one side, calculate the theoretical amount of paper saved (measured in tons) by printing double-sided instead of single-sided, given that each sheet of paper weighs 4.5 grams, and sort the results in descending order of the savings (even if the data exceeds practical system limits).",
        "query": "SELECT (100000000 / 2) AS Saved_Pages, ((100000000 / 2) * 4.5) / 1000000 AS Saved_Weight_Tons ORDER BY Saved_Weight_Tons DESC;",
        "step": "【step1】: Calculate saved pages by halving the total page count (100,000,000 / 2) to account for duplex printing.  【step2】: Convert saved pages to weight in tons by multiplying by 4.5 grams per sheet and dividing by 1,000,000 to convert grams to metric tons.  【step3】: Order the result by the calculated Saved_Weight_Tons in descending order, even though only one row is returned.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1217,
        "question": "Assuming a certain laser printer (Type='laser') has a power consumption of 800 watts, if the printer operates continuously for 24 hours with an average duty cycle of 65% per hour for printing tasks during that period, calculate its total energy consumption (in kilowatt-hours) and output the results grouped by Printer_ID.",
        "query": "SELECT Printer_ID, (Power_Consumption * 24 * 0.65 / 1000) AS Total_Energy_kWh FROM printers WHERE Type = '激光' GROUP BY Printer_ID;",
        "step": "【step1】: Filter laser printers using WHERE clause to select only records where Type='激光'  【step2】: Calculate energy consumption with formula (Power_Consumption * 24 * 0.65 / 1000) and alias as Total_Energy_kWh  【step3】: Group results by Printer_ID to ensure output aligns with printer-specific records",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1218,
        "question": "If a toner (Type=toner) model has a capacity of 5,000 pages and currently has 25% remaining, and it is known that the printer has completed print jobs totaling 3,800 pages in the past 30 days, where each page consumes supplies at a rate equivalent to 3 monochrome pages per page, calculate the remaining usable days of the consumable and output the results grouped by consumable model.",
        "query": "SELECT c.Model, (c.Capacity * (c.Current_Level / 100) / 3) / (SUM(p.Page_Count * 3) / 30) AS Remaining_Days FROM consumables c JOIN printers pr ON c.Printer_ID = pr.Printer_ID JOIN print_jobs p ON pr.Printer_ID = p.Printer_ID WHERE c.Type = '碳粉' AND p.Job_Date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY) GROUP BY c.Model;",
        "step": "【step1】: Filter consumables with Type='Toner' and join printers/print_jobs to get relevant print job data from the past 30 days.  【step2】: Calculate equivalent page consumption (treating color pages as 3x monochrome) by summing 3*Page_Count, then compute daily average consumption.  【step3】: Divide remaining capacity (Capacity*Current_Level/100 divided by 3 to account for color multiplier) by daily consumption rate to get Remaining_Days, grouped by Model.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1219,
        "question": "Users from a certain department (Department=Sales Department) completed duplex printing tasks (Duplex=1) in Q4 2023. Calculate the number of sheets of paper saved compared to if all tasks had been printed in single-sided mode, and output the results grouped by user department.",
        "query": "SELECT u.Department, SUM(p.Page_Count - CEIL(p.Page_Count / 2)) AS Saved_Papers FROM print_jobs p JOIN users u ON p.User_ID = u.User_ID WHERE u.Department = '销售部' AND p.Duplex = 1 AND YEAR(p.Job_Date) = 2023 AND QUARTER(p.Job_Date) = 4 GROUP BY u.Department;",
        "step": "【step1】: Perform INNER JOIN between `print_jobs` and `users` tables using `User_ID` to associate print jobs with department information  【step2】: Filter records where `Department='销售部'`, `Duplex=1`, and `Job_Date` falls in 2023 Q4 using `YEAR()` and `QUARTER()` functions  【step3】: Calculate paper savings per department using formula `Page_Count - CEIL(Page_Count/2)` to account for duplex efficiency, then aggregate results with `SUM()` and group by `Department`",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1220,
        "question": "Assume a 3D printer (Type=3D) has its material capacity incorrectly configured as 1×10^18 units, with a current remaining capacity of 0.1%. If it consumes 1 unit per second without interruption based on the past 30 days of print jobs, calculate how many universe ages (current universe age ≈1.38×10^10 years) are required to exhaust the material, and output the results grouped by Printer_ID.",
        "query": "SELECT c.Model, (c.Capacity * (c.Current_Level / 100) / 3) / (SUM(p.Page_Count * 3) / 30) AS Remaining_Days FROM consumables c JOIN printers pr ON c.Printer_ID = pr.Printer_ID JOIN print_jobs p ON pr.Printer_ID = p.Printer_ID WHERE c.Type = '碳粉' AND p.Job_Date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY) GROUP BY c.Model, c.Capacity, c.Current_Level;",
        "step": "【step1】: Filter 3D printers with misconfigured capacity (1e18 pages) and 0.1% remaining by joining consumables and printers tables using WHERE printers.Type='3D' AND consumables.Capacity=1e18 AND consumables.Current_Level=0.1  【step2】: Calculate total printable seconds: (1e18 * 0.1%) / 1 page-per-second = 1e15 seconds  【step3】: Convert seconds to universe ages: (1e15 / 31557600 sec/year) / 1.38e10 years per universe age, then GROUP BY Printer_ID",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1221,
        "question": "Calculate the total energy consumption (in kilowatt-hours) of a laser printer after operating continuously for 24 hours, given that its power consumption is 800 watts, and each print job starts with an additional 20% instantaneous power surge lasting 5 seconds.",
        "query": "SELECT Printer_ID, ((Power_Consumption * (86400 - 5) + Power_Consumption * 1.2 * 5) / 1000) AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Power_Consumption = 800;",
        "step": "【step1】: Filter printers where Type is 'Laser' and Power_Consumption is 800.  【step2】: Calculate base energy consumption for 86395 seconds (86400 total - 5 seconds).  【step3】: Add 5-second boosted consumption (20% extra power), sum both values, and convert to kWh by dividing by 1000.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1222,
        "question": "Calculate the composite value for each printer in a certain department, which is the product of (printer weight plus tray capacity multiplied by 365 multiplied by 0.0045) and (current year minus printer year).",
        "query": "SELECT p.Printer_ID, (p.Weight + (p.Tray_Capacity * 365 * 0.0045)) * (YEAR(CURDATE()) - p.Year) AS Composite_Value FROM printers p WHERE p.Printer_ID IN (SELECT DISTINCT j.Printer_ID FROM print_jobs j JOIN users u ON j.User_ID = u.User_ID WHERE u.Department = '某部门');",
        "step": "【step1】: Retrieve Printer_IDs associated with '某部门' through print_jobs and users tables using a subquery  【step2】: Calculate annual paper weight (Tray_Capacity × 365 × 0.0045) and combine with device Weight  【step3】: Multiply composite weight (device + annual paper) by years since production (CURDATE() - Year) for final Composite_Value",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1223,
        "question": "Identify printers that have never been used by any user whose department name contains the printer's location.",
        "query": "SELECT p.Printer_ID, p.Location FROM printers p WHERE NOT EXISTS (SELECT 1 FROM print_jobs j JOIN users u ON j.User_ID = u.User_ID WHERE j.Printer_ID = p.Printer_ID AND LOCATE(LOWER(u.Department), LOWER(p.Location)) > 0);",
        "step": "【step1】: Retrieve all printers with their associated print jobs and user departments from printers, print_jobs, and users tables using JOIN operations  【step2】: Check for department-location keyword matches using LOWER() and LOCATE() functions to compare users.Department and printers.Location case-insensitively  【step3】: Filter out matched records using NOT EXISTS clause to return printers with no departmental keyword matches in their locations",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1224,
        "question": "Assuming the existence of an industrial printer with a power consumption of 100 million watts, operating continuously for 100 years, calculate its total energy consumption equivalent to how many Moon mass-energy conversions (based on E=mc², with the Moon's mass being 7.342×10²² kg).",
        "query": "SELECT ((1e8 * 100 * 365 * 24 * 3600) / (POWER(3e8, 2))) / 7.342e22 AS Equivalent_Moon_Masses;",
        "step": "【step1】: Calculate total energy consumption over 100 years: 1e8 watts * (100 years * 365 days/year * 24 hours/day * 3600 seconds/hour)  【step2】: Convert energy to mass via E=mc²: Divide step1 result by (3e8 m/s)² to get equivalent mass in kg  【step3】: Calculate moon energy equivalents: Divide step2 result by lunar mass (7.342e22 kg) to get final ratio",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1225,
        "question": "Calculate the total energy (in kilowatt-hours) consumed by laser printers with maximum resolution, accounting for a base power consumption and an additional 200 watts for a 15-minute warm-up period.",
        "query": "SELECT (Power_Consumption * 23.75 + 200 * 0.25) / 1000 AS Total_Energy_KWh FROM printers WHERE Type = 'Laser' AND Max_Resolution = '最大分辨率值';",
        "step": "【step1】: Filter the 'printers' table to find laser printers with maximum resolution.  【step2】: Calculate energy consumption for 23.75 hours (800W × 23.75h) and preheating phase (200W × 0.25h).  【step3】: Sum both phases' energy and convert to kilowatt-hours (divide by 1000).",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1226,
        "question": "Calculate the R&D intensity (ratio of R&D spending to revenue) for the top 3 manufacturers by total production volume, with results rounded to four decimal places, limited to manufacturers founded before 2019.",
        "query": "SELECT Name, ROUND((SUM(RD_Spending) / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;",
        "step": "【step1】: Filter manufacturers founded before 2019 using WHERE Founded_Year < 2019 to ensure at least 5 years of potential data.  【step2】: Aggregate R&D_Spending and Revenue per manufacturer via GROUP BY Manufacturer_ID, then calculate RD_Intensity as (SUM(R&D_Spending)/SUM(Revenue))*100 rounded to 4 decimal places.  【step3】: Order results by Market_Cap proxy (Production_Volume_Total) DESC and limit to top 3 manufacturers with LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1227,
        "question": "Determine whether the paper saving rate of duplex printing mode for A4 paper complies with industry standards, specifically if the calculated rate is between 45% and 47.5%.",
        "query": "SELECT CASE WHEN (SUM(Page_Count * 2 - Page_Count) / SUM(Page_Count * 2) * 100) BETWEEN 45 AND 47.5 THEN '符合' ELSE '不符合' END AS Compliance FROM print_jobs WHERE Duplex = 1 AND Paper_Size = 'A4';",
        "step": "【step1】: Filter all A4 duplex print jobs by applying WHERE Duplex = 1 AND Paper_Size = 'A4'  【step2】: Calculate total saved pages (Page_Count*2 - Page_Count) and total theoretical pages (Page_Count*2) using SUM aggregation  【step3】: Compute saving percentage via (saved/total)*100 and determine compliance with CASE WHEN against the 45-47.5% range",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1228,
        "question": "Calculate the top 3 manufacturers (founded before 2019) by production volume, showing their names and R&D intensity (R&D spending as a percentage of revenue).",
        "query": "SELECT Name, ROUND((SUM('RD_Spending') / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;",
        "step": "【step1】: Filter manufacturers founded before 2019 using WHERE Founded_Year < 2019  【step2】: Calculate R&D Intensity by grouping Manufacturer_ID, summing R&D_Spending and Revenue, then computing (ΣR&D/ΣRevenue)*100 rounded to 4 decimals  【step3】: Order results by Production_Volume_Total descending and keep top 3 records using ORDER BY...LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1229,
        "question": "Calculate the total energy consumption (in kilowatt-hours) for administrator users (Role='Admin') using laser printers (Type='Laser'), and list the top 3 users with the highest total energy consumption in descending order.",
        "query": "SELECT users.User_ID, SUM(printers.Power_Consumption / 1000 * 24) AS total_energy_kWh FROM users JOIN print_jobs ON users.User_ID = print_jobs.User_ID JOIN printers ON print_jobs.Printer_ID = printers.Printer_ID WHERE users.Role = 'Admin' AND printers.Type = 'Laser' GROUP BY users.User_ID ORDER BY total_energy_kWh DESC LIMIT 3;",
        "step": "【step1】: Join users, print_jobs, and printers tables while filtering users.Role='Admin' and printers.Type='Laser'  【step2】: Calculate total energy consumption per user using (Power_Consumption/1000)*24 aggregation  【step3】: Sort results by total_energy_kWh in descending order and limit to top 3 records",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1230,
        "question": "Statistics the ratio of the total number of monochrome prints (Color_Usage='Monochrome') to the total number of color prints (Color_Usage='Color') for users in each department (Department), and sort the top 5 departments by this ratio in ascending order.",
        "query": "SELECT u.Department, (SUM(CASE WHEN pj.Color_Usage = 'Monochrome' THEN pj.Page_Count ELSE 0 END) * 1.0 / SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END)) AS ratio FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Color_Usage IN ('Monochrome', 'Color') GROUP BY u.Department HAVING SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END) > 0 ORDER BY ratio ASC LIMIT 5;",
        "step": "【step1】: Join the 'users' and 'print_jobs' tables via User_ID, filtering records where Color_Usage is either 'Monochrome' or 'Color'.  【step2】: Group by Department, calculate the sum ratio of monochrome pages to color pages using conditional aggregation, while excluding departments with zero color page totals via HAVING clause.  【step3】: Sort departments by the calculated ratio in ascending order and limit results to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1231,
        "question": "Find records where the user role is Guest (Role='Guest') but the number of pages printed per session exceeds 50, and sort the top 10 by page count in descending order.",
        "query": "SELECT u.*, pj.* FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE u.Role = 'Guest' AND pj.Page_Count > 50 ORDER BY pj.Page_Count DESC LIMIT 10;",
        "step": "【step1】: Perform INNER JOIN between users and print_jobs tables using User_ID to combine user information with their print job records. Apply WHERE clause filtering for Role='Guest' and Page_Count >50.  【step2】: Sort the merged results in descending order by Page_Count to prioritize high-volume print jobs.  【step3】: Apply LIMIT 10 to retrieve only the top 10 records meeting all criteria, ensuring result relevance and performance optimization.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1232,
        "question": "Assuming there are users who have print jobs with a page count of at least 1,000,000 (normal value <1,000 pages), please query the department distribution of these users and rank the top 5 departments in descending order by the total page count.",
        "query": "SELECT u.Department, SUM(pj.Page_Count) AS total_pages FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Page_Count >= 1000000 GROUP BY u.Department ORDER BY total_pages DESC LIMIT 5;",
        "step": "【step1】: Join the 'users' and 'print_jobs' tables using User_ID, filtering by Page_Count >= 1000000 to identify excessive single-day tasks.  【step2】: Group the results by Department and calculate the total_pages with SUM(pj.Page_Count).  【step3】: Sort departments by total_pages in descending order and limit output to the top 5.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1233,
        "question": "Calculate the total energy consumption (in kilowatt-hours) of print jobs completed by users in each department.",
        "query": "SELECT u.Department, SUM((p.Page_Count / (1 + p.Duplex) / pr.Print_Speed / 60) * (pr.Power_Consumption / 1000)) AS Total_Energy_kWh FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Department;",
        "step": "【step1】: Join 'users', 'print_jobs', and 'printers' tables to link department information with printing parameters (pages, duplex, speed, power).  【step2】: Calculate energy consumption per job: ((Page_Count / (1+Duplex)) / Print_Speed / 60) converts pages to operational hours, multiplied by (Power_Consumption/1000) converts watts to kilowatts.  【step3】: Group results by Department and aggregate using SUM() to get total energy consumption per department.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1234,
        "question": "Statistics the average time (in seconds) per page for printing tasks by different user roles (Role).",
        "query": "SELECT u.Role, SUM(p.Page_Count * (CASE WHEN p.Color_Usage = 'Color' THEN 1.2 ELSE 1 END) / pr.Print_Speed * 60) / SUM(p.Page_Count) AS Avg_Time_Per_Page FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Role ORDER BY Avg_Time_Per_Page;",
        "step": "【step1】: Join users, print_jobs, and printers tables to combine role information with page counts and printer speed data.  【step2】: Calculate adjusted page counts (color pages weighted 1.2x), total page time per job via (pages × adjustment / print_speed × 60), then compute weighted average per role.  【step3】: Group results by Role, calculate final Avg_Time_Per_Page by dividing total time by total pages, then order by average time.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1235,
        "question": "Analyze the most commonly used paper size (Paper_Size) among users in each department.",
        "query": "SELECT u.Department, p.Paper_Size, COUNT(*) AS Usage_Count FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID GROUP BY u.Department, p.Paper_Size ORDER BY u.Department, Usage_Count DESC;",
        "step": "【step1】: Join users and print_jobs tables via User_ID to associate departments with paper sizes  【step2】: Group records by Department and Paper_Size, count occurrences for each combination  【step3】: Sort results primarily by Department, secondarily by Usage_Count descending to show highest usage first",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1236,
        "question": "Calculate the ink consumption and replacement frequency for a 10,000,000-page full-color duplex printing task.",
        "query": "SELECT 10000000 * 0.05 * 2 AS Total_Ink_ml, CEIL((10000000 * 0.05 * 2) / 500) AS Replacement_Count;",
        "step": "【step1】: Retrieve fixed ink consumption parameters (0.05ml/page for color, 2x duplex multiplier)  【step2】: Calculate total ink consumption: 10,000,000 pages × 0.05ml × 2 = 1,000,000ml  【step3】: Compute cartridge replacements: CEIL(1,000,000ml / 500ml capacity) = 2000 times",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1237,
        "question": "Find all users whose cumulative print tasks, when adjusted for printer power consumption and speed, result in energy usage exceeding 10 times the printer's rated power, and whose printers have no maintenance records.",
        "query": "SELECT u.User_ID, u.Name FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pr.Power_Consumption * 1.2 * SUM(pj.Page_Count) / pr.Print_Speed > pr.Power_Consumption * 10 AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = pr.Printer_ID) GROUP BY u.User_ID, u.Name HAVING SUM(pj.Page_Count) > 0;",
        "step": "【step1】: Join users, print_jobs, and printers tables to link user details with their print jobs and corresponding printer specifications.  【step2】: Apply energy consumption calculation (pr.Power_Consumption * 1.2 * SUM(pj.Page_Count) / pr.Print_Speed) and filter printers with no maintenance records using the NOT EXISTS subquery against maintenance_logs.  【step3】: Group results by user, enforce SUM(pj.Page_Count) > 0 via HAVING, and return users exceeding the 10x power consumption threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1238,
        "question": "Calculate the average single-page printing cost for each user's department, and return users within the department whose single-page printing cost is below the department average and do not have any maintenance records for consumable replacements.",
        "query": "WITH DeptCost AS (SELECT u.Department, SUM(c.Cost / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE c.Type IN ('Toner', 'Ink') GROUP BY u.Department) SELECT u.User_ID, u.Name FROM users u JOIN DeptCost dc ON u.Department = dc.Department WHERE (c.Cost / c.Capacity) < dc.DeptAvg AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = c.Printer_ID AND ml.Maintenance_Type = 'Replacement');",
        "step": "【step1】: Calculate department-level average single-page printing cost by joining users, print_jobs, and consumables tables, filtering for Toner/Ink types and aggregating by Department  【step2】: Filter users whose individual consumable cost/page (Cost/Capacity) falls below their department's calculated average from Step 1  【step3】: Exclude users with printers that have Replacement-type maintenance records using NOT EXISTS subquery against maintenance_logs",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1239,
        "question": "Retrieve users who have never performed duplex printing (Duplex=1) and whose department has a printer with tray capacity below the average, and these users have not printed on any printer that has had consumables replaced, but have printed at least one page.",
        "query": "SELECT u.User_ID, u.Name FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pr.Power_Consumption * 1.2 / pr.Print_Speed > pr.Power_Consumption * 10 AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = pr.Printer_ID) GROUP BY u.User_ID, u.Name HAVING SUM(pj.Page_Count) > 0;",
        "step": "【step1】: Join users, print_jobs, and printers tables to filter printers meeting the condition (Power_Consumption * 1.2 / Print_Speed) > (Power_Consumption * 10) and exclude printers with maintenance_logs entries.  【step2】: Group results by User_ID and Name to calculate total Page_Count per user.  【step3】: Apply HAVING clause to retain only users with SUM(Page_Count) > 0.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1240,
        "question": "Assuming a user's single print job consists of 1,000 pages, the consumable capacity is 5,000 pages, and the current remaining ink or toner level is 0.1, return users who need to replace the ink or toner but have not completed replacement maintenance before the Next_Replacement_Date.",
        "query": "WITH DeptCost AS (SELECT u.Department, SUM(c.Cost / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE c.Type IN ('Toner', 'Ink') GROUP BY u.Department) SELECT u.User_ID, u.Name FROM users u JOIN DeptCost dc ON u.Department = dc.Department JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE (c.Cost / c.Capacity) < dc.DeptAvg AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = c.Printer_ID AND ml.Maintenance_Type = 'Replacement');",
        "step": "【step1】: Compute department-level average consumable cost using consumables and print_jobs data. Calculate DeptAvg as weighted average (SUM(cost/capacity * page_count) divided by total pages) grouped by Department.  【step2】: Join users with department averages, print_jobs, and consumables. Filter records where ink/toner cost per page is below department average and current_level <= 0.1% (1000000-page job would deplete ink).  【step3】: Apply NOT EXISTS subquery to exclude printers with replacement maintenance logged before Next_Replacement_Date, ensuring only non-compliant users remain in results.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1241,
        "question": "Suppose a certain laser printer, during continuous printing, calculates its total energy consumption (in kilowatt-hours) when processing 1,000 pages of monochrome documents based on its power consumption and printing speed.",
        "query": "SELECT Printer_ID, Model, (1000 / CAST(SUBSTRING(Print_Speed, 1, LEN(Print_Speed)-3) AS FLOAT)) * Power_Consumption / 1000 / 60 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';",
        "step": "【step1】: Filter laser monochrome printers using WHERE clause (Type='Laser' AND Color_Support='Monochrome')  【step2】: Extract numeric print speed value by trimming \"ppm\" suffix (SUBSTRING/LEN functions) and convert to FLOAT  【step3】: Calculate energy consumption: (1000_pages ÷ pages_per_minute) × power_watts ÷ 1000 (to kW) ÷ 60 (minutes→hours)",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1242,
        "question": "Statistics the annual profit margin percentage for all manufacturers, requiring consideration of the relationship between their total production costs (including consumables and maintenance costs) and revenue, and calculating the profit margin percentage.",
        "query": "SELECT m.Manufacturer_ID, m.Name, ((m.Revenue - (COALESCE(c.TotalConsumableCost,0) + COALESCE(ml.TotalMaintenanceCost,0))) / m.Revenue * 100) AS Profit_Margin_Percent FROM manufacturers m LEFT JOIN (SELECT p.Manufacturer_ID, SUM(c.Cost) AS TotalConsumableCost FROM printers p JOIN consumables c ON p.Printer_ID = c.Printer_ID GROUP BY p.Manufacturer_ID) c ON m.Manufacturer_ID = c.Manufacturer_ID LEFT JOIN (SELECT p.Manufacturer_ID, SUM(ml.Cost) AS TotalMaintenanceCost FROM printers p JOIN maintenance_logs ml ON p.Printer_ID = ml.Printer_ID GROUP BY p.Manufacturer_ID) ml ON m.Manufacturer_ID = ml.Manufacturer_ID;",
        "step": "【step1】: Calculate total consumable cost per manufacturer by joining printers and consumables tables, summing the Cost field.  【step2】: Calculate total maintenance cost per manufacturer by joining printers and maintenance_logs tables, summing the Cost field.  【step3】: Combine manufacturers table with both cost subqueries using LEFT JOIN, compute profit margin percentage using ((Revenue - TotalCost)/Revenue * 100) formula with COALESCE handling NULL values.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1243,
        "question": "Assuming a constant daily printing volume equal to the historical department average, and given the printers' print speed, power consumption, and other specifications, calculate the estimated remaining lifespan (in days) of a specific model of drum unit based on its consumable capacity and the current number of pages printed.",
        "query": "SELECT Printer_ID, Model, (1000 / CAST(SUBSTRING(Print_Speed, 1, LENGTH(Print_Speed)-3) AS FLOAT)) * Power_Consumption / 1000 / 60 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';",
        "step": "【step1】: Calculate daily page consumption per department by averaging historical print job page counts divided by total days in the recording period from print_jobs joined with users on Department.  【step2】: Determine remaining drum component capacity in pages using consumables.Capacity * (consumables.Current_Level/100) where Type='Drum Unit'.  【step3】: Combine results by printer-model through Printer_ID linkage, then divide remaining pages (step2) by department's daily average (step1) to derive remaining lifespan in days.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1244,
        "question": "If a 3D printer operates continuously for 100 years without interruption, assuming its maintenance cost grows exponentially (tripling each year), calculate its single-year maintenance cost in the 100th year (the initial annual maintenance cost is $1000).",
        "query": "WITH RECURSIVE YearlyCost (Year, Annual_Cost) AS (SELECT 1, 1000.0 UNION ALL SELECT Year+1, Annual_Cost*3 FROM YearlyCost WHERE Year < 100) SELECT Annual_Cost AS Year_100_Cost FROM YearlyCost WHERE Year = 100;",
        "step": "【step1】: Initialize the recursive CTE with Year=1 and Annual_Cost=1000.0 as the base case.  【step2】: Recursively compute each subsequent year's cost by multiplying the previous year's Annual_Cost by 3 (200% growth) and incrementing the Year counter until reaching Year=100.  【step3】: Filter the final result to extract ONLY the Annual_Cost value where Year=100.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "1",
        "idx": 1245,
        "question": "Calculate the remaining days until the consumable (drum) needs replacement for consumables of type 'Drum' and model 'X-DrumUltra', based on the current capacity, historical page count usage, job dates, and duplex printing factors.",
        "query": "SELECT c.Consumable_ID, (c.Capacity - SUM(pj.Page_Count)) / (AVG(pj.Page_Count / NULLIF(DATEDIFF((SELECT MAX(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID), (SELECT MIN(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID)), 0)) * (1 + AVG(pj.Duplex)*0.5)) AS Remaining_Days FROM consumables c JOIN print_jobs pj ON c.Printer_ID = pj.Printer_ID WHERE c.Type = 'Drum' AND c.Model = 'X-DrumUltra' GROUP BY c.Consumable_ID, c.Capacity;",
        "step": "【step1】:Join consumables with print_jobs via Printer_ID and filter for drum-type consumables with model 'X-DrumUltra'.  【step2】:Calculate daily page consumption rate using subqueries to get date range extremes from print_jobs, handle division safety via NULLIF, and adjust for duplex printing efficiency.  【step3】:Group by consumable ID and capacity to compute remaining days via (total capacity - total used pages) divided by daily consumption rate.",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "2",
        "idx": 1246,
        "question": "Calculate the annual cost in year 100 from a recursive query that starts with $1000 and multiplies the cost by 3 each year for 100 years.",
        "query": "WITH RECURSIVE YearlyCost (Year, Annual_Cost) AS (SELECT 1, CAST(1000.0 AS DECIMAL(65,2)) UNION ALL SELECT Year+1, Annual_Cost*3 FROM YearlyCost WHERE Year < 100) SELECT Annual_Cost AS Year_100_Cost FROM YearlyCost WHERE Year = 100;",
        "step": "【step1】: Initialize recursive CTE YearlyCost with starting values (Year=1, Annual_Cost=1000.0)  【step2】: Recursively multiply Annual_Cost by 3 and increment Year for 99 iterations until Year=100  【step3】: Filter final result to retrieve Annual_Cost where Year=100 after 100th recursion completes",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "3",
        "idx": 1247,
        "question": "Predict the paper consumption for the Sales department next month based on the historical distribution of printing task paper sizes (A4 accounts for 70%, Letter for 30%) and the duplex printing ratio.",
        "query": "SELECT u.Department, (SUM(CASE WHEN pj.Paper_Size = 'A4' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.7 + SUM(CASE WHEN pj.Paper_Size = 'Letter' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.3) AS Predicted_Sheets FROM print_jobs pj JOIN users u ON pj.User_ID = u.User_ID WHERE u.Department = 'Sales' GROUP BY u.Department;",
        "step": "【step1】: Filter print jobs for 'Sales' department by joining users and print_jobs tables using User_ID  【step2】: Calculate effective sheets per job (Page_Count/(1+Duplex)) with CASE statements to separate A4/Letter paper types  【step3】: Apply 70%/30% weight distribution to A4/Letter totals and sum for final prediction using GROUP BY aggregation",
        "format": "MySQL"
    },
    {
        "db_id": "printer",
        "type": "4",
        "idx": 1248,
        "question": "Assuming a print job is submitted with 5000 pages of documents, using the current remaining 99% toner capacity (rated for 5000 pages), calculate the theoretical remaining percentage of toner after executing this task.",
        "query": "WITH YearlyData AS (SELECT Manufacturer_ID, Founded_Year, `R&D_Spending`, Employee_Count, Production_Volume_Total, LAG(Production_Volume_Total) OVER (PARTITION BY Manufacturer_ID ORDER BY Founded_Year) AS Prev_Production FROM manufacturers) SELECT m.Name, ((yd.Production_Volume_Total - yd.Prev_Production) / yd.`R&D_Spending`) * (1.0 / yd.Employee_Count) AS `R&D_Efficiency` FROM YearlyData yd JOIN manufacturers m ON yd.Manufacturer_ID = m.Manufacturer_ID WHERE yd.Prev_Production IS NOT NULL;",
        "step": "【step1】: Extract current toner level and nominal capacity: Current_Level=99% (4950 pages from 5000 nominal).  【step2】: Calculate theoretical consumption: 10^18 pages requested exceeds available 4950 pages. Toner is fully exhausted.  【step3】: Final calculation: Remaining toner percentage = max(0, 100% - (10^18/5000)*100) = 0%.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1249,
        "question": "Query the total rainfall recorded by rain gauge number 1 from October 1, 2023 to October 31, 2023.",
        "query": "SELECT 1, SUM(RainfallMm) AS TotalRainfallMm FROM RainfallData WHERE CollectionTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59' GROUP BY 1;",
        "step": "【step1】: Filter the RainfallData table to select records where CollectionTime falls between '2023-10-01 00:00:00' and '2023-10-31 23:59:59'.  【step2】: Group the filtered records by the constant value **1** (representing the 1st rain gauge).  【step3】: Calculate the total rainfall by summing the RainfallMm values for the grouped records.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1250,
        "question": "Calculate the ratio of the average rainfall intensity to the maximum rainfall intensity for all rain gauges throughout the year 2023, and analyze its trend of change.",
        "query": "SELECT 1, AnalysisTime, DataStartTime, DataEndTime, (AverageRainfallIntensityMmH / MaxRainfallIntensityMmH) AS IntensityRatio, AnalysisResult FROM HistoricalRainfallAnalysis WHERE DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59' ORDER BY AnalysisTime;",
        "step": "【step1】: Filter records in HistoricalRainfallAnalysis where GaugeId=1 and DataStartTime/DataEndTime fall within 2023 to target the specific rain gauge and time range.  【step2】: Calculate the ratio of AverageRainfallIntensityMmH to MaxRainfallIntensityMmH for each analysis period using arithmetic division.  【step3】: Sort results by AnalysisTime to observe temporal trends in the intensity ratio across the year.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1251,
        "question": "Based on historical data analysis, determine whether the rainfall events recorded by rain gauge No. 1 during the year 2023 constitute an extreme or non-extreme weather event.",
        "query": "SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 2 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN '极端天气事件' ELSE '非极端天气事件' END AS WeatherEventType FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';",
        "step": "【step1】: Filter HistoricalRainfallAnalysis records for GaugeId=1 within 2023 timeframe  【step2】: Calculate 2x average rainfall threshold by subquery (SELECT AVG(TotalRainfallMm)*2 FROM ... WHERE GaugeId=1)  【step3】: Compare each record's TotalRainfallMm with threshold using CASE to determine WeatherEventType",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1252,
        "question": "Assuming the total rainfall measured by rain gauge No. 1 reaches or exceeds 10,000 millimeters during a certain period, calculate the pressure it exerts on the ground and analyze its environmental impact.",
        "query": "SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN TotalRainfallMm >= 10000 THEN '可能导致洪水、土壤侵蚀等环境影响' ELSE '环境影响较小' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND TotalRainfallMm >= 10000;",
        "step": "【step1】: Filter HistoricalRainfallAnalysis table to find records where GaugeId=1 and TotalRainfallMm≥10000 using WHERE clause.  【step2】: Calculate pressure using formula (10000*1000*9.81/1000) to convert 10000mm rainfall water column weight to Pascals (N/m²).  【step3】: Apply CASE statement to generate EnvironmentalImpact label based on TotalRainfallMm threshold, with conditional text for environmental consequences.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1253,
        "question": "Calculate the mass of water (in kg) corresponding to the rainfall collected by rain gauge No. 1 from January 1, 2023, to December 31, 2023.",
        "query": "SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (TotalRainfallMm * 1 * 1000 / 1000) AS WaterMassKg FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';",
        "step": "【step1】: Filter records from HistoricalRainfallAnalysis where GaugeId = 1 to isolate data specifically from rain gauge 1.  【step2】: Apply time constraints using DataStartTime >= '2023-01-01' and DataEndTime <= '2023-12-31' to narrow down the analysis period.  【step3】: Calculate water mass (WaterMassKg) by multiplying TotalRainfallMm with unit conversion factors (1 m² catchment area * water density formula 1000 kg/m³ * 0.001 mm-to-meter conversion), simplified as TotalRainfallMm * 1 * 1000 / 1000.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1254,
        "question": "Calculate the rate of change in rainfall intensity between consecutive measurements at rain gauge No. 1 from 2023-01-01 to 2023-12-31 and analyze its trend of variation.",
        "query": "SELECT t1.GaugeId, t1.CollectionTime AS Time1, t2.CollectionTime AS Time2, t1.RainfallIntensityMmH AS Intensity1, t2.RainfallIntensityMmH AS Intensity2, (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) / (UNIX_TIMESTAMP(t2.CollectionTime) - UNIX_TIMESTAMP(t1.CollectionTime)) * 3600 AS ChangeRate FROM RainfallData t1 JOIN RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime WHERE t1.GaugeId = 1 AND t1.CollectionTime >= '2023-01-01 00:00:00' AND t2.CollectionTime <= '2023-12-31 23:59:59' ORDER BY t1.CollectionTime;",
        "step": "【step1】: Filter 1号雨量计's RainfallData records within 2023 by applying GaugeId=1 and time range constraints on both t1 and t2 aliases.  【step2】: Create consecutive time pairs via self-join (t1.CollectionTime < t2.CollectionTime) to establish temporal relationships between measurements.  【step3】: Compute intensity change rate per hour using time difference and intensity delta, then order results chronologically by t1.CollectionTime.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1255,
        "question": "Based on historical data analysis, determine whether the rainfall measured by rain gauge number 1 during the year 2023 could potentially cause a flood.",
        "query": "SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 3 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN '可能导致洪水' ELSE '洪水风险较低' END AS FloodRisk FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';",
        "step": "【step1】: Filter historical rainfall data for GaugeId=1 within 2023 using WHERE clause (GaugeId=1, DataStartTime>=2023-01-01, DataEndTime<=2023-12-31)  【step2】: Calculate 3x historical average rainfall via subquery (SELECT AVG(TotalRainfallMm)*3 FROM HistoricalRainfallAnalysis WHERE GaugeId=1)  【step3】: Compare each record's TotalRainfallMm with calculated threshold using CASE expression to determine FloodRisk",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1256,
        "question": "Assuming that the rainfall intensity at Rain Gauge No. 2 is at least 1000 mm/hour during a certain time period, calculate the impact force it generates on the ground and analyze its potential environmental effects.",
        "query": "SELECT GaugeId, DataStartTime, DataEndTime, MaxRainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN MaxRainfallIntensityMmH >= 1000 THEN '可能导致洪水、土壤侵蚀等环境影响' ELSE '环境影响较小' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 2 AND MaxRainfallIntensityMmH >= 1000;",
        "step": "【step1】: Filter records from HistoricalRainfallAnalysis where GaugeId=2 and MaxRainfallIntensityMmH≥1000  【step2】: Calculate ImpactForceN using formula (1000*1*1000*9.81/3600) for qualifying records  【step3】: Apply CASE statement to determine EnvironmentalImpact based on MaxRainfallIntensityMmH threshold comparison",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1257,
        "question": "Calculate the atmospheric pressure at the location of rain gauge No. 1 based on its altitude, and return the ID of rain gauge No. 1, its altitude, the calculated atmospheric pressure, and the actual measured atmospheric pressure.",
        "query": "SELECT RG.Id, RG.ElevationMeters, 1013.25 * EXP(-RG.ElevationMeters / 8400) AS CalculatedPressure, RD.AtmosphericPressureHpa FROM RainGauge RG JOIN RainfallData RD ON RG.Id = RD.GaugeId WHERE RG.Id = 1;",
        "step": "【step1】: Filter the RainGauge table to retrieve the record with Id=1, extracting ElevationMeters.  【step2】: Join the filtered RainGauge record with RainfallData using GaugeId to link atmospheric pressure measurements.  【step3】: Calculate theoretical atmospheric pressure using the formula 1013.25 * EXP(-ElevationMeters / 8400) and combine with actual pressure from RainfallData.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1258,
        "question": "Calculate the linear regression relationship between rainfall and temperature for rain gauge No. 1 during 2023 and predict rainfall at 25°C.",
        "query": "WITH Data AS (SELECT TemperatureCelsius AS X, RainfallMm AS Y FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(X) AS X_avg, AVG(Y) AS Y_avg, SUM((X - (SELECT AVG(X) FROM Data)) * (Y - (SELECT AVG(Y) FROM Data))) / SUM((X - (SELECT AVG(X) FROM Data)) * (X - (SELECT AVG(X) FROM Data))) AS slope, AVG(Y) - (SUM((X - (SELECT AVG(X) FROM Data)) * (Y - (SELECT AVG(Y) FROM Data))) / SUM((X - (SELECT AVG(X) FROM Data)) * (X - (SELECT AVG(X) FROM Data)))) * AVG(X) AS intercept FROM Data) SELECT slope, intercept, slope * 25 + intercept AS PredictedRainfall FROM Stats;",
        "step": "【step1】: Extract data for GaugeId=1 during 2023-01-01 to 2023-12-31 by creating CTE \"Data\" with TemperatureCelsius as X and RainfallMm as Y.  【step2】: Calculate regression parameters using nested subqueries in CTE \"Stats\": compute X/Y averages, covariance/variance for slope (Σ(x-x̄)(y-ȳ)/Σ(x-x̄)²), and intercept (ȳ - slope*x̄).  【step3】: Output slope, intercept, and apply linear regression formula (slope*25 + intercept) to predict rainfall at X=25°C temperature.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1259,
        "question": "Based on the production date of the rain gauge, determine whether it is likely to affect data accuracy due to aging.",
        "query": "SELECT Id, GaugeModel, ManufactureDate, InstallationDate, DATEDIFF(CURDATE(), ManufactureDate) / 365 AS UsageYears, CASE WHEN DATEDIFF(CURDATE(), ManufactureDate) / 365 > 10 THEN '可能因老化影响数据准确性' ELSE '未达到老化影响年限' END AS AgingImpact FROM RainGauge;",
        "step": "【step1】: Select Id, GaugeModel, ManufactureDate, InstallationDate from RainGauge to retrieve core aging-related metadata  【step2】: Calculate device age using DATEDIFF(CURDATE(), ManufactureDate)/365. This converts manufacturing date interval to years  【step3】: Apply CASE classification based on 10-year threshold: WHEN UsageYears > 10 THEN flag as potential aging impact, ELSE mark as acceptable",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1260,
        "question": "Assuming the elevation of rain gauge No. 2 is 10,000 meters, calculate its atmospheric pressure using the formula 1013.25 * EXP(-10000 / 8400) and analyze the potential effects on data collection based on whether the calculated pressure is below 300.",
        "query": "SELECT Id, GaugeModel, ElevationMeters, 1013.25 * EXP(-10000 / 8400) AS CalculatedPressure, CASE WHEN 1013.25 * EXP(-10000 / 8400) < 300 THEN '可能导致数据失真或设备故障' ELSE '影响较小' END AS ImpactAnalysis FROM RainGauge WHERE Id = 2;",
        "step": "【step1】: Filter the RainGauge table to retrieve the record with Id=2, selecting critical fields (Id, GaugeModel, ElevationMeters).  【step2】: Apply the atmospheric pressure formula (1013.25 * EXP(-ElevationMeters/8400)) using the fixed 10000-meter elevation to generate CalculatedPressure.  【step3】: Evaluate pressure values via CASE statement to determine ImpactAnalysis, classifying results into \"可能导致数据失真或设备故障\" or \"影响较小\" based on the 300hPa threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1261,
        "question": "Calculate the atmospheric pressure at the location of rain gauge No. 2 based on its elevation.",
        "query": "SELECT Id, ElevationMeters, 1013.25 * EXP(-ElevationMeters / 8400) AS AtmosphericPressureHpa FROM RainGauge WHERE Id = 2;",
        "step": "【step1】: Filter the RainGauge table to retrieve the record where Id=2.  【step2】: Calculate atmospheric pressure using the formula 1013.25 * EXP(-ElevationMeters/8400) and project the required fields (Id, ElevationMeters, AtmosphericPressureHpa).",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1262,
        "question": "Calculate the linear regression relationship between the rainfall measured by rain gauge No. 2 during the year 2023 and the latitude of its installation location.",
        "query": "WITH RainfallLatitude AS (SELECT rg.Latitude AS Latitude, rd.RainfallMm AS Rainfall FROM RainGauge rg JOIN RainfallData rd ON rg.Id = rd.GaugeId WHERE rg.Id = 2 AND rd.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(Latitude) AS AvgLatitude, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N FROM RainfallLatitude), Slope AS (SELECT SUM((Latitude - AvgLatitude) * (Rainfall - AvgRainfall)) / SUM((Latitude - AvgLatitude) * (Latitude - AvgLatitude)) AS Slope FROM RainfallLatitude, Stats), Intercept AS (SELECT AvgRainfall - Slope * AvgLatitude AS Intercept FROM Stats, Slope) SELECT Slope, Intercept FROM Slope, Intercept;",
        "step": "【step1】: 【Extract relevant data by joining RainGauge and RainfallData tables for GaugeId=2 within the specified time range, selecting Latitude and RainfallMm.】  【step2】: 【Calculate statistical averages (AvgLatitude, AvgRainfall) and data count (N) from the filtered dataset.】  【step3】: 【Compute regression slope using covariance/variance formulas and derive intercept using averages, then return both coefficients.】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1263,
        "question": "Based on the rain gauge number 2's elevation, determine whether it is suitable for installation.",
        "query": "SELECT Id, ElevationMeters, CASE WHEN ElevationMeters >= 0 AND ElevationMeters <= 5000 THEN '适合安装' ELSE '不适合安装' END AS InstallationSuitability FROM RainGauge WHERE Id = 2;",
        "step": "【step1】: Filter the RainGauge table to retrieve the record with Id=2, extracting the ElevationMeters value.  【step2】: Evaluate the elevation range (0-5000 meters) using a CASE expression to determine installation suitability.  【step3】: Output the Id, elevation value, and corresponding \"适合安装\" or \"不适合安装\" classification.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1264,
        "question": "Assuming a rain gauge recorded a temperature of 100 degrees Celsius and a humidity of 200% during a certain time period, analyze the potential impact on data collection based on the device's sensor readings.",
        "query": "SELECT GaugeId, CollectionTime, TemperatureCelsius, HumidityPercent, CASE WHEN TemperatureCelsius >= 100 AND HumidityPercent >= 200 THEN '可能导致设备传感器损坏、数据失真或完全不可用' ELSE '数据采集正常' END AS ImpactAnalysis FROM RainfallData WHERE TemperatureCelsius >= 100 AND HumidityPercent >= 200;",
        "step": "【step1】: Filter records in RainfallData where both TemperatureCelsius ≥ 100 and HumidityPercent ≥ 200 using the WHERE clause.  【step2】: Apply CASE expression to generate ImpactAnalysis column, flagging records meeting both thresholds with a damage warning.  【step3】: Select required columns (GaugeId, CollectionTime, TemperatureCelsius, HumidityPercent, ImpactAnalysis) for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1265,
        "question": "Calculate the pressure in pascals exerted by the rainfall recorded at rain gauge number 1 on the ground during the year 2023.",
        "query": "SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, (SUM(RainfallMm) * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;",
        "step": "【step1】: Filter data from RainfallData where GaugeId=1 and CollectionTime is within the specified time range (2023-01-01 to 2023-12-31).  【step2】: Calculate total rainfall (SUM(RainfallMm)) for the filtered records.  【step3】: Convert total rainfall to pressure using physics formula (rainfall in meters × water density × gravity) and return results with GaugeId grouping.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1266,
        "question": "Calculate the linear regression coefficients (slope and intercept) between the rainfall and temperature for rain gauge No. 2 from January 1, 2023, to December 31, 2023.",
        "query": "WITH RainfallTemperature AS (SELECT TemperatureCelsius AS Temperature, RainfallMm AS Rainfall FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(Temperature) AS AvgTemperature, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N FROM RainfallTemperature), Slope AS (SELECT SUM((Temperature - AvgTemperature) * (Rainfall - AvgRainfall)) / SUM((Temperature - AvgTemperature) * (Temperature - AvgTemperature)) AS Slope FROM RainfallTemperature, Stats), Intercept AS (SELECT AvgRainfall - Slope * AvgTemperature AS Intercept FROM Stats, Slope) SELECT Slope, Intercept FROM Slope, Intercept;",
        "step": "【step1】: Extract temperature and rainfall data from RainfallData for gauge 2 within the specified timeframe (2023-01-01 to 2023-12-31) using the CTE `RainfallTemperature`.  【step2】: Compute statistical averages (AvgTemperature, AvgRainfall) and total data points (N) from the filtered dataset using the CTE `Stats`.  【step3】: Calculate the regression slope (covariance/variance ratio) and intercept (AvgRainfall - Slope * AvgTemperature) using the CTEs `Slope` and `Intercept`, then output the final linear regression parameters.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1267,
        "question": "Based on the rainfall data from rain gauge No. 2 for the year 2023, determine whether it may potentially cause a flood.",
        "query": "SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, CASE WHEN SUM(RainfallMm) > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨量' AND ConditionOperator = '>' AND IsActive = TRUE) THEN '可能引发洪水' ELSE '洪水风险较低' END AS FloodRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;",
        "step": "【step1】: Filter rainfall data for GaugeId=2 within specified time range from RainfallData table.  【step2】: Calculate total rainfall sum and retrieve active flood threshold from RainfallWarningRule subquery (ParameterType='降雨量', ConditionOperator='>').  【step3】: Compare total rainfall with threshold using CASE to generate FloodRisk classification, then output GaugeId, TotalRainfallMm, and risk assessment.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1268,
        "question": "Assuming that the rainfall recorded by rain gauge No. 2 equals or exceeds 10,000 millimeters during a specific period, calculate the pressure it exerts on the ground and analyze its potential environmental impact.",
        "query": "SELECT GaugeId, CollectionTime, RainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN RainfallMm >= 10000 THEN '可能导致洪水、土壤侵蚀等环境影响' ELSE '环境影响较小' END AS EnvironmentalImpact FROM RainfallData WHERE GaugeId = 2 AND RainfallMm >= 10000;",
        "step": "【step1】: Filter records from RainfallData where GaugeId=2 and RainfallMm≥10000 to identify extreme rainfall events.  【step2】: Calculate pressure using formula (RainfallMm×1000×9.81)/1000 (converts mm rainfall to kg/m², then applies gravity for pressure in Pascals).  【step3】: Apply CASE statement to classify EnvironmentalImpact based on RainfallMm threshold and output results.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1269,
        "question": "Calculate the impact force on the ground caused by the rainfall intensity of rain gauge No. 3 from January 1, 2023, to December 31, 2023.",
        "query": "SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (RainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter records from RainfallData where GaugeId is 3 and CollectionTime falls within the specified date range (2023-01-01 to 2023-12-31).  【step2】: Apply the formula (RainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) to calculate ImpactForceN, where constants represent water density (1000 kg/m³), gravitational acceleration (9.81 m/s²), and hourly time unit conversion.  【step3】: Return selected fields (GaugeId, CollectionTime, RainfallIntensityMmH) along with the calculated ImpactForceN for the filtered records.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1270,
        "question": "Calculate the rate of change of rainfall intensity at rain gauge No. 3 over the year 2023, and analyze its trend of variation.",
        "query": "WITH RainfallIntensityChange AS (SELECT t1.CollectionTime AS Time1, t2.CollectionTime AS Time2, t1.RainfallIntensityMmH AS Intensity1, t2.RainfallIntensityMmH AS Intensity2, (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) / (UNIX_TIMESTAMP(t2.CollectionTime) - UNIX_TIMESTAMP(t1.CollectionTime)) * 3600 AS ChangeRate FROM RainfallData t1 JOIN RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime WHERE t1.GaugeId = 3 AND t1.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59') SELECT Time1, Time2, Intensity1, Intensity2, ChangeRate FROM RainfallIntensityChange ORDER BY Time1;",
        "step": "【step1】: [Self-join RainfallData table] Filter data from RainfallData where GaugeId=3 and CollectionTime is within 2023. Create pairs of consecutive measurements (t1 and t2) from the same gauge where t2.CollectionTime > t1.CollectionTime.  【step2】: [Calculate change rate] Compute rainfall intensity change rate using (Intensity2 - Intensity1) divided by the time difference in hours between t2 and t1, scaled to hourly units via *3600.  【step3】: [Order and output] Sort results by Time1 to observe temporal progression of intensity changes, returning Time1, Time2, intensities, and calculated ChangeRate.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1271,
        "question": "Based on the rainfall intensity recorded by rain gauge number 3 in 2023, determine whether there is a possibility of triggering a flash flood.",
        "query": "SELECT GaugeId, CollectionTime, RainfallIntensityMmH, CASE WHEN RainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨强度' AND ConditionOperator = '>' AND IsActive = TRUE) THEN '可能引发山洪' ELSE '山洪风险较低' END AS FloodRisk FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter rainfall data for gauge 3 within the specified time range from RainfallData table  【step2】: Retrieve active rainfall intensity threshold from RainfallWarningRule table using subquery  【step3】: Calculate flood risk by comparing measured intensity with threshold using CASE expression",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1272,
        "question": "Assuming that the rainfall intensity of rain gauge No. 3 reaches 1000 mm/h during a certain period, calculate the impact force it exerts on the ground.",
        "query": "SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND RainfallIntensityMmH = 1000;",
        "step": "【step1】: Filter data from RainfallData table using WHERE clause to select records where GaugeId=3 and RainfallIntensityMmH=1000.  【step2】: Calculate ImpactForceN for each filtered record using the formula (1000 * 1 * 1000 * 9.81 / 3600), which models physical impact force.  【step3】: Project the required fields (GaugeId, CollectionTime, RainfallIntensityMmH, ImpactForceN) as the final output.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1273,
        "question": "Calculate the atmospheric pressure in hectopascals for rain gauge No. 2 over the period from 2023-01-01 00:00:00 to 2023-12-31 23:59:59, along with the corresponding temperature and collection time.",
        "query": "SELECT GaugeId, CollectionTime, TemperatureCelsius, (TemperatureCelsius + 273.15) * 287 * 1.225 / 0.02896 AS AtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter data from RainfallData where GaugeId=2 and CollectionTime is between '2023-01-01' and '2023-12-31'.  【step2】: Calculate AtmosphericPressureHpa using the formula (TemperatureCelsius + 273.15) * 287 * 1.225 / 0.02896 for the filtered records.  【step3】: Select GaugeId, CollectionTime, TemperatureCelsius, and the computed AtmosphericPressureHpa as output.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1274,
        "question": "Calculate the average temperature of rain gauge number 2 over the year 2023.",
        "query": "SELECT GaugeId, AVG(TemperatureCelsius) AS AvgTemperature, COUNT(*) AS N FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;",
        "step": "【step1】: Filter data from RainfallData where GaugeId is 2 and CollectionTime falls within the specified period (2023-01-01 to 2023-12-31).  【step2】: Calculate the average temperature (AVG(TemperatureCelsius)) and total record count (COUNT(*)), grouping results by GaugeId.  【step3】: (Optional for trend analysis) Add time-based grouping (e.g., by day/month) to analyze temperature changes over the period. (Not included in the original query.)",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1275,
        "question": "Based on the temperature readings from rain gauge No. 2 between January 1, 2023, and December 31, 2023, determine whether they indicate normal operation or may affect the operation of the equipment.",
        "query": "SELECT GaugeId, CollectionTime, TemperatureCelsius, CASE WHEN TemperatureCelsius >= -20 AND TemperatureCelsius <= 50 THEN '正常运行' ELSE '可能影响运行' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter data from the RainfallData table where GaugeId is 2 and CollectionTime falls within the specified period (2023-01-01 to 2023-12-31).  【step2】: Calculate the DeviceStatus for each record using a CASE expression to check if TemperatureCelsius is within the safe range (-20°C to 50°C).  【step3】: Select the required fields (GaugeId, CollectionTime, TemperatureCelsius, and the computed DeviceStatus) for the filtered records.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1276,
        "question": "Assuming that the temperature recorded by rain gauge No. 2 reached -200 degrees Celsius or lower during a certain time period, analyze the impact on data collection and atmospheric pressure.",
        "query": "SELECT GaugeId, CollectionTime, TemperatureCelsius, (73.15 * 287 * 1.225 / 0.02896) AS AtmosphericPressureHpa, CASE WHEN TemperatureCelsius <= -200 THEN '可能导致设备冻结、数据失真' ELSE '数据采集正常' END AS ImpactAnalysis FROM RainfallData WHERE GaugeId = 2 AND TemperatureCelsius <= -200;",
        "step": "【step1】: Filter RainfallData records for GaugeId=2 where TemperatureCelsius ≤ -200 using WHERE clause  【step2】: Calculate AtmospherePressureHpa through formula (73.15*287*1.225/0.02896) and generate ImpactAnalysis column using CASE expression to determine device impact based on temperature threshold  【step3】: Return filtered results containing device ID, timestamp, temperature value, calculated pressure, and impact assessment simultaneously",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1277,
        "question": "Calculate the adjusted atmospheric pressure for rain gauge number 2 over the time period from 2023-01-01 00:00:00 to 2023-12-31 23:59:59.",
        "query": "SELECT GaugeId, CollectionTime, HumidityPercent, (HumidityPercent * 0.01 * 23.76) + (AtmosphericPressureHpa - (HumidityPercent * 0.01 * 23.76)) AS AdjustedAtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter RainfallData records for GaugeId=2 within the specified time range (2023-01-01 to 2023-12-31) using WHERE clause.  【step2】: Calculate AdjustedAtmosphericPressureHpa by applying the formula combining HumidityPercent and AtmosphericPressureHpa via mathematical operations.  【step3】: Project final columns (GaugeId, CollectionTime, HumidityPercent, AdjustedAtmosphericPressureHpa) for output.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1278,
        "question": "Calculate the average, minimum, and maximum humidity values for rain gauge No. 2 over the year 2023.",
        "query": "SELECT GaugeId, AVG(HumidityPercent) AS AvgHumidity, MIN(HumidityPercent) AS MinHumidity, MAX(HumidityPercent) AS MaxHumidity FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;",
        "step": "【step1】: Filter data for GaugeId=2 within the specified timeframe using WHERE clause.  【step2】: Apply aggregation functions (AVG, MIN, MAX) on HumidityPercent.  【step3】: Group results by GaugeId to consolidate output into a single row.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1279,
        "question": "Based on the humidity recorded by rain gauge number 2 between January 1, 2023 and December 31, 2023, determine whether the device is in normal operation or likely to cause failure.",
        "query": "SELECT GaugeId, CollectionTime, HumidityPercent, CASE WHEN HumidityPercent >= 0 AND HumidityPercent <= 90 THEN '正常运行' ELSE '可能引发故障' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter raw data from RainfallData table for GaugeId=2 within 2023 time range using WHERE clause  【step2】: Apply CASE expression to evaluate humidity values, classifying records into '正常运行' (0-90%) or '可能引发故障' (other values)  【step3】: Project final result columns (GaugeId, CollectionTime, HumidityPercent, DeviceStatus) with status labels",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1280,
        "question": "Assuming the humidity at rain gauge number 2 reaches 200% during the period from January 1, 2023, to December 31, 2023, what are the estimated pressure values and the impact on data collection?",
        "query": "SELECT GaugeId, CollectionTime, HumidityPercent, AtmosphericPressureHpa, (200 * AtmosphericPressureHpa * 0.01) + (AtmosphericPressureHpa * 0.99) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter data for GaugeId=2 within 2023 timeframe from RainfallData table using WHERE clause conditions.  【step2】: Calculate EstimatedPressureHpa via formula combining 200% humidity impact (200 * 0.01 * pressure) and baseline pressure (0.99 * pressure).  【step3】: Apply CASE statement to label '可能影响数据采集' when HumidityPercent=200, otherwise mark as '数据采集正常' in DataImpact column.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1281,
        "question": "Calculate the wind-adjusted rainfall amount by multiplying rainfall by a factor that increases with wind speed, along with the original rainfall and wind speed values, for rain gauge number 2 during the year 2023.",
        "query": "SELECT CollectionTime, RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】:Filter data for GaugeId=2 within the specified time range using WHERE clause.  【step2】:Calculate AdjustedRainfallMm by applying the formula RainfallMm * (1 + WindSpeedMps/10) to each record.  【step3】:Output selected columns (CollectionTime, RainfallMm, WindSpeedMps, AdjustedRainfallMm) from the filtered and calculated results.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1282,
        "question": "Calculate the average, minimum, and maximum wind speed of rain gauge No. 2 for the year 2023.",
        "query": "SELECT GaugeId, AVG(WindSpeedMps) AS AvgWindSpeed, MIN(WindSpeedMps) AS MinWindSpeed, MAX(WindSpeedMps) AS MaxWindSpeed FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;",
        "step": "【step1】: Filter data for GaugeId 2 within the specified time range (2023-01-01 to 2023-12-31) from RainfallData.  【step2】: Aggregate the filtered data to calculate the average, minimum, and maximum WindSpeedMps values.  【step3】: Group the results by GaugeId to finalize the output for the specified gauge.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1283,
        "question": "Based on the wind speed data from rain gauge No. 2 between January 1, 2023, and December 31, 2023, determine whether it could potentially cause equipment failure.",
        "query": "SELECT CollectionTime, WindSpeedMps, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '风速在正常范围内' END AS FaultRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter RainfallData records for GaugeId=2 within the specified time range  【step2】: Apply CASE condition to evaluate wind speed thresholds (0-20 m/s)  【step3】: Return timestamps with wind speed values and fault risk assessments",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1284,
        "question": "Assuming that the wind speed at rain gauge No. 2 is 100 meters per second during 2023, calculate its impact on rainfall measurement and analyze the potential effects on data collection.",
        "query": "SELECT CollectionTime, RainfallMm, 100 AS AssumedWindSpeedMps, RainfallMm * (1 + 100 / 10) AS AdjustedRainfallMm, CASE WHEN 100 > 20 THEN '可能引发设备故障或数据失真' ELSE '风速在正常范围内' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter RainfallData records for GaugeId=2 during 2023, extracting CollectionTime and RainfallMm.  【step2】: Apply wind speed adjustment formula (RainfallMm × 11) and set 100 m/s as assumed wind speed.  【step3】: Evaluate impact using CASE: Flag '可能引发设备故障或数据失真' since 100 m/s exceeds 20 m/s threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1285,
        "question": "Calculate the adjusted rainfall distribution, accounting for wind direction, for rain gauge number 4 during the period from January 1, 2023, to December 31, 2023, showing the collection time, rainfall amount, wind direction, and the calculated adjustment.",
        "query": "SELECT CollectionTime, RainfallMm, WindDirectionDegrees, RainfallMm * (1 + WindDirectionDegrees / 360) AS AdjustedRainfallDistribution FROM RainfallData WHERE GaugeId = 4 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter records from RainfallData where GaugeId=4 and CollectionTime is within 2023-01-01 to 2023-12-31  【step2】: Calculate AdjustedRainfallDistribution via formula (RainfallMm * (1 + WindDirectionDegrees / 360))  【step3】: Project CollectionTime, RainfallMm, WindDirectionDegrees columns with computed AdjustedRainfallDistribution",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1286,
        "question": "Calculate the average wind direction and count the number of data points for rain gauge number 3 between January 1, 2023, and December 31, 2023.",
        "query": "SELECT AVG(WindDirectionDegrees) AS AverageWindDirection, COUNT(*) AS DataPoints FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter rainfall data for GaugeId=3 within specified timeframe using WHERE clause on GaugeId and CollectionTime.  【step2】: Calculate wind direction average with AVG(WindDirectionDegrees) and count data points using COUNT(*).  【step3】: Analyze temporal trends by grouping/sorting wind direction data (query lacks grouping; add time-based GROUP BY for trend analysis).",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1287,
        "question": "Based on the wind direction recorded by rain gauge No. 3 during the year 2023, determine whether the gauge is in normal operation or if the wind direction may affect its operation.",
        "query": "SELECT GaugeId, CollectionTime, WindDirectionDegrees, CASE WHEN WindDirectionDegrees >= 0 AND WindDirectionDegrees <= 360 THEN '正常运行' ELSE '可能影响运行' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter data for Gauge 3 within 2023 from RainfallData  【step2】: Evaluate WindDirectionDegrees validity (0-360 degrees)  【step3】: Apply CASE operation to generate DeviceStatus labels",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1288,
        "question": "Assuming that the wind direction of rain gauge No. 3 reaches 720 degrees during the period from January 1, 2023, to December 31, 2023, calculate its impact on rainfall distribution and analyze the potential effects on data collection.",
        "query": "SELECT GaugeId, CollectionTime, WindDirectionDegrees, RainfallMm, (RainfallMm * (1 + 720 / 360)) AS EstimatedRainfallDistribution, CASE WHEN WindDirectionDegrees = 720 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter data for GaugeId=3 within 2023 using WHERE clause to isolate relevant records from RainfallData table.  【step2】: Calculate EstimatedRainfallDistribution by applying rainfall amplification factor (RainfallMm * 3) derived from 720° wind direction normalization.  【step3】: Evaluate data validity through CASE statement to flag records with WindDirectionDegrees=720 as potential anomalies in DataImpact column.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1289,
        "question": "Calculate the adjusted rainfall, including the impact of atmospheric pressure, from rain gauge No. 1 during the period from January 1, 2023, to December 31, 2023.",
        "query": "SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - AtmosphericPressureHpa) / 1013.25) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】:【Filter records from RainfallData where GaugeId=1 and CollectionTime is between 2023-01-01 and 2023-12-31】  【step2】:【Calculate AdjustedRainfallMm using the formula RainfallMm * (1 + (1013.25 - AtmosphericPressureHpa)/1013.25)】  【step3】:【Project CollectionTime, RainfallMm, AtmosphericPressureHpa, and AdjustedRainfallMm for the filtered records】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1290,
        "question": "Calculate the average, minimum, and maximum atmospheric pressure of rain gauge No. 1 from January 1, 2023, to December 31, 2023.",
        "query": "SELECT GaugeId, AVG(AtmosphericPressureHpa) AS AvgPressure, MIN(AtmosphericPressureHpa) AS MinPressure, MAX(AtmosphericPressureHpa) AS MaxPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;",
        "step": "【step1】: Filter data from RainfallData where GaugeId=1 and CollectionTime is within the specified date range.  【step2】: Aggregate filtered data by GaugeId, calculate AVG, MIN, and MAX of AtmosphericPressureHpa.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1291,
        "question": "Based on the atmospheric pressure data from rain gauge No. 1 collected between January 1, 2023 and December 31, 2023, determine whether it may potentially cause equipment failure.",
        "query": "SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能引发设备故障' ELSE '大气压力在正常范围内' END AS FaultRisk FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter records from RainfallData for GaugeId=1 within specified time range (2023-01-01 to 2023-12-31)  【step2】: Apply conditional logic using CASE to evaluate AtmosphericPressureHpa values against thresholds (800-1100 hPa)  【step3】: Format output with CollectionTime, raw pressure data, and fault risk classification",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1292,
        "question": "Assuming that the atmospheric pressure at rain gauge No. 1 was 2000 hPa from 2023-01-01 to 2023-12-31, calculate the adjusted rainfall and analyze the potential impact on data collection.",
        "query": "SELECT CollectionTime, RainfallMm, 2000 AS AssumedAtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - 2000) / 1013.25) AS AdjustedRainfallMm, CASE WHEN 2000 < 800 OR 2000 > 1100 THEN '可能引发设备故障或数据失真' ELSE '大气压力在正常范围内' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter data from RainfallData table for GaugeId=1 within specified time range, retrieving CollectionTime and RainfallMm.  【step2】: Calculate AdjustedRainfallMm using atmospheric pressure compensation formula: RainfallMm * (1 + (1013.25-2000)/1013.25).  【step3】: Evaluate pressure validity via CASE statement and output PotentialImpact (\"可能引发设备故障或数据失真\" when pressure exceeds 800-1100hpa range).",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1293,
        "question": "Calculate the adjusted temperature, accounting for atmospheric pressure, for rain gauge No. 1 during the year 2023.",
        "query": "SELECT CollectionTime, TemperatureCelsius, AtmosphericPressureHpa, TemperatureCelsius * (1 + AtmosphericPressureHpa / 1013.25) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】:【Filter data for GaugeId=1 within specified time range】Extract records from RainfallData where GaugeId equals 1 and CollectionTime is between '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'.  【step2】:【Calculate pressure-adjusted temperature】Compute AdjustedTemperature using formula TemperatureCelsius * (1 + AtmosphericPressureHpa / 1013.25) to model atmospheric pressure's influence.  【step3】:【Return structured results】Select CollectionTime, raw TemperatureCelsius, AtmosphericPressureHpa, and the calculated AdjustedTemperature for analysis.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1294,
        "question": "Calculate the maximum and minimum atmospheric pressure values for rain gauge number 1 during the year 2023.",
        "query": "SELECT GaugeId, MAX(AtmosphericPressureHpa) AS MaxPressure, MIN(AtmosphericPressureHpa) AS MinPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;",
        "step": "【step1】: Filter records from RainfallData where GaugeId=1 and CollectionTime is between 2023-01-01 00:00:00 and 2023-12-31 23:59:59  【step2】: Apply MAX() and MIN() aggregate functions on AtmosphericPressureHpa column from the filtered dataset  【step3】: Select GaugeId with aggregated results grouped by GaugeId to produce final output",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1295,
        "question": "Based on the atmospheric pressure readings from rain gauge No. 1 during 2023, determine whether it may affect the normal operation of the equipment.",
        "query": "SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能影响设备正常运行' ELSE '大气压力在正常范围内' END AS OperationalImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】: Filter records for GaugeId=1 within the specified timeframe using WHERE clause.  【step2】: Apply CASE expression to evaluate atmospheric pressure anomalies (below 800hPa or above 1100hPa).  【step3】: Project CollectionTime, AtmosphericPressureHpa, and generated OperationalImpact status.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1296,
        "question": "Assuming that the atmospheric pressure measured by rain gauge No. 1 reaches 3000 hectopascals over a period between 2023-01-01 00:00:00 and 2023-12-31 23:59:59, calculate its impact on temperature and analyze the potential effects on data collection.",
        "query": "SELECT GaugeId, CollectionTime, AtmosphericPressureHpa, TemperatureCelsius, (TemperatureCelsius * (1 + 3000 / 1013.25)) AS EstimatedTemperature, CASE WHEN AtmosphericPressureHpa = 3000 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
        "step": "【step1】:【Filter RainfallData records for GaugeId=1 within 2023 and AtmosphericPressureHpa=3000】  【step2】:【Calculate EstimatedTemperature using TemperatureCelsius*(1+3000/1013.25)】  【step3】:【Apply CASE condition to flag data impact based on pressure threshold】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1297,
        "question": "Calculate the estimated rainfall amount when the actual rainfall exceeds the threshold for the Heavy Rainfall Alert rule.",
        "query": "SELECT RuleName, ThresholdValue, RainfallMm, (RainfallMm * (1 + ThresholdValue / 100)) AS EstimatedRainfall FROM RainfallWarningRule JOIN RainfallData ON RainfallWarningRule.ParameterType = '降雨量' AND RainfallData.RainfallMm > RainfallWarningRule.ThresholdValue WHERE RainfallWarningRule.RuleName = 'Heavy Rainfall Alert';",
        "step": "【step1】: Filter RainfallWarningRule entries where RuleName is 'Heavy Rainfall Alert' and ParameterType is '降雨量'.  【step2】: Perform an INNER JOIN with RainfallData, retaining only records where RainfallMm exceeds the ThresholdValue from the filtered rules.  【step3】: Compute EstimatedRainfall using the formula `RainfallMm * (1 + ThresholdValue / 100)` and output RuleName, ThresholdValue, RainfallMm, and EstimatedRainfall.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1298,
        "question": "Calculate the Pearson correlation coefficient between the rainfall threshold and rainfall intensity for the Heavy Rainfall Alert.",
        "query": "WITH ThresholdData AS (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = '降雨量'), IntensityData AS (SELECT RainfallIntensityMmH FROM RainfallData) SELECT (SUM((ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData)) * (RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData))) / (SQRT(SUM(POWER(ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData), 2)) * SUM(POWER(RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData), 2))))) AS PearsonCorrelation FROM ThresholdData, IntensityData;",
        "step": "【step1】: Retrieve threshold values for 'Heavy Rainfall Alert' from RainfallWarningRule table using a CTE (ThresholdData).  【step2】: Extract all rainfall intensity measurements (RainfallIntensityMmH) from RainfallData table using another CTE (IntensityData).  【step3】: Compute Pearson correlation coefficient by:  - Calculating covariance between threshold deviations and intensity deviations  - Dividing by the product of standard deviations of both datasets  - Combining cross-joined ThresholdData and IntensityData for vector operations",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1299,
        "question": "Based on the rainfall threshold in the Heavy Rainfall Alert, what is the device status?",
        "query": "SELECT RuleName, ThresholdValue, CASE WHEN ThresholdValue >= 0 AND ThresholdValue <= 1000 THEN '正常运行' ELSE '可能引发设备故障' END AS DeviceStatus FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert';",
        "step": "【step1】: Filter records from RainfallWarningRule where RuleName is 'Heavy Rainfall Alert'  【step2】: Apply CASE expression to categorize DeviceStatus based on ThresholdValue range (0-1000 = '正常运行', else '可能引发设备故障')  【step3】: Select RuleName, ThresholdValue, and computed DeviceStatus columns for output",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1300,
        "question": "Assuming the rainfall threshold in the Heavy Rainfall Alert reaches 10,000 millimeters, calculate its impact on rainfall measurements by computing adjusted rainfall values using an assumed threshold of 10,000, and analyze the potential effects on data collection based on whether the threshold exceeds the rule's stored value.",
        "query": "SELECT CollectionTime, RainfallMm, 10000 AS AssumedThresholdValue, RainfallMm * (1 + 10000 / 100) AS AdjustedRainfallMm, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = '降雨量') THEN '可能引发设备故障或数据失真' ELSE '降雨量阈值在正常范围内' END AS PotentialImpact FROM RainfallData;",
        "step": "【step1】: Retrieve rainfall data records and calculate adjusted rainfall values by applying the hypothetical 10000mm threshold multiplier (101x amplification) for all entries in RainfallData table  【step2】: Subquery execution to fetch actual rainfall threshold value from RainfallWarningRule where RuleName='Heavy Rainfall Alert' and ParameterType='降雨量'  【step3】: Compare hypothetical threshold (10000mm) with actual threshold from subquery, generating impact analysis labels through CASE statement while combining all calculated values",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1301,
        "question": "Calculate the pressure in pascals exerted on the ground by the total rainfall in the Low Rainfall Alert.",
        "query": "SELECT RuleName, TotalRainfallMm, (TotalRainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Low Rainfall Alert';",
        "step": "【step1】: Join HistoricalRainfallAnalysis with RainfallWarningRule using GaugeId=Id to associate analysis results with specific warning rules.  【step2】: Filter records where RuleName='Low Rainfall Alert' to isolate data related to low rainfall scenarios.  【step3】: Calculate PressurePa via (TotalRainfallMm * 1000 * 9.81 / 1000), converting rainfall depth (mm) to water volume (kg/m²) and applying gravitational acceleration (9.81 m/s²) to derive pressure in Pascals.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1302,
        "question": "Calculate the standard deviation of the total rainfall from operational rain gauges.",
        "query": "SELECT SQRT(SUM(POWER(TotalRainfallMm - (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');",
        "step": "【step1】: Filter active rain gauges by selecting Ids from RainGauge where Status is '运行'.  【step2】: Calculate the average TotalRainfallMm from HistoricalRainfallAnalysis using the filtered GaugeIds.  【step3】: Compute the standard deviation by evaluating squared deviations from the mean, summing them, dividing by count, and taking the square root.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1303,
        "question": "According to the total rainfall and a specific rainfall warning rule's threshold, determine whether it may trigger a flood.",
        "query": "SELECT AnalysisTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = '洪水预警' AND ParameterType = '降雨量') THEN '可能引发洪水' ELSE '总降雨量在安全范围内' END AS FloodRisk FROM HistoricalRainfallAnalysis;",
        "step": "【step1】: Retrieve TotalRainfall and analysis time from HistoricalRainfallAnalysis table  【step2】: Query ThresholdValue dynamically from RainfallWarningRule table using RuleName='洪水预警' and ParameterType='降雨量'  【step3】: Compare TotalRainfallMm with threshold using CASE statement to determine flood risk category",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1304,
        "question": "Assuming the total rainfall in the Low Rainfall Alert is -1000 millimeters, calculate the pressure it exerts on the ground and analyze its potential environmental impacts.",
        "query": "SELECT AnalysisTime, TotalRainfallMm, -1000 AS AssumedTotalRainfallMm, (-1000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Low Rainfall Alert' AND ParameterType = '降雨量') THEN '可能导致干旱或土壤干裂' ELSE '降雨量在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;",
        "step": "【step1】: Retrieve base data and calculate pressure  Extract AnalysisTime and TotalRainfallMm from HistoricalRainfallAnalysis. Embed the assumption (-1000 mm) and compute pressure using the formula: PressurePa = (-1000 * 1000 * 9.81 / 1000) to convert rainfall height (in meters) to Pascals.  【step2】: Fetch rainfall threshold via subquery  Access RainfallWarningRule to get ThresholdValue for the 'Low Rainfall Alert' rule where ParameterType = '降雨量'. This subquery dynamically determines the comparison baseline.  【step3】: Evaluate environmental impact  Compare the assumed rainfall (-1000 mm) against the retrieved threshold using CASE. If -1000 < ThresholdValue, output drought risk; otherwise, mark as normal range.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1305,
        "question": "Calculate the impact force (in newtons) of the average rainfall intensity for the Extreme Rainfall Alert rule on the ground.",
        "query": "SELECT RuleName, AverageRainfallIntensityMmH, (AverageRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Extreme Rainfall Alert';",
        "step": "【step1】:【Join HistoricalRainfallAnalysis with RainfallWarningRule using GaugeId=Id to link analysis results with warning rules】  【step2】:【Filter records where RuleName is 'Extreme Rainfall Alert' using WHERE clause】  【step3】:【Calculate ImpactForceN by multiplying AverageRainfallIntensityMmH with constants (1m² area * 1000kg/m³ water density * 9.81m/s² gravity / 3600s for hour→second conversion)】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1306,
        "question": "Calculate the standard deviation of the average rainfall intensity from operational rain gauges.",
        "query": "SELECT SQRT(SUM(POWER(AverageRainfallIntensityMmH - (SELECT AVG(AverageRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');",
        "step": "【step1】: Filter active rain gauges: Subquery selects Id from RainGauge where Status='运行' to ensure only operational devices are considered.  【step2】: Calculate average intensity: Compute the mean of AverageRainfallIntensityMmH from HistoricalRainfallAnalysis for filtered gauges.  【step3】: Compute standard deviation: Use the derived average to calculate the population standard deviation via SUM(POWER(deviation,2))/COUNT and SQRT.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1307,
        "question": "Based on the average rainfall intensity in the historical data, determine whether it may trigger urban waterlogging.",
        "query": "SELECT AnalysisTime, AverageRainfallIntensityMmH, CASE WHEN AverageRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能引发城市内涝' ELSE '降雨强度在安全范围内' END AS FloodRisk FROM HistoricalRainfallAnalysis;",
        "step": "【step1】: Retrieve the threshold value for 'Extreme Rainfall Alert' from RainfallWarningRule where ParameterType is '降雨强度'.  【step2】: Select AnalysisTime and AverageRainfallIntensityMmH from HistoricalRainfallAnalysis.  【step3】: Compare each AverageRainfallIntensityMmH with the retrieved threshold using CASE expression to determine FloodRisk classification.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1308,
        "question": "Assuming the average rainfall intensity in the Extreme Rainfall Alert reaches 1000 mm/hour, calculate the impact force it exerts on the ground and determine its potential environmental effects based on whether it exceeds the alert threshold.",
        "query": "SELECT AnalysisTime, AverageRainfallIntensityMmH, 1000 AS AssumedRainfallIntensity, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 1000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能引发洪水或土壤侵蚀' ELSE '降雨强度在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;",
        "step": "【step1】: Retrieve analysis time and average rainfall intensity from HistoricalRainfallAnalysis, while calculating impact force using the formula (1000*1*1000*9.81/3600) for assumed rainfall intensity  【step2】: Subquery extracts threshold value from RainfallWarningRule where RuleName='Extreme Rainfall Alert' and ParameterType='降雨强度'  【step3】: Compare assumed rainfall intensity (1000mm/h) with threshold using CASE statement to determine environmental impact description",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1309,
        "question": "Calculate the impact force exerted by the maximum rainfall intensity in the Light Rainfall Alert on the ground.",
        "query": "SELECT RuleName, MaxRainfallIntensityMmH, (MaxRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Light Rainfall Alert';",
        "step": "【step1】:【JOIN HistoricalRainfallAnalysis with RainfallWarningRule using GaugeId=Id to filter records under 'Light Rainfall Alert' rule】  【step2】:【Calculate maximum rainfall intensity's impact force using formula (MaxRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) for qualifying records】  【step3】:【Select RuleName, MaxRainfallIntensityMmH, and computed ImpactForceN for final output】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1310,
        "question": "Calculate the standard deviation of the maximum rainfall intensity from operational rain gauges.",
        "query": "SELECT SQRT(SUM(POWER(MaxRainfallIntensityMmH - (SELECT AVG(MaxRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');",
        "step": "【step1】: 【Filter active rain gauges】 Retrieve Ids of rain gauges with Status = '运行' from RainGauge to ensure only operational devices are considered.  【step2】: 【Calculate average max rainfall intensity】 Compute the average of MaxRainfallIntensityMmH from HistoricalRainfallAnalysis using the filtered GaugeIds.  【step3】: 【Compute standard deviation】 Calculate the standard deviation of MaxRainfallIntensityMmH by determining the square root of the average squared deviation from the mean.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1311,
        "question": "Based on the historical maximum rainfall intensity, determine whether it may affect outdoor activities.",
        "query": "SELECT AnalysisTime, MaxRainfallIntensityMmH, CASE WHEN MaxRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能影响户外活动' ELSE '降雨强度在安全范围内' END AS OutdoorActivityImpact FROM HistoricalRainfallAnalysis;",
        "step": "【step1】: Retrieve maximum rainfall intensity and analysis time from HistoricalRainfallAnalysis table  【step2】: Subquery to fetch rainfall intensity threshold from RainfallWarningRule where RuleName='Light Rainfall Alert' and ParameterType='降雨强度'  【step3】: Apply CASE statement to compare MaxRainfallIntensityMmH with threshold value and determine outdoor activity impact",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1312,
        "question": "Assuming the maximum rainfall intensity in the Light Rainfall Alert reaches 10,000 millimeters per hour, calculate the impact force it generates on the ground and determine the environmental impact based on whether this intensity exceeds the alert threshold.",
        "query": "SELECT AnalysisTime, MaxRainfallIntensityMmH, 10000 AS AssumedMaxRainfallIntensity, (10000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能引发洪水或土壤侵蚀' ELSE '降雨强度在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;",
        "step": "【step1】: Retrieve maximum rainfall intensity and analysis time from HistoricalRainfallAnalysis table, while setting a hardcoded assumption of 10000 mm/h rainfall intensity  【step2】: Calculate impact force using physics formula (10000 * 1 * 1000 * 9.81 / 3600) and compare against threshold through subquery (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = '降雨强度')  【step3】: Apply CASE statement to determine environmental impact based on threshold comparison and format final output columns (AnalysisTime, MaxRainfallIntensityMmH, AssumedMaxRainfallIntensity, ImpactForceN, EnvironmentalImpact)",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1313,
        "question": "Calculate the impact force on the ground caused by the minimum rainfall intensity in the Moderate Rainfall Intensity Alert.",
        "query": "SELECT RuleName, MinRainfallIntensityMmH, (MinRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Moderate Rainfall Intensity Alert';",
        "step": "【step1】: Filter the RainfallWarningRule table to retrieve the \"Moderate Rainfall Intensity Alert\" rule and obtain its associated Id.  【step2】: Join HistoricalRainfallAnalysis with the filtered rule using GaugeId = Id to access the MinRainfallIntensityMmH field.  【step3】: Calculate the impact force using the formula (MinRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) and return RuleName, MinRainfallIntensityMmH, and ImpactForceN.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1314,
        "question": "Calculate the standard deviation of the minimum rainfall intensity from operational rain gauges in the HistoricalRainfallAnalysis dataset.",
        "query": "SELECT SQRT(SUM(POWER(MinRainfallIntensityMmH - (SELECT AVG(MinRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');",
        "step": "【step1】: Filter active rain gauges by selecting IDs from RainGauge where Status = '运行'  【step2】: Calculate the average MinRainfallIntensityMmH from HistoricalRainfallAnalysis for filtered gauges  【step3】: Compute standard deviation of MinRainfallIntensityMmH using deviations from this average",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1315,
        "question": "Based on the minimum rainfall intensity in the Moderate Rainfall Intensity Alert, return the analysis results.",
        "query": "SELECT HRA.AnalysisResult FROM HistoricalRainfallAnalysis HRA JOIN RainfallWarningRule RWR ON HRA.GaugeId = RWR.Id WHERE RWR.RuleName = 'Moderate Rainfall Intensity Alert' AND HRA.MinRainfallIntensityMmH < 5;",
        "step": "【step1】: Join HistoricalRainfallAnalysis(HRA) with RainfallWarningRule(RWR) using GaugeId=Id, filter for RWR.RuleName='Moderate Rainfall Intensity Alert'  【step2】: Apply condition HRA.MinRainfallIntensityMmH < 5 to identify rainfall intensity below 5mm/h threshold  【step3】: Select HRA.AnalysisResult to retrieve impact assessment on crop growth from qualified records",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1316,
        "question": "Assuming the minimal rainfall intensity in the HistoricalRainfallAnalysis data is -1000 mm/hour, calculate its impact force on the ground and analyze its potential environmental effects.",
        "query": "SELECT AnalysisTime, MinRainfallIntensityMmH, -1000 AS AssumedMinRainfallIntensity, (-1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Moderate Rainfall Intensity Alert' AND ParameterType = '降雨强度') THEN '可能导致干旱或土壤干裂' ELSE '降雨强度在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;",
        "step": "【step1】: Retrieve historical rainfall analysis records and static warning threshold  Extract AnalysisTime and MinRainfallIntensityMmH from HistoricalRainfallAnalysis, simultaneously query the rainfall intensity threshold from RainfallWarningRule for \"Moderate Rainfall Intensity Alert\"  【step2】: Calculate hypothetical impact force  Compute ImpactForceN using physics formula:  ImpactForceN = (-1000 * 1 * 1000 * 9.81 / 3600)  (Assumes water density=1000kg/m³, area=1m², converts mm/h to m/s via /3600)  【step3】: Perform conditional environmental impact assessment  Compare -1000 mm/h with threshold using CASE:  IF -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE ...)  THEN return drought warning  ELSE return normal status",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1317,
        "question": "Calculate the pressure in Pascals exerted by the rainfall on the ground based on the rainfall amount and collection time.",
        "query": "SELECT CollectionTime, RainfallMm, (RainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData;",
        "step": "【step1】:【Select CollectionTime and RainfallMm from RainfallData to retrieve basic rainfall measurements.】  【step2】:【Convert RainfallMm to water volume in liters per square meter (1mm rainfall = 1L/m²) and multiply by water density (1000 kg/m³) and gravitational acceleration (9.81 m/s²) to calculate force.】  【step3】:【Divide the result by 1000 to convert the force to Pascals (Pa) and alias it as PressurePa.】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1318,
        "question": "Calculate the Pearson correlation coefficient between rainfall and rainfall intensity in the precipitation monitoring data.",
        "query": "WITH RainfallStats AS (SELECT RainfallMm AS X, RainfallIntensityMmH AS Y, AVG(RainfallMm) OVER () AS X_avg, AVG(RainfallIntensityMmH) OVER () AS Y_avg FROM RainfallData) SELECT (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM(POWER(X - X_avg, 2)) * SUM(POWER(Y - Y_avg, 2))))) AS PearsonCorrelation FROM RainfallStats;",
        "step": "【step1】: Calculate average rainfall (X_avg) and rainfall intensity (Y_avg) across all records using window functions.  【step2】: Compute deviations from the mean for each data point [(X - X_avg), (Y - Y_avg)], derive cross-products and squared deviations for correlation components.  【step3】: Aggregate results to calculate Pearson correlation coefficient by summing cross-products, normalizing with the product of summed squared deviations.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1319,
        "question": "Based on rainfall data from a certain rain monitoring station, determine the flood risk level for each collection time.",
        "query": "SELECT CollectionTime, RainfallMm, CASE WHEN RainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨量' AND RuleName = '洪水预警') THEN '可能引发洪水' ELSE '洪水风险较低' END AS FloodRisk FROM RainfallData;",
        "step": "【step1】: Retrieve the flood warning threshold value from RainfallWarningRule where ParameterType is 'rainfall' and RuleName is 'flood warning'  【step2】: Fetch all rainfall data records (CollectionTime and RainfallMm) from RainfallData  【step3】: Compare each rainfall value with the threshold and assign flood risk status using CASE expression",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1320,
        "question": "Assuming the rainfall in a precipitation monitoring dataset reaches or exceeds 10,000 millimeters, calculate its pressure on the ground and analyze its potential environmental impact.",
        "query": "SELECT CollectionTime, RainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨量' AND ConditionOperator = '>' AND IsActive = TRUE) THEN '可能导致洪水或土壤侵蚀' ELSE '降雨量在正常范围内' END AS EnvironmentalImpact FROM RainfallData WHERE RainfallMm >= 10000;",
        "step": "【step1】: Filter RainfallData records where rainfall exceeds 10,000mm (WHERE RainfallMm >= 10000)  【step2】: Calculate hydrostatic pressure using formula (10000mm × 1000kg/m³ × 9.81m/s² ÷ 1000) → PressurePa  【step3】: Subquery checks active threshold from RainfallWarningRule (ParameterType='降雨量', ConditionOperator='>'), then CASE determines environmental impact based on threshold comparison",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1321,
        "question": "Calculate the estimated atmospheric pressure incorporating humidity effects from rainfall monitoring data.",
        "query": "SELECT CollectionTime, HumidityPercent, AtmosphericPressureHpa, (HumidityPercent * 0.01 * AtmosphericPressureHpa) + ((1 - HumidityPercent * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa FROM RainfallData;",
        "step": "【step1】: Select CollectionTime, HumidityPercent, and AtmosphericPressureHpa from RainfallData to retrieve raw monitoring data.  【step2】: Calculate EstimatedPressureHpa using the formula (HumidityPercent*0.01*AtmosphericPressureHpa) + ((1-HumidityPercent*0.01)*AtmosphericPressureHpa), representing humidity's weighted contribution to pressure.  【step3】: Output results with CollectionTime, original humidity/pressure values, and the derived EstimatedPressureHpa for analysis.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1322,
        "question": "Calculate the Pearson correlation coefficient between humidity and wind speed in the rainfall monitoring data.",
        "query": "WITH HumidityWindStats AS (SELECT HumidityPercent AS X, WindSpeedMps AS Y, AVG(HumidityPercent) OVER () AS X_avg, AVG(WindSpeedMps) OVER () AS Y_avg FROM RainfallData) SELECT (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM(POWER(X - X_avg, 2)) * SUM(POWER(Y - Y_avg, 2))))) AS PearsonCorrelation FROM HumidityWindStats;",
        "step": "【step1】: Create a CTE (HumidityWindStats) that calculates the global averages of humidity (X_avg) and wind speed (Y_avg) using window functions, while preserving raw humidity (X) and wind speed (Y) values for each data point.  【step2】: Compute the covariance numerator SUM((X - X_avg) * (Y - Y_avg)) and the squared deviations SUM((X - X_avg)^2) and SUM((Y - Y_avg)^2) for variance calculations.  【step3】: Calculate Pearson’s correlation coefficient by dividing the covariance by the product of the square roots of the summed squared deviations (standard deviations).",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1323,
        "question": "Based on the humidity and wind speed data from a certain rainfall monitoring system, determine the fault risk, indicating whether equipment failure might be triggered or if the equipment is operating normally.",
        "query": "SELECT GaugeId, CollectionTime, HumidityPercent, WindSpeedMps, CASE WHEN HumidityPercent > 90 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '设备工作正常' END AS FaultRisk FROM RainfallData;",
        "step": "【step1】: Retrieve necessary fields from RainfallData table (GaugeId, CollectionTime, HumidityPercent, WindSpeedMps).  【step2】: Apply CASE expression to evaluate humidity (>90%) OR wind speed (>20m/s) conditions for fault risk assessment.  【step3】: Return final result set with calculated FaultRisk column indicating potential device failure or normal status.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1324,
        "question": "Assuming that in a certain rainfall monitoring data, the humidity reaches 200% or the wind speed reaches 100 meters per second, describe its impact on data collection and indicate whether atmospheric pressure is calculated or directly measured.",
        "query": "SELECT CollectionTime, HumidityPercent, WindSpeedMps, AtmosphericPressureHpa, (200 * 0.01 * AtmosphericPressureHpa) + ((1 - 200 * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 OR WindSpeedMps = 100 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData;",
        "step": "【step1】: Select core fields including CollectionTime, HumidityPercent, WindSpeedMps, and AtmosphericPressureHpa from RainfallData  【step2】: Calculate EstimatedPressureHpa using the formula (200 * 0.01 * AtmosphericPressureHpa) + ((1 - 200 * 0.01) * AtmosphericPressureHpa)  【step3】: Apply CASE-WHEN logic to create DataImpact flag based on HumidityPercent=200 OR WindSpeedMps=100 conditions",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1325,
        "question": "Calculate the adjusted rainfall amount considering wind speed for a specific rainfall gauge in the dataset.",
        "query": "SELECT RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfall FROM RainfallData WHERE GaugeId = '特定雨量计ID';",
        "step": "【step1】:【Filter records for the specific rain gauge using WHERE GaugeId='特定雨量计ID'】  【step2】:【Extract raw rainfall (RainfallMm) and wind speed (WindSpeedMps) values from RainfallData】  【step3】:【Calculate AdjustedRainfall by applying the formula RainfallMm * (1 + WindSpeedMps / 10) to quantify wind speed's influence on rainfall distribution】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1326,
        "question": "Calculate the average value of wind speed in rainfall monitoring data and its moving average trend over the last 10 data points.",
        "query": "WITH WindSpeedStats AS (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints FROM RainfallData), WindSpeedTrend AS (SELECT CollectionTime, WindSpeedMps, AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats, WindSpeedTrend;",
        "step": "【step1】: Compute overall average wind speed and data point count using CTE WindSpeedStats by aggregating all records in RainfallData.  【step2】: Calculate time-based moving average of wind speed (11-row sliding window) via CTE WindSpeedTrend using window function over ordered CollectionTime.  【step3】: Combine aggregated statistics (single-row) with time-series trend data (multiple rows) through cross join to output both global average and temporal trend metrics.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1327,
        "question": "Based on the wind speed and direction data from a certain rainfall monitoring station, determine whether it is likely to cause equipment failure.",
        "query": "SELECT CollectionTime, WindSpeedMps, WindDirectionDegrees, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Select CollectionTime, WindSpeedMps, and WindDirectionDegrees from RainfallData table  【step2】: Apply CASE expression to check four conditions: WindSpeedMps < 0, WindSpeedMps > 20, WindDirectionDegrees < 0, WindDirectionDegrees > 360  【step3】: Generate DeviceStatus column that returns '可能引发设备故障' if any condition is met, otherwise returns '设备运行正常'",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1328,
        "question": "Assuming the wind speed in a certain rainfall monitoring data reaches 100 meters per second or the wind direction reaches 720 degrees, identify the data impact and calculate the adjusted rainfall.",
        "query": "SELECT CollectionTime, RainfallMm, (RainfallMm * (1 + 100 / 10)) AS AdjustedRainfallMm, CASE WHEN WindSpeedMps >= 100 OR WindDirectionDegrees >= 720 THEN '可能导致设备损坏或数据失真' ELSE '风速和风向在正常范围内' END AS DataImpact FROM RainfallData WHERE WindSpeedMps >= 100 OR WindDirectionDegrees >= 720;",
        "step": "【step1】: Filter records where wind speed exceeds 100 m/s or wind direction exceeds 720 degrees using WHERE clause (WindSpeedMps >= 100 OR WindDirectionDegrees >= 720).  【step2】: Calculate adjusted rainfall values by multiplying original RainfallMm with (1 + wind speed / 10) formula (RainfallMm * (1 + 100 / 10)).  【step3】: Evaluate data integrity impact through CASE statement, marking \"可能导致设备损坏或数据失真\" for records meeting extreme wind criteria and \"风速和风向在正常范围内\" for others.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1329,
        "question": "Calculate the adjusted atmospheric pressure based on wind direction for a specific rainfall gauge.",
        "query": "SELECT WindDirectionDegrees, AtmosphericPressureHpa, AtmosphericPressureHpa * (1 + WindDirectionDegrees / 360) AS AdjustedPressure FROM RainfallData WHERE GaugeId = '特定雨量计ID';",
        "step": "【step1】: Filter data by specific gauge (WHERE GaugeId = '特定雨量计ID') to isolate relevant meteorological measurements.  【step2】: Select base parameters - original WindDirectionDegrees and AtmosphericPressureHpa values from RainfallData.  【step3】: Calculate adjusted pressure using (AtmosphericPressureHpa * (1 + WindDirectionDegrees / 360)) to model directional influence proportionally across 360-degree compass.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1330,
        "question": "Calculate the average wind direction in a certain rainfall monitoring data and analyze its trend of change by showing the moving average over the latest 11 data points.",
        "query": "WITH WindDirectionStats AS (SELECT AVG(WindDirectionDegrees) AS AvgWindDirection, COUNT(*) AS DataPoints FROM RainfallData), WindDirectionTrend AS (SELECT CollectionTime, WindDirectionDegrees, AVG(WindDirectionDegrees) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindDirection, MovingAvg FROM WindDirectionStats, WindDirectionTrend;",
        "step": "【step1】: Compute overall average wind direction and total data points using WindDirectionStats CTE by aggregating all records in RainfallData.  【step2】: Calculate moving average trend via WindDirectionTrend CTE using window function (10 preceding rows) ordered by CollectionTime to track temporal variation.  【step3】: Combine aggregated statistics and trend data via cross join (Cartesian product) between CTEs, outputting both static average and dynamic moving averages.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1331,
        "question": "Based on the wind direction and atmospheric pressure data from a certain rainfall monitoring system, determine whether it may potentially cause equipment failure, considering wind direction values outside 0-360 degrees or atmospheric pressure values outside 800-1100 hPa as potential causes.",
        "query": "SELECT CollectionTime, WindDirectionDegrees, AtmosphericPressureHpa, CASE WHEN WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Retrieve raw data fields from RainfallData table including CollectionTime, WindDirectionDegrees, and AtmosphericPressureHpa.  【step2】: Apply conditional logic using CASE expression to check if:  - WindDirectionDegrees falls outside valid range (0-360 degrees)  - AtmosphericPressureHpa exceeds operational thresholds (800-1100 hPa)  【step3】: Generate DeviceStatus classification based on combined conditions:  '可能引发设备故障' when any parameter is abnormal  '设备运行正常' when both parameters are within valid ranges",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1332,
        "question": "Assuming that in a certain rainfall monitoring data the wind direction reaches 720 degrees or the atmospheric pressure reaches 2000 hPa, calculate its impact on atmospheric pressure and analyze its potential effects on data collection.",
        "query": "SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa * (1 + 720 / 360)) AS AdjustedAtmosphericPressureHpa, CASE WHEN WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000 THEN '可能导致设备损坏或数据失真' ELSE '风向和大气压力在正常范围内' END AS DataImpact FROM RainfallData WHERE WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000;",
        "step": "【step1】: Data filtering using WHERE clause to retrieve records where wind direction exceeds 720 degrees or atmospheric pressure reaches 2000 hPa  【step2】: Calculate adjusted atmospheric pressure by multiplying original value with (1 + 720/360) factor (+100% pressure increase due to invalid wind direction)  【step3】: Apply CASE expression to flag abnormal records as potential equipment damage/distortion while labeling others as normal",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1333,
        "question": "Calculating the impact of rainfall on temperature in precipitation monitoring data for gauge ID 1.",
        "query": "SELECT RainfallMm, TemperatureCelsius, TemperatureCelsius - (RainfallMm / 10) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = '1';",
        "step": "【step1】: Filter data for the specific rain gauge (GaugeId = '1') from the RainfallData table.  【step2】: Calculate the adjusted temperature by subtracting rainfall (divided by 10) from the recorded temperature (TemperatureCelsius - (RainfallMm / 10)).  【step3】: Project the columns RainfallMm, TemperatureCelsius, and the calculated AdjustedTemperature as the final result.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1334,
        "question": "Calculate the average rainfall and the 10-day moving average of rainfall over time in a certain rainfall monitoring data set.",
        "query": "WITH RainfallStats AS (SELECT AVG(RainfallMm) AS AvgRainfall, COUNT(*) AS DataPoints FROM RainfallData), RainfallTrend AS (SELECT CollectionTime, RainfallMm, AVG(RainfallMm) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgRainfall, MovingAvg FROM RainfallStats, RainfallTrend;",
        "step": "【step1】: Calculate the overall average rainfall (AvgRainfall) and total data points count (DataPoints) from RainfallData table using the RainfallStats CTE.  【step2】: Compute 10-row sliding window moving averages (MovingAvg) for each rainfall measurement ordered by collection time using the RainfallTrend CTE with window function.  【step3】: Combine the static average (AvgRainfall) with dynamic moving averages (MovingAvg) through cross join between aggregated stats and trend data, creating a Cartesian product to display both metrics simultaneously.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1335,
        "question": "Based on the rainfall and temperature data from a certain rainfall monitoring system, determine the device status, indicating whether it is likely to cause equipment failure or if the equipment is operating normally.",
        "query": "SELECT CollectionTime, RainfallMm, TemperatureCelsius, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR TemperatureCelsius < -20 OR TemperatureCelsius > 50 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Retrieve CollectionTime, RainfallMm, and TemperatureCelsius from RainfallData  【step2】: Evaluate conditions (Rainfall < 0 OR > 1000 OR Temperature < -20 OR > 50) using CASE  【step3】: Assign '可能引发设备故障' or '设备运行正常' as DeviceStatus based on evaluation",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1336,
        "question": "Assuming that rainfall in a certain precipitation monitoring data reaches 10,000 millimeters or the temperature reaches 1,000 degrees Celsius, calculate its impact on temperature, and analyze its potential effects on data collection.",
        "query": "SELECT CollectionTime, TemperatureCelsius, (TemperatureCelsius - (10000 / 10)) AS AdjustedTemperatureCelsius, CASE WHEN RainfallMm >= 10000 OR TemperatureCelsius >= 1000 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和温度在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR TemperatureCelsius >= 1000;",
        "step": "【step1】: Filter data with extreme conditions (Rainfall >=10000mm OR Temperature >=1000°C) using WHERE clause  【step2】: Calculate adjusted temperature by subtracting 1000°C (10000mm/10) from recorded temperature  【step3】: Apply impact analysis through CASE statement to mark records meeting extreme conditions as potential data corruption/equipment damage",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1337,
        "question": "Calculating the adjusted humidity by incorporating rainfall influence for gauge 1 in a rainfall monitoring dataset.",
        "query": "SELECT RainfallMm, HumidityPercent, HumidityPercent + (RainfallMm / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '1';",
        "step": "【step1】: Filter data from the RainfallData table for the specific rain gauge (GaugeId = '1') to isolate relevant entries.  【step2】: Calculate the AdjustedHumidity by adding the original HumidityPercent value to RainfallMm divided by 10, while selecting the required columns (RainfallMm, HumidityPercent, and AdjustedHumidity).",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1338,
        "question": "Calculate the average humidity in certain rainfall monitoring data and compare it with the moving average trend.",
        "query": "WITH HumidityStats AS (SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints FROM RainfallData), HumidityTrend AS (SELECT CollectionTime, HumidityPercent, AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgHumidity, MovingAvg FROM HumidityStats, HumidityTrend;",
        "step": "【step1】: Calculate basic humidity statistics (average humidity and total data points) from the RainfallData table using a CTE.  【step2】: Compute the moving average of humidity (over 10 preceding rows) ordered by collection time using a window function in the second CTE.  【step3】: Combine the aggregated statistics (static average) with the time-series trend data (moving average) via a cross join between both CTEs.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1339,
        "question": "Based on the rainfall and humidity data from a certain rainfall monitoring station, determine the equipment status, indicating whether it is running normally or if a failure may be triggered.",
        "query": "SELECT CollectionTime, RainfallMm, HumidityPercent, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Retrieve raw sensor data columns (CollectionTime, RainfallMm, HumidityPercent) from RainfallData table  【step2】: Apply CASE expression to check if rainfall/humidity exceed physical measurement ranges (RainfallMm<0 OR>1000mm, HumidityPercent<0% OR>100%)  【step3】: Generate DeviceStatus labels ('可能引发设备故障'/'设备运行正常') based on anomaly thresholds",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1340,
        "question": "Assuming the rainfall in a certain precipitation monitoring data reaches 10,000 millimeters or the humidity reaches 200%, calculate its impact on humidity and analyze the potential effects on data collection.",
        "query": "SELECT CollectionTime, HumidityPercent, (HumidityPercent + (10000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallMm >= 10000 OR HumidityPercent >= 200 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和湿度在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR HumidityPercent >= 200;",
        "step": "【step1】: Filter data where rainfall is ≥10000mm or humidity ≥200% using the WHERE clause to identify extreme conditions.  【step2】: Calculate AdjustedHumidityPercent by adding 1000 (10000mm/10) to the original humidity percentage, simulating overflow impact.  【step3】: Use CASE expression to label potential impacts (\"可能导致设备损坏或数据失真\") when thresholds are exceeded, ensuring result clarity for abnormal data collection scenarios.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1341,
        "question": "Calculate the impact of rainfall on wind speed for GaugeId '1' in the RainfallData dataset.",
        "query": "SELECT RainfallMm, WindSpeedMps, WindSpeedMps + (RainfallMm / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '1';",
        "step": "【step1】:【Filter data from RainfallData where GaugeId = '1' to isolate records from the specific rain gauge.】  【step2】:【Compute AdjustedWindSpeed by adding one-tenth of RainfallMm (RainfallMm / 10) to the original WindSpeedMps for each record.】  【step3】:【Select RainfallMm, WindSpeedMps, and the calculated AdjustedWindSpeed to display the relationship between rainfall and adjusted wind speed.】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1342,
        "question": "Calculate the average wind speed from rainfall monitoring data and analyze its trend of change using a moving average.",
        "query": "WITH WindSpeedStats AS (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints FROM RainfallData), WindSpeedTrend AS (SELECT CollectionTime, WindSpeedMps, AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats, WindSpeedTrend;",
        "step": "【step1】: Create WindSpeedStats CTE to calculate average wind speed and total data points using AVG() and COUNT() from RainfallData  【step2】: Create WindSpeedTrend CTE to calculate 10-row moving average wind speed using window function (AVG OVER with ROWS BETWEEN) ordered by CollectionTime  【step3】: Cross join both CTEs to combine overall average (static scalar) with time-series moving averages (multiple rows) in final output",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1343,
        "question": "Based on rainfall and wind speed data from a certain rainfall monitoring system, determine the status of the equipment, indicating 'May cause equipment failure' or 'Equipment running normally'.",
        "query": "SELECT CollectionTime, RainfallMm, WindSpeedMps, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Select CollectionTime, RainfallMm, WindSpeedMps from RainfallData  【step2】: Apply conditional checks: RainfallMm < 0 OR RainfallMm > 1000 for rainfall anomalies, WindSpeedMps < 0 OR WindSpeedMps > 20 for wind anomalies  【step3】: Generate DeviceStatus via CASE WHEN to flag '可能引发设备故障' if any anomaly; ELSE '设备运行正常'",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1344,
        "question": "Assuming the rainfall data in a precipitation monitoring system records rainfall reaching 10,000 millimeters or wind speed reaching 100 meters per second, identify the data impact and adjusted wind speed values.",
        "query": "SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (10000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallMm >= 10000 OR WindSpeedMps >= 100 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和风速在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindSpeedMps >= 100;",
        "step": "【step1】: Filter records from RainfallData where rainfall exceeds 10,000mm or wind speed exceeds 100m/s using WHERE clause with OR conditions.  【step2】: Calculate adjusted wind speed by adding 1,000m/s (10,000mm rainfall divided by 10) to measured WindSpeedMps.  【step3】: Use CASE expression to flag records with extreme values as potential data integrity risks or mark normal conditions.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1345,
        "question": "Calculate the adjusted wind direction by adding the rainfall divided by 10 to the original wind direction for gauge ID 1 in the RainfallData table.",
        "query": "SELECT RainfallMm, WindDirectionDegrees, WindDirectionDegrees + (RainfallMm / 10) AS AdjustedWindDirection FROM RainfallData WHERE GaugeId = '1';",
        "step": "【step1】: Filter data for GaugeId '1' to focus on specific rainfall monitoring records.  【step2】: Select RainfallMm and WindDirectionDegrees values from the filtered dataset.  【step3】: Compute AdjustedWindDirection by adding RainfallMm/10 to WindDirectionDegrees, representing rainfall's hypothetical directional influence.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1346,
        "question": "Calculate the total sum of rainfall in a certain precipitation monitoring dataset and show the cumulative rainfall over time.",
        "query": "WITH RainfallTotal AS (SELECT SUM(RainfallMm) AS TotalRainfall FROM RainfallData), RainfallTrend AS (SELECT CollectionTime, RainfallMm, SUM(RainfallMm) OVER (ORDER BY CollectionTime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CumulativeRainfall FROM RainfallData) SELECT TotalRainfall, CumulativeRainfall FROM RainfallTotal, RainfallTrend;",
        "step": "【step1】: Calculate total rainfall using SUM(RainfallMm) aggregation in RainfallTotal CTE.  【step2】: Compute cumulative rainfall trend via window function SUM() OVER(ORDER BY CollectionTime) in RainfallTrend CTE.  【step3】: Combine total rainfall and cumulative trend data through CROSS JOIN between CTEs to align aggregated totals with time-series progression.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1347,
        "question": "Based on the rainfall and wind direction data from a certain rainfall monitoring system, determine whether it may trigger equipment failure.",
        "query": "SELECT CollectionTime, RainfallMm, WindDirectionDegrees, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Retrieve raw monitoring data fields (CollectionTime, RainfallMm, WindDirectionDegrees) from RainfallData table  【step2】: Apply conditional logic to validate parameter ranges - RainfallMm (<0 OR >1000mm) and WindDirectionDegrees (<0° OR >360°)  【step3】: Generate DeviceStatus labels using CASE expression based on validation results ('可能引发设备故障' for invalid ranges, '设备运行正常' otherwise)",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1348,
        "question": "Assuming a rainfall monitoring data shows precipitation reaching 10,000 millimeters and wind direction reaching 720 degrees, calculate its impact on wind direction, display both the original and adjusted wind direction, and analyze the potential effects on data collection.",
        "query": "SELECT CollectionTime, WindDirectionDegrees, (WindDirectionDegrees + (10000 / 10)) AS AdjustedWindDirectionDegrees, CASE WHEN RainfallMm >= 10000 OR WindDirectionDegrees >= 720 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和风向在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindDirectionDegrees >= 720;",
        "step": "【step1】: Filter records from RainfallData where RainfallMm ≥ 10000 or WindDirectionDegrees ≥ 720 using the WHERE clause.  【step2】: Calculate AdjustedWindDirectionDegrees by adding 1000 (10000/10) to WindDirectionDegrees for qualifying records.  【step3】: Generate DataImpact column via CASE expression to flag potential device/data issues based on extreme RainfallMm or WindDirectionDegrees values.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1349,
        "question": "Calculate the impact of rainfall on atmospheric pressure for a specific rain gauge in the rainfall monitoring dataset.",
        "query": "SELECT RainfallMm, AtmosphericPressureHpa, AtmosphericPressureHpa - (RainfallMm / 10) AS AdjustedPressure FROM RainfallData WHERE GaugeId = '特定雨量计ID';",
        "step": "【step1】: Filter records for the specified rain gauge using WHERE GaugeId = '特定雨量计ID' to isolate relevant data from RainfallData.  【step2】: Calculate the adjusted atmospheric pressure by subtracting RainfallMm/10 from AtmosphericPressureHpa using arithmetic operations in the SELECT clause.  【step3】: Project RainfallMm, AtmosphericPressureHpa, and the derived AdjustedPressure columns to display the impact relationship.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1350,
        "question": "Calculate the average atmospheric pressure and its moving average trend over time in a rainfall monitoring dataset.",
        "query": "WITH PressureStats AS (SELECT AVG(AtmosphericPressureHpa) AS AvgPressure, COUNT(*) AS DataPoints FROM RainfallData), PressureTrend AS (SELECT CollectionTime, AtmosphericPressureHpa, AVG(AtmosphericPressureHpa) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgPressure, MovingAvg FROM PressureStats, PressureTrend;",
        "step": "【step1】: Calculate the overall average atmospheric pressure (AvgPressure) and total data points (DataPoints) from the RainfallData table using aggregate functions.  【step2】: Compute a 10-row moving average (MovingAvg) of atmospheric pressure ordered by CollectionTime using a window function for trend analysis.  【step3】: Combine the static average (AvgPressure) from Step 1 with the dynamic moving averages (MovingAvg) from Step 2 via a Cartesian product to display both metrics in the final output.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1351,
        "question": "Based on rainfall and atmospheric pressure data from a rain monitoring station, determine whether equipment failure is likely to occur, and show the collection time, rainfall, atmospheric pressure, and the determined status.",
        "query": "SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】:【Select required fields】Collect CollectionTime, RainfallMm, and AtmosphericPressureHpa from RainfallData table.  【step2】:【Apply conditional judgment】Use CASE expression to check if RainfallMm < 0 OR > 1000 OR AtmosphericPressureHpa < 800 OR > 1100.  【step3】:【Generate status labels】Assign '可能引发设备故障' when thresholds are violated, else '设备运行正常' as DeviceStatus.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1352,
        "question": "Assuming the rainfall in a certain precipitation monitoring data reaches 10,000 millimeters and the atmospheric pressure reaches 2,000 hectopascals, what is the impact on atmospheric pressure and the potential influence on data collection for the records meeting these conditions?",
        "query": "SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa - (10000 / 10)) AS AdjustedAtmosphericPressureHpa, CASE WHEN RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和大气压力在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000;",
        "step": "【step1】: Filter data where rainfall exceeds 10,000mm OR atmospheric pressure exceeds 2,000hpa using WHERE clause  【step2】: Calculate adjusted atmospheric pressure by subtracting (10000/10) from original pressure values  【step3】: Apply CASE expression to generate impact analysis based on threshold violations and perform field projection",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1353,
        "question": "Calculate the adjusted humidity by incorporating the impact of rainfall intensity for gauge ID 2 in the RainfallData dataset.",
        "query": "SELECT RainfallIntensityMmH, HumidityPercent, HumidityPercent + (RainfallIntensityMmH / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '2';",
        "step": "【step1】: Filter records from RainfallData where GaugeId is '2' to focus on data from the specific rain gauge.  【step2】: Select RainfallIntensityMmH and HumidityPercent fields to directly analyze the relationship between rainfall intensity and humidity.  【step3】: Compute AdjustedHumidity by adding HumidityPercent and the adjusted rainfall intensity (RainfallIntensityMmH / 10) to quantify the influence of rainfall intensity on humidity.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1354,
        "question": "Calculate the average humidity in a certain rainfall monitoring dataset and analyze its trend of change using a 10-point moving average.",
        "query": "WITH HumidityStats AS (SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints FROM RainfallData), HumidityTrend AS (SELECT CollectionTime, HumidityPercent, AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgHumidity, MovingAvg FROM HumidityStats, HumidityTrend;",
        "step": "【step1】: Calculate basic humidity statistics (average humidity and total data points) from the entire RainfallData table using a CTE.  【step2】: Compute time-based moving averages (10-row window) for humidity values ordered by CollectionTime using another CTE with window functions.  【step3】: Combine the aggregated statistics (AvgHumidity) with trend analysis (MovingAvg) through a Cartesian product between the two CTEs to output both overall and trend values.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1355,
        "question": "Based on the rainfall intensity and humidity values in the rainfall monitoring data, determine the current device status.",
        "query": "SELECT CollectionTime, RainfallIntensityMmH, HumidityPercent, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Retrieve core measurement data columns (CollectionTime, RainfallIntensityMmH, HumidityPercent) from RainfallData table.  【step2】: Apply CASE conditional logic to check for invalid measurements:           - RainfallIntensity < 0 OR > 100           - HumidityPercent < 0 OR > 100  【step3】: Generate DeviceStatus column labeling abnormal measurements as '可能引发设备故障' and valid ones as '设备运行正常'.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1356,
        "question": "Assuming the rainfall intensity in a certain precipitation monitoring data reaches 1000 mm/hour or the humidity reaches 200%, what is the data impact and the adjusted humidity percent?",
        "query": "SELECT CollectionTime, HumidityPercent, (HumidityPercent + (1000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200 THEN '可能导致设备损坏或数据失真' ELSE '降雨强度和湿度在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200;",
        "step": "【step1】:【Filter raw data】Extract records meeting extreme conditions from RainfallData table using WHERE clause with RainfallIntensityMmH ≥1000 OR HumidityPercent ≥200  【step2】:【Calculate humidity adjustment】Compute AdjustedHumidityPercent by adding 100 units (1000mm/h ÷ 10) to original humidity values  【step3】:【Impact evaluation】Apply CASE statement to flag records with abnormal parameters as potential equipment/damage risks, others as normal conditions",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1357,
        "question": "Calculate the adjusted wind speed by adding one-tenth of rainfall intensity to wind speed for gauge ID 2 in the rainfall monitoring data.",
        "query": "SELECT RainfallIntensityMmH, WindSpeedMps, WindSpeedMps + (RainfallIntensityMmH / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '2';",
        "step": "【step1】: Filter the dataset to select only records from gauge '2' using WHERE clause  【step2】: Retrieve rainfall intensity (RainfallIntensityMmH) and original wind speed (WindSpeedMps) values  【step3】: Calculate AdjustedWindSpeed by applying formula: WindSpeedMps + (RainfallIntensityMmH/10) using column arithmetic",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1358,
        "question": "Calculate the average wind speed from certain rainfall monitoring data and analyze its variation trend using a moving average.",
        "query": "WITH WindSpeedStats AS (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints FROM RainfallData), WindSpeedTrend AS (SELECT CollectionTime, WindSpeedMps, AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats, WindSpeedTrend;",
        "step": "【step1】:【Calculate overall average wind speed and total data points using WindSpeedStats CTE by aggregating RainfallData】  【step2】:【Compute moving average of wind speed (10-row window) for each collection time via WindSpeedTrend CTE using window function】  【step3】:【Combine results through CROSS JOIN to display both global average and temporal trend in final output】",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1359,
        "question": "Based on the rainfall intensity and wind speed data from a certain rainfall monitoring system, determine the equipment status (whether it may cause equipment failure or is running normally).",
        "query": "SELECT CollectionTime, RainfallIntensityMmH, WindSpeedMps, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;",
        "step": "【step1】: Select CollectionTime, RainfallIntensityMmH, WindSpeedMps from RainfallData to retrieve raw monitoring data  【step2】: Apply conditional logic using CASE expression to evaluate RainfallIntensityMmH (valid range 0-100mm/h) and WindSpeedMps (valid range 0-20m/s)  【step3】: Generate DeviceStatus column marking '可能引发设备故障' when either parameter exceeds valid thresholds, otherwise '设备运行正常'",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1360,
        "question": "Assuming that the rainfall intensity in a certain rainfall monitoring data reaches 1000 mm/hour or the wind speed reaches 100 m/s, analyze the potential effects on data collection.",
        "query": "SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (1000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100 THEN '可能导致设备损坏或数据失真' ELSE '降雨强度和风速在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100;",
        "step": "【step1】: Filter data records where rainfall intensity reaches 1000 mm/h or wind speed reaches 100 m/s using WHERE clause with OR condition.  【step2】: Calculate adjusted wind speed by adding 100 m/s (derived from 1000mm/h precipitation's hypothetical influence) to original WindSpeedMps through arithmetic expression.  【step3】: Use CASE statement to evaluate data impact label based on rainfall/wind thresholds and append calculated fields through column aliases.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "1",
        "idx": 1361,
        "question": "If a rain gauge with ID '3' records 100 millimeters of rainfall within one hour, with a rainfall intensity of 100 millimeters per hour, does the rainfall amount recorded by the gauge exceed the threshold set in the warning rule table for the 'Rainfall' parameter type during this period?",
        "query": "SELECT RainfallMm, RainfallIntensityMmH, ThresholdValue FROM RainfallData JOIN RainfallWarningRule ON RainfallData.GaugeId = '3' AND RainfallWarningRule.ParameterType = '降雨量' WHERE RainfallMm > ThresholdValue AND RainfallIntensityMmH = 100;",
        "step": "【step1】: Join RainfallData with RainfallWarningRule using GaugeId='3' and ParameterType='降雨量'  【step2】: Filter records where RainfallIntensityMmH = 100  【step3】: Check if RainfallMm exceeds ThresholdValue in matched rules",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "2",
        "idx": 1362,
        "question": "Assuming a rain gauge recorded rainfall amounts of 50mm, 60mm, 70mm, 80mm, and 90mm over five consecutive hours, calculate the average rainfall intensity and total rainfall during these five hours.",
        "query": "WITH RainfallData AS (SELECT 50 AS RainfallMm UNION ALL SELECT 60 UNION ALL SELECT 70 UNION ALL SELECT 80 UNION ALL SELECT 90) SELECT AVG(RainfallMm) AS AvgRainfallIntensity, SUM(RainfallMm) AS TotalRainfall FROM RainfallData;",
        "step": "【step1】: Create a temporary CTE \"RainfallData\" that explicitly defines the 5-hour rainfall measurements (50,60,70,80,90) using UNION ALL.  【step2】: Calculate the average rainfall intensity via AVG(RainfallMm) and total rainfall via SUM(RainfallMm) directly from the CTE.  【step3】: (Not required - no JOINs/nested logic)",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "3",
        "idx": 1363,
        "question": "If a rain gauge is installed at an altitude of 1000 meters and the average annual rainfall is at least 1500 millimeters, is the installation location of the rain gauge suitable for long-term rainfall monitoring?",
        "query": "SELECT InstallationLocation, ElevationMeters, (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) AS AvgAnnualRainfall, CASE WHEN ElevationMeters = 1000 AND (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) >= 1500 THEN '适合长期监测' ELSE '不适合长期监测' END AS Suitability FROM RainGauge WHERE ElevationMeters = 1000;",
        "step": "【step1】: Filter RainGauge records where ElevationMeters = 1000 to identify gauges at the specified altitude.  【step2】: Correlate each filtered gauge with its historical rainfall data via a subquery (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) to calculate annual average rainfall.  【step3】: Apply a CASE statement to evaluate suitability: if elevation is 1000m AND calculated annual rainfall ≥1500mm, return '适合长期监测'; otherwise, return '不适合长期监测'.",
        "format": "MySQL"
    },
    {
        "db_id": "RainGauge",
        "type": "4",
        "idx": 1364,
        "question": "Assuming a rain gauge recorded 1,000 millimeters of rainfall within one hour, with a rainfall intensity of 1,000 millimeters per hour, under these circumstances, can the thresholds in the warning rule table still effectively determine whether a warning should be issued?",
        "query": "SELECT RuleName, ThresholdValue, CASE WHEN 1000 > ThresholdValue THEN '阈值无法有效判断，需调整预警规则' ELSE '阈值仍可有效判断' END AS WarningEffectiveness FROM RainfallWarningRule WHERE ParameterType = '降雨强度' AND IsActive = TRUE;",
        "step": "【step1】: Filter active rainfall intensity rules from RainfallWarningRule table using WHERE clause with conditions ParameterType='降雨强度' AND IsActive=TRUE  【step2】: Compare 1000 mm/h input value against ThresholdValue using CASE expression to determine warning effectiveness  【step3】: Project RuleName, ThresholdValue with calculated WarningEffectiveness status for remaining active rules",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1365,
        "question": "Calculate the current strength (in amperes) of the rice cooker during normal operation based on its rated power and rated voltage.",
        "query": "SELECT id, model, brand, power_rating, voltage_rating, (power_rating / voltage_rating) AS current_strength FROM rice_cooker_info;",
        "step": "【step1】: Select the basic information fields (id, model, brand, power_rating, voltage_rating) from the rice_cooker_info table.  【step2】: Add a calculated column using the formula (power_rating / voltage_rating) to derive the current_strength in amperes.  【step3】: Execute the query by combining the selected fields and the calculated current_strength without additional filters, joins, or sorting.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1366,
        "question": "Calculate the average energy consumption of each rice cooker during performance testing, and identify the model with the lowest energy consumption.",
        "query": "WITH avg_energy_consumption AS (SELECT rice_cooker_id, AVG(energy_consumption) AS avg_energy FROM performance_tests GROUP BY rice_cooker_id) SELECT rci.model, aec.avg_energy FROM rice_cooker_info rci JOIN avg_energy_consumption aec ON rci.id = aec.rice_cooker_id ORDER BY aec.avg_energy ASC LIMIT 1;",
        "step": "【step1】: Calculate the average energy consumption per rice cooker by aggregating performance_tests data using GROUP BY rice_cooker_id and AVG(energy_consumption).  【step2】: Join the result with rice_cooker_info table using rice_cooker_id to retrieve model information.  【step3】: Sort the combined data by avg_energy in ascending order and select the top record using LIMIT 1 to find the model with lowest consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1367,
        "question": "Determine whether the combined rice and water quantity recorded in each use of the rice cooker exceeds its maximum capacity based on the rice cooker's volume and usage records.",
        "query": "SELECT ur.id AS usage_id, ur.rice_cooker_id, rci.capacity, ur.rice_quantity, ur.water_quantity, (ur.rice_quantity + ur.water_quantity) AS total_quantity, CASE WHEN (ur.rice_quantity + ur.water_quantity) <= rci.capacity THEN 'No' ELSE 'Yes' END AS exceeded_capacity FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;",
        "step": "【step1】: Join 'usage_records' with 'rice_cooker_info' via rice_cooker_id to associate each usage record with its corresponding capacity.  【step2】: Calculate total_quantity by summing rice_quantity (kg) and water_quantity (L), assuming compatible units.  【step3】: Use CASE to output 'Yes'/'No' in exceeded_capacity by comparing total_quantity with rice_cooker_info.capacity (L).",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1368,
        "question": "Assuming all rice cookers operate continuously for 24 hours at 10 times their rated power, calculate the theoretical daily power consumption for each model (in megawatt-hours) and filter out models with a consumption exceeding 1 megawatt-hour.",
        "query": "SELECT model, (10 * power_rating * 24) / 1000000 AS daily_energy_mwh FROM rice_cooker_info WHERE (10 * power_rating * 24) / 1000000 > 1;",
        "step": "【step1】: Calculate theoretical daily energy consumption for each model by scaling power_rating by 10x, multiplying by 24 hours, and converting to megawatt-hours.  【step2】: Filter the results to retain only models where the calculated energy exceeds 1 MWh.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1369,
        "question": "Calculate the thermal conversion efficiency (output effective heat/input electrical energy) for each model of electric rice cooker, and return the models with efficiency below 60% and boiling time exceeding 15 minutes, sorted by efficiency value in ascending order.",
        "query": "WITH energy_efficiency AS (SELECT rci.model, pt.time_to_boil, (pt.water_evaporation_rate / 100 * 1.5) AS water_quantity, (pt.water_evaporation_rate / 100 * 1.5 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / (rci.power_rating * pt.time_to_boil / 60) * 100 AS efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, efficiency FROM energy_efficiency WHERE efficiency < 60 AND time_to_boil > 15 ORDER BY efficiency ASC;",
        "step": "【step1】: 【Create a CTE named 'energy_efficiency' that joins 'performance_tests' and 'rice_cooker_info' to calculate water quantity and efficiency using the formula: (water_evaporation_rate/100*1.5*4186*(final_temp - initial_temp)/3.6e6) / (power_rating*time_to_boil/60)*100, filtered by test_type='Boiling'】  【step2】: 【Filter the CTE results to select models where efficiency < 60% AND time_to_boil > 15 minutes】  【step3】: 【Order the final results by efficiency in ascending order】",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1370,
        "question": "Calculate the maintenance cost-effectiveness ratio (total usage count / total maintenance cost) for each rice cooker, including records without any maintenance (which will have NULL ratio), and take the bottom 50% of data sorted by the ratio in ascending order.",
        "query": "WITH usage_counts AS (SELECT rice_cooker_id, COUNT(id) AS total_usage FROM usage_records GROUP BY rice_cooker_id), maintenance_costs AS (SELECT rice_cooker_id, SUM(maintenance_cost) AS total_cost FROM maintenance_records GROUP BY rice_cooker_id), cost_benefit AS (SELECT rci.model, uc.total_usage, mc.total_cost, CASE WHEN mc.total_cost = 0 THEN NULL ELSE uc.total_usage / mc.total_cost END AS cost_benefit_ratio FROM rice_cooker_info rci JOIN usage_counts uc ON rci.id = uc.rice_cooker_id JOIN maintenance_costs mc ON rci.id = mc.rice_cooker_id), percentile_rank AS (SELECT *, NTILE(2) OVER (ORDER BY cost_benefit_ratio DESC) AS percentile FROM cost_benefit) SELECT model, total_usage, total_cost, cost_benefit_ratio FROM percentile_rank WHERE percentile = 1;",
        "step": "【step1】: Calculate total usage count per rice cooker from usage_records and total maintenance cost per rice cooker from maintenance_records using separate CTEs  【step2】: Join the aggregated usage and cost data with rice_cooker_info, calculate cost-benefit ratio (total_usage/total_cost), and filter out records with zero maintenance cost  【step3】: Use NTILE window function to rank records into 2 percentile groups by descending cost-benefit ratio, then select the top 50% group (percentile = 1)",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1371,
        "question": "Identify models with design flaws: Find models that have had at least three instances where the final temperature was below 90% of 100 and the rice quality score was below 8, and exclude models that have undergone repair maintenance.",
        "query": "WITH defect_models AS (SELECT rice_cooker_id FROM performance_tests WHERE final_temperature < 0.9 * 100 AND rice_quality_score < 8 GROUP BY rice_cooker_id HAVING COUNT(*) >= 3), repaired_models AS (SELECT DISTINCT rice_cooker_id FROM maintenance_records WHERE maintenance_type = 'Repair') SELECT rci.model FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id WHERE dm.rice_cooker_id NOT IN (SELECT rice_cooker_id FROM repaired_models);",
        "step": "【step1】: Filter models with 3+ performance failures (final_temp < 90% of 100°C AND quality_score <8) using CTE  【step2】: Exclude repaired models through subquery checking maintenance records  【step3】: Join defect models with rice_cooker_info to get model names using ID mapping",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1372,
        "question": "Assuming the rice cooker operates in an environment where the initial water temperature is -50℃, calculate the boiling time (considering heat loss). The formula is expanded as: t = (water_volume * 4186 * (100 - T_initial) + heat_loss_coefficient * A * t * ΔT) / power, where A = 0.12 m² is the assumed surface area and the heat loss coefficient takes an extreme value of 50 W/m²·℃.",
        "query": "SELECT model, power_rating, CASE WHEN power_rating > (50 * 0.12 * 150) THEN (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 ELSE NULL END AS boil_time_hours FROM rice_cooker_info WHERE (power_rating - (50 * 0.12 * 150)) > 0 AND (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 > 24;",
        "step": "【step1】: Filter rice cookers where effective power (total power minus heat loss) is positive: (power_rating - (50 * 0.12 * 150)) > 0  【step2】: Calculate boil_time_hours using conditional logic: Apply formula (1.8*4186*150)/(power_rating - 900)/60 only when power_rating > 900, else return NULL  【step3】: Filter results retaining only records where calculated boil_time_hours exceeds 24 hours: (result from step2) > 24",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1373,
        "question": "Given that the BrandC model RC-3003 rice cooker has a rated power of 900W, a performance test showed that it took 18 minutes to boil 6 liters of water with an initial temperature of 22°C. Calculate the thermal efficiency of this test (ignoring water evaporation).",
        "query": "SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;",
        "step": "【step1】: Retrieve the rice cooker's power rating (900W) from rice_cooker_info using brand 'BrandC' and model 'RC-3003'.  【step2】: Extract test parameters (6L water, 18-minute boil time, 22°C initial temp) from performance_tests, assuming water_quantity is stored implicitly via capacity in rice_cooker_info.  【step3】: Calculate efficiency via (6*4186*(100-22))/(900*18*60)*100, where 100°C is the boiling point derived from final_temperature.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1374,
        "question": "According to the maintenance records, Brand B products generated 3 maintenance records within two years, while Brand C products had 2 maintenance records within 18 months. What is the expected number of maintenance incidents per hundred devices for each brand, based on the provided data?",
        "query": "SELECT brand, ROUND((total_incidents / observation_years * 5 * 100), 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;",
        "step": "【step1】: Extract brand-specific maintenance incidence rates by joining rice_cooker_info with maintenance_records, calculating total incidents per brand and their observation periods (2 years for BrandB, 1.5 years for BrandC).  【step2】: Compute annualized repair rate per brand using (total_incidents / observation_years), then project to 5-year period and scale to 100 units (annual_rate * 5 * 100).  【step3】: Apply ROUND() to final calculation for presentable formatting of expected_repairs_per_100_units with 1 decimal precision.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1375,
        "question": "Identify models with a water evaporation rate exceeding 15% in performance tests and a rice quality score below 8 points. Return the production date and warranty status of these models (determine if the warranty has expired, assuming the current date is 2023-12-01).",
        "query": "WITH defect_models AS (SELECT pt.rice_cooker_id FROM performance_tests pt WHERE pt.water_evaporation_rate > 15 AND pt.rice_quality_score < 8) SELECT rci.model, rci.production_date, CASE WHEN DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH) > '2023-12-01' THEN '在保' ELSE '过保' END AS warranty_status FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;",
        "step": "【step1】: Filter performance_tests to find rice_cooker_ids where water_evaporation_rate > 15% and rice_quality_score < 8.  【step2】: Join the filtered rice_cooker_ids with rice_cooker_info to obtain model, production_date, and warranty_period.  【step3】: Calculate warranty_status by comparing production_date + warranty_period months with 2023-12-01 using DATE_ADD and CASE expression.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1376,
        "question": "Assuming a rice cooker with model RC-3003 (rated power 900W) is used in a plateau area at an altitude of 5000 meters, where the ambient temperature is -15°C and the boiling point drops to 85°C, calculate the time required to heat 2L of water from -15°C to 85°C (considering power reduction with increasing altitude, assuming power drops to 80% of the rated value, and additionally accounting for heat loss, with a heat loss coefficient of 20W/m²·°C and a rice cooker surface area of 0.12m²).",
        "query": "WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;",
        "step": "【step1】: Calculate heat loss using the formula: 20 (heat loss coefficient) * 0.12 (surface area) * (85 - (-15)) (temperature difference) in the CTE \"heat_loss_calc\".  【step2】: Compute boil time by applying the energy formula [(2L water mass * 4186 J/kg°C * 100°C temp change) / (720W effective power (80% of 900W) - heat_loss)] / 60 in the CTE \"boil_time_calc\", with nested reference to step1's heat_loss value.  【step3】: Extract the final calculated boil_time_minutes from the boil_time_calc CTE.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1377,
        "question": "Given that the BrandC model RC-3003 rice cooker has a rated power of 900W, and a performance test showed that it took 18 minutes to boil 6 liters of water with an initial water temperature of 78°C, calculate the heat transfer efficiency of the test (assuming water evaporation is negligible).",
        "query": "SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;",
        "step": "【step1】: Retrieve test parameters and power rating by joining 'rice_cooker_info' and 'performance_tests' tables using rice_cooker_id. The formula requires water quantity (6L), temperature difference (100-22=78°C), power (900W), and time (18 minutes).  【step2】: Apply thermodynamics formula: (water_quantity * 4186 * temp_diff) / (power_rating * time_to_boil * 60) * 100. The 4186 is water's specific heat capacity (J/kg°C) converted via 1L≈1kg.  【step3】: Handle unit conversions implicitly: Convert 18 minutes to seconds (18*60) and ensure power-time product represents energy in joules (900W = 900J/s * 1080s).",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1378,
        "question": "According to the maintenance records, BrandB products had 3 repair records within two years, while BrandC products had 2 repair records within 18 months. Calculate the expected annualized number of repairs per 100 devices for each brand.",
        "query": "SELECT brand, ROUND((total_incidents / observation_years * 5 * 100), 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;",
        "step": "【step1】: Aggregate maintenance incidents and observation periods per brand using a derived table with explicit values based on problem parameters.  【step2】: Calculate annual incident rate per brand by dividing total_incidents by observation_years to establish yearly failure frequency.  【step3】: Project 5-year expectation per 100 units by scaling the annual rate (rate × 5 × 100) and apply ROUND() for precision control.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1379,
        "question": "Find the models with a water evaporation rate exceeding 15% and a rice quality score below 8 points in the performance test, and return the models, production dates, and warranty status of these models (it is necessary to determine whether the warranty has expired, assuming the current date is 2023-12-01).",
        "query": "WITH defect_models AS (SELECT pt.rice_cooker_id FROM performance_tests pt WHERE pt.water_evaporation_rate > 15 AND pt.rice_quality_score < 8) SELECT rci.model, rci.production_date, CASE WHEN DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH) > '2023-12-01' THEN '在保' ELSE '过保' END AS warranty_status FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;",
        "step": "【step1】: Filter rice cooker IDs from performance_tests where water_evaporation_rate > 15% AND rice_quality_score < 8 using a CTE (defect_models).  【step2】: Join defect_models with rice_cooker_info to retrieve model, production_date, and warranty_period.  【step3】: Calculate warranty_status by comparing production_date + warranty_period (months) to '2023-12-01' via CASE expression.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1380,
        "question": "Assuming a rice cooker with model RC-3003 (rated power 900W) is used in a high-altitude area at 5000 meters above sea level with an ambient temperature of -15°C, and the boiling point drops to 85°C, calculate the time required to heat 2L of water from -15°C to 85°C. (Account for the power decreasing with altitude, assuming the power decreases to 80% of the rated value, and additionally consider heat loss, assuming a heat loss coefficient of 20W/m²·°C and a rice cooker surface area of 0.12m²).",
        "query": "WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;",
        "step": "【step1】: Calculate heat loss using heat_loss_calc CTE: 20 (W/m²·℃) * 0.12 (m²) * [85 - (-15)] (ΔT) = 240W heat loss  【step2】: Compute boiling time in boil_time_calc CTE: (2L*4186J/kg·℃*100℃)/(0.8*900W - 240W) = Total energy divided by effective power  【step3】: Extract final result by selecting boil_time_minutes from the second CTE after converting seconds to minutes",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1381,
        "question": "Calculate the effective heat efficiency (energy consumption for heating water / total input electrical energy) of each rice cooker model in performance tests, return models with heat efficiency below 65% and water evaporation rate above 10%, and sort the results in ascending order of heat efficiency. Additional conditions: each test uses a fixed water volume of 2 liters.",
        "query": "WITH heat_efficiency AS (SELECT rci.model, 2 AS water_quantity, pt.final_temperature, pt.initial_temperature, pt.energy_consumption, pt.water_evaporation_rate, (2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / pt.energy_consumption * 100 AS efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, efficiency FROM heat_efficiency WHERE efficiency < 65 AND water_evaporation_rate > 10 ORDER BY efficiency ASC;",
        "step": "【step1】: Calculate the effective heat efficiency for each rice cooker model using the formula (2*4186*(final_temp - initial_temp)/3.6e6) / energy_consumption * 100 by joining performance_tests and rice_cooker_info, filtering only 'Boiling' test_type.  【step2】: Filter results to retain models with efficiency < 65% and water_evaporation_rate > 10%.  【step3】: Sort the final output by heat efficiency in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1382,
        "question": "Calculate the monthly maintenance cost rate (total maintenance cost / service months) for each rice cooker model, filter for models with service months > 12 and cost rate > 5 RMB/month, and select the top 3 with the highest cost rates in descending order.",
        "query": "WITH maintenance_summary AS (SELECT rci.id, rci.model, rci.production_date, SUM(mr.maintenance_cost) AS total_cost, MAX(mr.maintenance_date) AS last_maintenance_date FROM rice_cooker_info rci JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id GROUP BY rci.id, rci.model, rci.production_date HAVING last_maintenance_date IS NOT NULL) SELECT model, total_cost, ROUND(DATEDIFF(last_maintenance_date, production_date)/30.0, 1) AS service_months, ROUND(total_cost / (DATEDIFF(last_maintenance_date, production_date)/30.0), 2) AS cost_rate FROM maintenance_summary WHERE DATEDIFF(last_maintenance_date, production_date)/30.0 > 12 AND total_cost / (DATEDIFF(last_maintenance_date, production_date)/30.0) > 5 ORDER BY cost_rate DESC LIMIT 3;",
        "step": "【step1】: Create maintenance summary CTE by joining rice_cooker_info and maintenance_records, calculating total maintenance cost and last maintenance date per appliance using GROUP BY  【step2】: Calculate service_months (converted from DATEDIFF/30.0) and derive cost_rate (total_cost/service_months), applying filters for service_months>12 and cost_rate>5  【step3】: Sort results by cost_rate DESC and limit to top 3 records using ORDER BY and LIMIT clauses",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1383,
        "question": "Identify models with a capacity <4L but having at least one record of cooking rice ≥1.5kg in a single session without water quantity <2.25L in that session, and return the brands and models along with their most recent usage dates.",
        "query": "WITH qualified_models AS (SELECT rci.id, rci.brand, rci.model FROM rice_cooker_info rci WHERE rci.capacity < 4 AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.rice_quantity >= 1.5) AND NOT EXISTS (SELECT 1 FROM usage_records ur2 WHERE ur2.rice_cooker_id = rci.id AND ur2.rice_quantity >= 1.5 AND ur2.water_quantity < 2.25)) SELECT qm.brand, qm.model, MAX(ur.end_time) AS last_usage_date FROM qualified_models qm JOIN usage_records ur ON qm.id = ur.rice_cooker_id GROUP BY qm.brand, qm.model;",
        "step": "【step1】: Filter rice cookers with capacity <4L that have at least one usage record with rice_quantity ≥1.5kg using EXISTS in qualified_models CTE.  【step2】: Exclude models where the same qualifying usage record has water_quantity <2.25L using NOT EXISTS in the CTE.  【step3】: Join qualified_models with usage_records, then aggregate by brand/model to find MAX(end_time) as last_usage_date.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1384,
        "question": "Assuming the model RC-2002 (700W) is used in a space vacuum environment (where the boiling point disappears and water continuously vaporizes at 100°C), calculate the time required for 2 liters of water to completely vaporize from 20°C, providing the result in both seconds and hours rounded to one decimal place.",
        "query": "SELECT (2 * (4186 * (100 - 20) + 2260000)) / (0.5 * 700 * 0.1) AS total_seconds, ROUND((2 * (4186 * 80 + 2260000)) / (0.5 * 700 * 0.1) / 3600, 1) AS hours;",
        "step": "【step1】: Calculate the total energy required to heat 2L of water from 20°C to 100°C and completely vaporize it. This includes sensible heat (4186 J/kg°C * 2kg * 80°C) and latent heat of vaporization (2260000 J/kg * 2kg).  【step2】: Calculate effective heating power using the formula (0.5 * 700W * 0.1), where 0.5 represents efficiency factor and 0.1 accounts for environmental conditions.  【step3】: Divide total energy by effective power to get seconds, then convert to hours using /3600 and ROUND() function for final presentation.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1385,
        "question": "Calculate the thermal efficiency deviation (actual thermal efficiency vs theoretical maximum thermal efficiency) of each rice cooker model in performance tests, and return models where the deviation value is >15% and water evaporation rate >12%, sorted in descending order by deviation value.",
        "query": "WITH efficiency_calc AS (SELECT rci.model, pt.initial_temperature, pt.energy_consumption, pt.time_to_boil, pt.water_evaporation_rate, (2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) AS eta_max, pt.energy_consumption AS eta_real, ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) - pt.energy_consumption) / ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000)) * 100 AS deviation FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, deviation, water_evaporation_rate FROM efficiency_calc WHERE deviation > 15 AND water_evaporation_rate > 12 ORDER BY deviation DESC;",
        "step": "【step1】: Calculate theoretical maximum efficiency (eta_max) and actual efficiency (eta_real) via JOIN between performance_tests and rice_cooker_info, compute heat efficiency deviation percentage using ((eta_max - eta_real)/eta_max)*100  【step2】: Filter results where deviation > 15% and water_evaporation_rate > 12% from the calculated CTE efficiency_calc  【step3】: Sort qualified models by deviation percentage in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1386,
        "question": "Calculate the fault recurrence rate (number of models with more than one repair per brand / total number of models per brand) for each brand of rice cookers. Only return brands with a recurrence rate >30% and a total number of repairs ≥2, and rank the top 3 by recurrence rate in descending order.",
        "query": "WITH model_maintenance AS (SELECT rci.brand, rci.model, COUNT(*) AS maintenance_count FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id GROUP BY rci.brand, rci.model), brand_recurrence AS (SELECT brand, SUM(CASE WHEN maintenance_count > 1 THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS recurrence_rate, SUM(maintenance_count) AS total_maintenance FROM model_maintenance GROUP BY brand HAVING SUM(maintenance_count) >= 2) SELECT brand, ROUND(recurrence_rate * 100, 2) AS recurrence_rate_percent, total_maintenance FROM brand_recurrence WHERE recurrence_rate > 0.3 ORDER BY recurrence_rate DESC LIMIT 3;",
        "step": "【step1】: Calculate maintenance count per model by joining maintenance_records and rice_cooker_info, grouping results by brand and model.  【step2】: Aggregate model-level data to brand-level, calculating recurrence_rate (ratio of models with >1 maintenance to total models) and total_maintenance (sum of maintenance counts), filtering brands with ≥2 total maintenance.  【step3】: Filter brands with recurrence_rate >30%, format percentage, sort by highest recurrence_rate, and limit to top 3 results.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1387,
        "question": "Identify models with a capacity ≥5L that have records of cooking rice with a single batch <0.5kg (note: low rice quantity may lead to uneven heating), and return the average rice quality score of the most recent 3 performance tests for these models.",
        "query": "WITH qualified_models AS (SELECT rci.id, rci.model FROM rice_cooker_info rci WHERE rci.capacity >= 5 AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.rice_quantity < 0.5)), recent_scores AS (SELECT qm.model, pt.rice_quality_score, ROW_NUMBER() OVER (PARTITION BY qm.id ORDER BY pt.test_date DESC) AS rn FROM qualified_models qm JOIN performance_tests pt ON qm.id = pt.rice_cooker_id) SELECT model, ROUND(AVG(rice_quality_score), 2) AS avg_rice_quality FROM recent_scores WHERE rn <= 3 GROUP BY model;",
        "step": "【step1】: Filter models with capacity ≥5L that have usage records with rice_quantity <0.5kg using EXISTS subquery and CTE (qualified_models).  【step2】: Join qualified_models with performance_tests, rank each model's test records by recency via ROW_NUMBER() window function partitioned by rice_cooker_id (recent_scores).  【step3】: Calculate rounded average of rice_quality_score for the top 3 most recent records per model using WHERE rn ≤3 and GROUP BY model.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1388,
        "question": "Assuming the model RC-3003 (900W) is used in a deep-sea environment at 4000 meters (boiling point 280°C, pressure 40MPa), calculate the time required to heat 3L of water from 5°C to 280°C (assuming the power is increased to 150%, heat loss formula: Q_loss=0.08×A×(T_water-2)^4, A=0.2m², ambient temperature 2°C).",
        "query": "WITH heat_loss_calc AS (SELECT 0.08 * 0.2 * POWER(280 - 2, 4) AS max_heat_loss), boil_time_calc AS (SELECT (3 * 4186 * (280 - 5)) / (1.5 * 900 - (SELECT max_heat_loss FROM heat_loss_calc)) / 3600 AS boil_time_hours) SELECT boil_time_hours FROM boil_time_calc;",
        "step": "【step1】: Calculate maximum heat loss using Q_loss formula where T_water=280°C  【step2】: Compute total time by dividing required heat energy (3L water heating from 5°C to 280°C) by net effective power (150% enhanced power minus max_heat_loss)  【step3】: Convert final result from seconds to hours and output",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1389,
        "question": "Calculate the difference between the actual thermal efficiency and the theoretical maximum thermal efficiency (theoretical maximum thermal efficiency = 1 - (298.15 / (final_temperature + 273.15))) for each rice cooker model in the boiling performance test. Return models where the difference is >10% and the water evaporation rate is >8%, sorted in descending order by the difference.",
        "query": "WITH efficiency_calc AS (SELECT rci.model, pt.final_temperature, pt.initial_temperature, pt.energy_consumption, pt.water_evaporation_rate, (2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / pt.energy_consumption AS eta_actual, 1 - (298.15 / (pt.final_temperature + 273.15)) AS eta_theoretical, ((2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / pt.energy_consumption - (1 - (298.15 / (pt.final_temperature + 273.15)))) * 100 AS efficiency_diff FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, efficiency_diff, water_evaporation_rate FROM efficiency_calc WHERE efficiency_diff > 10 AND water_evaporation_rate > 8 ORDER BY efficiency_diff DESC;",
        "step": "【step1】: Calculate actual efficiency (eta_actual) and theoretical efficiency (eta_theoretical) using JOIN between performance_tests and rice_cooker_info, with formula-based computations including temperature conversions (25°C→298.15K) and energy efficiency calculations.  【step2】: Filter results using WHERE clause to keep records where efficiency_diff > 10% and water_evaporation_rate > 8%.  【step3】: Sort final output by efficiency_diff in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1390,
        "question": "Calculate the energy cost-effectiveness ratio (total rice cooked/total energy consumption) for each rice cooker, requiring models with a ratio <0.8 kg/kWh and usage count >5 times, sorted in ascending order by the ratio and taking the first 2 entries.",
        "query": "WITH cost_benefit AS (SELECT rci.model, SUM(ur.rice_quantity) AS total_rice, SUM(pt.energy_consumption) AS total_energy, COUNT(*) AS usage_count, SUM(ur.rice_quantity) / SUM(pt.energy_consumption) AS benefit_ratio FROM usage_records ur JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id GROUP BY rci.model HAVING COUNT(*) > 5) SELECT model, ROUND(benefit_ratio, 2) AS benefit_ratio FROM cost_benefit WHERE benefit_ratio < 0.8 ORDER BY benefit_ratio ASC LIMIT 2;",
        "step": "【step1】: Create CTE 'cost_benefit' by joining 'usage_records', 'performance_tests', and 'rice_cooker_info' tables. Group by model to calculate total rice, energy, usage count, and benefit ratio (total_rice/total_energy). Filter groups with usage_count > 5 using HAVING clause.  【step2】: Filter CTE results where benefit_ratio < 0.8, order results by benefit_ratio in ascending order.  【step3】: Round benefit_ratio to 2 decimal places and apply LIMIT 2 to return the highest-ranked (i.e., worst-performing) 2 models.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1391,
        "question": "Identify models that have maintenance records of the 'repair' type and where the maintenance occurred within the warranty period. For these models, return the model name, the name of the maintenance technician, and the last usage date.",
        "query": "WITH repaired_in_warranty AS (SELECT rci.id, rci.model, mr.technician_name, DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH) AS warranty_end_date, mr.maintenance_date FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id WHERE mr.maintenance_type = 'Repair' AND mr.maintenance_date <= DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH)), last_usage AS (SELECT ur.rice_cooker_id, MAX(ur.end_time) AS last_usage_date FROM usage_records ur GROUP BY ur.rice_cooker_id) SELECT riw.model, riw.technician_name, lu.last_usage_date FROM repaired_in_warranty riw JOIN last_usage lu ON riw.id = lu.rice_cooker_id;",
        "step": "【step1】: Filter maintenance records of type 'Repair' within warranty period by joining maintenance_records and rice_cooker_info, calculating warranty end date with DATE_ADD.  【step2】: Get last usage dates for each rice cooker by aggregating MAX(end_time) from usage_records.  【step3】: Combine results from Step1 and Step2 via rice cooker ID to output model, technician name, and last usage date.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1392,
        "question": "Assuming the model RC-1001 (800W) is used in a nuclear reactor core environment (coolant temperature 300°C, pressure 15MPa), calculate the time required for 5L of water at 300°C to completely vaporize, considering heat loss via radiation with a coefficient of 0.06 W/m²·K⁴ and a surface area of 0.2 m².",
        "query": "WITH heat_loss_calc AS (SELECT 0.2 * 0.3 AS heat_loss_coeff), boil_time_calc AS (SELECT (5 * (4186 * (500 - 300) + 2260000 * (1 + 400/500))) / (5 * 800 - (SELECT heat_loss_coeff * (POWER(500,4) - POWER(300,4)) FROM heat_loss_calc)) / 3600 AS boil_time_hours) SELECT boil_time_hours FROM boil_time_calc;",
        "step": "【step1】: Calculate the heat loss coefficient using radiation formula: 0.2 * 0.3 = 0.06  【step2】: Compute boiling time through energy balance: (Total energy required for phase change) / (Power input - thermal radiation loss)  【step3】: Convert final result to hours by dividing by 3600 and output the calculated value",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1393,
        "question": "Calculate the sensible heat efficiency of each rice cooker model in the performance test (only counting the energy consumption ratio for water temperature increase), and return the models with a sensible heat efficiency <50% and boiling time >18 minutes, sorted in ascending order by efficiency. The sensible heat efficiency formula is: (Water volume (liters) × 4186 × (Final temperature - Initial temperature) / 3,600,000) / Energy consumption (kWh) × 100%.",
        "query": "SELECT rci.model, ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 AS thermal_efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id AND DATE(pt.test_date) = DATE(ur.start_time) WHERE pt.test_type = 'Boiling' AND pt.time_to_boil > 18 AND ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 < 50 ORDER BY thermal_efficiency ASC;",
        "step": "【step1】: Join performance_tests, rice_cooker_info, and usage_records tables via rice_cooker_id and date alignment, calculate thermal_efficiency using the formula with water_quantity, temperature difference, and energy_consumption.  【step2】: Filter records where test_type is 'Boiling', time_to_boil > 18 minutes, and thermal_efficiency < 50%.  【step3】: Select model and thermal_efficiency, then sort results in ascending order of thermal_efficiency.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1394,
        "question": "Calculate the mean time between failures (total service months divided by the number of failures) for each brand of rice cooker, excluding brands with zero failure occurrences. Return the top 3 brands ranked by ascending mean time between failures. Service months = (days between the earliest production date and the last usage date) / 30. Number of failures = count of distinct maintenance dates for all maintenance records of the brand.",
        "query": "SELECT rci.brand, DATEDIFF(MAX(ur.end_time), MIN(rci.production_date))/30 AS total_service_months, COUNT(DISTINCT mr.maintenance_date) AS total_faults, (DATEDIFF(MAX(ur.end_time), MIN(rci.production_date))/30) / COUNT(DISTINCT mr.maintenance_date) AS fault_interval FROM rice_cooker_info rci LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id GROUP BY rci.brand HAVING total_faults > 0 ORDER BY fault_interval ASC LIMIT 3;",
        "step": "【step1】: Perform LEFT JOIN operations across rice_cooker_info, usage_records, and maintenance_records tables using rice_cooker_id, then group by brand.  【step2】: Calculate total_service_months (MAX(end_time)-MIN(production_date)/30), count distinct maintenance_dates as total_faults, and derive fault_interval by division.  【step3】: Filter brands with HAVING total_faults>0, sort by fault_interval ASC, and limit results to top 3 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1395,
        "question": "Find models with a capacity >4L but having usage records with water quantity <1L, and return the maintenance count and last maintenance type for these models.",
        "query": "SELECT rci.model, COUNT(mr.id) AS maintenance_count, (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id = rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_maintenance_type FROM rice_cooker_info rci LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id WHERE rci.capacity > 4 AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.water_quantity < 1) GROUP BY rci.id;",
        "step": "【step1】: Filter rice cookers with capacity >4L and at least one usage record with water_quantity <1L using WHERE clause and EXISTS subquery on usage_records  【step2】: Left join maintenance_records to count total maintenance times per qualified rice cooker via GROUP BY aggregation  【step3】: Use correlated subquery to fetch last maintenance_type by ordering maintenance_date DESC with LIMIT 1 for each rice cooker",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1396,
        "question": "Assuming the model RC-2002 (7000W) is used in a stellar surface environment (gravitational acceleration 100g, boiling point 5000K), calculate the time required to heat 10L of water from 300K to the boiling point (assuming the heat loss formula: Q_loss = 10 × ((T_avg - 5000)^3), where T_avg is the average temperature during the step).",
        "query": "WITH RECURSIVE heating_time AS (SELECT 300 AS start_temp, 300 + 50 AS end_temp, CAST(0.0 AS DECIMAL(30,3)) AS elapsed_time UNION ALL SELECT end_temp, LEAST(end_temp + CASE WHEN end_temp < 4000 THEN 50 WHEN end_temp < 4900 THEN 10 ELSE 1 END, 5000), CAST(elapsed_time AS DECIMAL(30,3)) + CAST( (10 * 4186 * (end_temp - start_temp)) / GREATEST(7000 - 10 * POWER((start_temp + end_temp)/2 - 5000, 3), 1) AS DECIMAL(30,3)) FROM heating_time WHERE end_temp < 5000 ) SELECT MAX(elapsed_time) AS total_seconds FROM heating_time;",
        "step": "【step1】: Recursive CTE Initialization - Create the initial heating_time CTE with starting temperature (300K), end temperature (50K increment), and elapsed_time=0. Define temperature ranges & incremental steps (50K/10K/1K) based on proximity to boiling point.  【step2】: Recursive Energy Calculation - Iteratively calculate time for each temperature segment using:  Time = (10L × 4186 J/kg·K × ΔT) / (Enhanced_Power - Heat_Loss)  where Enhanced_Power = 700W×1000% = 7000W  Heat_Loss = 2 × 0.5m² × √100 × ((T_avg)-5000K)³  T_avg = (start_temp+end_temp)/2, with safety via GREATEST() to prevent negative denominator.  【step3】: Final Aggregation - After reaching 5000K, select MAX(elapsed_time) as the total cumulative time from all iterations.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1397,
        "question": "Calculate the thermal conduction efficiency (effective heating power / rated power) of each rice cooker model in the performance test, return models with efficiency <40% and a temperature setting difference (set temperature - actual maximum temperature) >5°C, sorted in ascending order by efficiency.",
        "query": "SELECT rci.model, ROUND(((ur.water_quantity*4186*(pt.final_temperature-pt.initial_temperature))/(pt.time_to_boil*60*rci.power_rating))*100,2) AS efficiency_rate FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id=rci.id JOIN usage_records ur ON pt.rice_cooker_id=ur.rice_cooker_id WHERE ur.temperature_setting-ur.actual_max_temperature>5 HAVING efficiency_rate<40 ORDER BY efficiency_rate ASC;",
        "step": "【step1】:【Join 'performance_tests', 'rice_cooker_info', and 'usage_records' tables via rice_cooker_id to combine test data, product specs, and usage parameters】  【step2】:【Filter records where temperature_setting - actual_max_temperature > 5°C using WHERE clause】  【step3】:【Calculate efficiency_rate via (water_quantity*4186*(final_temp - initial_temp))/(time_to_boil*60*power_rating)*100, apply HAVING efficiency_rate < 40, then sort results in ascending order】",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1398,
        "question": "Calculate the average daily energy cost (total energy consumption × electricity price / days of use) for each brand of rice cooker, returning brands with a cost > 2 yuan/day and days of use > 30, sorted by cost in descending order and limited to the top 2.",
        "query": "SELECT rci.brand, ROUND(SUM(COALESCE(pt.energy_consumption,0)+COALESCE(ur.energy_consumption,0))*0.6/GREATEST(DATEDIFF(MAX(ur.end_time),MIN(ur.start_time)),1),2) AS daily_cost FROM rice_cooker_info rci LEFT JOIN performance_tests pt ON rci.id=pt.rice_cooker_id LEFT JOIN usage_records ur ON rci.id=ur.rice_cooker_id GROUP BY rci.brand HAVING daily_cost>2 AND DATEDIFF(MAX(ur.end_time),MIN(ur.start_time))>30 ORDER BY daily_cost DESC LIMIT 2;",
        "step": "【step1】: Join tables with LEFT JOIN to aggregate energy consumption from performance tests and usage records per brand, calculating total energy (COALESCE handles nulls) and date range (DATEDIFF between earliest start and latest end).  【step2】: Filter results with HAVING clause to retain brands where daily_cost >2 and usage days >30 (using date_diff condition).  【step3】: Sort results by daily_cost DESC and apply LIMIT 2 for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1399,
        "question": "Identify models with a warranty period greater than 18 months but a production date older than 3 years, and return the last maintenance record date and maintenance type for these models.",
        "query": "SELECT rci.model, (SELECT MAX(maintenance_date) FROM maintenance_records WHERE rice_cooker_id=rci.id) AS last_date, (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id=rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_type FROM rice_cooker_info rci WHERE warranty_period>18 AND TIMESTAMPDIFF(YEAR,production_date,CURDATE())>3 AND EXISTS(SELECT 1 FROM maintenance_records WHERE rice_cooker_id=rci.id);",
        "step": "【step1】: Filter rice_cooker_info entries with warranty_period >18 months, production_date older than 3 years, and existing maintenance records using WHERE and EXISTS.  【step2】: For each qualifying model, retrieve the latest maintenance_date via correlated subquery with MAX(maintenance_date).  【step3】: Extract the corresponding maintenance_type for the latest date using a LIMIT 1 subquery sorted DESC by maintenance_date.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1400,
        "question": "Assuming model RC-3003 (900W at 300% power) is used in an absolute zero environment, calculate the time required to heat 10L of water from -273°C to 100°C (heat loss formula: Q_loss=0.5×A×(T+273)^4, where A is the surface area).",
        "query": "SET SESSION cte_max_recursion_depth = 1000000; WITH RECURSIVE heating_sim AS (SELECT -273.0 AS current_temp, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time UNION ALL SELECT LEAST(current_temp + CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END, 100), elapsed_time + (10*4186*(CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END)) / GREATEST(2700 - 0.5*POWER((current_temp + 273),4), 1) FROM heating_sim WHERE current_temp < 100 ) SELECT MAX(elapsed_time) AS total_seconds, MAX(elapsed_time)/3600 AS total_hours FROM heating_sim;",
        "step": "【step1】:【Set recursion depth and initialize recursive CTE】 Set session parameter to allow deep recursion, then initialize the heating simulation with starting temperature -273°C and 0 elapsed time through the anchor member of the CTE.  【step2】:【Recursive temperature calculation with dynamic steps】  1. Temperature increments:     - 10°C/step below -173°C     - 1°C/step between -173°C and 0°C     - 0.1°C/step above 0°C  2. Calculate time increment per step:     Energy needed (10L water * 4186J/kg°C * ΔT)     divided by effective power (300% of 900W - Q_loss)     using GREATEST() to prevent division by zero  【step3】:【Aggregate results and convert units】  After recursion completes (when reaching 100°C), calculate:  - Total seconds using MAX(elapsed_time)  - Hour conversion by dividing by 3600  Filters with WHERE current_temp < 100 ensure termination at target temperature.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1401,
        "question": "Calculate the thermal efficiency of each rice cooker usage record by comparing actual energy consumption to the theoretical energy required, considering specific heat capacity and heat of vaporization, and show the energy conversion rate as a percentage.",
        "query": "SELECT ur.rice_cooker_id, rci.model, ur.rice_quantity, ur.water_quantity, ur.energy_consumption AS E_actual, (ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600 AS E_theory, ((ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600) / ur.energy_consumption * 100 AS efficiency_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id",
        "step": "【step1】: Join usage_records with rice_cooker_info to obtain basic cooking data  【step2】: Calculate theoretical energy using formula: (rice_quantity * 4.18 * (ΔT) + water_quantity * 2260) / 3600  【step3】: Compute energy efficiency percentage by comparing theoretical energy to actual consumption",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1402,
        "question": "Calculate the total time in hours and seconds to heat an object from -273°C to 100°C, where the heating rate changes at -173°C and 0°C, and the time step depends on the thermal properties.",
        "query": "SET SESSION cte_max_recursion_depth = 1000000; WITH RECURSIVE heating_sim AS (SELECT -273.0 AS current_temp, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time UNION ALL SELECT LEAST(current_temp + CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END, 100), elapsed_time + (10*4186*(CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END)) / GREATEST(2700 - 0.5*POWER((current_temp + 273),4), 1) FROM heating_sim WHERE current_temp < 100 ) SELECT MAX(elapsed_time) AS total_seconds, MAX(elapsed_time)/3600 AS total_hours FROM heating_sim;",
        "step": "【step1】: Analyze the core calculation requirements: The query needs to calculate brand-wise \"value-for-money index\" using (rice_quality_score × warranty_period) / (price × avg_energy_consumption) and sort by quarter. Key tables involved: rice_cooker_info (brand, warranty_period, price) and performance_tests (rice_quality_score, energy_consumption).  【step2】: Build base metrics:  - Aggregate rice_quality_score and energy_consumption from performance_tests  - Join with rice_cooker_info to combine brand, warranty, price, and production_date  - Calculate quarter from production_date  【step3】: Final computation and ordering:  - Compute (AVG(rice_quality_score) * warranty_period) / (price * AVG(energy_consumption)) AS value_index  - Group by brand and quarter  - Sort results by quarter  - Handle potential division-by-zero with NULLIF or similar functions",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1403,
        "question": "Identify high-temperature usage records where the temperature deviation exceeds 5°C, showing the heating element replacement status.",
        "query": "SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.temperature_setting, ur.actual_max_temperature, ABS(ur.actual_max_temperature - ur.temperature_setting) AS temperature_deviation, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Heating%') THEN '加热元件已更换' ELSE '加热元件未更换' END AS heating_element_status FROM usage_records ur WHERE ABS(ur.actual_max_temperature - ur.temperature_setting) > 5",
        "step": "【step1】: Calculate temperature deviation and filter records exceeding ±5℃ by applying WHERE clause on usage_records with ABS(ur.actual_max_temperature - ur.temperature_setting) > 5  【step2】: Check maintenance history via correlated subquery (EXISTS) in CASE expression to detect Heating element replacements in maintenance_records for each rice_cooker_id  【step3】: Combine temperature deviation data with maintenance status, outputting usage_id, device ID, temperature metrics, deviation value, and component status through JOIN-free column projection",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1404,
        "question": "Assuming the use of an electric rice cooker at the summit of Mount Everest (atmospheric pressure ≈ 33 kPa), calculate the proportion of extended cooking time and the additional energy loss caused by the boiling point reduction (Clausius-Clapeyron equation: ln(P1/P2) = L/R(1/T2 - 1/T1)).",
        "query": "SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.time_to_boil * (373 / 344) AS mount_everest_time, (pt.time_to_boil * (373 / 344)) / pt.time_to_boil - 1 AS time_increase_ratio, pt.energy_consumption * (373 / 344 - 1) AS energy_loss FROM performance_tests pt",
        "step": "【step1】: Retrieve base performance data including boiling time and energy consumption from performance_tests table  【step2】: Calculate new boiling time at Mount Everest using thermodynamic ratio (373K/344K) applied to sea-level boiling time  【step3】: Compute time extension ratio using relative duration increase and calculate energy loss from prolonged operation",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1405,
        "question": "Calculate the heat loss rate percentage for different rice cooker materials based on temperature settings and power ratings.",
        "query": "SELECT rci.id AS rice_cooker_id, rci.model, rci.material, rci.power_rating, ur.temperature_setting, ur.actual_max_temperature, CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END AS k, (CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002 AS ΔQ, ((CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002) / rci.power_rating * 100 AS heat_loss_rate_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id",
        "step": "【step1】: Perform INNER JOIN between rice_cooker_info and usage_records tables using rice_cooker_id to combine technical specifications with operational temperature data.  【step2】: Apply CASE statements to assign thermal conductivity coefficient (k) values based on material: 50 for Non-stick, 1.5 for Ceramic, and 16 for Stainless Steel.  【step3】: Calculate heat loss rate using Fourier's Law formula (ΔQ = k*A*ΔT/d) with assumptions (A=0.1m², d=0.002m), then derive percentage heat loss relative to power rating.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1406,
        "question": "Calculate the maintenance cost-benefit ratio for each model of rice cooker by year: (Warranty period × Average rice quality score) / (Total maintenance cost × Usage count), and rank them annually.",
        "query": "WITH MaintenanceAnalysis AS ( SELECT rci.model, YEAR(mr.maintenance_date) AS year, rci.warranty_period, AVG(pt.rice_quality_score) AS avg_quality_score, SUM(mr.maintenance_cost) AS total_maintenance_cost, COUNT(ur.id) AS usage_count FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id GROUP BY rci.model, YEAR(mr.maintenance_date), rci.warranty_period ) SELECT model, year, (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) AS cost_benefit_ratio, RANK() OVER(PARTITION BY year ORDER BY (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) DESC) AS annual_rank FROM MaintenanceAnalysis;",
        "step": "【step1】: Aggregate maintenance, usage, and performance data by model and year. Join maintenance_records with rice_cooker_info to get warranty_period, left join usage_records for usage_count, and left join performance_tests for rice_quality_score averages. Group by model, year, and warranty_period.  【step2】: Calculate the cost-benefit ratio using formula (warranty_period × avg_quality_score) / (total_maintenance_cost × usage_count) from the aggregated MaintenanceAnalysis CTE.  【step3】: Apply RANK() window function partitioned by year to order results annually based on the calculated cost-benefit ratio in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1407,
        "question": "Identify high-energy-consumption records that violate usage regulations (industry standard requires energy consumption per kilogram ≤ 0.8 kWh).",
        "query": "SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.energy_consumption, ur.rice_quantity, ur.energy_consumption / ur.rice_quantity AS energy_per_kg, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN '米饭质量低于平均水平' ELSE '米饭质量正常' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.energy_consumption / ur.rice_quantity > 0.8",
        "step": "【step1】: Execute subquery to calculate average rice_quality_score from performance_tests table  【step2】: Perform LEFT JOIN between usage_records (ur) and performance_tests (pt) using rice_cooker_id  【step3】: Filter records where energy_consumption/rice_quantity > 0.8 and apply CASE expression to compare rice_quality_score against calculated average",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1408,
        "question": "Assuming the use of a rice cooker on a space station (microgravity environment), calculate the impact of water molecule motion on the boiling process (Maxwell-Boltzmann distribution v=√(8kT/πm)), including the time to boil water, velocity of water molecules on Earth and in space, percentage time increase, and energy loss.",
        "query": "SELECT pt.rice_cooker_id, pt.time_to_boil AS earth_time, SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) AS v_earth, SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) AS v_space, pt.time_to_boil * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01))) AS space_time, (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) * 100 AS time_increase_percent, pt.energy_consumption * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) AS energy_loss FROM performance_tests pt",
        "step": "【step1】: Retrieve base data and calculate Earth velocity (v_earth) using Maxwell-Boltzmann distribution formula  【step2】: Calculate space velocity (v_space) by adjusting denominator for microgravity (multiplying m by 0.01)  【step3】: Compute derived metrics (space_time, time_increase_percent, energy_loss) using velocity ratio between Earth and space environments",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1409,
        "question": "How do changes in boiling point at different altitudes affect energy consumption for electric rice cookers, based on the provided performance test data?",
        "query": "SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373 / 363 - 1) AS energy_increase, (373 / 363 - 1) * 100 AS efficiency_loss_percent FROM performance_tests pt",
        "step": "【step1】: Retrieve base performance data (boil time and energy consumption at sea level) from performance_tests table  【step2】: Apply Clausius-Clapeyron simplified calculation - calculate energy increase using (373K/363K-1) ratio representing boiling point temperature variation  【step3】: Calculate efficiency loss percentage through the same thermodynamic ratio multiplied by 100 for percentage conversion",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1410,
        "question": "Calculate the correlation coefficient between the failure rate and maintenance cost of rice cooker brands, grouped by quarter.",
        "query": "WITH MaintenanceAnalysis AS (SELECT rci.brand, QUARTER(mr.maintenance_date) AS quarter, COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) / COUNT(*) AS failure_rate, SUM(mr.maintenance_cost) / COUNT(*) AS avg_maintenance_cost FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id GROUP BY rci.brand, QUARTER(mr.maintenance_date)), CorrelationCalculation AS (SELECT brand, quarter, failure_rate, avg_maintenance_cost, AVG(failure_rate) OVER(PARTITION BY brand) AS mean_failure_rate, AVG(avg_maintenance_cost) OVER(PARTITION BY brand) AS mean_avg_maintenance_cost, (failure_rate - AVG(failure_rate) OVER(PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand)) AS covariance_term, POW(failure_rate - AVG(failure_rate) OVER(PARTITION BY brand), 2) AS variance_failure_rate, POW(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand), 2) AS variance_avg_maintenance_cost FROM MaintenanceAnalysis) SELECT brand, quarter, failure_rate, avg_maintenance_cost, SUM(covariance_term) OVER(PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER(PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER(PARTITION BY brand))) AS correlation_coefficient FROM CorrelationCalculation GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;",
        "step": "【step1】: Calculate quarterly failure rate and average maintenance cost per brand by joining maintenance_records with rice_cooker_info. Use QUARTER() to extract quarter from maintenance_date and aggregate using COUNT(CASE) for repairs/total maintenance ratio and SUM(maintenance_cost)/COUNT for cost per maintenance.  【step2】: Compute covariance and variance components for correlation calculation. Use window functions (AVG OVER PARTITION BY brand) to get brand-level mean values, then calculate deviation products (covariance_term) and squared deviations (variance columns) per quarter.  【step3】: Calculate Pearson correlation coefficient per brand by aggregating covariance terms and normalizing with pooled standard deviations (sqrt(SUM(variance)) terms) via windowed SUM operations partitioned by brand. Group final results by brand and quarter.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1411,
        "question": "Identify records with a water-to-rice ratio outside the industry standard range of 1.2 to 1.8.",
        "query": "SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN '米饭质量低于平均水平' ELSE '米饭质量正常' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8",
        "step": "【step1】: Filter usage records where water-to-rice ratio exceeds 1.8 or falls below 1.2 using WHERE clause with NOT BETWEEN condition  【step2】: LEFT JOIN performance_tests to append rice_quality_score and create subquery calculating average rice_quality_score for comparison  【step3】: Build CASE statement utilizing subquery result to determine rice_quality_status, while calculating water_rice_ratio through direct column division",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1412,
        "question": "Assuming the use of an electric rice cooker in an environment where the energy barrier is 5 eV and the barrier width is 1 nm, calculate the energy loss rate due to the quantum tunneling effect (probability formula P=exp(-2d√(2mE)/ћ)).",
        "query": "SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt",
        "step": "【step1】: [Retrieve base data] Select `rice_cooker_id` and `energy_consumption` from `performance_tests` table.  【step2】: [Calculate tunneling probability] Apply quantum tunneling formula: EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) as tunneling_probability.  【step3】: [Compute energy loss] Multiply `energy_consumption` by `tunneling_probability` and scale by 1e3 to convert to energy loss rate in kilowatt-hours.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1413,
        "question": "Calculate the percentage increase in energy consumption and efficiency loss for rice cookers when accounting for a boiling point change from 363K to 373K.",
        "query": "SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373 / 363 - 1) AS energy_increase, (373 / 363 - 1) * 100 AS efficiency_loss_percent FROM performance_tests pt",
        "step": "【step1】: Retrieve basic performance data from the performance_tests table, including rice_cooker_id, time_to_boil at sea level (aliased as sea_level_time), and energy_consumption at sea level (aliased as sea_level_energy).  【step2】: Apply the Clausius-Clapeyron ratio (373K/363K - 1) to calculate energy_increase by multiplying it with sea_level_energy.  【step3】: Calculate efficiency_loss_percent by converting the energy ratio difference (373K/363K - 1) to a percentage through multiplication with 100.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1414,
        "question": "Calculate the correlation coefficient between failure rates and average maintenance costs for rice cooker brands by quarter.",
        "query": "WITH MaintenanceAnalysis AS (SELECT rci.brand, QUARTER(mr.maintenance_date) AS quarter, COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) / COUNT(*) AS failure_rate, SUM(mr.maintenance_cost) / COUNT(*) AS avg_maintenance_cost FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id GROUP BY rci.brand, QUARTER(mr.maintenance_date)), CorrelationCalculation AS (SELECT brand, quarter, failure_rate, avg_maintenance_cost, AVG(failure_rate) OVER(PARTITION BY brand) AS mean_failure_rate, AVG(avg_maintenance_cost) OVER(PARTITION BY brand) AS mean_avg_maintenance_cost, (failure_rate - AVG(failure_rate) OVER(PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand)) AS covariance_term, POW(failure_rate - AVG(failure_rate) OVER(PARTITION BY brand), 2) AS variance_failure_rate, POW(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand), 2) AS variance_avg_maintenance_cost FROM MaintenanceAnalysis) SELECT brand, quarter, failure_rate, avg_maintenance_cost, SUM(covariance_term) OVER(PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER(PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER(PARTITION BY brand))) AS correlation_coefficient FROM CorrelationCalculation GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;",
        "step": "【step1】: Aggregate quarterly maintenance data by brand, calculating failure rate (repair count/total) and average cost using JOIN between maintenance_records and rice_cooker_info with GROUP BY brand/quarter.  【step2】: Compute covariance components and variances per brand via window functions - calculate deviations from brand-level averages for failure_rate/avg_maintenance_cost, then derive covariance_term, variance_failure_rate, and variance_avg_maintenance_cost.  【step3】: Calculate final correlation coefficient per brand using aggregated covariance and variances (Pearson formula) while preserving quarterly dimensions through GROUP BY brand/quarter with windowed SUM operations.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1415,
        "question": "Identify records of water-to-rice ratio that violate usage standards (industry standards require the water-to-rice ratio to be between 1.2 and 1.8).",
        "query": "SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN '米饭质量低于平均水平' ELSE '米饭质量正常' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8",
        "step": "【step1】: Filter usage records where the water-to-rice ratio falls outside the 1.2-1.8 range using WHERE clause with arithmetic operation and BETWEEN exclusion  【step2】: Left join with performance_tests to append rice quality scores through rice_cooker_id association  【step3】: Calculate dynamic average rice quality score via subquery and apply conditional labeling using CASE statement for quality status comparison",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1416,
        "question": "Assuming the use of an electric rice cooker in a zero-barrier energy environment (5 eV), calculate the energy loss rate caused by the quantum tunneling effect (probability formula P=exp(-2d√(2mE)/ħ)).",
        "query": "SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt",
        "step": "【step1】: Retrieve rice_cooker_id and energy_consumption from performance_tests table  【step2】: Calculate tunneling_probability using quantum tunneling formula EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34)  【step3】: Compute energy_loss by multiplying energy_consumption with tunneling_probability and scaling factor 1e3",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1417,
        "question": "Calculate the thermal stress, tensile strength, and safety status for each rice cooker model based on its material and final temperature.",
        "query": "SELECT rci.id AS rice_cooker_id, rci.model, rci.material, pt.final_temperature, CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END AS thermal_stress, CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END AS tensile_strength, CASE WHEN CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END < CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END THEN '安全' ELSE '不安全' END AS safety_status FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id",
        "step": "【step1】: JOIN rice_cooker_info and performance_tests tables using rice_cooker_id to combine product material data with temperature measurements  【step2】: Calculate thermal_stress and tensile_strength using CASE statements with material-specific thermal expansion coefficients and modulus values  【step3】: Compare thermal_stress with tensile_strength using nested CASE to determine safety_status (\"安全\" when stress < strength)",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1418,
        "question": "Constructing a full life-cycle cost model for rice cookers: (Initial price + SUM(Maintenance cost)) / (Number of uses × Average rice quality score)^0.5, normalized and ranked by brand.",
        "query": "WITH LifecycleCost AS (SELECT rci.brand, rci.price + SUM(mr.maintenance_cost) AS total_cost, COUNT(ur.id) AS usage_count, AVG(pt.rice_quality_score) AS avg_quality_score FROM rice_cooker_info rci LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id GROUP BY rci.brand, rci.price), NormalizedCost AS (SELECT brand, total_cost / POWER(usage_count * avg_quality_score, 0.5) AS lifecycle_cost, (total_cost / POWER(usage_count * avg_quality_score, 0.5) - MIN(total_cost / POWER(usage_count * avg_quality_score, 0.5)) OVER ()) / (MAX(total_cost / POWER(usage_count * avg_quality_score, 0.5)) OVER () - MIN(total_cost / POWER(usage_count * avg_quality_score, 0.5)) OVER ()) AS normalized_cost FROM LifecycleCost) SELECT brand, lifecycle_cost, normalized_cost, DENSE_RANK() OVER (ORDER BY normalized_cost) AS brand_rank FROM NormalizedCost",
        "step": "【step1】: (Calculate Lifecycle Cost Components) Use a CTE to aggregate maintenance costs, count usage records, and average rice quality scores per brand. Left join rice_cooker_info with maintenance_records, usage_records, and performance_tests tables. Group by brand and price to compute total_cost (price + maintenance sum), usage_count, and avg_quality_score.  【step2】: (Compute Normalized Cost) In a second CTE, calculate lifecycle_cost via the formula (total_cost / (usage_count * avg_quality_score)^0.5). Then normalize this value using MIN/MAX window functions to create normalized_cost across all brands.  【step3】: (Rank Brands) Apply DENSE_RANK() over the normalized_cost to generate brand rankings. Select brand, lifecycle_cost, normalized_cost, and the computed rank for the final output ordered by normalized_cost.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1419,
        "question": "Identify cleaning records that violate the safety standards for food contact materials by having a cleaning interval exceeding 3 months or by using acidic cleaning agents on stainless steel or ceramic materials.",
        "query": "WITH CleaningAnalysis AS (SELECT mr.rice_cooker_id, mr.maintenance_date, mr.maintenance_notes, rci.material, DATEDIFF(mr.maintenance_date, LAG(mr.maintenance_date) OVER (PARTITION BY mr.rice_cooker_id ORDER BY mr.maintenance_date)) AS cleaning_interval FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id) SELECT rice_cooker_id, maintenance_date, maintenance_notes, material, cleaning_interval, CASE WHEN cleaning_interval > 90 THEN '清洁间隔超过3个月' WHEN maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic') THEN '使用酸性清洁剂' ELSE '符合规范' END AS violation_status FROM CleaningAnalysis WHERE cleaning_interval > 90 OR (maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic'))",
        "step": "【step1】: Create a CTE \"CleaningAnalysis\" by joining maintenance_records and rice_cooker_info. Calculate cleaning intervals using LAG window function partitioned by devices and ordered by dates.  【step2】: Evaluate violation status through CASE logic - check intervals exceeding 90 days and detect acid cleaning mentions in notes for stainless/ceramic materials.  【step3】: Filter results using WHERE clause to show only records violating either temporal requirement (cleaning_interval >90) or chemical requirement (acid usage on restricted materials).",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1420,
        "question": "Assume heating the inner chamber in the superconducting state (resistance = 0Ω), calculate the temperature oscillation amplitude, temperature oscillation rate, and energy fluctuation caused by quantum locking effect (Ginzburg-Landau equation ΔT=ψ₀²/(2mξ₀²kB√τ)).",
        "query": "SELECT pt.rice_cooker_id, pt.final_temperature, (1.05e-34) / (2 * 9.1e-31 * POW(1e-8, 2) * 1.38e-23 * 1e-6) AS ΔT, (1.05e-34) / (2 * 9.1e-31 * POW(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature AS temperature_oscillation_rate, pt.energy_consumption * ((1.05e-34) / (2 * 9.1e-31 * POW(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature) AS energy_fluctuation FROM performance_tests pt",
        "step": "【step1】: Retrieve performance test data including rice_cooker_id, final_temperature, and energy_consumption from the performance_tests table.  【step2】: Compute ΔT using the Ginzburg-Landau equation formula with hardcoded constants (1.05e-34, 9.1e-31, etc.) and physical parameters.  【step3】: Derive temperature_oscillation_rate (ΔT / final_temperature) and energy_fluctuation (energy_consumption × temperature_oscillation_rate) as calculated metrics.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1421,
        "question": "Calculate the actual power consumption of the rice cooker under a 230V supply, and determine the corrected thermal efficiency by adjusting for voltage differences using the power formula.",
        "query": "SELECT ur.rice_cooker_id, rci.power_rating, rci.voltage_rating, ur.energy_consumption, ur.duration, 230 AS V_supply, rci.power_rating * (POW(230, 2) / POW(rci.voltage_rating, 2)) AS P_actual, (ur.energy_consumption * 1000 / (rci.power_rating * (POW(230, 2) / POW(rci.voltage_rating, 2)) * ur.duration / 60)) * POW(rci.voltage_rating / 230, 2) AS η_corrected FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id",
        "step": "【step1】: Perform INNER JOIN between `usage_records` and `rice_cooker_info` tables using `rice_cooker_id` to combine operational data with product specifications  【step2】: Calculate actual power (P_actual) using voltage adjustment formula: `power_rating * (230² / voltage_rating²)` based on Ohm's Law  【step3】: Compute corrected thermal efficiency (η_corrected) through energy conversion formula considering scaled power and voltage ratio: `(energy_consumption*1000/(P_actual*duration/60)) * (voltage_rating/230)²`",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1422,
        "question": "Construct a quality degradation index for rice cookers: LN(number of uses) × (MAX(rice_quality_score) - current score) / cumulative maintenance cost, sorted by year.",
        "query": "WITH QualityDecay AS (SELECT rci.model, YEAR(pt.test_date) AS year, pt.rice_quality_score, MAX(pt.rice_quality_score) OVER(PARTITION BY rci.model) - pt.rice_quality_score AS quality_decay, SUM(mr.maintenance_cost) OVER(PARTITION BY rci.model ORDER BY pt.test_date) AS cumulative_maintenance_cost, COUNT(ur.id) OVER(PARTITION BY rci.model) AS usage_count FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id) SELECT model, year, rice_quality_score, LN(usage_count) * quality_decay / cumulative_maintenance_cost AS decay_index, DENSE_RANK() OVER(PARTITION BY year ORDER BY LN(usage_count) * quality_decay / cumulative_maintenance_cost DESC) AS annual_rank FROM QualityDecay",
        "step": "【step1】: Join multiple tables to aggregate performance data, usage records, and maintenance costs per model. Extract test year and calculate quality decay as (max_score - current_score).  【step2】: Compute window functions: cumulative maintenance cost (rolling sum by model), usage count (total per model), and quality decay value.  【step3】: Calculate decay_index using formula LN(usage_count)*quality_decay/cumulative_maintenance_cost, then apply annual ranking via DENSE_RANK() partitioned by year.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1423,
        "question": "Identify usage records with voltage anomalies where the supply voltage deviates by more than ±10% from the rated voltage.",
        "query": "CREATE TEMPORARY TABLE temp_voltage_logs (usage_id INT, supply_voltage DECIMAL(5, 2)); INSERT INTO temp_voltage_logs (usage_id, supply_voltage) SELECT ur.id AS usage_id, 200 + RAND() * 40 AS supply_voltage FROM usage_records ur; WITH VoltageLog AS (SELECT ur.rice_cooker_id, ur.id AS usage_id, vl.supply_voltage, rci.voltage_rating, CASE WHEN vl.supply_voltage < 0.9 * rci.voltage_rating OR vl.supply_voltage > 1.1 * rci.voltage_rating THEN '电压异常' ELSE '电压正常' END AS voltage_status, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Power%') THEN '电源模块已更换' ELSE '电源模块未更换' END AS power_module_status FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id JOIN temp_voltage_logs vl ON ur.id = vl.usage_id) SELECT rice_cooker_id, usage_id, supply_voltage, voltage_rating, voltage_status, power_module_status FROM VoltageLog WHERE voltage_status = '电压异常';",
        "step": "【step1】: Create temporary table with simulated voltage data (200±20V range) by joining usage records with random voltage values between 180V-240V  【step2】: Build CTE with three-way join (usage_records ↔ rice_cooker_info ↔ temp_voltage_logs), calculate voltage status using ±10% tolerance check and maintenance history verification  【step3】: Filter final results showing only records where voltage exceeds allowable range, including power module replacement status",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1424,
        "question": "Assuming a standard Earth gravity environment, calculate the impact of a fixed scaling factor on the rice cooker's quality score and energy consumption.",
        "query": "SELECT pt.rice_cooker_id, pt.rice_quality_score, pt.energy_consumption, EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)) AS curvature_factor, pt.rice_quality_score * (1 - EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)))) AS quality_distortion, pt.energy_consumption / EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS energy_distortion FROM performance_tests pt",
        "step": "【step1】: Select base fields (rice_cooker_id, rice_quality_score, energy_consumption) from performance_tests  【step2】: Calculate curvature_factor using EXP(-POWER(0.2,2)/(8*POWER(1,2)))  【step3】: Compute quality_distortion (rice_quality_score scaled by curvature) and energy_distortion (energy_consumption adjusted via inverse curvature)",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1425,
        "question": "Based on the calculation of the condensation water recovery efficiency in electric rice cookers, derive its impact on the total energy consumption. Given the latent heat of vaporization of water L=2260 kJ/kg, assuming a condensation recovery rate η=60%, calculate the energy-saving benefit ΔE=(water_quantity × water_evaporation_rate% × η × L)/3600 according to the law of energy conservation and the latent heat formula Q=mL+mcΔT, and compare it with the actual energy consumption E_actual=energy_consumption.",
        "query": "CREATE TEMPORARY TABLE temp_voltage_logs (usage_id INT, supply_voltage DECIMAL(5, 2)); INSERT INTO temp_voltage_logs (usage_id, supply_voltage) SELECT ur.id AS usage_id, 200 + RAND() * 40 AS supply_voltage FROM usage_records ur; WITH VoltageLog AS (SELECT ur.rice_cooker_id, ur.id AS usage_id, vl.supply_voltage, rci.voltage_rating, CASE WHEN vl.supply_voltage < 0.9 * rci.voltage_rating OR vl.supply_voltage > 1.1 * rci.voltage_rating THEN '电压异常' ELSE '电压正常' END AS voltage_status, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Power%') THEN '电源模块已更换' ELSE '电源模块未更换' END AS power_module_status FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id JOIN temp_voltage_logs vl ON ur.id = vl.usage_id) SELECT rice_cooker_id, usage_id, supply_voltage, voltage_rating, voltage_status, power_module_status FROM VoltageLog WHERE voltage_status = '电压异常';",
        "step": "【step1】: Create temporary table 'temp_voltage_logs' and populate with usage IDs from 'usage_records' along with randomized supply voltages between 200V-240V.  【step2】: Build CTE 'VoltageLog' by joining usage records with appliance specs and maintenance data. Calculate voltage status (abnormal if outside ±10% of rating) and power module replacement status via subquery.  【step3】: Filter final output to show only records with abnormal voltage status, displaying cooker ID, usage ID, measured voltage, rated voltage, status flags for voltage and power module replacement.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1426,
        "question": "Construct a dynamic weighted comprehensive evaluation model to assess the overall performance of rice cookers. The model's weight distribution is as follows: rice quality score accounts for 40%, energy efficiency ratio for 30%, maintenance frequency for 20%, and price index for 10%. Standardization is required for rice quality score, energy efficiency ratio, maintenance frequency, and price index. The calculation formulas are: standardized rice quality score = (rice_quality_score - MIN) / (MAX - MIN), energy efficiency ratio = AVG(energy_consumption) / AVG(rice_quantity), maintenance frequency = COUNT(maintenance_records) / COUNT(usage_records), price index = 1 - (price - MIN) / (MAX - MIN). Finally, generate a comprehensive score ranking by brand.",
        "query": "SELECT pt.rice_cooker_id, pt.rice_quality_score, pt.energy_consumption, EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS curvature_factor, pt.rice_quality_score * (1 - EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)))) AS quality_distortion, pt.energy_consumption / EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS energy_distortion FROM performance_tests pt;",
        "step": "【step1】: Calculate required metrics with JOIN operations: Combine rice_cooker_info, usage_records, maintenance_records, and performance_tests to compute energy_ratio (AVG(energy_consumption)/AVG(rice_quantity)), maintenance_frequency (COUNT(maintenance)/usage_count), and price_index (1-(price-MIN(price))/(MAX(price)-MIN(price)))  【step2】: Perform normalization using window functions: Compute standardized scores for rice_quality_score (MIN/MAX by brand), energy_ratio (MIN/MAX by brand), and maintenance_frequency (MIN/MAX by brand)  【step3】: Calculate weighted sum and rank: Apply weights (40% rice_score + 30% energy_ratio + 20% maintenance_freq + 10% price_index) then aggregate by brand using GROUP BY and RANK() OVER ORDER BY total_score DESC",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1427,
        "question": "According to the national standard GB14536.1-2008, the response time of thermistors for temperature control should be ≤3 seconds/℃. By calculating the temperature rise rate = (final_temperature - initial_temperature) / time_to_boil, filter out records with a temperature rise rate exceeding 0.33℃/s, and cross-check with maintenance logs to identify any records of thermistor replacements, thus detecting abnormal entries that violate safety standards.",
        "query": "SELECT pt.*, (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) AS 温升速率, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = pt.rice_cooker_id AND mr.replaced_parts LIKE '%Thermistor%') THEN '已维护' ELSE '未维护' END AS 维护状态 FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) > 0.33 AND ABS(ur.actual_max_temperature - ur.temperature_setting) > 5;",
        "step": "【step1】: Join performance_tests with usage_records, calculate temperature rise rate using formula (final_temperature - initial_temperature)/(time_to_boil*60), and filter records where temperature rise rate > 0.33℃/s and actual/desired temperature difference >5℃  【step2】: Correlate maintenance_records subquery to check thermistor replacement status using LIKE '%Thermistor%' condition through rice_cooker_id association  【step3】: Combine results with dynamic CASE expression to display maintenance status and final filtering based on safety standard violations",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1428,
        "question": "Assuming a rice cooker is heated at the Planck temperature (1.4×10³² K), calculate the mass of a black hole equivalent to the rice cooker's weight multiplied by heating time, its Schwarzschild radius, the time dilation factor, the Hawking temperature based on the black hole mass, and the quantum energy consumption by multiplying Hawking temperature with the rice cooker's energy consumption.",
        "query": "SELECT rci.id AS rice_cooker_id, rci.model, rci.weight, ur.duration AS heating_time, (rci.weight * ur.duration * 60) AS black_hole_mass, (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)) AS schwarzschild_radius, SQRT(1 - (2 * 6.67430e-11 * (rci.weight * ur.duration * 60)) / (POWER(299792458, 2) * (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)))) AS time_dilation_factor, (1.0545718e-34 * POWER(299792458, 3)) / (8 * PI() * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) AS hawking_temperature, (1.0545718e-34 * POWER(299792458, 3)) / (8 * PI() * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) * ur.energy_consumption AS quantum_energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE ur.temperature_setting >= 1.4e32;",
        "step": "【step1】: Perform INNER JOIN between rice_cooker_info and usage_records using rice_cooker_id, filtering records where temperature_setting meets Planck temperature threshold (1.4e32°C)  【step2】: Calculate core physical parameters:  - black_hole_mass = weight × duration (converted to seconds)  - schwarzschild_radius using gravitational constant (6.67430e-11) and relativistic terms  【step3】: Derive complex quantum metrics:  - Simplify time_dilation_factor expression using calculated schwarzschild_radius  - Compute hawking_temperature through Hawking radiation formula constants  - Calculate quantum_energy_consumption by combining hawking_temperature with existing energy_consumption data",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1429,
        "question": "Calculate the average temperature rise rate and thermal conduction time constant for rice cooker inner pots grouped by material.",
        "query": "SELECT rci.material, AVG(ur.actual_max_temperature - ur.temperature_setting) / AVG(ur.duration) AS 平均温升速率, AVG(rci.capacity * rci.weight) / (AVG(rci.power_rating) * 1000) AS 热传导时间常数 FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id GROUP BY rci.material;",
        "step": "【step1】:【Join rice_cooker_info and usage_records tables by rice_cooker_id, then group by material to aggregate data for each inner pot material.】  【step2】:【Calculate average temperature rise rate per material by dividing the average temperature difference (actual_max_temperature - temperature_setting) by average duration.】  【step3】:【Derive thermal conduction time constant using the formula AVG(capacity * weight) / (AVG(power_rating) * 1000), approximating Biot number logic by combining thermal mass (capacity*weight) and power input (power_rating).】",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1430,
        "question": "Constructing a rice cooker health index: EXP(-maintenance cost/price)×(1+LN(usage frequency))×coefficient of variation for rice quality score and analyzing trends by quarter and year.",
        "query": "WITH usage_count AS (SELECT rice_cooker_id, COUNT(*) AS usage_times FROM usage_records GROUP BY rice_cooker_id), maintenance_cost_sum AS (SELECT rice_cooker_id, SUM(maintenance_cost) AS total_maintenance_cost FROM maintenance_records GROUP BY rice_cooker_id), rice_quality_variation AS (SELECT rice_cooker_id, STDDEV(rice_quality_score) / AVG(rice_quality_score) AS rice_quality_cv FROM performance_tests GROUP BY rice_cooker_id) SELECT rci.id AS rice_cooker_id, rci.model, EXP(-mcs.total_maintenance_cost / rci.price) * (1 + LN(uc.usage_times)) * rqv.rice_quality_cv AS health_index, QUARTER(ur.start_time) AS quarter, YEAR(ur.start_time) AS year FROM rice_cooker_info rci JOIN usage_count uc ON rci.id = uc.rice_cooker_id JOIN maintenance_cost_sum mcs ON rci.id = mcs.rice_cooker_id JOIN rice_quality_variation rqv ON rci.id = rqv.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id GROUP BY rci.id, rci.model, mcs.total_maintenance_cost, rci.price, uc.usage_times, rqv.rice_quality_cv, QUARTER(ur.start_time), YEAR(ur.start_time);",
        "step": "【step1】: Calculate aggregated metrics using three CTEs: usage_count (total usages per cooker), maintenance_cost_sum (total maintenance cost per cooker), and rice_quality_variation (coefficient of variation for rice quality scores per cooker).  【step2】: Join base table rice_cooker_info with all three CTEs and compute the health_index using the formula EXP(-total_maintenance_cost/price) * (1 + LN(usage_times)) * rice_quality_cv.  【step3】: Extract year and quarter from usage_records.start_time, group by cooker attributes, calculated metrics, and temporal dimensions (year/quarter) to finalize trend predictions.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1431,
        "question": "Identify usage patterns where the cooling interval between continuous rice cooking sessions is less than 15 minutes and rice quantity exceeds 0.5, starting from 2023-01-01, including whether the rice cooker has an overheat repair record.",
        "query": "WITH usage_sequence AS (SELECT device_id, start_time, end_time, rice_quantity, (julianday(start_time) - julianday(LAG(end_time) OVER(PARTITION BY device_id ORDER BY start_time))) * 1440 AS cooling_interval FROM usage_logs) SELECT us.*, CASE WHEN EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.device_id = us.device_id AND ml.maintenance_type = 'Overheat Repair') THEN 1 ELSE 0 END AS has_overheat_repair FROM usage_sequence us WHERE cooling_interval < 15 AND rice_quantity > 0.5 AND start_time > '2023-01-01';",
        "step": "【step1】: Calculate cooling intervals between consecutive cooking sessions for each device using LAG window function to get previous session's end time, compute time difference in minutes.  【step2】: Correlate usage sequences with maintenance records using EXISTS subquery to identify devices with 'Overheat Repair' maintenance history.  【step3】: Filter records where cooling interval <15 minutes, rice quantity >0.5kg, and usage occurred after 2023-01-01 to detect IEC violations.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1432,
        "question": "What are the performance metrics (model, brand, rice quantity, water quantity, water evaporation rate, rice quality score, and energy consumption) for rice cookers when cooking rice, given that both rice and water quantities are positive?",
        "query": "SELECT rci.model, rci.brand, ur.rice_quantity, ur.water_quantity, pt.water_evaporation_rate, pt.rice_quality_score, pt.energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id JOIN performance_tests pt ON rci.id = pt.rice_cooker_id WHERE pt.test_type = '煮饭' AND ur.rice_quantity > 0 AND ur.water_quantity > 0;",
        "step": "【step1】: Perform INNER JOIN between rice_cooker_info (rci) and usage_records (ur) using rice_cooker_id to associate basic cooker data with usage metrics  【step2】: Join the result with performance_tests (pt) via rice_cooker_id to incorporate cooking performance metrics  【step3】: Filter records where test_type is '煮饭' with valid rice/water quantities (ur.rice_quantity >0 AND ur.water_quantity >0), then select specified fields from joined tables",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1433,
        "question": "Calculate the initial temperature, final temperature, energy consumption, and time to boil for rice cookers during the heat preservation phase.",
        "query": "SELECT rice_cooker_id, test_date, initial_temperature, final_temperature, energy_consumption, time_to_boil FROM performance_tests WHERE test_type = '保温';",
        "step": "【step1】: Retrieve basic thermal parameters from performance_tests table including initial/final temperatures and energy consumption  【step2】: Filter records where test_type is '保温' (heat preservation) using WHERE clause  【step3】: (Not required) The actual physical calculations would need additional physics formulas and material properties not present in current schema",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1434,
        "question": "Construct a dynamic comprehensive quality index: 0.5 × (Rice Score Z-score) + 0.3 × (1 - Energy Efficiency Coefficient of Variation) - 0.2 × Maintenance Cost Ratio and generate a monthly trend chart by brand.",
        "query": "SELECT rc.model, ur.energy_consumption, ROUND(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12)),4) AS maturation_degree, ur.energy_consumption * (1/(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12))) - 1) AS energy_distortion, SQRT(1.38e-23*2e12/(1.05e-34*3e8)) * ur.duration*60 AS quantum_fluctuation FROM rice_cooker_info rc JOIN usage_records ur ON rc.id = ur.rice_cooker_id WHERE ur.duration > 0;",
        "step": "【step1】: Calculate Z-scores for rice quality scores by model and month using performance_tests data, including AVG(rice_quality_score) and STDDEV(rice_quality_score) in window functions  【step2】: Compute maintenance cost ratios by joining maintenance_records with rice_cooker_info, aggregating monthly maintenance costs per brand and calculating percentage of total costs  【step3】: Combine metrics using weighted formula (0.5*z_score + 0.3*(1-energy_cv) - 0.2*maintenance_ratio) with time-series aggregation by brand/month from all joined tables",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1435,
        "question": "Identify hazardous records of overcapacity usage (according to IEC 60335, the measured quantity must not exceed 120% of the nominal capacity)",
        "query": "SELECT rc.model, pt.final_temperature, ur.duration, (pt.final_temperature - 25) AS_T, ROUND((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration), 2) AS total_heat_loss_J, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600, 2) AS heat_loss_kWh, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600 / (0.1 * rc.power_rating * ur.duration / 60), 2) AS efficiency_ratio FROM rice_cooker_info rc JOIN performance_tests pt ON rc.id = pt.rice_cooker_id JOIN usage_records ur ON rc.id = ur.rice_cooker_id;",
        "step": "【step1】: Join tables `rice_cooker_info`, `performance_tests`, and `usage_records` via `id` to consolidate relevant data.  【step2】: Compute intermediate values like `AS_T` (temperature difference) and components of heat loss formulas.  【step3】: Calculate and format final metrics (`total_heat_loss_J`, `heat_loss_kWh`, `efficiency_ratio`) using combined thermal equations and unit conversions.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1436,
        "question": "Calculate the monthly quality index and its trend for each manufacturer based on rice cookers' performance data, including standardized rice quality scores, energy efficiency variation, and maintenance cost ratios.",
        "query": "WITH monthly_data AS (SELECT rc.brand AS manufacturer, DATE_FORMAT(pt.test_date, '%Y-%m') AS month, (pt.rice_quality_score - AVG(pt.rice_quality_score) OVER()) / (STDDEV(pt.rice_quality_score) OVER()) AS z_score, 1 - (STDDEV(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand) / AVG(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand)) AS efficiency_variation, SUM(mr.maintenance_cost) OVER(PARTITION BY rc.brand) / rc.price AS maintenance_ratio FROM rice_cooker_info rc LEFT JOIN usage_records ur ON rc.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rc.id = mr.rice_cooker_id JOIN performance_tests pt ON rc.id = pt.rice_cooker_id) SELECT manufacturer, month, ROUND(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio, 2) AS quality_index, AVG(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio) OVER(ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS trend FROM monthly_data ORDER BY manufacturer, month;",
        "step": "【step1】: Create CTE `monthly_data` by joining four tables:  - LEFT JOIN rice_cooker_info with usage_records/maintenance_records  - INNER JOIN performance_tests  - Calculate z-score (normalized rice quality deviation) using WINDOW function  - Compute efficiency_variation through energy consumption per rice quantity variation per brand  - Calculate maintenance_ratio as total maintenance cost divided by rice cooker price  【step2】: Main query calculation:  - Compute quality_index (0.5*z_score + 0.3*efficiency_variation - 0.2*maintenance_ratio)  - Calculate 3-month moving average trend using WINDOW function with ROWS BETWEEN 2 PRECEDING clause  【step3】: Finalize output:  - Sort results by manufacturer and month  - Round quality_index to 2 decimal places  - Return manufacturer, month, quality_index, and trend columns",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1437,
        "question": "Find the usage records where the rice quantity exceeds 120% of the rice cooker's capacity, and for each record, show the usage ID, rice cooker model, rice quantity, capacity, overload ratio, and whether the rice cooker has a maintenance record indicating inner pot deformation.",
        "query": "SELECT ul.id AS usage_id, di.model, ul.rice_quantity, di.capacity, ul.rice_quantity / di.capacity AS overload_ratio, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records ml WHERE ml.rice_cooker_id = ul.rice_cooker_id AND ml.maintenance_notes LIKE '%内胆变形%') THEN 1 ELSE 0 END AS has_deformation FROM usage_records ul JOIN rice_cooker_info di ON ul.rice_cooker_id = di.id WHERE ul.rice_quantity > 1.2 * di.capacity",
        "step": "【step1】: Perform INNER JOIN between 'usage_records' and 'rice_cooker_info' tables using rice_cooker_id to combine usage data with appliance specifications.  【step2】: Execute correlated subquery on 'maintenance_records' to detect \"inner pot deformation\" notes via CASE expression, generating binary has_deformation flag.  【step3】: Apply WHERE filter for rice_quantity exceeding 120% capacity and calculate overload_ratio through rice_quantity/capacity division.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1438,
        "question": "Calculate the present value of total life cycle costs for devices: PV = initial_price + Σ(maintenance_cost/(1+r)^n), where r=5% annual discount rate. Iterate through maintenance records, compute the discount factor for each maintenance event, accumulate the present value costs, and finally generate a ranking of total present value costs by brand.",
        "query": "SELECT di.model, pt.time_to_boil, ul.energy_consumption, ROUND(1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27, 30) AS k_quantum, ROUND(SQRT((1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27) / 0.6), 2) AS time_compression_ratio, ROUND(ul.energy_consumption / SQRT((1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27) / 0.6), 2) AS energy_gain, CASE WHEN ul.energy_consumption < (di.power_rating * pt.time_to_boil / 60 / SQRT((1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27) / 0.6)) THEN '安全' ELSE '超限' END AS quantum_limit FROM rice_cooker_info di JOIN performance_tests pt ON di.id = pt.rice_cooker_id JOIN usage_records ul ON di.id = ul.rice_cooker_id",
        "step": "【step1】: Calculate maintenance_cost/(1.05)^n for each maintenance record using DATEDIFF/NOW() to determine time period 'n' between maintenance_date and production_date  【step2】: Aggregate discounted maintenance costs per device (SUM), add initial price from rice_cooker_info.price  【step3】: Group results by brand, calculate total present value cost per brand, then rank using RANK() OVER (ORDER BY total_pv DESC)",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1439,
        "question": "Identify the model and material of rice cookers, their actual boil time in minutes, theoretical diffusion time in seconds, and the percentage deviation between actual and theoretical time, for rice cookers made of Stainless Steel or Ceramic.",
        "query": "SELECT di.model, di.material, pt.time_to_boil AS 实际煮沸时间_min, ROUND(CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END, 2) AS 理论扩散时间_s, ROUND((pt.time_to_boil*60 - CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END) / CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END *100, 1) AS 时间偏差率_percent FROM rice_cooker_info di JOIN performance_tests pt ON di.id = pt.rice_cooker_id WHERE di.material IN ('Stainless Steel','Ceramic')",
        "step": "【step1】: Perform INNER JOIN between rice_cooker_info (aliased as di) and performance_tests (aliased as pt) tables using rice_cooker_id, filtering materials to 'Stainless Steel' or 'Ceramic'  【step2】: Calculate theoretical diffusion time using CASE expression with material-specific physics formulas, rounded to 2 decimal places  【step3】: Compute time deviation percentage by comparing actual boil time (converted to seconds) with theoretical value, applying material-dependent calculation and rounding to 1 decimal",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1440,
        "question": "Assuming the use of a rice cooker inside a curvature propulsion drive (spatial compression ratio η=10^6), calculate the spacetime distortion energy consumption during cooking (energy density W=-(c^6/(8πG))σ^5 in the Alcubierre metric). Based on fictional parameters (curvature bubble radius R=3m, wall thickness σ=1m), use performance_tests.energy_consumption to verify whether W exceeds the critical cosmic density ρ_c=9.9×10^6kg/m^6.",
        "query": "WITH numbers AS (SELECT (a.n + b.n * 10 + c.n * 100 + d.n * 1000) AS n FROM (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) a CROSS JOIN (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) b CROSS JOIN (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) c CROSS JOIN (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) d WHERE (a.n + b.n * 10 + c.n * 100 + d.n * 1000) BETWEEN 1 AND 10000), lifetime_simulation AS (SELECT di.id AS device_id, RAND() AS rand_value, EXP(-SUM(0.01 * ul.rice_quantity * (DATEDIFF(ml.maintenance_date, di.production_date)) / 365)) AS survival_probability FROM numbers CROSS JOIN rice_cooker_info di LEFT JOIN maintenance_records ml ON di.id = ml.rice_cooker_id LEFT JOIN usage_records ul ON di.id = ul.rice_cooker_id GROUP BY di.id, numbers.n) SELECT ls.device_id AS id, AVG(CASE WHEN ls.rand_value > ls.survival_probability THEN (DATEDIFF(CURDATE(), di.production_date)) / 365 ELSE 999 END) AS simulated_lifetime FROM lifetime_simulation ls JOIN rice_cooker_info di ON ls.device_id = di.id GROUP BY ls.device_id;",
        "step": "【step1】: Generate number series (1-10,000) using recursive CTE with CROSS JOINs between 4 digit tables (0-9 for units/tens/hundreds/thousands places)  【step2】: Create Monte Carlo simulation by:  1. CROSS JOIN device info with numbers to create 10,000 simulation points per device  2. LEFT JOIN maintenance/usage records to calculate survival probability using exponential decay model based on rice quantity and operational time  【step3】: Calculate average simulated lifespan using:  1. Conditional CASE that returns actual age if random value exceeds survival probability  2. GROUP BY device with AVG() aggregation to determine mean lifetime  3. JOIN production_date from base table for age calculation",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1441,
        "question": "Calculate the thermal shock risk index for rice cooker inner pot materials and derive the safety threshold under rapid cooling/heating conditions. Based on the thermal stress formula σ = αEΔT / (1 - ν) and fracture toughness parameters, assuming thermal expansion coefficient α: ceramic 4.5e-6/°C, stainless steel 17.3e-6/°C; elastic modulus E: ceramic 350GPa, stainless steel 200GPa; Poisson's ratio ν = 0.25; fracture toughness K_IC: ceramic 3MPa√m, stainless steel 100MPa√m. Calculate the critical temperature difference ΔT_c = K_IC(1 - ν) / (αE√(πa)) (crack size a = 0.1mm), then derive the risk index and safety conditions.",
        "query": "SELECT pt.*, rci.power_rating FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE (pt.time_to_boil < 15 OR rci.power_rating > 1000) AND EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = rci.id AND mr.replaced_parts = '电磁屏蔽组件');",
        "step": "【step1】: Perform an INNER JOIN between performance_tests and rice_cooker_info using rice_cooker_id to combine test data with appliance specifications.  【step2】: Apply filter conditions (time_to_boil < 15 OR power_rating > 1000) to select high-performance/critical scenarios.  【step3】: Validate existence of maintenance records with '电磁屏蔽组件' replacement via subquery, ensuring devices comply with safety maintenance requirements.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1442,
        "question": "Construct a comprehensive energy efficiency evaluation model based on the entropy weight method. Calculate the standardized value of each indicator as p_ij = (x_ij - min) / (max - min), the information entropy Ej = -Σ(p_ij * ln(p_ij)) / ln(n), the weight w_j = (1 - Ej) / Σ(1 - Ej), and the comprehensive score = Σ(w_j * p_ij). The indicators include energy consumption, boiling time, and rice quality score.",
        "query": "SELECT rci.model, ur.energy_consumption, ROUND(ABS( (POWER(3e8,4)/(8*PI()*6.67e-11)) * POWER(1/3,2) ) / 9.9e-27, 2) AS 能量密度比, CASE WHEN (ur.energy_consumption*3.6e6 / (0.005*0.18)) < ABS( (POWER(3e8,4)/(8*PI()*6.67e-11)) * POWER(1/3,2) ) THEN '满足曲率条件' ELSE '能量不足' END AS 验证结果 FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id JOIN performance_tests pt ON rci.id = pt.rice_cooker_id;",
        "step": "【step1】: Perform multi-table JOIN operations between rice_cooker_info, usage_records, and performance_tests using rice_cooker_id as the foreign key to establish complete device-performance relationships.  【step2】: Calculate complex physical quantity \"能量密度比\" through dimensional formula (POWER(3e8,4)/(8*PI()*6.67e-11)) * POWER(1/3,2) / 9.9e-27, using energy_consumption from usage_records as input parameter.  【step3】: Implement conditional judgment via CASE statement to compare energy conversion results (ur.energy_consumption*3.6e6/(0.005*0.18)) with derived physical quantity, outputting validation labels '满足曲率条件' or '能量不足'.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1443,
        "question": "Identify the safety condition of rice cookers based on material, final temperature, and rice quantity, categorizing each as 'Safe' or 'Dangerous' by calculating a risk index derived from thermal stress parameters.",
        "query": "SELECT rci.id, rci.material, pt.final_temperature, ur.rice_quantity, CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.1415926 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.1415926 * 0.0001)) ELSE NULL END AS_t_c, (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.1415926 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.1415926 * 0.0001)) ELSE NULL END AS risk_index, CASE WHEN (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.1415926 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.1415926 * 0.0001)) ELSE NULL END < 1 THEN '安全' ELSE '危险' END AS safety_condition FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id;",
        "step": "【step1】: Join tables to combine rice cooker details with performance data and usage records  【step2】: Calculate material-specific thermal stress parameter (AS_t_c) using CASE expressions  【step3】: Compute risk index via temperature deviation ratio and classify safety conditions",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1444,
        "question": "What is the comprehensive score for each manufacturer based on normalized energy consumption, time to boil, and rice quality score, with weights determined by entropy?",
        "query": "WITH standardized_data AS (SELECT rci.brand AS manufacturer, (pt.energy_consumption - MIN(pt.energy_consumption) OVER()) / (MAX(pt.energy_consumption) OVER() - MIN(pt.energy_consumption) OVER()) AS p_energy, (pt.time_to_boil - MIN(pt.time_to_boil) OVER()) / (MAX(pt.time_to_boil) OVER() - MIN(pt.time_to_boil) OVER()) AS p_time, (pt.rice_quality_score - MIN(pt.rice_quality_score) OVER()) / (MAX(pt.rice_quality_score) OVER() - MIN(pt.rice_quality_score) OVER()) AS p_score FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id), entropy_calculation AS (SELECT manufacturer, -SUM(p_energy * LN(p_energy + 1e-9)) / LN(COUNT(*)) AS e_energy, -SUM(p_time * LN(p_time + 1e-9)) / LN(COUNT(*)) AS e_time, -SUM(p_score * LN(p_score + 1e-9)) / LN(COUNT(*)) AS e_score FROM standardized_data GROUP BY manufacturer), weights AS (SELECT manufacturer, (1 - e_energy) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_energy, (1 - e_time) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_time, (1 - e_score) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_score FROM entropy_calculation) SELECT sd.manufacturer, SUM(w.w_energy * (1 - sd.p_energy) + w.w_time * sd.p_time + w.w_score * sd.p_score) AS comprehensive_score FROM standardized_data sd JOIN weights w ON sd.manufacturer = w.manufacturer GROUP BY sd.manufacturer;",
        "step": "【step1】: [Standardize metrics] Create CTE standardized_data by joining rice_cooker_info and performance_tests, then normalize energy_consumption/time_to_boil/rice_quality_score to [0,1] range using MIN/MAX window functions.【step2】: [Calculate entropy weights] Create CTE entropy_calculation to compute information entropy (e_energy/e_time/e_score) for each manufacturer using normalized metrics. Then derive weights (w_energy/w_time/w_score) in CTE weights by normalizing (1-entropy values).【step3】: [Compute final score] Combine standardized_data with weights through manufacturer, calculate comprehensive_score using weighted sum: (w_energy*(1-p_energy) + w_time*p_time + w_score*p_score). Group by manufacturer for final ranking.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1445,
        "question": "Calculate the number of minutes between consecutive maintenance events for each rice cooker, identify when a thermal fuse reset maintenance occurs less than 30 minutes after the previous maintenance, and check if the rice cooker has ever been used with a temperature setting above 85°C to determine violation status.",
        "query": "WITH maintenance_intervals AS (SELECT rice_cooker_id, maintenance_date, LAG(maintenance_date) OVER (PARTITION BY rice_cooker_id ORDER BY maintenance_date) AS prev_date, maintenance_type FROM maintenance_records) SELECT mi.rice_cooker_id, mi.maintenance_date, mi.prev_date, TIMESTAMPDIFF(MINUTE, mi.prev_date, mi.maintenance_date) AS cooling_interval, CASE WHEN mi.maintenance_type = '热熔断复位' AND TIMESTAMPDIFF(MINUTE, mi.prev_date, mi.maintenance_date) < 30 AND EXISTS (SELECT 1 FROM usage_records ul WHERE ul.rice_cooker_id = mi.rice_cooker_id AND ul.temperature_setting > 85) THEN '违规' ELSE '合规' END AS violation_status FROM maintenance_intervals mi;",
        "step": "【step1】: Create maintenance_intervals CTE using window function LAG to get previous maintenance date per cooker, partitioned by cooker_id and ordered by maintenance_date.  【step2】: Calculate cooling_interval using TIMESTAMPDIFF between previous and current maintenance dates.  【step3】: Determine violation_status by checking three conditions: maintenance_type=热熔断复位, cooling_interval<30, and EXISTS subquery verifying temperature_setting>85℃ in usage_records for matching cooker_id.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1446,
        "question": "Calculate the thermal conductivity anomaly status (normal/abnormal) for each rice cooker based on power rating, voltage rating, and final temperature, and identify which cookers have abnormal thermal conductivity.",
        "query": "SELECT rci.id, rci.power_rating, rci.voltage_rating, pt.final_temperature, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) AS L, (rci.power_rating / POWER(rci.voltage_rating, 2)) AS sigma, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / POWER(rci.voltage_rating, 2)) * (pt.final_temperature + 273) AS k_quantum, CASE WHEN (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / POWER(rci.voltage_rating, 2)) * (pt.final_temperature + 273) > 5000 THEN '异常' ELSE '正常' END AS thermal_conductivity_anomaly FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id;",
        "step": "【step1】: Perform INNER JOIN between rice_cooker_info and performance_tests tables using rice_cooker_id to combine technical specifications with thermal performance data  【step2】: Calculate complex physics parameters (L, sigma, k_quantum) using quantum transport equations involving power/voltage relationships and Boltzmann constant calculations  【step3】: Implement conditional classification using CASE statement to flag thermal conductivity anomalies based on quantum conductivity threshold (>5000 quantum units)",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1447,
        "question": "Identify records that violate the thermostat calibration cycle. According to JJF 1101-2019 requirements, calibration must be performed every 12 months with an error ≤ ±2°C. By creating a `calibration_records` table (with supplemental fields), JOIN `performance_tests` to verify overdue calibration or excessive errors, combined with temperature deviation validation.",
        "query": "WITH calibration_records AS (SELECT 1 AS rice_cooker_id, '2023-01-15' AS calibration_date, 1.5 AS calibration_error UNION ALL SELECT 2, '2022-12-20', 2.5 UNION ALL SELECT 3, '2023-03-10', 0.8) SELECT pt.id, pt.test_date, cr.calibration_date, ABS(cr.calibration_error) AS calibration_error, ABS(pt.final_temperature - pt.initial_temperature) AS temperature_deviation, CASE WHEN DATEDIFF(pt.test_date, cr.calibration_date) > 365 THEN '校准超期' WHEN ABS(cr.calibration_error) > 2 THEN '误差超标' WHEN ABS(pt.final_temperature - pt.initial_temperature) > 5 THEN '温度偏差' ELSE '正常' END AS violation_status FROM performance_tests pt JOIN calibration_records cr ON pt.rice_cooker_id = cr.rice_cooker_id;",
        "step": "【step1】: Create CTE calibration_records with hardcoded calibration data containing rice_cooker_id, calibration_date, and calibration_error  【step2】: Perform INNER JOIN between performance_tests (pt) and calibration_records (cr) using rice_cooker_id as the join condition  【step3】: Calculate violation status using CASE statement with three conditions: calibration overdue (>365 days), error exceeding ±2℃, and temperature deviation (>5℃) from performance test results, while computing absolute values of calibration_error and temperature difference",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1448,
        "question": "Assuming cooking in a Casimir effect field (plate separation d = 1nm), calculate the contribution of vacuum zero-point energy to heat conduction. Based on the Casimir pressure P = π * ℏ * c/(240 * d^4), with fictional parameters: effective area A = 0.01m², time t = 1h, use performance_tests.energy_consumption to verify whether P * A * t > E_cooking is satisfied.",
        "query": "SELECT pt.id, pt.energy_consumption, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) AS P, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 AS energy_gain, CASE WHEN (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 > pt.energy_consumption * 3.6e6 THEN '满足' ELSE '不满足' END AS quantum_condition FROM performance_tests pt;",
        "step": "【step1】: Calculate Casimir pressure P using the formula (9.87*1.05e-34*3e8)/(240*POWER(1e-9,4))  【step2】: Compute energy_gain by multiplying P with effective area (0.01) and time converted to seconds (3600)  【step3】: Compare energy_gain (J) with pt.energy_consumption (kWh→J via *3.6e6) using CASE to determine quantum_condition",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1449,
        "question": "If an electric rice cooker is used on the lunar surface, where gravity is only 1/6 of that on Earth, calculate the change in cooking time. Assuming the boiling point of water decreases to 70° C and heat convection weakens to 1/3 of that on Earth, derive the relationship between the new boiling time on the moon (t_moon) and the time on Earth (t_earth) using the heat transfer equation Q = mcΔT + mL.",
        "query": "SELECT pt.time_to_boil AS t_earth, (pt.time_to_boil * (75 / (1/3 * 240)) * ((2260 / (75 * 1)) + 1) / ((2260 / (1/3 * 240 * 1)) + 1)) AS t_moon FROM performance_tests pt JOIN rice_cooker_info ri ON pt.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';",
        "step": "【step1】: Perform INNER JOIN between performance_tests (aliased as pt) and rice_cooker_info (aliased as ri) using pt.rice_cooker_id = ri.id to merge appliance specifications with test data.  【step2】: Filter records using WHERE pt.test_type = 'Boiling' to isolate boiling-specific performance tests.  【step3】: Calculate t_moon using the derived thermo-physical formula (accounting for Moon's 70°C boiling point and 1/3 convection) applied to Earth's original time_to_boil values through Q=mcΔT+mL energy equivalence scaling.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1450,
        "question": "If the lifespan of a rice cooker follows a Weibull distribution with shape parameter β=2.5 and scale parameter η=8 years, calculate the probability of failure within 5 years and predict the median lifetime for each brand.",
        "query": "SELECT ri.brand, 1 - EXP(-POWER(5 / 8, 2.5)) AS failure_probability_5_years, 8 * POWER(LN(2), 1 / 2.5) AS median_lifetime FROM rice_cooker_info ri GROUP BY ri.brand;",
        "step": "【step1】:【Select brand from rice_cooker_info table and establish grouping basis】  【step2】:【Calculate 5-year failure probability using Weibull CDF formula: 1 - EXP(-(5/η)^β) with β=2.5, η=8】  【step3】:【Compute median lifetime using Weibull quantile formula: η*(ln(2))^(1/β) and associate results per brand group】",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1451,
        "question": "Identify which rice cookers are producing undercooked rice by analyzing potential causes such as abnormal rice-to-water ratios, uneven heating, temperature control deviations, or coating peeling issues.",
        "query": "SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN '米水比异常' WHEN (SELECT STDDEV(pt.final_temperature) FROM performance_tests pt WHERE pt.rice_cooker_id = ur.rice_cooker_id) > 5 THEN '加热不均' WHEN ABS(AVG(ur.actual_max_temperature) - AVG(ur.temperature_setting)) > 5 THEN '温控偏差' WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%内胆涂层%') THEN '涂层脱落' ELSE '其他原因' END AS possible_cause FROM usage_records ur GROUP BY ur.rice_cooker_id, ur.rice_quantity, ur.water_quantity;",
        "step": "【step1】: Group usage_records by rice_cooker_id with rice/water quantities and calculate initial CASE condition (rice-water ratio check)  【step2】: Execute correlated subqueries - check heating uniformity via performance_tests STDDEV, inspect maintenance_records for coating issues, compare temperature deviations  【step3】: Evaluate conditional logic sequentially (CASE WHEN) to prioritize possible causes and finalize diagnosis per grouped records",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1452,
        "question": "Assuming the rice cooker is modified into a quantum cooking device that utilizes the quantum tunneling effect for heating, calculate the tunneling probability under a 2nm potential barrier with a barrier height of 10eV and an electron energy of 5eV, and derive the improvement multiple in heating efficiency.",
        "query": "SELECT EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS tunneling_probability, 1 / EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS efficiency_increase FROM rice_cooker_info;",
        "step": "【step1】: Calculate the exponent component -2*d*sqrt(2m(E-V))/ħ using constant values from quantum physics formula  【step2】: Apply EXP() function to determine quantum tunneling probability through 1nm barrier  【step3】: Compute reciprocal of tunneling probability to derive heating efficiency improvement factor",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1453,
        "question": "Using a rice cooker in a high-altitude region (3000 meters above sea level), the boiling point decreases to 90°C due to reduced atmospheric pressure. Based on the given formula that uses the Clausius-Clapeyron relation to correct energy efficiency for the lower boiling point, calculate the corrected thermal energy utilization efficiency.",
        "query": "SELECT pt.water_evaporation_rate, ur.energy_consumption, (ur.energy_consumption * ri.power_rating * (2260e3/461.5)*(1/363 - 1/373)/ri.power_rating) / (ur.water_quantity * 4.18 * 65 + pt.water_evaporation_rate * 2260) AS efficiency_correction FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';",
        "step": "【step1】: Join the three tables (performance_tests, usage_records, and rice_cooker_info) using rice_cooker_id as the key, while filtering records where test_type is 'Boiling'.  【step2】: Extract required parameters: water_evaporation_rate from performance_tests, energy_consumption from usage_records, and power_rating from rice_cooker_info.  【step3】: Calculate efficiency_correction using the derived formula incorporating the Clausius-Clapeyron relationship. This involves temperature-dependent terms (1/363 vs 1/373 for 90°C vs 100°C) and heat loss parameters scaled by power_rating and water_evaporation_rate.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1454,
        "question": "Building a Clustering Analysis Model Based on User Behavior: Use K-means to classify users into three categories—\"Frequent Quick Cooking,\" \"Scheduled Appointments,\" and \"Heat Retention Dependence\"—based on features such as usage frequency, average rice quantity, and average duration.",
        "query": "WITH user_features AS (SELECT rice_cooker_id, COUNT(*) AS usage_frequency, AVG(rice_quantity) AS avg_rice_quantity, AVG(duration) AS avg_duration FROM usage_records GROUP BY rice_cooker_id) SELECT rice_cooker_id, usage_frequency, avg_rice_quantity, avg_duration, CASE WHEN usage_frequency > 10 AND avg_duration < 30 THEN '频繁快煮' WHEN usage_frequency BETWEEN 5 AND 10 AND avg_rice_quantity > 1 THEN '定时预约' WHEN avg_duration > 60 THEN '保温依赖' ELSE '其他' END AS user_category FROM user_features;",
        "step": "【step1】: Aggregate usage records to calculate frequency, average rice quantity, and average duration per rice cooker using a CTE.  【step2】: Apply conditional CASE logic to classify users into predefined categories based on aggregated metrics.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1455,
        "question": "Analyze the misoperation types in rice cooker usage records, including water level abnormalities, incompatible rice types, peak time usage, and others, and establish a decision tree diagnostic process.",
        "query": "SELECT ur.rice_cooker_id, CASE WHEN ur.water_quantity / ri.capacity > 1.2 THEN '水位异常' WHEN ur.rice_type NOT IN ('White Rice', 'Brown Rice') THEN '米种不适配' WHEN HOUR(ur.start_time) BETWEEN 18 AND 20 THEN '高峰时段使用' ELSE '其他' END AS misoperation_type FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;",
        "step": "【step1】: Join usage_records with rice_cooker_info using rice_cooker_id to access capacity data  【step2】: Apply CASE-WHEN hierarchy:    - Check water_quantity/capacity ratio >1.2 → '水位异常'    - Validate rice_type against allowed list → '米种不适配'    - Extract hour from start_time → '高峰时段使用'  【step3】: Assign labels sequentially (priority: 水位异常 > 米种不适配 > 高峰时段使用) with ELSE fallback",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1456,
        "question": "Assuming the use of quantum teleportation technology to transmit thermal energy, calculate the number of entangled quantum bits required to cook 1kg of rice, given that the energy transmission efficiency is modeled as η = 1 - (1 - e^(-t/τ))^n with a decoherence time τ = 1μs, and the calculation involves a specific energy transfer condition where 2.8e6 J is required and 1e-25 J is the quantum energy unit.",
        "query": "SELECT LN(1 - (2.8e6 / (1e-25 * 0.9))) / LN(1 - EXP(-1/1e-6)) AS required_qubits FROM rice_cooker_info WHERE id IS NOT NULL;",
        "step": "【step1】: Filter the rice_cooker_info table to ensure valid records using WHERE id IS NOT NULL.  【step2】: Calculate the numerator LN(1 - (2.8e6 / (1e-25 * 0.9))) using constants derived from energy requirements and quantum efficiency parameters.  【step3】: Compute the denominator LN(1 - EXP(-1/1e-6)) for decoherence time and finalize the division to determine the required_qubits value.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1457,
        "question": "When an electric rice cooker is started in a polar environment (-40°C), calculate the additional energy consumption during the pot preheating phase, given that the initial temperature is from a performance test of type 'Boiling' and the heat loss is modeled using the Stefan-Boltzmann law for radiation.",
        "query": "SELECT ri.power_rating, pt.initial_temperature, (0.9*5.67e-8*0.15*(POW(373,4)-POW(233,4)))*((25*3.5*4180)/(ri.power_rating - (0.9*5.67e-8*0.15*(POW(373,4)-POW(233,4))))) AS extra_energy FROM rice_cooker_info ri JOIN performance_tests pt ON ri.id = pt.rice_cooker_id WHERE pt.test_type = 'Boiling';",
        "step": "【step1】: Perform INNER JOIN between rice_cooker_info (aliased as ri) and performance_tests (aliased as pt) tables using rice_cooker_id, filtering records where test_type is 'Boiling'  【step2】: Calculate thermal loss power using Stefan-Boltzmann constant (5.67e-8), emissivity (0.9), surface area (0.15m²), and temperature difference between boiling water (373K) and polar environment (233K) via (0.9*5.67e-8*0.15*(POW(373,4)-POW(233,4)))  【step3】: Compute extra energy consumption by multiplying thermal loss power with modified preheating time coefficient derived from (25*3.5*4180) divided by (power_rating - thermal_loss_power), representing mass × specific heat capacity adjusted for environmental heat dissipation",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1458,
        "question": "Build a fault prediction system based on fuzzy logic: Define input variables \"frequency of use,\" \"temperature control deviation,\" and \"maintenance interval,\" with the output being \"fault risk level,\" and design membership functions and inference rules.",
        "query": "WITH fuzzy_data AS ( SELECT ur.rice_cooker_id, COUNT(*)/30.0 AS usage_freq, AVG(ABS(ur.actual_max_temperature - ur.temperature_setting)) AS temp_deviation, DATEDIFF(MAX(mr.maintenance_date), MIN(mr.maintenance_date))/30.0 AS maintenance_interval FROM usage_records ur LEFT JOIN maintenance_records mr ON ur.rice_cooker_id = mr.rice_cooker_id GROUP BY ur.rice_cooker_id ) SELECT rice_cooker_id, CASE WHEN usage_freq > 0.8 AND temp_deviation > 5 THEN '高风险' WHEN usage_freq BETWEEN 0.5 AND 0.8 OR maintenance_interval > 6 THEN '中风险' ELSE '低风险' END AS risk_level FROM fuzzy_data;",
        "step": "【step1】: Perform LEFT JOIN between usage_records and maintenance_records tables, grouping by rice_cooker_id to aggregate usage frequency and maintenance interval data.  【step2】: Calculate three key indicators: normalized usage frequency (records/30 days), average temperature deviation, and maintenance interval in months using DATEDIFF.  【step3】: Apply fuzzy logic rules via CASE expression to categorize risk levels based on threshold conditions for the calculated indicators.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1459,
        "question": "Identify the specific overflow reasons—such as incorrect rice-to-water ratio, exceeding rice cooker capacity, or excessive power—for each rice cooker in the usage records.",
        "query": "SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN '米水比异常(合理范围1:1.2-1:1.8)' WHEN (ur.rice_quantity + ur.water_quantity) > ri.capacity THEN '总量超容(超过电饭煲容量)' WHEN ri.power_rating > 1000 THEN '功率过高(>1000W)' ELSE '其他原因' END AS overflow_reason FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;",
        "step": "【step1】: Perform INNER JOIN between usage_records(ur) and rice_cooker_info(ri) tables using rice_cooker_id to combine usage data with appliance specifications.  【step2】: Apply nested CASE expression with priority order:  - First check rice-to-water ratio (rice_quantity/water_quantity) outside 0.56-0.83 range  - Then check total (rice+water) exceeding cooker capacity  - Then check power_rating > 1000W  - Final ELSE catches other reasons  【step3】: Output rice_cooker_id with corresponding overflow_reason classification through the evaluated CASE conditions.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1460,
        "question": "Assuming a temperature gradient constraint of ≤5°C per millimeter, derive the number of iterations required for quantum optimization of the heat field distribution, given the characteristic length from the ratio of the square of 5e-3 to 4 times 0.6 and the ceiling of the difference between final and initial temperatures divided by 5, multiplied by the square root of energy consumption.",
        "query": "SELECT POWER(5e-3,2)/(4*0.6) AS characteristic_length, CEIL((pt.final_temperature - pt.initial_temperature)/5 * SQRT(ur.energy_consumption)) AS iterations FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE pt.test_type = 'Boiling';",
        "step": "【step1】: Calculate characteristic_length using physical formula based on given parameters: POWER(5e-3,2)/(4*0.6) converts 5mm to meters squared then divided by thermal conductivity factor  【step2】: Join performance_tests and usage_records tables using rice_cooker_id to align temperature data with energy consumption metrics for boiling tests  【step3】: Compute quantum iterations through CEIL() function combining temperature delta (final - initial)/5℃ gradient constraint and scaled energy consumption via SQRT()",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1461,
        "question": "Calculate the theoretical time required for a rice cooker with the model 'RC-2002' to heat 5 liters of water from 25°C to 100°C during the rice cooking process, given that the power rating is in watts, the energy required is (5 * 4200 * 75) joules, and thermal losses are ignored.",
        "query": "SELECT (5 * 4200 * 75) / (power_rating) / 60 AS theoretical_time_minutes FROM rice_cooker_info WHERE model = 'RC-2002';",
        "step": "【step1】:【Validate the thermodynamic formula: Calculate total energy required using Q = mass * specific_heat_capacity * temperature_difference (5kg * 4200 J/kg°C * 75°C)】  【step2】:【Retrieve appliance power: Extract power_rating from rice_cooker_info table for model 'RC-2002'】  【step3】:【Compute time: Convert total energy (Joules) to time (minutes) via (Q / power_rating) / 60, ensuring unit consistency】",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1462,
        "question": "Calculate the total energy consumption and usage count for each model of rice cookers with the brand 'BrandY' in 2023, and identify the top 5 models with the highest total energy consumption.",
        "query": "SELECT rci.model, SUM(ur.energy_consumption) AS total_energy, COUNT(*) AS usage_count FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE rci.brand = 'BrandY' AND YEAR(ur.start_time) = 2023 GROUP BY rci.model ORDER BY total_energy DESC LIMIT 5;",
        "step": "【step1】: Join 'rice_cooker_info' and 'usage_records' tables via 'id', filter records where brand is 'BrandY' and 'start_time' is in 2023.  【step2】: Group results by 'model', calculate total energy consumption sum and usage count for each group.  【step3】: Sort groups by total energy consumption in descending order and return the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1463,
        "question": "Find the models of rice cookers with a capacity greater than 4 liters and a rated power less than 800 watts, and list their brands and prices.",
        "query": "SELECT model, brand, price FROM rice_cooker_info WHERE capacity > 4 AND power_rating < 800;",
        "step": "【step1】: Filter records from 'rice_cooker_info' table where capacity exceeds 4 liters and power_rating is below 800 watts using the WHERE clause.  【step2】: Select the required columns (model, brand, price) from the filtered results using the SELECT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1464,
        "question": "Assuming an electric rice cooker has a rated power of 5000 watts, calculate the energy consumption in kilowatt-hours for 30 seconds of operation.",
        "query": "SELECT 5000 * (30 / 3600) AS energy_consumption_kwh;",
        "step": "【step1】: Convert 30 seconds to hours (30/3600) for unit consistency  【step2】: Calculate theoretical energy consumption by multiplying power rating (5000W) with time in hours (resulting in kWh)  【step3】: (Omitted as the query contains no joins/nested operations. Feasibility discussion requires physical calculations outside SQL scope)",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "1",
        "idx": 1465,
        "question": "Calculate the thermal efficiency (actual energy consumption/theoretical energy consumption) of a rice cooker with model number 'RC-3003' heating 1.5 liters of water and 1.2 kilograms of rice from 25°C to 100°C under standard atmospheric pressure, given that the specific heat capacity of rice is 1.8 kJ/(kg·°C) and the specific heat capacity of water is 4.18 kJ/(kg·°C).",
        "query": "SELECT pt.energy_consumption / ((1.5 * 4.18 + 1.2 * 1.8) * 75) AS thermal_efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE rci.model = 'RC-3003' AND pt.final_temperature = 100 LIMIT 1;",
        "step": "【step1】: Perform INNER JOIN between `performance_tests` and `rice_cooker_info` using `rice_cooker_id` to link test data with appliance specifications  【step2】: Apply filters for model 'RC-3003' and final_temperature=100°C to isolate relevant test records  【step3】: Calculate thermal efficiency by dividing actual energy consumption by theoretical energy ((1.5L×4.18kJ +1.2kg×1.8kJ)×75°C ΔT) using derived values",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "2",
        "idx": 1466,
        "question": "Calculate the coefficient of variation (standard deviation/mean) of rice quality ratings for each brand and model of rice cooker, and filter out the unstable models with a coefficient of variation greater than 0.25.",
        "query": "SELECT rci.brand, rci.model, STDDEV(pt.rice_quality_score)/AVG(pt.rice_quality_score) AS cv FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id GROUP BY rci.brand, rci.model HAVING cv > 0.25;",
        "step": "【step1】: Perform INNER JOIN between 'performance_tests' and 'rice_cooker_info' tables using rice_cooker_id to link test records with corresponding appliance brand/model information.  【step2】: Group results by brand and model, then calculate coefficient of variation (STDDEV(rice_quality_score)/AVG(rice_quality_score)) for each group.  【step3】: Filter groups using HAVING clause to retain only records where coefficient of variation exceeds 0.25, indicating unstable performance.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "3",
        "idx": 1467,
        "question": "Identify the models of rice cookers that have been used more than 10 times in the past two years but have never undergone cleaning maintenance.",
        "query": "SELECT rci.model FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id AND mr.maintenance_type = 'Cleaning' WHERE ur.start_time >= DATE_SUB(CURDATE(), INTERVAL 2 YEAR) GROUP BY rci.id HAVING COUNT(ur.id) > 10 AND COUNT(mr.id) = 0;",
        "step": "【step1】: Join usage records from the past 2 years and left join maintenance cleaning records. Filter the usage timeframe with `ur.start_time >= DATE_SUB(CURDATE(), INTERVAL 2 YEAR)` and set maintenance_type condition in JOIN.  【step2】: Group records by rice_cooker_id. Calculate total usage count and maintenance cleaning count using `COUNT(ur.id)` and `COUNT(mr.id)`. Apply HAVING clause to filter groups with >10 usages and 0 cleanings.  【step3】: Select distinct model names from the grouped results by accessing the model field from rice_cooker_info through the established joins.",
        "format": "MySQL"
    },
    {
        "db_id": "rice_cooker",
        "type": "4",
        "idx": 1468,
        "question": "Calculate the current strength when a 30,000 W electric rice cooker operates on a 220 V power supply.",
        "query": "SELECT 30000 / 220 AS current_strength;",
        "step": "【step1】: Verify if any rice cooker in 'rice_cooker_info' has a 30000W power rating using:  ```sql  SELECT id FROM rice_cooker_info WHERE power_rating = 30000;  ```  【step2】: Calculate current strength using the given formula:  ```sql  SELECT 30000 / 220 AS current_strength;  ```  【step3】: Validate physical feasibility by checking energy requirements against water heating physics (external calculation, not directly mapped to DB tables). Example energy check:  ```sql  SELECT (50 * 4186 * 90) AS required_energy_joules, (30000 * 5) AS provided_energy_joules;  ```",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1469,
        "question": "Calculate the dissolved oxygen saturation percentage for the water sample collected by water quality monitor No. 1 on October 1, 2023.",
        "query": "SELECT (DissolvedOxygenMgL / 8.24) * 100 AS DissolvedOxygenSaturation FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';",
        "step": "【step1】: Filter the WaterQualityData table to retrieve records where MonitorId = 1 and CollectionTime is on '2023-10-01' using the WHERE clause.  【step2】: Calculate the dissolved oxygen saturation percentage using the formula (DissolvedOxygenMgL / 8.24) * 100. Rename the result as DissolvedOxygenSaturation with the AS keyword.  【step3】: (No third step required as the query involves basic filtering and calculation without joins, subqueries, or sorting.)",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1470,
        "question": "For the water sample collected by Water Quality Monitor #1 on October 1, 2023, at 00:00:00, the pH value was 7.0, the temperature was 15 degrees Celsius, and the conductivity was 300 microsiemens/centimeter. Please calculate the hydrogen ion concentration H+ of this water sample.",
        "query": "SELECT PHValue, TemperatureCelsius, ConductivityUsCm, POWER(10, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 7.0 AND TemperatureCelsius = 15 AND ConductivityUsCm = 300;",
        "step": "【step1】: Filter the WaterQualityData table for records where MonitorId = 1, CollectionTime = '2023-10-01 00:00:00', and the specified parameter values (PHValue = 7.0, TemperatureCelsius = 15, ConductivityUsCm = 300) to isolate the target water sample.  【step2】: Calculate the hydrogen ion concentration (H⁺) using the formula H⁺ = 10^(-pH) directly in the SELECT clause via POWER(10, -PHValue) and alias the result as H_Concentration.  【step3】: No third step required. The query is simple (filtering + direct calculation), so steps 1-2 fully describe the logic.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1471,
        "question": "Water quality monitoring device No. 1 recorded a pH value of 4.5, dissolved oxygen of 2 mg/L, and turbidity of 50 NTU in its latest measurement. Please determine whether the river's water quality is suitable for fish survival and explain the reasons.",
        "query": "SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 THEN '不适合鱼类生存' WHEN DissolvedOxygenMgL < 5 THEN '不适合鱼类生存' WHEN TurbidityNTU > 25 THEN '不适合鱼类生存' ELSE '适合鱼类生存' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);",
        "step": "【step1】: Execute the subquery `SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1` to retrieve the latest data collection time for monitor ID 1.  【step2】: Query the main table `WaterQualityData` using the obtained timestamp (`WHERE MonitorId = 1 AND CollectionTime = [result_from_step1]`) to fetch pH, dissolved oxygen, and turbidity values.  【step3】: Apply the conditional logic in the `CASE` statement: check if pH (4.5) < 6.5 OR > 9.0, dissolved oxygen (2 mg/L) < 5 mg/L, or turbidity (50 NTU) > 25 NTU. All three conditions trigger \"不适合鱼类生存\" due to violating multiple thresholds.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1472,
        "question": "Assume that water sample collected by water quality monitor No. 1 on October 1, 2023 has a pH value of 15, dissolved oxygen of 1000 mg/L, and turbidity of 10000 NTU. Please calculate the ion activity product (IAP) of this water sample and determine whether it has reached saturation status.",
        "query": "SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.ConductivityUsCm, POWER(10, -WQD.PHValue) AS H_ion_concentration, POWER(10, -(14 - WQD.PHValue)) AS OH_ion_concentration, (POWER(10, -WQD.PHValue) * POWER(10, -(14 - WQD.PHValue)) * WQD.ConductivityUsCm) AS IAP FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01' AND WQD.PHValue = 15 AND WQD.DissolvedOxygenMgL = 1000 AND WQD.TurbidityNTU = 10000;",
        "step": "【step1】: Filter specific data using the WHERE clause to locate the water sample collected by MonitorId=1 on 2023-10-01 with extreme parameters (PH=15, DissolvedOxygen=1000mg/L, Turbidity=10000NTU)  【step2】: Calculate H⁺ and OH⁻ ion concentrations via POWER(10, -PHValue) and POWER(10, -(14-PHValue)) respectively  【step3】: Compute Ion Activity Product (IAP) by multiplying H⁺ concentration, OH⁻ concentration, and ConductivityUsCm to determine saturation status",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1473,
        "question": "The water sample collected by Water Quality Monitor No. 1 on October 1, 2023 had a conductivity of 400 microsiemens per centimeter. Please estimate the total dissolved solids (TDS) concentration of this water sample.",
        "query": "SELECT ConductivityUsCm * 0.64 AS EstimatedTDS FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';",
        "step": "【step1】:【Filter data from WaterQualityData table where MonitorId is 1 and CollectionTime matches 2023-10-01】  【step2】:【Calculate EstimatedTDS by multiplying ConductivityUsCm value (400 µS/cm) with conversion factor 0.64】  【step3】:【Return the calculated EstimatedTDS value as the final result】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1474,
        "question": "On October 1, 2023, water sample collected by Water Quality Monitor No. 1 had a pH value of 6.8. Please calculate the hydrogen ion concentration H+ of this water sample.",
        "query": "SELECT PHValue, POWER(10, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.8;",
        "step": "【step1】: [Filter records from WaterQualityData where MonitorId=1, CollectionTime='2023-10-01 00:00:00', and PHValue=6.8 using WHERE clause]  【step2】: [Calculate H+ concentration using pH formula POWER(10, -PHValue) and alias it as H_Concentration]  【step3】: [Return PHValue and calculated H_Concentration in the final result set]",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1475,
        "question": "Water quality monitor No. 1 detected a pH value of 5.5 and dissolved oxygen of 4 mg/L in a water sample at the latest collection time. Please determine whether this water sample is suitable for fish survival and explain the reason.",
        "query": "SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 THEN '不适合鱼类生存' WHEN DissolvedOxygenMgL < 5 THEN '不适合鱼类生存' ELSE '适合鱼类生存' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);",
        "step": "【step1】: Execute the subquery `(SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1)` to retrieve the latest data collection time for monitor ID 1.  【step2】: Query the `WaterQualityData` table using the obtained timestamp to fetch the pH and dissolved oxygen values for monitor ID 1 with `WHERE MonitorId = 1 AND CollectionTime = [subquery_result]`.  【step3】: Apply the conditional logic `CASE` to evaluate pH <6.5 OR >9.0 (acidic/alkaline) and dissolved oxygen <5 mg/L (hypoxic), returning '不适合鱼类生存' if either condition is met, otherwise '适合鱼类生存'.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1476,
        "question": "Assuming the water sample collected by Water Quality Monitor No. 1 on October 1, 2023, has a pH value of 0, dissolved oxygen of 2000 mg/L, and turbidity of 50,000 NTU. Please determine whether this water sample complies with conventional water quality standards and explain the reason.",
        "query": "SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, CASE WHEN WQD.PHValue = 0 OR WQD.DissolvedOxygenMgL = 2000 OR WQD.TurbidityNTU = 50000 THEN '不符合常规水质标准' ELSE '符合常规水质标准' END AS WaterQualityStatus FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';",
        "step": "【step1】: 【Execute SELECT clause to retrieve monitor ID, collection time, pH, dissolved oxygen, turbidity, and apply CASE expression to evaluate water quality status based on fixed anomaly thresholds (pH=0, DO=2000mg/L, Turbidity=50000NTU)】  【step2】: 【Apply WHERE filter to target MonitorId=1 and CollectionTime='2023-10-01' from WaterQualityData】  【step3】: 【Return results with WaterQualityStatus column indicating non-compliance due to explicit hardcoded thresholds matching all three abnormal parameters】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1477,
        "question": "In water samples collected by Water Quality Monitor No. 1 on October 1, 2023, the conductivity was 600 microsiemens per centimeter. Given that the ratio coefficient of Total Dissolved Solids (TDS) to conductivity for this water sample is 0.7, please calculate the TDS concentration of the water sample.",
        "query": "SELECT ConductivityUsCm * 0.7 AS TDSConcentration FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';",
        "step": "【step1】: Filter records for MonitorId=1 and CollectionTime on 2023-10-01 using WHERE clause  【step2】: Calculate TDS concentration by multiplying ConductivityUsCm field with coefficient 0.7  【step3】: Return calculated TDSConcentration value via SELECT projection",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1478,
        "question": "The water sample collected by Water Quality Detector No. 1 on October 1, 2023, showed a pH of 6.2, a temperature of 20°C, and a conductivity of 450 µS/cm. Calculate the ionic strength (I) of this water sample and determine whether it belongs to a high ionic strength water body. The known ionic strength formula is I = 0.5 * Σ(ci * zi^2), where ci is the ion concentration and zi is the ion charge number. Assume the main ions are Na+ (1 mg/L, z=+1) and Cl- (1.5 mg/L, z=-1).",
        "query": "SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) AS IonStrength, CASE WHEN 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) > 0.1 THEN '高离子强度' ELSE '非高离子强度' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.2 AND TemperatureCelsius = 20 AND ConductivityUsCm = 450;",
        "step": "【step1】: Filter the WaterQualityData table to retrieve the specific record with MonitorId=1, CollectionTime='2023-10-01 00:00:00', and matching PHValue, TemperatureCelsius, and ConductivityUsCm values.  【step2】: Compute IonStrength using the formula **0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2)))** based on the provided Na⁺ and Cl⁻ concentrations and charge values.  【step3】: Apply classification logic via CASE statement to label results as '高离子强度' if IonStrength exceeds 0.1, otherwise '非高离子强度'.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1479,
        "question": "Water Quality Monitor No. 1 detected a water sample with a pH value of 3.8, dissolved oxygen of 1.5 mg/L, and turbidity of 80 NTU. Please determine whether this water sample is suitable as a drinking water source and explain the reason.",
        "query": "SELECT CASE WHEN PHValue < 6.5 OR PHValue > 8.5 THEN '不适合作为饮用水源' WHEN DissolvedOxygenMgL < 5 THEN '不适合作为饮用水源' WHEN TurbidityNTU > 5 THEN '不适合作为饮用水源' ELSE '适合作为饮用水源' END AS DrinkingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);",
        "step": "【step1】: Retrieve the latest collection time from WaterQualityData for MonitorId=1 using the subquery: SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1  【step2】: Query WaterQualityData with the latest collection time and MonitorId=1 to fetch pH, dissolved oxygen, and turbidity values  【step3】: Apply conditional CASE logic comparing parameters against drinking water standards (pH 6.5-8.5, DO≥5mg/L, turbidity≤5NTU), returning suitability conclusion.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1480,
        "question": "Assuming that in the water sample collected by Water Quality Monitor No. 1 on October 1, 2023, the pH value is -5, dissolved oxygen is 50,000 mg/L, turbidity is 1,000,000 NTU, temperature is 200°C, and conductivity is 1,000,000 μS/cm, determine whether it is likely to exist in nature. If not, state the reasons; if possible, describe the potential environmental conditions for its existence.",
        "query": "SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -5 OR WQD.DissolvedOxygenMgL = 50000 OR WQD.TurbidityNTU = 1000000 OR WQD.TemperatureCelsius = 200 OR WQD.ConductivityUsCm = 1000000 THEN '不可能存在于自然界中' ELSE '可能存在于自然界中' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';",
        "step": "【step1】: [Filter data from WaterQualityData where MonitorId=1 and CollectionTime='2023-10-01']  【step2】: [Check if any parameter (PH=-5, DissolvedOxygen=50000mg/L, Turbidity=1e6NTU, Temp=200°C, Conductivity=1e6µS/cm) exceeds natural limits using CASE]  【step3】: [Return '不可能存在于自然界中' if any condition matches, otherwise return '可能存在于自然界中' as NaturalPossibility]",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1481,
        "question": "The water sample collected by Water Quality Detector No. 1 on October 1, 2023, is known to contain CO3^2- = 100 mg/L and HCO3^- = 200 mg/L. Please calculate the Carbonate Alkalinity (Alk_CO3), Bicarbonate Alkalinity (Alk_HCO3), and Total Alkalinity of the water sample. The formula for Carbonate Alkalinity is Alk_CO3 = CO3^2- * 2, the formula for Bicarbonate Alkalinity is Alk_HCO3 = HCO3^-, and the Total Alkalinity is the sum of the two.",
        "query": "SELECT (100 * 2) AS Alk_CO3, 200 AS Alk_HCO3, (100 * 2 + 200) AS Total_Alkalinity FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';",
        "step": "【step1】: Filter the WaterQualityData table to retrieve records from MonitorId=1 on 2023-10-01 using WHERE conditions  【step2】: Apply carbonate/bicarbonate concentration values (CO3^2- = 100 mg/L, HCO3^- = 200 mg/L) directly in SELECT clause  【step3】: Calculate Alk_CO3 (100*2), Alk_HCO3 (200), and Total_Alkalinity (sum) through arithmetic operations in projection",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1482,
        "question": "Sample collected by Water Quality Monitor No. 1 on October 1, 2023 showed a pH value of 8.0, temperature of 30°C, and conductivity of 800 μS/cm. The water sample is known to contain multiple ions, including Na+ (50 mg/L, z=+1), K+ (20 mg/L, z=+1), Ca2+ (100 mg/L, z=+2), Mg2+ (50 mg/L, z=+2), Cl- (150 mg/L, z=-1), and SO4^2- (200 mg/L, z=-2). Please calculate the ionic strength (I) of this water sample and determine whether it belongs to high ionic strength water. The ionic strength formula is given as I = 0.5 * Σ(ci * zi^2), where ci is the ion concentration (mg/L) and zi is the ion charge number.",
        "query": "SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) AS IonStrength, CASE WHEN 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) > 0.1 THEN '高离子强度' ELSE '非高离子强度' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 8.0 AND TemperatureCelsius = 30 AND ConductivityUsCm = 800;",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1, CollectionTime='2023-10-01 00:00:00', PHValue=8.0, TemperatureCelsius=30, and ConductivityUsCm=800.  【step2】: Calculate ion strength (I) using the formula 0.5 * Σ(ci * zi²), where ci and zi are hardcoded ion concentrations and charges from the problem statement.  【step3】: Apply CASE to classify the calculated I value as '高离子强度' if I > 0.1, otherwise '非高离子强度'.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1483,
        "question": "Water Quality Monitor No. 1 detected that a water sample has a pH value of 2.5, dissolved oxygen of 0.5 mg/L, turbidity of 500 NTU, and a temperature of 80°C. Please determine whether this water sample is suitable for use as industrial cooling water based on the latest data from Monitor ID 1.",
        "query": "SELECT CASE WHEN PHValue < 6.0 OR PHValue > 9.0 THEN '不适合作为工业冷却水' WHEN DissolvedOxygenMgL < 4 THEN '不适合作为工业冷却水' WHEN TurbidityNTU > 20 THEN '不适合作为工业冷却水' WHEN TemperatureCelsius > 40 THEN '不适合作为工业冷却水' ELSE '适合作为工业冷却水' END AS CoolingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);",
        "step": "【step1】: Execute subquery to find the latest CollectionTime for MonitorId=1: `SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1`  【step2】: Retrieve the corresponding water quality data using the obtained CollectionTime: `SELECT * FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = [result_from_step1]`  【step3】: Apply conditional logic with CASE statement to evaluate PHValue, DissolvedOxygenMgL, TurbidityNTU, and TemperatureCelsius against industrial cooling water thresholds, returning the suitability judgment.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1484,
        "question": "Assuming that Water Quality Monitor No. 1 collected a water sample on October 1, 2023, with a pH value of -10, dissolved oxygen of 100,000 milligrams per liter, turbidity of 10,000,000 NTU, a temperature of 500 degrees Celsius, and electrical conductivity of 10,000,000 microsiemens per centimeter. Please determine whether this water sample could exist in nature.",
        "query": "SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -10 OR WQD.DissolvedOxygenMgL = 100000 OR WQD.TurbidityNTU = 10000000 OR WQD.TemperatureCelsius = 500 OR WQD.ConductivityUsCm = 10000000 THEN '不可能存在于自然界中' ELSE '可能存在于自然界中' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId = 1 and CollectionTime = '2023-10-01' using WHERE clause.  【step2】: Apply CASE statement to evaluate PHValue (-10), DissolvedOxygenMgL (100000), TurbidityNTU (10000000), TemperatureCelsius (500), and ConductivityUsCm (10000000) against natural water parameter ranges.  【step3】: Generate the NaturalPossibility column by flagging '不可能存在于自然界中' if any parameter exceeds realistic natural water thresholds, otherwise '可能存在于自然界中'.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1485,
        "question": "If the dissolved oxygen concentration recorded by water quality monitor number 1 is 8 mg/L and the water temperature is 25 degrees Celsius, does the dissolved oxygen concentration in the water reach a saturated state when the saturation threshold is 8.24 mg/L?",
        "query": "SELECT CASE WHEN DissolvedOxygenMgL >= 8.24 THEN '已达到饱和状态' ELSE '未达到饱和状态' END AS SaturationStatus FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND DissolvedOxygenMgL = 8;",
        "step": "【step1】: Retrieve the specific data record from WaterQualityData where MonitorId=1, TemperatureCelsius=25, and DissolvedOxygenMgL=8.  【step2】: Calculate the theoretical saturation value (8.24 mg/L) using Henry's Law for dissolved oxygen at 25°C.  【step3】: Compare the actual DissolvedOxygenMgL value (8 mg/L) with the calculated saturation threshold (8.24 mg/L) using a CASE statement to determine SaturationStatus.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1486,
        "question": "If Water Quality Monitor No. 1 records pH values every 5 minutes over a 24-hour period, it will have recorded 288 data points in total. The average pH value is 7.2, with a standard deviation of 0.3. What is the 95% confidence interval for these data points?",
        "query": "SELECT AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData where MonitorId=1 and CollectionTime is within the last 24 hours  【step2】: Calculate required statistics: AVG(PHValue)=7.2, STDDEV(PHValue)=0.3, COUNT=288  【step3】: Compute confidence interval bounds using formula: 7.2 ± (1.96 × 0.3/√288)",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1487,
        "question": "If the turbidity recorded by the No. 1 water quality monitor is 50 NTU, then according to the SQL query's classification, is this water suitable for direct drinking?",
        "query": "SELECT CASE WHEN TurbidityNTU < 5 THEN '适合直接饮用' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 50;",
        "step": "【step1】: Filter water quality data where MonitorId is 1 and TurbidityNTU equals 50 to isolate the specific measurement.  【step2】: Apply a CASE statement to evaluate if the turbidity value (50 NTU) is below the drinking water threshold (<5 NTU), returning '不适合直接饮用' based on the result.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1488,
        "question": "Assuming the pH value recorded by water quality monitoring device 1 is 15, which is far beyond the normal range (6.5-8.5), how many warning records will be counted for this device in the past 24 hours according to the water quality warning rules? The warning rule threshold is pH > 8.5, and data is recorded every 5 minutes.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND PHValue > 8.5 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1 and pH>8.5, focusing on data from the last 24 hours using DATE_SUB(NOW(), INTERVAL 1 DAY).  【step2】: Apply the time range condition (CollectionTime BETWEEN calculated_start_time AND current_time) to capture all qualifying entries within the 24-hour window.  【step3】: Count the total matching records (every 5-minute interval where pH=15 exceeds 8.5), resulting in 288 triggers (24h*60min/5min).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1489,
        "question": "If the conductivity recorded by water quality monitor No. 1 is 2000 microsiemens per centimeter and the water temperature is 30 degrees Celsius, calculate the approximate concentration of total dissolved solids (TDS) in the water based on the relationship between conductivity and ion concentration. Assume the conversion factor between conductivity and TDS is 0.67.",
        "query": "SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30 AND ConductivityUsCm = 2000;",
        "step": "【step1】: Filter WaterQualityData records for MonitorId=1 to locate the specific sensor's data entries  【step2】: Apply conditions TemperatureCelsius=30 and ConductivityUsCm=2000 to isolate the matching measurement  【step3】: Calculate TDS concentration by multiplying the filtered ConductivityUsCm value (2000) with the conversion coefficient 0.67",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1490,
        "question": "Water quality monitor No. 1 recorded dissolved oxygen concentration data for the past 7 days. What percentage of the total data points in these 7 days had a dissolved oxygen concentration below 4 mg/L?",
        "query": "SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 4 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData where MonitorId=1 within the last 7 days using WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW().  【step2】: Calculate the total count of DissolvedOxygenMgL readings and conditional count of values below 4 mg/L using COUNT(CASE WHEN DissolvedOxygenMgL < 4 THEN 1 END) and COUNT(*).  【step3】: Compute the percentage by multiplying the conditional count by 100.0 and dividing by the total count, aliasing the result as PercentageBelowThreshold.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1491,
        "question": "The ammonia nitrogen concentration recorded by Water Quality Monitor No.1 was 2.5 mg/L, and the nitrate nitrogen concentration was 10 mg/L. Does the water quality exceed the safe drinking water limits for ammonia nitrogen or nitrate nitrogen individually according to water quality standards? Please reason based on drinking water standards.",
        "query": "SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2.5 AND NitrateNitrogenMgL = 10;",
        "step": "【step1】: Retrieve the specific water quality record for MonitorId=1 with AmmoniaNitrogenMgL=2.5 and NitrateNitrogenMgL=10 from WaterQualityData table  【step2】: Apply conditional logic using CASE statement to check if either parameter exceeds safety thresholds (AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50)  【step3】: Return the evaluation result as SafetyStatus indicating whether the combined thresholds are exceeded based on drinking water standards",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1492,
        "question": "Assuming the turbidity recorded by Water Quality Monitor No. 1 is 1000 NTU, which is 200 times the normal value (the normal range is 0-5 NTU). If the turbidity threshold of the water quality warning system is 10 NTU, and data is recorded every second, how many times will the system trigger a warning in the past 24 hours? Assume the warning rule is turbidity > 10 NTU.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: 【Filter data from WaterQualityData where CollectionTime is within the past 24 hours using BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().】  【step2】: 【Apply conditions MonitorId = 1 and TurbidityNTU > 10 to identify records exceeding the turbidity threshold.】  【step3】: 【Count the total number of qualifying records using COUNT(*) to determine the WarningCount.】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1493,
        "question": "Assuming that the number 1 water quality monitor records a temperature of 50 degrees Celsius and a dissolved oxygen concentration of 2 mg/L. Given that the relationship between the saturated dissolved oxygen concentration of water and temperature follows the Weiss formula, calculate the current oxygen deficit of the water body (i.e., the difference between the saturated dissolved oxygen concentration and the actual dissolved oxygen concentration).",
        "query": "SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 50 AND DissolvedOxygenMgL = 2;",
        "step": "【step1】: Filter the WaterQualityData table to retrieve records where MonitorId is 1, TemperatureCelsius is 50°C, and DissolvedOxygenMgL is 2 mg/L.  【step2】: Apply the Weiss formula (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93))) to calculate the saturated dissolved oxygen concentration for the filtered records.  【step3】: Subtract the actual dissolved oxygen value (2 mg/L) from the calculated saturated concentration to derive the OxygenDeficit and return the result.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1494,
        "question": "The No. 1 water quality monitor recorded pH values between 6.0 and 8.0 over the past 30 days. Calculate the percentage of all data points from this period that fall within this pH range, and compute the 95% confidence interval for the pH values in this range.",
        "query": "WITH FilteredData AS (SELECT PHValue FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() AND PHValue BETWEEN 6.0 AND 8.0) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW())) AS PercentageInRange, AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM FilteredData;",
        "step": "【step1】:【Filter relevant data using CTE: Select PHValue from WaterQualityData where MonitorId=1, within the last 30 days, and pH between 6.0-8.0】  【step2】:【Calculate percentage: Divide the count of filtered data by the total data count (subquery) and multiply by 100】  【step3】:【Compute confidence interval: Use AVG(PHValue), STDDEV(PHValue), and 1.96*z-score with SQRT(COUNT) to derive Lower/Upper bounds】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1495,
        "question": "The total dissolved solids (TDS) concentration recorded by Water Quality Monitor #1 is 2000 mg/L, and the electrical conductivity is 3000 microsiemens/cm. Given that the typical conversion factor between TDS and electrical conductivity ranges from 0.5 to 0.8, please determine whether the current TDS concentration of the water body is reasonable based on this conversion factor.",
        "query": "SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN '合理' ELSE '不合理' END AS TDSReasonability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 2000 AND ConductivityUsCm = 3000;",
        "step": "【step1】: Filter records from WaterQualityData table where MonitorId=1, TotalDissolvedSolidsMgL=2000, and ConductivityUsCm=3000  【step2】: Calculate the TDS validity range using ConductivityUsCm * 0.5 (lower bound) and ConductivityUsCm * 0.8 (upper bound)  【step3】: Evaluate TDS reasonability via CASE statement by checking if TotalDissolvedSolidsMgL falls within the calculated range",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1496,
        "question": "Assuming the pH value recorded by Water Quality Monitor #1 is -3, which is an extreme outlier (normal range is 6.5-8.5). If the pH threshold for the water quality warning system is pH < 6.5 or pH > 8.5, and data is recorded every millisecond, how many times will the system trigger warnings in the last 24 hours for MonitorId = 1? The warning rule is pH < 6.5 or pH > 8.5.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter all data from WaterQualityData where MonitorId is 1.  【step2】: Apply time constraint to select records within the last 24 hours using CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().  【step3】: Check pH conditions (PHValue < 6.5 OR PHValue > 8.5) and calculate the total count of qualifying records.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1497,
        "question": "Assume that the temperature recorded by Water Quality Monitor No. 1 is 80 degrees Celsius, with a dissolved oxygen concentration of 1 mg/L. Given that the relationship between the saturation concentration of dissolved oxygen in water and temperature follows the Benson-Krause modification formula, calculate the current oxygen deficit of the water body (i.e., the difference between the saturation dissolved oxygen concentration and the actual dissolved oxygen concentration).",
        "query": "SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * POWER(TemperatureCelsius, 2) - 0.000077774 * POWER(TemperatureCelsius, 3)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 80 AND DissolvedOxygenMgL = 1;",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1, TemperatureCelsius=80, and DissolvedOxygenMgL=1 using the WHERE clause  【step2】: Calculate saturation dissolved oxygen concentration using Benson-Krause formula: 14.652 - 0.41022*T + 0.007991*T² - 0.000077774*T³ (T=80)  【step3】: Subtract actual dissolved oxygen (1 mg/L) from calculated saturation value to derive OxygenDeficit, aliased in the SELECT clause",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1498,
        "question": "Water Quality Monitor No. 1 recorded turbidity data every minute for 365 consecutive days, totaling 525,600 data points. The overall mean turbidity is known to be 10 NTU, with an overall standard deviation of 5 NTU. Assuming the turbidity data follows a log-normal distribution, calculate the percentage of data points where the turbidity value exceeds 50 NTU relative to the total data points, and further determine the 99% confidence interval for the mean turbidity of the entire dataset based on log-transformed data.",
        "query": "WITH LogTransformedData AS (SELECT LN(TurbidityNTU) AS LogTurbidity FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 365 DAY) AND NOW()), FilteredData AS (SELECT TurbidityNTU FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 365 DAY) AND NOW() AND TurbidityNTU > 50) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 365 DAY) AND NOW())) AS PercentageAboveThreshold, EXP(AVG(LogTurbidity) - (2.576 * (STDDEV(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS LowerBound, EXP(AVG(LogTurbidity) + (2.576 * (STDDEV(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS UpperBound FROM LogTransformedData;",
        "step": "【step1】: Filter data from WaterQualityData for monitor ID 1 within the last 365 days, creating two temporary datasets: one with natural logarithm-transformed turbidity values (LogTransformedData) and another containing raw turbidity values exceeding 50 NTU (FilteredData).  【step2】: Calculate percentage of exceedances using filtered data counts (COUNT from FilteredData vs total COUNT from LogTransformedData source). Perform statistical calculations on log-transformed data to compute mean and standard error.  【step3】: Construct 99% confidence interval (using Z-score 2.576) for log-normal distribution by exponentiating the confidence bounds calculated from transformed data's mean ± (Z-score * standard error).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1499,
        "question": "The ammonia nitrogen concentration recorded by Water Quality Monitor No. 1 was 10 mg/L, and the nitrate nitrogen concentration was 100 mg/L. According to water quality standards, does either the ammonia nitrogen concentration or the nitrate nitrogen concentration individually exceed the safety limit for drinking water? Please analyze this by referencing drinking water standards and the self-purification capacity of water bodies, and also discuss the potential sources of pollution at this contamination level.",
        "query": "SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus, '潜在污染来源可能包括农业 runoff、工业废水或生活污水。' AS PotentialSources FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 10 AND NitrateNitrogenMgL = 100;",
        "step": "【step1】: Filter data from WaterQualityData table where MonitorId=1 with specified concentration values (AmmoniaNitrogenMgL=10 and NitrateNitrogenMgL=100)  【step2】: Apply CASE statement to evaluate if either parameter exceeds drinking water safety thresholds (0.5 mg/L for ammonia, 50 mg/L for nitrate)  【step3】: Append static text about potential pollution sources while maintaining result structure",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1500,
        "question": "Assuming that the conductivity recorded by water quality monitor No. 1 is 1,000,000 microsiemens per centimeter, which is 10,000 times the normal value (normal range is 50-1000 μS/cm). If the conductivity threshold of the water quality warning system is 1000 μS/cm and data is recorded every microsecond, how many records from monitor ID 1 will exceed the conductivity threshold of 1000 μS/cm in the past 24 hours?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data for MonitorId = 1, conductivity > 1000 μS/cm, and within the last 24 hours using WHERE clause with conditions MonitorId = 1, ConductivityUsCm > 1000, and CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().  【step2】: Apply time range calculation via DATE_SUB(NOW(), INTERVAL 1 DAY) to dynamically define the 24-hour window relative to the current timestamp.  【step3】: Aggregate filtered results using COUNT(*) to calculate total warning triggers, aliased as WarningCount.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1501,
        "question": "The temperature recorded by water quality monitor No.1 is 35 degrees Celsius, with a dissolved oxygen concentration of 4 mg/L. Please calculate the current oxygen deficit of the water body (i.e., the difference between the saturated dissolved oxygen concentration and the actual dissolved oxygen concentration).",
        "query": "SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35 AND DissolvedOxygenMgL = 4;",
        "step": "【step1】: Calculate oxygen deficit using Weiss formula: Apply the EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) formula to compute saturated dissolved oxygen, then subtract actual DissolvedOxygenMgL (4 mg/L) for MonitorId=1 where TemperatureCelsius=35.  【step2】: Validate warning thresholds: Cross-reference WaterQualityWarningRule for dissolved oxygen rules (ParameterType='溶解氧') to check if the calculated oxygen deficit or actual DissolvedOxygenMgL meets trigger conditions (e.g., ThresholdValue < 4 mg/L with ConditionOperator='<').  【step3】: Analyze biological impact: Map triggered severity levels (e.g., SeverityLevel≥7) to ecological impacts (e.g., hypoxia stress on fish, reduced biodiversity) based on oxygen deficit magnitude and duration.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1502,
        "question": "The water quality monitor No. 1 recorded pH data over the past 7 days. Calculate the percentage of pH values between 7.0 and 8.0 relative to the total data points from this period, and determine the 90% confidence interval for the pH values within this range.",
        "query": "WITH FilteredData AS (SELECT PHValue FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW() AND PHValue BETWEEN 7.0 AND 8.0) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW())) AS PercentageInRange, AVG(PHValue) - (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM FilteredData;",
        "step": "【step1】: Filter pH data for MonitorId=1 within the last 7 days and PHValue between 7.0-8.0 using a CTE (FilteredData).  【step2】: Calculate percentage of valid data points by comparing filtered count (numerator) with total dataset count (denominator via subquery).  【step3】: Compute 90% confidence interval using filtered data's average ± (1.645 * standard error) where standard error = STDDEV/sqrt(sample_count).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1503,
        "question": "The total dissolved solids (TDS) concentration recorded by Water Quality Monitor No. 1 is 1500 mg/L, with a conductivity of 2000 microsiemens/cm. Given that the conversion factor between TDS and conductivity typically ranges from 0.5 to 0.8, please assess whether the current TDS concentration in the water body is reasonable and explain the possible reasons.",
        "query": "SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN '合理' ELSE '不合理' END AS TDSReasonability, CASE WHEN TotalDissolvedSolidsMgL NOT BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN '可能原因：水体中存在异常离子或测量误差。' ELSE '无异常' END AS ReasonExplanation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1500 AND ConductivityUsCm = 2000;",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1 with specified TDS(1500 mg/L) and conductivity(2000 μS/cm) values.  【step2】: Calculate acceptable TDS range using conductivity × 0.5 and ×0.8 (1000-1600 mg/L), then check if actual TDS(1500) falls within this range.  【step3】: Generate judgment (\"合理\"/\"不合理\") and explanation based on the range check result, flagging non-compliance with possible ionic anomalies or measurement errors.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1504,
        "question": "Assuming the pH value recorded by monitoring device #1 is consistently 10.5, which is a high outlier (normal range is 6.5-8.5). If the pH threshold for the water quality warning system is set to pH < 6.5 or pH > 8.5, and data is recorded every minute, how many warnings would the system trigger for device #1 in the past 24 hours? The warning rule is pH < 6.5 or pH > 8.5.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data for MonitorId=1 within the last 24 hours using CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().  【step2】: Apply pH threshold conditions (PHValue < 6.5 OR PHValue > 8.5) to the filtered dataset.  【step3】: Count matching records with COUNT(*) and alias the result as WarningCount.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1505,
        "question": "Temperature recorded by Water Quality Monitor No. 1 is 20 degrees Celsius, with a dissolved oxygen concentration of 6 mg/L. Given that the relationship between water's saturated dissolved oxygen concentration and temperature follows the Weiss formula, please calculate the oxygen deficit of the current water body (i.e., the difference between the saturated dissolved oxygen concentration and the actual dissolved oxygen concentration).",
        "query": "SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 6;",
        "step": "【step1】: Filter the WaterQualityData table to retrieve records where MonitorId is 1, TemperatureCelsius is 20, and DissolvedOxygenMgL is 6.  【step2】: Calculate the saturated dissolved oxygen concentration using the Weiss formula: EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)).  【step3】: Compute the oxygen deficit by subtracting the actual dissolved oxygen value (6 mg/L) from the calculated saturation concentration.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1506,
        "question": "The No. 1 water quality monitor recorded turbidity data at hourly intervals over a continuous 3-day period, totaling 72 data points. What percentage of these data points have a turbidity value exceeding 20 NTU?",
        "query": "SELECT (COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 3 DAY) AND NOW();",
        "step": "【step1】: Filter the WaterQualityData table for records where MonitorId is 1 and CollectionTime is within the last 3 days using the WHERE clause.  【step2】: Use COUNT(*) to calculate total data points (72), and COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) to count data points exceeding 20 NTU.  【step3】: Calculate the percentage by dividing the count of exceeding data points by the total data points, then multiply by 100.0 for precise decimal results.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1507,
        "question": "The No. 1 water quality monitor recorded hourly turbidity data for 3 consecutive days, totaling 72 data points. What percentage of these data points have a turbidity value exceeding 20 NTU?",
        "query": "SELECT ROUND((COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)), 2) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 3 DAY) AND NOW();",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId = 1 and CollectionTime falls within the last 3 days.  【step2】: Calculate the percentage by dividing the count of records with TurbidityNTU > 20 by the total records (72), then multiply by 100 for the final percentage.  【step3】: Round the result to 2 decimal places using the ROUND function for precise output.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1508,
        "question": "Assuming the pH value recorded by the No.1 water quality monitor is consistently 9.5 (which is a high outlier, with normal range being 6.5-8.5), and data is recorded every 10 minutes, how many times will the system trigger a warning within the last 24 hours?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData table where MonitorId=1 to isolate records from the specific water quality monitor.  【step2】: Apply time constraint (`CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW()`) to target 24-hour data and filter pH values outside the threshold range (`PHValue < 6.5 OR PHValue > 8.5`).  【step3】: Aggregate the filtered records using `COUNT(*)` to calculate the total number of triggered warnings (WarningCount).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1509,
        "question": "The water quality monitor recorded a temperature of 10 degrees Celsius and a dissolved oxygen concentration of 9 mg/L. Given that the relationship between the saturated dissolved oxygen concentration and temperature follows the Weiss formula, please calculate the oxygen deficit (i.e., the difference between the saturated dissolved oxygen concentration and the actual dissolved oxygen concentration) of the current water body.",
        "query": "SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 10 AND DissolvedOxygenMgL = 9;",
        "step": "【step1】: Filter the WaterQualityData table to retrieve the specific record for MonitorId=1 with Temperature=10°C and DissolvedOxygen=9 mg/L using WHERE clause.  【step2】: Apply the Weiss formula (EXP(7.7117 - 1.31403*LN(TemperatureCelsius + 45.93))) to calculate the saturated dissolved oxygen concentration.  【step3】: Subtract the actual DissolvedOxygenMgL value from the calculated saturation value to derive the OxygenDeficit, then output the result via SELECT.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1510,
        "question": "Water quality monitor No. 1 recorded pH data over the past 1-day period. Calculate the percentage of data points where the pH value falls between 6.8 and 7.2, relative to the total number of data points.",
        "query": "SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.8 AND 7.2 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData where MonitorId=1 and within the last 24 hours using CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().  【step2】: Count total records meeting the criteria (COUNT(*)) and records where PHValue is between 6.8-7.2 using CASE WHEN.  【step3】: Calculate the percentage by dividing conditional count by total count, then multiply by 100.0 to maintain decimal precision.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1511,
        "question": "The ammonia nitrogen concentration recorded by Water Quality Monitor No. 1 is 0.3 mg/L, and the nitrate nitrogen concentration is 10 mg/L. Does the water sample exceed safety limits for drinking water standards based on its ammonia nitrogen and nitrate nitrogen concentrations?",
        "query": "SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.3 AND NitrateNitrogenMgL = 10;",
        "step": "【step1】: Filter WaterQualityData records for MonitorId=1 with AmmoniaNitrogenMgL=0.3 and NitrateNitrogenMgL=10 to isolate the specific measurement.  【step2】: Apply CASE statement to evaluate safety criteria: Check if either AmmoniaNitrogenMgL > 0.5 (hardcoded threshold) OR NitrateNitrogenMgL > 50 (hardcoded threshold).  【step3】: Return '超过安全限值' if thresholds are exceeded, otherwise return '未超过安全限值' as SafetyStatus.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1512,
        "question": "Assuming the pH value recorded by the No. 1 water quality monitor is 8.2, which is within the normal range of 6.5–8.5, and data is recorded every hour, how many warnings will the system trigger in 24 hours? The warning rule is pH < 6.5 or pH > 8.5.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter all records from WaterQualityData where MonitorId = 1 and CollectionTime is within the last 24 hours using BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().  【step2】: Apply the condition (PHValue < 6.5 OR PHValue > 8.5) to the filtered records to identify entries exceeding the pH threshold.  【step3】: Count the number of qualifying rows using COUNT(*) and return the result as WarningCount.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1513,
        "question": "If the pH value recorded by water quality monitor No. 1 is 6.5 and the temperature is 25 degrees Celsius, calculate the hydrogen ion concentration (H+) of the water body at this time.",
        "query": "SELECT POWER(10, -PHValue) AS HydrogenIonConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND PHValue = 6.5;",
        "step": "【step1】: Filter WaterQualityData entries where MonitorId=1, TemperatureCelsius=25, and PHValue=6.5  【step2】: Calculate HydrogenIonConcentration via POWER(10, -PHValue) for matching records  【step3】: Interpret pH=6.5 as weakly acidic (pH<7) and check WaterQualityWarningRule for pH-related thresholds to assess potential warnings",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1514,
        "question": "The No. 1 water quality monitor recorded pH values over the past 7 days. Calculate the percentage of data points where the pH values fall between 6.5 and 7.5, relative to the total number of data points.",
        "query": "SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.5 AND 7.5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData where MonitorId=1 and CollectionTime is within the last 7 days.  【step2】: Calculate the count of records where PHValue is between 6.5 and 7.5 using a CASE statement within COUNT.  【step3】: Compute the percentage by dividing the valid count by the total count in the filtered dataset and multiply by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1515,
        "question": "The pH value recorded by Water Quality Monitor No. 1 is 8.5. According to drinking water standards, is this water quality suitable for direct consumption, but close to the alkaline edge where long-term consumption should be cautious?",
        "query": "SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 THEN '适合直接饮用，但接近碱性边缘，长期饮用需谨慎' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5;",
        "step": "【step1】: Filter the specific data point using WHERE MonitorId = 1 AND PHValue = 8.5 to locate 1号监测仪's pH=8.5 record in WaterQualityData  【step2】: Apply conditional judgment using CASE WHEN PHValue BETWEEN 6.5 AND 8.5 to check against hardcoded drinking water pH standards (note: actual standards should reference WaterQualityWarningRule)  【step3】: Return customized recommendation text based on comparison results, though the query uses fixed thresholds rather than dynamically referencing WaterQualityWarningRule thresholds",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1516,
        "question": "Assuming the pH value recorded by water quality monitor No. 1 is 15, which is an extreme outlier (normal range is 6.5-8.5). If the water quality early warning system has a pH threshold of pH < 6.5 or pH > 8.5, and data is recorded every second, how many times will the system trigger alerts in the past 24 hours?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter records from the WaterQualityData table where MonitorId = 1.  【step2】: Apply conditions (PHValue < 6.5 OR PHValue > 8.5) and CollectionTime within the last 24 hours using DATE_SUB(NOW(), INTERVAL 1 DAY).  【step3】: Count the total number of qualifying records with COUNT(*) as WarningCount.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1517,
        "question": "If the dissolved oxygen concentration recorded by the No. 1 water quality monitor is 8 mg/L and the water temperature is 20 degrees Celsius, please calculate the saturated dissolved oxygen concentration of the water body at this time based on the given polynomial formula, and analyze the oxygen deficit of the current water body (i.e., the difference between the saturated dissolved oxygen concentration and the actual dissolved oxygen concentration).",
        "query": "SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * POWER(TemperatureCelsius, 2) - 0.000077774 * POWER(TemperatureCelsius, 3)) AS SaturatedOxygen, (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * POWER(TemperatureCelsius, 2) - 0.000077774 * POWER(TemperatureCelsius, 3)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 8;",
        "step": "【step1】: Filter WaterQualityData records where MonitorId=1, TemperatureCelsius=20, and DissolvedOxygenMgL=8  【step2】: Calculate saturated oxygen concentration using the polynomial formula (14.652 - 0.41022*T + 0.007991*T² - 0.000077774*T³)  【step3】: Compute oxygen deficit by subtracting actual DissolvedOxygenMgL value (8 mg/L) from the calculated saturated oxygen value",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1518,
        "question": "Water quality monitor No. 1 recorded dissolved oxygen concentration data over the past 30 days. Please calculate the percentage of data points where the dissolved oxygen concentration is below 5 mg/L relative to the total number of data points.",
        "query": "SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW();",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1 and CollectionTime falls within the last 30 days using the WHERE clause.  【step2】: Calculate the total number of data points (COUNT(*)) and the count of data points where DissolvedOxygenMgL <5 using conditional aggregation with CASE WHEN.  【step3】: Compute the percentage by multiplying the ratio of non-compliant data points to total data points by 100.0 to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1519,
        "question": "The dissolved oxygen concentration recorded by Water Quality Monitor No.1 is 4 mg/L. According to water quality standards, is this water suitable for fish survival?",
        "query": "SELECT CASE WHEN DissolvedOxygenMgL > 5 THEN '适合鱼类生存' ELSE '不适合鱼类生存，溶解氧浓度接近临界值' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND DissolvedOxygenMgL = 4;",
        "step": "【step1】: Filter WaterQualityData records for MonitorId=1 with DissolvedOxygenMgL=4mg/L  【step2】: Compare dissolved oxygen value against 5mg/L threshold for fish survival  【step3】: Generate suitability label using CASE statement based on comparison result",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1520,
        "question": "Assuming the dissolved oxygen concentration recorded by water quality monitor No. 1 is 0.1 mg/L, which is an extreme outlier (the normal range being 5-10 mg/L). If the threshold for dissolved oxygen concentration in the water quality early warning system is set at dissolved oxygen < 5 mg/L, and data is recorded once per second, how many times would the system trigger an alert within 24 hours? The alert rule is set as dissolved oxygen < 5 mg/L.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND DissolvedOxygenMgL < 5 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from the WaterQualityData table where MonitorId = 1 to focus on records from the specified monitoring device.  【step2】: Apply the condition DissolvedOxygenMgL < 5 to identify records with dissolved oxygen concentration below the threshold.  【step3】: Limit the time range to the last 24 hours using CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW(), then calculate the total count of qualifying records with COUNT(*).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1521,
        "question": "If the turbidity recorded by Water Quality Monitor No. 1 is 50 NTU and the water temperature is 15 degrees Celsius, please calculate the concentration of suspended particles in the water using a conversion factor of 2.5.",
        "query": "SELECT TurbidityNTU * 2.5 AS SuspendedSolidsConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 15 AND TurbidityNTU = 50;",
        "step": "【step1】: Filter the WaterQualityData table to find records where MonitorId is 1, TemperatureCelsius is 15°C, and TurbidityNTU equals 50  【step2】: Multiply the TurbidityNTU value by the conversion coefficient 2.5 for the filtered record  【step3】: Return the calculated value with the alias SuspendedSolidsConcentration",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1522,
        "question": "The No. 1 water quality monitor recorded turbidity data for the past 7 days. Please calculate the percentage of data points where the turbidity value exceeds 40 NTU out of the total data points.",
        "query": "SELECT (COUNT(CASE WHEN TurbidityNTU > 40 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();",
        "step": "【step1】: Filter data points from MonitorId=1 within the last 7 days using WHERE clause to isolate the 168 relevant data points.  【step2】: Count total valid data points (COUNT(*)) and count values exceeding 40 NTU (COUNT(CASE WHEN TurbidityNTU > 40 THEN 1 END)).  【step3】: Calculate the percentage by multiplying the ratio of exceeding counts to total counts by 100.0, then output as PercentageAboveThreshold.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1523,
        "question": "The turbidity recorded by Water Quality Monitor No. 1 is 100 NTU. Is this water suitable for direct consumption?",
        "query": "SELECT CASE WHEN TurbidityNTU < 5 THEN '适合直接饮用' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 100;",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1 and TurbidityNTU=100  【step2】: Apply CASE statement to evaluate if turbidity exceeds drinking standard (TurbidityNTU <5)  【step3】: Verify if active turbidity warning rules (ParameterType=\"浊度\") in WaterQualityWarningRule have threshold=5 NTU to confirm the standard reference",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1524,
        "question": "Assuming the turbidity recorded by water quality monitoring instrument No. 1 is 10,000 NTU continuously, which is an extreme outlier (normal range is 0-5 NTU). If the turbidity threshold of the water quality warning system is > 10 NTU, and data is recorded every second, how many warnings will the system trigger in the last 24 hours? Assume the warning rule is turbidity > 10 NTU.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId = 1 to isolate data from the specified water quality monitor.  【step2】: Apply the time condition (CollectionTime within the last 24 hours) to narrow down the dataset to the relevant period.  【step3】: Count all records where TurbidityNTU exceeds 10 NTU, calculating the total number of warnings triggered.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1525,
        "question": "If the temperature recorded by Water Quality Monitor No. 1 is 30 degrees Celsius, calculate the heat required to heat 1000 grams of water from 20 degrees Celsius to 30 degrees Celsius based on the specific heat capacity of water. The known specific heat capacity of water is 4.18 J/g·°C.",
        "query": "SELECT 1000 * 4.18 * (30 - 20) AS HeatRequired FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30;",
        "step": "【step1】: Filter WaterQualityData records where MonitorId = 1 and TemperatureCelsius = 30.  【step2】: Calculate heat required using formula (1000ml * 4.18 J/g°C * (30°C - 20°C)) for each qualifying record.  【step3】: Output the computed HeatRequired value from the calculation.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1526,
        "question": "The water quality monitoring instrument No. 1 recorded temperature data over the past 5 days. Calculate the percentage of data points where the temperature exceeds 35 degrees Celsius relative to the total number of data points recorded during this period.",
        "query": "SELECT (COUNT(CASE WHEN TemperatureCelsius > 35 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 5 DAY) AND NOW();",
        "step": "【step1】: Filter the WaterQualityData table to retrieve all 120 data points from monitor ID 1 within the last 5 days using WHERE clause conditions on MonitorId and CollectionTime.  【step2】: Calculate two counts: total records (COUNT(*)) and records exceeding 35°C (COUNT(CASE WHEN TemperatureCelsius > 35 THEN 1 END)).  【step3】: Compute the percentage by multiplying the ratio of exceeded records to total records by 100.0 and alias the result as PercentageAboveThreshold.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1527,
        "question": "The temperature recorded by water quality monitor No. 1 is 35 degrees Celsius. According to the water temperature standards for fish survival, is this temperature suitable for fish?",
        "query": "SELECT CASE WHEN TemperatureCelsius BETWEEN 15 AND 30 THEN '适合鱼类生存' ELSE '不适合鱼类生存，水温过高' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35;",
        "step": "【step1】: Retrieve the record from WaterQualityData where MonitorId is 1 and TemperatureCelsius equals 35.  【step2】: Apply a CASE statement to check if the temperature falls within the 15-30°C range (suitable for fish survival).  【step3】: Return the evaluation result labeled as FishSurvivalSuitability based on the temperature comparison.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1528,
        "question": "Assume that the temperature recorded by water quality monitor No. 1 is consistently 100 degrees Celsius, which is an extreme outlier (normal range is 0–40 degrees Celsius). If the temperature threshold for the water quality warning system is temperature > 40 degrees Celsius, and data is recorded once per second, how many times will the system trigger warnings within the most recent 24-hour period?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius > 40 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData table where MonitorId = 1 and TemperatureCelsius > 40, ensuring only records from the specified monitor with abnormal temperature are selected.【step2】: Apply time range filter using CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW(), isolating records from the last 24 hours.【step3】: Perform COUNT(*) aggregation on the filtered dataset to calculate total warning triggers.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1529,
        "question": "If the conductivity recorded by water quality monitor No. 1 is 500 microsiemens per centimeter and the temperature is 25 degrees Celsius, please estimate the approximate concentration of Total Dissolved Solids (TDS) in the water based on the relationship between conductivity and ion concentration. Assume the conversion factor from conductivity to TDS is 0.67.",
        "query": "SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND ConductivityUsCm = 500;",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1, TemperatureCelsius=25, and ConductivityUsCm=500  【step2】: Calculate TDS estimation by multiplying ConductivityUsCm (500) with the conversion factor (0.67)  【step3】: Return the calculated value as EstimatedTDSMgL through SELECT projection",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1530,
        "question": "The No. 1 water quality monitor recorded hourly conductivity data over 7 consecutive days. Calculate the percentage of data points where the conductivity value exceeds 600 μS/cm out of the total data points.",
        "query": "SELECT (COUNT(CASE WHEN ConductivityUsCm > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1 and CollectionTime is within the last 7 days using WHERE clause.  【step2】: Use COUNT(CASE WHEN...) to calculate the number of data points where ConductivityUsCm exceeds 600 μS/cm.  【step3】: Calculate the percentage by dividing valid case counts by total records (*100.0) and alias the result as PercentageAboveThreshold.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1531,
        "question": "The conductivity recorded by Water Quality Monitor No. 1 is 1000 μS/cm. According to drinking water standards, is this water quality suitable for direct consumption, but further testing of dissolved solids is required?",
        "query": "SELECT CASE WHEN ConductivityUsCm BETWEEN 500 AND 1500 THEN '适合直接饮用，但需进一步检测溶解固体含量' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm = 1000;",
        "step": "【step1】: 【Filter WaterQualityData table to retrieve records where MonitorId=1 and ConductivityUsCm=1000】  【step2】: 【Apply CASE statement to evaluate if ConductivityUsCm falls within the 500-1500 μS/cm range specified in the query】  【step3】: 【Generate DrinkingSuitability result based on the evaluation, explicitly incorporating the additional check for dissolved solids mentioned in the CASE output】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1532,
        "question": "Assuming the conductivity recorded by water quality monitor #1 is 1,000,000 μS/cm, which is an extreme outlier (normal range is 50-1000 μS/cm). If the conductivity threshold for the water quality warning system is conductivity > 1000 μS/cm, and data is recorded once per second, how many times will the query count warnings for monitor #1 within the past 24 hours?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter records from WaterQualityData where CollectionTime falls within the last 24 hours using DATE_SUB(NOW(), INTERVAL 1 DAY) and NOW() for temporal scope.  【step2】: Refine the filtered data by applying MonitorId = 1 and ConductivityUsCm > 1000 to isolate extreme anomalies.  【step3】: Execute COUNT(*) on the fully filtered dataset to calculate the total number of triggered warnings (WarningCount).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1533,
        "question": "If the total dissolved solids (TDS) concentration recorded by water quality monitor No. 1 is 500 mg/L and the conductivity is 750 microsiemens per centimeter, please verify whether the recorded TDS value is reasonable based on the relationship between TDS and conductivity. Assume the conversion factor between TDS and conductivity is 0.67.",
        "query": "SELECT CASE WHEN TotalDissolvedSolidsMgL = ConductivityUsCm * 0.67 THEN '合理' ELSE '不合理' END AS TDSValidation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 500 AND ConductivityUsCm = 750;",
        "step": "【step1】: Filter the WaterQualityData table to retrieve records where MonitorId is 1, TotalDissolvedSolidsMgL is 500, and ConductivityUsCm is 750.  【step2】: Calculate the theoretical TDS value by multiplying ConductivityUsCm (750) by the conversion factor (0.67), resulting in 502.5 mg/L.  【step3】: Compare the calculated TDS value (502.5) with the recorded TotalDissolvedSolidsMgL (500) using a CASE statement. Since they are not equal, return '不合理' (Unreasonable).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1534,
        "question": "In the past 30 days, for water quality monitor #1, what percentage of the total dissolved solids (TDS) concentration readings exceeded 600 mg/L out of all the readings taken?",
        "query": "SELECT (COUNT(CASE WHEN TotalDissolvedSolidsMgL > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData table for MonitorId=1 within the last 30 days using WHERE clause.  【step2】: Calculate the number of records where TotalDissolvedSolidsMgL > 600 using COUNT(CASE...END) and total records using COUNT(*).  【step3】: Compute percentage by dividing counted exceedances by total records, multiply by 100.0 for float precision, and alias as PercentageAboveThreshold.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1535,
        "question": "The total dissolved solids (TDS) concentration recorded by water quality monitor No. 1 is 1200 mg/L. According to drinking water standards, is this water quality suitable for direct consumption?",
        "query": "SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN 500 AND 1000 THEN '适合直接饮用' ELSE '不适合直接饮用，TDS浓度超出标准' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1200;",
        "step": "【step1】: Filter WaterQualityData to retrieve records where MonitorId = 1 and TotalDissolvedSolidsMgL = 1200.  【step2】: Apply CASE expression to evaluate if TotalDissolvedSolidsMgL is within the 500-1000 mg/L range.  【step3】: Return DrinkingSuitability based on the evaluation result.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1536,
        "question": "Assuming the total dissolved solids (TDS) concentration recorded by Water Quality Monitor #1 is 1,000,000 milligrams per liter, which is an extreme outlier (normal range is 0-1000 mg/L). If the TDS concentration threshold for the water quality warning system is TDS > 1000 mg/L, and data is recorded every second, how many warnings will the system trigger within the past 24 hours?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter all records from WaterQualityData where MonitorId = 1 and TotalDissolvedSolidsMgL > 1000.  【step2】: Narrow results to records collected within the last 24 hours using CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().  【step3】: Count qualifying records via COUNT(*) to determine total warnings triggered.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1537,
        "question": "If the ammonia nitrogen concentration recorded by Water Quality Monitor No. 1 is 2 mg/L and the nitrate nitrogen concentration is 10 mg/L, what is the total nitrogen concentration?",
        "query": "SELECT AmmoniaNitrogenMgL + NitrateNitrogenMgL AS TotalNitrogen FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2 AND NitrateNitrogenMgL = 10;",
        "step": "【step1】: Filter the WaterQualityData table to find records where MonitorId is 1, AmmoniaNitrogenMgL is 2 mg/L, and NitrateNitrogenMgL is 10 mg/L using the WHERE clause.  【step2】: Calculate the sum of AmmoniaNitrogenMgL and NitrateNitrogenMgL for the filtered record(s) using arithmetic addition.  【step3】: Return the computed value as TotalNitrogen in the result set.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1538,
        "question": "Water quality monitor No. 1 recorded ammonia nitrogen and nitrate nitrogen concentration data over the past 7 days. Calculate the percentage of data points where the total nitrogen concentration exceeds 12 mg/L out of the total data points.",
        "query": "SELECT (COUNT(CASE WHEN (AmmoniaNitrogenMgL + NitrateNitrogenMgL) > 12 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();",
        "step": "【step1】: Filter the dataset to retrieve all 14 data points from monitor ID 1 within the last 7 days using the WHERE clause (MonitorId=1 and CollectionTime in 7-day range).  【step2】: Calculate the sum of AmmoniaNitrogenMgL and NitrateNitrogenMgL for each data point, then apply a conditional check (SUM > 12 mg/L) via CASE WHEN.  【step3】: Compute the percentage by counting qualifying rows (COUNT(CASE...)) and dividing by total rows (COUNT(*)), multiplying by 100.0 for floating-point precision.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1539,
        "question": "Water Quality Monitor No. 1 recorded an ammonia nitrogen concentration of 0.8 mg/L and a nitrate nitrogen concentration of 20 mg/L. According to drinking water standards, does this water quality exceed the safe limit for direct consumption?",
        "query": "SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;",
        "step": "【step1】:【Filter WaterQualityData for MonitorId=1 with specified parameter values (AmmoniaNitrogenMgL=0.8, NitrateNitrogenMgL=20)】  【step2】:【Compare values against hardcoded thresholds (AmmoniaNitrogen >0.5 OR NitrateNitrogen >50) using conditional logic】  【step3】:【Generate SafetyStatus classification (超过安全限值/未超过安全限值) through CASE-WHEN operation】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1540,
        "question": "Assuming that Water Quality Monitor No. 1 recorded an ammonia nitrogen concentration of 1000 mg/L and a nitrate nitrogen concentration of 5000 mg/L, which are extreme outliers (normal ranges are ammonia nitrogen < 0.5 mg/L and nitrate nitrogen < 50 mg/L). If the water quality warning system has an ammonia nitrogen threshold of > 0.5 mg/L and a nitrate nitrogen threshold of > 50 mg/L, and data is recorded every second, then in 24 hours, how many warnings will the system trigger? The warning rule is defined as ammonia nitrogen > 0.5 mg/L or nitrate nitrogen > 50 mg/L.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData where MonitorId = 1 to focus on records from the specified monitor.  【step2】: Apply the warning conditions (AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) to identify all rows where either parameter exceeds its threshold.  【step3】: Restrict the timeframe to the last 24 hours using CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW(), then count the qualifying rows.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1541,
        "question": "If the water quality monitor No. 1 records a pH value of 6.5, an ammonia nitrogen concentration of 1.5 mg/L, and a nitrate nitrogen concentration of 10 mg/L, what are the existing forms of ammonia nitrogen and nitrate nitrogen in the water body and their impact on water quality?",
        "query": "SELECT CASE WHEN PHValue < 7 THEN '氨氮主要以NH4+形式存在' ELSE '氨氮主要以NH3形式存在' END AS AmmoniaForm, CASE WHEN NitrateNitrogenMgL > 5 THEN '硝酸盐氮浓度较高，可能对水体生态系统造成负面影响' ELSE '硝酸盐氮浓度正常' END AS NitrateImpact FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 6.5 AND AmmoniaNitrogenMgL = 1.5 AND NitrateNitrogenMgL = 10;",
        "step": "【step1】: Filter the WaterQualityData table using WHERE conditions to select records where MonitorId=1, PHValue=6.5, AmmoniaNitrogenMgL=1.5, and NitrateNitrogenMgL=10.  【step2】: Apply the first CASE statement to determine ammonia nitrogen form (NH4+ since pH<7).  【step3】: Apply the second CASE statement to evaluate nitrate nitrogen impact (concentration >5mg/L triggers a negative effect warning).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1542,
        "question": "Water quality monitor No. 1 recorded pH values, ammonia nitrogen concentrations, and nitrate nitrogen concentrations over the past 7 days. What percentage of the data points meet the condition where the pH value is below 6.5, the ammonia nitrogen concentration exceeds 1.5 mg/L, and the nitrate nitrogen concentration exceeds 10 mg/L?",
        "query": "SELECT (COUNT(CASE WHEN PHValue < 6.5 AND AmmoniaNitrogenMgL > 1.5 AND NitrateNitrogenMgL > 10 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageConditionMet FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();",
        "step": "【step1】: Filter the data for MonitorId=1 within the last 7 days using WHERE clause with time range condition (CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW()).  【step2】: Calculate conditional counts using COUNT(CASE WHEN...) to find rows meeting all three criteria (PHValue < 6.5 AND AmmoniaNitrogenMgL > 1.5 AND NitrateNitrogenMgL > 10).  【step3】: Compute percentage by multiplying conditional count by 100.0 and dividing by total count of filtered records, ensuring floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1543,
        "question": "Water quality monitor No. 1 recorded a pH value of 8.5, ammonia nitrogen concentration of 0.8 mg/L, and nitrate nitrogen concentration of 20 mg/L. According to drinking water standards, is this water suitable for direct consumption, and what is the reason for the assessment?",
        "query": "SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 AND AmmoniaNitrogenMgL <= 0.5 AND NitrateNitrogenMgL <= 50 THEN '适合直接饮用' ELSE '不适合直接饮用，需进一步检测' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;",
        "step": "【step1】: Filter records from WaterQualityData where MonitorId=1 with specified values (PHValue=8.5, AmmoniaNitrogenMgL=0.8, NitrateNitrogenMgL=20) to isolate the target monitoring data.  【step2】: Check if PHValue (8.5) meets the drinking water standard (6.5-8.5). Since 8.5 is the upper limit, it is considered compliant.  【step3】: Verify AmmoniaNitrogenMgL (0.8) against the threshold (≤0.5) and NitrateNitrogenMgL (20) against the threshold (≤50). Ammonia nitrogen exceeds the limit, triggering the ELSE clause in the CASE statement to return '不适合直接饮用，需进一步检测'.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1544,
        "question": "Assume that water quality monitor No. 1 records a pH value of 15, an ammonia nitrogen concentration of 1000 mg/L, and a nitrate nitrogen concentration of 5000 mg/L, which are extreme outliers (normal ranges are pH 6.5-8.5, ammonia nitrogen < 0.5 mg/L, nitrate nitrogen < 50 mg/L). If the water quality warning system has thresholds of pH < 6.5 or pH > 8.5 for pH, ammonia nitrogen > 0.5 mg/L for ammonia nitrogen, and nitrate nitrogen > 50 mg/L for nitrate nitrogen, and records data once per second, how many warnings will the system trigger in the past 24 hours? Assume the warning rule is pH < 6.5 or pH > 8.5 or ammonia nitrogen > 0.5 mg/L or nitrate nitrogen > 50 mg/L.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5 OR AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter records from WaterQualityData where CollectionTime is within the last 24 hours using BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW().  【step2】: Apply the MonitorId = 1 condition to isolate data from the specific water quality monitor.  【step3】: Count all entries where at least one parameter exceeds thresholds (PHValue < 6.5 OR PHValue > 8.5 OR AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) using conditional OR logic.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1545,
        "question": "If there is a rule in the water quality warning rules table with the parameter type as pH, a threshold of 8.5, and the conditional operator as '>', please analyze the change in hydrogen ion concentration in the water body and its impact on water quality when the pH value in the water quality monitoring data exceeds 8.5, based on the physical significance of the pH value.",
        "query": "SELECT POWER(10, -PHValue) AS HydrogenIonConcentration, CASE WHEN PHValue > 8.5 THEN '水体呈强碱性，可能影响水生生物生存和水质安全' ELSE '水体pH值正常' END AS WaterQualityImpact FROM WaterQualityData WHERE PHValue > 8.5;",
        "step": "【step1】: Filter WaterQualityData records where PHValue exceeds 8.5 using the WHERE clause.  【step2】: Calculate hydrogen ion concentration via POWER(10, -PHValue) based on pH's mathematical definition.  【step3】: Apply CASE statement to classify water quality impact as \"强碱性\" when pH >8.5 or \"正常\" otherwise.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1546,
        "question": "In the water quality warning rule table, calculate the percentage of rules with severity levels exceeding 8 out of the total number of rules.",
        "query": "SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningRule;",
        "step": "【step1】: Use COUNT with CASE WHEN to count the number of rules where SeverityLevel > 8.  【step2】: Calculate the total number of rules using COUNT(*).  【step3】: Divide the count from step 1 by the total count from step 2 and multiply by 100.0 to get the percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1547,
        "question": "In the water quality early warning rules table, there is a rule with the parameter type as dissolved oxygen, a threshold of 5 mg/L, and the condition operator as '<'. According to water quality standards, what is the rationale for setting this rule? Please reason based on the impact of dissolved oxygen on aquatic organisms.",
        "query": "SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = '溶解氧' AND ThresholdValue = 5 AND ConditionOperator = '<';",
        "step": "【step1】: Execute the SQL query to retrieve rules with ParameterType='溶解氧', ThresholdValue=5, and ConditionOperator='<'. This identifies rules triggering alerts when dissolved oxygen drops below 5 mg/L.  【step2】: Cross-reference biological standards: Dissolved oxygen below 5 mg/L threatens most fish (especially cold-water species), causing hypoxia and suffocation. This validates the rule's scientific basis for protecting aquatic life.  【step3】: Check WaterQualityWarningTriggerRecord for historical triggers of this rule to analyze spatial/temporal patterns, confirming its practical relevance to actual ecosystem risks.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1548,
        "question": "Assuming there is a rule in the water quality alert rules table with a parameter type of turbidity, a threshold of 1000 NTU, and a condition operator of '>', which represents an extreme outlier (the normal range is 0-5 NTU). If water quality monitoring records data every second, and the turbidity value exceeds 1000 NTU for 24 hours, how many records in the last 24 hours would trigger an alert based on this rule?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Determine the 24-hour window by calculating the time range from NOW() minus 1 day to NOW().  【step2】: Filter WaterQualityData records where TurbidityNTU > 1000 and CollectionTime is within the calculated 24-hour window.  【step3】: Count the total number of filtered records to calculate the WarningCount.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1549,
        "question": "If there is a rule in the water quality early warning rule table where the parameter type is conductivity, the threshold is 1000 microsiemens per centimeter, and the condition operator is '>', what impact does high conductivity have on water quality when the conductivity in the water quality monitoring data exceeds 1000 microsiemens per centimeter, based on the physical meaning of conductivity?",
        "query": "SELECT CASE WHEN ConductivityUsCm > 1000 THEN '电导率过高，表明水体中离子浓度较高，可能影响水质和生态系统' ELSE '电导率正常' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;",
        "step": "【step1】: Filter data where conductivity exceeds 1000 μS/cm using the WHERE clause to isolate relevant records.  【step2】: Apply CASE conditional logic to generate impact descriptions based on the conductivity threshold violation.  【step3】: Select only the computed impact assessment (ConductivityImpact) for the filtered high-conductivity entries.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1550,
        "question": "In the water quality warning rules table, there are 7 trigger records, with severity levels (SeverityLevel) of 8, 7, 9, 7, 8, 9, and 6 for each record respectively. Calculate the percentage of trigger records with severity levels exceeding 8 out of the total number of trigger records.",
        "query": "SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;",
        "step": "【step1】:【Apply a conditional count to identify records where SeverityLevel > 8 using CASE WHEN】  【step2】:【Calculate total number of records via COUNT(*)】  【step3】:【Compute the percentage by multiplying the conditional count by 100.0 and dividing by the total count, then alias as PercentageAboveThreshold】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1551,
        "question": "There is a triggered record in the water quality early warning rule table with a trigger value of 0.60 and a severity level of 9. Based on water quality standards, what is the rationale behind this triggered record? Please analyze it by considering the impact of ammonia nitrogen on aquatic organisms.",
        "query": "SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;",
        "step": "【step1】:【Access WaterQualityWarningTriggerRecord table and identify columns: TriggerValue, SeverityLevel, ActionTaken, TriggerDescription】  【step2】:【Filter records where TriggerValue = 0.60 mg/L AND SeverityLevel = 9】  【step3】:【Analyze ammonia nitrogen toxicity: At 0.60 mg/L, ammonia nitrogen exceeds safe thresholds for most aquatic life (typically <0.2 mg/L for sensitive species), disrupting osmoregulation and causing gill damage, justifying SeverityLevel 9 due to acute ecological risk】",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1552,
        "question": "Assuming there is a triggered record in the water quality alert rules table, the parameter type is turbidity, the trigger value is 1000 NTU, and the severity is 10, which is an extreme outlier (normal range is 0-5 NTU). If water quality monitoring data is recorded every second, and the turbidity value remains at 1000 NTU consistently over 24 hours, how many alert records will the system generate? Assume the alert rule is for turbidity > 1000 NTU.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from the WaterQualityData table within the last 24 hours using `BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW()` to scope CollectionTime.  【step2】: Apply the turbidity condition `TurbidityNTU > 1000` to identify records violating the warning rule.  【step3】: Aggregate the filtered results using `COUNT(*)` to calculate the total number of warnings triggered.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1553,
        "question": "If there is a rule in the water quality early warning rules table where the parameter type is pH, the threshold is 8.5, and the conditional operator is '>', what is the impact on the carbonate buffer system and water quality stability when the pH value exceeds 8.5?",
        "query": "SELECT CASE WHEN PHValue > 8.5 THEN '碳酸盐缓冲系统可能失效，导致水体pH值波动加剧，影响水质稳定性' ELSE '碳酸盐缓冲系统正常，水质稳定' END AS BufferSystemImpact FROM WaterQualityData WHERE PHValue > 8.5;",
        "step": "【step1】: Filter records where PHValue exceeds 8.5 using WHERE PHValue > 8.5 to isolate data points violating the threshold  【step2】: Apply CASE condition to generate impact analysis: WHEN PHValue > 8.5 returns buffer system instability warning, ELSE returns normal status  【step3】: Project results with BufferSystemImpact alias to explicitly indicate the carbonate buffer system's response to pH fluctuations",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1554,
        "question": "There are 100 rules in the water quality warning rules table, each with a severity level (SeverityLevel) ranging from 1 to 10. The overall average severity is known to be 5.5, with an overall standard deviation of 2.87. Assuming the severity data follows a normal distribution, calculate the percentage of rules with a severity level exceeding 8 out of the total number of rules, and further compute the 95% confidence interval for the average severity level of these rules exceeding 8.",
        "query": "WITH FilteredData AS (SELECT SeverityLevel FROM WaterQualityWarningRule WHERE SeverityLevel > 8) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityWarningRule)) AS PercentageAboveThreshold, AVG(SeverityLevel) - (1.96 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound, AVG(SeverityLevel) + (1.96 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound FROM FilteredData;",
        "step": "【step1】: [Filter data using CTE to retrieve records with SeverityLevel > 8]  【step2】: [Calculate percentage by comparing filtered count to total rules via subquery]  【step3】: [Compute confidence interval using sample mean, standard deviation, and z-score (1.96 for 95% CI)]",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1555,
        "question": "In the water quality early warning rules table, there is a rule with the parameter type as dissolved oxygen, a threshold of 5 mg/L, and the condition operator as '<'. Based on water quality standards and ecological principles, what is the rationale behind the setting of this rule? Please analyze by considering the impact of dissolved oxygen on aquatic organisms and the self-purification capacity of water bodies.",
        "query": "SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = '溶解氧' AND ThresholdValue = 5 AND ConditionOperator = '<';",
        "step": "【step1】: Execute SELECT clause to retrieve RuleName, ParameterType, ThresholdValue, ConditionOperator, and RuleDescription from WaterQualityWarningRule table  【step2】: Apply WHERE clause filters: ParameterType = '溶解氧' for dissolved oxygen parameter, ThresholdValue = 5 mg/L as critical level, and ConditionOperator = '<' for low-value alert  【step3】: Validate rule logic: Dissolved oxygen <5mg/L indicates hypoxia threatening fish survival (most species require >5mg/L), impairs aerobic microbial decomposition (critical for water self-purification), and triggers early warning to prevent ecosystem collapse through timely oxygen replenishment measures.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1556,
        "question": "Assuming there is a rule in the water quality warning rules table with a parameter type of turbidity, a threshold of 1000 NTU, and a condition operator of '>', which represents an extreme outlier (the normal range is 0-5 NTU). If water quality monitoring data is recorded every millisecond and the turbidity value remains above 1000 NTU for 24 hours, how many warning triggers will be counted?",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter records within the last 24 hours using `BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW()` on `CollectionTime`.  【step2】: Apply the turbidity threshold condition `TurbidityNTU > 1000` to identify exceeding values.  【step3】: Count all matching rows with `COUNT(*)` to determine the total warnings triggered.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1557,
        "question": "If there is a rule in the water quality early warning rules table where the parameter type is conductivity, the threshold is 1000 microsiemens per centimeter, and the condition operator is '>', what impact does high conductivity have on water quality when the conductivity in water quality monitoring data exceeds 1000 microsiemens per centimeter?",
        "query": "SELECT CASE WHEN ConductivityUsCm > 1000 THEN '电导率过高，表明水体中离子浓度较高，可能影响水质的化学平衡和生态系统的健康' ELSE '电导率正常' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;",
        "step": "【step1】: Filter records from WaterQualityData where ConductivityUsCm exceeds 1000 using WHERE ConductivityUsCm > 1000  【step2】: Apply CASE statement to generate impact messages - returns preset warning text when ConductivityUsCm >1000, otherwise \"normal\" status  【step3】: Output results with alias ConductivityImpact containing ion concentration analysis and water quality impacts for filtered records",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1558,
        "question": "Calculate the percentage of rules with severity levels between 4 and 7 out of the total number of rules.",
        "query": "SELECT (COUNT(CASE WHEN SeverityLevel BETWEEN 4 AND 7 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityWarningRule;",
        "step": "【step1】: Filter the table to count rows where SeverityLevel is between 4 and 7 using CASE WHEN in COUNT.  【step2】: Calculate total number of rows using COUNT(*).  【step3】: Compute percentage by multiplying (valid count * 100.0) divided by total count.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1559,
        "question": "In the water quality warning rules table, there is a rule with the parameter type as ammonia nitrogen, a threshold of 0.5, and the condition operator as '>'. According to water quality standards, what is the rationale for setting this rule? Please reason based on the impact of ammonia nitrogen on aquatic organisms.",
        "query": "SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = '氨氮' AND ThresholdValue = 0.5 AND ConditionOperator = '>';",
        "step": "【step1】: Retrieve all entries from the WaterQualityWarningRule table  【step2】: Filter entries where ParameterType is '氨氮' (ammonia nitrogen)  【step3】: Further filter results with ThresholdValue = 0.5 mg/L and ConditionOperator = '>', then select RuleName, ParameterType, ThresholdValue, ConditionOperator, and RuleDescription.  **Rationality Analysis**:  Ammonia nitrogen (NH₃-N) concentrations >0.5 mg/L endanger aquatic life. At this threshold:  1. **Acute toxicity**: Free ammonia (NH₃) damages fish gills, impairing oxygen uptake.  2. **Chronic effects**: Prolonged exposure disrupts osmoregulation and reduces growth rates.  3. **Water quality degradation**: Elevated levels indicate organic pollution, potentially triggering eutrophication and oxygen depletion.  This rule aligns with WHO/EPA guidelines (<0.5 mg/L for sensitive species) and preemptively triggers alerts to mitigate ecological risks.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1560,
        "question": "Assuming there is a rule in the water quality alarm rules table where the parameter type is temperature, the threshold is 40 degrees Celsius, the conditional operator is '>', and this is an extreme outlier (normal range is 0-30 degrees Celsius). If the water quality monitoring data is recorded every second and the temperature value remains at 40 degrees Celsius for 24 hours, how many water quality data records from the past day have a temperature above 40 degrees Celsius? The alarm rule is set as temperature > 40 degrees Celsius.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TemperatureCelsius > 40 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();",
        "step": "【step1】: Filter data from WaterQualityData where CollectionTime is within the last 24 hours using `BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW()`.  【step2】: Apply the condition `TemperatureCelsius > 40` to exclude all records where temperature equals or is below 40.  【step3】: Count the filtered records with `COUNT(*) AS WarningCount`, resulting in **0 triggers** (since temperature remains exactly 40, not exceeding 40).",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1561,
        "question": "If there is a record in the water quality warning trigger log with a trigger value of 8.75 pH, please calculate the hydrogen ion concentration (H+) in the water based on the physical meaning of the pH value, and analyze its impact on water quality (specifically whether it is alkaline and how that may affect aquatic organisms and safety).",
        "query": "SELECT POWER(10, -TriggerValue) AS HydrogenIonConcentration, CASE WHEN TriggerValue > 7 THEN '水体呈碱性，可能影响水生生物生存和水质安全' ELSE '水体pH值正常' END AS WaterQualityImpact FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 8.75 AND TriggerUnit = 'pH';",
        "step": "【step1】: Filter records from WaterQualityWarningTriggerRecord where TriggerValue equals 8.75 and unit is 'pH'.  【step2】: Calculate hydrogen ion concentration using formula H+ = 10^(-TriggerValue) via POWER(10, -TriggerValue).  【step3】: Apply CASE statement to determine water alkalinity: if pH >7 returns an alkaline warning, else indicates normal pH.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1562,
        "question": "There are 7 records in the water quality early warning trigger log, with severity levels (SeverityLevel) of 8, 7, 9, 7, 8, 9, and 6 for each record, respectively. Calculate the percentage of trigger records with severity exceeding 8 out of the total number of trigger records.",
        "query": "SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;",
        "step": "【step1】: Evaluate each record's SeverityLevel using CASE expression, returning 1 when exceeding 8 (others become NULL).  【step2】: Calculate two aggregated counts:  - COUNT(CASE...) counts records with SeverityLevel >8 (non-null values)  - COUNT(*) counts total records  【step3】: Compute percentage by (valid_count*100.0)/total_count and alias as PercentageAboveThreshold.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1563,
        "question": "There is a record in the water quality early warning trigger log with a triggered value of 3.80 and a severity level of 7. According to water quality standards, what is the justification for such a trigger record? Please reason based on the impact of dissolved oxygen on aquatic organisms.",
        "query": "SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 3.80 AND SeverityLevel = 7;",
        "step": "【step1】: Execute the provided query to retrieve the trigger record's TriggerValue (3.80 mg/L), SeverityLevel (7), and associated descriptions.  【step2】: Join `WaterQualityWarningTriggerRecord` with `WaterQualityWarningRule` via `RuleId` to verify the rule's threshold and operator (e.g., dissolved oxygen <4.0 mg/L as critical).  【step3】: Analyze biological impact: Dissolved oxygen <5 mg/L stresses aquatic life; 3.80 mg/L is critically low, justifying SeverityLevel 7 if the rule defines this range as severe hypoxia.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1564,
        "question": "Assuming there is a record in the water quality warning trigger log with a trigger value of 1000 NTU for turbidity and a severity level of 10, which is an extreme outlier (the normal range is 0-5 NTU). If water quality monitoring data is recorded every millisecond and the turbidity value remains at 1000 NTU for 24 hours, how many warning triggers will the system generate? The warning rule is set as turbidity > 1000 NTU.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 1000 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Retrieve the MonitorId(s) from the WaterQualityMonitor table where MonitorModel = 'YourMonitorModel' using the subquery `(SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel')`.  【step2】: Filter the WaterQualityData table for entries where the MonitorId matches the result from Step 1, TurbidityNTU exceeds 1000 NTU (`TurbidityNTU > 1000`), and CollectionTime falls within the 24-hour period (`BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00'`).  【step3】: Count the number of matching records (`COUNT(*)`) and return the result as WarningCount. Since the trigger condition is strictly *greater than* 1000 NTU and the scenario states values are *exactly* 1000 NTU, the final count is **0**.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "1",
        "idx": 1565,
        "question": "If there is a record in the water quality early warning trigger log with a triggered value of 7.5 and a unit of 'pH', what is the hydrogen ion concentration (H+) in the water at this time?",
        "query": "SELECT POWER(10, -TriggerValue) AS HydrogenIonConcentration FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 7.5 AND TriggerUnit = 'pH';",
        "step": "【step1】: Filter the WaterQualityWarningTriggerRecord table to retrieve the record where TriggerValue = 7.5 and TriggerUnit = 'pH'.  【step2】: Use the pH formula \\( \\text{[H+]} = 10^{-\\text{pH}} \\) to calculate the hydrogen ion concentration by applying the POWER function: POWER(10, -TriggerValue).  【step3】: Return the calculated hydrogen ion concentration under the alias HydrogenIonConcentration.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "2",
        "idx": 1566,
        "question": "There are 7 records in the water quality early warning trigger log, with severity levels (SeverityLevel) of 8, 7, 9, 7, 8, 9, and 6 for each record respectively. Please calculate the average severity level of these records.",
        "query": "SELECT AVG(SeverityLevel) AS AverageSeverity FROM WaterQualityWarningTriggerRecord;",
        "step": "【step1】: Retrieve all SeverityLevel values from the WaterQualityWarningTriggerRecord table.  【step2】: Calculate the arithmetic mean of the retrieved SeverityLevel values using the AVG() function and alias the result as AverageSeverity.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "3",
        "idx": 1567,
        "question": "There is a record in the water quality early warning trigger log with a trigger value of 0.60 and a severity level of 9. According to water quality standards, what is the rationale behind this trigger record? Please analyze by considering the impact of ammonia nitrogen on aquatic organisms.",
        "query": "SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;",
        "step": "【step1】: Retrieve relevant ammonia nitrogen threshold rules from WaterQualityWarningRule where ParameterType = 'AmmoniaNitrogen' and SeverityLevel = 9 to verify if 0.60 mg/L aligns with the defined threshold value and condition operator.  【step2】: Analyze environmental impacts: Compare 0.60 mg/L ammonia nitrogen against aquatic toxicity standards (typically >0.2-0.5 mg/L harms fish) to assess if SeverityLevel 9 appropriately reflects acute ecological risk at this concentration.  【step3】: Cross-validate with WaterQualityData and MonitorId's WaterSourceType to check if localized factors (e.g., sensitive species in rivers/lakes) justify escalated severity despite apparent threshold-value alignment.",
        "format": "MySQL"
    },
    {
        "db_id": "WaterQualityMonitor",
        "type": "4",
        "idx": 1568,
        "question": "Assuming there is a record in the water quality early warning trigger log with a triggered value of 50 NTU for turbidity and a severity level of 8, which is a relatively high outlier (normal range is 0-5 NTU). If water quality monitoring data is recorded every minute, and the turbidity value remains at 50 NTU for a specific 24-hour period (from 2023-01-01 00:00:00 to 2023-01-02 00:00:00), how many times will the system trigger an early warning? The warning rule is set for turbidity > 5 NTU, and the monitor's model is 'YourMonitorModel'.",
        "query": "SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 5 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
        "step": "【step1】: Execute the subquery to retrieve the MonitorId from WaterQualityMonitor where MonitorModel is 'YourMonitorModel'.  【step2】: Filter WaterQualityData records where MonitorId matches the result from step1, TurbidityNTU > 5, and CollectionTime falls within the 24-hour period (2023-01-01 00:00:00 to 2023-01-02 00:00:00).  【step3】: Count all filtered records from step2 to determine the total WarningCount.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1571,
        "question": "If a water pump has a flow rate of 100, head of 50, and power of 10, what is its efficiency?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;",
        "step": "【step1】: Filter pump_specifications records where Flow_Rate = 100, Head = 50, and Power = 10.  【step2】: Select the Efficiency value from the filtered records.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1572,
        "question": "If a pump has a flow rate of 1000 cubic meters per hour, a head of 1000 meters, and a power of 10,000 kilowatts, what is its efficiency?",
        "query": "SELECT Power, (Power * 10 * 30 * 0.5) AS Monthly_Cost FROM pump_specifications WHERE Voltage = 220 AND Current = 5;",
        "step": "【step1】: [Filter pump_specifications records] Select records where Voltage = 220 AND Current = 5.  【step2】: [Calculate Monthly_Cost] Multiply Power by constants (10 * 30 * 0.5) to derive Monthly_Cost.  【step3】: [None] (This query lacks efficiency calculation despite the user's question, but follows explicit SQL steps.)",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1573,
        "question": "Calculate the pump's power?",
        "query": "SELECT Pump_ID, Purchase_date, Warranty_Period, DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date, CASE WHEN '2023-06-01' <= DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;",
        "step": "【step1】: Extract pump warranty details by selecting Pump_ID, Purchase_date, Warranty_Period, and compute Warranty_End_Date using DATE_ADD function.  【step2】: Filter pumps with Purchase_date = '2022-01-01' and Warranty_Period = 24 months to identify specific records.  【step3】: Apply conditional logic with CASE to determine \"Is_Under_Warranty\" by comparing '2023-06-01' to the calculated Warranty_End_Date.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1574,
        "question": "If a pump has a flow rate of 1000 cubic meters per hour, a head of 1000 meters, and a power of 10,000 kilowatts, calculate the efficiency as a percentage?",
        "query": "SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 10000;",
        "step": "【step1】: Filter pump_specifications records where Flow_Rate = 1000 m³/h, Head = 1000m, and Power = 10000kW  【step2】: Calculate mechanical power formula (Flow_Rate * Head * 9.81) to get hydraulic power in watts  【step3】: Compute efficiency percentage by dividing hydraulic power by input power (Power*3600kW→W conversion) and multiply by 100",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1575,
        "question": "If a water pump has a voltage of 1,000,000 volts, a current of 10,000 amperes, and a power of 10,000,000 kilowatts, what is its efficiency?",
        "query": "SELECT Voltage * Current / 1000 AS Power FROM pump_specifications WHERE Voltage = 1000000 AND Current = 10000;",
        "step": "【step1】: Filter pump_specifications records where Flow_Rate=100 (m³/h), Head=50 (m), and Power=10 (kW) using WHERE clause.  【step2】: Calculate efficiency using formula: (Flow_Rate * Head * 9.81) / (Power * 3600) * 100.  【step3】: Return Efficiency value by applying the calculation in SELECT clause with proper unit conversion constants.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1576,
        "question": "If a water pump has a voltage of 1,000,000 volts, a current of 10,000 amperes, and a power that is calculated as voltage times current, what is its monthly electricity cost assuming an electricity rate of $0.50 per kilowatt-hour?",
        "query": "SELECT Power * 100 * 30 * 0.5 AS Monthly_Electricity_Cost FROM pump_specifications WHERE Voltage = 1000000 AND Current = 10000;",
        "step": "【step1】: Verify WHERE clause: The query uses incorrect voltage (1000000V) and current (10000A) values, while the problem specifies 220V and 30A. Filter should be `WHERE Voltage = 220 AND Current = 30`  【step2】: Validate calculation formula: The formula `Power * 100 * 30 * 0.5` appears to calculate monthly cost with 100 daily hours (unrealistic). A standard formula would use `Power * daily_hours * 30 * electricity_price`.  【step3】: Check field references: The \"Current\" column name is a reserved keyword in SQL. It should be escaped with backticks: ```WHERE Voltage = 220 AND `Current` = 30```",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1577,
        "question": "If a water pump has a warranty period of 24 months and the purchase date is January 15, 2023, what is the warranty expiration date?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;",
        "step": "【step1】: The provided SQL query `SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;` retrieves efficiency values from the `pump_specifications` table based on technical parameters (flow rate, head, power), but it does NOT solve the warranty date calculation problem mentioned in the question.  【step2】: The question requires calculating warranty expiration by adding 24 months to the purchase date (2023-01-15). This should query the `pumps` table using:  ```sql  SELECT DATE_ADD(Purchase_Date, INTERVAL Warranty_Period MONTH) AS Warranty_End  FROM pumps  WHERE Purchase_Date = '2023-01-15' AND Warranty_Period = 24;  ```  【step3】: The original query and the question are mismatched. Either the question is incorrectly paired with the SQL query, or additional context is missing (e.g., using efficiency values to filter pumps for warranty calculations, which would require JOIN operations between `pumps` and `pump_specifications`). Clarification is needed.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1578,
        "question": "If a water pump requires a power input of 1,000,000 kilowatts to achieve a flow rate of 1,000,000 cubic meters per hour against a head of 10,000 meters, what is its hydraulic efficiency? Assume the gravitational acceleration is 9.81 m/s² and the density of water is 1,000 kg/m³.",
        "query": "SELECT Power * Usage_Hours AS Total_Energy_Consumption FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15 AND Voltage = 220 AND Current = 30;",
        "step": "【step1】: Perform INNER JOIN between pump_specifications and usage_records tables using Pump_ID to combine technical parameters with usage data.  【step2】: Filter records with exact matching specifications (Flow_Rate=150, Head=60, Power=15, Voltage=220, Current=30) via WHERE clause.  【step3】: Calculate Total_Energy_Consumption by multiplying Power (from pump_specifications) with Usage_Hours (from usage_records) for qualified entries.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1579,
        "question": "Calculate the warranty end date for pumps purchased on 2023-01-15 with a warranty period of 24 months.",
        "query": "SELECT DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2023-01-15' AND Warranty_Period = 24;",
        "step": "【step1】:【Filter pumps records where Purchase_date is '2023-01-15' and Warranty_Period is 24 months】  【step2】:【Calculate Warranty_End_Date using DATE_ADD function on Purchase_date with Warranty_Period interval】  【step3】:【Return the Warranty_End_Date for matched records】",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1580,
        "question": "Calculate the total energy cost of a water pump over one year, assuming the pump operates for 8 hours per day, has a power of 5 kilowatts, and the electricity price is 0.8 yuan per kilowatt-hour.",
        "query": "SELECT (Flow_Rate * Head * 9.81 * 1000) / (Power * 3600 * 1000) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;",
        "step": "【step1】: 【Retrieve pump specifications】 Extract the pump's technical parameters (Flow_Rate, Head, Power) from pump_specifications table with specific values (Flow_Rate=1,000,000 m³/h, Head=10,000m, Power=1,000,000kW).  【step2】: 【Calculate hydraulic power】 Compute hydraulic power using formula (Flow_Rate × Head × 9.81 × 1000) to convert energy to watts.  【step3】: 【Calculate efficiency】 Convert hydraulic power to percentage efficiency by dividing with (Power × 3600 × 1000) and multiplying by 100, where 3600 converts kW to hourly watts and 1000 handles unit conversions.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1581,
        "question": "What is the power of the pump with a flow rate of 50 and head of 30?",
        "query": "SELECT Power FROM pump_specifications WHERE Flow_Rate = 50 AND Head = 30;",
        "step": "【step1】: Filter pump_specifications records where Flow_Rate is 50 m³/h and Head is 30m.  【step2】: Extract the Power values from the filtered records.  【step3】: (Not explicitly required) Return results with matching Power.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1582,
        "question": "Assuming the power consumption is 5 kW, operating 8 hours per day for 365 days, and the electricity cost is 0.8 RMB per kWh, calculate the total energy consumption in kWh and the total cost in RMB.",
        "query": "SELECT 5 * 8 * 365 AS total_energy_consumption_kWh, 5 * 8 * 365 * 0.8 AS total_cost_RMB;",
        "step": "【step1】: Calculate annual energy consumption by multiplying the given parameters (5kW assumed power * 8 hours/day * 365 days).  【step2】: Calculate total cost using the energy consumption value from Step 1 multiplied by an electricity rate of 0.8 RMB/kWh.  【step3】: No third step required - this query performs simple arithmetic calculations without database joins or conditional logic.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1583,
        "question": "Determine which active water pumps have exceeded their warranty hours in total usage.",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Purchase_date, p.Warranty_Period, p.Location, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, (p.Warranty_Period * 30 * 24) AS Warranty_Hours FROM pumps p JOIN usage_records u ON p.Pump_ID = u.Pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID HAVING Total_Usage_Hours >= Warranty_Hours;",
        "step": "【step1】: Join pumps with usage_records to calculate total usage hours per pump and convert warranty period to comparable hours (Warranty_Period * 30 days * 24 hours).  【step2】: Filter active pumps and group by Pump_ID to aggregate usage data.  【step3】: Apply HAVING clause to identify pumps where total usage hours exceed warranty-derived hours, though this logic misaligns with the original maintenance criteria (warranty validity check should use date comparisons, not usage hours).",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1584,
        "question": "Assuming the pump's flow rate is 10,000 cubic meters per hour, the head is 1,000 meters, and the efficiency is 200%, calculate the required power.",
        "query": "SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Power_Required FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Efficiency = 200;",
        "step": "【step1】:【Filter records in pump_specifications where Flow_Rate = 10000, Head = 1000, and Efficiency = 200】  【step2】:【Calculate the numerator (Flow_Rate * Head * 9.81) for the filtered records】  【step3】:【Divide the numerator by (Efficiency / 100) to compute Power_Required】",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1585,
        "question": "Calculate the pump ID, model number, status, total usage hours, last maintenance date, and warranty end date for active pumps that are still under warranty and have either exceeded 1000 usage hours, have never been maintained, or have not been maintained for over 180 days.",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, MAX(m.Maintenance_Date) AS Last_Maintenance_Date, DATE_ADD(p.Purchase_date, INTERVAL p.Warranty_Period MONTH) AS Warranty_End_Date FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID LEFT JOIN maintenance_records m ON p.Pump_ID = m.pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period HAVING (Total_Usage_Hours > 1000 OR Last_Maintenance_Date IS NULL OR DATEDIFF(CURDATE(), Last_Maintenance_Date) > 180) AND CURDATE() < Warranty_End_Date;",
        "step": "【step1】: Perform LEFT JOINs between pumps, usage_records, and maintenance_records to combine operational data while preserving all active pumps. Calculate Total_Usage_Hours, Last_Maintenance_Date, and Warranty_End_Date.  【step2】: Filter active pumps using WHERE, then GROUP BY pump attributes to aggregate usage hours and maintenance dates per pump.  【step3】: Apply HAVING to select pumps meeting at least one alert condition (excessive usage/exceeded maintenance interval/unmaintained) while still under warranty.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1586,
        "question": "Calculate the required power for a water pump given a flow rate of 10000 and a head of 1000, using the efficiency from pump specifications.",
        "query": "SELECT (10000 * 1000 * 9.81) / (3600 * Efficiency) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;",
        "step": "【step1】: Filter the pump_specifications table to retrieve records where Flow_Rate = 10000 and Head = 1000 using the WHERE clause.  【step2】: Calculate the required power for each filtered record by applying the formula (10000 * 1000 * 9.81) divided by the product of 3600 and Efficiency.  【step3】: Return the calculated result aliased as Required_Power using the AS keyword.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1587,
        "question": "Assuming the water pump has the specified flow rate and head from the database, calculate its required theoretical power and discuss the feasibility under such extreme conditions.",
        "query": "SELECT pumps.Pump_ID, Model_Number, Manufacturer, (Flow_Rate * Head * 9.81 * 1000) / 3600 AS Hydraulic_Power FROM pump_specifications JOIN pumps ON pump_specifications.Pump_ID = pumps.Pump_ID;",
        "step": "【step1】: Perform INNER JOIN between pumps and pump_specifications tables using Pump_ID to combine technical parameters with basic pump details.  【step2】: Calculate hydraulic power using formula (Flow_Rate * Head * 9.81 * 1000) / 3600 for each pump.  【step3】: Select Pump_ID, Model_Number, Manufacturer, and computed Hydraulic_Power for result output.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1588,
        "question": "If a water pump has a power of 10 kilowatts and an actual output power calculated from its specifications, what is its efficiency?",
        "query": "SELECT Pump_ID, Power * (Efficiency / 100) AS Actual_Output_Power FROM pump_specifications;",
        "step": "【step1】: Retrieve Power and Efficiency values from pump_specifications table for calculations  【step2】: Calculate Actual_Output_Power using formula: Power * (Efficiency / 100)  【step3】: Display Pump_ID alongside calculated Actual_Output_Power values",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1589,
        "question": "If a water pump has a flow rate of 200 cubic meters per hour, a head of 80 meters, and an efficiency of 85%, what is its theoretical power?",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, (ps.Flow_Rate * ps.Head * 9.81 / 3600) / (ps.Efficiency / 100) AS Theoretical_Power FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE ps.Flow_Rate = 10000 AND ps.Head = 1000;",
        "step": "【step1】: Perform an INNER JOIN between `pumps` (aliased as p) and `pump_specifications` (aliased as ps) using the Pump_ID field to combine pump metadata with technical specifications.  【step2】: Apply WHERE clause filtering to select records where Flow_Rate equals 10000 m³/h AND Head equals 1000 meters.  【step3】: Calculate Theoretical_Power via formula `(Flow_Rate * Head * 9.81 / 3600) / (Efficiency / 100)` while retrieving Pump_ID, Model_Number, and Manufacturer fields.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1590,
        "question": "If a water pump has a flow rate of 100 cubic meters per hour, a head of 50 meters, and a power of 10 kilowatts, how much electricity does it consume per hour?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;",
        "step": "【step1】: Retrieve the Efficiency value from pump_specifications where Flow_Rate=100, Head=50, and Power=10.  【step2】: Calculate hourly electricity consumption using formula: (Power / (Efficiency/100)) * 1 hour.  【step3】: Apply the calculated efficiency (e.g., 80% efficiency would mean 15kW / 0.8 = 18.75 kWh/hour).",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1591,
        "question": "If a pump has a flow rate of 10,000 cubic meters per hour, a head of 1,000 meters, and a power output of 10,000 kilowatts, what is its efficiency? Assume the gravitational acceleration is 100 m/s².",
        "query": "SELECT (Flow_Rate * Head * 9.81 * (Efficiency / 100)) / 3600 AS Power_kW FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 80 AND Efficiency = 85;",
        "step": "【step1】: Retrieve the pump specification record where Flow_Rate = 200, Head = 80, and Efficiency = 85.  【step2】: Calculate Power_kW using the formula (Flow_Rate * Head * 9.81 * (Efficiency / 100)) / 3600.  【step3】: Return the calculated Power_kW value for the matching record.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1592,
        "question": "If a water pump has a flow rate of 150, a head of 60, and a power of 15, what is its electricity consumption?",
        "query": "SELECT Power * 1 AS Electricity_Consumption FROM pump_specifications WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15;",
        "step": "【step1】: Filter records in the pump_specifications table where Flow_Rate = 150 m³/h and Head = 60m.  【step2】: Select the Power column (15kW) from the filtered records.  【step3】: Return the Power value as Electricity_Consumption through simple column aliasing (Power * 1).  Note: The query appears contradictory - it calculates power using static value 15 instead of voltage/current (220V*10A=2.2kW). The actual physics calculation isn't reflected in the SQL logic or database schema.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1593,
        "question": "If a pump has a flow rate of 100 cubic meters per hour, a head of 50 meters, and a power of 5 kilowatts, what is its efficiency?",
        "query": "SELECT (Flow_Rate * Head * 100) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 10000;",
        "step": "【step1】: Filter records in pump_specifications where Flow_Rate = 100 (unit: m³/h), Head = 50 (unit: meters), and Power = 5 (unit: kW)  【step2】: Calculate efficiency using formula ((Flow_Rate * Head * 100) / (Power * 3600)) * 100  【step3】: Return the calculated value as Efficiency  Note: The original query contains unit errors (10000 instead of 100, 1000 instead of 50, 10000 instead of 5) conflicting with the problem statement. This analysis assumes corrected parameters matching the problem's numerical values.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1594,
        "question": "If a water pump has a voltage of 1,000,000 volts and a current of 5,000 amperes, what is its power? Assume this water pump can withstand such high voltage and current, and disregard practical implementation limitations.",
        "query": "SELECT Power FROM pump_specifications WHERE Voltage = 220 AND Current = 10;",
        "step": "【step1】: Identify the 'pump_specifications' table containing voltage, current, and power metrics.  【step2】: Filter records where Voltage = 220 AND Current = 10 using the WHERE clause.  【step3】: Extract the Power value from the matching row in the filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1595,
        "question": "If a water pump has a flow rate of 100, a head of 50, and a power of 5, what is its efficiency?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 5;",
        "step": "【step1】:【Access the pump_specifications table to query efficiency data.】  【step2】:【Filter records where Flow_Rate is 100 m³/h, Head is 50 meters, and Power is 5 kW.】  【step3】:【Retrieve the Efficiency percentage from the matching specification entry.】",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1596,
        "question": "If a water pump has a flow rate of 1,000,000 cubic meters per hour, a head of 5,000 meters, and an efficiency of 100%, what is its theoretical power requirement?",
        "query": "SELECT (1000000 * 5000) / 1000 AS Power_kW;",
        "step": "【step1】:【Apply the power calculation formula P = (Q × H × ρ × g) / (η × 3600) where Q=100 m³/h, H=50m, η=80%, assuming ρ=1000 kg/m³ and g=9.8 m/s²】  【step2】:【Convert units and simplify: (100 * 50 * 1000 * 9.8) / (0.8 * 3600) ≈ 17013.89W → 17.01kW】  【step3】:【Execute SQL: SELECT ROUND((100 * 50 * 1000 * 9.8) / (0.8 * 3600 * 1000), 2) AS Power_kW;】",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1597,
        "question": "What is the pump's actual power when the current is 10 and voltage is 220?",
        "query": "SELECT (Voltage * Current * 0.8) / 1000 AS Actual_Power FROM pump_specifications WHERE Current = 10 AND Voltage = 220;",
        "step": "【step1】: Filter records from pump_specifications where Current is 10 amps  【step2】: Further filter the results where Voltage is 220 volts  【step3】: Calculate Actual_Power for the filtered records using the formula (Voltage * Current * 0.8) / 1000 and return the result",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1598,
        "question": "If a pump's current reaches 1000 amperes, the voltage is 10,000 volts, and the power factor is 1, what is its actual power?",
        "query": "SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Theoretical_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Efficiency = 80;",
        "step": "【step1】: Filter pump_specifications records where Flow_Rate = 100 m³/h, Head = 50m, and Efficiency = 80%  【step2】: Calculate Theoretical_Power using formula (Flow_Rate × Head × 9.81) / (Efficiency / 100) for the filtered records  【step3】: Return the calculated Theoretical_Power for the matching specifications",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1599,
        "question": "What information is available about pumps that are currently active and have a current value at least twice the average current for their pump ID, including their model number, location, current, voltage, power, maintenance type, maintenance description, usage hours, and usage notes?",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Location, ps.Current, ps.Voltage, ps.Power, mr.Maintenance_Type, mr.Description, ur.Usage_Hours, ur.Notes FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.pump_ID LEFT JOIN usage_records ur ON p.Pump_ID = ur.pump_ID WHERE ps.Current >= (SELECT 2 * AVG(Current) FROM pump_specifications WHERE Pump_ID = p.Pump_ID) AND p.Status = 'active';",
        "step": "【step1】: Join pumps with pump_specifications using Pump_ID, then LEFT JOIN maintenance_records and usage_records via Pump_ID.  【step2】: Calculate subquery (2 * average Current) for each Pump_ID from pump_specifications.  【step3】: Filter results where Current exceeds the subquery value and pump status is 'active'.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1600,
        "question": "If a water pump has a power of 10 kilowatts, and its actual power is calculated as 10000 watts, what is the ratio of actual power to rated power?",
        "query": "SELECT (1000 * 10000 * 1) / 1000 AS Actual_Power;",
        "step": "【step1】: Calculate theoretical input power using voltage and current: Voltage * Current  【step2】: Calculate output power by converting motor power to watts: power * 1000  【step3】: Compute efficiency percentage: (Output_Power / Input_Power) * 100  Note: The given query appears flawed as it uses fixed values (1000*10000*1) instead of actual database fields and applies incorrect formula. Proper implementation should reference pump_specifications table columns and use formula:  SELECT (power * 1000) / (Voltage * Current) * 100 AS Efficiency  FROM pump_specifications  WHERE ... [specific conditions]",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1601,
        "question": "If a water pump has an efficiency of 200%, a flow rate of 1000 cubic meters per hour, and a head of 1000 meters, what is its output power in kilowatts?",
        "query": "SELECT (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600 AS Output_Power_kW FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Efficiency = 85;",
        "step": "【step1】: Filter records in pump_specifications where Flow_Rate = 100, Head = 50, and Efficiency = 85.  【step2】: Calculate Output_Power_kW using formula (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600.  【step3】: Return the calculated Output_Power_kW as a single result column.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1602,
        "question": "If a water pump has a power of 10 kilowatts, a voltage of 220 volts, and a current of 50 amperes, what is its efficiency?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Power = 10 AND Voltage = 220 AND Current = 50;",
        "step": "【step1】: Access the pump_specifications table to retrieve efficiency data  【step2】: Apply the filter conditions **Power = 10**, **Voltage = 220**, and **Current = 50** to pinpoint the specific pump's efficiency  【step3】: Extract the **Efficiency** value directly from the filtered record",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1603,
        "question": "If a water pump has a warranty period of 24 months and was purchased on January 1, 2020, when does its warranty expire?",
        "query": "SELECT (Flow_Rate * Head * 9.81 * (Efficiency / 100)) / 3600 AS Output_Power FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Efficiency = 200;",
        "step": "【step1】: Filter the pump_specifications table where Flow_Rate = 1000, Head = 1000, and Efficiency = 200  【step2】: Calculate Output_Power using the formula (Flow_Rate * Head * 9.81 * (Efficiency / 100)) / 3600  【step3】: Return the calculated Output_Power for the matching specifications",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1604,
        "question": "If a water pump has a flow rate of 10,000 cubic meters per hour, a head of 1,000 meters, and a power of 1,000 kilowatts, what is its efficiency? Assuming the efficiency of this pump exceeds 100%, is this possible?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;",
        "step": "【step1】:【Retrieve Efficiency value】Execute SELECT statement on pump_specifications table to find Efficiency by matching Flow_Rate (100 m³/h), Head (50m), and Power (10kW).  【step2】:【Check input validity】Verify unit conversions (problem mentions 10000 m³/h flow vs query's 100) and physical plausibility.  【step3】:【Analyze efficiency result】If returned Efficiency >100%, flag data error since thermodynamic laws prohibit >100% energy conversion efficiency.  Note: Actual query parameters don't match problem statement values (100 vs 10000 flow rate), indicating potential unit mismatch or typo.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1605,
        "question": "If a pump was purchased on 2020-01-01 with a warranty period of 24 months, when does its warranty end?",
        "query": "SELECT DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 24;",
        "step": "【step1】: Filter records from the pumps table where Purchase_date is '2020-01-01' and Warranty_Period is 24.  【step2】: Apply the DATE_ADD function to calculate the Warranty_End_Date by adding 24 months to the Purchase_date.  【step3】: Return the computed Warranty_End_Date as the result set.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1606,
        "question": "If a water pump has a flow rate of 10,000 cubic meters per hour, a head of 1,000 meters, and a power of 1,000 kilowatts, what is its efficiency? Assume the gravitational acceleration is 9.81 m/s².",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000;",
        "step": "【step1】: Filter records in the pump_specifications table where Flow_Rate = 10000 m³/h, Head = 1000 m, and Power = 1000 kW.  【step2】: Retrieve the Efficiency value from the matched record.  (No step3 required since this is a direct lookup without joins, subqueries, or sorting.)",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1607,
        "question": "Calculate the efficiency of a water pump with a flow rate of 100, head of 50, and power of 10.",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;",
        "step": "【step1】: Filter pump_specifications records with Flow_Rate = 100, Head = 50, and Power = 10.  【step2】: Extract Efficiency values from the filtered specifications.  【step3】: Return single Efficiency metric meeting all technical criteria.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1608,
        "question": "Determine the efficiency of the pump with a flow rate of 1,000,000, a head of 10,000, and a power of 1,000,000.",
        "query": "SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;",
        "step": "【step1】: Calculate the efficiency of the pump with specific technical parameters (Flow_Rate=1000000, Head=10000, Power=1000000) using the formula _(Flow_Rate * Head * 9.81) / (Power * 3600) * 100_.  【step2】: Filter results by matching the exact technical specifications (Flow_Rate, Head, Power) in the `pump_specifications` table.  【step3】: Analyze maintenance frequency from `maintenance_records` and usage patterns from `usage_records` for Pump_ID=11 to evaluate part replacement needs (not explicitly covered in the provided query).",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1609,
        "question": "Assuming the maintenance cost of a certain water pump suddenly increases to 100 times its normal value, what are the possible reasons and their impact on the system, based on the total maintenance cost and total usage hours for each pump over the past year?",
        "query": "SELECT p.Pump_ID, p.Model_Number, SUM(mr.Cost) AS Total_Maintenance_Cost, SUM(ur.Usage_Hours) AS Total_Usage_Hours FROM pumps p JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID WHERE mr.Maintenance_Date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND ur.Start_Time >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY p.Pump_ID, p.Model_Number ORDER BY Total_Maintenance_Cost DESC, Total_Usage_Hours DESC;",
        "step": "【step1】: Join pumps with maintenance_records and usage_records via Pump_ID, filter records from the last year using DATE_SUB(CURDATE(), INTERVAL 1 YEAR) on both Maintenance_Date and Start_Time  【step2】: Group by Pump_ID and Model_Number, calculate SUM(mr.Cost) as Total_Maintenance_Cost and SUM(ur.Usage_Hours) as Total_Usage_Hours  【step3】: Sort results by Total_Maintenance_Cost descending first, then by Total_Usage_Hours descending as secondary sorting criteria",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1610,
        "question": "Which pump has a maintenance count greater than 5 or total usage hours greater than 1000 for pump ID 11?",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Status, COUNT(mr.record_ID) AS Maintenance_Count, SUM(u.Usage_Hours) AS Total_Usage_Hours FROM pumps p LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.pump_ID LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' GROUP BY p.Pump_ID, p.Model_Number, p.Status HAVING Maintenance_Count > 5 OR Total_Usage_Hours > 1000;",
        "step": "【step1】: Join pumps table with maintenance_records and usage_records via LEFT JOIN to collect maintenance/usage data for pump 11  【step2】: Group by pump details while aggregating maintenance count (COUNT) and total usage hours (SUM)  【step3】: Filter results using HAVING clause to retain only records with >5 maintenance instances OR >1000 usage hours",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1611,
        "question": "Determine which pumps require maintenance based on the following conditions: the pump's total usage time exceeds 1000 hours, or the pump's warranty period has expired.",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Location, p.Status, ps.Flow_Rate, ps.Head, ps.Power, ps.Voltage, ps.Current, ps.Efficiency, mr.Maintenance_Date, mr.Maintenance_Type, mr.Description, mr.Technician, mr.Cost, ur.Start_Time, ur.End_Time, ur.Usage_Hours, ur.Notes FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID WHERE mr.Cost > (SELECT AVG(Cost) * 100 FROM maintenance_records WHERE Pump_ID = p.Pump_ID) ORDER BY mr.Maintenance_Date DESC;",
        "step": "【step1】: Calculate the average maintenance cost multiplied by 100 for each pump via the subquery in the WHERE clause.  【step2】: Join the `pumps`, `pump_specifications`, `maintenance_records`, and `usage_records` tables using `Pump_ID` as the primary linking field.  【step3】: Filter records where the maintenance cost exceeds the subquery result (average cost × 100) and sort results by `Maintenance_Date` descending.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1612,
        "question": "Assuming a water pump has a flow rate of 10,000 cubic meters per hour and a head of 1,000 meters, calculate the total energy consumption for pump ID 11 in the current year.",
        "query": "SELECT SUM(ps.Power * u.Usage_Hours) AS Total_Energy_Consumption FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' AND YEAR(u.Start_Time) = YEAR(CURDATE());",
        "step": "【step1】:Join pumps and pump_specifications tables using Pump_ID to access the power value  【step2】:Join usage_records to filter records from current year and obtain usage hours  【step3】:Calculate total energy consumption by multiplying power with usage hours and summing results",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1613,
        "question": "Assuming the pump's flow rate increases to 10,000 cubic meters per hour and the head increases to 1,000 meters, calculate the required power.",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period, SUM(u.Usage_Hours) AS Total_Usage_Hours, CASE WHEN SUM(u.Usage_Hours) > 1000 OR DATE_ADD(p.Purchase_date, INTERVAL p.Warranty_Period MONTH) < CURDATE() THEN '需要维护' ELSE '无需维护' END AS Maintenance_Status FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period;",
        "step": "【step1】: Join the 'pumps' table with 'usage_records' using LEFT JOIN on Pump_ID to associate usage data with each pump.  【step2】: Group results by Pump_ID, Model_Number, Status, Purchase_date, and Warranty_Period, while calculating Total_Usage_Hours via SUM(u.Usage_Hours).  【step3】: Apply CASE statement to determine Maintenance_Status based on Total_Usage_Hours (>1000 hours) or warranty expiration (Purchase_date + Warranty_Period < current date).",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1614,
        "question": "Calculate the total energy consumption of the water pump during a specific time period (unit: kilowatt-hour).",
        "query": "SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;",
        "step": "【step1】: Retrieve pump specifications (Flow_Rate, Head, Efficiency) and calculate instantaneous power requirement using the formula (Flow_Rate * Head * 9.81) / (Efficiency / 100).  【step2】: Join with usage_records on Pump_ID to obtain Usage_Hours during specific time period through WHERE conditions on Start_Time/End_Time.  【step3】: Multiply calculated Required_Power by Usage_Hours to get total energy consumption (kWh) and aggregate using SUM().",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1615,
        "question": "Calculate the average maintenance cost of the water pump per month.",
        "query": "SELECT (10000 * 1000 * 9.81) / (3600 * Efficiency) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;",
        "step": "【step1】: Filter pump_specifications records where Flow_Rate = 10000 m³/h and Head = 1000m using WHERE clause.  【step2】: Calculate required hydraulic power for each matching pump using formula (10000*1000*9.81)/(3600*Efficiency) in SELECT.  【step3】: Return the calculated Required_Power values for qualified pump technical specifications.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1616,
        "question": "Assuming the pump's flow rate increases to 10,000 cubic meters per hour, calculate the total energy consumption in kWh for all pumps used between January 1, 2023, and December 31, 2023.",
        "query": "SELECT SUM(ps.Power * u.Usage_Hours) AS Total_Energy_Consumption_kWh FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE u.Start_Time >= '2023-01-01 00:00:00' AND u.End_Time <= '2023-12-31 23:59:59';",
        "step": "【step1】: Perform INNER JOIN between pumps, pump_specifications, and usage_records tables using Pump_ID as the foreign key relationship  【step2】: Filter records where usage period falls within calendar year 2023 using Start_Time and End_Time conditions  【step3】: Calculate total energy consumption by multiplying power (kW) with Usage_Hours and aggregate using SUM()",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1617,
        "question": "If a pump has a flow rate of 100 cubic meters per hour, a head of 50 meters, and a power of 10 kilowatts, what is its efficiency?",
        "query": "SELECT AVG(monthly_cost) AS average_monthly_maintenance_cost FROM (SELECT SUM(Cost) / 12 AS monthly_cost FROM maintenance_records WHERE Maintenance_Date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY YEAR(Maintenance_Date), MONTH(Maintenance_Date)) AS monthly_costs;",
        "step": "【step1】:【Filter maintenance records from the past year using WHERE Maintenance_Date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR).】  【step2】:【Group filtered records by year and month, calculate monthly total cost via SUM(Cost)/12 (adjusted to monthly average).】  【step3】:【Compute the overall average of the monthly costs using the outer AVG(monthly_cost) function.】",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1618,
        "question": "If a pump operates continuously for 24 hours with a flow rate of 200 cubic meters per hour, a head of 30 meters, and an efficiency of 85%, how much total electrical energy does it consume during these 24 hours?",
        "query": "SELECT Pump_ID, (10000 * Head * 9.81) / (Efficiency / 100) / 3600 AS New_Power FROM pump_specifications;",
        "step": "【step1】: Retrieve Head (30 meters) and Efficiency values from the pump_specifications table for relevant pumps.  【step2】: Calculate hydraulic power using formula: (10000 * Head * 9.81) / 3600  【step3】: Adjust for efficiency and derive New_Power: (hydraulic power result) / (Efficiency / 100)",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1619,
        "question": "Is the water pump with a flow rate of 100, head of 50, and power of 10 still under warranty if its operating duration has exceeded the warranty period?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;",
        "step": "【step1】: Retrieve technical specifications data from the pump_specifications table by matching Flow_Rate=100, Head=50, and Power=10.  【step2】: Filter records that simultaneously satisfy all three parameter conditions (Flow_Rate, Head, Power).  【step3】: Return the Efficiency value from the filtered records as the final result.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1620,
        "question": "If a water pump has a flow rate of 200 cubic meters per hour, a head of 30 meters, and a power of 15 kilowatts, what is its total energy consumed over 24 hours?",
        "query": "SELECT Power * 24 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 30 AND Power = 15;",
        "step": "【step1】: Filter records in the pump_specifications table where Flow_Rate = 200, Head = 30, and Power = 15.  【step2】: Calculate \"Power * 24\" for the filtered records.  【step3】: Return the result with the alias Total_Energy_Consumed.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1621,
        "question": "If a pump's usage hours exceed its warranty period in equivalent days, which pumps are out of warranty based on the warranty status calculated from their purchase date and warranty period?",
        "query": "SELECT Pump_ID, Model_Number, Manufacturer, Purchase_date, Warranty_Period, Location, Status, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) < NOW() THEN 'Out of Warranty' ELSE 'Under Warranty' END AS Warranty_Status FROM pumps WHERE Pump_ID IN (SELECT Pump_ID FROM usage_records WHERE Usage_Hours > (Warranty_Period * 30 * 24));",
        "step": "【step1】: Execute the subquery to retrieve Pump_IDs from usage_records where Usage_Hours exceed the warranty period converted to hours (Warranty_Period * 30 * 24).  【step2】: In the main query, calculate Warranty_Status for each pump using DATE_ADD and CASE to compare Purchase_date + Warranty_Period months against current time.  【step3】: Filter results with WHERE Pump_ID IN (subquery) to return pumps with usage exceeding warranty-based hour thresholds.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1622,
        "question": "If a water pump has a flow rate of 1000 cubic meters per hour, a head of 1000 meters, and a power of 1000 kilowatts, what is its efficiency?",
        "query": "SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;",
        "step": "【step1】: Access the \"pump_specifications\" table.  【step2】: Apply filters using WHERE clause to match Flow_Rate = 1000, Head = 1000, and Power = 1000.  【step3】: Retrieve the \"Efficiency\" value from the filtered row(s).",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1623,
        "question": "Calculate the total energy consumed by water pumps with a flow rate of 200, head of 30, power of 15, and usage hours of 8 * 365.",
        "query": "SELECT SUM(Power * Usage_Hours) AS Total_Energy_Consumption FROM usage_records JOIN pump_specifications ON usage_records.pump_ID = pump_specifications.Pump_ID WHERE pump_specifications.Flow_Rate = 200 AND pump_specifications.Head = 30 AND pump_specifications.Power = 15 AND usage_records.Usage_Hours = 8 * 365;",
        "step": "【step1】: Join usage_records with pump_specifications via Pump_ID to link operational data with technical parameters.  【step2】: Filter records matching Flow_Rate=200, Head=30, Power=15, and Usage_Hours=2920 (8*365) using WHERE conditions.  【step3】: Calculate total energy by summing Power × Usage_Hours across all filtered records using SUM() aggregation.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1624,
        "question": "Determine the efficiency of the water pump with a flow rate of 1000, head of 1000, and power of 1000.",
        "query": "SELECT (Flow_Rate * Head * 10 * 1000) / (Power * 3600 * 1000) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;",
        "step": "【step1】: Apply WHERE clause to filter pump_specifications records where Flow_Rate=1000, Head=1000, and Power=1000.  【step2】: Calculate hydraulic efficiency using formula ((Flow_Rate * Head * 10 * 1000) / (Power * 3600 * 1000)) * 100 as Efficiency.  【step3】: Output the calculated Efficiency value for matched specifications.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1625,
        "question": "Assuming a water pump has a power of 1000 kilowatts and runs continuously for 100 years, calculate its total energy consumption in kilowatt-hours.",
        "query": "",
        "step": "【step1】: Retrieve the pump's power value (1000 kW) from pump_specifications table.  【step2】: Calculate annual consumption: 1000 kW × 24 hours/day × 365 days.  【step3】: Multiply by 100 years to get total consumption: (1000×24×365) × 100.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1626,
        "question": "Calculate the total energy consumption of the active water pumps within one year, assuming each pump operates 8 hours per day with constant power.",
        "query": "",
        "step": "【step1】: Perform INNER JOIN between `pumps` and `pump_specifications` tables on `Pump_ID` to combine operational status and power specifications.  【step2】: Filter results using `WHERE Status = 'active'` to select only operational pumps.  【step3】: Calculate total annual energy consumption using `power * 8 * 365` for each qualifying pump.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1627,
        "question": "Calculate the average maintenance cost of this water pump and predict the total maintenance cost for the next 5 years.",
        "query": "SELECT 1000 * 24 * 365 * 100 AS Total_Energy_Consumption;",
        "step": "【step1】: Calculate average maintenance cost using AVG(Cost) from maintenance_records  【step2】: Multiply the average by 5 years (assuming linear projection)  【step3】: Combine both calculations in SELECT clause: SELECT (SELECT AVG(Cost) FROM maintenance_records) AS Avg_Cost, (SELECT AVG(Cost)*5 FROM maintenance_records) AS Total_5yr_Projection;",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1628,
        "question": "If a water pump has a warranty period of 24 months, the purchase date is January 1, 2021, and the current date is January 1, 2023, please determine whether the water pump is still under warranty and explain the basis for your judgment.",
        "query": "SELECT ps.Pump_ID, SUM(ps.Power * 8 * 365) AS Total_Energy_Consumption FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE p.Status = 'active' GROUP BY ps.Pump_ID;",
        "step": "【step1】:JOIN the `pumps` and `pump_specifications` tables using `Pump_ID`, filtering for active status pumps.  【step2】:Calculate energy consumption for each pump using formula `SUM(ps.Power * 8 * 365)`, assuming 8 hours/day operation.  【step3】:Group results by `Pump_ID` to show total annual energy consumption per active pump.  (Note: The original question about warranty period doesn't match the provided SQL query. This analysis focuses on the actual query given.)",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1629,
        "question": "Assuming a water pump has a flow rate of 10,000 cubic meters per hour, a head of 1,000 meters, a power of 1,000 kilowatts, a voltage of 10,000 volts, a current of 1,000 amperes, and an efficiency of 200%, please calculate the actual output power and theoretical output power of the pump, and analyze whether its efficiency is reasonable?",
        "query": "WITH MaintenanceCosts AS (SELECT Cost FROM maintenance_records WHERE pump_ID = '指定的水泵ID' ORDER BY Maintenance_Date DESC LIMIT 10) SELECT AVG(Cost) AS Average_Maintenance_Cost, AVG(Cost) * 5 * 10 AS Predicted_Total_Maintenance_Cost_Next_5_Years FROM MaintenanceCosts;",
        "step": "【step1】: Retrieve the latest 10 maintenance costs for the target pump via CTE MaintenanceCosts (SELECT Cost FROM maintenance_records with pump_ID filter, ordered by Maintenance_Date DESC with LIMIT 10)  【step2】: Calculate average maintenance cost from the CTE results using AVG(Cost)  【step3】: Project future maintenance costs by multiplying the average cost by 50 (5 years × 10 maintenance cycles assumption) via AVG(Cost)*5*10",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1630,
        "question": "What is the warranty status of pumps purchased on 2021-01-01 with a warranty period of 24 months?",
        "query": "SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) >= '2023-01-01' THEN '在保修期内' ELSE '不在保修期内' END AS Warranty_Status FROM pumps WHERE Purchase_date = '2021-01-01' AND Warranty_Period = 24;",
        "step": "【step1】: Filter records from the pumps table where Purchase_date is '2021-01-01' and Warranty_Period is 24 months  【step2】: Calculate warranty expiration date using DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH)  【step3】: Determine Warranty_Status by comparing the calculated expiration date with '2023-01-01' via CASE expression",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1631,
        "question": "Assuming a water pump has a flow rate of 10000 cubic meters per hour, a head of 1000 meters, a power of 1000 kilowatts, a voltage of 10000 volts, a current of 1000 amperes, and an efficiency of 200%. If the pump operates for 10 hours a day and the cost per kilowatt-hour is 0.8 yuan, what is the pump's monthly electricity cost?",
        "query": "SELECT Power AS Theoretical_Output_Power, (Flow_Rate * Head * 9.81) / 3600 AS Actual_Output_Power, Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000 AND Voltage = 10000 AND Current = 1000 AND Efficiency = 200;",
        "step": "【step1】: Filter pump_specifications records with exact parameters (Flow_Rate=10000, Head=1000, Power=1000, Voltage=10000, Current=1000, Efficiency=200)  【step2】: Calculate Actual_Output_Power using formula (Flow_Rate*Head*9.81)/3600 alongside existing Power column  【step3】: Select and alias Theoretical_Output_Power (original Power), calculated Actual_Output_Power, and Efficiency columns",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1632,
        "question": "If a water pump has a flow rate of 200 cubic meters per hour, a head of 30 meters, a power of 50 kilowatts, a voltage of 220 volts, a current of 200 amperes, and an efficiency of 80%, what is the actual output power of the pump?",
        "query": "SELECT Power * Efficiency / 100 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 500 AND Head = 80 AND Power = 100 AND Voltage = 380 AND Current = 150 AND Efficiency = 85;",
        "step": "【step1】: Filter pump_specifications records where Flow_Rate=500, Head=80, Power=100, Voltage=380, Current=150, and Efficiency=85.  【step2】: Calculate Actual_Output_Power by multiplying Power and Efficiency, then dividing by 100 for the filtered records.  【step3】: Return the computed Actual_Output_Power as the final result.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1633,
        "question": "Assuming a water pump has a flow rate of 300 cubic meters per hour, a head of 50 meters, a power of 75 kilowatts, a voltage of 400 volts, a current of 120 amperes, and an efficiency of 90%. If this pump runs for 10 hours daily for 30 days, what is the monthly electricity cost?",
        "query": "SELECT (Power * (Usage_Hours * 30) * 0.8) AS monthly_electricity_cost FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 300 AND Head = 50 AND Power = 75 AND Voltage = 400 AND Current = 120 AND Efficiency = 90 AND Usage_Hours = 10;",
        "step": "【step1】: Join pump_specifications and usage_records tables using Pump_ID to associate technical parameters with usage data.  【step2】: Filter records where Flow_Rate=300, Head=50, Power=75, Voltage=400, Current=120, Efficiency=90, and Usage_Hours=10 to identify matching pumps.  【step3】: Calculate monthly_electricity_cost by multiplying Power, total monthly usage hours (10*30), and 0.8 factor for eligible pumps.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1634,
        "question": "If a water pump has a flow rate of at least 200 cubic meters per hour, a head of at least 50 meters, a power of at least 50 kilowatts, a voltage of 220 volts, a current of 200 amperes, and an efficiency of at least 80%, what is the actual output power of the pump?",
        "query": "SELECT p.Pump_ID, p.Model_Number, p.Manufacturer FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID WHERE ps.Flow_Rate >= 200 AND ps.Head >= 30 AND ps.Power >= 50 AND ps.Voltage = 220 AND ps.Current = 200 AND ps.Efficiency >= 80 AND p.Status = 'active';",
        "step": "【step1】: Perform INNER JOIN between pumps and pump_specifications tables using Pump_ID to combine operational and technical data  【step2】: Apply filtering conditions (Flow_Rate ≥200, Head ≥30, Power ≥50, Voltage=220, Current=200, Efficiency ≥80%, Status=active) to identify qualified pumps  【step3】: Select required columns (Pump_ID, Model_Number, Manufacturer) from the filtered results",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1635,
        "question": "If a water pump has a warranty period of 36 months and was purchased on January 1, 2020, is the pump still under warranty on June 1, 2023? If not, how many days has it been out of warranty?",
        "query": "SELECT CEIL(100000000000 / (Flow_Rate * 3600)) AS required_pumps FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 5000 AND Voltage = 10000 AND Current = 500 AND Efficiency = 95;",
        "step": "【step1】:Filter pump_specifications records where Flow_Rate = 10000, Head = 1000, Power = 5000, Voltage = 10000, Current = 500, and Efficiency = 95.  【step2】:Calculate 100000000000 divided by (Flow_Rate * 3600) to determine base pump requirement.  【step3】:Apply CEIL() function to round up the division result and return as required_pumps.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1636,
        "question": "What is the actual output power of a water pump with a flow rate of 100, head of 50, power of 10, voltage of 220, current of 45, and efficiency of 85?",
        "query": "SELECT (Power * Efficiency / 100) AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Voltage = 220 AND Current = 45 AND Efficiency = 85;",
        "step": "【step1】: Apply WHERE clause to filter pump_specifications with Flow_Rate=100, Head=50, Power=10, Voltage=220, Current=45, and Efficiency=85  【step2】: Calculate Actual_Output_Power using formula (Power * Efficiency / 100) for the filtered record  【step3】: Return the computed Actual_Output_Power value as the final result",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1637,
        "question": "Assuming a water pump was purchased on January 1, 2020, with a warranty period of 36 months, what is the warranty status and the number of days out of warranty for that pump as of June 1, 2023?",
        "query": "SELECT Pump_ID, Purchase_date, Warranty_Period, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) >= '2023-06-01' THEN '在保修期内' ELSE '不在保修期内' END AS Warranty_Status, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) < '2023-06-01' THEN DATEDIFF('2023-06-01', DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH)) ELSE 0 END AS Days_Out_of_Warranty FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 36;",
        "step": "【step1】: Filter pumps purchased on '2020-01-01' with 36-month warranty using WHERE clause.  【step2】: Calculate warranty expiration date with DATE_ADD, then determine Warranty_Status by comparing to '2023-06-01'.  【step3】: Compute Days_Out_of_Warranty using DATEDIFF between '2023-06-01' and expiration date if expired.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1638,
        "question": "If a pump has a flow rate of 100 cubic meters per hour, a head of 50 meters, a power of 10 kilowatts, a voltage of 220 volts, a current of 45 amperes, and an efficiency of 85%, then what is the pump ID, maintenance date, maintenance type, and cost for the pump that had a maintenance record on '2023-01-01' with type 'Replace parts' and cost 5000, showing only its most recent maintenance record?",
        "query": "SELECT Pump_ID, Maintenance_Date, Maintenance_Type, Cost FROM maintenance_records WHERE Pump_ID = (SELECT Pump_ID FROM maintenance_records WHERE Maintenance_Date = '2023-01-01' AND Maintenance_Type = '更换零件' AND Cost = 5000) ORDER BY Maintenance_Date DESC LIMIT 1;",
        "step": "【step1】: Execute the subquery to find the Pump_ID that matches the maintenance record with date '2023-01-01', type '更换零件', and cost 5000.  【step2】: Retrieve all maintenance records for the identified Pump_ID from the maintenance_records table.  【step3】: Sort the results by Maintenance_Date in descending order and return the most recent record using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1639,
        "question": "Assuming a water pump has a flow rate of 120 cubic meters per hour, a head of 60 meters, a power output of 12 kilowatts, a voltage of 220 volts, a current of 50 amperes, and an efficiency of 90%. If the pump operates for 8 hours each day continuously for 30 days, how much total electrical energy will the pump consume during these 30 days?",
        "query": "SELECT Power * (Efficiency / 100) AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000 AND Voltage = 10000 AND Current = 1000 AND Efficiency = 200;",
        "step": "【step1】: Retrieve actual power output using formula: Power * (Efficiency/100) FROM pump_specifications WHERE given parameters match the technical specifications  【step2】: Calculate total operating hours: Daily_Hours * Days = 8 * 30  【step3】: Compute total energy consumption: Actual_Output_Power * Total_Operating_Hours (requires joining with usage_records for real-world implementation)",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1640,
        "question": "Assuming a water pump has a flow rate of 1000 cubic meters per hour, a head of 1000 meters, a power of 1000 kilowatts, a voltage of 1000 volts, a current of 1000 amperes, and an efficiency of 100%. If this water pump operates continuously for 1000 hours, what is the actual energy consumption of the pump during these 1000 hours?",
        "query": "SELECT (Power * 1000 * Usage_Hours) / Efficiency AS Actual_Energy_Consumption FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Voltage = 220 AND Current = 45 AND Efficiency = 85 AND Usage_Hours = 1;",
        "step": "【step1】: Perform INNER JOIN between `pump_specifications` and `usage_records` using `Pump_ID` to combine technical parameters with operational duration data.  【step2】: Filter rows by exact technical specifications (Flow_Rate=100, Head=50, Power=10, Voltage=220, Current=45, Efficiency=85) and Usage_Hours=1.  【step3】: Calculate energy consumption with formula `(Power * 1000 * Usage_Hours) / Efficiency`, converting power to watts and accounting for efficiency percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1641,
        "question": "If a water pump has a flow rate of 100 cubic meters per hour, a head of 50 meters, a power of 10 kilowatts, and an efficiency of 80%, what is the total energy consumed over 30 days assuming 8 hours of operation per day?",
        "query": "SELECT (Power * 8 * 30) AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 120 AND Head = 60 AND Power = 12 AND Voltage = 220 AND Current = 50 AND Efficiency = 90;",
        "step": "【step1】:【Filter records in pump_specifications where Flow_Rate=120, Head=60, Power=12, Voltage=220, Current=50, and Efficiency=90】  【step2】:【Calculate Total_Energy_Consumed for the filtered records using (Power * 8 * 30)】",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1642,
        "question": "If a water pump operates for 8 hours every day within a year, with a flow rate of 1000 cubic meters per hour, a head of 1000 meters, a power of 1000 kilowatts, a voltage of 1000 volts, a current of 1000 amperes, and an efficiency of 100%, what is the total annual energy consumption of the pump?",
        "query": "SELECT Power * 1000 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Voltage = 1000 AND Current = 1000 AND Efficiency = 100;",
        "step": "【step1】: Identify WHERE clause filter mismatch: Flow_Rate=150, Head=60, Efficiency=85 should be used instead of 1000  【step2】: Fix calculation formula: (15kW * 8h/day * 365 days) * (100/85) for energy consumption with efficiency factor  【step3】: Join usage_records for actual runtime verification rather than assuming 8h/day operation",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "3",
        "idx": 1643,
        "question": "If a water pump has a warranty period of 24 months and the purchase date is January 1, 2022, when does the warranty period end? If the water pump fails on June 1, 2023, is it still within the warranty period?",
        "query": "SELECT (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Efficiency = 80;",
        "step": "【step1】: Filter records from pump_specifications table using WHERE clause with conditions: Flow_Rate = 100, Head = 50, Power = 10, and Efficiency = 80  【step2】: Calculate Actual_Output_Power using formula (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600 for the filtered records",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "4",
        "idx": 1644,
        "question": "If a water pump has a flow rate of 1000 cubic meters per second, a head of 1000 meters, and an efficiency of 100%, what is the actual output power of the pump? Assume water density is 1000 kg/m³ and gravitational acceleration is 9.81 m/s².",
        "query": "SELECT (15 * 8 * 365) / 0.85 AS total_energy_consumption FROM pump_specifications WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15 AND Efficiency = 85;",
        "step": "【step1】: Filter pump_specifications records matching Flow_Rate=150, Head=60, Power=15, Efficiency=85  【step2】: Calculate energy consumption formula (15*8*365)/0.85  【step3】: Return calculated value as total_energy_consumption column",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1645,
        "question": "What is the pump ID, model number, purchase date, warranty period, warranty end date, and warranty status on 2023-06-01 for water pumps purchased on 2022-01-01 with a 24-month warranty?",
        "query": "SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date, CASE WHEN '2023-06-01' <= DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;",
        "step": "【step1】: Filter the pumps table where Purchase_date is '2022-01-01' and Warranty_Period is 24 months.  【step2】: Calculate Warranty_End_Date using DATE_ADD to add Warranty_Period months to Purchase_date.  【step3】: Apply CASE to determine if '2023-06-01' falls within the warranty period, labeling 'Yes' or 'No' as Is_Under_Warranty.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "1",
        "idx": 1646,
        "question": "Calculate the actual output power of the pump with a flow rate of 1000, head of 1000, power of 1000, and efficiency of 100.",
        "query": "SELECT (Flow_Rate * Head * 1000 * 9.81) / 3600000 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Efficiency = 100;",
        "step": "【step1】: Join the `pumps` and `pump_specifications` tables to link each pump with its specifications.  【step2】: Calculate the kinetic energy for each pump using the formula `(Flow_Rate * Head * 1000 * 9.81) / 3600000` (assuming maximum speed corresponds to the given specifications).  【step3】: Order the results by the calculated kinetic energy in descending order and limit to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "waterPump",
        "type": "2",
        "idx": 1647,
        "question": "Calculate the ratio of average maintenance cost to average usage hours for each pump, and identify the top 10 pumps with the lowest ratios.",
        "query": "WITH MaintenanceCosts AS (SELECT AVG(Cost) AS AvgCost FROM maintenance_records), UsageHours AS (SELECT AVG(Usage_Hours) AS AvgHours FROM usage_records) SELECT AvgCost / AvgHours AS CostToUsageRatio FROM MaintenanceCosts, UsageHours;",
        "step": "【step1】: Calculate the average maintenance cost (AvgCost) from the maintenance_records table.  【step2】: Calculate the average usage hours (AvgHours) from the usage_records table.  【step3】: Cross-join the aggregated results from both CTEs and compute the CostToUsageRatio by dividing AvgCost by AvgHours.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1648,
        "question": "Find the yacht model with the most voyages under specific weather conditions (such as wind speed greater than 30 knots and wave height greater than 2 meters).",
        "query": "SELECT y.Model, COUNT(v.Voyage_ID) AS Voyage_Count FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID WHERE v.Wind_Speed > 30 AND v.Wave_Height > 2 GROUP BY y.Model ORDER BY Voyage_Count DESC LIMIT 1;",
        "step": "【step1】: Join 'voyages' and 'yachts' tables using Yacht_ID, filter records where Wind_Speed >30 and Wave_Height >2  【step2】: Group results by yacht Model and count voyages for each group  【step3】: Order groups by voyage count in descending order and select top result",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1649,
        "question": "Calculate the duration of continuous sailing at maximum speed, assuming 1 million liters of fuel, and identify which yachts have a sailing time exceeding 1000 hours.",
        "query": "SELECT y.Yacht_ID, y.Model, 1000000 / (p.Fuel_Efficiency * y.Max_Speed) AS Sailing_Time FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID WHERE 1000000 / (p.Fuel_Efficiency * y.Max_Speed) > 1000;",
        "step": "【step1】:【Join the 'yachts' table with 'performance_metrics' on Yacht_ID to link each yacht's specifications with its performance data.】  【step2】:【Calculate sailing time by dividing 1,000,000 liters by the product of fuel efficiency (liters/hour) and max speed (knots).】  【step3】:【Filter results where the calculated sailing time exceeds 1000 hours using the derived value in the WHERE clause.】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1650,
        "question": "Calculate the ratio of buoyancy to gravity for each yacht, and identify the top 5 yachts with a ratio greater than 1.",
        "query": "SELECT Yacht_ID, Model, (Displacement * 9.81) / (Weight * 9.81) AS Buoyancy_Gravity_Ratio FROM yachts WHERE (Displacement * 9.81) / (Weight * 9.81) > 1 ORDER BY Buoyancy_Gravity_Ratio DESC LIMIT 5;",
        "step": "【step1】: Calculate buoyancy-to-gravity ratio for all yachts using (Displacement*9.81)/(Weight*9.81) formula and select required columns.  【step2】: Filter records where the calculated ratio exceeds 1 using WHERE clause.  【step3】: Sort results in descending order by the ratio and limit output to top 5 entries using ORDER BY and LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1651,
        "question": "Calculate the product of fuel consumption and sailing distance for each yacht, sort in descending order, and identify the top 10 yachts with the largest products.",
        "query": "SELECT v.Yacht_ID, y.Model, v.Fuel_Consumed * v.Distance AS Fuel_Distance_Product FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID ORDER BY Fuel_Distance_Product DESC LIMIT 10;",
        "step": "【step1】: Join the 'voyages' and 'yachts' tables using Yacht_ID to associate voyage data with yacht models.  【step2】: Calculate the fuel-distance product via \"Fuel_Consumed * Distance\" and sort results in descending order.  【step3】: Limit the output to the top 10 records with the highest fuel-distance product.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1652,
        "question": "Find all yachts produced after 2015 with diesel engine type, sorted in descending order by price.",
        "query": "SELECT Yacht_ID, Model, Year, Engine_Type, Price FROM yachts WHERE Year > 2015 AND Engine_Type = '柴油' ORDER BY Price DESC;",
        "step": "【step1】: Select the Yacht_ID, Model, Year, Engine_Type, and Price columns from the yachts table.  【step2】: Apply filters to retain only records where Year is greater than 2015 and Engine_Type is '柴油'.  【step3】: Sort the filtered results in descending order by Price.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1653,
        "question": "The fuel capacity of a yacht has been increased to 5 million liters. Calculate the continuous sailing distance at maximum speed (using fuel efficiency) and identify which yachts have a sailing distance exceeding 10,000 nautical miles.",
        "query": "SELECT Yacht_ID, Model, (5000000 / Fuel_Efficiency) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Efficiency) > 10000;",
        "step": "【step1】:【Calculate the maximum continuous sailing distance for each yacht by dividing the increased fuel capacity (5,000,000 liters) by its fuel efficiency】  【step2】:【Filter yachts where the calculated distance exceeds 10,000 nautical miles using the WHERE clause】  【step3】:【Output the Yacht_ID, Model, and computed Max_Distance for qualifying yachts】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1654,
        "question": "Calculate the kinetic energy of each yacht at its maximum speed and identify the top 5 yachts with the highest kinetic energy.",
        "query": "SELECT Yacht_ID, Model, 0.5 * (Weight * 1000) * POWER(Max_Speed * 0.514444, 2) AS Kinetic_Energy FROM yachts ORDER BY Kinetic_Energy DESC LIMIT 5;",
        "step": "【step1】: Calculate kinetic energy for each yacht using formula 0.5 * (weight converted to kg) * (max_speed converted to m/s)^2  【step2】: Sort results by calculated kinetic energy in descending order  【step3】: Limit output to top 5 records with highest kinetic energy",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1655,
        "question": "Identify the 10 yachts with the smallest maximum sailing distance (calculated as 5,000,000 divided by fuel capacity), sort them in ascending order of this distance, and show their yacht ID and model.",
        "query": "SELECT Yacht_ID, Model, (5000000 / Fuel_Capacity) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Capacity) > 10000;",
        "step": "【step1】: Calculate fuel efficiency ratio for each yacht (Fuel_Consumed/Distance) from voyages table grouped by Yacht_ID.  【step2】: Join with yachts table to get model information.  【step3】: Order results by the ratio in ascending order and limit to 10 smallest values.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1656,
        "question": "Find all yachts produced before 2010 with fiberglass hull material, sorted by production year in ascending order.",
        "query": "SELECT Yacht_ID, Model, Year, Hull_Material FROM yachts WHERE Year < 2010 AND Hull_Material = '玻璃钢' ORDER BY Year ASC;",
        "step": "【step1】: Filter records from 'yachts' table where Year is less than 2010  【step2】: Further refine results by selecting only rows where Hull_Material equals '玻璃钢'  【step3】: Sort the filtered dataset by Year in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1657,
        "question": "Calculate the continuous sailing time at maximum speed, assuming a fuel capacity of 1 million liters, and find which yachts have a sailing time exceeding 1000 hours.",
        "query": "SELECT Yacht_ID,  (1000000 / (Fuel_Efficiency / `Range`)) AS Sailing_Time_Hours FROM performance_metrics WHERE (1000000 / (Fuel_Efficiency / `Range`)) > 1000 ORDER BY Sailing_Time_Hours DESC;",
        "step": "【step1】: Calculate sailing time for each yacht using the formula (1000000 / (Fuel_Efficiency / `Range`)) as Sailing_Time_Hours by accessing fuel efficiency and range data from the performance_metrics table.  【step2】: Filter results to retain only rows where the calculated Sailing_Time_Hours exceeds 1000 hours using the WHERE clause.  【step3】: Sort the final output in descending order of Sailing_Time_Hours using ORDER BY to prioritize yachts with the longest continuous sailing duration.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1658,
        "question": "Calculate the drag power of each yacht at maximum speed and identify the top 5 yachts with the highest drag power.",
        "query": "SELECT Yacht_ID, Model, 0.5 * 1025 * Drag_Coefficient * (Length * Width) * POWER(Max_Speed * 0.514444, 3) AS Drag_Power FROM yachts ORDER BY Drag_Power DESC LIMIT 5;",
        "step": "【step1】: Calculate drag power using the formula \"0.5 * 1025 * Drag_Coefficient * (Length*Width) * (Max_Speed*0.514444)^3\" for each yacht  【step2】: Sort results by Drag_Power in descending order  【step3】: Return top 5 entries using LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1659,
        "question": "Calculate the ratio of total energy consumption to sailing distance for each yacht with a distance greater than 0, and sort them in descending order to find the top 10 yachts with the highest ratios.",
        "query": "SELECT Yacht_ID, (1000000 / Fuel_Efficiency) AS Max_Sailing_Time FROM performance_metrics WHERE (1000000 / Fuel_Efficiency) > 1000;",
        "step": "【step1】: Calculate total energy consumed and sailing distance per yacht by aggregating data from the voyages table using SUM(Total_Energy_Consumed) and SUM(Distance) with GROUP BY Yacht_ID.  【step2】: Compute the energy-distance ratio by dividing total energy consumed by sailing distance (SUM(Total_Energy_Consumed)/SUM(Distance)) as Energy_Distance_Ratio.  【step3】: Order results by Energy_Distance_Ratio DESC and limit to top 10 records using LIMIT 10.  *Note: The original query uses incorrect table (performance_metrics) and formula (1000000/Fuel_Efficiency). The correct logic requires aggregating voyage-level energy/distance data.*",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1660,
        "question": "Find all yachts produced after 2015 with diesel engine type, sorted by fuel efficiency in ascending order.",
        "query": "SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Efficiency FROM yachts WHERE Year > 2015 AND Engine_Type = '柴油' ORDER BY Fuel_Efficiency ASC;",
        "step": "【step1】: Select required columns (Yacht_ID, Model, Year, Engine_Type, Fuel_Efficiency) from the yachts table  【step2】: Apply filters for Year > 2015 and Engine_Type = '柴油'  【step3】: Sort the results by Fuel_Efficiency in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1661,
        "question": "If a yacht's fuel capacity is increased to 10 million liters, calculate the distance it can travel continuously at maximum speed, and identify which yachts have a travel distance exceeding 50,000 nautical miles.",
        "query": "SELECT Yacht_ID, Model, (10000000 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000 / Fuel_Efficiency) > 50000;",
        "step": "【step1】: Calculate the maximum continuous sailing distance for each yacht using the formula (10,000,000 / Fuel_Efficiency) from the performance_metrics table.  【step2】: Join the result with the yachts table via Yacht_ID to retrieve the Model information.  【step3】: Filter and return only yachts where the calculated Max_Distance exceeds 50,000 nautical miles.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1662,
        "question": "If a yacht was built after 2015 and has a diesel engine, and is ordered by fuel capacity from smallest to largest, calculate the yacht's draft in the water.",
        "query": "SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Capacity FROM yachts WHERE Year > 2015 AND Engine_Type = '柴油' ORDER BY Fuel_Capacity ASC;",
        "step": "【step1】: Filter yachts produced after 2015 with diesel engines using WHERE Year > 2015 AND Engine_Type = '柴油'  【step2】: Select required columns (Yacht_ID, Model, Year, Engine_Type, Fuel_Capacity) from the filtered dataset  【step3】: Sort results by Fuel_Capacity in ascending order using ORDER BY Fuel_Capacity ASC",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1663,
        "question": "A yacht has a maximum speed of 30 knots, an engine power of 1000 horsepower, and a fuel efficiency of 50 liters/hour. If the yacht sails at maximum speed, how far can it travel on 10,000,000 liters of fuel?",
        "query": "SELECT Yacht_ID, (10000000 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000 / Fuel_Efficiency) > 50000;",
        "step": "【step1】: Calculate the maximum theoretical distance (Max_Distance) each yacht can travel by dividing 10,000,000 by its fuel efficiency (Fuel_Efficiency) from performance_metrics table.  【step2】: Filter and return only those yachts (Yacht_ID) where the calculated maximum distance exceeds 50,000 units.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1664,
        "question": "A yacht has a fuel capacity of 5000 liters and a fuel consumption rate of 50 liters per nautical mile. If this yacht needs to sail for 1000 nautical miles, determine whether its fuel supply is sufficient.",
        "query": "SELECT Fuel_Capacity, (1000 / Fuel_Efficiency) AS Required_Fuel FROM yachts WHERE Yacht_ID = '特定游艇ID';",
        "step": "【step1】: Retrieve the yacht's Fuel_Capacity and Fuel_Efficiency values from the 'yachts' table using the specified Yacht_ID  【step2】: Calculate required fuel by dividing the voyage distance (1000 nautical miles) by Fuel_Efficiency to get consumption  【step3】: Compare Fuel_Capacity with Required_Fuel to determine sufficiency (though this comparison isn't explicitly in the SQL output)",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1665,
        "question": "Calculate the ratio of fuel efficiency to range for each yacht and identify the top 5 yachts with the highest efficiency ratio.",
        "query": "SELECT Yacht_ID, Model, (Fuel_Efficiency / `Range`) AS Efficiency_Ratio FROM performance_metrics ORDER BY Efficiency_Ratio DESC LIMIT 5;",
        "step": "【step1】: Retrieve Yacht_ID, Model, and calculate the Efficiency_Ratio (Fuel_Efficiency / Range) from the performance_metrics table.  【step2】: Order the results by Efficiency_Ratio in descending order.  【step3】: Limit the output to the top 5 records with the highest Efficiency_Ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1666,
        "question": "Retrieve the model, production year, length, maximum speed, and price of all yachts with a length exceeding 30 meters and a maximum speed over 20 knots, sorted by price in descending order.",
        "query": "SELECT Model, Year, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 20 ORDER BY Price DESC;",
        "step": "【step1】: Select required columns (Model, Year, Length, Max_Speed, Price) from yachts table  【step2】: Apply filtration conditions (Length > 30 meters AND Max_Speed > 20 knots)  【step3】: Sort results by Price in descending order using ORDER BY clause",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1667,
        "question": "Calculate the fuel consumption rate (liters per nautical mile) for each yacht and list the top 10 yachts with the lowest fuel consumption rate, sorted from lowest to highest.",
        "query": "SELECT y.Yacht_ID, y.Model, p.Fuel_Efficiency / y.Max_Speed AS Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID ORDER BY Fuel_Consumption_Rate ASC LIMIT 10;",
        "step": "【step1】: JOIN yachts and performance_metrics tables using Yacht_ID to associate fuel efficiency data with each yacht  【step2】: Calculate Fuel_Consumption_Rate by dividing Fuel_Efficiency (liters/hour) by Max_Speed (knots = nautical miles/hour) to get liters/nautical mile  【step3】: Sort results by Fuel_Consumption_Rate ascending and limit to top 10 most fuel-efficient yachts",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1668,
        "question": "Calculate the maximum cruising range (in nautical miles) for each yacht based on its fuel capacity, fuel efficiency, and maximum speed, and list the top 3 yachts with the longest cruising range.",
        "query": "SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity / p.Fuel_Efficiency * y.Max_Speed AS Max_Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID ORDER BY Max_Range DESC LIMIT 3;",
        "step": "【step1】:【JOIN yachts and performance_metrics tables using Yacht_ID to combine fuel-related data】  【step2】:【Calculate Max_Range using formula (Fuel_Capacity / Fuel_Efficiency) * Max_Speed for each yacht】  【step3】:【Sort results by Max_Range in descending order and limit to top 3 entries】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1669,
        "question": "A yacht has a displacement of 100,000 tons, a hull length of 500 meters, and a width of 50 meters. Calculate its draft depth using the formula draft = displacement / (length * width) and determine whether the yacht can float normally. If the draft depth exceeds 50 meters, what will happen?",
        "query": "SELECT 100000 / (500 * 50 * 1) AS Draft, CASE WHEN 100000 / (500 * 50 * 1) > 50 THEN '无法正常浮起' ELSE '可以正常浮起' END AS Status;",
        "step": "【step1】: Calculate draft depth using displacement divided by (length * width * water density). Formula: 100000 / (500 * 50 * 1)  【step2】: Apply conditional logic with CASE expression to determine buoyancy status based on draft threshold (50 meters).  【step3】: No third step required as this calculation doesn't involve table joins/nested queries.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1670,
        "question": "Based on the displacement, length, and width of the yachts, calculate the draft depth of each yacht, group them by hull material, and list the average draft depth for each hull material type.",
        "query": "SELECT Hull_Material, AVG(Displacement / (Length * Width * 1)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;",
        "step": "【step1】: Calculate individual draft depth for each yacht using the formula Displacement/(Length*Width)  【step2】: Group results by Hull_Material and compute the average draft using AVG() aggregation  【step3】: Select and display material groups with their corresponding average draft values",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1671,
        "question": "Calculate the average fuel consumption rate (fuel efficiency divided by max speed) for each engine type.",
        "query": "SELECT y.Engine_Type, AVG(p.Fuel_Efficiency / y.Max_Speed) AS Avg_Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY y.Engine_Type;",
        "step": "【step1】: Join 'yachts' and 'performance_metrics' tables on Yacht_ID to associate engine types with fuel efficiency and max speed data.  【step2】: Compute individual fuel consumption rates (Fuel_Efficiency / Max_Speed) for each yacht.  【step3】: Group results by Engine_Type and calculate the average fuel consumption rate per group.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1672,
        "question": "Based on the yacht's fuel capacity, fuel efficiency, and maximum speed, calculate the average maximum range (nautical miles) for yachts produced by each manufacturer.",
        "query": "SELECT Manufacturer_ID, AVG(Fuel_Capacity / Fuel_Efficiency * Max_Speed) AS Avg_Max_Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY Manufacturer_ID;",
        "step": "【step1】:【Join the 'yachts' and 'performance_metrics' tables on Yacht_ID to combine fuel capacity, fuel efficiency, and max speed data】  【step2】:【Calculate the maximum range for each yacht using the formula: Fuel_Capacity / Fuel_Efficiency * Max_Speed】  【step3】:【Group results by Manufacturer_ID and compute the average maximum range using AVG()】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1673,
        "question": "A yacht has a displacement of 1,000,000 tons, a hull length of 1,000 meters, and a width of 100 meters. Calculate its draft depth, group it by hull material, and list the average draft depth for each hull material.",
        "query": "SELECT Hull_Material, AVG(1000000 / (1000 * 100 * 1)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;",
        "step": "【step1】: Calculate individual draft depth using the formula (Displacement / (Length * Width * 1)) for each yacht.  【step2】: Group records by Hull_Material and compute the average draft depth per group using AVG().  【step3】: Return results with a hardcoded calculation (all entries use fixed values 1000000/1000/100/1=10m), making Avg_Draft constant across groups. Conditional logic about drafts exceeding 100m is not implemented in SQL.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1674,
        "question": "Based on the sailing distance and fuel consumption in the sailing records table, calculate the fuel efficiency (fuel consumed divided by distance) for each voyage, and list the 5 voyages with the lowest fuel efficiency.",
        "query": "SELECT Voyage_ID, Yacht_ID, Fuel_Consumed / Distance AS Fuel_Efficiency FROM voyages ORDER BY Fuel_Efficiency DESC LIMIT 5;",
        "step": "【step1】: Calculate fuel efficiency for each voyage by dividing Fuel_Consumed by Distance, aliased as Fuel_Efficiency.  【step2】: Order the results in descending order of Fuel_Efficiency to prioritize the highest (least efficient) values.  【step3】: Restrict output to the top 5 records using LIMIT, which corresponds to the 5 worst efficiency values.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1675,
        "question": "Calculate the average fuel efficiency (fuel consumed divided by distance) for each yacht, grouped by yacht ID.",
        "query": "SELECT Yacht_ID, SUM(Fuel_Consumed) / SUM(Distance) AS Avg_Fuel_Efficiency FROM voyages GROUP BY Yacht_ID;",
        "step": "【step1】: Retrieve all voyage records containing Yacht_ID, Fuel_Consumed, and Distance from the voyages table.  【step2】: Group the records by Yacht_ID and compute the aggregate sums of Fuel_Consumed and Distance for each group.  【step3】: Calculate the average fuel efficiency (SUM(Fuel_Consumed)/SUM(Distance)) for each Yacht_ID and output the results.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1676,
        "question": "Based on the crew roles in the crew table and the sailing distances in the voyage records table, calculate the average sailing distance for each crew role and list the crew role with the longest average sailing distance.",
        "query": "SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;",
        "step": "【step1】: Join crew table with voyages table using Yacht_ID to associate crew roles with voyage distances  【step2】: Group joined data by Role and calculate average distance for each role using AVG(v.Distance)  【step3】: Sort results by Avg_Distance descending and select top result using ORDER BY and LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1677,
        "question": "A yacht consumed 1,000,000 liters of fuel during a voyage, sailing 1,000,000 nautical miles. Calculate its fuel efficiency (liters/nautical mile) and determine whether this fuel efficiency is reasonable. What would happen if the fuel efficiency were below 0.01 liters/nautical mile?",
        "query": "SELECT 1000000 / 1000000 AS Fuel_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN '异常数据' ELSE '合理数据' END AS Status;",
        "step": "【step1】: Calculate fuel efficiency by dividing fuel consumed (1,000,000 liters) by distance traveled (1,000,000 nautical miles) using arithmetic operation 1000000 / 1000000.  【step2】: Compare result with threshold 0.01 using CASE expression to determine data validity.  【step3】: Return calculated Fuel_Efficiency (1.0) and Status ('合理数据') since the value exceeds the 0.01L/NM threshold.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1678,
        "question": "Based on the displacement and buoyancy force of the yachts, calculate the ratio of buoyancy to displacement for each yacht and list the top 5 yachts with the highest ratios.",
        "query": "SELECT Yacht_ID, Buoyancy_Force / Displacement AS Buoyancy_Ratio FROM yachts ORDER BY Buoyancy_Ratio DESC LIMIT 5;",
        "step": "【step1】: Calculate the buoyancy ratio for each yacht by dividing Buoyancy_Force by Displacement  【step2】: Sort all yachts in descending order based on the calculated buoyancy ratio  【step3】: Return only the top 5 yachts with the highest buoyancy ratios using LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1679,
        "question": "Calculate the ratio of total energy consumption to total sailing distance for each yacht, grouped by yacht ID, and list the average energy efficiency (joules per nautical mile) for each yacht.",
        "query": "SELECT Yacht_ID, SUM(Total_Energy_Consumed) / SUM(Distance) AS Avg_Energy_Efficiency FROM voyages GROUP BY Yacht_ID;",
        "step": "【step1】: Retrieve all voyage records containing Yacht_ID, Total_Energy_Consumed, and Distance from the voyages table.  【step2】: Group records by Yacht_ID and calculate aggregate sums for Total_Energy_Consumed and Distance using SUM().  【step3】: Compute the energy efficiency ratio (total energy divided by total distance) and output Yacht_ID with Avg_Energy_Efficiency.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1680,
        "question": "Based on the crew roles in the crew table and the weather conditions in the voyage records table, calculate the average sailing distance for each crew role during severe weather conditions (such as strong winds and heavy waves), and list the crew role with the longest average sailing distance.",
        "query": "SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID WHERE v.Weather_Conditions IN ('大风', '大浪') GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;",
        "step": "【step1】: Join 'crew' and 'voyages' tables using Yacht_ID, filter records with恶劣天气 conditions ('大风' or '大浪')  【step2】: Group by crew roles and calculate average voyage distance for each role using AVG(v.Distance)  【step3】: Sort results by Avg_Distance in descending order and select the top record with LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1681,
        "question": "A yacht consumes 1,000,000 joules of energy during a voyage, sailing for 1,000,000 nautical miles. Calculate its energy efficiency (joules/nautical mile) and determine whether this energy efficiency is reasonable. If the energy efficiency is below 0.01 joules/nautical mile, it should be labeled as 'Abnormal Data'; otherwise, it should be labeled as 'Reasonable Data'.",
        "query": "SELECT 1000000 / 1000000 AS Energy_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN '异常数据' ELSE '合理数据' END AS Status;",
        "step": "【step1】:【Calculate energy efficiency by dividing total energy consumed (1,000,000 joules) by sailing distance (1,000,000 nautical miles)】  【step2】:【Apply CASE statement to flag \"異常データ\" when the result is below 0.01 J/nm, otherwise return \"合理データ\"】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1682,
        "question": "Based on the sailing distance and fuel consumption recorded in the voyage log, calculate the average fuel efficiency (fuel consumed per distance) per charter type, and list the average fuel efficiency for each charter type.",
        "query": "SELECT c.Charter_Type, AVG(v.Fuel_Consumed / v.Distance) AS Avg_Fuel_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY c.Charter_Type;",
        "step": "【step1】: Join the `voyages` and `charters` tables using `Yacht_ID` to link each voyage record with its corresponding charter type.  【step2】: Calculate the fuel efficiency for each voyage by dividing `Fuel_Consumed` by `Distance` for every row.  【step3】: Group the results by `Charter_Type` and compute the average fuel efficiency for each group using the `AVG()` function.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1683,
        "question": "Calculate the ratio of total charter cost to total voyage distance for each yacht, grouped by yacht ID, and list the average charter cost efficiency (USD/nautical mile) for each yacht.",
        "query": "SELECT v.Yacht_ID, SUM(c.Total_Cost) / SUM(v.Distance) AS Avg_Charter_Cost_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY v.Yacht_ID;",
        "step": "【step1】: Join the voyages and charters tables on Yacht_ID to combine voyage distance and charter cost data.  【step2】: Group the joined records by Yacht_ID to aggregate total cost and total distance per yacht.  【step3】: Compute the average efficiency by dividing total cost by total distance for each Yacht_ID group.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1684,
        "question": "Based on the charter type in the charters table and the distance in the voyages table, calculate the average distance for each charter type and list the charter type with the longest average distance.",
        "query": "SELECT c.Charter_Type, AVG(v.Distance) AS Avg_Distance FROM charters c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Charter_Type ORDER BY Avg_Distance DESC LIMIT 1;",
        "step": "【step1】: Join 'charters' and 'voyages' tables using Yacht_ID to associate charter types with voyage distances  【step2】: Group by Charter_Type and calculate average distance for each type  【step3】: Order results by Avg_Distance in descending order and select the top result with LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1685,
        "question": "A yacht paid $1,000,000 in one lease and sailed 1,000,000 nautical miles. Calculate its leasing cost efficiency ($/nautical mile) and determine whether this leasing cost efficiency is reasonable. What would happen if the leasing cost efficiency falls below $0.01/nautical mile?",
        "query": "SELECT 1000000 / 1000000 AS Charter_Cost_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN '异常数据' ELSE '合理数据' END AS Status;",
        "step": "【step1】: Calculate charter cost efficiency by dividing total cost (1000000) by sailing distance (1000000)  【step2】: Apply CASE statement to categorize data as '异常数据' when efficiency < 0.01 USD/nm else '合理数据'  【step3】: (Not required - query uses hardcoded values instead of table joins)",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1686,
        "question": "Based on the crew's salary and work experience, calculate the ratio of the average salary to the average work experience for each yacht, grouped by yacht ID, and list the crew salary efficiency (USD/year) for each yacht.",
        "query": "SELECT Yacht_ID, AVG(Salary) / AVG(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;",
        "step": "【step1】:【GROUP the crew data by Yacht_ID using GROUP BY clause.】  【step2】:【CALCULATE the average Salary and average Experience_Years for each Yacht_ID using AVG() function.】  【step3】:【DIVIDE the average Salary by average Experience_Years to compute Salary_Efficiency (USD/year) for each group.】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1687,
        "question": "Calculate the ratio of total crew salary to total work experience for each yacht, grouped by yacht ID, and list the crew salary efficiency (USD/year) for each yacht.",
        "query": "SELECT Yacht_ID, SUM(Salary) / SUM(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;",
        "step": "【step1】: Select Yacht_ID and apply SUM aggregation on Salary and Experience_Years  【step2】: Group records by Yacht_ID  【step3】: Compute Salary_Efficiency by dividing total salary sum by total experience sum for each group",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1688,
        "question": "Based on the crew roles and salaries in the crew table, calculate the average salary for each crew role and list the crew role with the highest average salary.",
        "query": "SELECT Role, AVG(Salary) AS Avg_Salary FROM crew GROUP BY Role ORDER BY Avg_Salary DESC LIMIT 1;",
        "step": "【step1】: Calculate average salary per crew role using GROUP BY and AVG aggregation.  【step2】: Sort results by Avg_Salary in descending order.  【step3】: Retrieve top record with highest average salary using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1689,
        "question": "A crew member's salary is $1,000,000 per year with 100 years of work experience. Calculate their salary efficiency ($/year) and determine whether this salary efficiency is reasonable. If the salary efficiency is below $1,000/year, what would happen?",
        "query": "SELECT 1000000 * 12 / 100 AS Salary_Efficiency, CASE WHEN 1000000 * 12 / 100 < 1000 THEN '异常数据' ELSE '合理数据' END AS Status;",
        "step": "【step1】: Calculate monthly salary multiplied by 12 to get annual salary, then divide by experience years (1000000*12/100) to derive Salary_Efficiency  【step2】: Apply CASE conditional logic to compare Salary_Efficiency with 1000 threshold and assign '异常数据' or '合理数据' status  【step3】: Not required (simple calculation without table joins/nested queries)",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1690,
        "question": "Calculate the kinetic energy (in joules) of each yacht based on its weight and maximum speed, and list the kinetic energy for each yacht.",
        "query": "SELECT Yacht_ID, 0.5 * Weight * 1000 * POWER(Max_Speed * 0.5144, 2) AS Kinetic_Energy FROM yachts;",
        "step": "【step1】: Retrieve Yacht_ID, Weight (in tons), and Max_Speed (in knots) from the 'yachts' table.  【step2】: Convert units: multiply Weight by 1000 to convert tons to kilograms and multiply Max_Speed by 0.5144 to convert knots to meters per second.  【step3】: Apply the kinetic energy formula (0.5 * mass * velocity²) and group results by Yacht_ID to display calculated values.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1691,
        "question": "Calculate the ratio of the total crew salary to the yacht price for each yacht, grouped by yacht ID, and list the crew salary percentage for each yacht.",
        "query": "SELECT c.Yacht_ID, (SUM(c.Salary) / y.Price) * 100 AS Crew_Salary_Ratio FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Yacht_ID;",
        "step": "【step1】: Join the 'crew' and 'yachts' tables using Yacht_ID to associate crew salaries with corresponding yacht prices.  【step2】: Group the results by Yacht_ID and calculate the total salary sum for each group using SUM(c.Salary).  【step3】: Compute the crew salary ratio as a percentage by dividing the total salary by the yacht's price and multiplying by 100, aliased as Crew_Salary_Ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1692,
        "question": "Based on the crew roles in the crew table and the passenger capacity in the yacht table, calculate the average number of passengers per crew role, and list the crew role with the highest average number of passengers.",
        "query": "SELECT c.Role, AVG(y.Passenger_Capacity) AS Avg_Passenger_Per_Role FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Role ORDER BY Avg_Passenger_Per_Role DESC LIMIT 1;",
        "step": "【step1】: Join 'crew' and 'yachts' tables using Yacht_ID to associate crew roles with respective yacht passenger capacities  【step2】: Group by crew role and calculate average passenger capacity using AVG(y.Passenger_Capacity)  【step3】: Sort results by average passenger capacity in descending order and select the top result using LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1693,
        "question": "A yacht weighs 1,000,000 tons and has a maximum speed of 1,000 knots. Calculate its kinetic energy (in joules) and determine whether this kinetic energy is reasonable. If the kinetic energy exceeds 10^12 joules, it should be flagged as \"Abnormal Data\"; otherwise, it should be considered \"Reasonable Data\".",
        "query": "SELECT 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) AS Kinetic_Energy, CASE WHEN 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) > 1e12 THEN '异常数据' ELSE '合理数据' END AS Status;",
        "step": "【step1】: Extract weight (1,000,000 tons) and maximum speed (1000 knots) from hardcoded values instead of database tables since no table contains both parameters  【step2】: Calculate kinetic energy using formula 0.5*mass*velocity², converting tons to kg (×1000) and knots to m/s (×0.5144)  【step3】: Implement CASE conditional logic to compare calculated energy against 1e12 threshold and return status label",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1694,
        "question": "What is the draft depth of a yacht with a displacement of 500 tons and a buoyancy force of 4,905,000 Newtons, given water density is 1,000 kg/m³ and gravitational acceleration is 9.81 m/s²?",
        "query": "SELECT Displacement, Buoyancy_Force FROM yachts WHERE Yacht_ID = ?;",
        "step": "【step1】: Retrieve the yacht's Displacement (500 tons) and Buoyancy_Force (4,905,000 N) from the `yachts` table using `Yacht_ID`.  【step2】: Calculate draft depth using physics:  Draft = Buoyancy_Force / (Water_Density * g * (Length * Width))  Given water density=1000 kg/m³, g=9.81 m/s², but Length/Width must be retrieved from `yachts` table.  【step3】: Store/update calculated draft in `performance_metrics.Draft` for historical tracking.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1695,
        "question": "A yacht has a maximum speed of 30 knots, an engine power of 2000 horsepower, and a fuel efficiency of 50 liters per hour. If the yacht sails continuously at maximum speed for 24 hours, calculate its total fuel consumption and total energy consumption. Given: 1 horsepower = 745.7 watts, and the energy content of 1 liter of fuel is 34.2 megajoules.",
        "query": "SELECT Max_Speed, Engine_Power, Fuel_Efficiency FROM yachts WHERE Yacht_ID = ?;",
        "step": "【step1】: Retrieve Yacht's performance parameters (Max_Speed=30kt, Engine_Power=2000HP, Fuel_Efficiency=50L/h) from yachts table  【step2】: Calculate total fuel consumption: 50 L/h × 24h = 1200 liters  【step3】: Calculate energy consumption: 1200L × 34.2MJ/L = 41040MJ (4.104×10^10 joules) via fuel energy content",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1696,
        "question": "Query all yacht models with hull material as \"carbon fiber\" and passenger capacity exceeding 10 people, including the model name, production year, hull material, passenger capacity, and price, sorted by production year in ascending order.",
        "query": "SELECT Model, Year, Hull_Material, Passenger_Capacity, Price FROM yachts WHERE Hull_Material = '碳纤维' AND Passenger_Capacity > 10 ORDER BY Year ASC;",
        "step": "【step1】: Filter rows from 'yachts' where Hull_Material is '碳纤维' and Passenger_Capacity exceeds 10  【step2】: Select specified columns (Model, Year, Hull_Material, Passenger_Capacity, Price)  【step3】: Sort results by Year in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1697,
        "question": "Query all yacht models with engine power exceeding 500 horsepower and fuel capacity exceeding 5000 liters, including their engine type, engine power, fuel capacity, and maximum speed, sorted in descending order by maximum speed.",
        "query": "SELECT Model, Engine_Type, Engine_Power, Fuel_Capacity, Max_Speed FROM yachts WHERE Engine_Power > 500 AND Fuel_Capacity > 5000 ORDER BY Max_Speed DESC;",
        "step": "【step1】: Select the columns Model, Engine_Type, Engine_Power, Fuel_Capacity, and Max_Speed from the yachts table.  【step2】: Apply filters to retain rows where Engine_Power exceeds 500 horsepower and Fuel_Capacity exceeds 5000 liters.  【step3】: Sort the filtered results by Max_Speed in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1698,
        "question": "The query returns yacht models, production years, prices, and hull materials by filtering for yachts produced in 2018 or later with prices under 1 million US dollars, sorted in ascending order by price.",
        "query": "SELECT Model, Year, Price, Hull_Material FROM yachts WHERE Year >= 2018 AND Price < 1000000 ORDER BY Price ASC;",
        "step": "【step1】: [Select columns] Extract Model, Year, Price, and Hull_Material from the yachts table  【step2】: [Apply filters] Filter records where Year is 2018+ AND Price under $1M using WHERE Year >= 2018 AND Price < 1000000  【step3】: [Order results] Sort the filtered results by ascending price using ORDER BY Price ASC",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1699,
        "question": "Calculate the fuel consumption rate of each yacht and identify the top 3 yachts with the lowest fuel consumption rates.",
        "query": "SELECT Yacht_ID, (Fuel_Efficiency / `Range`) AS Fuel_Consumption_Rate FROM performance_metrics ORDER BY Fuel_Consumption_Rate ASC LIMIT 3;",
        "step": "【step1】: Retrieve Yacht_ID and calculate Fuel_Consumption_Rate by dividing Fuel_Efficiency by Range from the performance_metrics table.  【step2】: Order the results by Fuel_Consumption_Rate in ascending order to prioritize lower consumption.  【step3】: Apply LIMIT 3 to select the top 3 yachts with the lowest fuel consumption rates.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1700,
        "question": "Calculate the top 5 yachts with the highest fuel consumption per unit of range, ordered by this consumption metric in descending order.",
        "query": "SELECT Yacht_ID, (Fuel_Efficiency / `Range`) * 100 AS Total_Fuel_Consumption FROM performance_metrics ORDER BY Total_Fuel_Consumption DESC LIMIT 5;",
        "step": "【step1】: Extract Yacht_ID and calculate Total_Fuel_Consumption using the formula (Fuel_Efficiency / `Range`) * 100 for each yacht.  【step2】: Order the results by Total_Fuel_Consumption in descending order.  【step3】: Limit the output to the top 5 entries with the highest Total_Fuel_Consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1701,
        "question": "Calculate the fuel consumption per kilometer for each yacht, and identify the top 3 yachts with the lowest fuel consumption per kilometer.",
        "query": "SELECT Yacht_ID,  (Fuel_Efficiency / `Range`) AS Fuel_Consumption_per_Kilometer FROM performance_metrics ORDER BY Fuel_Consumption_per_Kilometer ASC LIMIT 3;",
        "step": "【step1】: Retrieve Yacht_ID and compute fuel consumption per kilometer by dividing Fuel_Efficiency by Range from performance_metrics  【step2】: Order the results in ascending order based on the calculated Fuel_Consumption_per_Kilometer  【step3】: Limit the output to the top 3 records with the lowest fuel consumption values",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1702,
        "question": "A yacht has a maximum speed of 30 knots, an engine power of 1,200 horsepower, a drag coefficient of 0.8, a hull length of 25 meters, and a beam of 6 meters. Calculate the kinetic energy of the yacht at its maximum speed.",
        "query": "SELECT Passenger_Capacity, Water_Capacity FROM yachts WHERE Yacht_ID = 1;",
        "step": "【step1】: Retrieve the specific yacht record by filtering on Yacht_ID = 1 through WHERE clause  【step2】: Extract the values of Passenger_Capacity and Water_Capacity columns from the selected row",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1703,
        "question": "The yacht has a fuel efficiency of 50 liters per hour and a fuel capacity of 5,000 liters, with a designed cruising range of 1,000 nautical miles. If the yacht sails at an average speed of 20 knots, determine whether its actual cruising range meets the designed cruising range.",
        "query": "SELECT Engine_Power, Fuel_Efficiency, Fuel_Capacity FROM yachts WHERE Yacht_ID = 2;",
        "step": "【step1】: Retrieve fuel capacity (5000 liters) from the yachts table for Yacht_ID=2.  【step2】: Fetch fuel efficiency (50 liters/hour) from performance_metrics table for the same yacht.  【step3】: Calculate actual range: (Fuel_Capacity / Fuel_Efficiency) * Average_Speed = (5000/50)*20 = 2000 nautical miles. Compare with design range (1000 nautical miles). Result: 2000 > 1000 ✔️",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1704,
        "question": "What is the kinetic energy of the yacht with ID 1, calculated using its displacement and maximum speed?",
        "query": "SELECT 0.5 * (Displacement * 1000) * POWER((Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts WHERE Yacht_ID = 1;",
        "step": "【step1】: Retrieve the Yacht_ID=1 record from yachts table  【step2】: Calculate displaced water mass in kg (Displacement*1000) and convert speed to m/s (Max_Speed*0.5144)  【step3】: Compute kinetic energy using formula 0.5 * mass * velocity²",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1705,
        "question": "A yacht has a fuel capacity of 100,000 liters and a fuel consumption rate of 1000 liters per hour at a speed of 50 knots. If it sails continuously at this speed, determine whether the yacht can complete a transpacific voyage (approximately 8000 nautical miles) before running out of fuel.",
        "query": "SELECT (Fuel_Capacity / Fuel_Efficiency) AS Actual_Range, `Range` AS Designed_Range FROM yachts JOIN performance_metrics ON yachts.Yacht_ID = performance_metrics.Yacht_ID WHERE yachts.Yacht_ID = 1;",
        "step": "【step1】: Filter the 'yachts' table to retrieve the specific yacht with Yacht_ID = 1, including its Fuel_Capacity.  【step2】: Join the filtered 'yachts' table with 'performance_metrics' using Yacht_ID to access the yacht's Fuel_Efficiency (L/hour) and pre-calculated Range (nautical miles).  【step3】: Calculate Actual_Range by dividing Fuel_Capacity by Fuel_Efficiency to get operational hours, then implicitly convert it to nautical miles using the yacht's Max_Speed (50 knots ≈ 50 nautical miles/hour). Compare Actual_Range with the required 8000 nautical miles.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1706,
        "question": "A yacht has an ID of 1. What is the total water needed for its passenger capacity for a week compared to its water capacity?",
        "query": "SELECT Water_Capacity, Passenger_Capacity * 50 * 7 AS Total_Water_Needed FROM yachts WHERE Yacht_ID = 1;",
        "step": "【step1】: JOIN yachts and performance_metrics tables using Yacht_ID to access both physical dimensions (Length, Width) and hydrodynamic parameter (Draft)  【step2】: Calculate displacement volume using formula: Length * Width * Draft  【step3】: Filter results for Yacht_ID = 1 using WHERE clause  The original query contains logical errors:  1. Water_Capacity represents freshwater tank size, unrelated to displacement  2. Passenger_Capacity*50*7 calculates water needs (assuming 50L/person/day & 7 days)  3. Actual displacement calculation requires joining yachts.Length/yachts.Width with performance_metrics.Draft",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1707,
        "question": "A yacht has a fuel capacity of 8000 liters. Given a fuel efficiency of 50 liters per 1000 nautical miles, what is the possible distance it can travel, and how does it compare to a required distance of 8000 nautical miles?",
        "query": "SELECT (Fuel_Capacity / 1000) * 50 AS Possible_Distance, 8000 AS Required_Distance FROM yachts WHERE Yacht_ID = 1;",
        "step": "【step1】: Retrieve Yacht's Fuel_Capacity from yachts table where Yacht_ID=1  【step2】: Calculate theoretical sailing distance using (8000 liters / 60 liters/hour) * 25 knots  【step3】: Compare actual voyage distance (3000 nautical miles) with calculation through unit conversions  This query contains fundamental errors:  1. Uses incorrect formula (should be (distance/speed)*fuel_rate)  2. Uses hardcoded 50 instead of actual fuel efficiency  3. Wrongly aliases 8000 as Required_Distance  4. Doesn't reference performance_metrics table where fuel efficiency is stored  A valid query should JOIN yachts and performance_metrics tables, then calculate:  (3000 / (25)) * 60 = 7200 liters required",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1708,
        "question": "Calculate the average price for each hull material",
        "query": "SELECT Hull_Material, AVG(Price) AS Avg_Price FROM yachts GROUP BY Hull_Material;",
        "step": "【step1】: Retrieve all records from the 'yachts' table, selecting the 'Hull_Material' and 'Price' columns.  【step2】: Group the retrieved data by the 'Hull_Material' column to categorize entries by material type.  【step3】: Calculate the average value of the 'Price' column within each material group using the AVG() function and alias the result as 'Avg_Price'.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1709,
        "question": "List the model, length, and maximum speed of all yachts exceeding 30 meters in length.",
        "query": "SELECT Model, Length, Max_Speed FROM yachts WHERE Length > 30;",
        "step": "【step1】: Select Model, Length, and Max_Speed columns from the yachts table.  【step2】: Apply the WHERE clause to filter rows where Length exceeds 30 meters.  【step3】: Execute the query to return the specified details of qualifying yachts.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1710,
        "question": "List the model, length, and width of all yachts that use \"Fiberglass\" as their hull material.",
        "query": "SELECT Model, Length, Width FROM yachts WHERE Hull_Material = 'Fiberglass';",
        "step": "【step1】: Access the 'yachts' table to retrieve yacht specifications.  【step2】: Filter records where Hull_Material equals 'Fiberglass'.  【step3】: Extract the Model, Length, and Width columns from the filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1711,
        "question": "Find the model, production year, and hull material of all yachts with a production year after 2020.",
        "query": "SELECT Model, Year, Hull_Material FROM yachts WHERE Year > 2020;",
        "step": "【step1】: Select Model, Year, and Hull_Material columns from yachts table  【step2】: Filter records using condition Year > 2020 to get post-2020 production yachts",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1712,
        "question": "Retrieve all rental records where the number of passengers exceeds the yacht's passenger capacity, and return the detailed information of these records.",
        "query": "SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity;",
        "step": "【step1】: Perform INNER JOIN between 'charters' and 'yachts' tables using Yacht_ID to combine charter records with corresponding yacht specifications  【step2】: Apply WHERE filter to select only rows where charter.Passenger_Count exceeds yacht.Passenger_Capacity  【step3】: Project all columns from the 'charters' table (c.*) as final output to show violating charter details",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1713,
        "question": "Calculate the fuel consumption time of yachts at maximum fuel efficiency (fuel capacity / fuel efficiency), and return information on yachts with fuel consumption time exceeding 1000 hours. The fuel efficiency is taken as the maximum value from the performance metrics table.",
        "query": "SELECT y.*, y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) AS Fuel_Consumption_Time FROM yachts y WHERE y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) > 1000;",
        "step": "【step1】: Retrieve all yachts' basic information from the 'yachts' table  【step2】: Correlate each yacht with its maximum Fuel_Efficiency from 'performance_metrics' using a subquery  【step3】: Calculate Fuel_Consumption_Time (Fuel_Capacity / max_Fuel_Efficiency) and filter results exceeding 1000 hours",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1714,
        "question": "Calculate the kinetic energy of each yacht and return the information of the top 5 yachts with the highest kinetic energy. The kinetic energy formula is 0.5 * mass * velocity², where mass is estimated by displacement (displacement * 1000), and velocity is the maximum speed (converted from knots to meters/second).",
        "query": "SELECT y.*, 0.5 * (y.Displacement * 1000) * POWER((y.Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts y ORDER BY Kinetic_Energy DESC LIMIT 5;",
        "step": "【step1】: Calculate kinetic energy for each yacht using the formula 0.5*(Displacement*1000)*(Max_Speed*0.5144)^2 and name the result column as Kinetic_Energy.  【step2】: Sort all results in descending order based on the calculated Kinetic_Energy.  【step3】: Restrict the final output to only the top 5 records with the highest kinetic energy values.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1715,
        "question": "Calculate the fuel consumption rate (liters/nautical mile) for each yacht and return the voyage with the lowest fuel consumption rate for each yacht. The fuel consumption rate is derived by dividing the fuel consumption (liters) by the sailing distance (nautical miles).",
        "query": "WITH Fuel_Rate AS (SELECT y.Yacht_ID, y.Model, v.Fuel_Consumed / v.Distance AS Fuel_Consumption_Rate FROM yachts y JOIN voyages v ON y.Yacht_ID = v.Yacht_ID) SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY Yacht_ID ORDER BY Fuel_Consumption_Rate ASC) AS rn FROM Fuel_Rate) WHERE rn = 1;",
        "step": "【step1】: Calculate the fuel consumption rate (Fuel_Consumed/Distance) for each voyage by joining the `yachts` and `voyages` tables.  【step2】: Use `ROW_NUMBER()` to assign a ranking per yacht (partitioned by Yacht_ID), ordering by fuel consumption rate ascending to identify the most efficient voyage for each yacht.  【step3】: Filter the results to retain only the top-ranked record (rn=1) for each yacht, ensuring only the lowest fuel consumption rate per yacht is returned.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1716,
        "question": "Query all rental records where the number of passengers exceeds the yacht's passenger capacity, group them by charter type, and return the record with the highest total cost in each group.",
        "query": "WITH Overloaded_Charters AS (SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity) SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY Charter_Type ORDER BY Total_Cost DESC) AS rn FROM Overloaded_Charters) WHERE rn = 1;",
        "step": "【step1】: Identify overloaded charters by joining 'charters' and 'yachts' tables where passenger count exceeds capacity.  【step2】: Apply window function to rank records within each Charter_Type group by Total_Cost in descending order.  【step3】: Filter results to retain only the highest-cost record (rank=1) from each Charter_Type group.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1717,
        "question": "Find the model, price, and maximum speed of all yachts priced over $5 million.",
        "query": "SELECT Model, Price, Max_Speed FROM yachts WHERE Price > 5000000;",
        "step": "【step1】:【Retrieve Model, Price, and Max_Speed columns from yachts table】  【step2】:【Filter records where Price exceeds 5,000,000 USD】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1718,
        "question": "List the model, engine power, and fuel capacity of all yachts that use the \"Inboard\" engine type.",
        "query": "SELECT Model, Engine_Power, Fuel_Capacity FROM yachts WHERE Engine_Type = 'Inboard';",
        "step": "【step1】: Select Model, Engine_Power, and Fuel_Capacity columns from yachts table  【step2】: Apply filter condition where Engine_Type equals 'Inboard'",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1719,
        "question": "Can this yacht with a passenger capacity of 20 meet the requirement that the total distinct customers and distinct crew members (5 crew and 10 customers) does not exceed 80% of the yacht's passenger capacity for a voyage?",
        "query": "SELECT y.Yacht_ID, y.Model, y.Passenger_Capacity, COUNT(c.Customer_ID) AS Customer_Count, COUNT(cr.Crew_ID) AS Crew_Count FROM yachts y JOIN charters ch ON y.Yacht_ID = ch.Yacht_ID JOIN customers c ON ch.Customer_ID = c.Customer_ID JOIN crew cr ON y.Yacht_ID = cr.Yacht_ID GROUP BY y.Yacht_ID HAVING (COUNT(c.Customer_ID) + COUNT(cr.Crew_ID)) <= y.Passenger_Capacity * 0.8;",
        "step": "【step1】: Perform JOINS to link yachts with charters (via Yacht_ID), customers (via Customer_ID), and crew (via Yacht_ID), creating a combined dataset for analysis.  【step2】: Calculate aggregated values using GROUP BY y.Yacht_ID - count customers per charter and crew members per yacht.  【step3】: Apply HAVING clause to filter yachts where (Customer_Count + Crew_Count) ≤ 80% of Passenger_Capacity, implementing the capacity constraint logic.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1720,
        "question": "If a yacht has a fuel capacity of 10,000 liters, a fuel efficiency of 200 liters per hour, a sailing distance of 500 nautical miles, and an average speed of 20 knots, can the yacht complete this voyage without refueling midway? (Hint: Calculate the required fuel using the formula fuel_efficiency * (distance / average_speed) and compare it with fuel_capacity.)",
        "query": "SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed);",
        "step": "【step1】: JOIN three tables (yachts, performance_metrics, voyages) using Yacht_ID to combine fuel capacity, fuel efficiency, and voyage details.  【step2】: Calculate required fuel consumption using (voyages.Distance / voyages.Average_Speed) * performance_metrics.Fuel_Efficiency to determine total fuel needed for the trip.  【step3】: Filter results where yachts.Fuel_Capacity >= calculated fuel requirement, identifying yachts that can complete the voyage without refueling.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1721,
        "question": "If a yacht has an engine power of 100,000 horsepower, a fuel capacity of 1,000,000 liters, a fuel efficiency of 500 liters/hour, a voyage distance of 10,000 nautical miles, and an average speed of 50 knots, can this yacht complete the journey without the need for mid-voyage refueling while running at full power?",
        "query": "SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed) AND y.Engine_Power = 100000;",
        "step": "【step1】: Join yachts with performance_metrics to correlate fuel capacity with fuel efficiency.  【step2】: Join the result with voyages to incorporate voyage-specific distance and speed.  【step3】: Filter records where Fuel_Capacity ≥ (Fuel_Efficiency × Distance / Average_Speed) and Engine_Power = 100000 to verify feasibility.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1722,
        "question": "A yacht has a displacement of 150 tons and the Yacht_ID is 'specific_yacht_ID'. If the yacht is sailing in fresh water, what is its draft depth?",
        "query": "SELECT Displacement / (Length * Width * 1) AS Draft FROM yachts WHERE Yacht_ID = '特定游艇ID';",
        "step": "【step1】: Retrieve the specific yacht's Displacement, Length, and Width values from the 'yachts' table using the Yacht_ID filter.  【step2】: Calculate Draft by dividing Displacement (in tons) by the product of Length (m), Width (m), and freshwater density (1 ton/m³), yielding Draft = Displacement / (Length × Width × 1).",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1723,
        "question": "A customer chartered multiple yachts in 2023. If 20% of the total cost was for additional services and the customer received a 15% discount on the base rental cost (excluding additional services), what is the actual amount the customer paid for the rental?",
        "query": "SELECT (Total_Cost * 0.8 * 0.85) + (Total_Cost * 0.2) AS Actual_Payment FROM charters WHERE Customer_ID = '特定客户ID' AND YEAR(Start_Date) = 2023;",
        "step": "【step1】:【Filter the 'charters' table to retrieve records for the specific customer in 2023】  【step2】:【Calculate discounted base rental cost: (Total_Cost * 0.8 * 0.85)】  【step3】:【Add non-discounted service fee (Total_Cost * 0.2) to get final payment】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1724,
        "question": "A yacht has a maximum speed of 25 knots, but the navigation record shows an average speed of 30 knots during a particular voyage. Is this situation possible according to the query? If not, what could be the possible reason?",
        "query": "SELECT Voyage_ID, Yacht_ID, Average_Speed FROM voyages WHERE Average_Speed > (SELECT Max_Speed FROM yachts WHERE yachts.Yacht_ID = voyages.Yacht_ID);",
        "step": "【step1】: Subquery retrieves the max_speed of each yacht from the yachts table via yachts.Yacht_ID = voyages.Yacht_ID  【step2】: Main query compares voyages.Average_Speed against the subquery result (yacht's max_speed)  【step3】: Returns voyages where average_speed exceeds the yacht's theoretical maximum, exposing data anomalies",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1725,
        "question": "If a yacht has a fuel capacity of 2,000,000 liters, a fuel efficiency of 2000 liters/hour, and an engine power of 200,000 horsepower, how many years of continuous sailing can the fuel support?",
        "query": "SELECT (Fuel_Capacity / Fuel_Efficiency) / (24 * 365) AS Fuel_Support_Years FROM yachts WHERE Yacht_ID = '特定游艇ID';",
        "step": "【step1】: Filter the 'yachts' table by Yacht_ID to retrieve the specific yacht's Fuel_Capacity and Fuel_Efficiency.  【step2】: Calculate total operational hours using Fuel_Capacity / Fuel_Efficiency.  【step3】: Convert hours to years by dividing by (24*365) and output as Fuel_Support_Years.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1726,
        "question": "Calculate the kinetic energy of yachts at their maximum speed, and identify the yacht models with kinetic energy exceeding 100,000,000 joules.",
        "query": "SELECT Model, 0.5 * (Weight * 1000) * POWER((Max_Speed * 0.514444), 2) AS Kinetic_Energy FROM yachts WHERE 0.5 * (Weight * 1000) * POWER((Max_Speed * 0.514444), 2) > 100000000;",
        "step": "【step1】:【Convert units: Multiply Weight (in tons) by 1000 to convert to kilograms, and multiply Max_Speed (in knots) by 0.514444 to convert to meters per second.】  【step2】:【Calculate kinetic energy using the formula 0.5 * mass (kg) * velocity² (m/s): Apply the formula to derive Kinetic_Energy for each yacht.】  【step3】:【Filter results: Use the WHERE clause to select only entries where the calculated kinetic energy exceeds 100,000,000 joules.】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1727,
        "question": "Find the model, length, and production year of all yachts with lengths between 20 meters and 30 meters.",
        "query": "SELECT Model, Length, Year FROM yachts WHERE Length BETWEEN 20 AND 30;",
        "step": "【step1】: Select Model, Length, Year columns from yachts table  【step2】: Apply WHERE filter to include only records with Length between 20 and 30 meters",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1728,
        "question": "Retrieve yachts sailing under severe weather conditions (wave height greater than 3 meters, wind speed exceeding 30 knots) and list their model, hull material and engine type.",
        "query": "SELECT y.Model, y.Hull_Material, y.Engine_Type FROM yachts y JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE v.Wave_Height > 3 AND v.Wind_Speed > 30;",
        "step": "【step1】: Perform an INNER JOIN between 'yachts' and 'voyages' tables using Yacht_ID to combine yacht specifications with voyage records.  【step2】: Apply filtering conditions v.Wave_Height > 3 AND v.Wind_Speed > 30 to isolate voyages with harsh weather.  【step3】: Select the required columns y.Model, y.Hull_Material, and y.Engine_Type from the filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1729,
        "question": "If a yacht's fuel capacity is 1,000,000 liters, calculate its range and identify the yacht models with a range exceeding 1,000,000 nautical miles.",
        "query": "SELECT y.Model, (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 AS Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 > 1000000;",
        "step": "【step1】: Join three tables (yachts, performance_metrics, voyages) via Yacht_ID to consolidate required data.  【step2】: Calculate the theoretical range using formula (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852, aliased as \"Range\".  【step3】: Filter results where the calculated Range exceeds 1,000,000 nautical miles using the WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1730,
        "question": "Calculate the maximum kinetic energy for each hull material and identify the yacht model with this highest kinetic energy for each material.",
        "query": "WITH KineticEnergy AS (SELECT Model, Hull_Material, 0.5 * (Weight * 1000) * POWER((Max_Speed * 0.514444), 2) AS Kinetic_Energy FROM yachts) SELECT Hull_Material, Model, MAX(Kinetic_Energy) AS Max_Kinetic_Energy FROM KineticEnergy GROUP BY Hull_Material;",
        "step": "【step1】: Calculate kinetic energy for each yacht by applying the formula (0.5 * weight_in_kg * speed_in_mps²) using a CTE.  【step2】: Group results by Hull_Material and find the maximum kinetic energy per group.  【step3】: Extract the corresponding yacht Model associated with each maximum kinetic energy value within its material group.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1731,
        "question": "List the model, maximum speed, and price of all yachts with a maximum speed exceeding 35 knots.",
        "query": "SELECT Model, Max_Speed, Price FROM yachts WHERE Max_Speed > 35;",
        "step": "【step1】: Select the 'Model', 'Max_Speed', and 'Price' columns from the 'yachts' table.  【step2】: Apply the filter condition to retain only rows where 'Max_Speed' is greater than 35 knots.  【step3】: (Not required for this query as it does not involve joins, sorting, or complex operations)",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1732,
        "question": "Find the model, fuel capacity, and hull material of all yachts with a fuel capacity exceeding 1000 liters.",
        "query": "SELECT Model, Fuel_Capacity, Hull_Material FROM yachts WHERE Fuel_Capacity > 1000;",
        "step": "【step1】: Select Model, Fuel_Capacity, Hull_Material columns from yachts table  【step2】: Apply WHERE filter condition Fuel_Capacity > 1000",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1733,
        "question": "List the model, passenger capacity, and price of all yachts that can accommodate more than 12 passengers.",
        "query": "SELECT Model, Passenger_Capacity, Price FROM yachts WHERE Passenger_Capacity > 12;",
        "step": "【step1】: Access the 'yachts' table containing yacht specifications  【step2】: Filter records where Passenger_Capacity exceeds 12 using WHERE clause  【step3】: Extract the requested columns (Model, Passenger_Capacity, Price) for qualified entries",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1734,
        "question": "Calculate the minimum buoyancy ratio (buoyancy force divided by weight times 1000 times 9.81) for each hull material, and identify the yacht model with this minimum ratio for each hull material.",
        "query": "WITH BuoyancyRatio AS (SELECT Model, Hull_Material, Buoyancy_Force / (Weight * 1000 * 9.81) AS Buoyancy_Ratio FROM yachts) SELECT Hull_Material, Model, MIN(Buoyancy_Ratio) AS Min_Buoyancy_Ratio FROM BuoyancyRatio GROUP BY Hull_Material;",
        "step": "【step1】: Calculate buoyancy ratio for each yacht model by dividing Buoyancy_Force by (Weight * 1000 * 9.81) using a CTE  【step2】: Group records by Hull_Material and find the minimum buoyancy ratio within each group  【step3】: Retrieve the corresponding yacht model associated with the minimum ratio per hull material group",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1735,
        "question": "Find the model, displacement, and maximum speed of all yachts with a displacement exceeding 50.",
        "query": "SELECT Model, Displacement, Max_Speed FROM yachts WHERE Displacement > 50;",
        "step": "【step1】: Retrieve Model, Displacement, and Max_Speed columns from yachts table  【step2】: Filter records where Displacement exceeds 50 tons",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1736,
        "question": "List the model, buoyancy, and center of gravity position for all yachts with a buoyancy exceeding 100,000 newtons.",
        "query": "SELECT Model, Buoyancy_Force, Center_of_Gravity FROM yachts WHERE Buoyancy_Force > 100000;",
        "step": "【step1】: Access the 'yachts' table to retrieve data about all yachts.  【step2】: Filter the records to include only yachts where the Buoyancy_Force exceeds 100000 Newtons.  【step3】: Extract the Model, Buoyancy_Force, and Center_of_Gravity attributes from the filtered dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1737,
        "question": "Find the model, drag coefficient, and hull speed of all yachts with a drag coefficient less than 0.5.",
        "query": "SELECT Model, Drag_Coefficient, Hull_Speed FROM yachts WHERE Drag_Coefficient < 0.5;",
        "step": "【step1】: Select Model, Drag_Coefficient, and Hull_Speed columns from the yachts table  【step2】: Apply filter condition to retain only records where Drag_Coefficient < 0.5",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1738,
        "question": "Calculate the highest ratio of kinetic energy to average crew salary for each hull material, and show the yacht model with that highest ratio for each hull material.",
        "query": "WITH KineticEnergy AS (SELECT y.Model, y.Hull_Material, 0.5 * (y.Weight * 1000) * POWER((y.Max_Speed * 0.514444), 2) AS Kinetic_Energy, AVG(c.Salary) AS Avg_Salary FROM yachts y JOIN crew c ON y.Yacht_ID = c.Yacht_ID GROUP BY y.Model, y.Hull_Material) SELECT Hull_Material, Model, MAX(Kinetic_Energy / Avg_Salary) AS Max_Ratio FROM KineticEnergy GROUP BY Hull_Material;",
        "step": "【step1】: Calculate kinetic energy and average crew salary per yacht model by joining 'yachts' and 'crew' tables, grouping by Model and Hull_Material. Kinetic energy formula: 0.5 * (Weight in kg) * (Max_Speed in m/s)^2.  【step2】: Create a CTE (KineticEnergy) containing Model, Hull_Material, calculated kinetic energy, and average salary.  【step3】: Group results by Hull_Material and use MAX(Kinetic_Energy / Avg_Salary) to find the highest ratio per material group, returning the corresponding yacht Model.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1739,
        "question": "List the model, production year, and price of all yachts with manufacturer ID 1.",
        "query": "SELECT Model, Year, Price FROM yachts WHERE Manufacturer_ID = 1;",
        "step": "【step1】: Access the 'yachts' table to retrieve data about all stored yachts.  【step2】: Filter records using the condition WHERE Manufacturer_ID = 1 to isolate yachts from the specified manufacturer.  【step3】: Project only the required columns (Model, Year, Price) from the filtered dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1740,
        "question": "Find the model, hull speed, and maximum speed of all yachts with a hull speed exceeding 25 knots.",
        "query": "SELECT Model, Hull_Speed, Max_Speed FROM yachts WHERE Hull_Speed > 25;",
        "step": "【step1】: Select the required fields Model, Hull_Speed, and Max_Speed from the yachts table.  【step2】: Apply the WHERE clause to filter records where Hull_Speed exceeds 25 knots.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1741,
        "question": "List the model, weight, and displacement of all yachts that weigh over 100.",
        "query": "SELECT Model, Weight, Displacement FROM yachts WHERE Weight > 100;",
        "step": "【step1】:【Filter yachts table to select records with Weight > 100 tons using WHERE clause】  【step2】:【Extract Model, Weight, and Displacement columns from the filtered records】",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "1",
        "idx": 1742,
        "question": "Calculate the ratio of kinetic energy to average crew salary for each yacht model, and sort them in descending order by this ratio. List the top 5 yacht models along with their respective ratios.",
        "query": "WITH KineticEnergy AS (SELECT y.Model, 0.5 * (y.Weight * 1000) * POWER((y.Max_Speed * 0.514444), 2) AS Kinetic_Energy, AVG(c.Salary) AS Avg_Salary FROM yachts y JOIN crew c ON y.Yacht_ID = c.Yacht_ID GROUP BY y.Model) SELECT Model, Kinetic_Energy / Avg_Salary AS Ratio FROM KineticEnergy ORDER BY Ratio DESC LIMIT 5;",
        "step": "【step1】: Perform inner join between yachts and crew tables, calculate kinetic energy (0.5*Weight*1000*(Max_Speed*0.514444)^2) and crew salary average per model through GROUP BY aggregation.  【step2】: Compute the energy-to-salary ratio (Kinetic_Energy/Avg_Salary) using the intermediate results from the CTE.  【step3】: Apply descending ordering by ratio and return top 5 records with LIMIT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "2",
        "idx": 1743,
        "question": "Find the model, water capacity, and fuel capacity of all yachts with a water capacity exceeding 500 liters.",
        "query": "SELECT Model, Water_Capacity, Fuel_Capacity FROM yachts WHERE Water_Capacity > 500;",
        "step": "【step1】: Identify 'yachts' table containing required columns (Model, Water_Capacity, Fuel_Capacity)  【step2】: Apply filter WHERE Water_Capacity > 500 to retrieve records meeting freshwater capacity criteria",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "3",
        "idx": 1744,
        "question": "Find the model, length, maximum speed, and price of all yachts with a length exceeding 30 meters and a maximum speed exceeding 35 knots, sorted in descending order by price.",
        "query": "SELECT Model, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 35 ORDER BY Price DESC;",
        "step": "【step1】: Access the yachts table to retrieve Model, Length, Max_Speed, and Price columns  【step2】: Filter records using combined conditions (Length > 30 meters AND Max_Speed > 35 knots)  【step3】: Sort remaining results in descending order based on Price",
        "format": "MySQL"
    },
    {
        "db_id": "yacht",
        "type": "4",
        "idx": 1745,
        "question": "List the model, production year, hull material, and engine power of all yachts produced after 2020 that use \"Fiberglass\" as the hull material, sorted by engine power in ascending order.",
        "query": "SELECT Model, Year, Hull_Material, Engine_Power FROM yachts WHERE Year > 2020 AND Hull_Material = 'Fiberglass' ORDER BY Engine_Power ASC;",
        "step": "【step1】: Select Model, Year, Hull_Material, and Engine_Power columns from the yachts table  【step2】: Apply filters WHERE Year > 2020 AND Hull_Material = 'Fiberglass'  【step3】: Sort the results by Engine_Power in ascending order using ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1746,
        "question": "The weight of an electric bike is 50kg, the motor power is 400W, the battery voltage is 48V, and the capacity is 20Ah. What is the theoretical endurance time of this electric bike when traveling at a constant speed on flat ground?",
        "query": "SELECT (b.Voltage * b.Capacity) / m.Power AS Theoretical_Range_Time FROM Batteries b JOIN ElectricBikes eb ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID WHERE eb.Weight = 50 AND m.Power = 400 AND b.Voltage = 48 AND b.Capacity = 20;",
        "step": "【step1】: Join ElectricBikes, Batteries, and Motors tables using Bike_ID to link associated components  【step2】: Apply filters for Weight=50kg, Power=400W, Voltage=48V, and Capacity=20Ah to identify matching records  【step3】: Calculate theoretical endurance time using formula (Voltage × Capacity) / Power and output result as Theoretical_Range_Time",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1747,
        "question": "An electric scooter has a battery capacity of 15Ah, a voltage of 36V, a motor power of 250W, and a wheel size of 12 inches. If the scooter consumes 0.05 kWh of energy per kilometer, what is the theoretical range of this electric scooter?",
        "query": "SELECT (b.Voltage * b.Capacity) / 0.05 AS Distance FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE b.Capacity = 15 AND b.Voltage = 36 AND m.Power = 250 AND bd.Wheel_Size = 12;",
        "step": "【step1】: Join tables ElectricBikes, Batteries, Motors, and BodyDimensions via Bike_ID to gather all required technical specifications.  【step2】: Filter records where battery capacity=15Ah, voltage=36V, motor power=250W, and wheel size=12 inches to match the target configuration.  【step3】: Calculate theoretical range using formula (Voltage × Capacity) / 0.05 and output as Distance.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1748,
        "question": "Find all types, voltages, and capacities where the voltage is 48V and the capacity is greater than 50Ah, sorted by capacity in descending order.",
        "query": "SELECT Type, Voltage, Capacity FROM Batteries WHERE Voltage = 48 AND Capacity > 50 AND Type = '锂电池' ORDER BY Capacity DESC;",
        "step": "【step1】: SELECT Type, Voltage, Capacity FROM Batteries  【step2】: Apply filters: Voltage = 48 AND Capacity > 50 AND Type = '锂电池'  【step3】: Sort results by Capacity in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1749,
        "question": "List all battery types, voltages, and capacities for those with 60V or 72V voltage, and calculate their total capacity.",
        "query": "SELECT  Type, Voltage, Capacity, SUM(Capacity) OVER () AS Total_Capacity FROM Batteries WHERE Voltage IN (60, 72);",
        "step": "【step1】: Filter records from the Batteries table where Voltage is 60V or 72V using the WHERE clause.  【step2】: Select the Type, Voltage, and Capacity columns, and compute the total capacity across all filtered rows using the SUM window function (SUM(Capacity) OVER ()).",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1750,
        "question": "Find all lithium batteries with a voltage of 72V and capacity greater than 90Ah, list their type, voltage, and capacity, and calculate their total capacity.",
        "query": "SELECT Type, Voltage, Capacity, SUM(Capacity) OVER () AS Total_Capacity FROM Batteries WHERE Voltage = 72 AND Capacity > 90 AND Type = '锂电池';",
        "step": "【step1】: Filter records from the Batteries table where Type is '锂电池', Voltage = 72, and Capacity > 90 using the WHERE clause.  【step2】: Select the Type, Voltage, and Capacity fields while simultaneously calculating the total capacity of all filtered records using the SUM(Capacity) OVER() window function.  【step3】: Output the result set containing individual battery details and the aggregated Total_Capacity for all matching rows.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1751,
        "question": "An electric scooter has a battery with a voltage of 1000 V and capacity of 1000 Ah, and a motor with power of 10000 W. Based on these specifications, what is the theoretical distance it can travel and is this configuration feasible?",
        "query": "SELECT (b.Voltage * b.Capacity) / 1 AS Distance, CASE WHEN b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 THEN '理论可行，实际不可行' ELSE '配置异常' END AS Feasibility FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID WHERE b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 LIMIT 1;",
        "step": "【step1】: Join ElectricBikes with Batteries and Motors tables using Bike_ID, filter records where Voltage=1000, Capacity=1000, and Power=10000.  【step2】: Calculate the Distance field as (Voltage * Capacity) / 1.  【step3】: Apply the CASE statement to determine Feasibility based on predefined logical conditions.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1752,
        "question": "An electric scooter has a body length of 1800mm, width of 700mm, height of 1200mm, and wheel diameter of 14 inches. Can this electric scooter pass through a tunnel with a height restriction of 1.5 meters?",
        "query": "SELECT (bd.Length * bd.Width * bd.Height) AS Body_Volume FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 1800 AND bd.Width = 700 AND bd.Height = 1200 AND bd.Wheel_Size = 14;",
        "step": "【step1】: Join ElectricBikes and BodyDimensions tables using Bike_ID to associate dimensions with specific bike models.  【step2】: Filter records where dimensions match 1800mm length, 700mm width, 1200mm height, and 14-inch wheels.  【step3】: Calculate body volume (Length × Width × Height) for the filtered records.  (Note: The original query appears flawed as it calculates volume unrelated to the height limit problem. A proper query should directly compare 1200mm (1.2m) height against the 1.5m tunnel limit, but steps are written based on the provided SQL logic.)",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1753,
        "question": "Assuming the dimensions of an electric vehicle are: body length 5000mm, width 2000mm, height 2500mm. If the user needs to park this electric vehicle in a parking space measuring 6 meters in length, 2.5 meters in width, and 3 meters in height, can this electric vehicle be parked successfully?",
        "query": "SELECT CASE WHEN bd.Length <= 2500 AND bd.Width <= 1000 AND bd.Height <= 1500 THEN '可以停放' ELSE '无法停放' END AS Parking_Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 2000 AND bd.Width = 750 AND bd.Height = 1100 AND bd.Wheel_Size = 16 LIMIT 1;",
        "step": "【step1】: Perform an INNER JOIN between ElectricBikes and BodyDimensions tables using Bike_ID, filtering BodyDimensions entries where Length=2000mm, Width=750mm, Height=1100mm, and Wheel_Size=16 inches.  【step2】: Apply CASE statement to check if the filtered dimensions meet parking constraints (Length≤2500mm, Width≤1000mm, Height≤1500mm) derived from the parking space parameters.  【step3】: Return \"可以停放\" if all dimension thresholds are satisfied, otherwise return \"无法停放\", limited to a single result.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1754,
        "question": "An electric scooter used 2kWh of electricity during a single charge, with a charging voltage of 220V. What was the current during this charging?",
        "query": "SELECT DISTINCT CASE WHEN bd.Height <= 1500 THEN '可以通过' ELSE '无法通过' END AS Tunnel_Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Height = 1200 AND bd.Wheel_Size = 14;",
        "step": "【step1】: The query retrieves tunnel feasibility status by joining ElectricBikes and BodyDimensions tables where Height=1200mm and Wheel_Size=14 inches.  【step2】: The CASE statement categorizes vehicles with height ≤1500mm as \"可以通过\", others as \"无法通过\".  【step3】: The DISTINCT modifier ensures uniqueness in results, though redundant since Height/Wheel_Size filters create inherent uniqueness in this context.  Observation: The provided SQL query is unrelated to the physics calculation question about electric current. The database lacks voltage/current time parameters required for current calculation (missing charging duration in ChargingRecords).",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1755,
        "question": "What are the parking feasibility and configuration feasibility details for an electric bike with a length of 5000, width of 2000, height of 2500, and wheel size of 30?",
        "query": "SELECT CASE WHEN bd.Length <= 6000 AND bd.Width <= 2500 AND bd.Height <= 3000 THEN '可以停放' ELSE '无法停放' END AS Parking_Feasibility, CASE WHEN bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30 THEN '理论可行，实际不可行' ELSE '配置异常' END AS Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30;",
        "step": "【step1】: Filter charging records for User_ID=3 from ChargingRecords table  【step2】: Calculate sum of Cost column using SUM() aggregation function  【step3】: Return final total charging cost via SELECT statement with WHERE clause",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1756,
        "question": "An electric scooter uses 2 kWh of electricity in one charge, and the charging station's efficiency is 90%. What is the actual amount of electricity consumed from the grid?",
        "query": "SELECT (cr.Energy_Used * 1000) / (220 * ((HOUR(TIMEDIFF(cr.EndTime, cr.StartTime)) * 3600) + (MINUTE(TIMEDIFF(cr.EndTime, cr.StartTime)) * 60) + SECOND(TIMEDIFF(cr.EndTime, cr.StartTime)))) AS Charging_Current FROM ChargingRecords cr WHERE cr.Energy_Used = 2;",
        "step": "【step1】: Calculate the time difference between EndTime and StartTime using TIMEDIFF to get the total charging duration.  【step2】: Convert the duration into total seconds by combining hours, minutes, and seconds components.  【step3】: Compute the charging current by dividing the energy (Energy_Used converted to watt-hours) by the product of voltage (220V) and total charging time in seconds.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1757,
        "question": "What is the total charging cost for user ID 3 on October 1, 2023?",
        "query": "SELECT SUM( Cost) AS Total_Charging_Cost FROM ChargingRecords WHERE User_ID = 3 AND DATE(StartTime) = '2023-10-01';",
        "step": "【step1】: Filter the ChargingRecords table to find all entries where User_ID is 3 and the StartTime date is '2023-10-01' using the WHERE clause.  【step2】: Calculate the total charging cost by summing the Cost column for the filtered records using the SUM() function and alias it as Total_Charging_Cost.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1758,
        "question": "What is the actual energy consumed from an electric bicycle's battery with a voltage of 48V and capacity of 20Ah, given that the energy used is 3 kWh?",
        "query": "SELECT Energy_Used / 0.9 AS Actual_Energy_Consumed FROM ChargingRecords WHERE Energy_Used = 3 Limit 1;",
        "step": "【step1】: Filter ChargingRecords where Energy_Used equals 3  【step2】: Calculate Actual_Energy_Consumed by dividing Energy_Used by 0.9  【step3】: Limit the result to 1 row using LIMIT 1",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1759,
        "question": "What is the result of 1000 divided by the product of 1000, 1, and 0.5?",
        "query": "SELECT 1000 / (1000 * 1 * 0.5) AS Actual_Current;",
        "step": "【step1】: Join ElectricBikes and Motors tables using Bike_ID to get both Weight and Power values for the specified e-bike.  【step2】: Calculate power-to-weight ratio using formula Power/Weight.  【step3】: Execute SELECT m.Power / e.Weight AS Power_Weight_Ratio FROM ElectricBikes e JOIN Motors m ON e.Bike_ID = m.BikeID WHERE e.Weight=30 AND m.Power=500;  Note: The original query appears incorrect as it calculates unrelated values (1000/(1000*1*0.5)=2) instead of the required 500W/30kg≈16.67 W/kg ratio. The provided solution follows proper relational database access and calculation logic.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1760,
        "question": "An electric scooter has a range of 60km, a battery capacity of 20Ah, and a voltage of 48V. What is the energy consumption per kilometer in watt-hours per kilometer?",
        "query": "SELECT Voltage * Capacity AS Energy FROM Batteries WHERE Voltage = 48 AND Capacity = 20 LIMIT 1;",
        "step": "【step1】: Filter battery records with Voltage=48V and Capacity=20Ah using WHERE clause  【step2】: Calculate total energy (Voltage × Capacity) for the filtered record  【step3】: Return single result using LIMIT 1 to get energy value per kilometer (60km distance implied in question)",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1761,
        "question": "Assuming an electric vehicle has a battery capacity of 1000Ah, a voltage of 1000V, and a motor power of 10000W, what is its power-to-weight ratio if the weight is 1000kg?",
        "query": "SELECT m.Power / e.Weight AS PowerToWeightRatio FROM ElectricBikes e JOIN Motors m ON e.Bike_ID = m.Bike_ID JOIN Batteries b ON e.Bike_ID = b.Bike_ID WHERE e.Weight = 30 AND m.Power = 500 AND b.Capacity = 20 AND b.Voltage = 48;",
        "step": "【step1】: Perform INNER JOIN operations between ElectricBikes, Motors, and Batteries tables using Bike_ID as the foreign key relationship  【step2】: Apply WHERE clause to filter records with Weight=30kg, Power=500W, Capacity=20Ah, and Voltage=48V  【step3】: Calculate power-to-weight ratio by dividing Motor.Power (500W) by ElectricBikes.Weight (30kg) through SELECT clause",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1762,
        "question": "A charging record shows the electricity usage is 2kWh with a charging time of 2 hours, so what is the average charging power in kilowatts?",
        "query": "SELECT (b.Voltage * b.Capacity) / b.Distance AS EnergyPerKm FROM Batteries b WHERE b.Distance = 60 AND b.Capacity = 20 AND b.Voltage = 48 LIMIT 1;",
        "step": "【step1】:【Calculate energy consumption per kilometer using formula (Voltage * Capacity)/Distance from Batteries table】  【step2】:【Filter records where Distance=60km, Capacity=20Ah, Voltage=48V】  【step3】:【Return EnergyPerKm (unit: Wh/km) via aliased column】  Note: The provided SQL incorrectly calculates energy consumption per km instead of solving the stated \"average charging power\" problem. To correctly calculate average power (kW), the formula should be `Energy_Used(kWh) / Charging_Time(hours)` using data from the **ChargingRecords** table. The current query structure and database usage are mismatched with the problem description.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1763,
        "question": "A user has 10 charging records in one month, with the electricity used in each record being 2kWh, 3kWh, 4kWh, 5kWh, 6kWh, 7kWh, 8kWh, 9kWh, 10kWh, and 11kWh. What is the total electricity consumption for this user in that month, and what is the average electricity consumed per charging session?",
        "query": "SELECT (b.Voltage * b.Capacity) / m.Power AS WorkingTime, m.Power / e.Weight AS PowerToWeightRatio FROM ElectricBikes e JOIN Motors m ON e.Bike_ID = m.Bike_ID JOIN Batteries b ON e.Bike_ID = b.Bike_ID WHERE b.Capacity = 1000 AND b.Voltage = 1000 AND m.Power = 10000 AND e.Weight = 1000;",
        "step": "【step1】: Perform INNER JOIN operations on ElectricBikes, Motors, and Batteries tables using Bike_ID as the foreign key.  【step2】: Filter records where battery capacity=1000Ah, voltage=1000V, motor power=10000W, and bike weight=1000kg.  【step3】: Calculate WorkingTime as (Voltage*Capacity)/Power and PowerToWeightRatio as Power/Weight for the filtered entries.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1764,
        "question": "A charging record shows that the energy used is 2 kWh, and the charging duration is 7200 seconds. What is the average power in kW?",
        "query": "SELECT Energy_Used / ((UNIX_TIMESTAMP(EndTime) - UNIX_TIMESTAMP(StartTime)) / 3600) AS AveragePower FROM ChargingRecords WHERE Energy_Used = 2 AND (UNIX_TIMESTAMP(EndTime) - UNIX_TIMESTAMP(StartTime)) = 7200;",
        "step": "【step1】: Calculate charging duration in hours by converting StartTime and EndTime to UNIX timestamps, subtracting them, and dividing by 3600.  【step2】: Divide Energy_Used (kWh) by the calculated duration to derive average power consumption rate (kW).  【step3】: Filter records where Energy_Used = 2 kWh and duration equals 7200 seconds (2 hours) to isolate specific charging sessions.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1765,
        "question": "Assuming a user has 1,000 charging records in a month, each record uses 100 kWh of electricity with a charging cost of 100 yuan. What is the user's total electricity consumption for this month? What is the total charging cost? If the cost per kWh is 1 yuan, is the user's electricity bill reasonable for this month?",
        "query": "SELECT SUM(Energy_Used) AS TotalEnergyUsed, AVG(Energy_Used) AS AverageEnergyPerCharge FROM ChargingRecords WHERE User_ID = 101 AND StartTime >= '2023-10-01 00:00:00' AND StartTime <= '2023-10-31 23:59:59';",
        "step": "【step1】:【Filter the charging records for User_ID 101 during October 2023 using WHERE clause on User_ID and StartTime】  【step2】:【Calculate total energy used with SUM(Energy_Used) and total charging cost with SUM(Cost)】  【step3】:【Verify cost reasonableness by comparing SUM(Cost) to SUM(Energy_Used)*1 (since 1元/kWh)】  (Note: The original query contains AVG(Energy_Used) which doesn't align with the stated problem requirements. A corrected query should use SUM for both energy and cost:  `SELECT SUM(Energy_Used) AS TotalEnergyUsed, SUM(Cost) AS TotalCost FROM ChargingRecords WHERE ...`  The answer assumes this logical correction while maintaining the requested analysis structure.)",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1766,
        "question": "The maintenance record for an e-bike shows a maintenance cost of 500 yuan with the description stating \"battery replacement\". What is the average cost for battery replacements?",
        "query": "SELECT Cost / Energy_Used AS CostPerKWh FROM ChargingRecords WHERE Cost = 10 AND Energy_Used = 5;",
        "step": "【step1】: Filter MaintenanceRecords where Description = '更换电池'  【step2】: Calculate average Cost using AVG() function on filtered records  【step3】: This query is invalid as shown - uses wrong table (ChargingRecords instead of MaintenanceRecords), incorrect calculations, and no aggregation needed for single-record average. Correct approach requires only 2 steps without complex operations.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1767,
        "question": "An electric bicycle has 12 maintenance records in a year, with maintenance costs of 100 yuan, 200 yuan, 300 yuan, 400 yuan, 500 yuan, 600 yuan, 700 yuan, 800 yuan, 900 yuan, 1000 yuan, 1100 yuan, and 1200 yuan for each instance respectively. What is the total annual maintenance cost for this electric bicycle? And what is the average cost per maintenance?",
        "query": "SELECT SUM(Energy_Used) AS TotalEnergyUsed, SUM(Cost) AS TotalCost, CASE WHEN SUM(Cost) = SUM(Energy_Used) * 1 THEN '合理' ELSE '不合理' END AS IsReasonable FROM ChargingRecords WHERE User_ID = 101 AND StartTime >= '2023-10-01 00:00:00' AND StartTime <= '2023-10-31 23:59:59';",
        "step": "【step1】: 【Filter charging records for User_ID 101 within October 2023 using WHERE clause】  【step2】: 【Calculate total energy used (SUM(Energy_Used)) and total cost (SUM(Cost)) from filtered records】  【step3】: 【Apply CASE statement to check if total cost equals total energy cost (1元/kWh) and assign '合理' or '不合理'】",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1768,
        "question": "When was the electric vehicle with Bike_ID 1 maintained for a battery replacement?",
        "query": "SELECT AVG(Cost) AS AverageCost FROM MaintenanceRecords WHERE Description = '更换电池' AND Bike_ID = 1;",
        "step": "【step1】: Filter MaintenanceRecords where Technician = '张师傅' and Bike_ID = 1.  【step2】: Select MaintenanceDate from the filtered records.  【step3】: No sorting/aggregation needed as the question asks for specific timestamp (Query provided is invalid - original Query calculates average cost of battery replacements, contradicting the actual question about maintenance time).",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1769,
        "question": "Assuming an electric scooter has 1,000 maintenance records in a year, with each maintenance costing 500 yuan and the maintenance description being battery replacement each time, what is the total maintenance cost for the electric scooter in that year? If the average cost of each battery replacement is 500 yuan, is the maintenance cost for this electric scooter reasonable?",
        "query": "SELECT SUM(Cost) AS TotalMaintenanceCost, AVG(Cost) AS AverageCostPerMaintenance FROM MaintenanceRecords WHERE Bike_ID = 1 AND Maintenance_Date >= '2023-01-01' AND Maintenance_Date <= '2023-12-31';",
        "step": "【step1】: Filter all maintenance records for Bike_ID = 1 within the year 2023 using the WHERE clause on BikeID and MaintenanceDate.  【step2】: Calculate the total maintenance cost by summing the Cost column and compute the average cost per maintenance using AVG(Cost).  【step3】: Return the aggregated results as TotalMaintenanceCost and AverageCostPerMaintenance.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1770,
        "question": "What is the maintenance date for the records where the technician is Master Zhang?",
        "query": "SELECT Maintenance_Date FROM MaintenanceRecords WHERE Technician = '张师傅';",
        "step": "【step1】: Analyze the core problem of calculating total power (10 slots * 7kW) which requires basic multiplication, but notice this is a pure arithmetic calculation unrelated to any tables in the database schema.  【step2】: Observe that the provided SQL query (SELECT Maintenance_Date FROM MaintenanceRecords WHERE Technician = '张师傅') only retrieves maintenance dates and has zero logical connection to the charging station power calculation problem.  【step3】: Conclude that neither the database schema nor the provided query contains charging_slot_power data or relevant relationships to support solving the stated problem through SQL operations.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1771,
        "question": "How much does it cost to maintain bike ID 201 for battery replacements in 2023, and is the total maintenance cost reasonable based on a standard cost of $500 per replacement?",
        "query": "SELECT SUM(Cost) AS TotalMaintenanceCost, CASE WHEN SUM(Cost) = 500 * COUNT(*) THEN '合理' ELSE '不合理' END AS IsReasonable FROM MaintenanceRecords WHERE Description = '更换电池' AND Bike_ID = 201 AND Maintenance_Date >= '2023-01-01' AND Maintenance_Date <= '2023-12-31';",
        "step": "【step1】: Filter MaintenanceRecords for battery replacements on Bike_ID 201 during 2023  【step2】: Calculate total cost (SUM) and count records, check if total equals 500 per entry  【step3】: Return aggregated cost with reasonableness evaluation using CASE statement",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1772,
        "question": "If a charging station has 10 available charging slots, each with a power of 7kW, what is the total power when the station simultaneously charges 10 electric vehicles?",
        "query": "SELECT 7 * Available_Slots AS TotalPower FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;",
        "step": "【step1】: Filter the ChargingStations table to find records where Available_Slots equals 10.  【step2】: Calculate the total power by multiplying 7 (kW per slot) with the Available_Slots value (10) for the filtered record.  【step3】: Return the total power result and limit the output to 1 row using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1773,
        "question": "If a charging station has 1,000 available charging slots, each with a power output of 1,000 kW, and each charging slot operates 24 hours a day, what is the total daily energy consumption of the charging station? How much is the daily electricity cost for the charging station, based on the cost per unit energy from the ChargingRecords table?",
        "query": "SELECT (7 * 8) * Available_Slots AS TotalEnergyConsumption FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;",
        "step": "【step1】: Retrieve the Available_Slots value (10) from ChargingStations table using WHERE clause  【step2】: Calculate daily energy consumption per slot using (7*8=56) - likely an error as it should be 1000kW*24h=24000kWh  【step3】: Multiply miscalculated per-slot consumption (56) by available slots (10) and alias as TotalEnergyConsumption, with LIMIT 1 to return single result  (Note: The actual correct calculation should be 1000 slots × 1000kW × 24h = 24,000,000 kWh energy consumption. The provided query contains fundamental errors in both logic and database schema usage.)",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1774,
        "question": "How many users registered in October 2023?",
        "query": "SELECT (7 * Available_Slots) / Available_Slots AS AverageChargingPower FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;",
        "step": "【step1】: Filter the Users table to only include records where the CreatedAt date falls within October 2023.  【step2】: Apply the COUNT() function to the filtered records to calculate the total number of users.  【step3】: No third step required as this is a straightforward aggregation without joins or complex nesting.  Correct Query:  SELECT COUNT(*) FROM Users WHERE YEAR(CreatedAt) = 2023 AND MONTH(CreatedAt) = 10;",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1775,
        "question": "How many pairs of distinct users have a registration time difference within one day, where the first user has a lower ID than the second?",
        "query": "SELECT (1000 * 24) * Available_Slots AS TotalEnergyConsumption, SUM(Cost) AS TotalCost FROM ChargingStations cs JOIN ChargingRecords cr ON cs.Station_ID = cr.Station_ID WHERE cs.Available_Slots = 1000 AND DATE(cr.StartTime) = '2023-10-01';",
        "step": "【step1】: Filter ChargingStations where Available_Slots = 1000.  【step2】: Join with ChargingRecords on Station_ID and filter records where StartTime is '2023-10-01'.  【step3】: Calculate TotalEnergyConsumption as (1000*24)*Available_Slots and sum Cost as TotalCost.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1776,
        "question": "How many users have distinct addresses who registered between October 1, 2023, and October 31, 2023?",
        "query": "SELECT COUNT(*) AS UserCount FROM users WHERE DATE(CreatedAt) >= '2023-10-01' AND DATE(CreatedAt) <= '2023-10-31';",
        "step": "【step1】: Filter records from users table where CreatedAt falls within October 2023.  【step2】: Count the number of distinct Address values in the filtered results.  【step3】: Return the calculated count as UserCount.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1777,
        "question": "If there is a user named Zhang San in Chaoyang District, Beijing, how many users registered within one day of his registration date (excluding Zhang San himself) are in the same district as him?",
        "query": "SELECT COUNT(DISTINCT u1.User_ID) AS UserCount FROM users u1 JOIN users u2 ON ABS(TIMESTAMPDIFF(DAY, u1.CreatedAt, u2.CreatedAt)) <= 1 AND u1.User_ID != u2.User_ID;",
        "step": "【step1】:【Self-join the users table (aliased as u1 and u2) with the condition that the absolute difference in their registration dates (CreatedAt) is ≤1 day】  【step2】:【Filter out rows where u1.User_ID equals u2.User_ID to exclude the same user】  【step3】:【Calculate the count of distinct User_ID values from u1 in the joined result】",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1778,
        "question": "A battery has a voltage of 48V and a capacity of 20Ah. How much electrical energy is stored in this battery?",
        "query": "SELECT COUNT(DISTINCT Address) AS DistinctRegionCount FROM users;",
        "step": "【step1】: Retrieve all unique addresses from the users table using DISTINCT.  【step2】: Count the number of unique addresses and alias the result as DistinctRegionCount.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1779,
        "question": "An electric scooter has a battery capacity of 20Ah with a voltage of 48V and a range of 60km. What is the energy consumption per kilometer?",
        "query": "SELECT COUNT(*) AS SameRegionUserCount FROM users WHERE Address = (SELECT Address FROM users WHERE Username = '张三');",
        "step": "【step1】: Retrieve the address of the user with Username '张三' using the subquery: `SELECT Address FROM users WHERE Username = '张三'`.  【step2】: Filter the users table to find all entries where the Address matches the result from the subquery.  【step3】: Count the number of matching users and return the result as `SameRegionUserCount`.",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "3",
        "idx": 1780,
        "question": "A battery has a capacity of 20Ah and a voltage of 48V. What is the energy (in watt-hours) of this battery?",
        "query": "SELECT Voltage * Capacity AS Energy FROM Batteries WHERE Voltage = 48 AND Capacity = 20;",
        "step": "【step1】: Filter records from Batteries table where Voltage equals 48V and Capacity equals 20Ah.  【step2】: Calculate stored energy by multiplying Voltage (48V) and Capacity (20Ah) to get 960Wh.  【step3】: Omitted in SQL (application-layer calculation: divide energy by motor power: 960Wh / 500W = 1.92 hours).",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "4",
        "idx": 1781,
        "question": "Assuming a battery has a capacity of 1000Ah and a voltage of 1000V, how much electrical energy does this battery store? If this battery is used to power a 10000W motor, how long can it support the motor?",
        "query": "SELECT (Voltage * Capacity) / Distance AS EnergyPerKm FROM Batteries WHERE Capacity = 20 AND Voltage = 48 AND Distance = 60;",
        "step": "【step1】: Filter records in Batteries table where Capacity=20, Voltage=48, and Distance=60  【step2】: Calculate \"(Voltage * Capacity) / Distance\" for the filtered records to derive EnergyPerKm  【step3】: Return the calculated EnergyPerKm value as the final result",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "1",
        "idx": 1782,
        "question": "Calculate the runtime for batteries with a capacity of 20 and voltage of 48.",
        "query": "SELECT (Voltage * Capacity) / 500 AS RunTime FROM Batteries WHERE Capacity = 20 AND Voltage = 48;",
        "step": "【step1】: Filter records from the Batteries table where Capacity is 20 AND Voltage is 48 using the WHERE clause.  【step2】: Calculate (Voltage * Capacity)/500 as RunTime for the filtered records.  【step3】: N/A (No sorting/joins required as the original query lacks ORDER BY and only involves direct calculation with WHERE filtering)",
        "format": "MySQL"
    },
    {
        "db_id": "electric_scooter",
        "type": "2",
        "idx": 1783,
        "question": "Calculate the number of items provided by each supplier, sorted in descending order by item count, and take the top 5.",
        "query": "SELECT Voltage * Capacity AS Energy, (Voltage * Capacity) / 10000 AS RunTime FROM Batteries WHERE Capacity = 1000 AND Voltage = 1000;",
        "step": "【step1】: Filter the Batteries table where Capacity = 1000 AND Voltage = 1000  【step2】: Calculate Energy (Voltage * Capacity) and RunTime ((Voltage * Capacity) / 10000) for the filtered records  【step3】: Output the calculated Energy and RunTime columns",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1784,
        "question": "Find all items in a specific area and list their item IDs, item names, specifications, and storage locations.",
        "query": "SELECT Devices.deviceId AS itemId, Devices.deviceName AS itemName, Devices.deviceType AS specification, Labs.location AS storageLocation FROM Devices JOIN Labs ON Devices.labId = Labs.labId WHERE Labs.location = '特定区域';",
        "step": "【step1】: Join Devices and Labs tables using labId to link device locations.  【step2】: Filter records where Labs.location matches the specified area.  【step3】: Select itemId (deviceId), itemName (deviceName), specification (deviceType), and storageLocation (Labs.location) from the joined result.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1785,
        "question": "Calculate the energy consumption efficiency for each device and identify the 5 devices with the lowest efficiency.",
        "query": "SELECT deviceId, (SUM(energyConsumed) / (SUM(powerUsage) * (MAX(julianday(timestamp)) - MIN(julianday(timestamp))) * 24) * 100 AS efficiency FROM EnergyConsumption GROUP BY deviceId ORDER BY efficiency ASC LIMIT 5;",
        "step": "【step1】: Calculate the energy efficiency for each device by summing energy consumed and power usage over the time duration between the earliest and latest timestamps, then compute the efficiency as (total_energy / (total_power * hours_interval)) * 100.  【step2】: Group the results by deviceId and sort them in ascending order of efficiency.  【step3】: Limit the sorted results to the 5 devices with the lowest efficiency values.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1786,
        "question": "Calculate the energy consumption fluctuation rate for each device and identify the top 10 devices with the highest fluctuation rates.",
        "query": "SELECT deviceId, (STDDEV(energyConsumed) / AVG(energyConsumed) * 100 AS fluctuationRate FROM EnergyConsumption GROUP BY deviceId ORDER BY fluctuationRate DESC LIMIT 10;",
        "step": "【step1】: Compute standard deviation and average energy consumption per device by grouping EnergyConsumption records with GROUP BY deviceId  【step2】: Calculate fluctuation rate using (STDDEV(energyConsumed)/AVG(energyConsumed))*100 for each device group  【step3】: Sort results by fluctuationRate in descending order and limit to top 10 devices using ORDER BY and LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1787,
        "question": "Calculate the number of items in each region, sorted in ascending order by item count, and take the first 5 entries.",
        "query": "SELECT location, COUNT(*) AS itemCount FROM EnergyManagementDB.EnergyDevices GROUP BY location ORDER BY itemCount ASC LIMIT 5;",
        "step": "【step1】: [GROUP BY location and count devices] Group the EnergyDevices table by the 'location' column and calculate the total number of devices in each group using COUNT(*).  【step2】: [ORDER BY itemCount ASC] Sort the grouped results in ascending order based on the computed itemCount.  【step3】: [LIMIT 5] Restrict the final output to the last 5 records (smallest counts) using LIMIT after sorting.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1788,
        "question": "Find all items with a status of 'Under Maintenance' and list their item names, specifications, and supplier names.",
        "query": "SELECT d.deviceName, d.deviceType, l.labName FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.status = '维护中';",
        "step": "【step1】: Filter devices with status '维护中' from Devices table  【step2】: Join filtered devices with Labs table via labId to get lab information  【step3】: Select required fields (deviceName, deviceType, labName) from the joined result  The original query contains an error: The problem specifies showing supplier names but the query selects labName instead. Proper implementation should JOIN Suppliers table via supplierId and select supplierName.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1789,
        "question": "Assuming the warranty period for all devices is extended by 10 years, calculate the total extended warranty days for each device type, then sort in descending order by total extended days and take the top 3.",
        "query": "SELECT d.deviceType, COUNT(d.deviceId) * 10 * 365 AS totalWarrantyExtensionDays FROM Devices d GROUP BY d.deviceType ORDER BY totalWarrantyExtensionDays DESC LIMIT 3;",
        "step": "【step1】: Group devices by deviceType and count the number of devices per group  【step2】: Calculate warranty extension days for each group using (device count × 10 × 365)  【step3】: Order results by totalWarrantyExtensionDays descending and limit to top 3",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1790,
        "question": "Calculate the number of days since the last calibration date for faulty devices, and sort them in ascending order by the number of days.",
        "query": "SELECT d.deviceName, d.deviceType, s.supplierName FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE d.status = '故障' ORDER BY DATEDIFF(NOW(), d.calibrationDate) ASC;",
        "step": "【step1】: Retrieve maintenance records with next maintenance date using LEAD window function partitioned by deviceId and ordered by maintenanceDate  【step2】: Calculate the interval days between current and next maintenance dates using DATEDIFF function  【step3】: Join with Devices table to get item details and apply ORDER BY on interval days",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1791,
        "question": "Calculate the number of distinct device types provided by each supplier, sort them in descending order by the count of distinct device types, and take the top 5.",
        "query": "SELECT s.supplierName, COUNT(DISTINCT d.deviceType) AS specificationCount FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierName ORDER BY specificationCount DESC LIMIT 5;",
        "step": "【step1】: Perform INNER JOIN between Suppliers and Devices tables using supplierId to associate suppliers with their provided devices  【step2】: Group the joined data by supplierName and calculate COUNT(DISTINCT deviceType) to get unique specification counts per supplier  【step3】: Order results by specificationCount descending and apply LIMIT 5 to retrieve top 5 suppliers",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1792,
        "question": "Find all devices that are under warranty and list their device name, device type, and warranty expiration date.",
        "query": "SELECT deviceName, deviceType, warrantyEndDate FROM Devices WHERE warrantyEndDate >= CURDATE();",
        "step": "【step1】: Select itemName (as deviceName), specifications (as deviceType), warrantyEndDate columns from Devices table.  【step2】: Filter records where warrantyEndDate is equal to or later than current date using CURDATE() comparison.  【step3】: Output results with device name, specifications, and valid warranty expiration date.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1793,
        "question": "Assuming the maintenance cost of all items is 1000, calculate the total maintenance cost for each supplier, then sort them in descending order by total maintenance cost and take the top 3.",
        "query": "SELECT s.supplierId, COUNT(d.deviceType) * 1000 AS totalMaintenanceCost FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierId ORDER BY totalMaintenanceCost DESC LIMIT 3;",
        "step": "【step1】: Join Devices and Suppliers tables to associate each device with its supplier  【step2】: Group by supplierId and calculate total maintenance cost as COUNT(deviceType) × 1000  【step3】: Order results by totalMaintenanceCost descending and limit to top 3 records",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1794,
        "question": "Calculate the total warranty days for devices from the purchase date to the warranty end date, and sort them in descending order by total warranty days.",
        "query": "SELECT deviceName, deviceType, DATEDIFF(warrantyEndDate, purchaseDate) AS totalWarrantyDays FROM Devices ORDER BY totalWarrantyDays DESC;",
        "step": "【step1】: SELECT deviceName, deviceType, DATEDIFF(warrantyEndDate, purchaseDate) AS totalWarrantyDays FROM Devices  【step2】: Apply ORDER BY totalWarrantyDays DESC to sort results",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1795,
        "question": "Calculate the number of devices for each country and sort them in ascending order by device count, then take the top 5.",
        "query": "SELECT m.country, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.country ORDER BY deviceCount ASC LIMIT 5;",
        "step": "【step1】: Perform INNER JOIN between EnergyDevices and Manufacturers tables using manufacturerId to associate devices with their country information.  【step2】: Group results by country and calculate device count using COUNT(e.deviceId) aggregation.  【step3】: Sort grouped results in ascending order by deviceCount and limit output to 5 rows using LIMIT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1796,
        "question": "Find all items with the status 'Disabled', and list their item name, specifications, and storage location.",
        "query": "SELECT itemName, specifications, storageLocation FROM Devices WHERE status = '停用';",
        "step": "【step1】: Select required columns (itemName, specifications, storageLocation) from Devices table  【step2】: Apply filter condition WHERE status = '停用' to identify inactive items  【step3】: (Not required for this simple query)",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1797,
        "question": "Assuming the maintenance cost of all items is reduced by 90%, calculate the total maintenance cost for each supplier after the reduction, sort them in ascending order by total maintenance cost, and take the top 3.",
        "query": "SELECT d.supplierId, SUM(dt.maintenanceCost) * 0.1 AS totalMaintenanceCost FROM Devices d JOIN DeviceTypes dt ON d.deviceType = dt.deviceType GROUP BY d.supplierId ORDER BY totalMaintenanceCost ASC LIMIT 3;",
        "step": "【step1】: JOIN Devices and DeviceTypes tables to associate each device with its maintenance cost  【step2】: Aggregate maintenance costs per supplier after applying 90% reduction (multiply by 0.1)  【step3】: Sort suppliers by total reduced maintenance cost in ascending order and limit to top 3",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1798,
        "question": "Calculate the number of days inactive devices have gone without maintenance from their last calibration date to the current date, and sort them in descending order by the number of days without maintenance.",
        "query": "SELECT d.deviceName, DATEDIFF(CURDATE(), d.calibrationDate) AS unmaintainedDays FROM Devices d WHERE d.status = '停用' ORDER BY unmaintainedDays DESC;",
        "step": "【step1】: Filter devices with '停用' status using WHERE clause on d.status  【step2】: Calculate date difference between CURDATE() and calibrationDate using DATEDIFF function  【step3】: Sort results by calculated unmaintainedDays in DESC order via ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1799,
        "question": "Calculate the number of devices from each manufacturer, sort them in descending order by the number of devices, and take the top 5.",
        "query": "SELECT m.manufacturerName, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.manufacturerName ORDER BY deviceCount DESC LIMIT 5;",
        "step": "【step1】: Perform INNER JOIN between EnergyDevices and Manufacturers using manufacturerId to link device records with their corresponding manufacturer information.  【step2】: Group the joined results by manufacturerName and calculate device count per manufacturer using COUNT(e.deviceId).  【step3】: Sort results by deviceCount in descending order and apply LIMIT 5 to retrieve top 5 manufacturers.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1800,
        "question": "Find all items provided by a specific supplier (such as 'a certain supplier') and list their item names, specifications, and purchase dates.",
        "query": "SELECT d.itemName, d.purchaseDate FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE s.supplierName = '某供应商';",
        "step": "【step1】: Join the Devices and Suppliers tables using the supplierId to link the relevant supplier information.  【step2】: Filter the joined data to retain only records where the supplierName matches '某供应商'.  【step3】: Select the itemName and purchaseDate fields from the filtered results.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1801,
        "question": "Assuming the warranty period for each device is shortened by 50%, calculate the total number of days reduced across all devices for each supplier, then sort them in descending order by total reduced days and take the top 3.",
        "query": "SELECT d.supplierId, SUM(DATEDIFF(d.warrantyEndDate, d.purchaseDate) * 0.5) AS totalWarrantyReduction FROM Devices d GROUP BY d.supplierId ORDER BY totalWarrantyReduction DESC LIMIT 3;",
        "step": "【step1】: Calculate the original warranty days per device using DATEDIFF(warrantyEndDate, purchaseDate), then apply 50% reduction by multiplying with 0.5  【step2】: Aggregate total warranty reduction days per supplier using GROUP BY supplierId and SUM()  【step3】: Sort results by totalWarrantyReduction in DESC order and limit to top 3 records using ORDER BY + LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1802,
        "question": "Show the device names, purchase dates, and energy consumption values for all devices, sorted from highest to lowest energy consumption.",
        "query": "SELECT i.itemName, i.purchaseDate, i.energyConsumption FROM Devices i ORDER BY i.energyConsumption DESC;",
        "step": "【step1】: Join Devices table with EnergyConsumption table using deviceId to access actual consumption records  【step2】: Calculate daily average energy consumption using AVG(energyConsumed) grouped by deviceId and consumptionDate  【step3】: Convert result to kilowatt-hours (kWh), sort by average consumption DESC",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1803,
        "question": "Calculate the total energy consumption for each device type, ranked in ascending order of total energy consumption, and take the top 3.",
        "query": "SELECT s.supplierName, SUM((i.warrantyPeriod * 0.5)) AS totalShortenedDays FROM Devices i JOIN Suppliers s ON i.supplierId = s.supplierId GROUP BY s.supplierName ORDER BY totalShortenedDays DESC LIMIT 3;",
        "step": "【step1】: JOIN Devices and EnergyConsumption tables via deviceId to combine device types with their energy consumption records.  【step2】: GROUP BY deviceType and SUM(energyConsumed to calculate total energy consumption per device type.  【step3】: ORDER BY total energy consumption ASC and LIMIT 3 to get the top 3 least consuming device types.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1804,
        "question": "Find all devices with a power rating greater than 100 and list their device name, device type, and power rating.",
        "query": "SELECT deviceName, deviceType, powerRating FROM EnergyDevices WHERE powerRating > 100 ORDER BY powerRating DESC;",
        "step": "【step1】: Select deviceName, deviceType, and powerRating columns from EnergyDevices table  【step2】: Filter records where powerRating exceeds 100 watts  【step3】: Sort remaining results in descending order by powerRating",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1805,
        "question": "Assuming the rated power of all devices increases tenfold, calculate the total energy consumed for each device type, sorted in descending order by total energy consumed, and take the top 5.",
        "query": "SELECT deviceType, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;",
        "step": "【step1】: Join the `EnergyConsumption` table with `EnergyDevices` using `deviceId` to associate energy records with device types.  【step2】: Group records by `deviceType` and calculate the sum of `energyConsumed` for each group.  【step3】: Sort the grouped results by `totalEnergyConsumed` in descending order and limit the output to the top 5 results.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1806,
        "question": "Show the names, types, and power values for devices with power consumption exceeding 100 watts, sorted from highest to lowest power.",
        "query": "SELECT deviceName, deviceType, power FROM Devices WHERE power > 100 ORDER BY power DESC;",
        "step": "【step1】: Filter records from Devices table where power exceeds 100 watts using WHERE clause  【step2】: Select required columns (deviceName, deviceType, power) for qualifying devices  【step3】: Sort the results in descending order of power using ORDER BY power DESC",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1807,
        "question": "Count the number of devices for each supplier, sort in descending order by device count, and take the top 5.",
        "query": "SELECT supplierId, COUNT(*) AS deviceCount FROM Devices GROUP BY supplierId ORDER BY deviceCount DESC LIMIT 5;",
        "step": "【step1】: Group records in Devices table by supplierId and count the number of devices per group using COUNT(*)  【step2】: Sort the grouped results by deviceCount in descending order  【step3】: Apply LIMIT 5 to retain only the top 5 manufacturers with highest device counts",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1808,
        "question": "Find all devices with a status of 'fault' and list their device names, device types, and installation dates.",
        "query": "SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = '故障';",
        "step": "【step1】: Access the Devices table containing equipment information  【step2】: Filter records where the status field equals '故障' (faulty condition)  【step3】: Extract deviceName, deviceType, and installationDate fields from the filtered results",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1809,
        "question": "Assuming the energy consumption value of all devices is increased by 100 times, calculate the total energy consumption for each device type, sort by total energy consumption in descending order, and take the top 3.",
        "query": "SELECT deviceType, SUM(power * 100) AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Multiply each device's power by 100 and calculate the total energy consumption per device type using GROUP BY aggregation.  【step2】: Apply descending sorting based on the calculated total energy consumption values.  【step3】: Restrict results to the top 3 entries using LIMIT clause after sorting.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1810,
        "question": "Calculate the total current for each device name and device type, sorted in descending order by total current value.",
        "query": "SELECT deviceName, deviceType, SUM(current) AS totalCurrent FROM Devices GROUP BY deviceName, deviceType ORDER BY totalCurrent DESC;",
        "step": "【step1】: Select deviceName, deviceType, and current values from the Devices table  【step2】: Group records by deviceName and deviceType, calculate SUM(current) as totalCurrent for each group  【step3】: Sort the results in descending order based on totalCurrent",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1811,
        "question": "Calculate the average energy consumption for each device type, sort them in ascending order by average energy consumption, and take the first 5 entries.",
        "query": "SELECT deviceType, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY avgEnergyConsumed ASC LIMIT 5;",
        "step": "【step1】: Perform INNER JOIN between EnergyConsumption and EnergyDevices tables using deviceId to associate consumption records with device types.  【step2】: Group results by deviceType and calculate average energy consumption using AVG(energyConsumed).  【step3】: Sort groups by avgEnergyConsumed in ascending order and apply LIMIT 5 to retrieve the bottom 5 entries with lowest average consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1812,
        "question": "Find all equipment installed for more than 5 years and list their equipment name, equipment type, and installation date.",
        "query": "SELECT deviceName, deviceType, installationDate FROM Devices WHERE DATEDIFF(CURRENT_DATE, installationDate) > 5 * 365;",
        "step": "【step1】: Select deviceName, deviceType, installationDate columns FROM Devices table  【step2】: Apply WHERE clause filtering records where the difference between CURRENT_DATE and installationDate exceeds 5 years (calculated as 5*365 days)",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1813,
        "question": "Assuming the real-time voltage of all devices increases by five times, calculate the total energy consumption for each device type, sorted in descending order by total energy consumption, and take the top 3.",
        "query": "SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Perform an INNER JOIN between EnergyConsumption and EnergyDevices tables using deviceId to associate consumption data with device types.  【step2】: Calculate adjusted total energy consumption by multiplying each energyConsumed value by 5, then aggregate using SUM() grouped by deviceType.  【step3】: Sort results by totalEnergyConsumed in descending order and apply LIMIT 3 to return top-ranked device types.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1814,
        "question": "Calculate the real-time power factor for all devices (assuming a power factor of 0.8) and sort them in ascending order by power factor value.",
        "query": "SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;",
        "step": "【step1】: Select device names, types and apply static 0.8 power factor value  【step2】: Sort results by the calculated power factor column in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1815,
        "question": "Calculate the total maintenance cost for each device type, sorted in descending order of maintenance cost, and take the top 5.",
        "query": "SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;",
        "step": "【step1】: Join MaintenanceRecords and EnergyDevices tables using deviceId to associate maintenance costs with device types.  【step2】: Group the joined data by deviceType and calculate the sum of cost for each group as totalMaintenanceCost.  【step3】: Order the result by totalMaintenanceCost in descending order and limit the output to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1816,
        "question": "Find all devices with temperature sensor data above 50 or below -20, and list their device names, device types, and temperature values.",
        "query": "SELECT deviceName, deviceType, temperature FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId WHERE temperature > 50 OR temperature < -20 ORDER BY temperature;",
        "step": "【step1】: Perform an INNER JOIN between EnergyConsumption and EnergyDevices tables using deviceId to combine sensor data with device metadata.  【step2】: Apply WHERE filter to select records where temperature exceeds 50 or drops below -20, identifying abnormal sensor readings.  【step3】: Sort the final results by temperature value in ascending order using ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1817,
        "question": "Assuming the maintenance cost of all devices increases by a factor of 1000, calculate the total maintenance cost for each device type, then sort them in descending order by total maintenance cost and take the top 3.",
        "query": "SELECT deviceType, SUM(cost * 1000) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;",
        "step": "【step1】: Perform INNER JOIN between MaintenanceRecords and EnergyDevices tables using deviceId to associate maintenance costs with device types.  【step2】: Calculate scaled total maintenance cost by multiplying individual costs by 1000 and aggregating per deviceType using SUM(cost * 1000) with GROUP BY deviceType.  【step3】: Order results by totalMaintenanceCost in descending order and limit output to top 3 records using ORDER BY and LIMIT clauses.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1818,
        "question": "Calculate the ratio of power usage to power rating for all devices, and sort them in descending order by the ratio.",
        "query": "SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerRatio DESC;",
        "step": "【step1】: Join EnergyConsumption with EnergyDevices on deviceId to access real-time power usage (powerUsage) and rated power (powerRating).  【step2】: Calculate powerRatio by dividing powerUsage by powerRating for each device.  【step3】: Order results by powerRatio in descending sequence using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1819,
        "question": "Calculate the average energy consumption of devices per manufacturer, sort them in ascending order by average energy consumption, and take the top 5.",
        "query": "SELECT manufacturerId, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY manufacturerId ORDER BY avgEnergyConsumed ASC LIMIT 5;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables via deviceId to link consumption data with manufacturer information  【step2】: Group results by manufacturerId and calculate average energy consumption per manufacturer  【step3】: Order results by average consumption in ascending order and select last 5 entries using LIMIT 5 after sorting",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1820,
        "question": "Find all devices with abnormal humidity sensor data, and list their device names, device types, and sensor data values.",
        "query": "SELECT deviceName, deviceType, humidity FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId WHERE humidity < 0 OR humidity > 100 ORDER BY humidity DESC;",
        "step": "【step1】: Perform an INNER JOIN between the EnergyConsumption and EnergyDevices tables using deviceId to combine sensor data with device metadata.  【step2】: Filter records where humidity values fall outside the valid range (humidity < 0 OR humidity > 100) to identify abnormal sensor readings.  【step3】: Sort the results by humidity in descending order and project deviceName, deviceType, and humidity values for final output.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1821,
        "question": "Assuming the energy consumption of all devices is reduced by 90%, calculate the total energy consumption for each device type, then sort them in descending order of total energy consumption and take the top 3.",
        "query": "SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Join the 'EnergyConsumption' and 'EnergyDevices' tables using the 'deviceId' field to associate consumption records with device types.  【step2】: Calculate the adjusted total energy consumption per device type by summing 10% (90% reduction) of the original 'energyConsumed' values via GROUP BY.  【step3】: Order the results by totalEnergyConsumed in descending order and retain only the top 3 entries using LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1822,
        "question": "Calculate the difference between power usage and power rating for all devices, and sort the results in descending order by the difference.",
        "query": "SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerDifference DESC;",
        "step": "【step1】: Perform an INNER JOIN between `EnergyConsumption` and `EnergyDevices` tables using the shared `deviceId` to combine real-time power usage and rated power data.  【step2】: Calculate the difference between `powerUsage` (from `EnergyConsumption`) and `powerRating` (from `EnergyDevices`), aliasing the result as `powerDifference`.  【step3】: Sort the final result set in descending order based on `powerDifference` using `ORDER BY powerDifference DESC`.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1823,
        "question": "Calculate the total number of devices under maintenance or faulty for each device type, sorted in descending order by maintenance count, and take the top 5.",
        "query": "SELECT deviceType, COUNT(deviceId) AS maintenanceCount FROM Devices WHERE status IN ('维护中', '故障') GROUP BY deviceType ORDER BY maintenanceCount DESC LIMIT 5;",
        "step": "【step1】: Filter devices with status '维护中' or '故障' using WHERE clause.  【step2】: Group filtered records by deviceType and calculate COUNT(deviceId) as maintenanceCount.  【step3】: Sort groups by maintenanceCount DESC and limit output to top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1824,
        "question": "Find all equipment whose last maintenance date exceeds one year, and list their equipment name, equipment type, and last maintenance date.",
        "query": "SELECT deviceName, deviceType, lastMaintenanceDate FROM EnergyDevices JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId WHERE DATEDIFF(CURRENT_DATE, lastMaintenanceDate) > 365 ORDER BY lastMaintenanceDate DESC;",
        "step": "【step1】: Perform an INNER JOIN between EnergyDevices and MaintenanceRecords tables using deviceId to combine device information with maintenance records.  【step2】: Filter the joined data using WHERE clause with DATEDIFF(CURRENT_DATE, lastMaintenanceDate) > 365 to isolate devices exceeding 1 year since last maintenance.  【step3】: Sort the filtered results by lastMaintenanceDate in descending order using ORDER BY for chronological clarity.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1825,
        "question": "Assuming the maintenance count for all devices is increased by 100 times, calculate the total maintenance count for each device type, sort in descending order of total maintenance count, and take the top 3.",
        "query": "SELECT deviceType, COUNT(maintenanceId) * 100 AS totalMaintenanceCount FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCount DESC LIMIT 3;",
        "step": "【step1】: Join MaintenanceRecords with EnergyDevices on deviceId to associate each maintenance record with its device type.  【step2】: Group by deviceType and calculate total maintenance count per type by multiplying COUNT(maintenanceId) by 100.  【step3】: Order results by totalMaintenanceCount descending and limit output to top 3 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1826,
        "question": "Calculate the percentage of real-time power to rated power for all devices, and sort them in descending order by percentage.",
        "query": "SELECT d.deviceName, d.deviceType, (ec.powerUsage / d.powerRating) * 100 AS powerPercentage FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId ORDER BY powerPercentage DESC;",
        "step": "【step1】: Perform INNER JOIN between EnergyConsumption and EnergyDevices tables using deviceId to combine real-time power usage with device specifications.  【step2】: Calculate powerPercentage by dividing powerUsage from EnergyConsumption by powerRating from EnergyDevices, then multiply by 100.  【step3】: Sort results by the derived powerPercentage column in descending order using ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1827,
        "question": "Calculate the ratio of total energy consumption to total maintenance cost for each device type, sort them in ascending order by the ratio, and select the top 5.",
        "query": "SELECT d.deviceType, SUM(ec.energyConsumed) / SUM(mr.cost) AS energyToCostRatio FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId JOIN MaintenanceRecords mr ON mr.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY energyToCostRatio ASC LIMIT 5;",
        "step": "【step1】: Join EnergyConsumption, EnergyDevices, and MaintenanceRecords tables on deviceId to associate device types with their energy consumption and maintenance cost data.  【step2】: Group by deviceType to calculate the ratio of total energyConsumed (SUM(ec.energyConsumed)) to total maintenance cost (SUM(mr.cost)) for each device type.  【step3】: Order results by the calculated ratio in ascending order and limit output to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1828,
        "question": "Find all devices with temperatures higher than 30°C, and list their device names, device types, and temperature values.",
        "query": "SELECT d.deviceName, d.deviceType, ec.temperature FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId WHERE ec.temperature > 30 ORDER BY ec.temperature DESC;",
        "step": "【step1】: Join the 'EnergyConsumption' and 'EnergyDevices' tables using deviceId to combine temperature data with device metadata.  【step2】: Apply WHERE filter to select records where temperature exceeds 30°C.  【step3】: Sort results by temperature in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1829,
        "question": "Calculate the total energy consumption for each device type, sort them in descending order by total energy consumption, and take the top 3.",
        "query": "SELECT d.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables via deviceId to associate consumption records with device types.  【step2】: Group results by deviceType and sum energyConsumed to calculate totalEnergyConsumed for each group.  【step3】: Sort grouped results by totalEnergyConsumed in descending order and limit output to the top 3 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1830,
        "question": "Calculate the squared ratio of the power usage to the power rating for all devices, and sort the results in descending order by the squared ratio.",
        "query": "SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerSquareRatio DESC;",
        "step": "【step1】: Join the EnergyConsumption table with the EnergyDevices table via deviceId to link real-time power data with rated power values.  【step2】: Compute the squared ratio (powerUsage/powerRating)² for each device using the POWER function and alias it as powerSquareRatio.  【step3】: Order the final results by powerSquareRatio in descending sequence using the ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1831,
        "question": "Calculate the ratio of total energy consumed to the number of maintenance records for each device type, sort in ascending order by the ratio, and take the first 5.",
        "query": "SELECT d.deviceType, SUM(ec.energyConsumed) / COUNT(mr.maintenanceId) AS energyMaintenanceRatio FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId JOIN MaintenanceRecords mr ON ec.deviceId = mr.deviceId GROUP BY d.deviceType ORDER BY energyMaintenanceRatio ASC LIMIT 5;",
        "step": "【step1】: Join EnergyConsumption, EnergyDevices, and MaintenanceRecords tables on deviceId to associate energy consumption and maintenance records with device types.  【step2】: Group by deviceType, calculate total energy consumed (SUM(ec.energyConsumed)) and total maintenance count (COUNT(mr.maintenanceId)), then compute their ratio.  【step3】: Order results by energyMaintenanceRatio in ascending order and limit to the top 5 records.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1832,
        "question": "Find all devices with humidity below 20% and list their device names, device types, and humidity values.",
        "query": "SELECT d.deviceName, d.deviceType, d.humidity FROM EnergyDevices d WHERE d.humidity < 20 ORDER BY d.humidity ASC;",
        "step": "【step1】: Select deviceName, deviceType, and humidity fields from EnergyDevices table  【step2】: Filter records where humidity value is less than 20% using WHERE clause  【step3】: Sort the results in ascending order of humidity using ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1833,
        "question": "Assuming the energy consumption values of all devices increased by 80%, calculate the total energy consumption for each device type, sort them in descending order by total energy consumption, and take the top 3.",
        "query": "SELECT deviceType, SUM(energyConsumed * (1 + 0.8)) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Join the `EnergyConsumption` and `EnergyDevices` tables using `deviceId` to link consumption records with device types.  【step2】: Calculate the adjusted energy consumption (original value multiplied by 1.8) for each record, then group by `deviceType` and sum the adjusted values as `totalEnergyConsumed`.  【step3】: Sort the grouped results by `totalEnergyConsumed` in descending order and retain only the top 3 entries using `LIMIT 3`.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1834,
        "question": "Calculate the cubic ratio between the current power usage and rated power of all devices, and sort them in descending order by the cubic ratio.",
        "query": "SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerCubicRatio DESC;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables via deviceId to access real-time powerUsage (EnergyConsumption) and rated powerRating (EnergyDevices).  【step2】: Calculate cubic ratio using POWER(powerUsage/powerRating, 3) and alias as powerCubicRatio.  【step3】: Sort results by powerCubicRatio in descending order with ORDER BY powerCubicRatio DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1835,
        "question": "Calculate the square ratio of the total energy consumption (multiplied by 1.8) to the square of the total maintenance cost for each device type, sort the results in ascending order by the square ratio, and take the top 5.",
        "query": "SELECT deviceType, SUM(energyConsumed * 1.8) / POWER(SUM(cost), 2) AS energyMaintenanceRatioSquare FROM EnergyConsumption JOIN MaintenanceRecords ON EnergyConsumption.deviceId = MaintenanceRecords.deviceId JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY energyMaintenanceRatioSquare ASC LIMIT 5;",
        "step": "【step1】: Join EnergyConsumption, MaintenanceRecords, and EnergyDevices tables using deviceId to associate energy consumption data with maintenance costs and device type information.  【step2】: Group results by deviceType, calculate SUM(energyConsumed * 1.8) for total adjusted energy consumption and SUM(cost) for total maintenance cost. Compute the ratio energyMaintenanceRatioSquare using the formula SUM(energyConsumed * 1.8)/POWER(SUM(cost),2).  【step3】: Sort the calculated ratios in ascending order using ORDER BY energyMaintenanceRatioSquare ASC and limit results to the top 5 entries with LIMIT 5.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1836,
        "question": "Find all devices with voltage below 200V, and list their device names, device types, and voltage values.",
        "query": "SELECT deviceName, deviceType, voltage FROM EnergyDevices WHERE voltage < 200 ORDER BY voltage DESC;",
        "step": "【step1】: Filter records from EnergyDevices table where voltage is less than 200 using the WHERE clause  【step2】: Sort the filtered results in descending order of voltage using ORDER BY  【step3】: Select specific columns (deviceName, deviceType, voltage) for final output",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1837,
        "question": "Assuming the energy consumption value of all devices is increased by a factor of 500, calculate the total energy consumption for each device type, sort in descending order by total energy consumption, and take the top 3.",
        "query": "SELECT deviceType, SUM(energyConsumed * 500) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Perform an INNER JOIN between EnergyConsumption and EnergyDevices using deviceId to link consumption records with device types.  【step2】: Calculate adjusted total energy consumption by multiplying each energyConsumed value by 500 and summing per deviceType via GROUP BY.  【step3】: Sort results in descending order by totalEnergyConsumed and select top 3 entries using ORDER BY and LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1838,
        "question": "Calculate the fourth power ratio of the real-time power to the rated power for all devices, and sort them in descending order by the fourth power ratio.",
        "query": "SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerFourthRatio DESC;",
        "step": "【step1】: Perform INNER JOIN between EnergyConsumption and EnergyDevices tables using deviceId to combine real-time power data with device specifications  【step2】: Calculate the fourth power ratio using POWER(powerUsage/powerRating, 4) for each device and alias it as powerFourthRatio  【step3】: Sort results in descending order by the calculated powerFourthRatio using ORDER BY clause",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1839,
        "question": "Calculate the ratio of total energy consumption to the cube of total maintenance times for each device type, sorted in ascending order by the cube ratio, and take the top 5.",
        "query": "SELECT deviceType, (SUM(energyConsumed) / POW(COUNT(maintenanceId), 3)) AS energyMaintenanceCubeRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId GROUP BY deviceType ORDER BY energyMaintenanceCubeRatio ASC LIMIT 5;",
        "step": "【step1】: JOIN EnergyConsumption, EnergyDevices, and MaintenanceRecords tables using deviceId to associate energy consumption data with maintenance records for each device.  【step2】: Group by deviceType, calculate total energyConsumed (SUM) and total maintenance count (COUNT), then compute the ratio of energy to the cube of maintenance count.  【step3】: Order results by energyMaintenanceCubeRatio in ascending order and limit output to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1840,
        "question": "Find all devices with current above 10 and list their device name, device type, and current value.",
        "query": "SELECT deviceName, deviceType, current FROM EnergyDevices WHERE current > 10 ORDER BY current DESC;",
        "step": "【step1】: Retrieve deviceName, deviceType, and current columns from the EnergyDevices table.  【step2】: Apply the filter condition to select only records where current exceeds 10A (current > 10).  【step3】: Sort the results in descending order based on the current value using ORDER BY current DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1841,
        "question": "Assuming the current value of all devices increases by 50A, calculate the total energy consumption for each device type, sort them in descending order by total energy consumption, and take the top 3.",
        "query": "SELECT deviceType, POWER(SUM(energyConsumed) / COUNT(maintenanceId), 3) AS energyMaintenanceCubicRatio FROM EnergyConsumption JOIN MaintenanceRecords ON EnergyConsumption.deviceId = MaintenanceRecords.deviceId JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY energyMaintenanceCubicRatio DESC LIMIT 5;",
        "step": "【step1】:Join EnergyConsumption, MaintenanceRecords, and EnergyDevices tables using deviceId to access energyConsumed, maintenanceId, and deviceType data.  【step2】:Group by deviceType, calculate POWER(SUM(energyConsumed)/COUNT(maintenanceId),3) as energyMaintenanceCubicRatio.  【step3】:Sort results by energyMaintenanceCubicRatio in descending order and limit to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1842,
        "question": "Calculate the daily average energy consumption (in kilowatt-hours) for each device, sorted in descending order by daily average energy consumption value.",
        "query": "SELECT deviceId, deviceName, SUM(energyConsumed) / DATEDIFF(CURRENT_DATE, installationDate) AS dailyAvgEnergyConsumed FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId GROUP BY deviceId, deviceName ORDER BY dailyAvgEnergyConsumed DESC;",
        "step": "【step1】: Join the EnergyConsumption and EnergyDevices tables using deviceId to link consumption records with device metadata.  【step2】: Group the joined data by deviceId and deviceName, calculate total energy consumed (SUM) and days since installation (DATEDIFF), then derive daily average by dividing total energy by days.  【step3】: Sort the grouped results by dailyAvgEnergyConsumed in descending order to display devices with highest average consumption first.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1843,
        "question": "Calculate the total energy consumption for each device type, sort in ascending order by total energy consumption, and take the top 3.",
        "query": "SELECT deviceType, SUM(current * 5 * voltage * 24 / 1000) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed ASC LIMIT 3;",
        "step": "【step1】: JOIN EnergyConsumption and EnergyDevices tables via deviceId to associate consumption data with device types  【step2】: Calculate total energy consumption per deviceType using SUM(current*5*voltage*24/1000) formula and group by deviceType  【step3】: Sort results by totalEnergyConsumed in ascending order and limit output to top 3 records",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1844,
        "question": "Find all devices with a power rating greater than 100, and list their device name, device type, and power rating.",
        "query": "SELECT EnergyDevices.deviceId, EnergyDevices.deviceName, SUM(EnergyConsumption.energyConsumed) / DATEDIFF(CURRENT_DATE, EnergyDevices.installationDate) AS dailyAvgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY EnergyDevices.deviceId, EnergyDevices.deviceName ORDER BY dailyAvgEnergyConsumed DESC;",
        "step": "【step1】: Perform INNER JOIN between `EnergyConsumption` and `EnergyDevices` tables using `deviceId` to combine consumption data with device metadata.  【step2】: Group joined data by `deviceId` and `deviceName`, then calculate `dailyAvgEnergyConsumed` via `SUM(energyConsumed) / DATEDIFF(CURRENT_DATE, installationDate)` aggregation.  【step3】: Sort results in descending order by the calculated `dailyAvgEnergyConsumed` value.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1845,
        "question": "Assuming the rated power of all devices is increased by 10 times, calculate the total energy consumption for each device type, sort them in descending order by total energy consumption, and take the top 5.",
        "query": "SELECT ed.deviceType, SUM(ec.energyConsumed * (ed.powerRating * 10) / ed.powerRating) AS totalEnergyConsumed FROM EnergyConsumption AS ec JOIN EnergyDevices AS ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;",
        "step": "【step1】: Join EnergyConsumption (ec) and EnergyDevices (ed) tables on deviceId to associate energy consumption records with device metadata.  【step2】: Calculate adjusted total energy consumption per deviceType by scaling each device's energyConsumed by 10x (via SUM(ec.energyConsumed * 10)), leveraging the mathematical simplification of the powerRating adjustment.  【step3】: Group results by deviceType, sort by totalEnergyConsumed in descending order, and limit output to the top 5 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1846,
        "question": "Calculate the total power (in watts) for all devices and sort them in descending order by total power.",
        "query": "SELECT SUM(ed.measurementValue) AS totalPower FROM Devices d JOIN ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = '瓦特';",
        "step": "【step1】: Join Devices and ExperimentData tables using deviceId to associate devices with their measurements  【step2】: Filter records where the measurement unit is '瓦特' (Watts) to ensure correct power value selection  【step3】: Aggregate results using SUM() on measurementValue and alias the output as totalPower",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1847,
        "question": "Count the number of devices for each supplier, sort them in descending order by device count, and take the top 5.",
        "query": "SELECT deviceType, COUNT(*) AS deviceCount FROM Devices GROUP BY deviceType ORDER BY deviceCount DESC LIMIT 5;",
        "step": "【step1】: Retrieve deviceType and count devices for each type from Devices table using GROUP BY  【step2】: Sort the aggregated results by deviceCount in descending order  【step3】: Apply LIMIT 5 to get the top 5 manufacturers by device quantity",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1848,
        "question": "Find all devices with a status of 'Fault', and list their device names, device types, and installation dates.",
        "query": "SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = '故障';",
        "step": "【step1】: Retrieve deviceName, deviceType, installationDate, and status fields from the Devices table  【step2】: Filter records where the status field equals '故障' and retain only the deviceName, deviceType, and installationDate fields",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1849,
        "question": "Assuming the energy consumption value of each device is multiplied by 100, calculate the total energy consumption per device type, sort it in descending order by total energy consumption, and take the top 3.",
        "query": "SELECT deviceType, COUNT(*) * 100 AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Join Devices table with EnergyConsumption table via deviceId to access actual energy values  【step2】: Group by deviceType and calculate SUM(energyConsumed)*100 for total energy  【step3】: Order aggregated results by totalEnergyConsumed DESC and apply LIMIT 3",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1850,
        "question": "Calculate the total real-time current (in amperes) for each device type, and sort in descending order by current value.",
        "query": "SELECT deviceType, COUNT(*) * 10 AS totalCurrent FROM Devices GROUP BY deviceType ORDER BY totalCurrent DESC;",
        "step": "【step1】: Group records by deviceType and calculate total current by multiplying the count of devices in each group by 10  【step2】: Assign the calculated value an alias \"totalCurrent\"  【step3】: Sort the results in descending order based on totalCurrent",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1851,
        "question": "Compute the average energy consumption for each device type, sort in ascending order by average energy consumption, and take the first 5 entries.",
        "query": "SELECT deviceType, AVG(energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY averageEnergyConsumed ASC LIMIT 5;",
        "step": "【step1】: Join the EnergyConsumption and EnergyDevices tables using deviceId to link energy consumption data with device types.  【step2】: Group the joined data by deviceType and calculate the average energyConsumed for each group.  【step3】: Sort the results by averageEnergyConsumed in ascending order and apply LIMIT 5 to retrieve the bottom 5 entries based on average energy consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1852,
        "question": "Find all equipment with an installation date exceeding 5 years, and list their equipment name, equipment type, and installation date.",
        "query": "SELECT deviceName, deviceType, installationDate FROM Devices WHERE DATEDIFF(CURRENT_DATE, installationDate) > 5 * 365;",
        "step": "【step1】: Select deviceName, deviceType, and installationDate columns from the Devices table  【step2】: Calculate date difference between current date and installationDate using DATEDIFF function  【step3】: Apply filter condition where the calculated difference exceeds 5 years (1825 days)",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1853,
        "question": "Assuming the real-time energy consumption of all devices has increased by 5 times, calculate the total energy consumption for each device type, and rank the top 3 in descending order of total energy consumption.",
        "query": "SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Join EnergyConsumption with EnergyDevices using deviceId to associate consumption data with device types  【step2】: Calculate total energy consumption by multiplying energyConsumed by 5 for each device type grouping  【step3】: Sort results by totalEnergyConsumed in descending order and limit output to top 3 records",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1854,
        "question": "Calculate the real-time power factor for all devices (assuming the power factor is 0.8), and sort the results in ascending order by power factor value.",
        "query": "SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;",
        "step": "【step1】: Select deviceName and deviceType from Devices table  【step2】: Apply fixed power factor value 0.8 as a calculated column  【step3】: Order results by powerFactor in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1855,
        "question": "Calculate the total maintenance cost for each device type, ranked by maintenance cost in descending order, and take the top 5.",
        "query": "SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;",
        "step": "【step1】: Perform an INNER JOIN between MaintenanceRecords and EnergyDevices using deviceId to link maintenance costs with device types.  【step2】: Group the joined data by deviceType and calculate SUM(cost) as totalMaintenanceCost for each group.  【step3】: Sort results by totalMaintenanceCost in descending order and apply LIMIT 5 to retrieve the top 5 device types.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1856,
        "question": "Find all devices with temperature readings outside the expected range (below -273.15°C or above 1000°C), and list their device names, device types, and temperature values.",
        "query": "SELECT SUM(ed.measurementValue) AS totalPower FROM PhysicsLabDB.Devices d JOIN PhysicsLabDB.ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = '瓦特';",
        "step": "【step1】: Join Devices and ExperimentData tables on deviceId to associate sensor data with corresponding devices.  【step2】: Filter records where the measurement unit is 'Watts' using WHERE ed.unit = '瓦特'.  【step3】: Aggregate the filtered results by summing measurementValue with SUM(ed.measurementValue) to calculate totalPower.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1857,
        "question": "Assuming the maintenance cost of all devices increased by 1000 times, calculate the total maintenance cost for each device type, sort them in descending order of total maintenance cost, and take the top 3.",
        "query": "SELECT deviceType, SUM(cost) * 1000 AS totalMaintenanceCost FROM EnergyManagementDB.MaintenanceRecords JOIN PhysicsLabDB.Devices ON MaintenanceRecords.deviceId = Devices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;",
        "step": "【step1】: Perform INNER JOIN between MaintenanceRecords (from EnergyManagementDB) and Devices (from PhysicsLabDB) using deviceId to associate maintenance costs with device types  【step2】: Calculate sum of maintenance costs per deviceType and multiply by 1000 using SUM(cost)*1000 AS totalMaintenanceCost, group by deviceType  【step3】: Order results by totalMaintenanceCost in descending order and limit to top 3 records using ORDER BY...DESC LIMIT 3",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1858,
        "question": "Calculate the ratio of the real-time power to the rated power for all devices, and sort them in descending order by the ratio.",
        "query": "SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerRatio DESC;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables using deviceId to combine real-time power usage with rated power information.  【step2】: Calculate powerRatio by dividing powerUsage (from EnergyConsumption) by powerRating (from EnergyDevices) for each device.  【step3】: Sort the results in descending order of powerRatio using ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1859,
        "question": "Calculate the average energy consumption for each manufacturer's equipment, sort in ascending order by average energy consumption, and take the top 5.",
        "query": "SELECT deviceType, AVG(energyConsumption) AS avgEnergyConsumption FROM EnergyManagementDB.MaintenanceRecords JOIN PhysicsLabDB.Devices ON MaintenanceRecords.deviceId = Devices.deviceId GROUP BY deviceType ORDER BY avgEnergyConsumption ASC LIMIT 5;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables on deviceId to associate energy records with manufacturer information  【step2】: Calculate average energy consumption per manufacturer by grouping on manufacturerId  【step3】: Select top 5 manufacturers using ORDER BY (asc) + LIMIT after sorting by calculated averages  (Note: The original query contains errors - it incorrectly uses MaintenanceRecords and PhysicsLabDB.Devices tables which don't exist in the provided schema, and groups by deviceType instead of manufacturers. The correct logic requires joining EnergyConsumption → EnergyDevices → Manufacturers.)",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1860,
        "question": "Find all devices with humidity sensor data that is both non-null and negative, and list their device names, device types, and humidity values.",
        "query": "SELECT SUM(ed.measurementValue) AS totalPower FROM PhysicsLabDB.Devices d JOIN PhysicsLabDB.ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = '瓦特';",
        "step": "【step1】: JOIN EnergyDevices (d) and EnergyConsumption (ed) via deviceId to link device info with sensor data  【step2】: Filter records where humidity exceeds normal range (assuming sensor data is stored in 'humidity' field of EnergyConsumption)  【step3】: Select deviceName, deviceType, and humidity values from filtered abnormal records  (Note: Original query contains inconsistencies - it calculates power sum while question asks about humidity anomalies. This solution reinterprets the logic based on the actual database schema provided.)",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1861,
        "question": "Assuming the rated power of all devices is reduced by 90%, calculate the total energy consumption for each device type, sort in descending order by total energy consumption, and take the top 3.",
        "query": "SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyManagementDB.EnergyConsumption JOIN PhysicsLabDB.Devices ON EnergyConsumption.deviceId = Devices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;",
        "step": "【step1】: Join `EnergyConsumption` with `Devices` using `deviceId` to associate energy records with device types.  【step2】: Calculate adjusted total energy consumption by summing `energyConsumed * 0.1` (90% reduction) grouped by `deviceType`.  【step3】: Sort results by `totalEnergyConsumed` in descending order and limit to top 3 entries.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1862,
        "question": "Calculate the difference between the real-time power usage and the rated power for all devices, and sort the results in descending order of the difference.",
        "query": "SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerDifference DESC;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables via deviceId to combine real-time power usage (powerUsage) and rated power (powerRating).  【step2】: Calculate the difference between powerUsage and powerRating for each device, aliasing the result as powerDifference.  【step3】: Order the final output by powerDifference in descending sequence.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1863,
        "question": "Find the experiment name, experiment description, researcher name, laboratory name, and equipment count for all experiments with the \"data analyst\" role researchers in charge and a status of \"in progress,\" sorted in ascending order by experiment start time.",
        "query": "SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount FROM Experiments eJOIN Researchers r ON e.researcherId = r.researcherIdJOIN Labs l ON e.labId = l.labIdWHERE r.role = '数据分析师' AND e.status = '进行中'ORDER BY e.startDate ASC;",
        "step": "【step1】: Join Experiments with Researchers via researcherId to associate each experiment with its researcher.  【step2】: Join the intermediate result with Labs via labId to access lab information.  【step3】: Apply role and status filters, then sort experiments by startDate in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1864,
        "question": "List the device name, rated power, and device location of all devices with a device type of \"Solar\" and a status of \"In Operation,\" sorted by rated power in descending order.",
        "query": "SELECT deviceName, powerRating, location FROM EnergyDevices WHERE deviceType = '太阳能' AND status = '运行中' ORDER BY powerRating DESC;",
        "step": "【step1】: Filter EnergyDevices where deviceType is '太阳能'  【step2】: Apply additional filter for status = '运行中'  【step3】: Select deviceName, powerRating, location fields and sort by powerRating DESC",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1865,
        "question": "Retrieve the names, contacts, and cities of all manufacturers with revenue exceeding 1000, sorted in descending order by revenue.",
        "query": "SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;",
        "step": "【step1】: Filter the Manufacturers table to include only records where the annual revenue exceeds 10 million (revenue > 1000).  【step2】: Sort the filtered results in descending order based on the revenue column.  【step3】: Select and display the manufacturerName, contactPerson, and city columns from the sorted dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1866,
        "question": "List all energy consumption records with energy values greater than 500 kilowatt-hours, including the device ID, energy consumption value, and timestamp, sorted in ascending order by timestamp.",
        "query": "SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 500 ORDER BY timestamp ASC;",
        "step": "【step1】: Retrieve deviceId, energyConsumed, and timestamp columns from the EnergyConsumption table.  【step2】: Apply the filter condition to select only records where energyConsumed exceeds 500 kWh.  【step3】: Sort the filtered results in ascending order based on the timestamp.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1867,
        "question": "Find the device ID, carbon footprint, and energy source for all environmental impact records with a carbon footprint greater than 1000, sorted in descending order by carbon footprint.",
        "query": "SELECT deviceId, carbonFootprint, energySource FROM EnvironmentalImpact WHERE carbonFootprint > 1000 ORDER BY carbonFootprint DESC;",
        "step": "【step1】:Retrieve the required columns (deviceId, carbonFootprint, energySource) from the EnvironmentalImpact table  【step2】:Filter records using WHERE clause to select only entries where carbonFootprint exceeds 1000 kg CO2  【step3】:Sort the filtered results in descending order using ORDER BY carbonFootprint DESC",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1868,
        "question": "List the equipment ID, efficiency value, and energy saved for all energy efficiency records where the equipment efficiency is greater than 90%, sorted in descending order by energy saved.",
        "query": "SELECT deviceId, efficiency, energySaved FROM EnergyEfficiency WHERE efficiency > 90 ORDER BY energySaved DESC;",
        "step": "【step1】: Select deviceId, efficiency, and energySaved columns from the EnergyEfficiency table  【step2】: Filter records where efficiency exceeds 90% using the WHERE clause  【step3】: Sort results by energySaved in descending order using ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1869,
        "question": "Find all maintenance records with the maintenance type \"Emergency Repair,\" displaying the equipment ID, maintenance date, and maintenance cost, then sort them in descending order by maintenance date.",
        "query": "SELECT deviceId, maintenanceDate, cost FROM MaintenanceRecords WHERE maintenanceType = '紧急维修' ORDER BY maintenanceDate DESC;",
        "step": "【step1】: Filter records from MaintenanceRecords table where maintenanceType equals '紧急维修'  【step2】: Extract deviceId, maintenanceDate, and cost columns from the filtered records  【step3】: Sort the final results by maintenanceDate in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1870,
        "question": "Calculate the squared ratio of the real-time power to the rated power for all devices, and sort them in descending order by the squared ratio.",
        "query": "SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerSquareRatio DESC;",
        "step": "【step1】: Perform an INNER JOIN between the 'EnergyConsumption' and 'EnergyDevices' tables using the common 'deviceId' field to combine real-time power usage and rated power data.  【step2】: Calculate the squared ratio of powerUsage to powerRating using the POWER() function, aliased as powerSquareRatio.  【step3】: Sort the results in descending order based on the calculated powerSquareRatio using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1871,
        "question": "List all predictive records with a prediction type of \"Energy Consumption Forecast\" and a confidence level greater than 95%, including the device ID, predicted value, and prediction timestamp, sorted in descending order by the predicted value.",
        "query": "SELECT deviceId, forecastValue, timestamp FROM EnergyForecasts WHERE forecastType = '能耗预测' AND confidenceLevel > 95 ORDER BY forecastValue DESC;",
        "step": "【step1】: Retrieve deviceId, forecastValue, and timestamp columns from the EnergyForecasts table  【step2】: Apply filters for forecastType = '能耗预测' and confidenceLevel > 95%  【step3】: Sort the results by forecastValue in descending order using ORDER BY clause",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1872,
        "question": "Find the policy name, target efficiency, and target carbon footprint for all energy policies with a target efficiency greater than 85, sorted in descending order by target efficiency.",
        "query": "SELECT policyName, targetEfficiency, targetCarbonFootprint FROM EnergyPolicies WHERE targetEfficiency > 85 ORDER BY targetEfficiency DESC;",
        "step": "【step1】: Select the columns policyName, targetEfficiency, and targetCarbonFootprint from the EnergyPolicies table.  【step2】: Filter the records to include only those where targetEfficiency exceeds 85%.  【step3】: Sort the resulting entries in descending order based on targetEfficiency.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1873,
        "question": "List the device ID, audit date, and recommendations for all energy audit records with an audit result of \"non-compliant,\" sorted by audit date in ascending order.",
        "query": "SELECT deviceId, auditDate, recommendations FROM EnergyAudits WHERE auditResult = '不合规' ORDER BY auditDate ASC;",
        "step": "【step1】: Filter records from EnergyAudits where auditResult is '不合规' using WHERE clause  【step2】: Select required columns (deviceId, auditDate, recommendations)  【step3】: Sort filtered results by auditDate in ascending order using ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1874,
        "question": "Calculate the cubic ratio of power usage to power rating for all devices, and sort them in descending order by the cubic ratio.",
        "query": "SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerCubicRatio DESC;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables using deviceId to combine real-time power usage (powerUsage) and rated power (powerRating) data.  【step2】: Calculate the cubic ratio by applying POWER() function to (powerUsage/powerRating) with exponent 3, aliased as powerCubicRatio.  【step3】: Sort results in descending order using ORDER BY on powerCubicRatio.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1875,
        "question": "Find the device ID, temperature value, and energy consumption value for all energy consumption records where the device temperature is higher than 50 degrees Celsius, and sort them in descending order by temperature value.",
        "query": "SELECT deviceId, temperature, energyConsumed FROM EnergyConsumption WHERE temperature > 50 ORDER BY temperature DESC;",
        "step": "【step1】: Filter records from EnergyConsumption table where temperature exceeds 50°C using WHERE clause.  【step2】: Select required fields (deviceId, temperature, energyConsumed) from the filtered dataset.  【step3】: Apply descending sorting on temperature values using ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1876,
        "question": "List the device name, installation date, and device status for all devices of type \"Wind Energy\" installed after 2020, sorted by installation date in ascending order.",
        "query": "SELECT deviceName, installationDate, status FROM EnergyDevices WHERE deviceType = '风能' AND installationDate > '2020-01-01' ORDER BY installationDate ASC;",
        "step": "【step1】: Select the required columns (deviceName, installationDate, status) from the EnergyDevices table.  【step2】: Apply filters to retain only records where deviceType is '风能' and installationDate is after 2020-01-01.  【step3】: Sort the filtered results by installationDate in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1877,
        "question": "Find the names, profits, and countries of all manufacturers with profits exceeding 500, sorted in descending order by profit.",
        "query": "SELECT manufacturerName, profit, country FROM Manufacturers WHERE profit > 500 ORDER BY profit DESC;",
        "step": "【step1】: Select manufacturerName, profit, and country columns from the Manufacturers table  【step2】: Apply filter condition to retain records where profit exceeds 5 million (profit > 500)  【step3】: Sort the results in descending order of profit using ORDER BY profit DESC",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1878,
        "question": "Calculate the ratio of the real-time power to the rated power raised to the fourth power for all devices, and sort them in descending order by this ratio.",
        "query": "SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerFourthRatio DESC;",
        "step": "【step1】: Join the EnergyConsumption and EnergyDevices tables using deviceId to associate real-time power data with device specifications.  【step2】: Calculate the fourth power ratio of real-time power to rated power using POWER(powerUsage / powerRating, 4) and alias it as powerFourthRatio.  【step3】: Sort the results in descending order based on the calculated powerFourthRatio using ORDER BY powerFourthRatio DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1879,
        "question": "List all energy consumption records where the energy consumption value is greater than 1000 kWh and the data quality is \"high,\" displaying the device ID, energy consumption value, and timestamp, then sort them in descending order by energy consumption value.",
        "query": "SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 1000 AND dataQuality = '高' ORDER BY energyConsumed DESC;",
        "step": "【step1】: Select deviceId, energyConsumed, timestamp columns from EnergyConsumption table  【step2】: Apply filters for energyConsumed > 1000 and dataQuality = '高'  【step3】: Sort results by energyConsumed in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1880,
        "question": "Find all environmental impact records with pollution levels greater than 50 micrograms per cubic meter, displaying the device ID, pollution level, and energy source, sorted by pollution level in descending order.",
        "query": "SELECT deviceId, pollutionLevel, energySource FROM EnvironmentalImpact WHERE pollutionLevel > 50 ORDER BY pollutionLevel DESC;",
        "step": "【step1】: Retrieve all records from the EnvironmentalImpact table where pollutionLevel exceeds 50 μg/m³.  【step2】: Extract the specified columns (deviceId, pollutionLevel, and energySource) from the filtered records.  【step3】: Sort the final dataset in descending order based on pollutionLevel values.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1881,
        "question": "List all energy efficiency records where the saved cost is greater than 1000 yuan, including the equipment ID, saved cost, and saved energy, sorted in descending order by the saved cost.",
        "query": "SELECT deviceId, costSavings, energySaved FROM EnergyEfficiency WHERE costSavings > 1000 ORDER BY costSavings DESC;",
        "step": "【step1】: Filter records from the EnergyEfficiency table where costSavings exceeds 1000 using the WHERE clause.  【step2】: Select the required columns (deviceId, costSavings, energySaved) from the filtered dataset.  【step3】: Sort the results in descending order based on costSavings using the ORDER BY clause.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1882,
        "question": "Calculate the average warranty period length (in days) for each device in the Devices table, and find the device with the longest average warranty period.",
        "query": "SELECT AVG(julianday(warrantyExpiryDate) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;",
        "step": "【step1】: Calculate warranty duration in days for each device using julianday() on warrantyExpiryDate and purchaseDate  【step2】: Compute average warranty duration across all devices using AVG() function  【step3】: Group results by device, sort by avg_warranty descending, and limit to 1 record to find the longest warranty device",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1883,
        "question": "Calculate the total maintenance cost for each device in the MaintenanceRecords table, sort them in descending order by cost, and identify the top 3 devices with the highest maintenance costs.",
        "query": "SELECT deviceId, maintenanceDate, maintenanceType FROM MaintenanceRecords WHERE cost > 5000 ORDER BY cost DESC;",
        "step": "【step1】: Aggregate the maintenance costs per device using SUM(cost) and GROUP BY deviceId.  【step2】: Order the results by total maintenance cost in descending order.  【step3】: Limit the output to the top 3 devices using LIMIT 3.  Note: The original query provided in the problem statement is incorrect for solving the task, as it lacks aggregation (SUM) and grouping (GROUP BY) needed to calculate total maintenance cost per device. The steps above reflect the proper solution.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1884,
        "question": "List the names, email addresses, and joining dates of all researchers whose role is \"Data Analyst,\" sorted in ascending order by joining date.",
        "query": "SELECT researcherName, email, joinDate FROM Researchers WHERE role = '数据分析师' ORDER BY joinDate ASC;",
        "step": "【step1】: Select researcherName, email, joinDate columns from the Researchers table.  【step2】: Apply the WHERE clause to filter records where role = '数据分析师'.  【step3】: Sort the results by joinDate in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1885,
        "question": "Assuming that the warranty period for all devices in the Devices table is suddenly extended to 100 years, calculate the average warranty period length for each device (in days), and identify the device with the longest warranty period.",
        "query": "SELECT AVG(julianday(datetime(purchaseDate, '+100 years')) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;",
        "step": "【step1】: Calculate the warranty period in days for each device by adding 100 years to purchaseDate and computing the Julian day difference.  【step2】: Group results by deviceId and deviceName, calculate the average warranty (effectively showing individual device warranties due to grouping).  【step3】: Order devices by avg_warranty in descending order and select the top result to identify the device with the longest warranty period.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1886,
        "question": "Find the names, locations, and number of equipment for all laboratories with a capacity greater than 20 people and a status of \"open\", sorted in descending order by the number of equipment.",
        "query": "SELECT labName, location, equipmentCount FROM Labs WHERE capacity > 20 AND status = '开放' ORDER BY equipmentCount DESC;",
        "step": "【step1】: Retrieve all records from the Labs table where the capacity exceeds 20.  【step2】: Filter the results from step1 to include only labs with the status '开放'.  【step3】: Select the labName, location, and equipmentCount columns from the filtered data and sort them in descending order by equipmentCount.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1887,
        "question": "List the names, start dates, and end dates of all experiments with a status of \"In Progress,\" sorted by start date in ascending order.",
        "query": "SELECT experimentName, startDate, endDate FROM Experiments WHERE status = '进行中' ORDER BY startDate ASC;",
        "step": "【step1】: Filter the Experiments table to select records where the status is '进行中' using the WHERE clause.  【step2】: Extract the required fields (experimentName, startDate, endDate) from the filtered records.  【step3】: Sort the results by startDate in ascending order using ORDER BY ASC.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1888,
        "question": "Find all devices in the Devices table where the status is 'Malfunction' and the device type is 'Lighting', sorted by device name in ascending order.",
        "query": "SELECT * FROM Devices WHERE status = '故障' AND deviceType = '照明' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter records from Devices table where status equals '故障' and deviceType equals '照明'  【step2】: Sort the filtered results by deviceName in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "4",
        "idx": 1889,
        "question": "Find the device name, power rating, and installation date of all devices with the device type \"lighting\" and status \"online,\" and calculate their total energy consumption values, sorted in descending order by total energy consumption.",
        "query": "SELECT d.deviceName, d.powerRating, d.installationDate, SUM(e.energyConsumed) AS totalEnergyConsumed FROM Devices d JOIN EnergyConsumption e ON d.deviceId = e.deviceId WHERE d.deviceType = '照明' AND d.status = '在线' GROUP BY d.deviceName, d.powerRating, d.installationDate ORDER BY totalEnergyConsumed DESC;",
        "step": "【step1】: Join Devices and EnergyConsumption tables via deviceId, applying filters for deviceType='照明' and status='オンライン'  【step2】: Group results by deviceName, powerRating, installationDate and calculate SUM(energyConsumed)  【step3】: Sort aggregated records by totalEnergyConsumed in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1890,
        "question": "Calculate the total weight (in kilograms) for each product in the Products table and identify the top 3 products with the highest total weight.",
        "query": "SELECT SUM(weight) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;",
        "step": "【step1】: Aggregate the total weight for each product using SUM(weight) with GROUP BY on productId and productName.  【step2】: Sort the results in descending order based on total_weight.  【step3】: Limit the output to the top 3 records with the highest total_weight.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1891,
        "question": "Calculate the total order amount for each user in the Orders table, sort it in descending order by amount, and find the top 5 users with the highest spending.",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC LIMIT 5;",
        "step": "【step1】: Group all records in the Orders table by userId to consolidate data per user.  【step2】: Calculate the sum of totalAmount for each grouped userId using SUM(totalAmount) AS total_spent.  【step3】: Sort the results by total_spent in descending order and limit the output to the top 5 users using ORDER BY total_spent DESC LIMIT 5.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1892,
        "question": "Find all orders in the Orders table where the order status is 'Completed' and the payment method is 'Alipay', and sort them by order date in ascending order.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentMethod = '支付宝' ORDER BY orderDate ASC;",
        "step": "【step1】: Filter records from Orders table where orderStatus equals '已完成' and paymentMethod equals '支付宝'  【step2】: Sort the filtered results by orderDate in ascending order  【step3】: Retrieve all columns from the processed dataset",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1893,
        "question": "Assuming the weight of all products in the Products table is now 1000 kilograms, identify the top 3 products with the highest total weight (in kilograms).",
        "query": "SELECT SUM(1000) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;",
        "step": "【step1】: Calculate the fixed weight of 1000kg for each product by grouping on productId and productName, resulting in each product's total_weight being 1000kg.  【step2】: Sort the grouped results in descending order of total_weight. Since all products have equal weight, sorting won't change the sequence.  【step3】: Limit the output to the top 3 products. Due to identical weights, the selection will be arbitrary based on default ordering.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1894,
        "question": "Calculate the total cost (in yuan) for each maintenanceId in the MaintenanceRecords table, and identify the top 3 maintenanceIds with the highest total costs.",
        "query": "SELECT SUM(cost) AS total_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY total_cost DESC LIMIT 3;",
        "step": "【step1】: Group records by maintenanceId and calculate the sum of cost for each group using SUM(cost) AS total_cost.  【step2】: Sort the grouped results in descending order based on total_cost with ORDER BY total_cost DESC.  【step3】: Limit the output to the top 3 highest-cost records using LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1895,
        "question": "Count the number of devices for each manufacturer in the Devices table, sort them in descending order by quantity, and identify the top 3 manufacturers with the most devices.",
        "query": "SELECT manufacturerId, COUNT(deviceId) AS device_count FROM Devices GROUP BY manufacturerId ORDER BY device_count DESC LIMIT 3;",
        "step": "【step1】: Group the records in the Devices table by manufacturerId and calculate the count of deviceId for each group.  【step2】: Sort the grouped results by the calculated device_count in descending order.  【step3】: Restrict the output to the top 3 records using LIMIT to show manufacturers with the highest device counts.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1896,
        "question": "Find all records in the MaintenanceRecords table where the maintenance type is 'emergency repair' and the maintenance cost is greater than 1000, sorted by maintenance date in ascending order.",
        "query": "SELECT * FROM MaintenanceRecords WHERE maintenanceType = '紧急维修' AND cost > 1000 ORDER BY maintenanceDate ASC;",
        "step": "【step1】: Filter records where maintenanceType is '紧急维修' using the WHERE clause.  【step2】: Apply an additional filter to include only records with cost greater than 1000 using the AND operator.  【step3】: Sort the filtered results by maintenanceDate in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1897,
        "question": "Find the names, calibration dates, and laboratory IDs of all devices whose device type is \"Oscilloscope\" and status is \"Normal,\" sorted by calibration date in descending order.",
        "query": "SELECT deviceName, calibrationDate, labId FROM Devices WHERE deviceType = '示波器' AND status = '正常' ORDER BY calibrationDate DESC;",
        "step": "【step1】: Select deviceName, calibrationDate, labId columns from Devices table  【step2】: Filter records where deviceType equals '示波器' and status equals '正常'  【step3】: Sort results by calibrationDate in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1898,
        "question": "Calculate the average power usage for each device in the EnergyConsumption table, and identify the top 3 devices with the highest average power consumption.",
        "query": "SELECT AVG(powerUsage) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;",
        "step": "【step1】:【Calculate average power usage per device using GROUP BY on deviceId and AVG(powerUsage)】  【step2】:【Sort results by avg_power in descending order to prioritize highest values】  【step3】:【Limit output to top 3 devices using LIMIT 3 for final ranking】",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "2",
        "idx": 1899,
        "question": "Count the number of records with data quality (dataQuality) rated as 'high' for each sensor in the SensorData table, sort them in descending order by count, and identify the top 3 sensors with the highest data quality.",
        "query": "SELECT sensorId, COUNT(dataId) AS high_quality_count FROM SensorData WHERE dataQuality = '高' GROUP BY sensorId ORDER BY high_quality_count DESC LIMIT 3;",
        "step": "【step1】: Filter records in SensorData where dataQuality is '高' using the WHERE clause.  【step2】: Group the filtered records by sensorId and count dataId for each group using GROUP BY and COUNT().  【step3】: Sort results by high_quality_count in descending order and limit output to top 3 sensors using ORDER BY and LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1900,
        "question": "Find all devices in the Devices table where the device type is 'Security' and the status is 'Online', sorted by device name in ascending order.",
        "query": "SELECT * FROM Devices WHERE deviceType = '安防' AND status = '在线' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter all records from the Devices table where deviceType is '安防'.  【step2】: Further filter the results from Step 1 to include only devices with status '在线'.  【step3】: Sort the filtered results by deviceName in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1901,
        "question": "Assuming the real-time power of all devices in the EnergyConsumption table suddenly becomes 10000 watts, calculate the average power (in watts) for each device and identify the top 3 devices with the highest average power.",
        "query": "SELECT AVG(10000) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;",
        "step": "【step1】: Calculate the average power (10000 watts) for each device using AVG(10000) with GROUP BY deviceId.  【step2】: Order the results by avg_power in descending order.  【step3】: Restrict the output to the top 3 devices with LIMIT 3.  Note: The query has logical flaws. Since all devices have the same fixed power (10000), the \"highest power\" filtering is redundant. A valid approach would require aggregating actual dynamic power values instead of hardcoding 10000.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1902,
        "question": "Calculate the total volume (in cubic meters) for each product in the Products table, and find the top 3 products with the largest total volume.",
        "query": "SELECT SUM(volume) AS total_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_volume DESC LIMIT 3;",
        "step": "【step1】: Group products by productId and productName, calculate total volume per group using SUM(volume)  【step2】: Sort results in descending order by total_volume  【step3】: Limit output to top 3 records with largest accumulated volume",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1903,
        "question": "Calculate the total sales quantity for each product, sort them in descending order by total sales quantity, and identify the top 5 products with the highest sales quantity.",
        "query": "SELECT productId, SUM(quantity) AS total_sales FROM Orders GROUP BY productId ORDER BY total_sales DESC LIMIT 5;",
        "step": "【step1】: Extract productId and sum of quantity from Orders table grouped by productId  【step2】: Sort aggregated results by total_sales in descending order  【step3】: Restrict output to top 5 records using LIMIT clause",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1904,
        "question": "Find all orders in the Orders table where the order status is 'Shipped' and the shipping method is 'Express', sorted by order date in ascending order.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已发货' AND shippingMethod = '快递' ORDER BY orderDate ASC;",
        "step": "【step1】: Filter records from Orders table where orderStatus is '已发货' and shippingMethod is '快递' using WHERE clause  【step2】: Apply ascending sorting on orderDate field using ORDER BY ASC  【step3】: Select all columns (*) from the filtered and sorted results",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1905,
        "question": "List the names, email addresses, and registration dates of all users whose role is \"Administrator,\" sorted by registration date in descending order.",
        "query": "SELECT userName, email, registrationDate FROM Users WHERE userRole = '管理员' ORDER BY registrationDate DESC;",
        "step": "【step1】: Select the columns `userName`, `email`, and `registrationDate` from the `Users` table.  【step2】: Apply the filter condition `userRole = '管理员'` to retrieve only administrator users.  【step3】: Sort the resulting records by `registrationDate` in descending order using `ORDER BY registrationDate DESC`.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1906,
        "question": "Find the names, prices, and categories of all products with stock quantities less than 10 and a status of \"on-shelf,\" sorted by price in ascending order.",
        "query": "SELECT productName, price, category FROM Products WHERE stock < 10 AND status = '上架' ORDER BY price ASC;",
        "step": "【step1】: Filter records from Products table where stock quantity is less than 10 and status is '上架'.  【step2】: Select the productName, price, and category columns from the filtered records.  【step3】: Sort the results in ascending order based on the price column.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1907,
        "question": "Count the number of maintenance records for each technician in the MaintenanceRecords table, sort them in descending order by quantity, and identify the top 3 technicians with the most maintenance records.",
        "query": "SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC LIMIT 3;",
        "step": "【step1】: Group the MaintenanceRecords table by technicianName and count the number of maintenanceId entries for each technician.  【step2】: Sort the grouped results in descending order based on the maintenance_count.  【step3】: Restrict the output to only the top 3 technicians with the highest maintenance_count using LIMIT.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1908,
        "question": "Find the experiment names, descriptions, researcher names, lab names, and equipment count for all experiments in \"Ongoing\" status that are managed by researchers with the role \"Data Analyst,\" sorted by experiment start time in ascending order.",
        "query": "SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount FROM Experiments e JOIN Researchers r ON e.researcherId = r.researcherId JOIN Labs l ON e.labId = l.labId WHERE r.role = '数据分析师' AND e.status = '进行中' ORDER BY e.startDate ASC;",
        "step": "【step1】: Join Experiments table with Researchers table on researcherId to link experiments with their responsible researchers  【step2】: Join the result with Labs table on labId to access laboratory information and apply WHERE filters (role='数据分析师' AND status='进行中')  【step3】: Select required fields and sort results by experiment's startDate in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1909,
        "question": "Assuming the purchase date of all devices in the Devices table is shifted forward by 100 years, find the device with the longest average lifespan (in days) by calculating the average difference in days between the current date and the adjusted purchase date for each device.",
        "query": "SELECT AVG(julianday('now') - julianday(date('now', '-100 years'))) AS avg_lifetime, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_lifetime DESC LIMIT 1;",
        "step": "【step1】: Calculate each device's lifespan in days by subtracting 100 years-adjusted purchase date from current date using `julianday` functions.  【step2】: Compute average lifetime across all devices with `AVG`, group by deviceId/deviceName to isolate individual device calculations.  【step3】: Order results by descending avg_lifetime and select top entry via `LIMIT 1` to identify the device with maximum lifespan.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1910,
        "question": "List the names, calibration dates, laboratory names, and laboratory statuses of all equipment with the type \"oscilloscope\" that have a calibration date after 2023-01-01, sorted by calibration date in descending order.",
        "query": "SELECT d.deviceName, d.calibrationDate, l.labName, l.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = '示波器' AND d.calibrationDate > '2023-01-01' ORDER BY d.calibrationDate DESC;",
        "step": "【step1】: Join 'Devices' and 'Labs' tables using labId to combine device information with corresponding lab details  【step2】: Filter records where deviceType is '示波器' and calibrationDate is after 2023-01-01  【step3】: Sort the results by calibrationDate in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1911,
        "question": "Find the experiment names, measured values, device names, and collection times from all experimental data where the data quality is \"high\" and the measured values are greater than 100, sorted in descending order by measured value.",
        "query": "SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = '高' AND ed.measurementValue > 100 ORDER BY ed.measurementValue DESC;",
        "step": "【step1】: Filter ExperimentData table to select rows where dataQuality is '高' and measurementValue > 100  【step2】: Join filtered ExperimentData with Experiments (on experimentId) and Devices (on deviceId) to fetch experimentName, deviceName  【step3】: Sort the combined results by measurementValue in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1912,
        "question": "Find all devices in the Devices table where the device type is 'Entertainment' and the status is 'Offline', sorted by device name in ascending order.",
        "query": "SELECT * FROM Devices WHERE deviceType = '娱乐' AND status = '离线' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter records from Devices where deviceType is '娱乐'  【step2】: Further filter results where status is '离线'  【step3】: Sort the final results by deviceName in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1913,
        "question": "Assuming the real-time current of all devices in the EnergyConsumption table suddenly becomes 1000 amperes, calculate the average current (in amperes) for each device and identify the top 3 devices with the highest average current.",
        "query": "SELECT AVG(1000) AS avg_current, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_current DESC LIMIT 3;",
        "step": "【step1】: Calculate the average current for each device by using the fixed value 1000 and grouping by deviceId.  【step2】: Order the results by the calculated average current in descending order.  【step3】: Limit the output to the top 3 devices based on the sorted average current.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1914,
        "question": "Compute the total value (in yuan) for each product in the Products table, and identify the top 3 most valuable products by total value.",
        "query": "SELECT SUM(price) AS total_value, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_value DESC LIMIT 3;",
        "step": "【step1】: Group products by productId and productName while calculating total_value using SUM(price) aggregation.  【step2】: Sort the grouped results in descending order based on total_value.  【step3】: Restrict the output to the top 3 records using LIMIT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1915,
        "question": "Calculate the total discount amount for each product in the Orders table, sort them in descending order of discount amount, and find the top 5 products with the highest discount amounts.",
        "query": "SELECT productId, SUM(discount) AS total_discount FROM Orders GROUP BY productId ORDER BY total_discount DESC LIMIT 5;",
        "step": "【step1】: Group the Orders table by productId and calculate the total discount for each product using SUM(discount).  【step2】: Sort the grouped results in descending order based on the calculated total_discount.  【step3】: Restrict the output to the top 5 records using LIMIT 5.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1916,
        "question": "Find all orders in the Orders table where the order status is 'Pending Payment' and the payment method is 'Credit Card', sorted by order date in ascending order.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '待支付' AND paymentMethod = '信用卡' ORDER BY orderDate ASC;",
        "step": "【step1】: Select all records from the Orders table  【step2】: Apply filters for orderStatus = '待支付' AND paymentMethod = '信用卡'  【step3】: Sort the filtered results by orderDate in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1917,
        "question": "List the order ID, total order amount, and shipping address for all orders with a status of \"Shipped,\" sorted in descending order by the total order amount.",
        "query": "SELECT orderId, totalAmount, shippingAddress FROM Orders WHERE orderStatus = '已发货' ORDER BY totalAmount DESC;",
        "step": "【step1】: Filter records from the 'Orders' table where orderStatus equals '已发货'.  【step2】: Select the required columns orderId, totalAmount, and shippingAddress from the filtered dataset.  【step3】: Sort the results in descending order based on totalAmount.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1918,
        "question": "Calculate the average maintenance cost (in yuan) for each maintenanceId in the MaintenanceRecords table and identify the top 3 maintenanceIds with the highest average costs.",
        "query": "SELECT AVG(cost) AS avg_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_cost DESC LIMIT 3;",
        "step": "【step1】: Calculate the average maintenance cost (AVG(cost)) for each maintenanceId by grouping records in MaintenanceRecords.  【step2】: Sort the results in descending order based on the calculated average cost.  【step3】: Limit the output to the top 3 records with the highest average maintenance cost.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1919,
        "question": "Count the number of devices at each location in the Devices table, sort in descending order by quantity, and identify the top 3 locations with the highest number of devices.",
        "query": "SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC LIMIT 3;",
        "step": "【step1】: Group devices by locationId and count deviceId for each group  【step2】: Sort the grouped results by device_count in descending order  【step3】: Limit the final output to top 3 records",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 1920,
        "question": "Find all records in the MaintenanceRecords table where the maintenance type is 'routine maintenance' and the maintenance cost is less than 500, and sort them in ascending order by maintenance date.",
        "query": "SELECT * FROM MaintenanceRecords WHERE maintenanceType = '定期维护' AND cost < 500 ORDER BY maintenanceDate ASC;",
        "step": "【step1】: Filter all records where maintenanceType is '定期维护' from MaintenanceRecords.  【step2】: Apply cost < 500 condition to the filtered records.  【step3】: Sort the resulting records by maintenanceDate in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1921,
        "question": "Find the experiment names, measurement values, device names, and timestamps from all experimental data where the data quality is \"high\" and the measurement values are greater than 100, sorted by measurement value in descending order.",
        "query": "SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = '高' AND ed.measurementValue > 100 ORDER BY ed.measurementValue DESC;",
        "step": "【step1】: Join ExperimentData, Experiments, and Devices tables on experimentId and deviceId to link measurement data with experiment and device details.  【step2】: Apply filters for dataQuality = '高' and measurementValue > 100.  【step3】: Sort the combined results by measurementValue in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1922,
        "question": "Calculate the average voltage for each device in the EnergyConsumption table, and identify the top 3 devices with the highest average voltage.",
        "query": "SELECT AVG(voltage) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;",
        "step": "【step1】:【Group the EnergyConsumption table by deviceId and calculate the average voltage for each group using AVG(voltage) AS avg_voltage.】  【step2】:【Sort the grouped results in descending order based on avg_voltage using ORDER BY avg_voltage DESC.】  【step3】:【Limit the final output to the top 3 devices with the highest average voltage using LIMIT 3.】",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "2",
        "idx": 1923,
        "question": "Calculate the total number of data entries for each sensor in the SensorData table, sort them in descending order of the count, and identify the top 3 sensors with the highest number of data entries.",
        "query": "SELECT sensorId, COUNT(dataId) AS data_count FROM SensorData GROUP BY sensorId ORDER BY data_count DESC LIMIT 3;",
        "step": "【step1】: [Group data by sensorId and count entries] Use GROUP BY to aggregate records by sensorId and calculate data frequency with COUNT(dataId)  【step2】: [Sort by frequency descending] Apply ORDER BY data_count DESC to rank sensors by collection frequency  【step3】: [Limit to top 3 results] Restrict output to highest-frequency sensors using LIMIT 3",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1924,
        "question": "Find all devices in the Devices table where the device type is 'Lighting' and the status is 'Online', sorted by device name in ascending order.",
        "query": "SELECT * FROM Devices WHERE deviceType = '照明' AND status = '在线' ORDER BY deviceName ASC;",
        "step": "【step1】: Access the Devices table to retrieve all device records.  【step2】: Apply filters using WHERE clause for deviceType = '照明' and status = '在线'.  【step3】: Sort the filtered results in ascending order by deviceName using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1925,
        "question": "Assuming the real-time voltage of all devices in the EnergyConsumption table is set to 1000 volts, identify the top 3 devices with the highest voltage.",
        "query": "SELECT AVG(1000) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;",
        "step": "【step1】: Replace all real-time voltage values with 1000 volts and calculate the average voltage per device using AVG(1000).  【step2】: Group the results by deviceId to ensure each device's average is computed separately.  【step3】: Sort devices by avg_voltage in descending order and limit output to the top 3 devices.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1926,
        "question": "Calculate the average weight (in kilograms) for each product in the Products table, and find the top 3 products with the highest average weight.",
        "query": "SELECT AVG(weight) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;",
        "step": "【step1】: Group products by productId and productName while calculating the average weight for each group.  【step2】: Order the grouped results by avg_weight in descending order.  【step3】: Limit the output to the top 3 records using the LIMIT clause.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1927,
        "question": "Count the total number of orders for each user in the Orders table, sort them in descending order by the total number of orders, and find the top 5 users with the highest number of orders.",
        "query": "SELECT userId, COUNT(orderId) AS order_count FROM Orders GROUP BY userId ORDER BY order_count DESC LIMIT 5;",
        "step": "【step1】: Group records by userId and count orderId for each group to calculate total orders per user  【step2】: Sort the grouped results by order_count in descending order  【step3】: Restrict output to top 5 users with highest order counts using LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1928,
        "question": "Find all orders in the Orders table with the status 'Completed' and delivery method 'Logistics,' sorted by order date in ascending order.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已完成' AND shippingMethod = '物流' ORDER BY orderDate ASC;",
        "step": "【step1】: Filter records from Orders table where orderStatus equals '已完成'  【step2】: Apply additional filter to retain records with shippingMethod equals '物流'  【step3】: Sort the filtered results by orderDate in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1929,
        "question": "Calculate the average weight of 5000 for each product group and identify the top 3 product groups by this calculated average weight.",
        "query": "SELECT AVG(5000) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;",
        "step": "【step1】: Calculate the average weight by taking the constant value 5000 for all products. AVG(5000) will return 5000 since it's a fixed value across all rows.  【step2】: Select productId and productName columns while including the constant weight value (5000) for each product.  【step3】: Apply ORDER BY on avg_weight (which is always 5000) and limit results to 3 rows. Since all weights are identical, the final ordering is arbitrary.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1930,
        "question": "List all hypotheses with verification results marked as \"false,\" verification dates after 2023, including their hypothesis content, experiment names, verification dates, and researcher names, sorted by verification date in descending order.",
        "query": "SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId JOIN Researchers r ON e.researcherId = r.researcherId WHERE h.verificationResult = '假' AND h.verificationDate > '2023-01-01' ORDER BY h.verificationDate DESC;",
        "step": "【step1】: JOIN Hypotheses and Experiments on experimentId to link hypothesis data with corresponding experiment information.  【step2】: JOIN Researchers on researcherId to include researcher names associated with the experiments.  【step3】: Apply WHERE filters (verificationResult = '假' AND verificationDate > '2023-01-01') and ORDER BY verificationDate DESC for final sorting.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1931,
        "question": "Calculate the number of maintenance occurrences for each device in the MaintenanceRecords table, sort them in descending order by frequency, and identify the top 3 devices with the highest maintenance counts.",
        "query": "SELECT deviceId, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenance_count DESC LIMIT 3;",
        "step": "【step1】: Group the MaintenanceRecords table by deviceId and count the number of maintenance records for each device using COUNT(maintenanceId).  【step2】: Sort the grouped results in descending order based on the maintenance_count using ORDER BY maintenance_count DESC.  【step3】: Restrict the output to the top 3 devices with the highest maintenance counts using LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1932,
        "question": "Find all variable names, experiment names, sensitivity values, and impact levels in the sensitivity analysis where the impact level is \"high\" and the sensitivity value is greater than 0.5, sorted in descending order by sensitivity value.",
        "query": "SELECT v.variableName, e.experimentName, sa.sensitivityValue, sa.impact FROM SensitivityAnalysis sa JOIN Variables v ON sa.variableId = v.variableId JOIN Experiments e ON sa.experimentId = e.experimentId WHERE sa.impact = '高' AND sa.sensitivityValue > 0.5 ORDER BY sa.sensitivityValue DESC;",
        "step": "【step1】: Filter records from SensitivityAnalysis where impact is '高' and sensitivityValue > 0.5.  【step2】: Join filtered SensitivityAnalysis with Variables (on variableId) and Experiments (on experimentId) to retrieve variableName and experimentName.  【step3】: Sort the combined results by sensitivityValue in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1933,
        "question": "Assuming the maintenance interval for all devices in the Devices table suddenly becomes 1 day, identify the device with the shortest maintenance interval.",
        "query": "SELECT AVG(1) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;",
        "step": "【step1】: Calculate the average maintenance interval as 1 day for all devices by using AVG(1) and group results by deviceId.  【step2】: Order the grouped results by avg_interval in ascending order to prioritize the shortest interval.  【step3】: Limit the output to the first row to retrieve the device with the shortest maintenance interval (all will be 1 day, so this selects an arbitrary device).",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1934,
        "question": "List all constraint contents, experiment names, and constraint types where the constraint type is \"inequality\" and the data quality is \"high\", sorted by constraint content in ascending order.",
        "query": "SELECT c.constraintText, e.experimentName, c.constraintType FROM Constraints c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.constraintType = '不等式' AND c.dataQuality = '高' ORDER BY c.constraintText ASC;",
        "step": "【step1】: Join Constraints and Experiments tables using experimentId to combine constraint details with experiment names  【step2】: Apply filters for constraintType='不等式' and dataQuality='高' in the WHERE clause  【step3】: Sort results by constraintText in ascending order using ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "2",
        "idx": 1935,
        "question": "Count the number of records with 'low' data quality (dataQuality) for each sensor in the SensorData table, sort them in descending order by the count, and identify the top 3 sensors with the poorest data quality.",
        "query": "SELECT sensorId, COUNT(dataId) AS low_quality_count FROM SensorData WHERE dataQuality = '低' GROUP BY sensorId ORDER BY low_quality_count DESC LIMIT 3;",
        "step": "【step1】: Filter records in SensorData table where dataQuality is '低'  【step2】: Group filtered records by sensorId and count occurrences using COUNT(dataId)  【step3】: Sort results by low_quality_count in descending order and limit output to top 3 sensors",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1936,
        "question": "Find all devices in the Devices table where the device type is 'Security' and the status is 'Fault', sorted in ascending order by device name.",
        "query": "SELECT * FROM Devices WHERE deviceType = '安防' AND status = '故障' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter records from Devices table where deviceType is '安防'  【step2】: Apply additional filter to retain only records with status '故障' from step1 results  【step3】: Sort the final results by deviceName in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1937,
        "question": "Assuming the real-time temperature of all devices in the EnergyConsumption table suddenly increases to 1000 degrees Celsius, calculate the average real-time temperature (in degrees Celsius) for each device, and identify the top 3 devices with the highest average temperature.",
        "query": "SELECT AVG(1000) AS avg_temperature, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_temperature DESC LIMIT 3;",
        "step": "【step1】: Group all records in EnergyConsumption by deviceId and calculate the average temperature for each group, explicitly setting temperature to 1000 for all devices using AVG(1000).  【step2】: Sort the grouped results in descending order by the calculated average temperature (which is uniformly 1000).  【step3】: Limit the output to the top 3 deviceIds, though all devices have identical averages, resulting in arbitrary selection.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1938,
        "question": "Calculate the average volume (in cubic meters) for each product in the Products table and identify the top 3 products with the largest average volume.",
        "query": "SELECT AVG(volume) AS avg_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_volume DESC LIMIT 3;",
        "step": "【step1】: GROUP BY productId and productName to calculate average volume per product (incorrect logic as grouping makes AVG redundant for unique products).  【step2】: ORDER BY avg_volume DESC to sort products by their individual volume values.  【step3】: LIMIT 3 to retrieve top 3 largest-volume products.  Note: The original query contains flawed logic. Proper approach:  1. Calculate overall average volume: `SELECT AVG(volume) FROM Products`  2. Get top 3 individual volumes: `SELECT productId, productName, volume FROM Products ORDER BY volume DESC LIMIT 3`",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1939,
        "question": "Calculate the total tax amount for each product in the Orders table, sort them in descending order by total tax amount, and find the top 5 products with the highest total tax amounts.",
        "query": "SELECT productId, SUM(tax) AS total_tax FROM Orders GROUP BY productId ORDER BY total_tax DESC LIMIT 5;",
        "step": "【step1】: Group orders by productId and calculate the sum of the tax field for each group using `GROUP BY productId` with `SUM(tax)`.  【step2】: Sort the aggregated results in descending order of the calculated total tax using `ORDER BY total_tax DESC`.  【step3】: Restrict the output to the top 5 records with the highest total tax values using `LIMIT 5`.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1940,
        "question": "Find all orders in the Orders table where the order status is 'Shipped' and the payment method is 'Alipay', sorted by order date in ascending order.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已发货' AND paymentMethod = '支付宝' ORDER BY orderDate ASC;",
        "step": "【step1】: Filter records from Orders table where orderStatus equals '已发货'  【step2】: Apply additional filter on paymentMethod equals '支付宝' from step1 results  【step3】: Sort the remaining records by orderDate in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1941,
        "question": "List the order ID, shipment date, and actual delivery date for all logistics records with a logistics status of \"Delivered,\" sorted by shipment date in ascending order.",
        "query": "SELECT orderId, shippingDate, actualDeliveryDate FROM Shipping WHERE shippingStatus = '已签收' ORDER BY shippingDate ASC;",
        "step": "【step1】: Filter records from the Shipping table where shippingStatus equals '已签收'.  【step2】: Select the required columns (orderId, shippingDate, actualDeliveryDate) from the filtered results.  【step3】: Sort the final output by shippingDate in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1942,
        "question": "Calculate the average purchase price (in yuan) of all devices in the MaintenanceRecords table, assuming the purchase price is the total maintenance cost divided by the number of devices.",
        "query": "SELECT SUM(cost) / COUNT(deviceId) AS avg_purchase_price FROM MaintenanceRecords;",
        "step": "【step1】: Calculate the total maintenance cost using SUM(cost) from the MaintenanceRecords table.  【step2】: Count the number of distinct devices using COUNT(DISTINCT deviceId) to avoid duplicate device entries in MaintenanceRecords.  【step3】: Divide the total cost by the device count to compute the average purchase price: SUM(cost)/COUNT(DISTINCT deviceId) AS avg_purchase_price.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1943,
        "question": "Count the number of maintenance records for each maintenance type in the MaintenanceRecords table, sort them in descending order by quantity, and identify the top 3 maintenance types with the highest number of maintenance records.",
        "query": "SELECT maintenanceType, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY maintenanceType ORDER BY maintenance_count DESC LIMIT 3;",
        "step": "【step1】: Group all records in MaintenanceRecords by maintenanceType and count the number of maintenanceId entries for each group  【step2】: Sort the grouped results by maintenance_count in descending order  【step3】: Restrict the final output to show only the top 3 entries with highest counts using LIMIT",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1944,
        "question": "Find all devices in the Devices table with a status of 'disabled' and located in the 'warehouse', sorted in ascending order by device name.",
        "query": "SELECT * FROM Devices WHERE status = '停用' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = '仓库') ORDER BY deviceName ASC;",
        "step": "【step1】: Execute subquery to select locationId from Locations table where locationName is '仓库'  【step2】: Filter Devices table where status = '停用' and locationId matches subquery results  【step3】: Sort final output by deviceName in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1945,
        "question": "Assuming the total maintenance cost of all devices in the MaintenanceRecords table is 1,000,000 yuan, find the device with the highest average purchase price, where the average purchase price per device is calculated as the total maintenance cost divided by the number of devices.",
        "query": "SELECT SUM(1000000) / COUNT(deviceId) AS avg_purchase_price, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_purchase_price DESC LIMIT 1;",
        "step": "【step1】: Retrieve all device IDs and calculate the average maintenance cost per device by dividing the total fixed cost (1,000,000) by the number of maintenance records per device.  【step2】: Group the results by deviceId and compute the derived avg_purchase_price (incorrectly named, as it actually represents average maintenance cost).  【step3】: Sort the grouped results by avg_purchase_price in descending order and return the top record to identify the device with the highest value derived from this artificial cost calculation.  (This analysis highlights critical inconsistencies:  1. The query incorrectly uses maintenance records to calculate \"purchase price,\" which is unrelated to the MaintenanceRecords table.  2. EnergyDevices table lacks a purchase price field, making the problem’s premise invalid based on the provided schema.)",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1946,
        "question": "Find the experiment name, measured value, environmental conditions, and timestamp for all experimental data where the environmental conditions contain \"temperature:3\" and the extracted temperature value is above 30, sorted in descending order of the extracted temperature value.",
        "query": "SELECT e.experimentName, ed.measurementValue, ed.environmentalConditions, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId WHERE ed.environmentalConditions LIKE '%温度:3%' ORDER BY ed.environmentalConditions DESC;",
        "step": "【step1】: Perform INNER JOIN between ExperimentData and Experiments tables using experimentId to link experiment data with corresponding experiment names.  【step2】: Filter records where environmentalConditions contains '温度:3' (indicating temperatures starting with 3, e.g., 30°C+), using wildcard matching.  【step3】: Sort results by environmentalConditions DESC lexicographically (note: this may not sort numerically as intended due to text-based field).",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "2",
        "idx": 1947,
        "question": "Calculate the proportion of abnormal data (where dataStatus is 'abnormal') for each sensor in the SensorData table, sort them in descending order by proportion, and identify the top 3 sensors with the highest abnormal data ratio.",
        "query": "SELECT sensorId, COUNT(dataId) * 1.0 / (SELECT COUNT(dataId) FROM SensorData WHERE sensorId = s.sensorId) AS anomaly_ratio FROM SensorData s WHERE dataStatus = '异常' GROUP BY sensorId ORDER BY anomaly_ratio DESC LIMIT 3;",
        "step": "【step1】: Filter and count abnormal data entries for each sensor using `WHERE dataStatus = '异常'` and `GROUP BY sensorId`.  【step2】: Calculate total data entries per sensor via a correlated subquery `(SELECT COUNT(dataId) FROM SensorData WHERE sensorId = s.sensorId)`.  【step3】: Compute the anomaly ratio (abnormal count / total count), sort results by `anomaly_ratio DESC`, and limit to the top 3 sensors.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1948,
        "question": "Find all devices in the Devices table where the device type is 'Entertainment' and the status is 'Online', sorted by device name in ascending order.",
        "query": "SELECT * FROM Devices WHERE deviceType = '娱乐' AND status = '在线' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter records from Devices where deviceType is '娱乐'  【step2】: Further filter the results to include only devices with status '在线'  【step3】: Sort the remaining records by deviceName in ascending order",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1949,
        "question": "Assuming the real-time humidity of all devices in the EnergyConsumption table suddenly increases to 100%, calculate the average humidity (in percentage) for each device, and identify the top 3 devices with the highest average humidity.",
        "query": "SELECT AVG(100) AS avg_humidity, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_humidity DESC LIMIT 3;",
        "step": "【step1】: Calculate the average humidity value (fixed at 100%) per device using AVG(100) and group by deviceId.  【step2】: Order the results by avg_humidity in descending order (though all values are 100, ordering has no practical effect).  【step3】: Limit the output to the top 3 devices, which are arbitrarily selected due to identical averages.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1950,
        "question": "Calculate the average price (in yuan) for each product in the Products table, and find the top 3 products with the highest average prices.",
        "query": "SELECT AVG(price) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;",
        "step": "【step1】: Calculate individual product prices grouped by productId and productName. Since each product has a unique price, AVG(price) effectively returns the original price.  【step2】: Order the results by the calculated avg_price (which equals actual price) in descending order.  【step3】: Limit the output to the top 3 highest-priced products using LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1951,
        "question": "Calculate the total discount amount for each user in the Orders table, sort by total discount amount in descending order, and identify the top 5 users with the highest total discount amounts.",
        "query": "SELECT userId, SUM(discount) AS total_discount FROM Orders GROUP BY userId ORDER BY total_discount DESC LIMIT 5;",
        "step": "【step1】: Group the records in the Orders table by userId and calculate the total discount for each user using SUM(discount).  【step2】: Sort the grouped results in descending order based on the total_discount value.  【step3】: Restrict the output to only show the top 5 users with the highest total discount amounts using LIMIT 5.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1952,
        "question": "Find all orders in the Orders table where the order status is 'Completed' and the payment method is 'Credit Card', and sort them in ascending order by order date.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentMethod = '信用卡' ORDER BY orderDate ASC;",
        "step": "【step1】: Filter records from Orders table where orderStatus is 'Completed'  【step2】: From the filtered results, select records where paymentMethod is 'Credit Card'  【step3】: Sort the remaining records in ascending order by orderDate",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1953,
        "question": "Assuming the price of all products in the Products table suddenly increases to 100,000 yuan, calculate the average price of all products (in yuan) and identify the top 3 products by average price.",
        "query": "SELECT AVG(100000) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;",
        "step": "【step1】: Calculate the average price by applying AVG(100000) without grouping, since all prices are fixed at 100000.  【step2】: Select productId and productName while statically setting price=100000 for all products.  【step3】: Order results by avg_price (which is identical for all entries) and apply LIMIT 3. The GROUP BY clause creates redundant groupings but doesn't affect the final output due to identical values.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 1954,
        "question": "Calculate the average maintenance cost (in yuan) for each device and identify the top 3 devices with the highest average maintenance costs.",
        "query": "SELECT AVG(cost) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;",
        "step": "【step1】: GROUP BY deviceId to calculate average maintenance cost per device using AVG(cost).  【step2】: ORDER BY avg_cost DESC to sort devices by highest average maintenance cost.  【step3】: LIMIT 3 to retrieve only the top 3 devices with the highest maintenance costs.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1955,
        "question": "Calculate the total maintenance cost for each technician in the MaintenanceRecords table, sort them in descending order by cost, and identify the top 3 technicians with the highest maintenance costs.",
        "query": "SELECT technicianName, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY technicianName ORDER BY total_cost DESC LIMIT 3;",
        "step": "【step1】: Group records by technicianName and calculate the sum of cost for each technician using GROUP BY and SUM(cost).  【step2】: Sort the aggregated results in descending order of total_cost using ORDER BY total_cost DESC.  【step3】: Restrict the output to the top 3 entries using LIMIT 3 to show technicians with highest maintenance costs.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1956,
        "question": "Find all devices in the Devices table with a status of 'under maintenance' and located in the 'laboratory', sorted in ascending order by device name.",
        "query": "SELECT * FROM Devices WHERE status = '维修中' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = '实验室') ORDER BY deviceName ASC;",
        "step": "【step1】: Retrieve locationId(s) from Locations table where locationName is '实验室' using subquery: SELECT locationId FROM Locations WHERE locationName = '实验室'  【step2】: Filter Devices table records where status = '维修中' and locationId matches any value from the subquery result  【step3】: Sort the final results by deviceName in ascending order using ORDER BY clause",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1957,
        "question": "Assuming the cost of all maintenance records in the MaintenanceRecords table is 1,000,000 yuan, calculate the average maintenance cost for each device (unit: yuan), and find the top 3 devices with the highest average maintenance cost.",
        "query": "SELECT AVG(1000000) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;",
        "step": "【step1】: Calculate the average cost per device by replacing all maintenance costs with 1000000 and grouping by deviceId. Since AVG(1000000) is a constant, this effectively assigns 1000000 as the average cost for every device.  【step2】: Order the results by the calculated average cost (descending). However, since all averages are identical (1000000), the ordering has no logical impact.  【step3】: Limit the output to the top 3 devices. Due to identical average costs, this arbitrarily returns the first 3 deviceIds encountered in the dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1958,
        "question": "List all experimental names, calculation results, computational formulas, and units of calculation for records where the calculation result is greater than 1000 and the data quality is \"high,\" sorted in descending order by the calculation result.",
        "query": "SELECT e.experimentName, c.result, c.formula, c.unit FROM Calculations c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.result > 1000 AND c.dataQuality = '高' ORDER BY c.result DESC;",
        "step": "【step1】: Join Calculations and Experiments tables using experimentId to combine calculation details with experiment names.  【step2】: Filter records where result > 1000 and dataQuality = '高' from the joined dataset.  【step3】: Sort the filtered results by result in descending order and output specified fields.",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "2",
        "idx": 1959,
        "question": "Calculate the data collection time interval (in seconds) for each sensor in the SensorData table, sort them in ascending order, and identify the top 3 sensors with the shortest collection intervals.",
        "query": "SELECT sensorId, (strftime('%s', MAX(timestamp)) - strftime('%s', MIN(timestamp))) AS time_interval FROM SensorData GROUP BY sensorId ORDER BY time_interval ASC LIMIT 3;",
        "step": "【step1】: Group sensor data by sensorId and calculate the time interval between earliest and latest timestamp in seconds.  【step2】: Sort the results by the calculated time_interval in ascending order.  【step3】: Limit the output to the top 3 records with the smallest intervals.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1960,
        "question": "Find all devices in the Devices table where the device type is 'Lighting' and the status is 'Offline', sorted in ascending order by device name.",
        "query": "SELECT * FROM Devices WHERE deviceType = '照明' AND status = '离线' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter the Devices table to include only records where deviceType is '照明'  【step2】: Further filter the results to retain only devices with status '离线'  【step3】: Apply ascending order sorting based on the deviceName field",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "4",
        "idx": 1961,
        "question": "Find the names, contacts, and cities of all manufacturers with revenue exceeding 1000, and sort them in descending order by revenue.",
        "query": "SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;",
        "step": "【step1】: Filter manufacturers with annual revenue exceeding 10 million using WHERE revenue > 1000  【step2】: Select the required columns (manufacturerName, contactPerson, city) from the filtered dataset  【step3】: Sort results in descending order by revenue using ORDER BY revenue DESC",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1962,
        "question": "Calculate the inventory turnover rate (turnover rate is total sales quantity divided by inventory stock) for each product, and identify the top 3 products with the highest turnover rates.",
        "query": "SELECT productId, SUM(quantity) / stock AS turnover_rate FROM Orders GROUP BY productId ORDER BY turnover_rate DESC LIMIT 3;",
        "step": "【step1】:【Aggregate total quantity sold per product from OrderDetails using GROUP BY productId and SUM(quantity).】  【step2】:【Join with Products table to access stock values and calculate turnover rate (SUM(quantity)/stock).】  【step3】:【Order results by turnover_rate in descending order and limit to top 3 using ORDER BY and LIMIT.】",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1963,
        "question": "Calculate the total shipping cost for each product in the Orders table, sort them in descending order by shipping cost, and find the top 5 products with the highest shipping costs.",
        "query": "SELECT productId, SUM(shippingFee) AS total_shipping_fee FROM Orders GROUP BY productId ORDER BY total_shipping_fee DESC LIMIT 5;",
        "step": "【step1】: Group the records in the Orders table by productId and calculate the total shipping fee for each group using SUM(shippingFee).  【step2】: Sort the aggregated results in descending order based on the total_shipping_fee.  【step3】: Restrict the output to the top 5 rows using LIMIT 5 to show the highest total shipping fees.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1964,
        "question": "Find the product ID, rating, and review content of all evaluation records with ratings greater than 4, and sort them in descending order by rating.",
        "query": "SELECT productId, rating, reviewText FROM Reviews WHERE rating > 4 ORDER BY rating DESC;",
        "step": "【step1】: Select the productId, rating, and reviewText columns from the Reviews table.  【step2】: Apply a filter to retain only records where the rating exceeds 4.  【step3】: Sort the filtered results in descending order based on the rating column.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1965,
        "question": "List all discount records with a discount type of \"Percentage Discount\" and a discount status of \"Enabled,\" including the product ID, discount value, and discount description, sorted in descending order by the discount value.",
        "query": "SELECT productId, discoutValue, description FROM Discounts WHERE discoutType = '百分比折扣' AND status = '启用' ORDER BY discoutValue DESC;",
        "step": "【step1】: Select productId, discoutValue, description columns from Discounts table  【step2】: Filter records where discountType is '百分比折扣' and status is '启用'  【step3】: Sort results by discoutValue in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1966,
        "question": "List the order ID, total order amount, and payment method for all orders where the total amount exceeds 5,000 yuan and the payment method is \"Alipay,\" sorted in descending order by the total order amount.",
        "query": "SELECT orderId, totalAmount, paymentMethod FROM Orders WHERE totalAmount > 5000 AND paymentMethod = '支付宝' ORDER BY totalAmount DESC;",
        "step": "【step1】: Select orderId, totalAmount, and paymentMethod columns from Orders table.  【step2】: Filter records where totalAmount exceeds 5000 and paymentMethod is '支付宝'.  【step3】: Sort the results by totalAmount in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1967,
        "question": "Retrieve the names, prices, and listing dates of all products with the category \"Electronics\" that weigh less than 1 kilogram, sorted by listing date in descending order.",
        "query": "SELECT productName, price, creationDate FROM Products WHERE category = '电子产品' AND weight < 1 ORDER BY creationDate DESC;",
        "step": "【step1】: Select the required columns (productName, price, creationDate) from the Products table.  【step2】: Filter rows where category equals '电子产品' and weight is less than 1 using the WHERE clause.  【step3】: Sort the results by creationDate in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1968,
        "question": "Find the variable names, experiment names, initial values, and units for all variables where the initial value is greater than 50 and the data quality is \"High,\" sorted in descending order by initial value.",
        "query": "SELECT v.variableName, e.experimentName, v.initialValue, v.unit FROM Variables v JOIN Experiments e ON v.experimentId = e.experimentId WHERE v.initialValue > 50 AND v.dataQuality = '高' ORDER BY v.initialValue DESC;",
        "step": "【step1】: Perform INNER JOIN between Variables (v) and Experiments (e) tables using experimentId to link variable data with experiment information.  【step2】: Filter results where initialValue exceeds 50 and dataQuality equals '高'.  【step3】: Sort the final dataset by initialValue in descending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1969,
        "question": "Find all maintenance records with a maintenance cost greater than 5,000 yuan, including the equipment ID, maintenance date, and maintenance type, sorted in descending order by maintenance cost.",
        "query": "SELECT deviceId, maintenanceDate, maintenanceType FROM MaintenanceRecords WHERE cost > 5000 ORDER BY cost DESC;",
        "step": "【step1】: Filter records from MaintenanceRecords where maintenance cost exceeds 5000 using WHERE cost > 5000  【step2】: Select required columns (deviceId, maintenanceDate, maintenanceType) using projection  【step3】: Sort results by cost in descending order using ORDER BY cost DESC",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1970,
        "question": "List the names of all devices with a status of \"fault\" located in labs with a status of \"open\", along with the lab names and device statuses, sorted in ascending order by device name.",
        "query": "SELECT d.deviceName, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.status = '故障' AND l.status = '开放' ORDER BY d.deviceName ASC;",
        "step": "【step1】: Perform an INNER JOIN between Devices (d) and Labs (l) using labId to combine device and lab information.  【step2】: Apply filters WHERE d.status = '故障' to select faulty devices and l.status = '开放' to ensure labs are open.  【step3】: Sort the final results by d.deviceName in ascending order using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1971,
        "question": "Find the name, objective, start date, and end date of all experiments where the objective includes \"energy\" and the status is \"completed,\" sorted by end date in descending order.",
        "query": "SELECT experimentName, objective, startDate, endDate FROM Experiments WHERE objective LIKE '%energy%' AND status = '已完成' ORDER BY endDate DESC;",
        "step": "【step1】: Select required columns (experimentName, objective, startDate, endDate) from Experiments table  【step2】: Apply filters: objective contains \"energy\" (LIKE '%energy%') and status equals '已完成'  【step3】: Sort results by endDate in descending order using ORDER BY",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1972,
        "question": "Find all devices in the Devices table where the device type is 'Security' and the status is 'Online', sorted by device name in ascending order.",
        "query": "SELECT * FROM Devices WHERE deviceType = '安防' AND status = '在线' ORDER BY deviceName ASC;",
        "step": "【step1】: Filter all records in the Devices table where deviceType equals '安防'.  【step2】: From the filtered results, select records where status equals '在线'.  【step3】: Sort the final results by deviceName in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1973,
        "question": "Assuming the power factor for all device records in the EnergyConsumption table is set to 1.5, identify the top 3 devices with the highest average power factor.",
        "query": "SELECT AVG(1.5) AS avg_power_factor, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power_factor DESC LIMIT 3;",
        "step": "【step1】: Group all entries in EnergyConsumption by deviceId, force-set power factor to 1.5 for each record and calculate the average per device.  【step2】: Sort the grouped results by the computed average_power_factor (1.5 for all devices) in descending order.  【step3】: Apply LIMIT 3 to return the top 3 devices, though all grouped averages are identical (1.5).",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1974,
        "question": "Calculate the average shipping volume of all products in the Products table, and identify the top 3 products with the largest average shipping volumes.",
        "query": "SELECT AVG(volume) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;",
        "step": "【step1】: Calculate the average shipping volume (AVG(volume)) for each product by grouping records using productId and productName.  【step2】: Order the results in descending order based on the calculated average shipping volume.  【step3】: Limit the output to the top 3 products with the highest average shipping volume using LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1975,
        "question": "Calculate the total tax amount for each user in the Orders table, sort them in descending order by the total tax amount, and identify the top 5 users with the highest total tax amounts.",
        "query": "SELECT userId, SUM(tax) AS total_tax FROM Orders GROUP BY userId ORDER BY total_tax DESC LIMIT 5;",
        "step": "【step1】: Group the Orders table by userId and calculate the sum of tax for each user using SUM(tax) AS total_tax.  【step2】: Sort the aggregated results in descending order based on total_tax using ORDER BY total_tax DESC.  【step3】: Limit the output to the top 5 users with the highest total tax using LIMIT 5.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1976,
        "question": "Find all orders in the Orders table where the order status is 'Completed' and the payment method is 'Alipay', sorted by order date in ascending order.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentMethod = '支付宝' ORDER BY orderDate ASC;",
        "step": "【step1】: Retrieve all records from the Orders table  【step2】: Filter records where orderStatus is '已完成' AND paymentMethod is '支付宝'  【step3】: Sort the filtered results in ascending order by orderDate",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1977,
        "question": "Assuming the delivery volume of all products in the Products table is 1000 cubic meters, identify the top 3 products with the largest delivery volume.",
        "query": "SELECT AVG(1000) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;",
        "step": "【step1】:【Set all products' shipping volume to 1000 and calculate the fixed average value (AVG(1000) = 1000) for each product grouped by productId and productName】  【step2】:【Order the results by the calculated avg_shipping_volume (which is identical for all entries) in descending order】  【step3】:【Limit the output to the top 3 entries, effectively returning arbitrary products due to identical sorting values】",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 1978,
        "question": "Calculate the average maintenance interval (in days) for each device in the Devices table, and identify the top 3 devices with the shortest average maintenance intervals.",
        "query": "SELECT AVG(julianday(nextMaintenanceDate) - julianday(lastMaintenanceDate)) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 3;",
        "step": "【step1】: Calculate the maintenance interval in days for each device using julianday() function on lastMaintenanceDate and nextMaintenanceDate columns  【step2】: Group results by deviceId and calculate average interval using AVG() function  【step3】: Sort by avg_interval ascending and limit to top 3 records",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1979,
        "question": "Calculate the total maintenance cost for each device in the MaintenanceRecords table, sort them in descending order by cost, and identify the top 3 devices with the highest maintenance costs.",
        "query": "SELECT deviceId, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY deviceId ORDER BY total_cost DESC LIMIT 3;",
        "step": "【step1】: Group the records in the MaintenanceRecords table by deviceId and calculate the total maintenance cost for each device using SUM(cost).  【step2】: Sort the grouped results in descending order based on the total_cost.  【step3】: Limit the final output to the top 3 devices with the highest maintenance costs using LIMIT 3.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1980,
        "question": "List the name, calibration date, laboratory name, and status of all devices with the type \"spectrometer\" that were calibrated after 2022, sorted by calibration date in ascending order.",
        "query": "SELECT d.deviceName, d.calibrationDate, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = '光谱仪' AND d.calibrationDate > '2022-01-01' ORDER BY d.calibrationDate ASC;",
        "step": "【step1】: Perform a JOIN between the `Devices` and `Labs` tables using `labId` to combine device and lab information.  【step2】: Filter the results where `deviceType` is '光谱仪' and `calibrationDate` is after '2022-01-01'.  【step3】: Sort the filtered records by `calibrationDate` in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1981,
        "question": "Assuming the maintenance interval for all devices in the Devices table is set to 0 days, identify the device with the shortest (lowest) maintenance interval.",
        "query": "SELECT AVG(0) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;",
        "step": "【step1】: Calculate the average maintenance interval (0 days) for each device using AVG(0) and group by deviceId.  【step2】: Order the results by avg_interval in ascending order to prioritize the shortest intervals.  【step3】: Limit the output to 1 row to retrieve the device with the \"shortest\" interval (all will be 0, so this arbitrarily picks one).",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1982,
        "question": "Find the experiment names, measurement values, device names, and timestamps from all experimental data where the data quality is \"low\" and the measurement value is less than 50, sorted in ascending order by measurement value.",
        "query": "SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = '低' AND ed.measurementValue < 50 ORDER BY ed.measurementValue ASC;",
        "step": "【step1】: Filter ExperimentData table to select rows where dataQuality is '低' and measurementValue < 50.  【step2】: Join ExperimentData with Experiments on experimentId to get experimentName, and with Devices on deviceId to get deviceName.  【step3】: Order the combined results by measurementValue in ascending order.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1983,
        "question": "Find equipment that has passed the warranty period but is still in use.",
        "query": "SELECT * FROM Devices WHERE warrantyExpiryDate < DATE('now') AND status = '运行中';",
        "step": "【step1】: Filter devices where the warranty expiration date is earlier than the current date using WHERE warrantyExpiryDate < DATE('now')  【step2】: Further refine results by checking devices still in active use with AND status = '运行中'  【step3】: Combine both conditions in a single SELECT statement to retrieve all matching device records",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 1984,
        "question": "List all hypotheses with a verification result of \"true\" and a verification date after January 1, 2022, including the hypothesis text, experiment name, verification date, and researcher name, sorted in ascending order by the verification date.",
        "query": "SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId JOIN Researchers r ON e.researcherId = r.researcherId WHERE h.verificationResult = '真' AND h.verificationDate > '2022-01-01' ORDER BY h.verificationDate ASC;",
        "step": "【step1】: JOIN Hypotheses and Experiments tables using experimentId to link hypothesis data with corresponding experiment information.  【step2】: JOIN the result with Researchers table via researcherId to associate each experiment with its responsible researcher.  【step3】: Apply WHERE clause to filter records with verificationResult='真' and verificationDate after 2022-01-01, then ORDER BY verificationDate in ascending sequence.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1985,
        "question": "Statistics on the average energy consumption of each type of equipment, sorted in descending order of energy consumption.",
        "query": "SELECT deviceType, AVG(measurementValue) AS Avg_Energy_Consumption FROM Devices JOIN ExperimentData ON Devices.deviceId = ExperimentData.deviceId GROUP BY deviceType ORDER BY Avg_Energy_Consumption DESC;",
        "step": "【step1】: Join Devices and ExperimentData tables using deviceId to associate devices with their corresponding experiment measurements.  【step2】: Group the joined data by deviceType and calculate the average of measurementValue for each group.  【step3】: Sort the grouped results in descending order based on the computed average energy consumption.",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "3",
        "idx": 1986,
        "question": "Find abnormal records where the sensor data value exceeds 50 or falls below -20.",
        "query": "SELECT * FROM SensorData WHERE dataValue > 50 OR dataValue < -20;",
        "step": "【step1】: Select all records from the SensorData table without filtering.  【step2】: Apply the first condition (dataValue > 50) to filter records with temperature exceeding 50℃.  【step3】: Combine with the second condition (dataValue < -20) using OR to include records below -20℃, returning the final abnormal records.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 1987,
        "question": "Assuming the energy consumption of all devices increases by 20%, calculate the total increased energy consumption by device type.",
        "query": "SELECT ed.deviceType, AVG(ec.energyConsumed) AS avg_energy_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY avg_energy_consumption DESC;",
        "step": "【step1】: Calculate the adjusted annual energy consumption by summing each device's energy consumption increased by 20% using `SUM(ec.energyConsumed * 1.2)`.  【step2】: Multiply the total adjusted consumption by the electricity rate (assumed or provided value) to derive the annual cost via `SUM(ec.energyConsumed * 1.2) * [electricity_rate] AS total_cost`.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1988,
        "question": "Calculate the total weight of products (unit: kilograms).",
        "query": "SELECT SUM(weight) AS total_weight FROM Products;",
        "step": "【step1】: Access the 'Products' table to retrieve the weight column for all products.  【step2】: Apply the SUM() aggregation function on the weight column to compute the total weight in kilograms.  【step3】: [N/A] (The query requires only a straightforward aggregation without joins/filters)",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1989,
        "question": "Count the total spending amount for each user and sort them in descending order by the total amount spent.",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;",
        "step": "【step1】: Retrieve user IDs and totalAmount fields from the Orders table.  【step2】: Group the results by userId and calculate the sum of totalAmount for each user, aliased as total_spent.  【step3】: Sort the grouped results in descending order based on the calculated total_spent.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1990,
        "question": "Find records where the order status is 'completed' but the payment was not successful.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentStatus != '成功';",
        "step": "【step1】: Filter orders with '已完成' status from Orders table  【step2】: Join with Payments table using orderId to access paymentStatus field  【step3】: Exclude records where paymentStatus = '成功' or filter by paymentStatus != '成功'",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1991,
        "question": "Assuming the weight of all products increases by 50%, calculate the total shipping weight.",
        "query": "SELECT SUM(weight * 1.5) AS total_weight FROM Products;",
        "step": "【step1】: Calculate the increased weight for each product by multiplying the original weight by 1.5.  【step2】: Sum all adjusted weights using the SUM() function to obtain the total transportation weight.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 1992,
        "question": "Count the number of orders that have a status of 'Completed' but a payment status other than 'Success'.",
        "query": "SELECT o.orderId, o.orderStatus, p.paymentStatus FROM Orders o JOIN Payments p ON o.orderId = p.orderId WHERE o.orderStatus = '已完成' AND p.paymentStatus != '成功';",
        "step": "【step1】:【Join Orders and Payments tables using orderId to combine order and payment information】  【step2】:【Filter results where orderStatus is '已完成' and paymentStatus is not '成功'】  【step3】:【Select orderId, orderStatus, and paymentStatus fields from the filtered dataset】",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1993,
        "question": "Find device records with purchase dates after today.",
        "query": "SELECT * FROM Devices WHERE purchaseDate > DATE('now');",
        "step": "【step1】: Retrieve current date using DATE('now') to establish comparison baseline.  【step2】: Filter records in Devices table where purchaseDate exceeds the retrieved current date.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 1994,
        "question": "Statistics on the status distribution (online, offline, malfunction) for each device type.",
        "query": "SELECT deviceType, status, COUNT(deviceId) AS device_count FROM Devices GROUP BY deviceType, status;",
        "step": "【step1】: Retrieve device type and status data from Devices table.  【step2】: Group records by both deviceType and status columns.  【step3】: Count devices (deviceId) in each grouped category to display status distribution.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 1995,
        "question": "Identify devices that are currently offline (status 'fault') but have recent energy consumption records in the experiment data.",
        "query": "SELECT * FROM Devices WHERE status = '故障' AND deviceId IN (SELECT deviceId FROM ExperimentData WHERE timestamp > DATE('now'));",
        "step": "【step1】: Retrieve all devices with '故障' status from Devices table  【step2】: Filter ExperimentData records where timestamp exceeds current date and extract associated deviceIds  【step3】: Combine results using IN operator to find faulty devices paradoxically recording experiment data after becoming offline",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 1996,
        "question": "Calculate the total volume of products (unit: cubic meters).",
        "query": "SELECT SUM(volume) AS total_volume FROM Products;",
        "step": "【step1】: Access the 'Products' table to retrieve the volume data for all products.  【step2】: Calculate the total volume by summing the 'volume' column across all records using the SUM() aggregation function.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 1997,
        "question": "Statistics the total energy consumed by offline devices where the energy consumed is greater than zero.",
        "query": "SELECT * FROM EnergyConsumption WHERE deviceId IN (SELECT deviceId FROM EnergyDevices WHERE status = '离线') AND energyConsumed > 0;",
        "step": "【step1】: Execute the subquery to retrieve deviceId values from the EnergyDevices table where status is '离线'.  【step2】: Filter the EnergyConsumption table using the deviceId list from step1, and apply energyConsumed > 0 condition.  【step3】: Return all columns (*) from EnergyConsumption that satisfy the combined criteria.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 1998,
        "question": "Find records where the order status is 'shipped' but the tracking number has not been filled in.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已发货' AND trackingNumber IS NULL;",
        "step": "【step1】: Filter records from Orders table where orderStatus equals '已发货'  【step2】: Apply additional condition to select records where trackingNumber is NULL  【step3】: Return all columns matching both conditions (order status and missing tracking number)",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 1999,
        "question": "Assuming the total sales volume of all products increases by 20%, calculate the total shipping volume.",
        "query": "SELECT od.productId, SUM(od.quantity) AS total_sales FROM OrderDetails od GROUP BY od.productId ORDER BY total_sales DESC;",
        "step": "【step1】: Join OrderDetails with Products to access each product's original volume.  【step2】: Calculate adjusted volume per item by multiplying original volume by 1.2, then multiply by quantity for each order detail.  【step3】: Aggregate results using SUM() to get the total adjusted shipping volume across all products.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 2000,
        "question": "Calculate the average age of the products since their creation date (assuming age is the current date minus the creation date).",
        "query": "SELECT * FROM Orders o JOIN Shipping s ON o.orderId = s.orderId WHERE o.orderStatus = '已发货' AND s.trackingNumber IS NULL;",
        "step": "【step1】: Join Orders and Shipping tables on orderId to link shipment information with orders.  【step2】: Filter records where orderStatus is '已发货' and trackingNumber is NULL.  【step3】: Return all fields of the combined dataset meeting these conditions.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 2001,
        "question": "Count the number of maintenance records for each technician and sort them in descending order by the count.",
        "query": "SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC;",
        "step": "【step1】: Retrieve all maintenance records from the MaintenanceRecords table, selecting the technicianName and maintenanceId fields.  【step2】: Group the records by technicianName and calculate the count of maintenanceId for each group using COUNT(maintenanceId) AS maintenance_count.  【step3】: Sort the grouped results in descending order based on maintenance_count using ORDER BY maintenance_count DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 2002,
        "question": "Find the average lifespan of devices by calculating the number of days between the current date and the purchase date.",
        "query": "SELECT AVG(DATEDIFF(NOW(), purchaseDate)) AS avg_lifespan FROM Devices;",
        "step": "【step1】: Perform INNER JOIN between MaintenanceRecords and Devices tables using deviceId to link maintenance and purchase dates  【step2】: Apply WHERE clause to filter records where maintenanceDate < purchaseDate  【step3】: Select conflict data fields (deviceId, maintenanceDate, purchaseDate) with explicit comparison in results",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 2003,
        "question": "Assuming the purchase date of all devices is advanced by 1 year, recalculate the average time since purchase.",
        "query": "SELECT AVG(JULIANDAY('now') - JULIANDAY(purchaseDate, '-1 year')) AS avg_lifespan FROM Devices;",
        "step": "【step1】: Adjust purchase dates by subtracting 1 year from the original purchaseDate for all devices  【step2】: Calculate the lifespan for each device by finding the difference between the current date (JULIANDAY('now')) and the adjusted purchase date (JULIANDAY(purchaseDate, '-1 year'))  【step3】: Compute the average of all calculated lifespans using the AVG() function",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 2004,
        "question": "Statistics on the data quality distribution (high, medium, low) for each type of sensor.",
        "query": "SELECT * FROM MaintenanceRecords WHERE maintenanceDate < (SELECT installationDate FROM EnergyDevices WHERE EnergyDevices.deviceId = MaintenanceRecords.deviceId);",
        "step": "【step1】: Retrieve the installationDate for each device from the EnergyDevices table by matching deviceId with MaintenanceRecords.  【step2】: Compare maintenanceDate in MaintenanceRecords with the corresponding installationDate from the subquery.  【step3】: Filter and return records where maintenanceDate is earlier than installationDate.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 2005,
        "question": "Identify abnormal records from humidity sensors where the measurement value exceeds 100 or falls below 0.",
        "query": "SELECT * FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '湿度传感器') AND (measurementValue > 100 OR measurementValue < 0);",
        "step": "【step1】: Retrieve all deviceIds from Devices where deviceType is '湿度传感器'.  【step2】: Filter ExperimentData records where deviceId matches the retrieved humidity sensor deviceIds.  【step3】: Apply additional conditions to select records with measurementValue exceeding 100% or below 0%.",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "4",
        "idx": 2006,
        "question": "Assuming a 50% increase in the carbon emission coefficient, calculate the total annual carbon emissions.",
        "query": "SELECT s.sensorType, sd.dataQuality, COUNT(sd.dataId) AS data_count FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType, sd.dataQuality;",
        "step": "【step1】: Perform JOIN operation between SensorData and Sensors tables to associate sensor readings with their corresponding sensor types and quality indicators.  【step2】: Multiply the original emission factor by 1.5 (50% increase) in the calculation logic, assuming energyConsumed values from EnergyConsumption are used for emission calculations.  【step3】: Aggregate total annual carbon emissions by applying the adjusted coefficient to energy consumption data, filtered by year and grouped by required dimensions.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 2007,
        "question": "Calculate the total shipping cost for the goods (assuming the shipping cost is weight × distance × 0.5 yuan per kilogram-kilometer).",
        "query": "SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;",
        "step": "【step1】: Access the 'Products' table to retrieve the weight of each product.  【step2】: Calculate the shipping cost for individual products by multiplying weight, distance (implicitly assumed from context), and the rate 0.5.  【step3】: Aggregate all individual shipping costs using SUM() to derive the total_shipping_cost.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2008,
        "question": "Count the total order amount for each user and sort in descending order by total amount.",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;",
        "step": "【step1】: Select userId and sum totalAmount for each user from Orders table.  【step2】: Group the results by userId to aggregate total spending per user.  【step3】: Order the aggregated results by total_spent in descending sequence.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 2009,
        "question": "Find records where the order amount is negative or zero.",
        "query": "SELECT SUM(p.weight * s.shippingFee * 0.5) AS total_shipping_cost FROM Products p JOIN Shipping s ON p.productId = s.orderId;",
        "step": "【step1】: Access the 'Orders' table to retrieve order records.  【step2】: Apply filter condition WHERE totalAmount <= 0 OR finalAmount <= 0.  【step3】: Return all fields (*) from the filtered orders where the amount is non-positive.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 2010,
        "question": "Assuming a 28% discount on freight rates, calculate the total shipping cost.",
        "query": "SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;",
        "step": "【step1】: Identify the original shipping rate (0.6) and apply a 20% increase, resulting in an adjusted rate of 0.6 * 1.2 = 0.72.  【step2】: Calculate the total shipping cost by summing the product of weight, distance, and the adjusted rate (0.72) for all entries in the Products table.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "1",
        "idx": 2011,
        "question": "Calculate the average maintenance interval of the equipment (unit: days).",
        "query": "SELECT AVG(JULIANDAY(nextMaintenanceDate) - JULIANDAY(lastMaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;",
        "step": "【step1】: Access the 'MaintenanceRecords' table to retrieve 'lastMaintenanceDate' and 'nextMaintenanceDate' for each maintenance record.  【step2】: Calculate the difference in days between 'nextMaintenanceDate' and 'lastMaintenanceDate' for each record using JULIANDAY() to convert dates to Julian day numbers.  【step3】: Compute the average of all calculated day differences using the AVG() function to determine the mean maintenance interval.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2012,
        "question": "Count the number of devices for each location, and sort them in descending order by quantity.",
        "query": "SELECT category AS product_category, COUNT(productId) AS product_count FROM Products GROUP BY category ORDER BY product_count DESC;",
        "step": "【step1】: Group all records in the 'Products' table by the 'category' column.  【step2】: Calculate the number of products in each category using COUNT(productId) and alias the result as 'product_count'.  【step3】: Sort the grouped results in descending order based on the 'product_count' value.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 2013,
        "question": "Identify the contradictory data in maintenance records where the maintenance date is later than the next scheduled maintenance date.",
        "query": "SELECT * FROM MaintenanceRecords WHERE maintenanceDate > nextMaintenanceDate;",
        "step": "【step1】: Retrieve all records from the MaintenanceRecords table.  【step2】: Apply the filter condition where maintenanceDate is later than nextMaintenanceDate.  【step3】: Return all columns for the conflicting records that meet the criteria.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 2014,
        "question": "Given the current number of devices per lab, what is the new average maintenance interval per lab if the maintenance interval for each device is reduced by 50%?",
        "query": "SELECT labId, COUNT(deviceId) AS device_count FROM Devices GROUP BY labId ORDER BY device_count DESC;",
        "step": "【step1】: Calculate the original average maintenance interval per device by analyzing the time difference between consecutive maintenance dates from MaintenanceRecords table.  【step2】: Apply a 50% reduction to each device's maintenance interval by multiplying the calculated intervals by 0.5.  【step3】: Aggregate the adjusted intervals and compute the final average maintenance interval, grouping by labId if required.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 2015,
        "question": "Count the failure rate (number of failures/days of use) for each type of device and sort them in descending order by failure rate.",
        "query": "SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;",
        "step": "【step1】: Calculate maintenance count per deviceType using GROUP BY and COUNT(maintenanceId)  【step2】: Compute usage days per deviceType with JULIANDAY difference between current date and installationDate  【step3】: Derive failure_rate by dividing maintenance count by usage days, then ORDER BY failure_rate DESC",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 2016,
        "question": "Identify records where the device installation date is in the future.",
        "query": "SELECT * FROM EnergyDevices WHERE installationDate > NOW();",
        "step": "【step1】: Identify the target table \"EnergyDevices\" where installation dates are stored.  【step2】: Apply the filter condition \"installationDate > NOW()\" to select records with future installation dates.  【step3】: Execute the SELECT * query to retrieve all columns from the filtered records.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 2017,
        "question": "Assuming the power of all devices increases by 40%, what is the failure rate for each device type, and how does it relate to the total annual electricity cost?",
        "query": "SELECT e.deviceType, COUNT(m.maintenanceId) / AVG(DATEDIFF(NOW(), e.installationDate)) AS failure_rate FROM MaintenanceRecords m JOIN EnergyDevices e ON m.deviceId = e.deviceId GROUP BY e.deviceType ORDER BY failure_rate DESC;",
        "step": "【step1】:JOIN MaintenanceRecords and EnergyDevices using deviceId to associate maintenance records with device information  【step2】:GROUP BY deviceType and calculate failure_rate as (total maintenance count) divided by (average days since installation)  【step3】:ORDER results by calculated failure_rate in descending order to show most failure-prone device types first",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 2018,
        "question": "Calculate the average weight of the products (unit: kilograms).",
        "query": "SELECT AVG(measurementValue) AS avg_weight FROM ExperimentData WHERE unit = 'kg';",
        "step": "【step1】: Filter ExperimentData records where the unit is 'kg'  【step2】: Calculate the average of the measurementValue column from the filtered records  【step3】: Output the result as avg_weight using column aliasing",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2019,
        "question": "Count the total sales for each product category and sort them in descending order by total sales.",
        "query": "SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;",
        "step": "【step1】: Retrieve all records from the Orders table and group them by the category column.  【step2】: Calculate the sum of totalPrice for each grouped category, aliased as total_sales.  【step3】: Sort the result set in descending order based on the total_sales value.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 2020,
        "question": "Find records where the product inventory is negative or zero.",
        "query": "SELECT * FROM Products WHERE stock <= 0;",
        "step": "【step1】: Access the 'Products' table to retrieve all columns.  【step2】: Apply filter condition `WHERE stock <= 0` to select records with non-positive stock values.  【step3】: (Not required for this simple query. Omitted as per guidelines.)",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 2021,
        "question": "Assuming the weight of all products is reduced by 30%, what is the total transportation weight for each product category?",
        "query": "SELECT p.category, SUM(od.quantity * p.weight) AS total_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId GROUP BY p.category ORDER BY total_weight DESC;",
        "step": "【step1】: Join OrderDetails and Products tables to associate each ordered product with its weight.  【step2】: Calculate adjusted weight for each product by multiplying original weight (p.weight) by 0.7 (30% reduction), then sum the total adjusted weight per category using SUM(od.quantity * p.weight * 0.7).  【step3】: Group results by product category and sort descendingly by total_weight using GROUP BY p.category and ORDER BY total_weight DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 2022,
        "question": "Calculate the average remaining warranty days for the devices (in days).",
        "query": "SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;",
        "step": "【step1】: Retrieve warrantyExpiryDate values from Devices table  【step2】: Calculate remaining warranty days for each device by subtracting current date (JULIANDAY('now')) from warranty expiry dates (JULIANDAY(warrantyExpiryDate))  【step3】: Apply AVG() function to all calculated remaining warranty days to get final average",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 2023,
        "question": "Statistics on the average maintenance cost of equipment for each manufacturer, sorted in descending order by cost.",
        "query": "SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;",
        "step": "【step1】: Retrieve manufacturerId and cost values from MaintenanceRecords table.  【step2】: Group records by manufacturerId and compute the average maintenance cost using AVG(cost).  【step3】: Sort the grouped results in descending order based on avg_maintenance_cost.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 2024,
        "question": "Find records where the device status is 'Running' but no calibration date is recorded.",
        "query": "SELECT * FROM Devices WHERE status = '运行中' AND calibrationDate IS NULL;",
        "step": "【step1】: Filter records from the Devices table where the status is '运行中'.  【step2】: Apply an additional filter to select records where calibrationDate is NULL from the results of step 1.  【step3】: (Not required for this query, as it involves only two straightforward conditions without joins or sorting.)",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 2025,
        "question": "Calculate the average maintenance cost per maintenance ID, ordered by the average cost in descending order.",
        "query": "SELECT maintenanceId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_maintenance_cost DESC;",
        "step": "【step1】: Calculate the original warranty expiration date for all devices by adding the extended 1 year to their installation dates.  【step2】: Compute the remaining warranty days by finding the difference between the new expiration date and the current date using `DATEDIFF()`.  【step3】: Calculate the average of the remaining warranty days across all devices with `AVG()`.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 2026,
        "question": "Counting the data collection frequency (in units of times/day) for each type of sensor, and sorting them in descending order by frequency.",
        "query": "SELECT * FROM Devices WHERE status = '运行中' AND lastMaintenanceDate IS NULL;",
        "step": "【step1】: Select sensorType and dataCollectionFrequency from the Sensors table.  【step2】: Group records by sensorType to aggregate the data collection frequency.  【step3】: Apply ORDER BY dataCollectionFrequency DESC to sort the result.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 2027,
        "question": "Identify abnormal records where the temperature sensor data exceeds 50°C or falls below -20°C.",
        "query": "SELECT * FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;",
        "step": "【step1】: Filter records where temperature exceeds 50°C using `temperature > 50` condition  【step2】: Filter records where temperature falls below -20°C using `temperature < -20` condition  【step3】: Combine both results using `OR` operator to retrieve all abnormal readings",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "4",
        "idx": 2028,
        "question": "Calculate the data frequency for each sensor, sorted in descending order.",
        "query": "SELECT sensorId, COUNT(dataId) AS data_frequency FROM SensorData GROUP BY sensorId ORDER BY data_frequency DESC;",
        "step": "【step1】: Calculate annual total energy consumption from EnergyConsumption table by summing energyConsumed values filtered by year.  【step2】: Apply 50% increased emission coefficient (original coefficient ×1.5) to the total energy value.  【step3】: Return the final result as annual_total_carbon_emission.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 2029,
        "question": "Calculate the total shipping cost for the goods (assuming the shipping cost is weight × distance × 0.5 yuan per kilogram-kilometer).",
        "query": "SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;",
        "step": "【step1】: Retrieve the weight and (assumed) distance values for each product from the **Products** table.  【step2】: Multiply each product's weight by its distance and the rate 0.5 to compute individual shipping costs.  【step3】: Aggregate all individual shipping costs using the **SUM** function to calculate the total shipping cost.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2030,
        "question": "Calculate the total order amount for each user and sort them in descending order by amount.",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;",
        "step": "【step1】: Select userId and sum totalAmount for each user using SUM(totalAmount) with GROUP BY userId.  【step2】: Alias the summed totalAmount as total_spent to represent the aggregated spending per user.  【step3】: Order the results by total_spent in descending order using ORDER BY total_spent DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 2031,
        "question": "Find records where the order status is 'Completed' but the payment was not successful.",
        "query": "SELECT SUM(weight * price * 0.5) AS total_shipping_cost FROM Products;",
        "step": "【step1】: Retrieve all product records' weight and price columns from Products table  【step2】: Calculate temporary shipping cost for each product using (weight × price × 0.5)  【step3】: Aggregate results by summing all temporary values into total_shipping_cost alias",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 2032,
        "question": "Assuming a 20% increase in freight rates and a base rate of $0.60 per weight-distance unit, calculate the total shipping cost.",
        "query": "SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;",
        "step": "【step1】: Adjust the original shipping rate (0.6) by 20%, resulting in a new rate of 0.72 (0.6 * 1.2).  【step2】: Calculate shipping costs for each product by multiplying weight, distance, and the adjusted rate (weight * distance * 0.72).  【step3】: Aggregate all individual shipping costs using SUM() to produce the total_shipping_cost.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 2033,
        "question": "Calculate the average payment interval between order date and payment date (unit: days).",
        "query": "SELECT AVG(DATEDIFF(paymentDate, orderDate)) AS avg_payment_interval FROM Payments JOIN Orders ON Payments.orderId = Orders.orderId;",
        "step": "【step1】: Join the 'Payments' and 'Orders' tables using the orderId to link payment records with corresponding order dates.  【step2】: Calculate the day difference between paymentDate (from Payments) and orderDate (from Orders) for each matched record using DATEDIFF().  【step3】: Compute the average of all calculated day intervals using AVG() to get the final metric.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2034,
        "question": "Count the number of devices per address and sort them in descending order by quantity.",
        "query": "SELECT address, COUNT(*) AS device_count FROM Manufacturers GROUP BY address ORDER BY device_count DESC;",
        "step": "【step1】: Select the 'address' field and count records from the 'Manufacturers' table.  【step2】: Group the results by the 'address' field to calculate the number of devices per location.  【step3】: Sort the grouped results in descending order based on the calculated device count.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 2035,
        "question": "Find contradictory data in maintenance records where the next scheduled maintenance date is earlier than the maintenance date.",
        "query": "SELECT * FROM MaintenanceRecords WHERE DATEDIFF(nextMaintenanceDate, maintenanceDate) < 0;",
        "step": "【step1】: Retrieve all maintenance records from the MaintenanceRecords table.  【step2】: Calculate the date difference between nextMaintenanceDate and maintenanceDate for each record using the DATEDIFF function.  【step3】: Filter records where the calculated date difference is negative, indicating maintenanceDate occurs after nextMaintenanceDate.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 2036,
        "question": "What is the total number of devices at each location, listed in descending order of device count?",
        "query": "SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;",
        "step": "【step1】: Calculate original average maintenance interval per device using MaintenanceRecords by finding datediff between consecutive maintenance dates  【step2】: Multiply each device's average interval by 0.5 to simulate 50% reduction  【step3】: Group results by locationId from Devices table and calculate final averaged reduced intervals",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 2037,
        "question": "Statistics of the failure rate (number of failures/days in use) for each type of equipment, sorted in descending order by failure rate.",
        "query": "SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;",
        "step": "【step1】: [Join MaintenanceRecords with EnergyDevices using deviceId to access deviceType and installationDate for each maintenance record]  【step2】: [Group by deviceType, calculate total maintenance count per group and average usage days (current_date - installationDate)]  【step3】: [Compute failure_rate (count/days), then sort results by failure_rate descending]",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 2038,
        "question": "Find records where the equipment installation date is after the current date.",
        "query": "SELECT * FROM EnergyDevices WHERE installationDate > CURRENT_DATE;",
        "step": "【step1】:【Retrieve all columns from the EnergyDevices table】  【step2】:【Filter records where installationDate is greater than the current date using the condition installationDate > CURRENT_DATE】  【step3】:【(No additional steps required; the query does not involve joins, subqueries, or sorting)】",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 2039,
        "question": "Assuming the power of all devices increases by 40%, calculate the total annual electricity cost per device type.",
        "query": "SELECT d.deviceType, SUM(e.energyConsumed * d.powerRating * 1.4 * 365 * 24) AS annualElectricityCost FROM EnergyConsumption e JOIN EnergyDevices d ON e.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY annualElectricityCost DESC;",
        "step": "【step1】: Join EnergyConsumption and EnergyDevices tables via deviceId to link consumption data with device power ratings.  【step2】: Calculate annual electricity cost per device type using (energyConsumed × powerRating × 1.4 × 24 × 365), then aggregate with SUM grouped by deviceType.  【step3】: Sort results in descending order by the calculated annualElectricityCost.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 2040,
        "question": "Calculate the average weight of the devices (unit: kilograms).",
        "query": "SELECT AVG(weightKg) AS avgWeight FROM Devices;",
        "step": "【step1】: Retrieve the weightKg column from the Devices table containing all device weight records in kilograms.  【step2】: Calculate the average value of the weightKg column using the AVG() aggregation function and alias the result as avgWeight.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2041,
        "question": "Count the total sales for each product category and sort them in descending order by sales.",
        "query": "SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;",
        "step": "【step1】: Select category and totalPrice columns from Orders table  【step2】: Group records by category and calculate sum of totalPrice as total_sales  【step3】: Sort results in descending order by total_sales",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 2042,
        "question": "Find records where the product inventory is negative or zero.",
        "query": "SELECT * FROM Products WHERE stock <= 0;",
        "step": "【step1】: Select all columns from the Products table.  【step2】: Apply the filter condition to retain records where the stock value is less than or equal to 0.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 2043,
        "question": "Assuming the weight of all goods is reduced by 30%, calculate the total shipping weight.",
        "query": "SELECT SUM(p.weight * od.quantity * 0.7) AS total_shipping_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId;",
        "step": "【step1】: Join OrderDetails with Products using productId to access each product's weight and ordered quantity.  【step2】: Calculate adjusted shipping weight per item by reducing original weight by 30% (multiply by 0.7) and multiply by ordered quantity.  【step3】: Aggregate results using SUM() to get the total shipping weight across all order details.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "1",
        "idx": 2044,
        "question": "Calculate the average remaining warranty days of the equipment (unit: days).",
        "query": "SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;",
        "step": "【step1】: Calculate remaining warranty days per device using JULIANDAY() function  【step2】: Apply AVG() aggregate function to compute average  【step3】: Alias the result column as avg_warranty_remaining",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 2045,
        "question": "Statistics on the average maintenance cost of equipment for each manufacturer, sorted in descending order by cost.",
        "query": "SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;",
        "step": "【step1】: Retrieve manufacturerId and maintenance cost values from the MaintenanceRecords table.  【step2】: Group the records by manufacturerId and compute the average maintenance cost using AVG(cost).  【step3】: Sort the grouped results in descending order based on the calculated average maintenance cost.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 2046,
        "question": "Find records where the equipment status is 'running' but no maintenance date has been recorded.",
        "query": "SELECT * FROM Devices WHERE status = '运行中' AND lastMaintenanceDate IS NULL;",
        "step": "【step1】: Filter all records from the Devices table where the status is '运行中'.  【step2】: Further restrict the results to include only records where lastMaintenanceDate is NULL.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 2047,
        "question": "Assuming the warranty period for all devices is extended by 1 year, what is the average remaining warranty days?",
        "query": "SELECT deviceId, DATEDIFF(DATE_ADD(installationDate, INTERVAL 1 YEAR), CURRENT_DATE) AS remaining_warranty_days FROM EnergyDevices;",
        "step": "【step1】: Extend warranty period by 1 year using DATE_ADD on installationDate.  【step2】: Calculate remaining days using DATEDIFF between adjusted warranty date and current date.  【step3】: Aggregate results with AVG to compute the average remaining warranty days.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "2",
        "idx": 2048,
        "question": "Statistics on the average data collection frequency (unit: times/day) for each type of sensor, sorted in descending order by average frequency.",
        "query": "SELECT sensorType, AVG(dataCollectionFrequency) AS avgFrequency FROM Sensors GROUP BY sensorType ORDER BY avgFrequency DESC;",
        "step": "【step1】: Group sensor records by sensorType  【step2】: Calculate average dataCollectionFrequency per group  【step3】: Sort results by avgFrequency in descending order",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "3",
        "idx": 2049,
        "question": "Identify abnormal records where the temperature sensor data exceeds 50°C or falls below -20°C.",
        "query": "SELECT sensorId, recordedAt, temperature FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;",
        "step": "【step1】: Retrieve sensorId, recordedAt, and temperature columns from TemperatureReadings table  【step2】: Filter records where temperature exceeds 50°C using the condition **temperature > 50**  【step3】: Combine with records where temperature falls below -20°C via **OR temperature < -20** to capture both anomaly thresholds",
        "format": "MySQL"
    },
    {
        "db_id": "SmartHomeDB",
        "type": "4",
        "idx": 2050,
        "question": "Assuming the carbon emission factor increases by 50%, calculate the total annual carbon emissions.",
        "query": "SELECT s.sensorType, COUNT(sd.dataId) AS data_frequency FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType ORDER BY data_frequency DESC;",
        "step": "【step1】: Join SensorData and Sensors tables on sensorId to associate sensor readings with their types.  【step2】: Group records by sensorType and count dataId occurrences using COUNT() to get data frequency per type.  【step3】: Sort the grouped results in descending order of calculated data_frequency using ORDER BY.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 2051,
        "question": "Calculate the total shipping cost for the goods (assuming the shipping cost is weight × distance × 0.5 yuan per kilogram-kilometer).",
        "query": "SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;",
        "step": "【step1】: Retrieve all product records from the 'Products' table, including the **weight** field required for calculation.  【step2】: Calculate the shipping cost for each product using the formula *weight × distance × 0.5*. Assume **distance** is implicitly available (even though it is not explicitly defined in the provided schema).  【step3】: Aggregate all individual shipping costs with the **SUM()** function to return the final **total_shipping_cost**.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2052,
        "question": "Count the total order amount for each user and sort them in descending order by total order amount.",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;",
        "step": "【step1】: Select userId and totalAmount from the Orders table.  【step2】: Group the results by userId and calculate the sum of totalAmount for each user using SUM(totalAmount) AS total_spent.  【step3】: Order the grouped results in descending order based on total_spent using ORDER BY total_spent DESC.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "3",
        "idx": 2053,
        "question": "Find records where the order status is 'Completed' but the payment was not successful.",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已完成' AND orderId NOT IN (SELECT orderId FROM Payments WHERE paymentStatus = '成功');",
        "step": "【step1】: Filter all orders with status 'Completed' from Orders table using WHERE orderStatus = 'Completed'  【step2】: Retrieve orderIDs from Payments table where payment was successful via subquery (SELECT orderId FROM Payments WHERE paymentStatus = 'Success')  【step3】: Exclude completed orders that appear in successful payment records using NOT IN operator on the subquery results",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "4",
        "idx": 2054,
        "question": "Assuming a 20% increase in freight rates, calculate the total shipping cost.",
        "query": "SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;",
        "step": "【step1】: Calculate the new shipping rate by increasing the original rate (0.6) by 20%, resulting in 0.6 * 1.2 = 0.72.  【step2】: Compute individual shipping costs for each product using the updated rate: weight * distance * 0.72.  【step3】: Aggregate all individual shipping costs with SUM() to produce the total_shipping_cost.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "1",
        "idx": 2055,
        "question": "Calculate the average maintenance interval of the equipment (unit: days).",
        "query": "SELECT AVG(DATEDIFF(nextMaintenanceDate, maintenanceDate)) AS avg_maintenance_interval FROM Orders WHERE maintenanceDate IS NOT NULL AND nextMaintenanceDate IS NOT NULL;",
        "step": "【step1】: Filter valid maintenance records by checking non-null maintenanceDate and nextMaintenanceDate in Orders table.  【step2】: Calculate the day difference between nextMaintenanceDate and maintenanceDate for each valid record using DATEDIFF().  【step3】: Compute the average of these calculated intervals using AVG() function to get the final result.",
        "format": "MySQL"
    },
    {
        "db_id": "ECommerce",
        "type": "2",
        "idx": 2056,
        "question": "Count the number of devices in each category and sort in descending order by quantity.",
        "query": "SELECT category, COUNT(*) AS device_count FROM Products GROUP BY category ORDER BY device_count DESC;",
        "step": "【step1】: Select the 'category' column and count all records for each category using COUNT(*) function.  【step2】: Group the results by the 'category' column to aggregate device counts.  【step3】: Sort the grouped results in descending order based on the calculated 'device_count' values.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 2057,
        "question": "Find contradictory data in the maintenance records where the next scheduled maintenance date is earlier than the maintenance date.",
        "query": "SELECT AVG(DATEDIFF(nextMaintenanceDate, MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;",
        "step": "【step1】: Filter records from MaintenanceRecords where maintenanceDate should logically precede nextMaintenanceDate.  【step2】: Apply condition WHERE maintenanceDate > nextMaintenanceDate to detect chronological contradictions.  【step3】: Return conflicting entries with SELECT * FROM MaintenanceRecords WHERE maintenanceDate > nextMaintenanceDate;.",
        "format": "MySQL"
    },
    {
        "db_id": "PhysicsLabDB",
        "type": "4",
        "idx": 2058,
        "question": "Calculate the number of devices per location, sorted by device count in descending order.",
        "query": "SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;",
        "step": "【step1】: Calculate original average maintenance intervals per device using MaintenanceRecords (time difference between consecutive maintenance dates)  【step2】: Apply 50% reduction to each device's average interval (multiply by 0.5)  【step3】: Compute final global average of adjusted maintenance intervals across all devices",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "2",
        "idx": 2059,
        "question": "Count the failure rate (number of failures / days in use) for each type of equipment, and sort in descending order by failure rate.",
        "query": "SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;",
        "step": "【step1】: Calculate the number of maintenance records (failure count) per deviceType using COUNT(maintenanceId) with GROUP BY deviceType.  【step2】: Compute usage days for each deviceType by subtracting installationDate from the current date using JULIANDAY functions.  【step3】: Derive failure_rate by dividing failure count by usage days, then order results by failure_rate in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "3",
        "idx": 2060,
        "question": "What is the average maintenance interval between consecutive maintenance dates in the MaintenanceRecords table?",
        "query": "SELECT AVG(DATEDIFF(nextMaintenanceDate, MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;",
        "step": "【step1】: Filter records from EnergyDevices where installationDate > CURDATE() to select devices with future installation dates  【step2】: Select deviceId and installationDate from the filtered results  【step3】: Return final list of devices (all columns) satisfying this temporal condition",
        "format": "MySQL"
    },
    {
        "db_id": "EnergyManagementDB",
        "type": "4",
        "idx": 2061,
        "question": "Assuming all devices' power increases by 40%, calculate the total annual electricity cost for the current year.",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.powerRating * 1.4 AS newPowerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SUM(ec.energyConsumed) * 1.4 * 0.1) AS annualElectricityCost FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE YEAR(ec.timestamp) = YEAR(CURDATE()) GROUP BY ed.deviceId, ed.deviceName;",
        "step": "【step1】: Join EnergyDevices and EnergyConsumption tables using deviceId, filter records from current calendar year using YEAR(timestamp)=YEAR(CURDATE()).  【step2】: Calculate new power ratings (original powerRating × 1.4) and aggregate total energyConsumed per device using SUM().  【step3】: Compute annual electricity cost by multiplying total energyConsumed with scaled power (×1.4) and electricity rate (×0.1), grouped by deviceId/deviceName.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2062,
        "question": "List the IDs of customers and their ages when they signed up for the driving school.",
        "query": "SELECT customer_id , strftime ( \"%Y\" , date_became_customer ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_became_customer ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Customers",
        "step": "【step1】: Extract the customer_id, calculate the raw age difference by subtracting the customer's birth year from the registration year.  【step2】: Adjust for incomplete years by checking if the registration month-day is earlier than the birth month-day using DATE_FORMAT comparisons.  【step3】: Subtract the adjustment (0 or 1) from the raw age difference to get the precise signup age.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2063,
        "question": "Give me IDs of all customers and their ages at the time of registering for driving school?",
        "query": "SELECT customer_id , strftime ( \"%Y\" , date_became_customer ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_became_customer ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Customers",
        "step": "【step1】: Extract the customer_id and calculate the preliminary age by subtracting the birth year from the registration year (YEAR(date_became_customer) - YEAR(date_of_birth)).  【step2】: Adjust the age calculation by checking if the birthdate anniversary occurred before registration date using DATE_FORMAT comparisons on month-day values.  【step3】: Subtract 1 year from the preliminary age when registration month-day comes before birth month-day, finalizing the accurate registration age.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2064,
        "question": "If Damon Sanford was born on the first day of the 21st century, list the customer IDs and their ages when they signed up for the driving school.",
        "query": "SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = \"Dameon\" AND last_name = \"Sanford\") UNION ALL SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", \"2001-01-01\") - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", \"2001-01-01\")) AS age FROM Customers WHERE first_name = \"Dameon\" AND last_name = \"Sanford\"",
        "step": "【step1】: Filter out customers named 'Dameon Sanford', calculate their signup age using their actual date_of_birth.  【step2】: Select 'Dameon Sanford' specifically, calculate his age using the fixed birthdate '2001-01-01'.  【step3】: Combine both results with UNION ALL to include all customers with correct age calculations.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2065,
        "question": "Give me IDs of all customers and their ages when registering for driving school if Damon Sanford was born on the first day of the 21st Century.",
        "query": "SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = \"Dameon\" AND last_name = \"Sanford\") UNION ALL SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", \"2001-01-01\") - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", \"2001-01-01\")) AS age FROM Customers WHERE first_name = \"Dameon\" AND last_name = \"Sanford\"",
        "step": "【step1】: Calculate age for non-Dameon Sanford customers by subtracting birth year from registration year, adjusting for unpassed birthdays via DATE_FORMAT comparison.  【step2】: Handle Dameon Sanford separately by fixing his birth year to 2001 and checking if registration occurred before Jan 1st to adjust age.  【step3】: Combine both results using UNION ALL to include all customers while excluding Dameon Sanford from the first subset.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2066,
        "question": "What percentage of customers with outstanding amounts larger than 2000 are good customers?",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )",
        "step": "【step1】: Calculate the number of \"Good Customers\" (those with amount_outstanding > 2000 AND customer_status_code = 'Good Customer') using a subquery with COUNT(*).  【step2】: Calculate the total number of customers with amount_outstanding > 2000 (regardless of status) using another subquery with COUNT(*).  【step3】: Cross-join the two subquery results and compute the percentage via 100.0 * good / n to avoid integer division.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2067,
        "question": "Give me the percentage of customers with over 2000 in outstanding balance who are rated good?",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )",
        "step": "【step1】: Calculate the number of \"Good Customer\" entries meeting the criteria using the subquery: `SELECT COUNT(*) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = 'Good Customer'`.  【step2】: Calculate the total number of customers with outstanding balances over 2000 using the subquery: `SELECT COUNT(*) AS n FROM Customers WHERE amount_outstanding > 2000`.  【step3】: Combine results via cross-join and compute the percentage with `100.0 * good / n AS percent` to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2068,
        "question": "If all customers who registered in 2015 have an outstanding amount of 200, what percentage of customers with outstanding amounts greater than 2000 are good customers?",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 )",
        "step": "【step1】: Create a temporary dataset (sub1/sub2) by combining 2015-registered customers (with forced amount_outstanding=200) and other customers (retaining original values) via UNION ALL.  【step2】: Calculate the numerator (good) by filtering the temporary dataset for entries where amount_outstanding > 2000 AND customer_status_code = 'Good Customer'.  【step3】: Calculate the denominator (n) by filtering the same temporary dataset for entries where amount_outstanding > 2000, then compute the percentage via (good / n) * 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2069,
        "question": "What percentage of customers are rated good with an outstanding balance of over 2000 if all customers registered in 2015 have an outstanding amount over 2000?",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 )",
        "step": "【step1】: Create a combined dataset (subquery1/subquery2) where all customers registered in 2015 have their amount_outstanding forced to 200 (contradicting the problem's premise), while retaining original data for others.  【step2】: Calculate two values separately:  - **good**: Count customers with amount_outstanding > 2000 and status 'Good Customer' from the combined dataset.  - **n**: Count all customers with amount_outstanding > 2000 from the same dataset.  【step3】: Compute the percentage using `100.0 * good / n` by joining the two intermediate results.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2070,
        "question": "List the ID and number of lessons scheduled for staffs who were older than 20 when they joined the driving school.",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "step": "【step1】: Filter staff members who were older than 20 when joining by calculating age as (YEAR(date_joined_staff) - YEAR(date_of_birth)) adjusted with a CASE statement for birthday occurrence, then join with Lessons to count scheduled lessons per staff_id using GROUP BY.  【step2】: Select qualifying staff with no lessons by checking staff_ids not in the joined Lessons table, assigning 0 as n_lesson.  【step3】: Combine both results (staffs with lessons and staffs without lessons) using UNION ALL to ensure all eligible staff are included in the final output.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2071,
        "question": "Give me the ID and number of scheduled lessons for all staff older than age 20 at the time of joining the driving school.",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "step": "【step1】: Calculate the age of each staff member at the time of joining using `TIMESTAMPDIFF(YEAR, date_of_birth, date_joined_staff)` and adjust for birthdate/month-day comparison to filter staff older than 20.  【step2】: For staff matching the age criteria, join the `Staff` and `Lessons` tables to count scheduled lessons via `COUNT(*)` grouped by `staff_id`.  【step3】: Use `UNION ALL` to combine results with staff from the age-filtered group who have no lessons (detected via `NOT IN` subquery on Lessons-connected staff), assigning `0` as `n_lesson`.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2072,
        "question": "If the staffs who resigned on March 8th, 2018 all joined on March 8th, 2016, list the IDs and number of lessons scheduled for staffs who were older than 20 when they joined.",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "step": "【step1】: Create a combined dataset (A) by selecting staff who left on 2018-03-08 (with joined date forced to 2016-03-08) and other staff with their original joined dates via UNION ALL.  【step2】: Calculate staff age-at-joining for dataset A and join with Lessons to count scheduled lessons for staff aged >20. Simultaneously, create dataset C (same as A), identify staff aged >20 with ZERO lessons via NOT IN subquery against Lessons.  【step3】: Combine results from step 2 (staff with lessons) and step 2's sub-result (staff without lessons) using UNION ALL to finalize IDs and lesson counts.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2073,
        "question": "Give me the ID and quantity of scheduled lessons for all staff older than age 20 at the time of commencing employment at the driving school if all staff who joined on March 8 2016 resigned on March 8 2018.",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "step": "【step1】: Create a derived table `A` combining staff who resigned on 2018-03-08 (with enforced `date_joined_staff`=2016-03-08) and staff with other resignation dates (using original `date_joined_staff`), including birth dates.  【step2】: Calculate staff's age at employment using `YEAR(date_joined_staff) - YEAR(date_of_birth) - (date_of_birth day/month > date_joined_staff day/month)`, filter those older than 20. Join with `Lessons` to count scheduled lessons.  【step3】: Use `UNION ALL` to combine: 1) staff with lessons count from step 2, and 2) staff meeting age criteria but having no lessons (using `staff_id NOT IN` subquery to detect staff without lesson matches).",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2074,
        "question": "What's the ID of staff who has worked at the driving school the longest?",
        "query": "SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1",
        "step": "【step1】: Calculate the duration each staff member has worked using DATEDIFF(date_left_staff, date_joined_staff).  【step2】: Order the results by this calculated duration in descending order.  【step3】: Limit the output to the top result to retrieve the staff_id with the longest tenure.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2075,
        "question": "Tell me the ID of staff who have worked at the driving school the longest?",
        "query": "SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1",
        "step": "【step1】: Calculate the duration each staff has worked by using DATEDIFF(date_left_staff, date_joined_staff) to find the difference in days between their join and leave dates.  【step2】: Order the results in descending order based on the calculated duration to prioritize the longest-working staff.  【step3】: Retrieve the staff_id of the top result using LIMIT 1 to get the staff with the maximum duration.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2076,
        "question": "If Lincoln Benny Carroll joined on his 21st birthday, list the ID of the staff who has worked at the driving school the longest? ",
        "query": "SELECT staff_id FROM (SELECT staff_id, strftime (\"%Y-%m-%d\", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1",
        "step": "【step1】: Calculate the adjusted `date_joined_staff` for Lincoln Benny Carroll by adding 21 years (approximated via 21*365.25 days) to his `date_of_birth`, while retaining original `date_joined_staff` for other staff via a subquery.  【step2】: Combine Lincoln's modified record with all other staff records using `UNION ALL`, creating a unified dataset with derived/raw join dates and original leave dates.  【step3】: Order all staff by total working duration (`DATEDIFF(date_left_staff, date_joined_staff)`) in descending order and select the top result’s `staff_id` using `LIMIT 1`.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2077,
        "question": "What's the ID of the staff member who has worked at the driving school longest if Lincoln Benny Carroll joined on their 21st birthday?",
        "query": "SELECT staff_id FROM (SELECT staff_id, strftime (\"%Y-%m-%d\", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1",
        "step": "【step1】: Calculate Lincoln Benny Carroll's adjusted \"date_joined_staff\" as their 21st birthday using DATE_ADD and DATE_FORMAT, while keeping original dates for other staff members.  【step2】: Combine Lincoln's modified record with other staff records through UNION ALL, creating a merged dataset with consistent date_joined_staff/date_left_staff columns.  【step3】: Calculate employment duration using DATEDIFF(date_left_staff, date_joined_staff), sort descending by duration, and select the top result with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2078,
        "question": "Among the customers who have never attended a class, how much more bad customers than good customers?",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "step": "【step1】: Filter customers who never attended a non-cancelled class using `customer_id NOT IN (SELECT DISTINCT customer_id FROM Lessons WHERE lesson_status_code != 'Cancelled')`.  【step2】: Calculate two counts separately:  - `n_good` by adding `customer_status_code = 'Good Customer'`  - `n_bad` by adding `customer_status_code = 'Bad Customer'`  【step3】: Compute the difference between bad and good customer counts via `n_bad - n_good AS diff` using JOIN on the two subqueries.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2079,
        "question": "How many more customers are rated bad than good for only the customers who have never attended a class?",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "step": "【step1】: Identify customers who have never attended a non-cancelled class by filtering Customers with customer_id NOT IN (SELECT DISTINCT customer_id FROM Lessons WHERE lesson_status_code != 'Cancelled').  【step2】: Calculate the count of \"Good Customer\" (n_good) and \"Bad Customer\" (n_bad) separately from the filtered customer list using two subqueries.  【step3】: Compute the difference (diff) between n_bad and n_good by joining the results of the subqueries through a CROSS JOIN and performing arithmetic subtraction.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2080,
        "question": "Assuming that all classes are not canceled on March 7, 2018, how much more bad customers than good customers among the customers who have never attended a class?",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "step": "【step1】: Identify customers who have never attended any non-cancelled classes by excluding those who appear in the union dataset (combining 2018-03-07 completed lessons and non-cancelled lessons from other dates).  【step2】: Count \"Good Customer\" and \"Bad Customer\" separately from the filtered customer pool using two subqueries with customer_status_code filters.  【step3】: Calculate the arithmetic difference between bad customer count (n_bad) and good customer count (n_good) using JOIN on the two subquery results.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2081,
        "question": "How many more customers are rated bad than good for only the customers who have never attended a class if all classes were not canceled on March 7 2018?",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "step": "【step1】: Identify customers who have never attended any non-cancelled classes by excluding those who appear in the union of: 1) March 7, 2018 classes treated as 'Completed', and 2) non-March 7 classes with original statuses except 'Cancelled'.  【step2】: Count 'Good Customer' and 'Bad Customer' statuses separately within this filtered group using two subqueries (t1 for good, t2 for bad).  【step3】: Calculate the difference between bad and good counts by subtracting t1.n_good from t2.n_bad using a JOIN between the two subqueries.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2082,
        "question": "How much is the average course fee for a staff who has no course schedule after March 5, 2018? What's his staff ID and how old is he this year?",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "step": "【step1】: Retrieve all `staff_id` values from the `Lessons` table where `lesson_date` is after March 5, 2018, using a subquery in the `WHERE` clause.  【step2】: Join the `Lessons` and `Staff` tables on `staff_id`, filtering out staff who appear in the subquery results (i.e., exclude those with lessons after March 5, 2018).  【step3】: Group the remaining records by `staff_id`, calculate the average course fee (`AVG(price)`), and compute age using date arithmetic based on `date_of_birth` and the current year.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2083,
        "question": "Tell me the staff ID, average course fee, and age (this year) for staff with no course scheduled after 5 March 2018?",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "step": "【step1】: Retrieve staff IDs who have lessons scheduled after '2018-03-05' using a subquery: `SELECT staff_id FROM Lessons WHERE DATE(lesson_date) > '2018-03-05'`.  【step2】: Join the **Lessons** and **Staff** tables, filtering out staff IDs from the subquery. Calculate age using date_of_birth and current date.  【step3】: Compute the average course fee (AVG(price)) for the remaining staff and group results by staff_id to finalize the output.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2084,
        "question": "If the prices of all courses were increased by 8% in February 2018, how much is the average course fee for a staff who has no course schedule after March 5, 2018? What's his staff ID and how old is he this year?",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) = \"2018-02\" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) != \"2018-02\" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "step": "【step1】: Calculate adjusted course prices for February 2018 (8% increase) and combine with unchanged prices from other months using UNION ALL, creating temporary table A.  【step2】: Join table A with Staff table to get birthdates, filter out staff with lessons after 2018-03-05 via subquery in WHERE clause.  【step3】: Group results by staff_id, compute average price, and calculate precise age using TIMESTAMPDIFF with birthday adjustment logic.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2085,
        "question": "What is the staff ID, average course fee, and age this year, for staff with no course scheduled after March 5 2018 if all course prices were increased by 8% in February 2018?",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) = \"2018-02\" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) != \"2018-02\" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "step": "【step1】: Calculate adjusted course prices by increasing February 2018 course fees by 8% (using UNION ALL to combine adjusted Feb prices with unchanged prices from other months).  【step2】: Filter out staff who have lessons scheduled after March 5, 2018 via NOT IN subquery on the original Lessons table.  【step3】: Join the adjusted price data with Staff table to calculate age, then group by staff_id to compute average course fee and final age calculation using birthdate comparison.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2086,
        "question": "What's the ID of the coach who has the highest average course price and how much higher than that of the coach with the lowest average course price?",
        "query": "SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1",
        "step": "【step1】: Calculate the average course price for each coach by grouping lessons data and joining with the staff table.  【step2】: Use a subquery to find the lowest average course price among all coaches.  【step3】: Compute the difference between the highest and lowest average prices, then sort and limit to return the coach with the maximum average price and their price difference.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2087,
        "question": "Tell me the ID of the coach who has the highest average course price and how much more does this cost than the average price from the coach with the lowest average price?",
        "query": "SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1",
        "step": "【step1】: Calculate the average price for each coach, then find the lowest average price via a subquery: `(SELECT AVG(price) FROM Lessons GROUP BY staff_id ORDER BY AVG(price) ASC LIMIT 1)`.  【step2】: Join the `Lessons` and `Staff` tables, group by `staff_id`, compute each coach's average price, and subtract the lowest average (from step 1) to get the difference (`diff`).  【step3】: Order the results by average price in descending order and limit to the top result, returning the coach's ID and the calculated price difference.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2088,
        "question": "If all courses offered by Winnifred Liam Jast were reduced by 12%, what's the ID of the coach who has the highest average course price and how much higher than that of the coach with the lowest average course price?",
        "query": "SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1",
        "step": "【step1】: Adjust prices for Winnifred Liam Jast's courses by 12% reduction and combine with unchanged prices of other coaches using UNION ALL.  【step2】: Calculate each coach's average price from the combined dataset, then determine the minimum average price via subquery.  【step3】: Identify the coach with the maximum average price, compute the difference from the minimum average, and return the staff_id with the highest value and the calculated difference.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2089,
        "question": "Tell me the ID of the coach who has the highest average price of a course and how much more this is than the price of a course from the coach with the lowest average price if courses from Winnifred Liam Jast were 12% cheaper?",
        "query": "SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1",
        "step": "【step1】: Create a union dataset where Winnifred's course prices are reduced by 12% while other coaches' prices remain unchanged.  【step2】: Calculate average prices per coach, identify the coach with the highest average price, and simultaneously compute their average price.  【step3】: Subtract the lowest average price (from a parallel calculation filtering Winnifred's adjusted prices and others) from the highest average price to get the difference.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2090,
        "question": "What percentage of clients have multiple coaches?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "step": "【step1】: Identify clients with multiple coaches by grouping lessons on customer_id and filtering those with at least 2 distinct staff_ids.  【step2】: Calculate the total number of clients in the Customers table.  【step3】: Compute the percentage by dividing the count from step1 by the total from step2 and scaling by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2091,
        "question": "Calculate the percentage of clients with more than one coach?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "step": "【step1】: Identify clients with multiple coaches by grouping the `Lessons` table by `customer_id` and filtering those with ≥2 distinct `staff_id` using `HAVING COUNT(DISTINCT staff_id) >= 2`.  【step2】: Count the number of clients from step 1 (via `COUNT(*)` on the subquery result).  【step3】: Calculate the percentage by dividing the result from step 2 by the total number of clients in `Customers` and multiplying by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2092,
        "question": "If the coach of the course with ID 12 is Winnifred Liam Jast, what percentage of clients have multiple coaches?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = \"Winnifred\" AND middle_name = \"Liam\" AND last_name = \"Jast\" ) AS staff_id FROM Lessons WHERE lesson_id = \"12\" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != \"12\" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "step": "【step1】: Retrieve the customer_id and the specific staff_id (Winnifred Liam Jast) for lesson_id 12, while fetching customer_id and their actual staff_id from other lessons.  【step2】: Combine both datasets using UNION ALL, then group by customer_id to count distinct staff_ids per client.  【step3】: Filter clients with ≥2 distinct staff_ids, calculate their count, and divide by the total number of customers to determine the percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2093,
        "question": "Calculate the percentage of clients with more than a single coach if course with ID 12 is coached by Winnifred Liam Jast.",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = \"Winnifred\" AND middle_name = \"Liam\" AND last_name = \"Jast\" ) AS staff_id FROM Lessons WHERE lesson_id = \"12\" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != \"12\" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "step": "【step1】: Retrieve the staff_id of 'Winnifred Liam Jast' and combine lesson records: The innermost subquery fetches the staff_id for the specified coach and creates a unified dataset of all lessons, replacing the coach for lesson_id 12 with this staff_id.  【step2】: Group customers by distinct coaches: The middle subquery groups combined lesson records by customer_id, counting clients with ≥2 distinct staff_id (coaches) via HAVING COUNT(DISTINCT staff_id) >= 2.  【step3】: Calculate percentage: The outer query divides the count of qualifying clients by the total Customers table count, multiplying by 100.0 to return the final percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2094,
        "question": "How many years older is the oldest staff than the youngest staff?",
        "query": "SELECT strftime ( \"%Y\" , MAX ( date_of_birth ) ) - strftime ( \"%Y\" , MIN ( date_of_birth ) ) - ( strftime ( \"%m-%d\" , MAX ( date_of_birth ) ) < strftime ( \"%m-%d\" , MIN ( date_of_birth ) ) ) AS diff FROM Staff",
        "step": "【step1】: Extract the maximum (oldest) and minimum (youngest) date_of_birth values from the Staff table using MAX() and MIN() functions.  【step2】: Calculate the difference in birth years between the oldest and youngest staff by subtracting YEAR(MIN(date_of_birth)) from YEAR(MAX(date_of_birth)).  【step3】: Adjust for incomplete years by checking if the month-day of the oldest date_of_birth is earlier than the youngest, using DATE_FORMAT comparisons, and subtract 1 if true to get the accurate age difference.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2095,
        "question": "Calculate the difference in age between the oldest and youngest staff?",
        "query": "SELECT strftime ( \"%Y\" , MAX ( date_of_birth ) ) - strftime ( \"%Y\" , MIN ( date_of_birth ) ) - ( strftime ( \"%m-%d\" , MAX ( date_of_birth ) ) < strftime ( \"%m-%d\" , MIN ( date_of_birth ) ) ) AS diff FROM Staff",
        "step": "【step1】: Retrieve the maximum and minimum date_of_birth values from the Staff table using MAX(date_of_birth) and MIN(date_of_birth).  【step2】: Calculate the year difference between these two dates by subtracting YEAR(MIN()) from YEAR(MAX()).  【step3】: Adjust for month-day comparison: subtract 1 if the month-day of MAX(date_of_birth) is earlier than MIN(date_of_birth), using DATE_FORMAT comparisons.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2096,
        "question": "If Camylle Icie Weissnat's age in 2020 is twice that of a person born in 2009, how many years older is the oldest staff than the youngest staff?",
        "query": "SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" ) ) ORDER BY date_of_birth DESC",
        "step": "【step1】: Calculate Camylle's virtual birth year (1998) using the age condition: 2020 - (2020 - 2009)*2.  【step2】: Combine Camylle's calculated birth year with other staff's actual birth years via UNION ALL.  【step3】: Compute the age difference between the oldest (MIN(date_of_birth)) and youngest (MAX(date_of_birth)) in the merged dataset.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2097,
        "question": "Calculate the difference in age between the oldest and youngest staff, if in 2020, Camylle Icie Weissnat was twice as old as someone born in 2009.",
        "query": "SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" ) ) ORDER BY date_of_birth DESC",
        "step": "【step1】: Calculate Camylle's birth year based on the condition that in 2020, she was twice as old as someone born in 2009 (2020 - 2009 = 11 → 2×11 = 22 → 2020 - 22 = 1998).  【step2】: Create a combined dataset using UNION ALL, including Camylle's derived birth year (1998) and actual birth years of other staff members.  【step3】: Compute the difference between the maximum and minimum values in the combined dataset to get the age gap.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2098,
        "question": "What is the total number of courses arranged for the oldest coach when leaving the driving school, and what percentage of them were canceled?",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = \"Cancelled\" )",
        "step": "【step1】: Identify the oldest coach by calculating their age based on date_left_staff and date_of_birth, then retrieve their staff_id via a subquery.  【step2】: Count the total lessons (total) and canceled lessons (n_cancel) for this staff_id in separate subqueries on the Lessons table.  【step3】: Compute the cancellation ratio by dividing n_cancel by total in the main SELECT statement.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2099,
        "question": "What is the sum total of scheduled courses for the oldest coach when leaving the driving school and how many of these were cancelled?",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = \"Cancelled\" )",
        "step": "【step1】: Identify the oldest coach by calculating their age using date_of_birth and date_left_staff, then retrieve their staff_id via a subquery.  【step2】: Calculate the total number of scheduled courses (total) and the number of cancelled courses (n_cancel) for this coach using two separate subqueries filtered by the identified staff_id.  【step3】: Combine the results from the subqueries and compute the cancellation ratio (n_cancel / total) in the main SELECT statement.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2100,
        "question": "If all coaches have no course scheduled within 60 days after joining, what is the total number of courses arranged for the oldest coach when leaving the driving school, and what percentage of them were canceled?",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = \"Cancelled\" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )",
        "step": "【step1】: Identify the oldest coach by calculating age using date_left_staff and date_of_birth, then select their staff_id via a subquery ordered by age descending with LIMIT 1.  【step2】: Calculate total courses (t1) for this coach where lesson_date occurs >60 days after their join date (via DATE_ADD), filtered by the staff_id from step1.  【step3】: Compute canceled courses (t2) with the same staff_id and date filter, adding lesson_status_code='Cancelled', then join t1 and t2 to calculate the cancellation ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2101,
        "question": "Give me the total number of arranged courses, and the cancellation rate, for the oldest coach when leaving the driving school if all coaches have no course scheduled within 60 days after joining.",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = \"Cancelled\" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )",
        "step": "【step1】: Identify the oldest coach by calculating age via `TIMESTAMPDIFF` adjusted for day/month comparison, then extract their `staff_id` via subquery.  【step2】: Compute total arranged courses (`total`) by counting all lessons for this coach occurring >60 days after their join date (`DATE_ADD`).  【step3】: Calculate cancellation count (`n_cancel`) for the same coach and timeframe, then combine results to derive cancellation rate (`1.0 * n_cancel / total`).",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2102,
        "question": "What's the ID of the customer who paid the most, and how much more than the customer who paid the least?",
        "query": "SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id",
        "step": "【step1】: Retrieve the minimum payment amount from Customer_Payments using a subquery.  【step2】: Join Customer_Payments with Customers, group by customer_id, and determine the maximum payment for each customer.  【step3】: Subtract the overall minimum payment (from step1) from each customer's maximum payment to compute payment_diff, then display the customer_id and payment_diff.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 2,
        "idx": 2103,
        "question": "Tell me the ID of the customer who paid the highest fee and how much more was this than the customer paying the lowest fee?",
        "query": "SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id",
        "step": "【step1】: Join Customer_Payments (A) with Customers (B) to ensure valid customer records.  【step2】: Find the highest payment amount (MAX(A.amount_payment)) and its corresponding customer_id.  【step3】: Calculate the difference by subtracting the globally lowest payment (via subquery MIN) from the highest payment.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2104,
        "question": "If Amya Spinka paid 5000 more on March 12th, 2018, what's the ID of the customer who paid the most, and how much more than the customer who paid the least?",
        "query": "SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )",
        "step": "【step1】: Adjust Amya Spinka's payment on 2018-03-12 by adding 5000, and create a dataset combining this adjusted payment with all others (also increased by 5000 for non-Amya or non-2018-03-12 records) via UNION ALL.  【step2】: Build the combined_data temporary table containing all payments after the 5000 adjustment.  【step3】: Calculate the maximum adjusted payment, subtract the minimum adjusted payment from the combined_data, and retrieve the customer_id associated with the maximum payment.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2105,
        "question": "Tell me the ID of the customer who paid the highest fee and how much more was this than the customer paying the lowest fee if Amya Spinka paid 5000 more on 12 March 2018?",
        "query": "SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )",
        "step": "【step1】: Adjust payments for Amya Spinka's 2018-03-12 record by adding 5000 via JOIN with Customers table and filter by name/date.  【step2】: Adjust all other payments (non-Amya or non-2018-03-12) by 5000 using the same JOIN, then UNION ALL with step 1's result to create a combined dataset.  【step3】: Calculate the difference between the MAX(adjusted_payment) and MIN(adjusted_payment) from the combined dataset, while selecting the customer_id associated with the highest payment.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2106,
        "question": "What is the average age of the coaches living in Lake Elaine, Georgia?",
        "query": "SELECT AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Lake Elaina\"",
        "step": "【step1】: Join the Staff table (aliased as A) with the Addresses table (aliased as B) using the staff_address_id and address_id to link coach records with their addresses.  【step2】: Filter the combined dataset to retain only coaches located in \"Lake Elaina, Georgia\" using the conditions B.state_province_county = 'Georgia' AND B.city = 'Lake Elaina'.  【step3】: Calculate the average age of these filtered coaches by computing the difference between the current year and their birth year (with adjustment for month/day comparison using DATE_FORMAT), then apply the AVG() function.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2107,
        "question": "For the coaches resident in Lake Elaine Georgia, calculate the average age.",
        "query": "SELECT AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Lake Elaina\"",
        "step": "【step1】: Join the `Staff` table (A) with the `Addresses` table (B) using `staff_address_id` to link coaches' data with their location information.  【step2】: Filter records where `B.state_province_county` is \"Georgia\" and `B.city` is \"Lake Elaina\" to isolate coaches in the specified region.  【step3】: Calculate the average age by evaluating `YEAR(CURDATE()) - YEAR(date_of_birth)`, adjusting for unpassed birthdays via `DATE_FORMAT`, then apply the `AVG()` function.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2108,
        "question": "If the average age of coaches living in Lake Elaine, Georgia is twice the average age of coaches living in Port Melyssa,Georgia, what is the average age of the coaches living in Lake Elaine, Georgia?",
        "query": "SELECT 2 * AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Port Melyssa\"",
        "step": "【step1】: Join the Staff and Addresses tables based on staff_address_id and filter records to include only coaches in 'Port Melyssa, Georgia'.  【step2】: Calculate the exact age for each coach using date_of_birth and adjust for unpassed birthdays via DATE_FORMAT comparisons.  【step3】: Compute the average age of the filtered coaches and multiply by 2 to reflect the required ratio for Lake Elaine's average.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2109,
        "question": "What is the average age of coaches in Lake Elaine Georgia if the average ages of coaches here is twice the average of coaches living in Port Melyssa, Georgia?",
        "query": "SELECT 2 * AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Port Melyssa\"",
        "step": "【step1】: Calculate the average age of coaches in Port Melyssa, Georgia with:  ```sql  SELECT AVG(YEAR(CURDATE()) - YEAR(date_of_birth) - (DATE_FORMAT(CURDATE(), '%m-%d') < DATE_FORMAT(date_of_birth, '%m-%d'))) AS port_avg  FROM Staff  WHERE staff_address_id IN (      SELECT address_id      FROM Addresses      WHERE city = 'Port Melyssa'      AND state_province_county = 'Georgia'  )  ```  【step2】: Multiply the result from step 1 by 2 to get Lake Elaine's average age.  【step3】: Use the final calculation as the answer (no additional SQL needed since it's a mathematical operation on the retrieved value).  *Note: The original query contained incorrect logic (directly multiplying by 2 in SQL) and city name inconsistencies (\"Port Melyssa\" vs \"Port Melyssa\"). This solution separates the critical components while maintaining accurate geographical references.*",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2110,
        "question": "How old is Janessa Amara Sawayn five years after she left office, and how many years younger than Camylle Icie Weissnat?",
        "query": "SELECT * FROM ( SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) AS diff FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" )",
        "step": "【step1】: Calculate Janessa's age 5 years after leaving: Compute her age by (YEAR(date_left_staff) - YEAR(date_of_birth)) adjusted for month/day comparison, then add 5.  【step2】: Compute birthdate difference: Retrieve Camylle's date_of_birth, subtract Janessa's date_of_birth (via nested subquery) using DATEDIFF to get the day gap.  【step3】: Join both results: Combine the age calculation (t1) and birthdate difference (t2) into a single output via an implicit JOIN.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 3,
        "idx": 2111,
        "question": "Give me Janessa Amara Sawayn's age five years after leaving office and how many years younger were they than Camylle Icie Weissnat?",
        "query": "SELECT * FROM ( SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) AS diff FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" )",
        "step": "【step1】: Calculate Janessa's age five years after leaving office by subtracting her birth year from her exit year, adjusting if her birthday hadn't occurred yet, and adding 5.  【step2】: Retrieve Camylle's birth date, compute the difference from Janessa's birth date via a nested subquery to determine the age gap.  【step3】: Combine both results using a JOIN to display the final age and age difference in a single output.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2112,
        "question": "If Camylle Icie Weissnat is 30 years old when Janessa Amara Sawayn leaves, how old is Janessa Amara Sawayn five years after she left office, and how many years younger than Camylle Icie Weissnat?",
        "query": "SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age , 30 - ( strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\"",
        "step": "【step1】: Filter the Staff table to retrieve the specific record for Janessa Amara Sawayn using first_name, middle_name, and last_name in the WHERE clause.  【step2】: Calculate her age when leaving office: (YEAR(date_left_staff) - YEAR(date_of_birth)) with a conditional adjustment for birthdate precision using DATE_FORMAT comparisons on month-day.  【step3】: Compute final outputs: Add 5 years to her leaving-age for \"age\" and subtract her leaving-age from 30 to determine \"diff\" in age compared to Camylle.",
        "format": "MySQL"
    },
    {
        "db_id": "school",
        "type": 4,
        "idx": 2113,
        "question": "How old was Janessa Amara Sawayn five years after leaving office if Camylle Icie Weissnat was 30 years old when Janessa Amara Sawayn left? How much younger was Janessa Amara Sawayn than Camylle Icie Weissnat?",
        "query": "SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age , 30 - ( strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\"",
        "step": "【step1】: Filter the Staff table to retrieve the row for Janessa Amara Sawayn using first_name, middle_name, and last_name conditions.  【step2】: Calculate Janessa's age when leaving office: YEAR(date_left_staff) - YEAR(date_of_birth), adjusted by comparing month-day values to account for incomplete birth years.  【step3】: Compute two final results:  - Add 5 years to Janessa's leaving age (age at leaving + 5).  - Subtract Janessa's leaving age from Camylle's age (30) to determine the age difference (diff).",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2114,
        "question": "How many days did John Smith stay in hospital?",
        "query": "SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "step": "【step1】: Join Stay and Patient tables using Patient.SSN to link hospitalization records with patient information.  【step2】: Filter the combined data to retain only entries where Patient.name equals 'John Smith'.  【step3】: Calculate the date difference between StayEnd and StayStart using DATEDIFF(), then explicitly cast the result as a signed integer for clarity.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2115,
        "question": "How long was John Smith admitted to the hospital?",
        "query": "SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "step": "【step1】: Join the Stay (A) and Patient (B) tables using A.Patient = B.SSN to link hospitalization records with patient information.  【step2】: Apply WHERE B.name = 'John Smith' to filter records specifically for the patient named John Smith.  【step3】: Calculate the date difference between StayEnd and StayStart using DATEDIFF, then cast the result as SIGNED to return the hospitalization duration in days.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2116,
        "question": "If John Smith left the hospital on International Nurses Day, how many days did John Smith stay in the hospital?",
        "query": "SELECT julianday ( strftime ( \"%Y-\" , A.StayEnd ) || \"05-12\" ) - julianday ( strftime ( \"%Y-\" , A.StayStart ) || strftime ( \"%m-%d\" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "step": "【step1】: Join the `Stay` table with the `Patient` table on `Patient.SSN = Stay.Patient` and filter for `Patient.name = 'John Smith'` to retrieve his hospitalization records.  【step2】: Replace the actual `StayEnd` date with a constructed International Nurses Day date (May 12 of the same year as `StayEnd`) using `STR_TO_DATE(CONCAT(YEAR(A.StayEnd), '-05-12'), '%Y-%m-%d')`.  【step3】: Calculate the day difference between the formatted `StayStart` and the constructed International Nurses Day using `DATEDIFF()`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2117,
        "question": "If John Smith was discharged from the hospital on International Nurses Day, for how long was he admitted to the hospital?",
        "query": "SELECT julianday ( strftime ( \"%Y-\" , A.StayEnd ) || \"05-12\" ) - julianday ( strftime ( \"%Y-\" , A.StayStart ) || strftime ( \"%m-%d\" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "step": "【step1】: Join the \"Stay\" and \"Patient\" tables using SSN, filtering records where patient name is \"John Smith\".  【step2】: Extract year from StayEnd date, then reconstruct a new date using that year combined with fixed \"05-12\" (International Nurses Day).  【step3】: Calculate date difference between original admission date (StayStart) and the constructed discharge date using DATEDIFF().",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2118,
        "question": "How many more patients have used Foo Labs branded drugs than those have used Baz Industries branded drugs?",
        "query": "SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Foo Labs\"",
        "step": "【step1】: Calculate the number of distinct patients who used Foo Labs drugs by joining Medication and Prescribes tables, filtering with Brand='Foo Labs'.  【step2】: Calculate the number of distinct patients who used Baz Industries drugs via a subquery using the same table join method with Brand='Baz Industries'.  【step3】: Subtract the Baz Industries patient count (from step2) from the Foo Labs patient count (from step1) to get the final difference.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2119,
        "question": "What is the difference in the number of patients who have used drugs branded by Foo Labs compared to those who have used drugs branded by Baz Industries?",
        "query": "SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Foo Labs\"",
        "step": "【step1】: Calculate the number of distinct patients associated with \"Foo Labs\" by joining the Medication and Prescribes tables, filtering on `A.Brand = 'Foo Labs'`, and counting unique `Patient` values.  【step2】: Calculate the number of distinct patients associated with \"Baz Industries\" using a subquery with the same table join logic but filtering on `A.Brand = 'Baz Industries'`.  【step3】: Subtract the result of the subquery (Baz Industries patient count) from the main query's result (Foo Labs patient count) to compute the final `diff` value.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2120,
        "question": "If there were 10 patients who used Foo Labs brand drugs, how many more patients have used Foo Labs branded drugs than those have used Baz Industries branded drugs?",
        "query": "SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff",
        "step": "【step1】: Join the Medication and Prescribes tables to link medications with prescriptions, filtering for records where the Brand is 'Baz Industries'.  【step2】: Calculate the count of distinct patients from the joined result to determine how many unique patients used Baz Industries drugs.  【step3】: Subtract the count from step 2 from the fixed value 10 to get the difference in patient counts between Foo Labs and Baz Industries.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2121,
        "question": "If 10 patients have used drugs branded by Foo Labs, how many additional patients have used Foo Labs branded drugs compared to the number of patients who have used drugs branded by Baz Industries?",
        "query": "SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff",
        "step": "【step1】: Join the \"Medication\" and \"Prescribes\" tables where the medication codes match, filtering only records where the brand is 'Baz Industries'.  【step2】: Count the distinct number of patients from the joined result.  【step3】: Subtract this count from 10 to get the difference in patient numbers.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2122,
        "question": "How many times is the number of appointments made by the physician with the highest number of appointments compared to the physician with the lowest number of appointments?",
        "query": "SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "step": "【step1】: Execute the inner subquery to group appointments by physician and count each group's entries, creating a temporary table \"sub\" with columns (Physician, c).  【step2】: Compute the maximum (MAX(c)) and minimum (MIN(c)) values from the \"c\" column in the \"sub\" table.  【step3】: Calculate the ratio of MAX(c) to MIN(c) and multiply by 1.0 to ensure a floating-point result, aliasing the final value as \"times\".",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2123,
        "question": "What is the ratio between the number of appointments made by the physician with the highest and lowest appointments?",
        "query": "SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "step": "【step1】: Group appointments by physician and count the number of appointments for each one using `GROUP BY Physician` and `COUNT(*)`.  【step2】: Calculate the maximum and minimum appointment counts from the grouped results using `MAX(c)` and `MIN(c)`.  【step3】: Compute the ratio of the maximum to minimum counts with `1.0 * MAX(c) / MIN(c)` to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2124,
        "question": "If the physician with the fewest appointments made 2 new appointments, how many times is the number of appointments made by the physician with the highest number of appointments compared to the physician with the lowest number of appointments?",
        "query": "SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "step": "【step1】: Calculate the number of appointments for each physician by grouping the Appointment table and counting entries per Physician.  【step2】: Determine the maximum appointment count (highest) and the minimum appointment count (lowest) from the grouped results.  【step3】: Compute the ratio by dividing the highest count by (lowest count + 2) to account for the 2 new appointments, using 1.0* to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2125,
        "question": "If the physician who has the least number of appointments schedules 2 additional appointments, what is the ratio between the number of appointments made by the physician with the highest and him?",
        "query": "SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "step": "【step1】: Subquery (t) groups appointments by physician and counts each group's total (c).  【step2】: Compute MAX(c) (highest appointment count) and MIN(c) (lowest appointment count) from subquery t.  【step3】: Calculate the ratio using 1.0*MAX(c)/(MIN(c)+2) to ensure floating-point division and handle the \"+2 appointments\" scenario.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2126,
        "question": "All drugs are 2 dollars per dose. How much did Dennis Doe spend on all drugs and treatment in total?",
        "query": "SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "step": "【step1】: Calculate medication cost by summing prescribed doses for 'Dennis Doe' and multiplying by $2 via subquery `med_sub`.  【step2】: Calculate procedure cost by summing all procedure costs linked to 'Dennis Doe' via subquery `pro_sub`.  【step3】: Combine results from both subqueries and output the total cost using `med_cost + pro_cost`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2127,
        "question": "If all drugs cost 2 dollars per dose, what is the total amount spent by Dennis Doe on drugs and treatment?",
        "query": "SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "step": "【step1】: Calculate the total medication cost by multiplying the sum of prescribed doses by 2 for Dennis Doe from the **Prescribes** and **Patient** tables.  【step2】: Calculate the total procedure cost by summing the cost of all treatments linked to Dennis Doe from the **Procedures**, **Undergoes**, and **Patient** tables.  【step3】: Combine the results of step 1 and step 2 using a **CROSS JOIN** (since both subqueries return single values) and sum them as **total_cost**.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2128,
        "question": "All drugs are 2 dollars per dose. If Dennis Doe bought 10 more doses of Thesisin at 16:53 on April 30th, 2008, how much did Dennis Doe spend on all drugs and treatment in total?",
        "query": "SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" AND A.Date != \"2008-04-30 16:53\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "step": "【step1】: Calculate the medication cost for Dennis Doe excluding the purchase on 2008-04-30 16:53 by summing doses from Prescribes, multiplying by 2 (since each dose costs $2).  【step2】: Calculate the total procedure cost for Dennis Doe by summing costs from Procedures linked via Undergoes.  【step3】: Combine the two calculated costs (med_cost and pro_cost) and add $20 (10 doses × $2) for the additional purchase to get the final total_cost.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2129,
        "question": "If all drugs cost 2 dollars per dose and Dennis Doe purchased 10 additional doses of Thesisin at 16:53 on April 30, 2008, what is the total amount spent by Dennis Doe on all drugs and treatment?",
        "query": "SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" AND A.Date != \"2008-04-30 16:53\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "step": "【step1】:Calculate the medication cost excluding the specified purchase: Sum all doses prescribed to Dennis Doe (excluding the April 30, 2008 16:53 record), multiply by $2 per dose using an INNER JOIN between Prescribes and Patient tables.  【step2】:Calculate the treatment procedure cost: Sum all procedure costs for Dennis Doe through an INNER JOIN chain across Procedures, Undergoes, and Patient tables.  【step3】:Combine results via CROSS JOIN: Add the medication cost (from step1), procedure cost (from step2), and the additional 10-dose purchase cost (10*2) to get the total amount.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2130,
        "question": "How long is the validity period of John Wen''s trained procedures qualification certificate?",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "step": "【step1】: Join tables `Trained_In` (A), `Physician` (B), and `Procedures` (C) using `A.Physician = B.EmployeeID` and `C.code = A.Treatment` to link qualification, physician, and procedure data.  【step2】: Filter the joined data to retain only records where `B.name = 'John Wen'`.  【step3】: Calculate the validity period by applying `DATEDIFF(A.CertificationExpires, A.CertificationDate)` and alias it as `lifetime`, while explicitly casting the result as a signed integer.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2131,
        "question": "What is the validity period of John Wen''s trained procedure qualification certificate?",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "step": "【step1】: Join the `Trained_In` table with `Physician` using `EmployeeID` to filter records where `Physician.name` equals 'John Wen'.  【step2】: Join the result with `Procedures` using `code` to retrieve the associated procedure name.  【step3】: Calculate the validity period by subtracting `CertificationDate` from `CertificationExpires` with `DATEDIFF`, then cast the result as `SIGNED` for explicit integer output.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2132,
        "question": "How long is the validity period of John Wen''s trained procedures qualification certificate, if the the validity period is extended by 180 days?",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "step": "【step1】: Join the \"Trained_In\", \"Physician\", and \"Procedures\" tables using their respective foreign keys (Physician.EmployeeID and Procedures.code).  【step2】: Calculate the original validity period with `DATEDIFF(A.CertificationExpires, A.CertificationDate)` and add 180 days to this value.  【step3】: Filter the results to only include records where the physician's name is \"John Wen\" and return the procedure name and extended validity period.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2133,
        "question": "If the validity period of John Wen's trained procedures qualification certificate is extended by 180 days, what is the new validity period of the certificate?",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "step": "【step1】: Join the \"Trained_In\", \"Physician\", and \"Procedures\" tables to link the physician's qualifications with their identity and procedure details.  【step2】: Filter the joined data to retain only records where the physician's name is \"John Wen\".  【step3】: Calculate the extended validity period by adding 180 days to the original duration (difference between CertificationExpires and CertificationDate) using DATEDIFF and CAST.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2134,
        "question": "What is the proportion of physicians who belong to both Surgery department and General Medicine department out of physicians who belong to Surgery department?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = \"Surgery\" or B.Name = \"General Medicine\" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "step": "【step1】: Retrieve the DepartmentID for 'Surgery' from the Department table.  【step2】: Calculate the total number of physicians in the Surgery department using the DepartmentID obtained in Step1.  【step3】: Identify physicians affiliated with both 'Surgery' and 'General Medicine', count them as the numerator, and compute the proportion by dividing this count by the total from Step2.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2135,
        "question": "What is the ratio of physicians who are members of both the Surgery department and the General Medicine department, compared to the total number of physicians in the Surgery department?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = \"Surgery\" or B.Name = \"General Medicine\" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "step": "【step1】: Retrieve the total number of physicians in the Surgery department by filtering the Affiliated_With table using the DepartmentID of 'Surgery' from the Department table.  【step2】: Identify physicians affiliated with both 'Surgery' and 'General Medicine' by joining Affiliated_With and Department, grouping by physicians, and filtering those with exactly two distinct department names.  【step3】: Calculate the ratio by dividing the count of dual-affiliated physicians (from step2) by the total Surgery department physicians (from step1), using 1.0 * to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2136,
        "question": "If Keith Dudermeister belongs to both the Surgery department and the General Medicine department, what is the proportion of physicians who belong to both the Surgery department and the General Medicine department among physicians who belong to the Surgery department?",
        "query": "SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != \"Keith Dudermeister\" and Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != \"Keith Dudermeister\" and ( B.Name = \"Surgery\" or B.Name = \"General Medicine\" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "step": "【step1】: Calculate the denominator: Count all physicians in the Surgery department (excluding Keith Dudermeister) and add 1 to avoid division errors. This is done via the subquery filtering `B.Name != 'Keith Dudermeister'` and matching the Surgery department.  【step2】: Calculate the numerator: Identify physicians (excluding Keith) affiliated with both Surgery and General Medicine via `GROUP BY Physician HAVING COUNT(DISTINCT B.Name) = 2`, then add 1 to include Keith as per the hypothetical condition.  【step3】: Compute the proportion by dividing the adjusted numerator by the adjusted denominator, using `1.0 *` to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2137,
        "question": "If Keith Dudermeister is a member of both the Surgery and General Medicine departments, what is the proportion of physicians who belong to both departments out of the total number of physicians in the Surgery department?",
        "query": "SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != \"Keith Dudermeister\" and Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != \"Keith Dudermeister\" and ( B.Name = \"Surgery\" or B.Name = \"General Medicine\" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "step": "【step1】: Calculate the count of physicians (excluding Keith) affiliated with both 'Surgery' and 'General Medicine' via subquery: Join **Affiliated_With**, **Department**, and **Physician**, filter by department names, group by physician, and keep those with exactly two distinct departments.  【step2】: Calculate total physicians in the Surgery department (excluding Keith) via nested subquery: Join **Affiliated_With** and **Physician**, filter by department ID derived from **Department**, and exclude Keith.  【step3】: Compute the proportion by combining results: Add 1 to both counts (to include Keith) in the numerator and denominator, then perform division with type conversion to ensure decimal output.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2138,
        "question": "How many times is the highest price of the treatments compared to the lowest price?",
        "query": "SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures",
        "step": "【step1】: Retrieve the maximum value of the Cost column from the Procedures table using MAX(Cost).  【step2】: Retrieve the minimum value of the Cost column from the same table using MIN(Cost).  【step3】: Calculate the ratio of these two values by dividing MAX(Cost) by MIN(Cost), and multiply by 1.0 to ensure floating-point division. Assign the result to the alias \"times\".",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2139,
        "question": "What is the ratio between the highest and lowest prices of the treatments?",
        "query": "SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures",
        "step": "【step1】: Retrieve the maximum cost from the \"Cost\" column in the Procedures table using MAX(Cost).  【step2】: Retrieve the minimum cost from the \"Cost\" column in the Procedures table using MIN(Cost).  【step3】: Calculate the ratio by dividing the maximum cost by the minimum cost, multiplied by 1.0 to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2140,
        "question": "How many times is the highest price of the treatments compared to the lowest price, if the the lowest price was increased by 75%?",
        "query": "SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures",
        "step": "【step1】: Adjust the lowest price by increasing it by 75% using `(1 + 0.75) * MIN(Cost)`.  【step2】: Calculate the highest price using `MAX(Cost)`.  【step3】: Divide the highest price by the adjusted lowest price and ensure floating-point division with `1.0 * MAX(...) / adjusted_min`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2141,
        "question": "If the lowest price of the treatments was increased by 75%, what would be the new ratio between the highest and lowest prices?",
        "query": "SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures",
        "step": "【step1】: Retrieve the original MAX(Cost) and MIN(Cost) from the `Procedures` table.  【step2】: Calculate the adjusted lowest price by increasing the original MIN(Cost) by 75% (multiplying by 1.75).  【step3】: Compute the ratio between the original MAX(Cost) and the adjusted lowest price, ensuring floating-point division for precision.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2142,
        "question": "How many treatments with a cost higher than 1000 account for the total number of treatments?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000",
        "step": "【step1】: Calculate the number of treatments where the cost exceeds 1000 using **COUNT(*)** filtered by **WHERE Cost > 1000**.  【step2】: Compute the total number of treatments in the **Procedures** table via a subquery **SELECT COUNT(*) FROM Procedures**.  【step3】: Divide the result of Step1 by Step2 and multiply by **1.0** to ensure floating-point division, producing the final ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2143,
        "question": "What proportion of treatments, out of the total number of treatments, cost higher than 1000?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000",
        "step": "【step1】: Calculate the total number of treatments using the subquery `(SELECT COUNT(*) FROM Procedures)`.  【step2】: Count the number of treatments where `Cost > 1000` via `COUNT(*) FROM Procedures WHERE Cost > 1000`.  【step3】: Divide the two results (cast as a float using `1.0 *`) to compute the proportion.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2144,
        "question": "What is the proportion of patients who do not use Procrastin-X in the total number of patients?",
        "query": "SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = \"Procrastin-X\"",
        "step": "【step1】: Calculate the total number of distinct patients using `COUNT(DISTINCT SSN)` on the **Patient** table.  【step2】: Count distinct patients prescribed \"Procrastin-X\" by joining **Medication** and **Prescribes** on `code = Medication` and filtering with `Name = 'Procrastin-X'`.  【step3】: Compute the proportion by subtracting the ratio of patients using Procrastin-X (Step2) to total patients (Step1) from 1.0.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2145,
        "question": "What proportion of patients, out of the total number of patients, do not use Procrastin-X?",
        "query": "SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = \"Procrastin-X\"",
        "step": "【step1】: Calculate the total number of distinct patients using the subquery `(SELECT COUNT(DISTINCT SSN) FROM Patient)`, where SSN serves as the unique patient identifier.  【step2】: Identify patients prescribed \"Procrastin-X\" by joining the **Medication** and **Prescribes** tables on `code = Medication`, filtering with `A.Name = 'Procrastin-X'`, and counting distinct `Patient` values.  【step3】: Compute the proportion by subtracting the ratio of \"Procrastin-X\" patients (from Step 2) to the total patients (from Step 1) from `1.0`, ensuring floating-point division via `1.0 *` multipliers.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2146,
        "question": "How much is the difference between Dennis Doe's most expensive treatment and his cheapest treatment?",
        "query": "SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "step": "【step1】: Join the \"Procedures\", \"Undergoes\", and \"Patient\" tables to link treatment costs with Dennis Doe's records.  【step2】: Filter the joined dataset to only include entries where the patient's name is 'Dennis Doe'.  【step3】: Calculate the difference between the maximum and minimum treatment costs from the filtered results using `MAX(A.Cost) - MIN(A.Cost)`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2147,
        "question": "What is the difference between Dennis Doe's most expensive and least expensive treatments?",
        "query": "SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "step": "【step1】: Join the \"Procedures\", \"Undergoes\", and \"Patient\" tables using their respective keys to link treatment records with Dennis Doe. Filter to retain only records where the patient's name is 'Dennis Doe'.  【step2】: Extract the cost values of all treatments associated with Dennis Doe from the joined dataset.  【step3】: Calculate the difference between the maximum and minimum treatment costs using the MAX() and MIN() aggregate functions on the extracted cost values.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2148,
        "question": "If the price of each treatment was increased by 50%, how much is the difference between Dennis Doe's most expensive treatment and his cheapest treatment?",
        "query": "SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "step": "【step1】: Join the Patient, Undergoes, and Procedures tables to retrieve all treatment records associated with Dennis Doe.  【step2】: Calculate the original maximum and minimum treatment costs from the filtered records.  【step3】: Apply the 50% price increase to both values and compute their difference using **(1.5 * MAX(Cost)) - (1.5 * MIN(Cost))**.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2149,
        "question": "If the price of each treatment was increased by 50%, what would be the difference between Dennis Doe's most expensive and least expensive treatments?",
        "query": "SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "step": "【step1】: Join the `Procedures`, `Undergoes`, and `Patient` tables using their respective keys to filter records associated with 'Dennis Doe'.  【step2】: Calculate the original maximum and minimum treatment costs (`MAX(A.Cost)` and `MIN(A.Cost)`) from the filtered results.  【step3】: Apply a 50% increase to both values and compute their difference using `(1.5 * MAX) - (1.5 * MIN)` to get the final `diff`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2150,
        "question": "How many available rooms account for the total number of rooms?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = \"0\"",
        "step": "【step1】: Calculate the total number of rooms using the subquery `(SELECT COUNT(*) FROM Room)`.  【step2】: Determine the count of available rooms by filtering `WHERE Unavailable = 0`.  【step3】: Compute the proportion by dividing the available count by the total count, using `1.0 *` to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2151,
        "question": "What is the proportion of available rooms to the total number of rooms?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = \"0\"",
        "step": "【step1】: Calculate the total number of rooms using a subquery: `(SELECT COUNT(*) FROM Room)`.  【step2】: Count available rooms by filtering with `WHERE Unavailable = '0'`: `COUNT(*) FROM Room WHERE Unavailable = '0'`.  【step3】: Compute the proportion by dividing the available count by the total count, ensuring floating-point division with `1.0 *`: `1.0 * (step2 result) / (step1 result) AS prop`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2152,
        "question": "If there are two beds in each room, how many people can be accommodated in the available room in total?",
        "query": "SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = \"0\"",
        "step": "【step1】: Filter the \"Room\" table to only include available rooms where Unavailable is '0'.  【step2】: Count the number of available rooms using `COUNT(*)`.  【step3】: Multiply the count by 2 (since each room accommodates 2 people) and alias the result as `n_people`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2153,
        "question": "If each room has two beds, what is the total number of people that can be accommodated in all the available rooms?",
        "query": "SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = \"0\"",
        "step": "【step1】: Filter available rooms by selecting rows where Unavailable is '0'  【step2】: Count the number of available rooms using COUNT(*)  【step3】: Multiply the room count by 2 (beds per room) and alias the result as n_people",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2154,
        "question": "What is the duration in minutes of an appointment with an appointment ID of 13216584?",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "step": "【step1】: Filter the Appointment table where AppointmentID is '13216584' to find the specific appointment.  【step2】: Calculate the time difference between End and Start times in seconds using UNIX_TIMESTAMP.  【step3】: Convert the time difference from seconds to minutes by dividing by 60.0 and return as 'time'.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 3,
        "idx": 2155,
        "question": "How long is the appointment with appointment ID 13216584 in minutes?",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "step": "【step1】: Filter the Appointment table to retrieve the record with AppointmentID '13216584'.  【step2】: Calculate the time difference between End and Start in seconds using UNIX_TIMESTAMP().  【step3】: Convert the seconds to minutes by dividing by 60 and alias the result as 'time'.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2156,
        "question": "If the duration of the appointment with an appointment ID 13216584 is extended for half an hour, how many minutes will it last?",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "step": "【step1】: Retrieve the Start and End timestamps for the appointment with ID '13216584' from the Appointment table.  【step2】: Calculate the original duration in minutes using `(UNIX_TIMESTAMP(End) - UNIX_TIMESTAMP(Start)) / 60.0` to convert the timestamp difference to minutes.  【step3】: Add 30 minutes to the original duration to reflect the extension and return the total duration as `time`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2157,
        "question": "If the appointment with appointment ID 13216584 is extended by 30 minutes, what will be the new total duration of the appointment in minutes?",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "step": "【step1】: Retrieve the start and end times of the appointment with ID '13216584' from the Appointment table using the WHERE clause.  【step2】: Calculate the original duration in minutes by subtracting the UNIX timestamps of Start and End, then dividing by 60.0 to convert seconds to minutes.  【step3】: Add 30 minutes to the original duration to get the new total duration, aliased as \"time\".",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2158,
        "question": "If the training fee for each training is 50, who is the physician who spent the most on training? List his name, position, and training expenses.",
        "query": "SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )",
        "step": "【step1】: Join the Physician and Trained_In tables to associate each physician with their training records. Calculate the training cost (50 * training count) and group by physician.  【step2】: In a subquery, compute the maximum training count across all physicians by grouping and aggregating the Trained_In table.  【step3】: Filter the grouped results from step1 using HAVING to match the maximum training count from step2, ensuring only the physician(s) with the highest expense are selected.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2159,
        "question": "Which physician has incurred the highest training expenses, if the training fee for each session is 50? Provide their name, position, and total training expense.",
        "query": "SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )",
        "step": "【step1】: Calculate the total training sessions per physician by joining the Physician and Trained_In tables, grouping by physician, and multiplying the session count by 50 to compute the cost.  【step2】: Determine the maximum number of training sessions across all physicians using a subquery that aggregates and calculates the max count from the Trained_In table.  【step3】: Filter the grouped results to retain only the physician(s) whose training session count matches the maximum value found in step 2, returning their name, position, and total expense.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2160,
        "question": "How many more rooms are available on the top floor than on the bottom floor?",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )",
        "step": "【step1】: Determine the highest (MAX) and lowest (MIN) BlockFloor values from the Room table using subqueries.  【step2】: Calculate the number of available rooms (Unavailable = '0') on the top floor (MAX BlockFloor) with the outer query's main COUNT(*).  【step3】: Subtract the available rooms on the bottom floor (MIN BlockFloor), computed via a nested subquery, from the top floor count to get the difference (diff).",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 2,
        "idx": 2161,
        "question": "What is the difference in the number of available rooms on the top and bottom floors?",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )",
        "step": "【step1】: Retrieve the maximum floor number using a subquery: (SELECT MAX(BlockFloor) FROM Room).  【step2】: Calculate available rooms on max floor (WHERE Unavailable=0) and min floor via nested subquery: (SELECT MIN(BlockFloor)...).  【step3】: Subtract the bottom floor count from the top floor count using arithmetic operation COUNT(*) - (subquery result).",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2162,
        "question": "Suppose there are 20 available rooms on the top floor, how many more rooms are available on the top floor than on the bottom floor?",
        "query": "SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff",
        "step": "【step1】: Retrieve the lowest floor number by executing the innermost subquery: `SELECT MIN(BlockFloor) FROM Room`.  【step2】: Calculate the number of available rooms on the lowest floor using the result from step 1: `SELECT COUNT(*) FROM Room WHERE Unavailable = '0' AND BlockFloor = [lowest_floor]`.  【step3】: Subtract the count from step 2 from the fixed value 20 (top-floor available rooms) to get the difference: `SELECT 20 - [step2_count] AS diff`.",
        "format": "MySQL"
    },
    {
        "db_id": "hospital",
        "type": 4,
        "idx": 2163,
        "question": "If the top floor has 20 available rooms, what is the difference in the number of available rooms between the top and bottom floors?",
        "query": "SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff",
        "step": "【step1】: Find the minimum BlockFloor value in the Room table using `(SELECT MIN(BlockFloor) FROM Room)`.  【step2】: Count available rooms (where Unavailable = '0') on the identified minimum floor with `(SELECT COUNT(*) FROM Room WHERE Unavailable = '0' AND BlockFloor = [step1_result])`.  【step3】: Subtract the count from step2 from the fixed value 20 to calculate the difference, aliased as `diff`.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2164,
        "question": "What is the percentage of players with coaches in the total number of players?",
        "query": "SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach",
        "step": "【step1】: Execute the subquery to calculate the total number of distinct players: `SELECT COUNT(DISTINCT Player_ID) FROM player`.  【step2】: Calculate the number of distinct players with coaches from the `player_coach` table: `COUNT(DISTINCT Player_ID)`.  【step3】: Compute the percentage by dividing the result from Step 2 by Step 1 and multiplying by 100.0, then alias the output as `ratio`.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2165,
        "question": "What percentage of total players have coaches?",
        "query": "SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach",
        "step": "【step1】: Calculate the total number of distinct players with coaches by using COUNT(DISTINCT Player_ID) on the player_coach table.  【step2】: Retrieve the overall distinct player count via a subquery (SELECT COUNT(DISTINCT Player_ID) FROM player).  【step3】: Compute the percentage by dividing the two values, multiplying by 100.0 for decimal precision, and aliasing the result as \"ratio\".",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2166,
        "question": "If Jim Maloway's coach is Joe Fabbri, what is the percentage of players with coaches in the total number of players?",
        "query": "SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != \"Jim Maloway\"",
        "step": "【step1】: Calculate the total number of distinct players using the subquery: `SELECT COUNT(DISTINCT Player_ID) FROM player`.  【step2】: Compute the count of players with coaches by joining `player_coach` and `player`, excluding \"Jim Maloway\" via `WHERE B.Player_name != 'Jim Maloway'`, then add 1 (to include Jim Maloway's hypothetical coach) via `COUNT(DISTINCT A.Player_ID) + 1`.  【step3】: Combine the results to calculate the percentage: multiply the adjusted coached player count by 100.0 and divide by the total player count from step 1.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2167,
        "question": "What percentage of players have a coach under the premise of Joe Fabbri coaching Jim Maloway?",
        "query": "SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != \"Jim Maloway\"",
        "step": "【step1】: Calculate the total number of distinct players using a subquery:  `(SELECT COUNT(DISTINCT Player_ID) FROM player)`  【step2】: Join the `player_coach` and `player` tables to find players with coaches. Exclude \"Jim Maloway\" via `WHERE B.Player_name != 'Jim Maloway'`, counting distinct `Player_ID` from `player_coach` (denoted as `COUNT(DISTINCT A.Player_ID)`).  【step3】: Add 1 to the counted players (compensating for the excluded \"Jim Maloway\" who is coached by Joe Fabbri) and calculate the percentage by dividing the adjusted count by the total players from step1, then multiplying by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2168,
        "question": "What percentage of the total number of clubs were built before the year the Bitcoin Network was first launched?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\"",
        "step": "【step1】: Calculate the total number of clubs using the subquery `(SELECT COUNT(*) FROM club)`.  【step2】: Count clubs built before 2009 with `COUNT(*)` filtered by `WHERE Start_year < '2009'`.  【step3】: Compute the percentage by dividing the two counts and multiplying by 100.0 to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2169,
        "question": "How many clubs, out of the total number, were constructed and opened prior to the launching of the Bitcoin Network?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\"",
        "step": "【step1】: Filter clubs with Start_year earlier than 2009 and count them using `COUNT(*)`.  【step2】: Calculate the total number of clubs via the subquery `(SELECT COUNT(*) FROM club)`.  【step3】: Compute the ratio by dividing the count from Step1 by the result of Step2, then multiply by 100.0 to get the percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2170,
        "question": "If the Helsingborgs IF Club was established in 2000 instead, what percentage of the total number of clubs were built before the year the Bitcoin Network was first launched?",
        "query": "SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\" AND Club_name != \"Helsingborgs IF\"",
        "step": "【step1】: Calculate the number of clubs established before 2009 (Bitcoin Network's launch year) excluding the original 'Helsingborgs IF', then add 1 to account for the hypothetical 2000 establishment.  【step2】: Retrieve the total number of clubs in the database.  【step3】: Compute the percentage by dividing the adjusted count (Step1) by the total clubs (Step2), then multiply by 100.0 for final ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2171,
        "question": "Which clubs, as a percentage of total clubs, existed prior to the foundation of the Bitcoin Network if the Helsingborgs IF Club was actuallly established in 2000?",
        "query": "SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\" AND Club_name != \"Helsingborgs IF\"",
        "step": "【step1】: Filter clubs established before 2009 (Bitcoin Network's foundation year) while excluding \"Helsingborgs IF\" using `WHERE Start_year < '2009' AND Club_name != 'Helsingborgs IF'`, and count them.  【step2】: Calculate the total number of clubs using a subquery `(SELECT COUNT(*) FROM club)`.  【step3】: Adjust the count by adding 1 (to include the corrected establishment year of Helsingborgs IF), compute the percentage with `100.0 * (COUNT(*) + 1) / total_clubs`, and return the final ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2172,
        "question": "How many medals have all the clubs in the country that owns the world's longest railway won?",
        "query": "SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "step": "【step1】: Filter clubs located in the country owning the world's longest railway (Russia) via WHERE A.Region = 'Russia'  【step2】: Join club and match_result tables using Club_ID to access medal records  【step3】: Calculate total medals by summing Gold, Big_Silver, Small_Silver and Bronze columns across all matching rows",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2173,
        "question": "What is the medal count for all clubs located in the same country as the longest railway in the world?",
        "query": "SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "step": "【step1】: Retrieve all clubs located in Russia by filtering the `club` table where `Region` equals 'Russia'.  【step2】: Join the filtered clubs with the `match_result` table using `Club_ID` to access medal data.  【step3】: Calculate the total medal count by summing `Gold`, `Big_Silver`, `Small_Silver`, and `Bronze` values for the joined results.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2174,
        "question": "How many medals have all the clubs in the country that owns the world's longest railway won if the number of gold medal of each club was doubled?",
        "query": "SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "step": "【step1】: Join the `club` and `match_result` tables using `Club_ID`, then filter clubs located in Russia (country with the world's longest railway) via `WHERE A.Region = 'Russia'`.  【step2】: For each qualifying club, calculate adjusted medals by doubling `Gold` (via `2 * Gold`) and summing it with other medal types (`Big_Silver`, `Small_Silver`, `Bronze`).  【step3】: Aggregate the adjusted medal counts across all qualifying clubs using `SUM()` to produce the final `total_medals` result.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2175,
        "question": "Assuming the number of gold medal of each club was doubled, what is the medal count for all clubs located in the same country as the longest railway in the world?",
        "query": "SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "step": "【step1】: Identify the country with the longest railway in the world (implied as \"Russia\" from the WHERE clause).  【step2】: Join the \"club\" and \"match_result\" tables to link clubs with their medal data, filtering clubs located in Russia.  【step3】: Calculate the adjusted medal count by doubling the Gold medals, summing all medals (2*Gold + Big_Silver + Small_Silver + Bronze), and return the total for eligible clubs.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2176,
        "question": "How many times more medals does the top ranked club have than the third ranked club?",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "step": "【step1】: Calculate the total number of medals (Gold + Big_Silver + Small_Silver + Bronze) for the club ranked 1st in the match_result table.  【step2】: Calculate the total number of medals for the club ranked 3rd using the same medal summation logic.  【step3】: Join the two results and compute the ratio (1st-ranked medals / 3rd-ranked medals) as times, using 1.0* to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2177,
        "question": "What is the ratio of medals between the top ranked and third ranked club?",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "step": "【step1】: Retrieve total medals for the top-ranked club (rank=1) by summing all medal columns (Gold, Big_Silver, Small_Silver, Bronze) into \"n_1\".  【step2】: Retrieve total medals for the third-ranked club (rank=3) using the same summation method, storing it as \"n_3\".  【step3】: Calculate the ratio via cross-joining the two results and computing 1.0*n_1/n_3 to preserve decimal precision.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2178,
        "question": "How many times more medals does the top ranked club have than the third ranked club, if the number of bronze medals of the top ranked club was tripled?",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "step": "【step1】: Calculate the adjusted total medals for the top-ranked club (rank=1) by tripling its bronze medals: `Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1` from the `match_result` table.  【step2】: Calculate the total medals for the third-ranked club (rank=3) without adjustments: `Gold + Big_Silver + Small_Silver + Bronze AS n_3` from the `match_result` table.  【step3】: Compute the ratio between the top-ranked club's adjusted medals (n_1) and the third-ranked club's total medals (n_3) using `1.0 * n_1 / n_3 AS times` by joining the two subqueries.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2179,
        "question": "If the number of bronze medals for the highest-ranking club was tripled, how many times more medals does the highest-ranking club club have compared to the thrid ranked club?",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "step": "【step1】: Calculate the adjusted medal count for the highest-ranking club (rank=1) by tripling its bronze medals and summing with other medals.  【step2】: Calculate the total medal count for the third-ranked club (rank=3) by summing all medals without adjustment.  【step3】: Join the two results and compute the ratio of the highest-ranking club's adjusted medals to the third-ranked club's medals.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2180,
        "question": "If a gold medal equals 5 points, a big silver medal equals 3 points, a small silver equals 2 points, and a bronze equals 1 point, where is the club with the highest number of points located, when was it established, and how many male and female coaches does it have?",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"F\" )",
        "step": "【step1】: Calculate the highest scoring club using medal points (5*Gold +3*Big_Silver +2*Small_Silver +1*Bronze) via subquery, find its Club_ID.  【step2】: Count male coaches (Gender='M') for this club with GROUP BY Region/Start_year in one subquery, and count female coaches (Gender='F') in a separate subquery.  【step3】: Combine male coach count (containing Region/Start_year) and female coach count via CROSS JOIN to produce final unified output.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2181,
        "question": "Assuming you converted a gold medal to 5 points, a big silver medal to 3 points, a small silver to two points and a bronze medal to 1 point, where is the highest scoring club located, when was it established, and what are the male coach count and the female coach count for the club?",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"F\" )",
        "step": "【step1】: Calculate the total points for each club in the match_result table using the medal-to-point conversion formula (5*Gold + 3*Big_Silver + 2*Small_Silver + 1*Bronze), then identify the Club_ID with the maximum points via a nested subquery (sub1/sub2).  【step2】: Retrieve the club's Region and Start_year from the club table, while also counting male coaches (n_M) by joining with the coach table and filtering Gender = 'M' for the identified Club_ID (t1 subquery).  【step3】: In parallel, count female coaches (n_F) using the same Club_ID via a similar join and filter (Gender = 'F') in the t2 subquery, then combine both counts with the club details using a final JOIN.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2182,
        "question": "If a gold medal equals 5 points, a big silver medal equals 3 points, a small silver equals 2 points, a bronze equals 1 point and the number of bronze medals of clubs that have the most and fewest number of gold medals were the same, where is the club with the highest number of points located, when was it established, and how many male and female coaches does it have?",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"F\" )",
        "step": "【step1】: Calculate the adjusted points for clubs by handling two scenarios: clubs with the most gold medals use their original bronze count, while clubs with the fewest gold medals take the bronze count from the club with the most gold medals. Combine these results using UNION.  【step2】: Identify the club with the highest total points from the UNION result, and extract its Club_ID.  【step3】: Retrieve the club's region, founding year, and count male/female coaches by joining the club and coach tables using the identified Club_ID.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2183,
        "question": "If the clubs with the highest and lowest number of gold medals had an equivalent number of bronze medals --- find me where the highest scoring club is located, when it was established, and the male coach count and the female coach count for the club if you converted all medals to points when a gold medal is 5 points, a big silver medal is 3 points, a small silver medal is 2 points and a bronze medal is 1 point.",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"F\" )",
        "step": "【step1】: **Identify the club with the highest gold medals** and the club with the lowest gold medals. Check if they have the same bronze count. Use subqueries to calculate their bronze equivalence by dynamically substituting the bronze count of the highest-gold club into the lowest-gold club's calculation.  【step2】: **Calculate weighted scores** for all clubs using the formula `5*Gold + 3*Big_Silver + 2*Small_Silver + 1*Bronze` (with bronze replaced for the lowest-gold club). Filter out non-matching clubs, sort by the score, and isolate the top-scoring club's ID.  【step3】: **Join the identified club** with `club` and `coach` tables to extract its region, establishment year, and count male/female coaches via partitioned `COUNT` with gender filters. Merge results into a final output with columns `Region`, `Start_year`, `n_M`, and `n_F`.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2184,
        "question": "What is the proportion of small businessman among the contestants who have won the championship?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" GROUP BY Player_ID )",
        "step": "【step1】: Calculate the total number of unique champions by selecting Player_IDs with Rank='1st' and grouping to avoid duplicates.  【step2】: Calculate the number of unique champions with Occupation='Small Businessman' using the same deduplication method.  【step3】: Compute the proportion by dividing the result from Step2 by Step1, using 1.0* to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2185,
        "question": "Out of contestants winning the championship, how many of them are small businessman as a proportion?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" GROUP BY Player_ID )",
        "step": "【step1】: Calculate the total number of unique championship-winning players by selecting `Player_ID` from the `player` table where `Rank` is '1st' and grouping to eliminate duplicates.  【step2】: Calculate the subset of championship-winning players who are 'Small Businessman' by filtering with `Occupation = 'Small Businessman'` in addition to `Rank = '1st'`, also grouping by `Player_ID` to ensure uniqueness.  【step3】: Divide the count of small businessman winners by the total championship winners (from step1) and multiply by `1.0` to force floating-point division, producing the final proportion.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2186,
        "question": "If Ross Eadie won the first place instead, what is the proportion of small businessman among the contestants who have won the championship?",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" AND Occupation = \"Small Businessman\" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" and Player_name != \"Ross Eadie\" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" AND Player_name != \"Ross Eadie\" GROUP BY Player_ID )",
        "step": "【step1】: Calculate the base count of unique champion Small Businessman (excluding Ross Eadie) using SELECT DISTINCT Player_ID FROM player WHERE Rank='1st' AND Occupation='Small Businessman' AND Player_name != 'Ross Eadie'.  【step2】: Compute two conditional counts:  - Potential Ross Eadie's Small Businessman status: (SELECT COUNT(*) FROM player WHERE Player_name='Ross Eadie' AND Occupation='Small Businessman')  - Original champion count without Ross: (SELECT COUNT(*) FROM (SELECT DISTINCT Player_ID FROM player WHERE Rank='1st' AND Player_name != 'Ross Eadie') AS sub1)  【step3】: Combine values using formula (base_small_biz + potential_ross_biz) / (original_champ_count + ross_as_champ_count) where ross_as_champ_count is (SELECT COUNT(*) FROM player WHERE Player_name='Ross Eadie'), then output as proportion.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2187,
        "question": "What proportion of the winning contestants are small businessmen if Ross Eadie won first place instead of their actual placement?",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" AND Occupation = \"Small Businessman\" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" and Player_name != \"Ross Eadie\" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" AND Player_name != \"Ross Eadie\" GROUP BY Player_ID )",
        "step": "【step1】: Calculate the number of unique 1st-place contestants who are small businessmen (excluding Ross Eadie) using the main subquery with GROUP BY Player_ID.  【step2】: Compute the numerator by adding Ross Eadie's eligibility (1 if he's a Small Businessman, else 0) to the count from Step 1.  【step3】: Calculate the denominator as the sum of unique original 1st-place contestants (excluding Ross Eadie) and Ross Eadie's total entries, then divide the numerator by this denominator to get the proportion.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2188,
        "question": "What is the probability of a contestant guided by Jameson Tomas winning the championship?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\"",
        "step": "【step1】: Calculate the total number of contestants coached by Jameson Tomas using a subquery by joining the player, player_coach, and coach tables with the condition Coach_name = 'Jameson Tomas'.  【step2】: Count the number of contestants coached by Jameson Tomas who won the championship (Rank = '1st') by joining the same tables and applying both Coach_name and Rank filters.  【step3】: Divide the championship-winning count (Step2) by the total coached contestants (Step1) using 1.0 * to ensure floating-point division, returning the probability.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2189,
        "question": "If a contestant is guided by Jameson Tomas then what probability is there of this contestant winning the championship?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\"",
        "step": "【step1】: Calculate the total number of contestants guided by Jameson Tomas using a subquery. This is done by joining the `player`, `player_coach`, and `coach` tables, filtering where `Coach_name = 'Jameson Tomas'`.  【step2】: Count how many of these contestants have a `Rank` of '1st' (indicating championship winners) by repeating the same joins and adding the condition `A.Rank = '1st'` in the main query.  【step3】: Divide the number of championship winners (from step 2) by the total contestants guided by Jameson Tomas (from step 1) using `1.0 * COUNT(*) / (subquery)` to ensure floating-point division and output the result as `prob`.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2190,
        "question": "If Fiona Shiells won the first place instead, what is the probability of a contestant guided by Jameson Tomas winning the championship?",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Player_name = \"Fiona Shiells\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\" AND A.Player_name != \"Fiona Shiells\"",
        "step": "【step1】: Calculate the count of contestants guided by Jameson Tomas who currently have 1st place rank and are not Fiona Shiells.  【step2】: Compute the numerator by adding the count from step1 and the hypothetical scenario where Fiona Shiells (if guided by Jameson Tomas) is included via a subquery.  【step3】: Determine the denominator by counting all contestants guided by Jameson Tomas, then divide the numerator by the denominator to calculate the probability.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2191,
        "question": "Imagine if Fiona Shiells won the championship then what would the probability be for a contestant winning if they are guided by Jameson Tomas?",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Player_name = \"Fiona Shiells\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\" AND A.Player_name != \"Fiona Shiells\"",
        "step": "【step1】: Count the number of contestants coached by Jameson Tomas who have already won the championship (Rank = '1st') excluding Fiona Shiells.  【step2】: Add the result from Step 1 to the hypothetical scenario where Fiona Shiells (if coached by Jameson Tomas) is also counted as a winner.  【step3】: Divide the combined count (Step 1 + Step 2) by the total number of contestants coached by Jameson Tomas to calculate the adjusted probability.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2192,
        "question": "What's the name of the coach who has guided the most number of champions, and how many more has he produced than the coach who has guided the fewest?",
        "query": "SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) )",
        "step": "【step1】: Calculate the number of champions guided by each coach using a UNION to include coaches with zero champions. This creates a combined dataset of all coaches with their champion counts (either actual counts or 0).  【step2】: Identify the maximum champion count (n_1st) from the combined dataset to filter the top coach, and calculate the minimum champion count (n_1st) to determine the difference.  【step3】: Subtract the minimum champion count from the top coach’s count to get the difference, and output the coach’s name and this difference.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2193,
        "question": "Find me the name of the coach with the most winning contestants and then find me how many more champions this coach has trained than the coach with the fewest winning contestants.",
        "query": "SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) )",
        "step": "【step1】: Calculate each coach's championship count (including coaches with 0 wins via UNION) through joined tables.  【step2】: Identify the coach with MAX(n_1st) and prepare MIN(n_1st) via subquery.  【step3】: Subtract MIN from MAX in final SELECT to output the championship difference.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2194,
        "question": "Coaches earn $100 for every champion they guided, $60 for every runner-up and $20 for every third-place finisher. What's the name of the coach who gets the most bonuses and how much does they earn?",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "step": "【step1】: Calculate each coach's number of 1st, 2nd, and 3rd-place players using three subqueries (t1, t2, t3). For coaches without players in a specific rank, use UNION to set their count to 0.  【step2】: Join these three subqueries by coach name to create a unified dataset containing all rank counts per coach.  【step3】: Compute the total bonus (100×n_1st + 60×n_2nd + 20×n_3rd), then select the coach with the highest bonus using MAX() and LIMIT 1 after sorting in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 2,
        "idx": 2195,
        "question": "Find me the name and bonus of the highest bonus earning coach if each champion earns $100, a runner-up earns $60 and a third place earns $20.",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "step": "【step1】: Calculate each coach's count of 1st place players (n_1st) via JOINs between player, player_coach, and coach tables, while ensuring coaches with zero 1st place players are included via UNION.  【step2】: Repeat the same logic as step1 separately for 2nd place (n_2nd) and 3rd place (n_3rd) counts, creating subqueries t2 and t3.  【step3】: JOIN subqueries t1, t2, t3 by Coach_name, compute total bonus (100*n_1st + 60*n_2nd + 20*n_3rd), then select the maximum value and corresponding coach using MAX() aggregation.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2196,
        "question": "Coaches earn $100 for every champion they guided, $60 for every runner-up and $20 for every third-place finisher. If Rachel Heinrichs won the runner-up, what's the name of the coach who gets the most bonuses and how much does he earn?",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND A.Player_name = \"Rachel Heinrichs\" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "step": "【step1】: Calculate each coach's number of 1st place wins (n_1st), including coaches with 0 wins via UNION to ensure all coaches are listed.  【step2】: Compute each coach's 2nd place count (n_2nd), excluding the coach of \"Rachel Heinrichs\" initially, then explicitly add her coach's count +1 to ensure her runner-up status is reflected. Simultaneously include coaches with 0 runner-ups.  【step3】: Derive each coach's 3rd place count (n_3rd), again including coaches with 0 via UNION. Join all three results (t1, t2, t3) by Coach_name, calculate total bonuses (100*n_1st +60*n_2nd +20*n_3rd), and select the coach with the MAX total earnings.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2197,
        "question": "What is the name and bonus of the coach with the highest bonus of Rachel Heinrichs won runner-up? Convert a champion into $100 bonus, a runner-up to $60 bonus and a third-place position to a $20 bonus.",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND A.Player_name = \"Rachel Heinrichs\" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "step": "【step1】: Calculate the number of 1st-place wins (n_1st) for each coach using a UNION to include coaches with zero 1st-place results.  【step2】: Compute the number of 2nd-place wins (n_2nd): exclude Rachel Heinrichs' coach from general counts, add an extra +1 to her coach's count via a UNION, and include coaches with zero 2nd-place results.  【step3】: Calculate 3rd-place wins (n_3rd) similarly to step 1, then join all subqueries to compute total bonuses and select the coach with the highest bonus using MAX().",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2198,
        "question": "What percentage of clubs were established before the 21st century?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001",
        "step": "【step1】: Calculate total number of clubs using subquery: (SELECT COUNT(*) FROM club).  【step2】: Count clubs established before 2001 with WHERE Start_year < 2001.  【step3】: Compute percentage via (filtered_count / total_count) * 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2199,
        "question": "What percentage of clubs were founded prior to the 21st Century?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001",
        "step": "【step1】: Calculate the total number of clubs using a subquery: `(SELECT COUNT(*) FROM club)`.  【step2】: Count clubs founded before 2001 via `COUNT(*)` with a filter `WHERE Start_year < 2001`.  【step3】: Compute the percentage by dividing the pre-21st-century count by the total count and multiplying by `100.0` for decimal precision.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2200,
        "question": "If all the clubs in USA were established in 2000, what percentage of clubs were established before the 21st century?",
        "query": "SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = \"USA\" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != \"USA\"",
        "step": "【step1】: Calculate the number of non-USA clubs established before 2001 using `COUNT(*)` with conditions `Start_year < 2001 AND Region != 'USA'`.  【step2】: Retrieve the total number of USA clubs via subquery `(SELECT COUNT(*) FROM club WHERE Region = 'USA')`, treating them as pre-21st-century clubs (since they are hypothetically set to 2000).  【step3】: Compute the final percentage by summing the results from Step1 and Step2, dividing by the global club count (via subquery `(SELECT COUNT(*) FROM club)`), and multiplying by 100.0 for percentage formatting.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2201,
        "question": "What percentage of clubs were founded before the 21st Century given that all clubs in the USA were founded in 2000.",
        "query": "SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = \"USA\" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != \"USA\"",
        "step": "【step1】: Calculate the count of non-USA clubs founded before 2001 using `COUNT(*)` with filters `Start_year < 2001 AND Region != 'USA'`.  【step2】: Add the count of all USA clubs (implicitly founded in 2000 as per the problem statement) via the subquery `(SELECT COUNT(*) FROM club WHERE Region = 'USA')`.  【step3】: Divide the combined count by the total number of clubs (from the subquery `(SELECT COUNT(*) FROM club)`) and multiply by 100.0 to get the percentage.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2202,
        "question": "What are the names of players living in the capital of Manitoba provincee in Cnanda received more than twice as many votes as Ross C. Martin?",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = \"Ross C. Martin\" )",
        "step": "【step1】: Determine the capital of Manitoba province in Canada, which is 'Winnipeg'.  【step2】: Retrieve Ross C. Martin's vote count via subquery: `SELECT Votes FROM player WHERE Player_name = 'Ross C. Martin'`.  【step3】: Filter players residing in Winnipeg with votes exceeding twice Ross C. Martin's votes using combined WHERE clause.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2203,
        "question": "Of the players living in Manitona province's capital city, what are the names of players who received more than twice the votes that Ross C. Martin recieved?",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = \"Ross C. Martin\" )",
        "step": "【step1】: Retrieve the number of votes received by Ross C. Martin using a subquery: `(SELECT Votes FROM player WHERE Player_name = 'Ross C. Martin')`  【step2】: Calculate twice the retrieved votes (2 * subquery result) as the threshold value.  【step3】: Filter players residing in 'Winnipeg' (Manitona province's capital) whose votes exceed this threshold via `WHERE Residence = 'Winnipeg' AND Votes > [threshold]`.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2204,
        "question": "What are the names of players living in the capital of Manitoba provincee in Cnanda received more than twice as many votes as Ross C. Martin, if Ross C. Martin obtained 2000 votes instead?",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * 2000 AND Player_name != \"Ross C. Martin\"",
        "step": "【step1】: Filter players residing in 'Winnipeg' (the capital of Manitoba, Canada).  【step2】: Apply a vote threshold of **4000** (twice Ross C. Martin's 2000 votes) using `Votes > 4000`.  【step3】: Exclude 'Ross C. Martin' explicitly with `Player_name != 'Ross C. Martin'` to finalize the results.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2205,
        "question": "Of the players living in Manitona province's capital city, what are the names of players who received more than twice the votes that Ross C. Martin recieved, if if Ross C. Martin obtained 2000 votes instead?",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * 2000 AND Player_name != \"Ross C. Martin\"",
        "step": "【step1】: Filter players residing in 'Winnipeg' (the capital of Manitona province) using `WHERE Residence = 'Winnipeg'`.  【step2】: Apply the vote condition `Votes > 2 * 2000` to select players with votes exceeding twice Ross's 2000 votes.  【step3】: Exclude 'Ross C. Martin' explicitly using `Player_name <> 'Ross C. Martin'` to avoid including the player in the results.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2206,
        "question": "What are the names of the players whose coaches come from clubs established before the 21st Century, and how much higher are their votes than the lowest?",
        "query": "SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "step": "【step1】: Filter clubs established before 2006 via `D.Start_year < 2006` and establish table connections (player→player_coach→coach→club)  【step2】: Match players to their coaches' clubs using JOINs on Player_ID→Coach_ID→Club_ID  【step3】: Calculate vote differential by subtracting the global minimum vote (subquery `SELECT MIN(Votes) FROM player`) from each player's votes",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2207,
        "question": "Find me the names of players who have coaches that come from clubs established prior to the 21st Century and then calculate how much higher their respective votes are than the lowest number of votes.",
        "query": "SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "step": "【step1】: Perform INNER JOINs across player, player_coach, coach, and club tables to link players with their coaches' clubs. Apply the WHERE clause to filter clubs established before 2006.  【step2】: Execute the subquery `(SELECT MIN(Votes) FROM player)` to retrieve the absolute minimum vote value across all players.  【step3】: Calculate the difference (`diff`) between each filtered player's votes and the globally lowest votes, then project `Player_name` and `diff` in the final output.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2208,
        "question": "What are the names of players who are guided by coaches from clubs established before the 21st Century, and how much higher are their votes than the lowest if the lowest votes count is 1000?",
        "query": "SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "step": "【step1】: Filter clubs established before 2006 (21st Century cutoff based on the query) via `WHERE D.Start_year < 2006`.  【step2】: Join `club`, `coach`, `player_coach`, and `player` tables to link players with their coaches' clubs.  【step3】: Calculate the vote difference by subtracting 1000 from each player's votes (`A.Votes - 1000 AS diff`) and output the player names with this difference.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2209,
        "question": "If the lowest vote count is 1000 then find what are the names of the players who have coaches from pre-21st-century clubs and calculate how much higher these players votes are than the minimum vote count.",
        "query": "SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "step": "【step1】: Join tables (player, player_coach, coach, club) to link players with their coaches' clubs and filter clubs with Start_year < 2006.  【step2】: Apply the condition to select players whose coaches belong to pre-21st-century clubs (Start_year < 2006).  【step3】: Calculate the difference between each player's votes and the minimum vote count (1000), then return Player_name and the computed diff.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2210,
        "question": "What is the probability of a player without a coach winning the championship?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = \"1st\"",
        "step": "【step1】: Identify all players without a coach by excluding those with entries in the `player_coach` table through a subquery using `Player_ID NOT IN (SELECT ... JOIN player_coach ... JOIN coach)`.  【step2】: Calculate the total count of players without a coach (denominator) and the count of such players who won the championship (`Rank = '1st'`, numerator) using filtered `WHERE` conditions.  【step3】: Compute the probability ratio by dividing the numerator by the denominator using `1.0 * COUNT(*) / (subquery)` to ensure floating-point precision.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2211,
        "question": "If a player has no coach then how likely is it that they will win the championship?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = \"1st\"",
        "step": "【step1】: Retrieve all players without a coach by excluding those with entries in the `player_coach` table via `Player_ID NOT IN (SELECT ... JOIN coach)`.  【step2】: Calculate the numerator (players without a coach *and* with `Rank` = '1st') and denominator (total players without a coach) using filtered subqueries.  【step3】: Compute the ratio by dividing the numerator by the denominator using `1.0 * COUNT(*) / (subquery)` to ensure floating-point division.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2212,
        "question": "How much more likely is the coached player to finish in the top two than the uncoached player?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" )",
        "step": "【step1】: Calculate the coached players' probability of finishing in the top two by dividing the number of coached top-two players by the total coached players.  【step2】: Calculate the uncoached players' probability similarly, using a subquery to exclude coached players and counting those in the top two.  【step3】: Subtract the uncoached probability from the coached probability to get the likelihood difference (`diff`).",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 3,
        "idx": 2213,
        "question": "What is the difference in likelihood of a coached player finishing in the top two versus an uncoached player?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" )",
        "step": "【step1】: Calculate the proportion of coached players who finished in the top two: Join `player`, `player_coach`, and `coach` tables, count those with rank '1st' or '2nd', then divide by the total number of coached players.  【step2】: Calculate the proportion of uncoached players who finished in the top two: Identify players not in the coached subset via `NOT IN`, count those with rank '1st' or '2nd', then divide by the total number of uncoached players.  【step3】: Subtract the uncoached proportion from the coached proportion to get the likelihood difference (`diff`), using arithmetic operations on the two subquery results.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2214,
        "question": "If Niki Ashton was an uncoached player, how much more likely is the coached player to finish in the top two than the uncoached player?",
        "query": "SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) AND A.Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != \"Niki Ashton\" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != \"Niki Ashton\" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name != \"Niki Ashton\" )",
        "step": "【step1】: Calculate the probability (prob_1) of coached players (excluding Niki Ashton) finishing in the top two by:  - Counting coached top-two players (excluding Niki Ashton) in the numerator.  - Dividing by the total number of coached players (excluding Niki Ashton).  【step2】: Calculate the adjusted probability (prob_2) of uncoached players (assuming Niki Ashton is uncoached) by:  - Adding Niki Ashton’s top-two count to the numerator of uncoached top-two players.  - Adjusting the denominator to include her in the total uncoached player count.  【step3】: Subtract prob_2 from prob_1 to find the difference in likelihood (diff) between coached and uncoached players.",
        "format": "MySQL"
    },
    {
        "db_id": "exerciseclub",
        "type": 4,
        "idx": 2215,
        "question": "How much likelier is it that a coached player ranks in the top two than a player without a coach if Niki Ashton has no coach?",
        "query": "SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) AND A.Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != \"Niki Ashton\" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != \"Niki Ashton\" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name != \"Niki Ashton\" )",
        "step": "【step1】: Calculate the probability (prob_1) of coached players (excluding Niki Ashton) ranking in the top two by:  - Subtracting the count of Niki Ashton (with a coach, if applicable) from coached top-two players.  - Dividing by the total coached players (excluding Niki Ashton).  【step2】: Calculate the probability (prob_2) of non-coached players (excluding Niki Ashton) ranking in the top two by:  - Adding the count of Niki Ashton (if non-coached and in the top two) to non-coached top-two players.  - Dividing by the total non-coached players (excluding Niki Ashton) + 1 (to account for potential inclusion logic).  【step3】: Compute the difference (diff) between prob_1 and prob_2 to determine the likelihood gap.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2216,
        "question": "How much has Sterling spent so far?",
        "query": "SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "step": "【step1】: Join all relevant tables (Customers, Customer_Orders, Order_Items, Products) using appropriate foreign keys to link customer data with product price information.  【step2】: Filter the joined dataset to retain only records where the customer_name is 'Sterling'.  【step3】: Calculate the total expenditure by summing the product of order quantities and corresponding product prices for the filtered records.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2217,
        "question": "What is the total spend for Sterling to date?",
        "query": "SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "step": "【step1】: Join all related tables (Customers, Customer_Orders, Order_Items, Products) via customer_id and order/product foreign keys.  【step2】: Filter the combined data to retain only records where customer_name = 'Sterling'.  【step3】: Calculate the sum of (order_quantity × product_price) across all matching records to get total spend.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2218,
        "question": "If the unit price of all Gucci products is 600, how much has Sterling spent so far?",
        "query": "SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name = \"gucci\" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name != \"gucci\" )",
        "step": "【step1】: Calculate the cost of 'Gucci' products using the fixed unit price of 600. Join relevant tables (Customers, Customer_Orders, Order_Items, Products), filter for 'Sterling' and 'gucci', then compute SUM(order_quantity * 600).  【step2】: Calculate the cost of non-'Gucci' products using original prices. Use the same joins but filter for 'Sterling' and product_name ≠ 'gucci', computing SUM(order_quantity * product_price).  【step3】: Combine both results via UNION (ensuring no duplicates), then aggregate the total sum from the combined subquery using an outer SUM(cost).",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2219,
        "question": "Calculate Sterling's total spend to date if all Gucci products cost 600 each.",
        "query": "SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name = \"gucci\" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name != \"gucci\" )",
        "step": "【step1】: Calculate the cost for all 'Gucci' products ordered by Sterling using the fixed price of 600 per unit by joining Customers, Customer_Orders, Order_Items, and Products tables with conditions **customer_name = 'Sterling'** and **product_name = 'gucci'**, then multiply order_quantity by 600.  【step2】: Calculate the cost for non-'Gucci' products ordered by Sterling using the original product_price by joining the same tables with conditions **customer_name = 'Sterling'** and **product_name != 'gucci'**, then multiply order_quantity by product_price.  【step3】: Combine the two results using **UNION** to merge both cost calculations into a single column, then apply an outer **SUM()** to aggregate the total spend across all products (both Gucci and non-Gucci).",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2220,
        "question": "Sterling is a member and gets a 20% discount on all products. How much has he spent so far?",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "step": "【step1】: Join `Customers` (A) with `Customer_Orders` (B) via `customer_id` to identify all orders placed by customer 'Sterling'.  【step2】: Link the result to `Order_Items` (C) and `Products` (D) via `order_id` and `product_id` respectively, obtaining product prices and quantities.  【step3】: Calculate total expenditure by summing `order_quantity * product_price` with a 20% discount applied, aliased as `cost_after_discount`.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2221,
        "question": "Calculate Sterling's spend to date factoring in a 20% member price discount.",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "step": "【step1】: Join `Customers` and `Customer_Orders` on `customer_id` to link Sterling's orders.  【step2】: Join `Order_Items` and `Products` on `product_id` to access product prices and quantities.  【step3】: Calculate total spend using `SUM` with a 20% discount applied to `product_price` multiplied by `order_quantity`, filtered by `customer_name = 'Sterling'`.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2222,
        "question": "Sterling is a member and gets a 20% discount on all products. How much has he saved so far?",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "step": "【step1】: Join the Customers, Customer_Orders, Order_Items, and Products tables using customer_id, order_id, and product_id relationships.  【step2】: Filter records where customer_name is 'Sterling' to isolate his orders.  【step3】: Calculate total savings by summing 20% of (order_quantity * product_price) across all matching entries.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2223,
        "question": "Calculate how much Sterling has saved to date through their 20% member price discount.",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "step": "【step1】: Join the Customers table (A) with Customer_Orders (B) using customer_id to identify Sterling's orders.  【step2】: Join Order_Items (C) to get product quantities and Products (D) to access prices for each ordered item.  【step3】: Calculate the total discount savings by summing (quantity × price × 20%) for all matching records filtered by customer_name = 'Sterling'.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2224,
        "question": "List customer IDs, names, addresses, phone numbers, and email addresses in descending order of their total spending to date.",
        "query": "SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC",
        "step": "【step1】: Join customer, order, and product tables to link customer details with purchased item data.  【step2】: Calculate total spending per customer by summing the product of order quantities and prices.  【step3】: Group results by customer attributes and sort by total spending in descending order.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2225,
        "question": "Sort customers by descending order of total spending to today and give me the total spend, name, email address, phone number, mail address and customer ID.",
        "query": "SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC",
        "step": "【step1】: Join all related tables (Customers, Customer_Orders, Order_Items, Products) using their foreign keys to consolidate customer information with order quantities and product prices.  【step2】: Group the joined data by customer attributes (customer_id, name, address, phone, email) and calculate total spending using SUM(order_quantity * product_price).  【step3】: Sort the grouped results in descending order of the calculated total spending (cost).",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2226,
        "question": "What is the total price of Cleo's latest order?",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "step": "【step1】: Join the Customers, Customer_Orders, Order_Items, and Products tables to gather all relevant order details for Cleo.  【step2】: Calculate the total cost per order (grouped by order_id) by multiplying product quantities and prices, then filter for Cleo using WHERE A.customer_name = 'Cleo'.  【step3】: Sort the results by order_date in descending order and select the top entry (LIMIT 1) to retrieve the latest order's total price.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2227,
        "question": "Calculate the sum price of the lastest order from Cleo.",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "step": "【step1】: Join the `Customers`, `Customer_Orders`, `Order_Items`, and `Products` tables to gather order details and product prices for customer 'Cleo'.  【step2】: Calculate the total cost per order (`SUM(C.order_quantity * D.product_price)`) grouped by `order_id`, generating a temporary result set (`subquery`).  【step3】: Sort the temporary results by `order_date` in descending order and select the top entry (`LIMIT 1`) to retrieve the cost of the most recent order.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2228,
        "question": "What is the total price of Cleo's latest order if he purchased 5 of each product?",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "step": "【step1】: Join tables (Customers, Customer_Orders, Order_Items, Products) using respective IDs, filter for customer_name = 'Cleo'.  【step2】: Group by order_id to calculate total price per order by summing 5×product_price for all products in each order.  【step3】: Sort results by order_date descending and select the top entry to retrieve the latest order's total cost.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2229,
        "question": "If Cleo purchased 5 of each product, then what is the total cost of Cleo's latest order?",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "step": "【step1】: Retrieve Cleo's orders with product details by joining Customers, Customer_Orders, Order_Items, and Products tables.  【step2】: Calculate total cost per order (5 units × product_price for each item) and group by order_id.  【step3】: Sort results by order_date descending and extract the latest order's total cost using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2230,
        "question": "The cost of Apple products is 40% of the selling price, Gucci products is 20% of the selling price, and other products is 50% of the selling price. Please list each product's ID, name, sales volume, sales revenue, and total gross profit.",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "step": "【step1】: Calculate sales metrics for 'Apple' products: Join Order_Items with Products, filter by product_name='Apple', group by product_id, compute SUM(order_quantity) as quantity, SUM(quantity×price) as revenue, and apply 40% cost (60% profit margin) to calculate profit.  【step2】: Calculate metrics for 'Gucci' and other products using similar logic: Two separate UNION blocks handle 'Gucci' (20% cost → 80% margin) and non-Apple/Gucci products (50% cost → 50% margin) with respective WHERE/NOT IN filters.  【step3】: Include unsold products: Use LEFT JOIN to find products without Order_Items entries, set quantity/revenue/profit to 0, then UNION with previous results to ensure all products are listed.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2231,
        "question": "List all products and product ID, name, volume of sales, sales revenue and total gross profit if Apple products cost 40% of selling price, Gucci products cost 20% of selling price and all other products cost half their sale price.",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "step": "【step1】: Calculate Apple product metrics: JOIN Order_Items and Products, filter by 'Apple', group by product_id, apply 40% cost to compute profit.  【step2】: Process Gucci products similarly via UNION: filter by 'gucci', use 20% cost formula, maintain group aggregation.  【step3】: Merge results for non-Apple/Gucci products (50% cost) and unsold products (zero sales data) using UNION, ensuring full product coverage.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2232,
        "question": "The cost of Apple products is 40% of the selling price, Gucci products is 20% of the selling price, and other products is 50% of the selling price. If all Apple products are discounted by 15%, please list each product's ID, name, sales volume, sales revenue, and total gross profit.",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "step": "【step1】: Process Apple products with a 15% discount: Join Order_Items and Products, filter 'Apple' products, apply 15% discount on price, calculate revenue and profit (40% cost ratio), then aggregate by product.  【step2】: Handle Gucci and other products separately: Use UNION to combine three segments - Gucci products with 20% cost ratio, non-Apple/non-Gucci products with 50% cost ratio (both without discount), aggregating sales data similarly.  【step3】: Include unsold products: Use LEFT JOIN to find products without orders, set quantity/revenue/profit to 0, then UNION with previous results to ensure all products are listed.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2233,
        "question": "During an Apple sale discounting all product selling price by 15%, list all products and name, sales volume, product ID, revenue of sales and total profit gross if Apple products cost 40% of selling price, Gucci products cost 20% of selling price and all other products cost half their sale price.",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "step": "【step1】: Calculate discounted revenue and profit for Apple products: Apply a 15% discount, use 40% cost rate (profit=60% of discount price), aggregate sales data with JOIN on product_id.  【step2】: Process Gucci and other products with UNION:  - Gucci: No discount, 20% cost rate (profit=80% of original price)  - Others: No discount, 50% cost rate (profit=50% of original price)  【step3】: Include unsold products via subquery: Use NOT EXISTS to find products without orders, set quantity/revenue/profit=0, and UNION with previous results.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 2,
        "idx": 2234,
        "question": "What percentage of orders have been completed?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = \"Completed\"",
        "step": "【step1】: Calculate the total number of orders by using the subquery `(SELECT COUNT(*) FROM Customer_Orders)`.  【step2】: Count the completed orders with `WHERE order_status_code = 'Completed'` in the main query.  【step3】: Compute the percentage by dividing completed orders (from step2) by total orders (from step1), then multiply by 100 and convert to a float using `1.0 *`.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 2,
        "idx": 2235,
        "question": "Of total orders, what percentage are completed?",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = \"Completed\"",
        "step": "【step1】: Calculate the total number of orders using the subquery: `SELECT COUNT(*) FROM Customer_Orders`.  【step2】: Count completed orders by filtering with `WHERE order_status_code = 'Completed'`.  【step3】: Compute the percentage by dividing completed orders by total orders (from step1 and step2), then multiply by 100 and ensure floating-point division with `1.0 *`.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2236,
        "question": "If all orders before year 2000 have been completed, what percentage of orders have been completed?",
        "query": "SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( \"%Y\" , order_date ) >= \"2000\" AND order_status_code != \"Completed\"",
        "step": "【step1】: Calculate total number of orders using a subquery: `(SELECT COUNT(*) FROM Customer_Orders)`  【step2】: Count orders from year 2000 onward that are **not** completed: `COUNT(*) WHERE YEAR(order_date) >= 2000 AND order_status_code != 'Completed'`  【step3】: Compute percentage by subtracting non-completed orders' ratio from 100: `100 - (step2_result / step1_result * 100)`",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2237,
        "question": "Of total orders, what percentage are completed assuming all pre-2000 orders are completed?",
        "query": "SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( \"%Y\" , order_date ) >= \"2000\" AND order_status_code != \"Completed\"",
        "step": "【step1】: Calculate the total number of orders using a subquery: `(SELECT COUNT(*) FROM Customer_Orders)`.  【step2】: Count post-2000 orders that are *not* completed with `COUNT(*)` filtered by `YEAR(order_date) >= 2000 AND order_status_code != 'Completed'`.  【step3】: Compute the inverse percentage (subtracting non-completed post-2000 orders from total) via `100 - (step2 / step1 * 100)` to derive the percentage of \"completed\" orders under the assumption.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2238,
        "question": "What are the names of users with multiple contact methods and the amount of their first order?",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "step": "【step1】: Calculate the total price of each order by joining Order_Items, Customer_Orders, and Products. Group by customer_id and order_id to get SUM(A.order_quantity * C.product_price) as price.  【step2】: Filter customers with multiple contacts via a subquery on Contacts (HAVING COUNT(*) > 1), then join with Customers to append customer_name. Group by customer_id and include MIN(order_date) to identify the earliest order.  【step3】: Extract customer_name and price from the derived table, where the grouping in step2 ensures only the first order's price (linked to the earliest order_date) is retained per customer.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2239,
        "question": "Tell me the names and first order cost of users only with multiple contact methods?",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "step": "【step1】: Calculate the total cost (price) for each order by joining Order_Items, Customer_Orders, and Products, grouping by customer_id and order_id.  【step2】: Filter customers with multiple contact methods (via subquery on Contacts) and join with Customers to get names, retaining only relevant fields.  【step3】: Group results by customer_id, use ANY_VALUE() to fetch non-grouped fields (name and price), and wrap everything in an outer query for final projection.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2240,
        "question": "If all Apple products before year 2000 were priced at 888, what is the amount of the first order for users with multiple contact methods?",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = \"Apple\" AND strftime ( \"%Y\" , B.order_date ) < \"2000\" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != \"Apple\" OR strftime ( \"%Y\" , B.order_date ) >= \"2000\" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "step": "【step1】: Calculate order prices by splitting into two scenarios: (1) Apple products before 2000 use fixed price 888, (2) others use original price. Combine results via UNION and aggregate per order.  【step2】: Join with Customers table, filter users with >1 contact method using subquery on Contacts table.  【step3】: For qualifying users, find earliest order date per customer via MIN(order_date), then extract corresponding price and customer name in final output.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2241,
        "question": "Tell me the amount of the initial order only for users with multiple contact methods if all Apple products cost 888 before 2000?",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = \"Apple\" AND strftime ( \"%Y\" , B.order_date ) < \"2000\" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != \"Apple\" OR strftime ( \"%Y\" , B.order_date ) >= \"2000\" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "step": "【step1】: Calculate order prices by splitting into two scenarios: (1) Apple products before 2000 with fixed price 888, (2) Non-Apple products or orders after 2000 with original prices using UNION. Group by customer_id and order_id.  【step2】: Join with Customers table, filter users with multiple contacts via subquery (customer_id in Contacts with COUNT > 1), and aggregate per customer to retain MIN(order_date).  【step3】: Wrap in outer query to explicitly select customer_name and price, ensuring only the earliest order's price for qualifying users is returned.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2242,
        "question": "What are the names of users who have had multiple different addresses, and which postcode have they used the longest?",
        "query": "SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)",
        "step": "【step1】: Join the Customer_Address_History, Addresses, and Customers tables to associate address details and customer names with usage periods.  【step2】: Group by customer_id, calculate the duration of each address usage (DATEDIFF), and filter for users with >1 addresses (HAVING COUNT(*) > 1). Track the maximum usage duration per customer.  【step3】: Select the customer_name and zip_postcode from the subquery, implicitly returning the zip_postcode linked to the longest-dated address entry via MAX(DATEDIFF).",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2243,
        "question": "Tell me the names of users who have held multiple addresses on file and which postcode each user has held the longest?",
        "query": "SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)",
        "step": "【step1】: Join the Customer_Address_History, Addresses, and Customers tables to link user details, addresses, and address durations.  【step2】: Group by customer_id, calculate the maximum address duration (DATEDIFF), and filter users with multiple addresses (HAVING COUNT(*) > 1).  【step3】: Extract the customer_name and corresponding zip_postcode associated with the longest recorded duration from the grouped results.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2244,
        "question": "What are the names of users have never had multiple different addresses, and which postcode have they used?",
        "query": "SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1",
        "step": "【step1】: Join the Customer_Address_History, Addresses, and Customers tables to link user information with their address records.  【step2】: Group the results by customer_id to count how many distinct address entries each user has in their history.  【step3】: Apply a HAVING clause to filter only users with exactly 1 address record, then return their name and associated postcode.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2245,
        "question": "Tell me the names of users who have never had more than 1 address at any given time and which postcode each user held?",
        "query": "SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1",
        "step": "【step1】: Join Customer_Address_History, Addresses, and Customers tables to link user data with address details and postal codes.  【step2】: Group results by customer_id to aggregate address history entries per user.  【step3】: Filter groups using HAVING COUNT(*) = 1 to retain only users with exactly one permanent address record.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2246,
        "question": "Which user has not placed an order since 2000? List their ID, name, email, and the amount of their last order.",
        "query": "SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( \"%Y\" , MAX ( order_date ) ) < \"2000\" ) GROUP BY M.customer_id )",
        "step": "【step1】: Calculate the total price of each order by joining Order_Items, Customer_Orders, and Products, grouping by customer_id and order_id.  【step2】: Filter customers whose last order was before 2000 using a subquery, then join with Customers to get their details and derive the last_order_price via MAX(order_date).  【step3】: Output the final result by selecting customer_id, name, email, and the price of their last order from the aggregated subquery.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2247,
        "question": "Tell me the name, email, customer ID and most recent order total of users who have not ordered anything since 2000?",
        "query": "SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( \"%Y\" , MAX ( order_date ) ) < \"2000\" ) GROUP BY M.customer_id )",
        "step": "【step1】: Compute the total price of each historical order by joining Order_Items, Customer_Orders, and Products tables. Group by customer_id and order_id to calculate order_quantity × product_price sums.  【step2】: Filter customers whose last order was before 2000 using a subquery on Customer_orders (GROUP BY customer_id + HAVING YEAR(MAX(order_date)) < 2000), then join with Customers table to attach customer details.  【step3】: For qualifying customers, retrieve their most recent order total by grouping results from Step 2 by customer_id and selecting the MAX(order_date) along with the associated price.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2248,
        "question": "Users can earn 222 points for a single order with a total price of over 1000 and another 666 points for a total price of over 2000. Which user currently has the most total points? Give me their ID.",
        "query": "SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1",
        "step": "【step1】: Calculate the total price per order by joining Order_Items, Customer_Orders, and Products, then group by customer_id and order_id.  【step2】: Split into two subqueries:  - For orders over 2000: count each as 888 points (222+666).  - For orders between 1000-2000: count each as 222 points.  【step3】: Combine results via UNION, aggregate total points per user, sort descendingly, and return the top customer_id.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2249,
        "question": "Tell me the ID of the user with the most total points if all orders over 1000 earn 222 points and orders over 2000 earn and additional 666 points?",
        "query": "SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1",
        "step": "【step1】: Calculate the total price per order by joining Order_Items, Customer_Orders, and Products. Group by customer_id and order_id to compute SUM(order_quantity * product_price).  【step2】: Split into two subqueries: orders over 2000 (assign 888 points each via COUNT * 888) and orders between 1000-2000 (assign 222 points each via COUNT * 222). Combine results with UNION.  【step3】: Aggregate combined points by customer_id, sort by descending total points, and select the top customer_id with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 2,
        "idx": 2250,
        "question": "How much higher is the average unit price of clothing compared to hardware?",
        "query": "SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "step": "【step1】: Calculate the average price of hardware products using a subquery with alias 'a'  【step2】: Calculate the average price of clothing products using another subquery with alias 'b'  【step3】: Compute the difference between the two averages via CROSS JOIN of subquery results",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 2,
        "idx": 2251,
        "question": "Calculate the difference in average prices between clothing and hardware?",
        "query": "SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "step": "【step1】: Calculate the average price of Hardware products in subquery t1.  【step2】: Calculate the average price of Clothes products in subquery t2.  【step3】: Perform a JOIN between t1 and t2 (implicit cross join) and compute the difference between the two averages as diff.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2252,
        "question": "If clothing prices increase by 20%, how much higher is the average unit price of clothing compared to hardware?",
        "query": "SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "step": "【step1】: Calculate the average price for Hardware products using a subquery with alias 'hw'  【step2】: Calculate the original average price for Clothes products using a subquery with alias 'clothes', then perform CROSS JOIN between both subquery results  【step3】: Compute the price difference by applying the 20% increase to clothes_avg before subtracting hw_avg, using explicit floating-point arithmetic (20.0)",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2253,
        "question": "Calculate how much higher the difference in average price is between clothing and hardware if clothing prices increase by 20%?",
        "query": "SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "step": "【step1】: Calculate the average price of hardware products (hw_avg) using a subquery filtering by product_type_code = 'Hardware'.  【step2】: Calculate the current average price of clothing products (clothes_avg) using another subquery filtering by product_type_code = 'Clothes'.  【step3】: Perform a CROSS JOIN between the two subquery results, then compute the adjusted difference as (1.2 * clothes_avg) - hw_avg to account for the 20% price increase.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2254,
        "question": "How many users have used an address in a state with a capital city of Frankfurt, and what is the proportion of females among them?",
        "query": "SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = \"Kentucky\" AND C.gender = \"female\" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = \"Kentucky\" )",
        "step": "【step1】: Calculate the total number of distinct users who have used addresses in the state 'Kentucky' by joining **Customer_Address_History** and **Addresses** tables, filtering on `state_province_county = 'Kentucky'`.  【step2】: Calculate the number of distinct female users in the same state by joining **Customer_Address_History**, **Addresses**, and **Contacts** tables, filtering on `state_province_county = 'Kentucky'` and `gender = 'female'`.  【step3】: Combine the results of the two subqueries via **JOIN** (implicit Cartesian join) and compute the female ratio using `1.0 * n_female / n_total`.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2255,
        "question": "What is the total number of users in the state with Frankfurt as the capital city? What proportion of this total are females?",
        "query": "SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = \"Kentucky\" AND C.gender = \"female\" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = \"Kentucky\" )",
        "step": "【step1】: Retrieve total number of distinct users in Kentucky state by joining Customer_Address_History and Addresses tables, filtering with B.state_province_county = 'Kentucky'.  【step2】: Calculate female users count in Kentucky state by adding Contacts table join with C.gender = 'female' filter while keeping other conditions consistent.  【step3】: Cross-join the two aggregated results (total & female counts) and compute female ratio via 1.0 * n_female / n_total in the final SELECT projection.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 2,
        "idx": 2256,
        "question": "What are the ID, name, and sales volume of the product that has the highest sales volume, and how much higher is it compared to the product with the lowest sales volume?",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "step": "【step1】: Generate a dataset including all products with their total sales volume (sum of order_quantity) and products without orders (assigned 0 sales) using a UNION between grouped Order_Items and unlisted Products.  【step2】: Calculate the difference between the maximum and minimum sales volumes using the same UNION-derived dataset from Step 1 via a nested subquery.  【step3】: Join the aggregated product data (Step 1) with the precomputed sales difference (Step 2), then filter to return the product row with the MAX(quantity) alongside the global difference value.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 2,
        "idx": 2257,
        "question": "Find me the product ID and name with the highest volume of sales, and tell me its sales volumne, and how much higher this volume is than the product with the lowest sales volume?",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "step": "【step1】: Generate sales data for all products (including those with zero sales by using UNION to combine actual sales from Order_Items and zero entries for unsold products from Products).  【step2】: Calculate the difference between maximum and minimum sales volumes (MAX(quantity) - MIN(quantity)) using the dataset created in Step 1.  【step3】: Join the sales data (Step1) with the calculated difference (Step2), then select the product with MAX(quantity) to output its ID, name, sales volume, and the volume difference.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2258,
        "question": "What are the ID and name of product that has the highest sales volume? If its sales volume was increased by 500, what is its sales volume and how much higher is it compared to the product with the lowest sales volume?",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "step": "【step1】: Calculate sales volume for all products (including products with 0 sales via UNION) by joining Order_Items and Products, grouping by product_id and product_name.  【step2】: Compute the difference between max and min sales volumes (diff) from the same aggregated dataset generated in step1.  【step3】: Combine results from step1 and step2 via JOIN, then project product_id, product_name, max sales+500, and diff+500 using GROUP BY on product attributes and precomputed diff.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2259,
        "question": "Find me the ID and name of the product with the highest sales volume. What would its sales volume be if it increased by 500, and how much higher would its sale volume be , relative to the product with lowest sale?",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "step": "【step1】: Generate a temporary table (t1) containing all products, combining those with sales data (summing order_quantity) and those without sales (quantity set to 0) using UNION.  【step2】: Calculate the difference (diff) between the highest and lowest sales volumes from the same temporary dataset (t1) via subquery t2.  【step3】: Select the product with the highest sales volume from t1, add 500 to its quantity, and append the pre-computed diff value (also incremented by 500) from t2 via a cross join.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2260,
        "question": "A 5% service charge is required for credit card payments. List the name of each customer and how much each customer spent on each order along with the order id.",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "step": "【step1】: Calculate order costs with 5% fee for credit card users by joining Customers, Customer_Orders, Order_Items, and Products tables. Apply (quantity × price) × 1.05 formula and filter via WHERE payment_method_code='Credit Card'.  【step2】: Calculate regular order costs (without fee) for non-credit-card users using the same tables but with WHERE payment_method_code≠'Credit Card'.  【step3】: Combine both results using UNION to display all customers' order costs with appropriate fee logic based on payment method.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2261,
        "question": "Tell me the name of each customer and how much each customer spent on each order along with the order id, if a 5% service charge is required for all credit card payments.",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "step": "【step1】: Join Customers, Customer_Orders, Order_Items, and Products tables. Calculate order costs with 5% service fee for credit card payments, grouping by customer_name and order_id.  【step2】: Repeat the join but exclude credit card payments, calculating raw order costs without service fee, grouping by customer_name and order_id.  【step3】: Combine both result sets using UNION to display credit card orders with fees and non-credit-card orders without fees in final output.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2262,
        "question": "A 5% service charge is required for credit card payments. If the unit price of each product is 99, list the name of each customer and how much each customer spent on each order along with the order id.",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "step": "【step1】: Calculate credit card orders with 5% service charge by joining relevant tables (Customers, Customer_Orders, Order_Items) and applying formula (quantity*99)*1.05. Filter using payment_method_code='Credit Card' and group by customer+order.  【step2】: Calculate non-credit card orders with base price using same table joins but exclude credit card payments, applying formula (quantity*99).  【step3】: Combine both credit card and non-credit card results using UNION to produce final unified output.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 4,
        "idx": 2263,
        "question": "Tell me the name of each customer and how much each customer spent on each order along with the order id, given that the unit price of all products is 99 and we charge a 5% fee for credit card payments.",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "step": "【step1】: Retrieve credit card orders: Join Customers, Customer_Orders, Order_Items, and Products tables. Calculate total cost with 5% fee using (order_quantity * 99 * 1.05). Filter by credit card payments and group by customer_name + order_id.  【step2】: Retrieve non-credit card orders: Repeat joins but filter out credit card payments. Calculate cost without fee using (order_quantity * 99), group by customer_name + order_id.  【step3】: Combine results using UNION to merge credit/non-credit order data into final output with consistent column structure.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2264,
        "question": "List the year in record and the annual sales revenue for each year.",
        "query": "SELECT strftime ( \"%Y\" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( \"%Y\" , A.order_date )",
        "step": "【step1】: Join tables Customer_Orders (A), Order_Items (B), and Products (C) via order_id and product_id to link order details with product prices.  【step2】: Calculate sales revenue per transaction by multiplying B.order_quantity by C.product_price.  【step3】: Group results by YEAR(A.order_date) and sum the per-transaction revenue to derive annual_sales_revenue.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2265,
        "question": "Tell me the year in record and corresponding annual sales revenue.",
        "query": "SELECT strftime ( \"%Y\" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( \"%Y\" , A.order_date )",
        "step": "【step1】: Join the Customer_Orders, Order_Items, and Products tables using order_id and product_id to link relevant data.  【step2】: Calculate the sales revenue for each individual order item by multiplying order_quantity (B) with product_price (C).  【step3】: Group the results by year derived from order_date (A) using YEAR() function, then sum all item revenues per year as annual_sales_revenue.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2266,
        "question": "List the highest price, lowest price, and variance of Apple products.",
        "query": "SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = \"Apple\" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = \"Apple\" )",
        "step": "【step1】: Calculate the average price (avg_price) and total count (cnt) of Apple products via a subquery.  【step2】: Compute variance for each Apple product using **(product_price - avg_price)² / cnt** by cross-joining with the avg/cnt subquery, then extract max_price and min_price in a separate subquery.  【step3】: Join the variance results (aggregated implicitly) with the max/min prices to output the final columns.",
        "format": "MySQL"
    },
    {
        "db_id": "contract",
        "type": 3,
        "idx": 2267,
        "question": "Considering only Apple products tell me the highest and lowest prices and also the variance across the Apple range.",
        "query": "SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = \"Apple\" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = \"Apple\" )",
        "step": "【step1】: Calculate the average price of Apple products using window function AVG(product_price) OVER() in subquery t1, filtering by product_name = 'Apple'.  【step2】: Compute price variance using SUM(POW(product_price - avg_price, 2)) / COUNT(*) on t1's results (variance_subquery).  【step3】: Fetch max/min prices via price_subquery and CROSS JOIN with variance_subquery to combine all metrics in final output.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2268,
        "question": "List the name and age of each singer at the time of the release of the song \"Gentleman\".",
        "query": "SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Gentleman\" ) - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "step": "【step1】: Retrieve the song release year of \"Gentleman\" using a subquery: `(SELECT Song_release_year FROM singer WHERE Song_Name = 'Gentleman')`.  【step2】: Calculate the target age by adjusting the singer's current age based on the difference between the song's release year and the current year: `Age + (retrieved_release_year - YEAR(CURDATE()))`.  【step3】: Combine the results by selecting the `Name` and the calculated `target_age` for all singers in the table.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2269,
        "question": "What were the names and ages of all singers of the release of the song \"Gentleman\"",
        "query": "SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Gentleman\" ) - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "step": "【step1】: Retrieve the song release year of \"Gentleman\" using a subquery: `(SELECT Song_release_year FROM singer WHERE Song_Name = \"Gentleman\")`.  【step2】: Calculate the adjusted age for each singer by adding their current age to the difference between the song's release year and the current year: `Age + (subquery_result) - YEAR(CURDATE())`.  【step3】: Return the names and calculated ages (at the time of the song's release) for all singers in the table, regardless of their association with \"Gentleman\" (no explicit filtering is applied).",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2270,
        "question": "If the song \"Gentleman\" was released in the first year of the 21st century, list the name and age of each singer at the time of the song's release.",
        "query": "SELECT Name , Age + 2001 - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "step": "【step1】: Retrieve the current age of each singer from the singer table.  【step2】: Adjust the age by calculating the difference between 2001 (the assumed release year of \"Gentleman\") and the current year, then add this difference to the current age to derive the singer's age at the time of the song's release.  【step3】: Display the singer's name and the calculated target_age.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2271,
        "question": "Assuming that the song \"Gentleman\" was released in the first year of the 21st century, what were the names and ages of all its singers at the time of its release?",
        "query": "SELECT Name , Age + 2001 - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "step": "【step1】: Retrieve the \"Name\" and current \"Age\" of all singers from the \"singer\" table.  【step2】: Adjust the ages to reflect the year 2001 by calculating the time difference between the current year (via `YEAR(CURRENT_DATE())`) and 2001, then applying this offset to the current age using `Age + 2001 - YEAR(CURRENT_DATE())`, aliased as \"target_age\".  【step3】: Finalize the output to show the singers' names and their calculated ages during the release year of \"Gentleman\".",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2272,
        "question": "What are the names and ages of the participating singers in the concert with the theme of \"Free choice\" at that time?",
        "query": "SELECT C.Name , C.Age + ( A.Year - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\"",
        "step": "【step1】: Filter the 'concert' table to find the concert with the theme \"Free choice\" and retrieve its concert_ID.  【step2】: Join 'singer_in_concert' with the filtered concert results to get the Singer_IDs participating in the concert.  【step3】: Join the 'singer' table to fetch names and calculate adjusted ages (Age + (concert year - current year)) for the singers.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2273,
        "question": "What were the names and ages of all singers who participated in the \"Free Choice\" themed concert at the time of the concert?",
        "query": "SELECT C.Name , C.Age + ( A.Year - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\"",
        "step": "【step1】: Join the `concert` (A) and `singer_in_concert` (B) tables using `concert_ID` to identify singers associated with the \"Free choice\" concert.  【step2】: Join the result with the `singer` (C) table via `Singer_ID` to retrieve singer names and current ages.  【step3】: Calculate each singer’s age at the concert by adjusting their current age (`C.Age`) using the difference between the concert year (`A.Year`) and the current year.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2274,
        "question": "If all singers born before 1985 participated in the \"Free Choice\" themed concert, what are the names and ages of the participating singers in the concert with the theme of \"Free choice\" at that time?",
        "query": "SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = \"Free choice\" ) - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\" OR strftime ( \"%Y\" , \"now\" ) - C.Age < 1985 GROUP BY C.Name",
        "step": "【step1】: Join the `concert`, `singer_in_concert`, and `singer` tables to link singers with concerts, using `concert_ID` and `Singer_ID` as connection keys.  【step2】: Filter records where the concert theme is \"Free choice\" **OR** the singer’s birth year (derived via `YEAR(CURDATE()) - Age`) is before 1985, introducing a logical inconsistency with the original problem’s requirement.  【step3】: Calculate the singer’s age at the concert using a subquery to fetch the concert year and adjust the age dynamically, then group results by singer name to eliminate duplicates.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2275,
        "question": "Assuming that all the singers born before 1985 participated in the \"Free Choice\" themed concert, what were the names and ages of all the singers who took part at the time of the concert?",
        "query": "SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = \"Free choice\" ) - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\" OR strftime ( \"%Y\" , \"now\" ) - C.Age < 1985 GROUP BY C.Name",
        "step": "【step1】: Retrieve the concert year for the 'Free choice' theme using a subquery, then calculate each singer's birth year by subtracting their current age from the current year.  【step2】: Join singer, singer_in_concert, and concert tables to link singers with the concert, applying the condition that either the theme matches 'Free choice' or the calculated birth year is before 1985.  【step3】: Compute the age at the concert by adding the difference between the concert year and the current year to the singer's current age, then group results by name to eliminate duplicates.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2276,
        "question": "How many years has it been since the earliest concert?",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM concert",
        "step": "【step1】: Retrieve the earliest concert year using MIN(Year) from the concert table.  【step2】: Calculate the current year using YEAR(NOW()).  【step3】: Subtract the earliest year from the current year and alias the result as \"years\".",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2277,
        "question": "How many years ago did the first concert occur?",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM concert",
        "step": "【step1】: Retrieve the current year using YEAR(NOW()).  【step2】: Determine the earliest year from the \"Year\" column in the \"concert\" table using MIN(Year).  【step3】: Calculate the difference between the current year and the earliest year, and alias the result as \"years\".",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2278,
        "question": "If the \"Wide Awake\" themed concert was held three years earlier, how many years has it been since the earliest concert?",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = \"Wide Awake\" UNION ALL SELECT Year FROM concert WHERE Theme != \"Wide Awake\" )",
        "step": "【step1】Adjust the year of the \"Wide Awake\" concert by subtracting 3, creating a temporary column Year.  【step2】Combine the adjusted year with non-\"Wide Awake\" concert years using UNION ALL in a subquery.  【step3】Calculate the difference between the current year and the earliest year (MIN(Year)) from the combined results.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2279,
        "question": "How many years ago did the earliest concert occur if the concert with the theme \"Wide Awake\" took place three years earlier?",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = \"Wide Awake\" UNION ALL SELECT Year FROM concert WHERE Theme != \"Wide Awake\" )",
        "step": "【step1】: Adjust the year for concerts with the theme \"Wide Awake\" by subtracting 3 years.  【step2】: Combine this adjusted dataset with unmodified years from other concerts using UNION ALL.  【step3】: Calculate the difference between the current year and the minimum year in the merged dataset to determine how many years ago the earliest concert occurred.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2280,
        "question": "What are the names of the singer participating in the \"Home Visits\" concert, and how old will they be on its 20th anniversary?",
        "query": "SELECT C.Name , A.Year - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\"",
        "step": "【step1】: Join concert, singer_in_concert, and singer tables to link singer details with the \"Home Visits\" concert.  【step2】: Filter the joined data to retain only records where the concert name is \"Home Visits\".  【step3】: Calculate each singer's age on the 20th anniversary by adding their current age to the time difference between the concert year and the target anniversary year (current age + (concert year + 20 - current year)).",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2281,
        "question": "What are the names of the \"Home Visits\" concert singer, and how old will they be on its 20th anniversary?",
        "query": "SELECT C.Name , A.Year - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\"",
        "step": "【step1】: Join the `concert` table with `singer_in_concert` using `concert_ID` to map the concert to participating singers.  【step2】: Join the result with the `singer` table using `Singer_ID` to retrieve singer names and ages.  【step3】: Filter records where `concert_Name` is \"Home Visits\" and calculate the target age by adjusting the singer’s current age with the 20-year difference between the concert’s year and its 20th anniversary.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2282,
        "question": "If all the singers who participated in concerts held in Stark Park also participated in the \"Home Visits\" concert, what are the names of the singer participating in the \"Home Visits\" concert, and how old will they be on its 20th anniversary?",
        "query": "SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = \"Home Visits\" ) - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = \"Stark's Park\" ) GROUP BY B.Singer_ID",
        "step": "【step1】: Retrieve all Singer_IDs who performed in concerts held at 'Stark''s Park' by joining concert, stadium, and singer_in_concert tables.  【step2】: Combine singers from 'Home Visits' concert and the Singer_IDs from Step 1 via an OR condition, then deduplicate using GROUP BY.  【step3】: Calculate the target_age for each singer by extracting the year of the 'Home Visits' concert and adjusting for the 20th anniversary offset.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2283,
        "question": "What will be the ages and names of the \"Home Visits\" concert singers on its 20th anniversary, if all the singers who performed at concerts in Stark Park also took part in it?",
        "query": "SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = \"Home Visits\" ) - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = \"Stark's Park\" ) GROUP BY B.Singer_ID",
        "step": "【step1】: Join the concert, singer_in_concert, and singer tables to retrieve singers associated with the \"Home Visits\" concert or those who performed at Stark's Park.  【step2】: Calculate the target age using the formula: `(Home Visits concert year - current year + singer's current age + 20)`, and filter singers via a subquery checking Stark's Park participation.  【step3】: Group results by Singer_ID to eliminate duplicates, ensuring each singer appears once with their name and calculated age.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2284,
        "question": "When all tickets sold out, how much money can be made from ticket sales at the Balmoor stadium with a ticket price of 20 dollars and the Hampden Park stadium with a ticket price of 5.5 dollars?",
        "query": "SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = \"Hampden Park\" ) AS total FROM stadium WHERE Name = \"Balmoor\"",
        "step": "【step1】: Retrieve the capacity of 'Balmoor' stadium and calculate its total revenue by multiplying capacity with $20.  【step2】: Execute a subquery to fetch the capacity of 'Hampden Park' stadium and compute its total revenue using $5.5 per ticket.  【step3】: Sum the revenue from both stadiums and output the combined total under the alias \"total\".",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2285,
        "question": "If the ticket price for Balmoor stadium is $20 and for Hampden Park stadium is $5.5, and all tickets are sold out, how much money can be generated from ticket sales?",
        "query": "SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = \"Hampden Park\" ) AS total FROM stadium WHERE Name = \"Balmoor\"",
        "step": "【step1】: Calculate ticket sales for 'Balmoor' stadium by multiplying its capacity by $20.  【step2】: Calculate ticket sales for 'Hampden Park' stadium via a subquery, multiplying its capacity by $5.5.  【step3】: Combine the two results using the `+` operator to produce the total revenue from both stadiums.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2286,
        "question": "If the capacity of the Hampden Park stadium is twice that of the Balmoor stadium, when all tickets sold out, how much money can be made from ticket sales at the Balmoor stadium with a ticket price of 20 dollars and the Hampden Park stadium with a ticket price of 5.5 dollars?",
        "query": "SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = \"Balmoor\"",
        "step": "【step1】: Retrieve the capacity of Balmoor stadium from the database table using the WHERE clause to filter by Name = 'Balmoor'.  【step2】: Calculate Balmoor's ticket revenue by multiplying its capacity by $20, and compute Hampden Park's revenue using twice Balmoor's capacity (as per the capacity relationship) multiplied by $5.5.  【step3】: Sum the calculated revenues from both stadiums and output the total using the arithmetic expression in the SELECT statement.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2287,
        "question": "Assuming the ticket price for Balmoor stadium is $20 and for Hampden Park stadium is $5.5, and if the Hampden Park stadium has twice the capacity of the Balmoor stadium, what would be the total revenue generated from ticket sales if all tickets are sold out at both stadiums?",
        "query": "SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = \"Balmoor\"",
        "step": "【step1】: Retrieve the capacity of Balmoor stadium from the 'stadium' table.  【step2】: Calculate Balmoor's revenue by multiplying its capacity by $20.  【step3】: Calculate Hampden Park's revenue (using twice Balmoor's capacity multiplied by $5.5) and sum both revenues to get the total.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2288,
        "question": "Singers born before 1980 earn $355 per concert, while singers born after 1980 earn $228 per concert. How much was spent on paying the singers for the concerts held in Somerset Park stadium?",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age >= 1980 )",
        "step": "【step1】: Calculate the total payment for singers born before 1980 by joining the concert, singer_in_concert, singer, and stadium tables, filtering for 'Somerset Park' stadium and checking if YEAR(CURDATE()) - Age < 1980. Multiply the count of qualifying records by $355.  【step2】: Calculate the total payment for singers born in or after 1980 using the same table joins and stadium filter, but with YEAR(CURDATE()) - Age >= 1980. Multiply the count by $228.  【step3】: Combine the results of the two subqueries via a CROSS JOIN and sum the two calculated values (p1 + p2) to produce the final total cost.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2289,
        "question": "What was the total expenditure on paying singers for concerts held at Somerset Park stadium, given that singers born before 1980 earned $355 per concert and those born after 1980 earned $228 per concert?",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age >= 1980 )",
        "step": "【step1】: Join tables concert, singer_in_concert, singer, and stadium to filter concerts held at \"Somerset Park\".  【step2】: Calculate costs separately for singers born before 1980 (355 * count) and after 1980 (228 * count) using YEAR(NOW()) - Age to derive birth year.  【step3】: Combine the two calculated costs via CROSS JOIN and sum them to get the total expenditure.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2290,
        "question": "Singers born before 1980 earn $355 per concert, while singers born after 1980 earn $228 per concert. If Justin Brown is 3 years older than John Nizinik, how much was spent on paying the singers for the concerts held in Somerset Park stadium?",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year >= 1980 )",
        "step": "【step1】: Calculate birth years for all singers. Handle Justin Brown's special case by deriving his birth year based on John Nizinik's age (John's birth year = current year - John's age, Justin's birth year = John's birth year - 3). Use UNION ALL to combine regular singers and Justin's adjusted data.  【step2】: Compute payment for pre-1980 singers (p1) by joining concert/stadium data, filtering to \"Somerset Park\" stadium, counting eligible concert appearances, and multiplying by $355.  【step3】: Repeat calculation for post-1980 singers (p2) with $228 rate. Sum p1 and p2 in the final SELECT to get total cost.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2291,
        "question": "If Justin Brown was 3 years older than John Nizinik, what was the total expenditure on paying singers for concerts held at Somerset Park stadium, given that singers born before 1980 earned $355 per concert and those born after 1980 earned $228 per concert?",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year >= 1980 )",
        "step": "【step1】: Calculate adjusted birth years for singers. For all singers except Justin Brown, use current year minus age. For Justin Brown, derive birth year by subtracting 3 from John Nizinik's calculated birth year (YEAR(CURDATE()) - John's Age - 3).  【step2】: Calculate pre-1980 costs ($355/concert). Count eligible singers (birth_year < 1980) linked to Somerset Park concerts, multiply by 355. Simultaneously calculate post-1980 costs ($228/concert) using same linkage but birth_year >= 1980.  【step3】: Combine both cost components (pre-1980 total + post-1980 total) through JOIN operations between the two subqueries to output final expenditure.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2292,
        "question": "Which stadiums have the lowest and highest average attendance rates respectively, and how many concerts have they each held?",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "step": "【step1】: Retrieve the stadium name with the highest average attendance rate by calculating `100.0 * Average / Capacity`, sorting in descending order, and limiting to 1 result.  【step2】: Retrieve the stadium name with the lowest average attendance rate using the same formula but sorting in ascending order, and count concerts for both stadiums by matching their IDs via nested subqueries.  【step3】: Combine the highest/lowest stadium names and their corresponding concert counts using `CROSS JOIN` to merge all subquery results into a single output.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2293,
        "question": "What are the names of the stadiums with the highest and lowest average attendance rates, and how many concerts have been held in each of them?",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "step": "【step1】: Extract the stadium name with the highest average attendance rate by grouping and sorting stadiums in descending order of (Average/Capacity)*100.  【step2】: Calculate the concert count for the highest-attendance stadium by joining with the concert table using its Stadium_ID obtained via a nested subquery.  【step3】: Repeat steps 1-2 for the lowest-attendance stadium, then combine all results using CROSS JOIN to display all values in a single row.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2294,
        "question": "Suppose Gayfield Park stadium had a tenth of the capacity of Hampden Park stadium, which stadiums have the lowest and highest average attendance rates respectively, and how many concerts have they each held?",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "step": "【step1】: Create a modified dataset by adjusting Gayfield Park's capacity (set to 1/10 of Hampden Park's capacity) via subquery and UNION ALL with other stadiums' original data.  【step2】: Calculate attendance rates (Average/Capacity) to determine the highest (DESC LIMIT 1) and lowest (ASC LIMIT 1) stadiums from the modified dataset.  【step3】: Count concerts for the identified highest/lowest stadiums by joining the `stadium` and `concert` tables, using nested subqueries to re-fetch their Stadium_IDs.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2295,
        "question": "What are the names of the stadiums with the highest and lowest average attendance rates, if Gayfield Park stadium has one-tenth the capacity of Hampden Park stadium, and how many concerts have been held in each of them?",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "step": "【step1】: Adjust Gayfield Park's capacity to 1/10 of Hampden Park's and create a unified dataset with all stadiums.  【step2】: Calculate attendance rate (Average/Capacity*100) for each stadium, then select the stadium with the highest rate (DESC LIMIT 1) and the lowest rate (ASC LIMIT 1).  【step3】: Count concerts for both selected stadiums by joining the concert table and filtering with their Stadium_IDs from Step 2.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 2,
        "idx": 2296,
        "question": "What are the ID and name of each concert held at Somerset Park stadium, and what percentage of the singers in each of these concert are female singers?",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "step": "【step1】: Calculate the total number of singers (n) per concert at Somerset Park stadium by joining concert, singer_in_concert, singer, and stadium tables, filtered by stadium name and grouped by concert_ID/Name.  【step2】: Calculate female singer counts (n_female) via two subqueries combined with UNION ALL: one counts actual female singers per concert, the other ensures concerts with zero females are included by using NOT IN and explicitly setting n_female=0.  【step3】: Join the results from Step1 (total singers) and Step2 (female counts) on concert_ID, then compute the female_proportion as (n_female / n) * 100.0 for each concert.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 2,
        "idx": 2297,
        "question": "What are the ID and name of each concert held at Somerset Park stadium, and what is the percentage of female singers in each of these concert held at Somerset Park?",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "step": "【step1】: Calculate the number of female singers (n_female) for each Somerset Park concert. If no female singers exist, explicitly set n_female=0 using UNION ALL to ensure concert entries aren't excluded.  【step2】: Calculate the total number of singers (n) for each Somerset Park concert by joining concert, singer_in_concert, singer, and stadium tables with Name='Somerset Park'.  【step3】: Join the results of step1 (t1) and step2 (t2) on concert_ID, then compute female_proportion via (n_female/n)*100 to finalize the percentage output.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2298,
        "question": "If the \"Week 2\" concert was held at Somerset Park stadium, what are the ID and name of each concert held at Somerset Park stadium, and what percentage of the singers in each concert held at Somerset Park stadium are female singers?",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "step": "【step1】: Retrieve concerts held at Somerset Park stadium (including \"Week 2\") and count female singers per concert, handling cases with no female singers via UNION ALL.  【step2】: Calculate total number of singers per concert for the same stadium/criteria.  【step3】: Combine step1 and step2 results via concert_ID, compute female percentage as (n_female/n)*100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2299,
        "question": "What are the ID and name of each concert held at Somerset Park stadium, and what is the percentage of female singers in each concert held at Somerset Park, if the \"Week 2\" concert was held there?",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "step": "【step1】: Extract female singer counts for concerts at Somerset Park or named 'Week 2' using two subqueries: one counting actual female singers (WHERE C.Is_male='F'), another assigning 0 via NOT IN exclusion for concerts with no female singers. Combine results with UNION ALL into temporary table t1.  【step2】: Calculate total singer counts (n) per concert in the same venue/name conditions via subquery t2, joining concert, singer_in_concert, singer, and stadium tables.  【step3】: Join t1 and t2 on concert_ID to compute female_proportion as (n_female / n) * 100.0, ensuring all qualifying concerts (including those with 0 females) are included.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2300,
        "question": "What percentage of the concerts were held in the top three stadiums in terms of average attendance rate?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "step": "【step1】: Identify the top three stadiums based on average attendance rate (calculated as (100.0 * Average) / Capacity) using a subquery with ORDER BY and LIMIT 3.  【step2】: Count the total number of concerts held in these top three stadiums by filtering the concert table with WHERE Stadium_ID IN (subquery result).  【step3】: Calculate the percentage by dividing the count from step 2 by the total number of concerts (via a subquery SELECT COUNT(*) FROM concert) and multiplying by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2301,
        "question": "What is the percentage of concerts that took place in the three stadiums with the highest average attendance rates?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "step": "【step1】: Retrieve the Stadium_IDs of the three stadiums with the highest average attendance rates (calculated as 100.0 * Average / Capacity) from the stadium table, ordered descendingly and limited to 3.  【step2】: Count the number of concerts (COUNT(*)) in the concert table where Stadium_ID matches the three IDs obtained in Step 1.  【step3】: Calculate the percentage by dividing the count from Step 2 by the total number of concerts (subquery: SELECT COUNT(*) FROM concert), then multiply by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2302,
        "question": "If the \"Bleeding Love\" themed concert was held at Glebe Park stadium, what percentage of the concerts were held in the top three stadiums in terms of average attendance rate?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = \"Glebe Park\" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != \"Bleeding Love\" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "step": "【step1】: Identify the top three stadiums based on average attendance rate by calculating (Average / Capacity * 100) for each stadium, sorting in descending order, and limiting to 3 results.  【step2】: Combine two sets of Stadium_IDs: ① the specific \"Glebe Park\" stadium and ② all concerts with themes other than \"Bleeding Love\".  【step3】: Calculate the percentage by counting how many combined Stadium_IDs fall within the top three stadiums, then dividing by the total number of concerts and multiplying by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2303,
        "question": "What percentage of concerts took place in the three stadiums with the highest average attendance rates, assuming that the concert with the theme \"Bleeding Love\" took place at the Glebe Park stadium?",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = \"Glebe Park\" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != \"Bleeding Love\" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "step": "【step1】: Identify the top 3 stadiums by average attendance rate (calculated as \\( \\frac{100.0 \\times \\text{Average}}{\\text{Capacity}} \\)) and retrieve their `Stadium_ID`.  【step2】: Create a derived table combining:  - The `Stadium_ID` of \"Glebe Park\" (regardless of concert theme).  - All concerts with themes other than \"Bleeding Love\" (to align with the assumption that \"Bleeding Love\" only occurs at \"Glebe Park\").  【step3】: Calculate the percentage of concerts in the derived table that occurred in the top 3 stadiums by dividing the matching count by the total concert count and multiplying by 100.0.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 2,
        "idx": 2304,
        "question": "Which stadium has at least three times the number of singers who have sung at the Glebe Park stadium?",
        "query": "SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "step": "【step1】: Calculate the number of distinct singers who performed at the 'Glebe Park' stadium using a subquery: `SELECT COUNT(DISTINCT B.Singer_ID) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = 'Glebe Park'`.  【step2】: Group concerts by stadium and count distinct singers per stadium via `JOIN` operations across the concert, singer_in_concert, and stadium tables.  【step3】: Filter grouped results using `HAVING` to retain only stadiums with singer counts ≥ 3× the subquery result from Step 1.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 2,
        "idx": 2305,
        "question": "Which stadium has had a minimum of three times more singers than Glebe Park does?",
        "query": "SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "step": "【step1】: Retrieve the number of distinct singers at Glebe Park by joining the `concert`, `singer_in_concert`, and `stadium` tables, filtering for stadium name 'Glebe Park'.  【step2】: Calculate the total distinct singers per stadium by joining the same tables and grouping by `Stadium_ID`.  【step3】: Filter stadiums where the singer count is at least three times the value obtained in Step 1 using the `HAVING` clause with a correlated subquery.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2306,
        "question": "If all the singers who have performed at Somerset Park stadium also performed at Balmoor stadium, what is the name of the stadium with at least three times the number of singers who have sung at the Glebe Park stadium?",
        "query": "SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = \"Balmoor\" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Somerset Park\" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "step": "【step1】: Combine all singers from concerts along with their stadium info, and forcibly include singers from \"Somerset Park\" as if they performed at \"Balmoor\" stadium using UNION ALL.  【step2】: Group the combined results by Stadium_ID, count distinct singers per stadium.  【step3】: Filter stadiums where the singer count is ≥3 times the count from \"Glebe Park\", calculated via a nested subquery on its distinct singers.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2307,
        "question": "What is the name of the stadium that has a minimum of three times more singers than Glebe Park if the singers who have performed at Somerset Park also performed at the Balmoor stadium?",
        "query": "SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = \"Balmoor\" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Somerset Park\" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "step": "【step1】: Collect all singer performances from regular concerts and duplicate Somerset Park performances under Balmoor's Stadium_ID by using UNION ALL. This ensures singers who performed at Somerset Park are artificially linked to Balmoor.  【step2】: Group the combined data by Stadium_ID, count distinct singers for each stadium, and calculate Glebe Park's distinct singer count multiplied by 3.  【step3】: Filter stadiums where their singer count meets or exceeds 3× Glebe Park's count using HAVING clause, then return the qualifying stadium names.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2308,
        "question": "What is the name of the stadium that has a highest attendance rate more than twice the highest attendance rate of the Balmoor stadium?",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = \"Balmoor\" )",
        "step": "【step1】: Calculate the attendance rate percentage (100.0 * Highest / Capacity) for the Balmoor stadium.  【step2】: Multiply Balmoor's attendance rate by 2 to establish the threshold.  【step3】: Filter stadiums where their attendance rate exceeds this threshold and return their names.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2309,
        "question": "Which stadium's maximum attendance rate is more than double the Balmoor stadium's highest attendance rate? Give the the stadium names.",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = \"Balmoor\" )",
        "step": "【step1】: Calculate Balmoor's attendance rate: (100.0 * Highest / Capacity)  【step2】: Multiply Balmoor's rate by 2 to get the threshold.  【step3】: Compare each stadium's attendance rate against the threshold and return qualifying names.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2310,
        "question": "If the capacity of the Balmoor stadium is 5600, what is the name of the stadium that has a highest attendance rate more than twice the highest attendance rate of the Balmoor stadium?",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = \"Balmoor\" )",
        "step": "【step1】: Calculate Balmoor's highest attendance rate using the subquery: `100.0 * Highest / 5600` where Name is 'Balmoor'.  【step2】: Double the result from Step 1 to determine the threshold attendance rate (`2 * subquery_result`).  【step3】: Select stadium names where the calculated attendance rate (`100.0 * Highest / Capacity`) exceeds the threshold from Step 2.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2311,
        "question": "Which stadium's maximum attendance rate is more than double the Balmoor stadium's highest attendance rate, given its capacity of 5600? List the stadium names.",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = \"Balmoor\" )",
        "step": "【step1】: Calculate Balmoor stadium's highest attendance rate by dividing its \"Highest\" attendance value by its capacity (5600) and multiplying by 100.  【step2】: Multiply Balmoor's attendance rate by 2 to create the threshold.  【step3】: Compare every stadium's attendance rate (100.0 * Highest / Capacity) against this threshold and return qualifying names.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 2,
        "idx": 2312,
        "question": "What are the IDs and names of the concerts held after 2012 and has more singers than the \"Happy Tonight\" themed concert, and how many times is it?",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" )",
        "step": "【step1】: Filter concerts held after 2012 and join with singer records.  【step2】: Calculate the number of singers in the \"Happy Tonight\" concert via subquery as the comparison baseline.  【step3】: Group filtered concerts, apply HAVING clause to keep those with more singers than the baseline, and compute the ratio using the baseline subquery.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 2,
        "idx": 2313,
        "question": "What are the ID and name of the post-2012 concert features more singers than the \"Happy Tonight\" themed concert, what is the ratio of the number of singers in both concerts?",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" )",
        "step": "【step1】: Filter concerts after 2012 and join with singers. The base dataset is formed by combining `concert` (aliased as A) and `singer_in_concert` (aliased as B) tables via `concert_ID`, with `A.Year > 2012` as the initial filter.  【step2】: Group by concert ID/name, calculate singer counts. For each qualifying concert, count distinct singers. Use a correlated subquery in HAVING to enforce that this count exceeds the singer count of the \"Happy Tonight\" concert (subquery reuses same join logic but filters by theme).  【step3】: Compute the ratio. Add a scalar subquery in the SELECT clause to calculate the \"Happy Tonight\" singer count once, then divide the current concert's singer count by this value (cast to float via 1.0*) to derive the `times` ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2314,
        "question": "If singer Joe Sharp performed in every concert, what are the IDs and names of concerts held after 2012 has more singers than the \"Happy Tonight\" themed concert, and and how many times is it?",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) )",
        "step": "【step1】: Filter concerts held after 2012 and exclude Joe Sharp's records, joining concert and singer_in_concert tables. Group by concert_ID and concert_Name to count distinct singers (excluding Joe).  【step2】: Calculate the baseline singer count plus 1 (excluding Joe) for the \"Happy Tonight\" concert via a subquery, used as the denominator for comparison.  【step3】: Compare each concert's adjusted singer count (COUNT + 1) against the baseline in HAVING, then compute the ratio (current count +1)/(baseline count +1) as times in SELECT.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2315,
        "question": "Assuming that Joe Sharp performed in all concerts, what are the ID and name of post-2012 concert features more singers than the \"Happy Tonight\" themed concert, and what is the ratio of the number of singers in both concerts?",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) )",
        "step": "【step1】: Filter concerts after 2012, exclude Joe Sharp's participation record, and join with singer_in_concert to get singer data. Use subqueries to:  1. Find Joe Sharp's Singer_ID  2. Exclude him via B.Singer_ID != (subquery)  3. Apply A.Year > 2012 condition.  【step2】: Group by concert_ID and calculate singer count (plus 1 for Joe's assumed participation). Use HAVING to compare against the \"Happy Tonight\" concert's singer count (similarly calculated via subquery that excludes Joe).  【step3】: Compute the ratio 1.0*(current_concert_singer_count+1)/(Happy_Tonight_singer_count+1) via scalar subquery in the SELECT clause, ensuring consistent exclusion of Joe Sharp in both numerator and denominator calculations.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2316,
        "question": "At the time of the release of the song \"Love,\" what are the names of singers who were more than twice as old as the singer of the song?",
        "query": "SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Love\" ) - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - Song_release_year ) FROM singer WHERE Song_Name = \"Love\" )",
        "step": "【step1】: Determine the release year of the song \"Love\" and calculate the age of its singer at that time using subqueries.  【step2】: Compute each singer's age during the release year of \"Love\" by subtracting their birth year (derived from current year minus age) from the song's release year.  【step3】: Filter singers where their computed age during the release year is more than twice the original singer's age at that time.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 3,
        "idx": 2317,
        "question": "Which singers, at the time when \"Love\" was released, had an age more than double that of the singer who performed the song? List their names.",
        "query": "SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Love\" ) - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - Song_release_year ) FROM singer WHERE Song_Name = \"Love\" )",
        "step": "【step1】: Retrieve the release year of the song \"Love\" and calculate the age of its performer **at the time of release** using subqueries: `(Song_release_year - (YEAR(CURDATE()) - Age))`.  【step2】: Calculate each singer's age **at the time of \"Love\" release** by comparing their birth year (`YEAR(CURDATE()) - Age`) to the song’s release year.  【step3】: Filter singers whose calculated age (from step 2) exceeds double the performer’s age (from step 1) using the inequality in the `WHERE` clause.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2318,
        "question": "If \"Love\" was released in 2010, at the time of the release of the song \"Love,\" what are the names of singers who were more than twice as old as the singer of the song?",
        "query": "SELECT Name FROM singer WHERE 2010 - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - 2010 ) FROM singer WHERE Song_Name = \"Love\" )",
        "step": "【step1】: Retrieve the singer's age of the song \"Love\" at the time of its 2010 release using the subquery: `Age - (YEAR(CURDATE()) - 2010)` to adjust their current age to their age in 2010.  【step2】: Calculate each singer's age in 2010 via `2010 - (YEAR(CURDATE()) - Age)`, which derives their birth year from the current age and subtracts it from 2010.  【step3】: Filter singers whose 2010 age (step2) exceeds twice the \"Love\" singer's 2010 age (step1) using the condition `> 2 * (subquery)`.",
        "format": "MySQL"
    },
    {
        "db_id": "concert",
        "type": 4,
        "idx": 2319,
        "question": "Assuming \"Love\" was released in 2010, which singers, at that time, had an age that was more than twice the age of the singer who performed the song? List their names.",
        "query": "SELECT Name FROM singer WHERE 2010 - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - 2010 ) FROM singer WHERE Song_Name = \"Love\" )",
        "step": "【step1】: Extract the base age of the singer who performed \"Love\" in 2010 using a subquery: Calculate their age at that time by adjusting their current age with the difference between the current year and 2010.  【step2】: Compute each singer's birth year by subtracting their current age from the current year, then derive their age in 2010 as `2010 - (birth year)`.  【step3】: Filter singers whose 2010 age (from Step 2) exceeds twice the base age (from Step 1) and return their names.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2320,
        "question": "Which continent is the country with the highest GNP per capita located in?",
        "query": "SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "step": "【step1】: Calculate the per capita GNP for each country by dividing GNP by Population (using 1.0 to ensure floating-point division).  【step2】: Sort all countries in descending order based on the calculated per capita GNP.  【step3】: Select the Continent value from the top-ranked row (highest per capita GNP) using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2321,
        "question": "In which continent can we find the country with the highest GNP per capita?",
        "query": "SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "step": "【step1】: Calculate the GNP per capita (GNP / Population) for each country.  【step2】: Order the results in descending order based on the calculated GNP per capita.  【step3】: Select the continent of the top-ranked country using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2322,
        "question": "If the gross national product of the country where Korla City is located is 1982268.0, which continent is the country with the highest GNP per capita located in?",
        "query": "SELECT Continent FROM (SELECT \"1982268.0\" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "step": "【step1】: Locate the country containing Korla City by joining the country and city tables, retrieving the country's name.  【step2】: Create a combined dataset via UNION ALL: one subset forces GNP=1982268.0 for Korla's country (using CAST), while the other retains original GNP values for all other countries, both including Population and Continent.  【step3】: Calculate GNP per capita (GNP/Population) for all entries in the combined dataset, then sort descendingly and select the Continent from the top-ranked row.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2323,
        "question": "In which continent can we find the country with the highest GNP per capita, if the GNP of the country containing Korla City is 1982268?",
        "query": "SELECT Continent FROM (SELECT \"1982268.0\" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "step": "【step1】: Identify the country containing Korla City by joining the `country` and `city` tables, then select its **name**, **Continent**, and **Population** while overriding its GNP with the fixed value `1982268.0`.  【step2】: Combine this overridden GNP record with GNP data from **all other countries** (excluding the one containing Korla City) using `UNION ALL`.  【step3】: Calculate GNP per capita (`GNP/Population`) for all entries in the combined dataset, sort in descending order, and select the **Continent** of the top-ranked entry.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2324,
        "question": "Among the countries that became independent after 1979, which country has the highest growth rate of GNP?",
        "query": "SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Filter countries that gained independence after 1979 using **WHERE IndepYear > 1979**.  【step2】: Calculate the GNP growth rate as **(GNP - GNPOld) / GNPOld** and sort results in descending order by this value.  【step3】: Select the top-ranked country with **LIMIT 1** to return the highest growth rate entry.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2325,
        "question": "Which country, among those that gained independence after 1979, has the highest gross national product growth rate?",
        "query": "SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Filter countries that gained independence after 1979 using `WHERE IndepYear > 1979`.  【step2】: Calculate the GNP growth rate as `1.0 * (GNP - GNPOld) / GNPOld` and sort the results in descending order.  【step3】: Select the top-ranked country with `LIMIT 1` to get the highest growth rate.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2326,
        "question": "Among the countries that became independent after 1979, which country has the highest growth rate in GNP if all countries in Oceania have an increase in curretn GNP of 1,000,000?",
        "query": "SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = \"Oceania\" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != \"Oceania\" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Create a derived table containing all countries, with GNP increased by 1,000,000 for Oceania countries while keeping other continents' GNP unchanged through UNION ALL.  【step2】: Filter countries that gained independence after 1979 (IndepYear > 1979) from the derived table.  【step3】: Calculate growth rate using (GNP - GNPOld)/GNPOld, sort results in descending order, and select the top entry with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2327,
        "question": "Assuming all countries in Oceania have an increase of 1,000,000 in their current GNP, which country among those that gained independence after 1979 has the highest gross national product growth rate?",
        "query": "SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = \"Oceania\" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != \"Oceania\" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Create a temporary dataset combining all countries. For Oceania countries, increase GNP by 1,000,000 using UNION ALL to merge adjusted Oceania data with unmodified non-Oceania data.  【step2】: Filter the combined dataset to retain only countries with IndepYear > 1979.  【step3】: Calculate growth rate (GNP - GNPOld)/GNPOld for qualified entries, sort descendingly by this rate, and select the top result with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2328,
        "question": "Which country where the majority of people speak English has the highest population density, how many times larger than the country with the lowest population density?",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "step": "【step1】: Identify countries where English is the majority language by joining `countrylanguage` with a subquery that groups countries by their maximum spoken language percentage.  【step2】: Calculate the minimum population density (population/surface area) globally from the `country` table, ensuring the value is positive to avoid division issues.  【step3】: Compute the population density ratio for English-majority countries relative to the minimum density, then sort and limit to show the country with the highest ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2329,
        "question": "Among the countries in which English is the most spoken language, which country has the highest population density? What is the ratio between the highest and lowest population density?",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "step": "【step1】: Identify countries where English is the primary language by selecting **CountryCode** from **countrylanguage** where **Language**='English' and grouped by **CountryCode** with the highest **Percentage**.  【step2】: Calculate population density (Population/SurfaceArea *100) for all countries in **country** and determine the global minimum non-zero population density using a subquery.  【step3】: Filter countries from step1, compute the ratio of their population density against the global minimum, then sort by density descending to return the country with the highest density and its ratio.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2330,
        "question": "If no one in Ireland speaks English, which country where the majority of people speak English has the highest population density, how many times larger than the country with the lowest population density?",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != \"Ireland\" GROUP BY A.CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "step": "【step1】: Filter countries where the primary language is English (excluding Ireland) using a subquery with ROW_NUMBER() to identify the top language per country by percentage.  【step2】: Calculate population density (Population/SurfaceArea) for these filtered countries, and simultaneously find the minimum non-zero population density globally via a subquery.  【step3】: Compute the density ratio (selected country's density ÷ minimum density), then return the country with the highest density and its multiple compared to the lowest density.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2331,
        "question": "If English is not spoken in Ireland, which country among those in which English is the most spoken language has the highest population density? What is the ratio between the highest and lowest population density?",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != \"Ireland\" GROUP BY A.CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "step": "【step1】: Filter countries where the primary language is English and exclude Ireland. Use a subquery with ROW_NUMBER() to identify the most spoken language per country (PARTITION BY CountryCode ORDER BY Percentage DESC), retaining only rows where rn=1 and Language='English'.  【step2】: Calculate population density (Population/SurfaceArea *100) for these filtered countries. In parallel, compute the minimum non-zero population density globally via a subquery (SELECT MIN(...) FROM country).  【step3】: Divide the highest density by the minimum density to get the ratio (times), then return the country name and ratio sorted by density descending, limited to the top result.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2332,
        "question": "In countries where Arabic is not the official language, which country has the largest increase rate in GNP?",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Filter countries where Arabic is not the official language using a subquery to exclude countries with 'Arabic' as an official language in the countrylanguage table.  【step2】: Calculate the GNP growth rate percentage for remaining countries using the formula ((GNP - GNPOld)/GNPOld)*100.0 and sort them in descending order.  【step3】: Select the country with the highest growth rate by limiting the result to the top entry using LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2333,
        "question": "Among countries with non-Arabic official languages, what is the name of the country that has experienced the greatest growth rate in GNP?",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Filter out countries where Arabic is an official language by using a subquery to select CountryCodes from countrylanguage where Language='Arabic' and IsOfficial='T'.  【step2】: Exclude these countries from the main query using NOT IN, then calculate the GNP growth rate as (GNP - GNPOld)/GNPOld * 100 for the remaining countries.  【step3】: Order the results by the calculated growth rate in descending order and select the top result with LIMIT 1 to get the country with the highest growth rate.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2334,
        "question": "Among the countries where Arabic is not the official language, which country has the largest growth rate of GNP if the old GNP of all countries in South America increased by 9999.0?",
        "query": "SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = \"South America\" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != \"South America\" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Create a derived table combining South American countries (with GNPOld increased by 9999) and non-South American countries (original GNPOld) using UNION ALL.  【step2】: Filter out countries where Arabic is an official language using WHERE Code NOT IN (subquery on countrylanguage).  【step3】: Calculate GNP growth rate percentage ((GNP-GNPOld)/GNPOld*100), sort results in descending order, and select the top entry with LIMIT 1.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2335,
        "question": "If all South American countries have an increase of 9999.0 in their previous GNP, which country, among those with non-Arabic official languages, has the highest Gross National Product growth rate?",
        "query": "SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = \"South America\" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != \"South America\" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "step": "【step1】: Create a temporary dataset (sub) combining South American countries with their GNPOld increased by 9999.0 and all other countries retaining original GNPOld values using UNION ALL.  【step2】: Filter out countries where Arabic is an official language by excluding CountryCodes linked to Arabic in countrylanguage (IsOfficial='T').  【step3】: Calculate the GNP growth rate [(GNP - GNPOld)/GNPOld * 100], order results descendingly by growth rate, and return the top-ranked country.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2336,
        "question": "Which city in North America has a population at least twice that of Kang-won?",
        "query": "SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = \"North America\" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "step": "【step1】: Calculate the total population of all cities in the Kang-won district using the subquery: `(SELECT SUM(Population) FROM city WHERE District = 'Kang-won')`.  【step2】: Perform a JOIN between the `country` and `city` tables, filtering countries in North America with `A.Continent = 'North America'`.  【step3】: Compare each city's population to twice the subquery result using `B.Population >= 2 * [subquery]` and return matching city names.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2337,
        "question": "What North American city has a population that is at least double the population of Kang-won?",
        "query": "SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = \"North America\" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "step": "【step1】: Execute the subquery to calculate the total population of cities in the 'Kang-won' district: `SELECT SUM(Population) FROM city WHERE District = 'Kang-won'`.  【step2】: Join the `country` and `city` tables using `CountryCode`, filter by continent `North America`, and reference the subquery result.  【step3】: Compare each North American city's population against twice the subquery result, then output qualifying city names via `B.Population >= 2 * (subquery_result)`.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2338,
        "question": "If the population of North American countries where English is the official language was increased by 1%, which city in North America has a population at least twice that of Kang-won?",
        "query": "SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND C.Language = \"English\" AND C.IsOfficial = \"T\" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND NOT ( C.Language = \"English\" AND C.IsOfficial = \"T\" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "step": "【step1】: Calculate adjusted populations (increased by 1%) for cities in North American countries with English as the official language by joining **country**, **city**, and **countrylanguage** tables.  【step2】: Combine these adjusted populations with unmodified populations of other North American cities using **UNION ALL** to create a unified dataset.  【step3】: Filter cities where the population is at least twice the total population of the 'Kang-won' district, using a subquery to calculate Kang-won's population sum and **DISTINCT** to remove duplicates.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2339,
        "question": "If all countries in North America with English as the official language experienced a population increase of 1%, what North American city would have a population that is at least double the population of Kang-won?",
        "query": "SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND C.Language = \"English\" AND C.IsOfficial = \"T\" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND NOT ( C.Language = \"English\" AND C.IsOfficial = \"T\" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "step": "【step1】: Calculate the total population of all cities in the Kang-won district using a subquery: `SELECT SUM(Population) FROM city WHERE District = 'Kang-won'`.  【step2】: Create a combined dataset via `UNION ALL`, containing:  - Cities from North American countries with English as the official language, with populations increased by 1%  - Cities from other North American countries (without population adjustment).  【step3】: Filter the combined dataset to select distinct city names where the adjusted/unaltered population is at least double the Kang-won district's total population.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2340,
        "question": "Which continent has a GNP growth rate at least 1.5 times that of Africa?",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "step": "【step1】: Calculate the GNP growth rate for each continent using the formula: (Total GNP - Total GNPOld) / Total GNPOld * 100.  【step2】: Compute the GNP growth rate specifically for Africa with the same formula.  【step3】: Filter continents where their growth rate exceeds 1.5 times Africa's rate via HAVING clause.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2341,
        "question": "Name the continent whose rate of growth of GNP is no less than 1.5 times that of Africa?",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "step": "【step1】: Calculate the GNP growth rate percentage for each continent using the formula: (SUM(GNP) - SUM(GNPOld)) / SUM(GNPOld) * 100.  【step2】: Compute the GNP growth rate percentage for Africa using the same formula within a subquery.  【step3】: Filter continents where their growth rate is at least 1.5 times Africa's rate via the HAVING clause, excluding Africa implicitly through comparison.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2342,
        "question": "If the current GNP of countries where the majority of people speak Czech was increased by 0.5%, which continent has a GNP growth rate at least 1.5 times that of Africa?",
        "query": "SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "step": "【step1】: Identify country codes where Czech is the majority language by selecting **CountryCode** with the maximum **Percentage** from **countrylanguage** where **Language = 'Czech'**, grouped by **CountryCode**.  【step2】: Split countries into two groups using **UNION ALL**:  - For countries in the Czech-speaking group, calculate **GNP * 1.005** to simulate a 0.5% increase.  - For others, keep original **GNP**.  【step3】: Group results by **Continent**, compute the growth rate `(SUM(GNP) - SUM(GNPOld)) / SUM(GNPOld) * 100` for each continent, and filter continents where this rate is > 1.5x Africa’s growth rate (calculated via subquery on **country** with **Continent = 'Africa'**).",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2343,
        "question": "Which continent would have a GNP growth rate that is at least 1.5 times greater than Africa if the GNP of countries where Czech is the dominant language increased by 0.5%?",
        "query": "SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "step": "【step1】: Identify countries where Czech is the dominant language by selecting the CountryCode with the highest percentage of Czech speakers per country from the countrylanguage table. Adjust their GNP by 0.5%.  【step2】: Combine adjusted GNP data for Czech-speaking countries with unmodified GNP data for non-Czech-speaking countries using UNION ALL, preserving continent information.  【step3】: Calculate each continent's GNP growth rate (using SUM(GNP)-SUM(GNPOld) normalized by SUM(GNPOld)), then compare against 1.5x Africa's equivalent growth rate through a subquery in the HAVING clause.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2344,
        "question": "Which country has a life expectancy no less than 1.5 times that of Zambia?",
        "query": "SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "step": "【step1】: Retrieve Zambia's LifeExpectancy via subquery: `SELECT LifeExpectancy FROM country WHERE name = 'Zambia'`  【step2】: Calculate 1.5 times the retrieved Zambia's LifeExpectancy value.  【step3】: Select countries where LifeExpectancy >= the calculated value from step 2.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2345,
        "question": "What country has an average life expectancy that is at least 1.5 times that of Zambia?",
        "query": "SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "step": "【step1】: Execute the subquery to retrieve Zambia's life expectancy: SELECT LifeExpectancy FROM country WHERE name = 'Zambia'  【step2】: Calculate 1.5 times the retrieved Zambia's life expectancy value  【step3】: Filter countries where LifeExpectancy >= the calculated value from step 2 via the main query: SELECT Name FROM country WHERE LifeExpectancy >= [calculated_value]",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2346,
        "question": "If the top 20 countries in terms of per capita GNP in the world has a life expectancy of 90, which country has a life expectancy no less than 1.5 times that of Zambia?",
        "query": "SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "step": "【step1】: Identify the top 20 countries by per capita GNP and set their LifeExpectancy to 90. Use a subquery to calculate `(GNP / Population)` for ordering and limit results.  【step2】: Combine these top 20 countries (with forced LifeExpectancy=90) and all other countries (retaining their original LifeExpectancy) using `UNION ALL`, creating the temporary table `combined`.  【step3】: Filter the `combined` table to retain countries where LifeExpectancy is at least 1.5 times Zambia's actual LifeExpectancy, obtained via a subquery on the original `country` table.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2347,
        "question": "Which country has a life expectancy that is at least 1.5 times that of Zambia, given that the top 20 countries in the world with the highest per capita GNP have a life expectancy of 90?",
        "query": "SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "step": "【step1】: Retrieve the top 20 country codes ranked by per capita GNP (GNP divided by Population) in descending order.  【step2】: Combine two datasets using UNION ALL: one assigns a fixed LifeExpectancy of 90 to the top 20 countries, while the other retains original LifeExpectancy values for non-top-20 countries.  【step3】: Filter the combined dataset to select countries where LifeExpectancy is at least 1.5 times Zambia's actual LifeExpectancy value.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2348,
        "question": "In countries where Dutch is not the main language, which country has the largest reduction in GNP?",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "step": "【step1】: Identify countries where Dutch is the primary language by joining the `countrylanguage` table with a subquery that finds the most widely spoken language (MAX(Percentage)) for each country.  【step2】: Filter out these Dutch-speaking countries from the `country` table using the `NOT IN` clause.  【step3】: Calculate the GNP reduction (GNPOld - GNP) for the remaining countries, sort them in descending order of reduction, and select the top result with `LIMIT 1`.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2349,
        "question": "Which country, among those where Dutch is not the primary language, has experienced the most significant decrease in Gross National Product (GNP)?",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "step": "【step1】: Identify countries where Dutch is the primary language by grouping countrylanguage entries, filtering for the highest percentage language per country, and retaining only those with Dutch.  【step2】: Exclude these Dutch-primary-language countries from the main list of countries in the country table.  【step3】: Calculate the GNP decline (GNPOld - GNP) for the remaining countries, sort them in descending order of decline, and select the top result.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2350,
        "question": "If everyone in Aruba spoke Dutch, in countries where Dutch is not the main language, which country has the largest reduction in GNP?",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" UNION SELECT Code FROM country WHERE name = \"Aruba\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "step": "【step1】: Identify countries where Dutch is the primary language by joining the countrylanguage table with a subquery that finds the language with the highest percentage for each country. Filter for Dutch and combine with Aruba's country code via UNION.  【step2】: Exclude these identified countries (Dutch-speaking primary or Aruba) using NOT IN, then calculate the GNP reduction (GNPOld - GNP) for the remaining countries.  【step3】: Order the results by the GNP reduction in descending order and return the top entry (largest reduction).",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2351,
        "question": "Assuming every person in Aruba speaks Dutch, which country, among those where Dutch is not the primary language, has experienced the most significant decrease in Gross National Product (GNP)?",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" UNION SELECT Code FROM country WHERE name = \"Aruba\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "step": "【step1】: Identify countries where Dutch is the primary language (using countrylanguage table) and include Aruba. This is done via a subquery:  `SELECT CountryCode FROM (...) WHERE Language='Dutch'`  combined with  `UNION SELECT Code FROM country WHERE name='Aruba'`, creating an exclusion list.  【step2】: Filter out all countries from the main country table that are in the exclusion list using `WHERE Code NOT IN (...)`.  【step3】: Calculate GNP decrease as `(GNPOld - GNP)`, sort results by this value in descending order, and select the top result with `LIMIT 1`.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2352,
        "question": "How many more countries in North America than in South America have a declining GNP?",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = \"North America\"",
        "step": "【step1】: Calculate the count of countries in North America where GNP is declining (GNP < GNPOld).  【step2】: Calculate the count of countries in South America where GNP is declining (GNP < GNPOld) using a subquery.  【step3】: Subtract the South America count from the North America count to get the difference (diff).",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2353,
        "question": "What is the difference in the number of countries with a decreasing GNP in North America compared to South America?",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = \"North America\"",
        "step": "【step1】: Calculate the number of countries in North America where GNP < GNPOld using COUNT(*) with filters Continent = 'North America' and GNP < GNPOld.  【step2】: Calculate the number of countries in South America where GNP < GNPOld via a subquery with COUNT(*) and filters Continent = 'South America' and GNP < GNPOld.  【step3】: Subtract the South America count from the North America count using arithmetic operation (COUNT(*) - subquery_result) to get the difference.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2354,
        "question": "Suppose the current GNP of the top two most populous countries in North America increases by 2%, how many more countries in North America than in South America have a declining GNP?",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = \"North America\"",
        "step": "【step1】: Extract the two most populous North American countries using a subquery:  `SELECT Code FROM country WHERE Continent = 'North America' ORDER BY Population DESC LIMIT 2`  【step2】: Combine two datasets via UNION ALL:  - First dataset: Apply a 2% GNP increase **only** to the top two populous countries (using results from step1).  - Second dataset: Include all other North American countries **without** changing their GNP.  This creates a virtual table `combined` with adjusted/unaltered GNP values.  【step3】: Calculate the difference between:  - Filtered North American countries (from `combined`) where adjusted GNP < GNPOld.  - Pre-filtered South American countries (directly from original table) where GNP < GNPOld.  Subtract the South American count from the North American count to get the final `diff`.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2355,
        "question": "If the two most populated North American countries experience a 2% increase in GNP, what is the difference in the number of countries with a decreasing GNP between North and South America?",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = \"North America\"",
        "step": "【step1】: Identify the two most populated North American countries, calculate their GNP with a 2% increase, and keep other North American countries' GNP unchanged via UNION ALL.  【step2】: Create a combined dataset (subquery) containing all North American countries—modified and unmodified—then filter those with decreased GNP (GNP < GNPOld).  【step3】: Subtract the count of South American countries with decreased GNP from the North American count to get the final difference (diff).",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2356,
        "question": "Which continent has a per capita GNP growth rate at least two percentage points higher than Europe?",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "step": "【step1】: Calculate the per capita GNP growth rate for all continents by summing GNP, GNPOld, and Population per continent group.  【step2】: Compute Europe's per capita GNP growth rate using a subquery with the same formula (applied only to Europe's aggregated data).  【step3】: Use HAVING clause to filter continents where growth rate ≥ (Europe's rate + 0.02), leveraging the subquery result for comparison.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2357,
        "question": "Name a continent whose per capita GNP growth rate exceeds Europe by at least two percentage points?",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "step": "【step1】: Calculate total GNP, total GNPOld, and total population for each continent using GROUP BY.  【step2】: Compute the per capita GNP growth rate for each continent by comparing current and old GNP per capita.  【step3】: Filter continents where this growth rate is ≥ (Europe's rate + 0.02) using a subquery to isolate Europe's rate.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2358,
        "question": "If the GNP of the top three countries with the longest life expectancy decreases by 2%, which continent has a per capita GNP growth rate at least two points higher than Europe?",
        "query": "SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "step": "【step1】: Identify the 3 countries with the longest life expectancy using a subquery:  `SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3`  【step2】: Create a derived table combining two datasets:  1. Selected top 3 countries with reduced GNP (2% decrease) via `GNP * (1 - 0.02)`  2. All other countries retaining original GNP values using `UNION ALL`  【step3】: Group results by Continent, calculate per-capita GNP growth rate difference between adjusted GNP and GNPOld, and filter continents meeting the 2%-higher-than-Europe threshold via HAVING clause with subquery for Europe's baseline.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2359,
        "question": "Assuming a 2% decrease in the GNP of the top three countries with the highest life expectancy, which continent has a per capita GNP growth rate that exceeds Europe by at least two points?",
        "query": "SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "step": "【step1】: Identify the top three countries with the highest LifeExpectancy using a subquery: `SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3`.  【step2】: Create a combined dataset where:  - Top 3 countries have GNP reduced by 2% (via `GNP * (1 - 0.02)`)  - Other countries retain original GNP values  using UNION ALL to merge both groups.  【step3】: Calculate per capita GNP growth rate for each continent using aggregate functions in the outer query. Compare against Europe's growth rate (+2% threshold) via HAVING clause with correlated subquery filtering Europe's baseline growth.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2360,
        "question": "List name, the past and current gross national product of each country in Asia, and estimate the future gross national product if the growth rate remains unchanged.",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = \"Asia\"",
        "step": "【step1】: Filter countries in Asia using the WHERE clause to select only those in the 'Asia' continent.  【step2】: Retrieve the name, GNPOld, and GNP columns from the filtered dataset.  【step3】: Calculate GNPFuture by adding the difference between GNP and GNPOld (current growth) to the current GNP, assuming a constant growth rate.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2361,
        "question": "For each country in Asia, provide a list of their name, the past and current GNP, and estimate their future Gross National Product assuming a constant growth rate.",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = \"Asia\"",
        "step": "【step1】: Filter countries located in Asia using the WHERE clause.  【step2】: Select the country name, historical GNP (GNPOld), and current GNP (GNP) from the filtered results.  【step3】: Calculate the estimated future GNP (GNPFuture) by adding the difference between current and past GNP (GNP - GNPOld) to the current GNP.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2362,
        "question": "If the current gross national product of a country with Chinese as its main language is 1000000.0, list name, the past and current gross national product of each country in Asia, and estimate the future gross national product if the growth rate remains unchanged.",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) ) WHERE Continent = \"Asia\"",
        "step": "【step1】: Retrieve countries where Chinese is the primary language by selecting CountryCodes with the highest percentage of Chinese speakers from the countrylanguage table.  【step2】: Create a combined dataset using UNION ALL:  - For Chinese-speaking countries, set current GNP to 1000000.0 while retaining GNPOld.  - For non-Chinese-speaking countries, use their original GNP and GNPOld values.  【step3】: Filter the combined dataset to include only Asian countries, then calculate GNPFuture by projecting GNP growth as GNP + (GNP - GNPOld).",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2363,
        "question": "Assuming that the country with Chinese as its primary language has a current GNP of 1000000.0, provide a list of their name, the past and current GNP for each Asian country, and estimate their future Gross National Product assuming a constant growth rate.",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) ) WHERE Continent = \"Asia\"",
        "step": "【step1】: Extract countries with Chinese as their primary language by identifying CountryCodes where the highest percentage language in `countrylanguage` is 'Chinese'. For these countries, set GNP to 1000000.0 while retaining GNPOld.  【step2】: Combine these Chinese-speaking countries with all other countries (using `UNION ALL`), preserving their original GNP values but filtering out countries where Chinese is the primary language.  【step3】: Filter the combined dataset to include only Asian countries (`Continent = 'Asia'`) and calculate `GNPFuture` by projecting linear growth: `GNP + (GNP - GNPOld)`.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2364,
        "question": "The annual population growth rate in the UK is 0.4%. What is the population size in the UK one year later?",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = \"United Kingdom\"",
        "step": "【step1】: Filter the country table to select the row where the name is 'United Kingdom'.  【step2】: Calculate the projected population by multiplying the current **Population** by **1.004** (which represents a 0.4% increase).  【step3】: Assign the alias **population_in_1year** to the calculated result.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 2,
        "idx": 2365,
        "question": "What will be the population size of UK after one year, given that the UK has an annual growth rate of 0.4%?",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = \"United Kingdom\"",
        "step": "【step1】: Filter the country table to retrieve the population of the United Kingdom using WHERE name = 'United Kingdom'.  【step2】: Calculate the projected population by multiplying the current population by the growth factor (1 + 0.004).  【step3】: Assign the calculated value to the alias **population_in_1year** using the AS keyword.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2366,
        "question": "The annual population growth rate in the UK is 0.4%. If the population of countries with a life expectancy greater than 75 in Europe is 103000, what is the population size in the UK one year later?",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy <= 75 ) WHERE name = \"United Kingdom\"",
        "step": "【step1】: Filter European countries into two groups: those with LifeExpectancy >75 (assign Population=103000) and others (keep original Population).  【step2】: Combine both groups using UNION to form a derived table containing all European countries with adjusted/actual populations.  【step3】: Calculate the UK's population growth by applying 0.4% increase to the entry where name='United Kingdom' from the combined results.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2367,
        "question": "What will be the population size of the UK after one year, given that the UK has an annual population growth rate of 0.4% and all European countries with a life expectancy greater than 75 have a population of 103000?",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy <= 75 ) WHERE name = \"United Kingdom\"",
        "step": "【step1】: Create a temporary table (subquery) containing European countries, assigning a fixed population of 103000 to countries with LifeExpectancy > 75 and retaining original Population values for others.  【step2】: Combine the two filtered datasets (countries with LifeExpectancy > 75 and ≤75) using UNION to form a unified European country list.  【step3】: Filter the subquery for the United Kingdom and calculate its projected population after applying the 0.4% growth rate (Population * 1.004).",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2368,
        "question": "According to Zambia's life expectancy, what is the expected year of death for people born in the year of Zambia's independence?",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = \"Zambia\"",
        "step": "【step1】: Filter the country table to retrieve the record where the name is 'Zambia'.  【step2】: Extract the values of the **IndepYear** (independence year) and **LifeExpectancy** columns from the filtered record.  【step3】: Add **IndepYear** and **LifeExpectancy**, then cast the result to an integer to calculate the expected death year.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 3,
        "idx": 2369,
        "question": "Based on Zambia's life expectancy, what is the predicted year of death for individuals born in the year of it's independence?",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = \"Zambia\"",
        "step": "【step1】: Filter the database to retrieve the row where the country name is 'Zambia' using the **WHERE** clause.  【step2】: Access the **IndepYear** (independence year) and **LifeExpectancy** values for Zambia from the selected row.  【step3】: Calculate the predicted death year by adding **IndepYear** and **LifeExpectancy**, then cast the result to an integer using **CAST()** and alias it as **death_year**.",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2370,
        "question": "If life expectancy increases by 10 years in countries with per capita GNP greater than the average per capita GNP of all European countries, what is the expected year of death for people born in the year of Zambia's independence asccording to Zambia's life expectancy?",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) ) ) WHERE name = \"Zambia\"",
        "step": "【step1】: Calculate the average per capita GNP of all European countries using a subquery:  `SELECT 1.0 * SUM(GNP)/SUM(Population) FROM country WHERE Continent = 'Europe'`  【step2】: Split countries into two groups via UNION ALL:  - Group 1: Countries with per capita GNP > European average, add 10 years to LifeExpectancy  - Group 2: Other countries retain original LifeExpectancy  【step3】: Filter merged results for Zambia, compute death year by summing IndepYear and adjusted LifeExpectancy:  `CAST(IndepYear + LifeExpectancy AS SIGNED)`",
        "format": "MySQL"
    },
    {
        "db_id": "Population",
        "type": 4,
        "idx": 2371,
        "question": "What is the predicted year of death for individuals born during the year of Zambia's independence, according to the country's life expectancy, if countries with a per capita GNP higher than the average per capita GNP of all European countries experience a 10-year increase in life expectancy?",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) ) ) WHERE name = \"Zambia\"",
        "step": "【step1】: Calculate the average per capita GNP of all European countries using the inner subquery: `SUM(GNP)/SUM(Population)`.  【step2】: Split countries into two groups via UNION ALL:  - Group 1: Add 10 to LifeExpectancy for countries with per capita GNP > European average.  - Group 2: Keep original LifeExpectancy for others.  【step3】: Filter the combined results for 'Zambia', then compute the death year by adding its IndepYear (independence year) to the adjusted LifeExpectancy.",
        "format": "MySQL"
    }
]