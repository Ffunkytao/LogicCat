[
  {
    "db_id": "AirCraft",
    "type": "1",
    "idx": 1,
    "question": "If a Robinson R-22 helicopter has a total rotor disc area of 46.2 square meters and a maximum rotor disc loading of 14 kilograms per square meter, what is its lift under maximum gross weight?",
    "query": "SELECT Total_Disk_Area * Max_Disk_Loading AS Lift FROM aircraft WHERE Aircraft = 'Robinson R-22';",
    "step": "【step1】: Filter the aircraft table to find the entry where Aircraft = 'Robinson R-22' using the WHERE clause.  【step2】: Calculate the product of Total_Disk_Area and Max_Disk_Loading for the filtered row.  【step3】: Return the computed result as Lift using column aliasing.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "2",
    "idx": 2,
    "question": "Assuming a Robinson R-22 aircraft has a maximum gross weight of 635 kg, a total rotor disc area of 46.2 square meters, and a maximum rotor disc loading of 14 kg/square meter. If the aircraft's weight increases by 20%, what is the new maximum rotor disc loading?",
    "query": "SELECT (Max_Gross_Weight * 1.2) / Total_Disk_Area AS New_Max_Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';",
    "step": "【step1】: Filter the aircraft table to retrieve the record where Aircraft is 'Robinson R-22'.  【step2】: Calculate the new maximum gross weight by multiplying the original Max_Gross_Weight by 1.2 (20% increase).  【step3】: Divide the adjusted weight by Total_Disk_Area to determine the New_Max_Disk_Loading and alias the result.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "3",
    "idx": 3,
    "question": "If a Robinson R-22 aircraft has a maximum gross weight of 635 kilograms, its total rotor disc area is 46.2 square meters, and its maximum disk loading is known, is this aircraft suitable for flying in plateau regions?",
    "query": "SELECT CASE WHEN Max_Disk_Loading * Total_Disk_Area * 0.75 < Max_Gross_Weight THEN 'Not Suitable' ELSE 'Suitable' END AS Suitability FROM aircraft WHERE Aircraft = 'Robinson R-22';",
    "step": "【step1】: Calculate adjusted disk loading by multiplying Max_Disk_Loading, Total_Disk_Area, and 0.75 (high altitude efficiency factor).  【step2】: Compare the adjusted disk loading value against the aircraft's Max_Gross_Weight.  【step3】: Return 'Suitable' if the adjusted value meets or exceeds Max_Gross_Weight, otherwise 'Not Suitable'.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "4",
    "idx": 4,
    "question": "Assuming a Robinson R-22 helicopter has a total rotor disk area of 46.2 square meters and the weight of this helicopter suddenly increases to 10,000 kg, what would its rotor disk loading be? What would happen to the helicopter under such extreme conditions?",
    "query": "SELECT 10000 / Total_Disk_Area AS Extreme_Disk_Loading, 'The aircraft will likely stall or crash due to insufficient lift.' AS Consequence FROM aircraft WHERE Aircraft = 'Robinson R-22';",
    "step": "【step1】: Filter the aircraft table to retrieve the record where Aircraft = 'Robinson R-22'.  【step2】: Calculate Extreme_Disk_Loading by dividing the hypothetical weight 10000 kg by Total_Disk_Area (46.2 m²).  【step3】: Return the computed value with a static consequence string indicating stall/crash risk.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "2",
    "idx": 5,
    "question": "Assuming the total annual passenger volume at London Heathrow Airport is 67,054,745, with international passengers accounting for 61,344,438, domestic passengers for 5,562,516, and transit passengers for 147,791. Please calculate the percentage of international passenger volume relative to the total passenger volume, rounding to two decimal places.",
    "query": "SELECT ROUND((International_Passengers / Total_Passengers) * 100, 2) AS International_Passenger_Percentage FROM airport WHERE Airport_Name = 'LondonHeathrow';",
    "step": "【step1】: Filter the airport table to retrieve the row where Airport_Name is 'LondonHeathrow'.  【step2】: Calculate the ratio of International_Passengers to Total_Passengers from the filtered data.  【step3】: Multiply the ratio by 100, round it to two decimal places using ROUND(), and alias the result as International_Passenger_Percentage.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "3",
    "idx": 6,
    "question": "If the number of aircraft movements at London Heathrow Airport is 478,893 with a freight volume of 1,397,054 metric tons, what is the average freight volume per aircraft movement?",
    "query": "SELECT Freight_Tonnes / Aircraft_Movements AS Average_Freight_Per_Movement FROM airport WHERE Airport_Name = 'LondonHeathrow';",
    "step": "【step1】: Filter the 'airport' table to retrieve the record where Airport_Name is 'LondonHeathrow'.  【step2】: Extract the values of the 'Freight_Tonnes' and 'Aircraft_Movements' fields from the filtered record.  【step3】: Calculate the average freight per movement by dividing 'Freight_Tonnes' by 'Aircraft_Movements' and return the result as 'Average_Freight_Per_Movement'.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "4",
    "idx": 7,
    "question": "Assuming that London Heathrow Airport has an annual total passenger volume of 67,054,745 people, with each passenger carrying an average of 2 luggage items and each item weighing an average of 20 kilograms, what is the total annual weight of luggage at the airport? If all these luggage items were to be transported by Robinson R-22 helicopters, with each helicopter having a maximum total weight capacity of 635 kilograms, how many helicopter trips would be required to transport all the luggage?",
    "query": "SELECT (Total_Passengers * 2 * 20) AS Total_Luggage_Weight, CEIL((Total_Passengers * 2 * 20) / 635) AS Required_Flights FROM airport WHERE Airport_Name = 'LondonHeathrow';",
    "step": "【step1】: Retrieve the Total_Passengers value for 'LondonHeathrow' from the airport table.  【step2】: Calculate Total_Luggage_Weight by multiplying Total_Passengers × 2 (bags per passenger) × 20 (kg per bag).  【step3】: Compute Required_Flights by dividing Total_Luggage_Weight by 635 (helicopter max weight) and apply CEIL() to round up.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "2",
    "idx": 8,
    "question": "Assuming an airport named 'London Heathrow' had a total passenger volume of 67,054,745 in 2023, including 61,344,438 international passengers, 5,562,516 domestic passengers, and 147,791 transit passengers. If the international passenger volume grows by 1.5% annually, the domestic passenger volume grows by 2% annually, and the transit passenger volume decreases by 0.5% annually, what will the airport's total passenger volume be after 5 years?",
    "query": "SELECT (International_Passengers * POW(1 + 0.015, 5) + Domestic_Passengers * POW(1 + 0.02, 5) + Transit_Passengers * POW(1 - 0.005, 5)) AS Total_Passengers_After_5_Years FROM airport WHERE Airport_Name = 'London Heathrow';",
    "step": "【step1】: Retrieve the current passenger numbers (International_Passengers, Domestic_Passengers, Transit_Passengers) for 'London Heathrow' from the airport table.  【step2】: Apply growth/decay formulas using POW() for each passenger type: International (1.5% annual growth), Domestic (2% growth), Transit (0.5% annual reduction) over 5 years.  【step3】: Sum the calculated future passenger values to get the total projected passengers after 5 years.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "3",
    "idx": 9,
    "question": "If a pilot participated in a competition and won the championship at the age of 23, can Prof. Zackery Collina still maintain the same level of competitive performance by the age of 30?",
    "query": "SELECT CASE WHEN Age + 7 <= 30 THEN 'may maintain the same level of competitive performance' ELSE 'may not maintain the same level of competitive performance' END AS Competitive_Status FROM pilot WHERE Name = 'Prof. Zackery Collina';",
    "step": "【step1】: Retrieve the pilot's current age from the pilot table using the WHERE clause filtering by Name = 'Prof. Zackery Collina'.  【step2】: Apply CASE expression to calculate Age + 7 and compare it with 30.  【step3】: Output '可能保持竞技状態' if the result ≤30, otherwise output '可能无法保持竞技状態' as Competitive_Status.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "1",
    "idx": 10,
    "question": "If a Robinson R-22 helicopter takes off at its maximum gross weight, what are its rotor disc area and maximum rotor disc loading?",
    "query": "SELECT Aircraft, Max_Gross_Weight, Total_Disk_Area, Max_Disk_Loading FROM aircraft WHERE Aircraft = 'RobinsonR-22';",
    "step": "【step1】: Filter the 'aircraft' table to find the record where the 'Aircraft' field is 'RobinsonR-22'.  【step2】: Retrieve the 'Max_Gross_Weight', 'Total_Disk_Area', and 'Max_Disk_Loading' values from the filtered record.  【step3】: Analyze the relationship between Max_Disk_Loading (calculated as Max_Gross_Weight / Total_Disk_Area) and lift, where sufficient disk area reduces required disk loading to generate lift equal to the aircraft's weight.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "2",
    "idx": 11,
    "question": "Calculate the total passenger volume for London Heathrow Airport in 2019, given that the total passenger volume in 2020 was 67,054,745, with a -1.5% change compared to 2019.",
    "query": "SELECT Total_Passengers / (1 + Change_2019 / 100) AS Total_Passengers_2019 FROM airport WHERE Airport_Name = 'LondonHeathrow';",
    "step": "【step1】: Filter the airport table to retrieve the row for 'LondonHeathrow'.  【step2】: Extract the Total_Passengers (2020) and Change_2019 (1.5%) values from the filtered record.  【step3】: Calculate the 2019 total passengers by dividing Total_Passengers by (1 + Change_2019/100) and alias the result as Total_Passengers_2019.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "3",
    "idx": 12,
    "question": "If an airport's domestic passenger volume accounts for 80% of the total passenger volume, then what is the total passenger volume of this airport?",
    "query": "SELECT Domestic_Passengers / 0.80 AS Total_Passengers FROM airport;",
    "step": "【step1】: Recognize that domestic passengers represent 80% of total passengers.  【step2】: Calculate total passengers by dividing domestic passenger count by 0.80.  【step3】: Execute `SELECT Domestic_Passengers / 0.80 AS Total_Passengers FROM airport;` to derive the result.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "4",
    "idx": 13,
    "question": "Assuming a maximum total weight of an aircraft is 1,000,000 lb and the rotor disc area is 1,000,000 ft², calculate its maximum rotor disc loading and discuss how the maximum rotor disc loading would change if the maximum gross weight increases to 10,000,000 lb.",
    "query": "SELECT Max_Gross_Weight / Total_Disk_Area AS Max_Disk_Loading, Max_Gross_Weight / 10000000 AS Max_Disk_Loading_New FROM aircraft WHERE Max_Gross_Weight = 1000000 AND Total_Disk_Area = 1000000;",
    "step": "【step1】: Filter the aircraft table to find records where Max_Gross_Weight = 1,000,000 lb and Total_Disk_Area = 1,000,000 ft².  【step2】: Calculate initial Max_Disk_Loading by dividing Max_Gross_Weight by Total_Disk_Area (1,000,000 lb / 1,000,000 ft² = 1 lb/ft²).  【step3】: Compute Max_Disk_Loading_New using the hypothetical Total_Disk_Area (1,000,000 lb / 10,000,000 ft² = 0.1 lb/ft²), showing a 10x decrease in disk loading.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "1",
    "idx": 14,
    "question": "Calculate what is the rotor disk loading of the Robinson R-22 helicopter at its maximum gross weight?",
    "query": "SELECT Max_Gross_Weight / Total_Disk_Area AS Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';",
    "step": "【step1】: Filter the aircraft table to retrieve the record where Aircraft is 'Robinson R-22'.  【step2】: Extract the values of Max_Gross_Weight and Total_Disk_Area from the filtered record.  【step3】: Calculate Disk_Loading by dividing Max_Gross_Weight by Total_Disk_Area.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "4",
    "idx": 15,
    "question": "If a pilot is 23 years old, in which year could he have obtained his pilot's license at the earliest?",
    "query": "SELECT YEAR(CURDATE()) - (Age - 17) AS Earliest_License_Year FROM pilot WHERE Age = 23;",
    "step": "【step1】: Filter the pilot table to select the row where Age is 23 using `WHERE Age = 23`.  【step2】: Calculate the current year using `YEAR(CURDATE())` and subtract the difference between the pilot's age (23) and the minimum licensing age (17), which is `23 - 17 = 6`.  【step3】: Compute `YEAR(CURDATE()) - 6` to determine the earliest possible year the pilot could have obtained the license (e.g., 2023 - 6 = 2017).",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "1",
    "idx": 16,
    "question": "Calculate the lift requirement for the Robinson R-22 helicopter at maximum gross weight, assuming a gravitational acceleration of 9.81 m/s².",
    "query": "SELECT Aircraft, CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(Max_Gross_Weight, '(', -1), 'kg', 1) AS FLOAT) * 9.81 AS Lift_Required FROM aircraft WHERE Aircraft = 'RobinsonR-22';",
    "step": "【step1】: 【Filter the aircraft table to retrieve the 'RobinsonR-22' record using WHERE clause.】  【step2】: 【Extract the numerical value (in kg) from the Max_Gross_Weight field using SUBSTRING_INDEX functions and CAST it to FLOAT.】  【step3】: 【Multiply the extracted weight by 9.81 to calculate the lift required (Lift_Required).】",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "2",
    "idx": 17,
    "question": "Calculate the total disk area of all winning aircraft in the MiraZayd, Abu Dhabi competition, and determine the average disk area.",
    "query": "SELECT SUM(a.Total_Disk_Area) AS Total_Disk_Area, AVG(a.Total_Disk_Area) AS Avg_Disk_Area FROM `match` m JOIN aircraft a ON m.Winning_Aircraft = a.Aircraft_ID WHERE m.Location = 'MiraZayd, Abu Dhabi';",
    "step": "【step1】: Filter the `match` table to select records where the Location is 'MiraZayd, Abu Dhabi'.  【step2】: Join the filtered `match` records with the `aircraft` table using `Winning_Aircraft = Aircraft_ID` to retrieve the Total_Disk_Area of the winning aircraft.  【step3】: Apply aggregate functions SUM() and AVG() to calculate the total and average Total_Disk_Area from the joined dataset.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "3",
    "idx": 18,
    "question": "Determine whether the international passenger volume at London Heathrow Airport exceeds 90% of the total passenger volume.",
    "query": "SELECT Airport_Name, (International_Passengers / Total_Passengers) * 100 AS International_Percentage, CASE WHEN (International_Passengers / Total_Passengers) * 100 > 90 THEN 'Yes' ELSE 'No' END AS Exceeds_90_Percent FROM airport WHERE Airport_Name = 'London Heathrow';",
    "step": "【step1】: Filter the airport table to retrieve data specifically for 'London Heathrow'.  【step2】: Calculate the percentage of international passengers relative to total passengers using (International_Passengers / Total_Passengers) * 100.  【step3】: Apply CASE statement to determine if the calculated percentage exceeds 90%, returning 'Yes' or 'No' in the Exceeds_90_Percent column.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "1",
    "idx": 19,
    "question": "What is the calculated loading for the Robinson R-22 helicopter at maximum gross weight, and does it exceed the maximum disk loading?",
    "query": "SELECT Aircraft, (Max_Gross_Weight/Total_Disk_Area) AS Calculated_Loading, Max_Disk_Loading, CASE WHEN (Max_Gross_Weight/Total_Disk_Area) > Max_Disk_Loading THEN 'Exceeded' ELSE 'Within Limit' END FROM aircraft WHERE Aircraft = 'RobinsonR-22';",
    "step": "【step1】: Filter the 'aircraft' table to retrieve the record where Aircraft is 'RobinsonR-22'.  【step2】: Calculate average lift density (Max_Gross_Weight/Total_Disk_Area) and compare with Max_Disk_Loading.  【step3】: Use CASE to validate if calculated loading exceeds the maximum disk loading and output the result.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "2",
    "idx": 20,
    "question": "Calculate the average cargo load in kilograms per aircraft movement per distinct aircraft at London Heathrow Airport.",
    "query": "SELECT (SUM(a.Freight_Tonnes*1000)/SUM(a.Aircraft_Movements))/COUNT(DISTINCT aa.Aircraft_ID) FROM airport a JOIN airport_aircraft aa ON a.Airport_ID=aa.Airport_ID WHERE Airport_Name='LondonHeathrow';",
    "step": "【step1】: Join `airport` and `airport_aircraft` tables to link London Heathrow's data with associated aircraft.  【step2】: Calculate total freight in kilograms (sum of `Freight_Tonnes * 1000`) and total aircraft movements.  【step3】: Divide the total freight by total movements to get per-movement average, then divide by the distinct aircraft count for final result.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "3",
    "idx": 21,
    "question": "Verify whether the total passenger volume at the airport equals the sum of international, domestic, and transit passengers.",
    "query": "SELECT Total_Passengers, (International_Passengers+Domestic_Passengers+Transit_Passengers) AS Sum_Passengers, CASE WHEN Total_Passengers = International_Passengers+Domestic_Passengers+Transit_Passengers THEN 'Match' ELSE 'Mismatch' END FROM airport;",
    "step": "【step1】: Select the original passenger values: Total_Passengers, International_Passengers, Domestic_Passengers, and Transit_Passengers from the airport table.  【step2】: Calculate the sum of International_Passengers, Domestic_Passengers, and Transit_Passengers as Sum_Passengers.  【step3】: Compare Total_Passengers with Sum_Passengers using CASE WHEN to output 'Match' or 'Mismatch'.",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "4",
    "idx": 22,
    "question": "If the Max_Gross_Weight of a certain aircraft is 600 tons and its Total_Disk_Area is 0.01 m², what is the equivalent rotor disk loading in terms of atmospheric pressure?",
    "query": "SELECT (600000*9.8)/0.01/101325 AS Atmospheric_Pressure_Multiples FROM DUAL;",
    "step": "【step1】: Calculate the total force exerted by the aircraft's maximum gross weight using Newtonian physics (F = m * g, where m = 600,000 kg and g = 9.8 m/s²).  【step2】: Compute disk loading by dividing the force by total disk area (0.01 m²) to get pressure in Pascals.  【step3】: Convert the pressure to multiples of atmospheric pressure by dividing by 101325 Pa (1 standard atmosphere).",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "1",
    "idx": 23,
    "question": "Calculate the rotational energy for the helicopter rotor using the Robinson R-22's maximum gross weight, a rotor radius of 5m, and a rotation speed of 300 RPM.",
    "query": "SELECT 0.5*(0.3*Max_Gross_Weight)*POWER(5,2)*POWER((2*PI()*300/60),2) AS Rotational_Energy FROM aircraft WHERE Aircraft='RobinsonR-22';",
    "step": "【step1】: Retrieve Max_Gross_Weight for 'RobinsonR-22' from aircraft table using WHERE clause  【step2】: Calculate angular velocity (2π*300RPM/60) and square the result  【step3】: Compute rotational energy using formula: 0.5*(0.3*Max_Gross_Weight)*r²*(angular_velocity)²",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "2",
    "idx": 24,
    "question": "Calculate the winning probability and its confidence interval for a 23-year-old pilot in the 2023 season.",
    "query": "WITH cte AS (SELECT COUNT(*) AS total, SUM(CASE WHEN p.Age=23 THEN 1 ELSE 0 END) AS wins FROM `match` m JOIN pilot p ON m.Winning_Pilot = p.Pilot_ID WHERE YEAR(m.Date) = 2023) SELECT ROUND(wins*1.0/total,3) AS p_value, ROUND(1.96 * SQRT((wins*1.0/total) * (1 - wins*1.0/total) / total), 3) AS margin FROM cte;",
    "step": "【step1】: Filter 2023 season matches and calculate total wins and age-specific wins by joining match and pilot tables  【step2】: Compute proportion (p_value) of wins by 23-year-old pilots using wins/total ratio  【step3】: Calculate confidence interval margin using normal approximation formula (1.96 * sqrt(p*(1-p)/n))",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "3",
    "idx": 25,
    "question": "Analyze whether the ratio of daily transfer passenger volume per aircraft movement exceeds the airport's ground handling capacity limit.",
    "query": "SELECT Transit_Passengers/(Aircraft_Movements/365) AS Daily_Transit_Per_Movement FROM airport;",
    "step": "【step1】: Compute daily average aircraft movements by dividing total annual Aircraft_Movements by 365 days.  【step2】: Calculate transit passenger volume allocated per movement by dividing Transit_Passengers by the daily average movements.  【step3】: Evaluate if the resulting ratio exceeds airport ground capacity thresholds (though explicit capacity metrics are absent in the schema, this calculation provides the critical comparison value).",
    "format": "MySQL"
  },
  {
    "db_id": "AirCraft",
    "type": "4",
    "idx": 26,
    "question": "If an airport's international passenger traffic reaches 5.1 × 10¹⁴ passengers, with each passenger occupying 0.5 m² of space, how many times the Earth's surface area would the terminal building need to be?",
    "query": "SELECT (1E15*0.5)/(5.1E14) AS Earth_Surface_Multiples FROM DUAL;",
    "step": "【step1】: Calculate total required terminal area by multiplying international passengers (1E15) by space per person (0.5m²) → (1E15 * 0.5)  【step2】: Obtain Earth's total surface area reference value → 5.1E14 m²  【step3】: Divide total required area by Earth's surface area → (1E15*0.5)/(5.1E14) AS Earth_Surface_Multiples",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 27,
    "question": "If there is a record in the warning event table where the event type is a tsunami with an impact radius of 200 kilometers, what is the propagation time in seconds for the tsunami wave to travel from the epicenter to the edge of the impact radius, assuming a wave speed of 200 meters per second?",
    "query": "SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;",
    "step": "【step1】:【Filter records in WarningEvent where EventType is 'tsunami' and RadiusKm equals 200】  【step2】:【Convert RadiusKm from kilometers to meters by multiplying by 1000】  【step3】:【Calculate propagation time by dividing adjusted radius (in meters) by the wave speed (200 m/s), aliased as PropagationTimeSeconds】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 28,
    "question": "The alert event table contains 1,000 records, with each record's severity level (SeverityLevel) ranging from 1 to 10. Assuming the severity data follows a normal distribution, calculate the percentage of events where the severity level exceeds 8 relative to the total number of events, and further compute the 99% confidence interval for the average severity level of these events.",
    "query": "WITH FilteredData AS (SELECT SeverityLevel FROM WarningEvent WHERE SeverityLevel > 8) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, AVG(SeverityLevel) - (2.576 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound, AVG(SeverityLevel) + (2.576 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound FROM FilteredData;",
    "step": "【step1】: Filter records with SeverityLevel >8 using CTE  【step2】: Calculate percentage by comparing filtered count (FROM CTE) to total count (subquery FROM base table)  【step3】: Compute confidence interval using formula: mean ± (Z-score * (stddev/√n)) with 2.576 Z-value for 99% confidence",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 29,
    "question": "There is a record in the early warning events table with the event type being flood and severity level of 8. Based on common knowledge, what emergency response measures might be applicable for such an event? Please reason in conjunction with flood disaster emergency management.",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;",
    "step": "【step1】: Filter WarningRule table entries where EventType equals 'flood'  【step2】: Apply additional filter for SeverityLevel = 8  【step3】: Extract ActionType values from the resulting records",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 30,
    "question": "Assuming there is a record in the warning event table with the event type as fire, an impact radius of 1,000 kilometers, an affected population of 100 million people, and an estimated loss of 1 trillion USD, which are extreme outliers (the normal range is an impact radius of 0–100 kilometers, an affected population of 0–1 million people, and an estimated loss of 0–10 billion USD). If the warning system records data every millisecond and the event data remains at these extreme values for 24 hours, how many times will the system trigger a warning? Assume the warning rule is an impact radius > 100 kilometers or an affected population > 1 million people or an estimated loss > 10 billion USD, and the query is run for the time period of '2023-01-01 00:00:00' to '2023-01-02 00:00:00'.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR PopulationAffected > 1000000 OR EstimatedDamageUSD > 10000000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
    "step": "【step1】: Filter all records from WarningEvent where EventTime falls within the 24-hour period (BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00').  【step2】: Apply the warning condition filters (RadiusKm > 100 OR PopulationAffected > 1000000 OR EstimatedDamageUSD > 10000000000) to the time-filtered dataset.  【step3】: Count the total number of matching rows using COUNT(*) since the extreme values meet all three conditions simultaneously, resulting in one record per millisecond (86,400,000 triggers in 24 hours).",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 31,
    "question": "If there is a record in the warning event table with the event type as a volcanic eruption and a radius of 50 kilometers, what is the diffusion time in seconds calculated by converting the radius to meters and then dividing by a speed of 10 meters per second?",
    "query": "SELECT (RadiusKm * 1000) / 10 AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 50;",
    "step": "【step1】:【Filter records where EventType is 'volcanic eruption' and RadiusKm equals 50 using WHERE clause】  【step2】:【Convert RadiusKm from kilometers to meters by multiplying 1000】  【step3】:【Calculate diffusion time by dividing converted radius (in meters) by the speed of 10 meters/second】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 32,
    "question": "There are 7 records in the early warning event table, with estimated losses (EstimatedDamageUSD) of $5,000,000.00, $10,000,000.00, $2,000,000.00, $1,500,000.00, $50,000,000.00, $1,000,000.00, and $3,000,000.00 for each record. Please calculate the percentage of events where the estimated loss exceeds $20,000,000.00 relative to the total number of events.",
    "query": "SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 20000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;",
    "step": "【step1】: Calculate the number of events where EstimatedDamageUSD exceeds 20,000,000.00 USD using a conditional COUNT() with CASE WHEN.  【step2】: Divide the count from step1 by the total number of records (COUNT(*)), multiply by 100.0 to get the percentage, and alias the result as PercentageAboveThreshold.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 33,
    "question": "There is a record in the warning event table with an event type of tornado and severity level of 6. Based on common knowledge, what emergency response measures might this event involve? Please reason based on emergency management principles for tornado disasters.",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'tornado' AND SeverityLevel = 6;",
    "step": "【step1】: Filter WarningRule table where EventType matches 'tornado'  【step2】: Further filter results where SeverityLevel equals 6  【step3】: Extract ActionType values from the filtered rules",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 34,
    "question": "Assume there is a record in the warning event table where the event type is a tsunami, with an impact radius of 1000 kilometers, a severity level of 10, and estimated losses of 100,000,000.00 USD. This is an extreme outlier (the normal range is an impact radius of 0-200 kilometers, severity levels 1-9, and estimated losses of 0-50,000,000.00 USD). If the warning system logs data every millisecond, and the event data remains at these extreme values for 24 hours, how many times will the system trigger warnings? Assume the warning rule is triggered when the impact radius > 200 kilometers, or the severity level > 9, or the estimated losses > 50,000,000.00 USD.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 50000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
    "step": "【step1】: Filter all records within the 24-hour period using `EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00'`.  【step2】: Apply the composite logical condition `(RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 50000000)` to identify extreme outliers.  【step3】: Execute `COUNT(*)` aggregation on the filtered results to calculate the total number of triggered warnings, yielding `WarningCount = 86,400,000` (24h × 60m × 60s × 1,000ms).",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 35,
    "question": "If there is a record in the alert event table with the event type as earthquake and an influence radius of 100 kilometers, please calculate the time required for the seismic wave to propagate from the epicenter to the edge of the influence radius based on the seismic wave speed (assuming it is 5 kilometers per second).",
    "query": "SELECT RadiusKm / 5 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'earthquake' AND RadiusKm = 100;",
    "step": "【step1】:【Filter records in WarningEvent where EventType is 'earthquake' and RadiusKm equals 100】  【step2】:【Calculate PropagationTimeSeconds by dividing RadiusKm by the seismic wave speed (5 km/s)】  【step3】:【Return the calculated PropagationTimeSeconds as the result】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 36,
    "question": "There are 10 records in the early warning event table, with estimated damages (EstimatedDamageUSD) of $1,000,000.00, $2,000,000.00, $3,000,000.00, $4,000,000.00, $5,000,000.00, $6,000,000.00, $7,000,000.00, $8,000,000.00, $9,000,000.00, and $10,000,000.00 respectively. What percentage of events have estimated damages exceeding $8,000,000.00?",
    "query": "SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 8000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;",
    "step": "【step1】: Calculate total number of events using COUNT(*) to get the denominator  【step2】: Count events exceeding $8,000,000 threshold using COUNT(CASE WHEN) conditional logic  【step3】: Compute percentage by multiplying qualifying count ratio with 100.0 and casting to floating-point division",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 37,
    "question": "There is a record in the warning rule table where the event type is flood and the severity level is 8. Based on common sense, what emergency response measures might this event entail? Please reason in combination with flood disaster emergency management.",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;",
    "step": "【step1】:【Query the WarningRule table to filter records where EventType matches 'flood'】  【step2】:【Apply additional filter on the pre-selected records to match SeverityLevel = 8】  【step3】:【Retrieve the ActionType values from the final filtered records】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 38,
    "question": "Assuming there is a record in the WarningEvent table with an impact radius of 5,000 kilometers, a severity level of 10, and estimated losses of $1,000,000,000,000.00. If the system records data every millisecond and the event data remains at these extreme values for 24 hours, how many times will the system trigger an early warning? Assume the early warning rule is triggered if the impact radius > 100 kilometers, or severity level > 9, or estimated losses > $100,000,000.00.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
    "step": "【step1】: Filter all records in the WarningEvent table where EventTime falls within the 24-hour period from '2023-01-01 00:00:00' to '2023-01-02 00:00:00'.  【step2】: Apply the warning condition using OR logic: (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) to identify extreme values.  【step3】: Count the total number of qualifying records (1 per millisecond), resulting in 86,400,000 triggers (24h × 60m × 60s × 1000ms).",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 39,
    "question": "If there is a record in the early warning event table where the event type is fire and the impact radius is 2 kilometers, and the radius is divided by 0.1, what does the result represent?",
    "query": "SELECT RadiusKm / 0.1 AS SpreadTimeMinutes FROM WarningEvent WHERE EventType = 'fire' AND RadiusKm = 2;",
    "step": "【step1】: Filter records in WarningEvent table where EventType is 'fire' and RadiusKm equals 2  【step2】: Calculate SpreadTimeMinutes by dividing RadiusKm (2) by flame spread speed (0.1 km/minute)  【step3】: (not required for this simple calculation)",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 40,
    "question": "The alert event table contains 5 records, with affected population numbers (PopulationAffected) of 100, 200, 300, 400, and 500 people respectively. Please calculate the average affected population for these records.",
    "query": "SELECT AVG(PopulationAffected) AS AveragePopulationAffected FROM WarningEvent;",
    "step": "【step1】:【Access the WarningEvent table to retrieve the PopulationAffected column】  【step2】:【Apply the AVG() aggregate function to calculate the arithmetic mean of PopulationAffected values】  【step3】:【Alias the result as AveragePopulationAffected using the AS keyword】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 41,
    "question": "What action type is associated with the warning rule for a typhoon event with a severity level of 5?",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'typhoon' AND SeverityLevel = 5;",
    "step": "【step1】:【Execute the query to filter applicable rules】The query selects ActionType from WarningRule table where EventType matches 'typhoon' (typhoon) and SeverityLevel equals 5, retrieving predefined emergency actions associated with typhoons of severity 5.  【step2】:【Determine triggered actions】Check WarningTriggerRecord for records linked to the event's Id, verifying executed actions (ActionTaken) corresponding to the retrieved ActionType from step 1.  【step3】:【Validate notification measures】Cross-reference WarningNotificationRecord using TriggerId to confirm implementation details (e.g., recipient types, notification methods) for the actions, ensuring alignment with typhoon-specific protocols like mass evacuations or public alerts.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 42,
    "question": "Assuming there is a record in the early warning event table with the event type as earthquake, an impact radius of 1,000 kilometers, a severity level of 10, and an estimated loss of $10,000,000,000.00, which are extreme outliers (the normal range is an impact radius of 0-100 kilometers, severity level 1-9, and an estimated loss of $0-1,000,000.00). If the early warning system records data once per second and the event data remains at these extreme values for 24 hours, how many times will the system trigger an early warning between '2023-01-01 00:00:00' and '2023-01-02 00:00:00'? Assume the warning rules are: impact radius > 100 kilometers, or severity level > 9, or estimated loss > $1,000,000.00.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
    "step": "【step1】: Filter all events within the 24-hour period (EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00').  【step2】: Apply the warning rules (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) to the filtered events.  【step3】: Count the number of records satisfying ANY of the three conditions using COUNT(*). Since data is recorded every second for 24 hours, the result is 86,400 total triggers.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 43,
    "question": "If there is a record in the early warning event table where the event type is tsunami and the affected radius is 200 kilometers, please calculate the time required for the tsunami wave to propagate from the source to the edge of the affected radius, assuming a propagation speed of 200 meters per second.",
    "query": "SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;",
    "step": "【step1】: Filter records in WarningEvent where EventType is 'tsunami' and RadiusKm equals 200.  【step2】: Convert RadiusKm to meters by multiplying by 1000 (200 km → 200,000 meters).  【step3】: Calculate propagation time by dividing the converted radius value by the wave speed (200,000 meters / 200 m/s = 1000 seconds).",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 44,
    "question": "There are 10 records in the early warning events table. Calculate the percentage of events where the estimated damage (EstimatedDamageUSD) falls between $3,000,000.00 and $7,000,000.00 out of the total number of events.",
    "query": "SELECT (COUNT(CASE WHEN EstimatedDamageUSD BETWEEN 3000000.00 AND 7000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageWithinRange FROM WarningEvent;",
    "step": "【step1】:【Filter records where EstimatedDamageUSD falls within the specified range (3,000,000.00 to 7,000,000.00) using CASE WHEN】  【step2】:【Count qualifying records (numerator) and total records (denominator) via COUNT() aggregation】  【step3】:【Calculate percentage by multiplying the ratio (numerator/denominator) by 100.0】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 45,
    "question": "What action type is specified in the warning rule for earthquake events with severity level 7?",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'earthquake' AND SeverityLevel = 7;",
    "step": "【step1】: Filter WarningRule records where EventType matches 'earthquake'  【step2】: Apply additional filter for SeverityLevel = 7 from the earthquake-specific subset  【step3】: Extract ActionType values (e.g., evacuation protocols, emergency response activation, public alert broadcasting) based on earthquake severity and radius thresholds.  Typical emergency measures for magnitude-7 earthquakes with 50km impact:  1. Immediate evacuation of high-risk zones  2. Activation of emergency response teams  3. Critical infrastructure shutdown (gas/power lines)  4. Emergency shelter deployment  5. Real-time public notification via multiple channels  6. Road clearance for rescue operations  7. Coordination with geological monitoring agencies  8. Secondary disaster prevention protocols (landslides/tsunamis)",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 46,
    "question": "Assume there is a record in the warning event table with a radius of 1,000 kilometers, a severity level of 10, and an estimated damage of 100,000,000,000.00 USD, which is an extreme outlier (normal ranges are radius 0-100 kilometers, severity level 1-9, estimated damage 0-1,000,000.00 USD). If the warning system records data once per second and the event data remains at these extreme values for 24 hours, and the query is run for the 24-hour period from '2023-01-01 00:00:00' to '2023-01-02 00:00:00', how many times will the system trigger warnings? The warning rules are defined as: radius > 100 kilometers or severity level > 9 or estimated damage > 1,000,000.00 USD.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
    "step": "【step1】: Filter all records within the 24-hour period (2023-01-01 00:00:00 to 2023-01-02 00:00:00) using the EventTime condition.  【step2】: Apply the combined trigger conditions (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) to the filtered time range.  【step3】: Count all matching records (1 record per second × 86,400 seconds/day = 86,400 total warnings).",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 47,
    "question": "If there is a record in the early warning events table where the event type is a volcanic eruption, with an impact radius of 500 kilometers, and an initial ash dispersion speed of 20 meters per second that decays exponentially over time with a decay coefficient of 0.01 per second, what is the time required for the volcanic ash to disperse to the edge of the impact radius?",
    "query": "SELECT (20 / 0.01) * (1 - EXP(-0.01 * (500 * 1000 / 20))) AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 500;",
    "step": "【step1】:【Filter WarningEvent records with EventType 'volcanic eruption' and RadiusKm = 500】  【step2】:【Convert radius to meters (500 km → 500,000 meters) and calculate the base time component (500,000/20)】  【step3】:【Apply exponential decay formula: (20/0.01) * (1 - EXP(-0.01 * [base time])) to compute adjusted diffusion time】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 48,
    "question": "There are 1,000 records in the early warning event table, and the estimated damage (EstimatedDamageUSD) for each record follows a log-normal distribution. The known log mean (μ_ln) is 15, and the log standard deviation (σ_ln) is 2. Please calculate the percentage of events where the estimated damage exceeds $1,000,000,000.00 out of the total number of events, and further calculate the total estimated damage for these events.",
    "query": "WITH FilteredEvents AS (SELECT EstimatedDamageUSD FROM WarningEvent WHERE EstimatedDamageUSD > 1000000000.00) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, SUM(EstimatedDamageUSD) AS TotalDamageAboveThreshold FROM FilteredEvents;",
    "step": "【step1】: Filter event records in WarningEvent table where EstimatedDamageUSD exceeds 1,000,000,000.00 USD using a CTE (FilteredEvents).  【step2】: Calculate the count of filtered events (numerator) and their total EstimatedDamageUSD directly from FilteredEvents.  【step3】: Compute the percentage by dividing the filtered count by the total count from WarningEvent (denominator via subquery) and multiply by 100.0, then combine results with SUM aggregation.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 49,
    "question": "There is a record in the early warning event table with an event type of nuclear leak, a severity level of 10. Based on common knowledge, what emergency response measures might be taken for such an event? Please provide reasoning based on the emergency management of nuclear leakage disasters and analyze the long-term environmental impact on the affected areas.",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'nuclear leak' AND SeverityLevel = 10;",
    "step": "【step1】: Retrieve records from WarningRule table filtering by EventType='nuclear leak' and SeverityLevel=10  【step2】: Extract ActionType field from matched records",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 50,
    "question": "Assuming there is a record in the early warning event table with an impact radius of 100,000 kilometers, a severity level of 10, and estimated losses of $10,000,000,000,000.00. If the early warning system records data every millisecond and the event data remains at these extreme values for 365 days, how many times will the system trigger an early warning? The warning rule is defined as impact radius > 200 kilometers or severity level > 9 or estimated losses > $100,000,000.00.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
    "step": "【step1】: Filter all records within the time range '2023-01-01 00:00:00' to '2024-01-01 00:00:00' using the EventTime field.  【step2】: Apply the combined condition (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) to identify events violating any of the three thresholds.  【step3】: Aggregate the results by counting all matching rows to determine the total number of triggered warnings.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 51,
    "question": "If there is a record in the alert rule table where the event type is flood and the threshold value is 500, please calculate the time required to reach the alert threshold in hours assuming a rate of 10 units per hour.",
    "query": "SELECT ThresholdValue / 10 AS TimeToThresholdHours FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;",
    "step": "【step1】:【Filter WarningRule records where EventType is 'flood' and ThresholdValue equals 500】  【step2】:【Calculate TimeToThresholdHours by dividing ThresholdValue (500) by hourly rainfall rate (10)】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 52,
    "question": "There are 100 records in the alert rule table, each with threshold values (ThresholdValue) of 100, 200, 300, ..., 10,000 units, respectively. Calculate the percentage of rules where the threshold value exceeds 8,000 units out of the total number of rules.",
    "query": "SELECT (COUNT(CASE WHEN ThresholdValue > 8000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningRule;",
    "step": "【step1】: Calculate the number of rules where ThresholdValue exceeds 8000 using conditional aggregation  【step2】: Compute the total number of records in the WarningRule table  【step3】: Calculate the percentage by dividing the count from step1 by the count from step2 and multiplying by 100.0 to ensure floating-point precision",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 53,
    "question": "There is a record in the early warning rule table with an event type of fire, a threshold of 1000, and an action type of evacuation. What emergency response measures might this rule include?",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 1000 AND ActionType = 'evacuation';",
    "step": "【step1】: [Locate relevant rules] Access the WarningRule table and filter records where EventType is 'fire' to focus on fire-related rules  【step2】: [Apply threshold and action criteria] Refine the result by checking ThresholdValue = 1000 AND ActionType = 'evacuation' to isolate rules with specific temperature thresholds and evacuation actions  【step3】: [Extract response measures] Retrieve the ActionType field from the filtered records, which explicitly returns \"疏散\" while implicitly suggesting supplementary actions like activating emergency protocols, notifying authorities, deploying firefighters, and establishing safety perimeters based on fire emergency management practices.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 54,
    "question": "Assuming there is a record in the alert rule table with the event type \"nuclear leak,\" a threshold of 100,000 millisieverts (radiation dose), which is an extreme outlier (normal range is 0-100 millisieverts). If the alert system records data once per second and the event data remains at these extreme values for 365 days, how many alert records will be created in the WarningTriggerRecord table for this rule between '2023-01-01 00:00:00' and '2024-01-01 00:00:00'?",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'nuclear leak' AND ThresholdValue > 100 AND ThresholdUnit = 'millisieverts') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
    "step": "【step1】: Retrieve RuleId from WarningRule table where EventType is 'nuclear leak', ThresholdValue > 100, and unit is 'millisieverts' using a subquery.  【step2】: Count all records in WarningTriggerRecord that match the obtained RuleId.  【step3】: Filter these records by the time range '2023-01-01 00:00:00' to '2024-01-01 00:00:00' using BETWEEN clause.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 55,
    "question": "If there is a record in the early warning rule table with the event type as earthquake and a threshold value of 5.0 (Richter magnitude), please calculate the time required for the seismic waves to travel from the hypocenter to a monitoring station 100 km away, and analyze the relationship between magnitude and seismic wave energy.",
    "query": "SELECT 100 / 5 AS PropagationTimeSeconds, POWER(10, 1.5 * ThresholdValue + 4.8) AS EarthquakeEnergy FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue = 5.0;",
    "step": "【step1】: Filter records in WarningRule table where EventType is 'earthquake' and ThresholdValue is 5.0  【step2】: Calculate wave propagation time using formula (100 km / 5 km/s) as PropagationTimeSeconds  【step3】: Compute earthquake energy relationship using empirical formula POWER(10, 1.5*ThresholdValue+4.8) as EarthquakeEnergy",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 56,
    "question": "The table contains 1,000 alert rules with threshold values from 1.0 to 1000.0 units in increments of 1.0. What percentage of rules have threshold values exceeding 800.0 units, and what is the total sum of threshold values for these rules?",
    "query": "WITH FilteredRules AS (SELECT ThresholdValue FROM WarningRule WHERE ThresholdValue > 800.0) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningRule)) AS PercentageAboveThreshold, SUM(ThresholdValue) AS TotalThresholdAbove FROM FilteredRules;",
    "step": "【step1】:【Filter records with ThresholdValue > 800.0 using CTE】  【step2】:【Calculate percentage by dividing filtered count by total count from WarningRule】  【step3】:【Sum ThresholdValue for filtered records to get TotalThresholdAbove】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 57,
    "question": "Retrieve the action type for the warning rule where the event type is 'tsunami', the threshold value is 10, and the action type is 'evacuation'.",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'tsunami' AND ThresholdValue = 10 AND ActionType = 'evacuation';",
    "step": "【step1】: Access WarningRule table filtering by EventType='tsunami', ThresholdValue=10  【step2】: Validate ActionType='evacuation' matches tsunami-specific emergency protocols  【step3】: Cross-check ThresholdUnit consistency (meters for wave height) and disaster response logic",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 58,
    "question": "Assuming there is a record in the warning rule table with the event type being volcanic eruption and a threshold of 1000 kilometers (volcanic ash dispersion range), which is an extreme outlier (the normal range is 0-100 kilometers). If the warning system records data every millisecond and the event data remains at these extreme values for 365 days, how many times will the system trigger a warning? The warning rule is defined as a volcanic ash dispersion range > 100 kilometers, and the query counts warnings triggered between 2023-01-01 and 2024-01-01.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'volcanic eruption' AND ThresholdValue > 100 AND ThresholdUnit = 'kilometer') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
    "step": "【step1】: Execute subquery to get RuleId: SELECT Id FROM WarningRule WHERE EventType = 'volcanic eruption' AND ThresholdValue > 100 AND ThresholdUnit = 'kilometer'  【step2】: Filter WarningTriggerRecord by the retrieved RuleId and time range: WHERE RuleId = [subquery result] AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00'  【step3】: Aggregate the filtered records using COUNT(*) to calculate total triggers: SELECT COUNT(*) AS WarningCount",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 59,
    "question": "If there is a record in the alert rule table with the event type as flood and a threshold value of 500 millimeters (rainfall), please provide the required rainfall to reach the alert threshold.",
    "query": "SELECT ThresholdValue AS RequiredRainfall FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;",
    "step": "【step1】:【Select the ThresholdValue column and rename it as RequiredRainfall from the WarningRule table】  【step2】:【Filter records where EventType is 'flood' (flood) and ThresholdValue equals 500】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 60,
    "question": "There are 10 records in the alert rule table, with threshold values (ThresholdValue) of 100, 200, 300, 400, 500, 600, 700, 800, 900, and 1000 units respectively. Please calculate the average threshold value of these records.",
    "query": "SELECT AVG(ThresholdValue) AS AverageThresholdValue FROM WarningRule;",
    "step": "【step1】:【Access the WarningRule table and target the ThresholdValue column】  【step2】:【Apply the AVG() function to compute the mean of ThresholdValue across all records】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 61,
    "question": "The warning rules table contains a record with an event type of fire, a threshold of 100 degrees Celsius, and an action type of notification. What emergency response measures might be associated with this rule?",
    "query": "SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 100 AND ActionType = 'notification';",
    "step": "【step1】: Filter records in WarningRule table where EventType equals 'fire' using WHERE EventType = 'fire'  【step2】: Apply additional constraints to the filtered results: ThresholdValue = 100 AND ActionType = 'notification'  【step3】: Extract the ActionType field from the fully qualified records  Fire emergency response measures may include:  1. Immediate evacuation protocols  2. Activation of fire suppression systems  3. Emergency services notification (fire department/hospital)  4. Critical infrastructure shutdown (gas/electricity)  5. Mass notification through multiple channels (SMS/broadcast)  6. Crowd management and safe route guidance  7. Post-incident safety inspections  8. Data logging for incident analysis and rule optimization",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 62,
    "question": "Assuming there is a record in the warning rule table with the event type as earthquake, a threshold of 9.0 (Richter scale). If the early warning system records data once per second and the event data remains at 10.0, which is above the threshold, throughout 24 hours, how many warning alerts will the system trigger between '2023-01-01 00:00:00' and '2023-01-02 00:00:00'?",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue > 9.0 AND ThresholdUnit = 'Richter scale') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';",
    "step": "【step1】: Execute subquery to retrieve RuleId from WarningRule where EventType='earthquake' with ThresholdValue>9.0 and ThresholdUnit='Richter scale'  【step2】: Filter WarningTriggerRecord by matching RuleId from step1 and TriggerTime between '2023-01-01 00:00:00' and '2023-01-02 00:00:00'  【step3】: Count total matching records using COUNT(*) aggregation",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 63,
    "question": "If there is a record in the alert trigger log table with a trigger value of 1000, please calculate the time to trigger in hours by dividing the trigger value by 50.",
    "query": "SELECT TriggerValue / 50 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 1000;",
    "step": "【step1】: Access the WarningTriggerRecord table to locate entries where the TriggerValue equals 1000.  【step2】: Extract the TriggerValue field from the filtered record.  【step3】: Calculate TimeToTriggerHours by dividing the TriggerValue (1000 mm) by the rainfall rate (50 mm/h), yielding 20 hours as the result.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 64,
    "question": "The warning trigger record table contains 1,000 entries, with each entry's trigger value (TriggerValue) being 100, 200, 300, ..., 100,000 units, respectively. What percentage of records have a trigger value exceeding 80,000 units out of the total number of records?",
    "query": "SELECT (COUNT(CASE WHEN TriggerValue > 80000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningTriggerRecord;",
    "step": "【step1】:【Filter records where TriggerValue exceeds 80000】  【step2】:【Count qualified records and total records】  【step3】:【Calculate percentage using (qualified_count * 100.0 / total_count)】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 65,
    "question": "There is a record in the early warning trigger log with a trigger value of 100 degrees Celsius (temperature) and an action taken of evacuation. Based on common knowledge, what emergency response measures might be triggered by this? Please reason in conjunction with emergency management for high-temperature disasters.",
    "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';",
    "step": "【step1】: Filter WarningTriggerRecord where TriggerValue=100 and TriggerUnit='Celsius' to identify high-temperature triggers  【step2】: Further filter records where ActionTaken='evacuation' to isolate evacuation actions  【step3】: Retrieve ActionTaken field confirming the implemented emergency measure aligns with high-temperature disaster protocols",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 66,
    "question": "Assuming there is a record in the alert trigger log with a trigger value of 1,000,000 millisieverts (radiation dose), which is an extreme outlier (normal range is 0-100 millisieverts). If the alert system records data once per second and these extreme values persist for 365 days, how many alerts will the system trigger in 2023? The alert rule is defined as radiation dose > 100 millisieverts.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';",
    "step": "【step1】: Filter all records in WarningTriggerRecord where TriggerTime falls between '2023-01-01 00:00:00' and '2024-01-01 00:00:00'.  【step2】: Apply conditions TriggerValue > 100 and TriggerUnit = 'millisieverts' to the filtered temporal dataset.  【step3】: Calculate the total count of qualifying records using COUNT(*) as WarningCount.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 67,
    "question": "If there is a record in the early warning trigger log table with a trigger value of 5000 millimeters (rainfall), and the natural logarithm of the trigger value divided by 0.0001 is divided by 0.1 to determine the time in hours to reach the trigger value, what is the calculated time and how does the rainfall change over time under an exponential growth model?",
    "query": "SELECT LN(TriggerValue / 0.0001) / 0.1 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 5000;",
    "step": "【step1】: Filter records with TriggerValue=5000 using WHERE clause to isolate the specific exponential growth scenario  【step2】: Apply natural logarithm LN(5000/0.0001) to calculate exponent component in growth formula V(t)=V0*e^(0.1t)  【step3】: Divide logarithmic result by growth coefficient 0.1 to derive time-to-trigger in hours while demonstrating exponential growth trend analysis",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 68,
    "question": "The warning trigger log table contains 10,000 records, and the trigger value (TriggerValue) of each record follows a lognormal distribution. It is known that the logarithmic mean (μ_ln) is 10 and the logarithmic standard deviation (σ_ln) is 2. Please use the SQL query to calculate the percentage of records with trigger values exceeding 100,000 units out of the total number of records, and further compute the sum of the trigger values for these records.",
    "query": "WITH FilteredRecords AS (SELECT TriggerValue FROM WarningTriggerRecord WHERE TriggerValue > 100000) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningTriggerRecord)) AS PercentageAboveThreshold, SUM(TriggerValue) AS TotalTriggerValueAbove FROM FilteredRecords;",
    "step": "【step1】: Create CTE FilteredRecords to select records with TriggerValue exceeding 100,000  【step2】: Calculate percentage by dividing filtered count by total count via subquery  【step3】: Compute total sum of TriggerValue from filtered records",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 69,
    "question": "There is a record in the early warning trigger log with a trigger value of 1000°C (temperature) and an action type of evacuation. Based on common sense, what emergency response measures might be triggered? Please infer by combining emergency management for extreme heat disasters and analyze the impacts of high temperatures on the environment and human health.",
    "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';",
    "step": "【step1】: Access WarningTriggerRecord table and filter records where TriggerValue=1000 AND TriggerUnit='Celsius'  【step2】: Apply additional filter condition ActionTaken='evacuation' to isolate evacuation actions  【step3】: Extract ActionTaken column values from fully filtered records",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 70,
    "question": "In the warning trigger log table, what action was taken for the record with a trigger value of 1000°C (temperature) and an action type of evacuation?",
    "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';",
    "step": "【step1】: Filter records in WarningTriggerRecord where TriggerValue equals 1000 and TriggerUnit is 'Celsius'.  【step2】: Apply an additional filter to select only records where ActionTaken is 'evacuation'.  【step3】: Retrieve the ActionTaken field from the filtered results.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 71,
    "question": "If there is a record in the alert trigger log table with a trigger value of 100 millimeters, please calculate the required time to reach the trigger value in hours.",
    "query": "SELECT TriggerValue / 10 AS RequiredTime FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'millimeters';",
    "step": "【step1】: Filter records from WarningTriggerRecord where TriggerValue is 100 millimeters using the WHERE clause with conditions `TriggerValue = 100 AND TriggerUnit = 'millimeters'`.  【step2】: Calculate the required rainfall time by dividing the TriggerValue (100) by the rainfall rate (10 mm/hour), expressed as `TriggerValue / 10 AS RequiredTime`.  【step3】: Extract the computed result (RequiredTime) directly from the filtered record without additional joins or sorting.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 72,
    "question": "There are 10 records in the warning trigger log table, with trigger values (TriggerValue) of 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 units respectively. Please calculate the average trigger value for these records.",
    "query": "SELECT AVG(TriggerValue) AS AverageTriggerValue FROM WarningTriggerRecord WHERE TriggerValue IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);",
    "step": "【step1】:【Filter records from WarningTriggerRecord where TriggerValue is in the specified list (100, 200, ..., 1000) using the WHERE clause】  【step2】:【Apply the AVG() function to calculate the average of the TriggerValue column from the filtered records】  【step3】:【Assign the result column alias AverageTriggerValue using the AS keyword】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 73,
    "question": "There is a record in the early warning trigger log with a trigger value of 50 degrees Celsius (temperature) and the action taken as notification. Based on common knowledge, what emergency response measures might this trigger include? Please reason based on emergency management of high-temperature disasters.",
    "query": "SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 50 AND TriggerUnit = 'Celsius' AND ActionTaken = 'notification';",
    "step": "【step1】: Retrieve the triggered rule's action type by joining WarningTriggerRecord with WarningRule using RuleId, verifying the 50°C threshold corresponds to high-temperature events.  【step2】: Cross-reference WarningEvent's SeverityLevel and PopulationAffected to determine required escalation steps (e.g., public alerts for SeverityLevel≥7 or large populations).  【step3】: Analyze HistoricalDataAnalysis.FalseAlarmRate to validate reliability before recommending extended actions like evacuation/equipment deployment.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 74,
    "question": "Assuming there is a record in the alarm trigger log with a trigger value of 1000 millisieverts (radiation dose), which is an extreme outlier (normal range is 0-100 millisieverts). If the alarm system records data once per second and the event data remains at these extreme values for 24 hours, how many alarms will the system trigger between October 1, 2023, 00:00:00 and October 2, 2023, 00:00:00? Assume the alarm rule is radiation dose > 100 millisieverts and the unit is millisieverts.",
    "query": "SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
    "step": "【step1】: Filter records within the 24-hour period using `TriggerTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00'` to isolate data from the specified time range.  【step2】: Apply dual conditions `TriggerValue > 100` and `TriggerUnit = 'millisieverts'` to select records exceeding the radiation threshold with correct units.  【step3】: Aggregate results using `COUNT(*)` to calculate the total number of valid warning triggers as `WarningCount`.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 75,
    "question": "If there is a record in the warning notification table with the notification method as broadcast, the propagation speed of the broadcast signal is 3^8 meters/second, and the receiver is 100 meters away from the notification source, please calculate the time required for the broadcast signal to propagate from the notification source to the receiver.",
    "query": "SELECT (100 * 1000) / POW(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';",
    "step": "【step1】: Filter records from WarningNotificationRecord where NotificationMethod is 'broadcast' using the WHERE clause  【step2】: Calculate propagation time for each matching record using (100*1000)/POW(3,8) formula  【step3】: Return computed PropagationTime value for all qualified records as result set",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 76,
    "question": "The warning notification record table contains 1,000 entries. Assuming the number of recipients follows a normal distribution with a mean of 50,500 and a standard deviation of 28,722.81, calculate the percentage of notification records where the number of recipients exceeds 80,000 people out of the total number of notification records.",
    "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 80000;",
    "step": "【step1】: Filter records with RecipientCount > 80000 using WHERE clause.  【step2】: Calculate the count of filtered records (numerator) and total record count via subquery (denominator).  【step3】: Compute percentage by dividing numerator by denominator and multiplying by 100.0.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 77,
    "question": "In the early warning notification records table, there is a record where the notification method is SMS and the recipient type is people. Based on common sense, what emergency response measures might this type of notification include? Please reason by combining emergency management for SMS notifications.",
    "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'people';",
    "step": "【step1】: Execute base query to retrieve notification content targeting general public via SMS from WarningNotificationRecord  【step2】: Join with WarningEvent via EventID to obtain event type (e.g. earthquake/flood) and severity level  【step3】: Cross-reference WarningRule thresholds and action types based on event characteristics to infer emergency measures: evacuation protocols, shelter locations, emergency contact numbers, resource distribution points, real-time situation updates, and safety precaution reminders.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 78,
    "question": "Assuming there is a record in the alert notification log with a recipient count of 1,000,000,000, which is an extreme outlier (normal range is 0–1,000,000). If the alert system records data once per second and maintains these extreme values continuously for 365 days, how many times would the system trigger notifications? The notification rule is: recipient count > 1,000,000 and the notification time is within the year 2023.",
    "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
    "step": "【step1】: Filter all records in WarningNotificationRecord where NotificationTime falls within the entire year 2023 (2023-01-01 00:00:00 to 2023-12-31 23:59:59).  【step2】: Apply the condition RecipientCount > 1000000 to the filtered records from Step 1.  【step3】: Count the total number of matching rows from Step 2 and return it as NotificationCount.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 79,
    "question": "If there is a record in the alert notification table with a notification method as broadcast, the propagation speed of the broadcast signal is the speed of light (approximately 3×10^8 meters per second), and the receiver is 1000 meters away from the notification source. Considering the atmospheric attenuation of signal propagation with an attenuation coefficient of 0.001 per meter, calculate the time required for the broadcast signal to propagate from the notification source to the receiver and analyze the attenuation of signal strength.",
    "query": "SELECT (1000 * 1000) / POW(3, 8) AS PropagationTime, EXP(-0.001 * 1000) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';",
    "step": "【step1】:【Filter the notification record with 'broadcast' method】  【step2】:【Calculate propagation time by dividing converted distance (1000km to meters) by speed of light】  【step3】:【Compute signal attenuation using exponential decay formula with given coefficient and distance】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 80,
    "question": "In the warning notification record table, please calculate the percentage of notification records where the number of recipients exceeds 1,000,000 out of the total number of notification records. Additionally, calculate the total sum of recipients for these records.",
    "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage, SUM(RecipientCount) AS TotalRecipients FROM WarningNotificationRecord WHERE RecipientCount > 1000000;",
    "step": "【step1】: Filter records from WarningNotificationRecord where RecipientCount exceeds 1,000,000 using the WHERE clause.  【step2】: Calculate total records count via subquery (SELECT COUNT(*) FROM WarningNotificationRecord) to serve as the denominator for percentage calculation.  【step3】: Compute final results by combining filtered COUNT(*) (numerator) with total count to derive percentage, and sum RecipientCount for qualifying records using aggregate functions.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 81,
    "question": "What does the NotificationContent contain for records where the NotificationMethod is 'broadcast' and the RecipientType is 'people'?",
    "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast' AND RecipientType = 'people';",
    "step": "【step1】: Filter records from WarningNotificationRecord where NotificationMethod is 'broadcast' (broadcast) and RecipientType is 'people' (public) using the WHERE clause conditions  【step2】: Join with WarningEvent via EventId to contextualize the emergency type (e.g., earthquake, flood) and severity level  【step3】: Join with WarningTriggerRecord via TriggerId to retrieve associated actions (ActionTaken) and severity thresholds, then extract NotificationContent for广播-based emergency protocols",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 82,
    "question": "Assuming there is a record in the warning notification record table where the number of recipients is 10,000,000 and occurs every millisecond between '2023-01-01 00:00:00.000' and '2023-12-31 23:59:59.999', how many notifications would the system count?",
    "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';",
    "step": "【step1】: Filter all records in WarningNotificationRecord where RecipientCount exceeds 1,000,000 using the predicate `RecipientCount > 1000000`.  【step2】: Apply the time filter `NotificationTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999'` to restrict results to the 2023 calendar year.  【step3】: Calculate the total number of matching rows using `COUNT(*)`, resulting in the final count of notifications triggered (one per millisecond × 365 days).",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 83,
    "question": "If there is a record in the early warning notification log table with the notification method as SMS, where the SMS signal propagates at a speed of 3^8 meters per second, and the recipient is 10,000 meters away from the notification source, please calculate the time required for the SMS signal to travel from the notification source to the recipient.",
    "query": "SELECT (10 * 1000) / POW(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS';",
    "step": "【step1】: Filter records from WarningNotificationRecord where NotificationMethod is 'SMS'  【step2】: Convert 10 kilometers to meters (10*1000)  【step3】: Calculate propagation time using (distance_in_meters)/(3*10^8) with corrected formula: (10*1000)/(3*POWER(10,8)) instead of incorrect POW(3,8)",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 84,
    "question": "There are 10 records in the early warning notification log, with the number of recipients (RecipientCount) for each record being 100, 200, 300, 400, 500, 600, 700, 800, 900, and 1000 people respectively. Please calculate the average number of recipients for these records.",
    "query": "SELECT AVG(RecipientCount) AS AverageRecipientCount FROM WarningNotificationRecord WHERE RecipientCount IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);",
    "step": "【step1】: Filter records from WarningNotificationRecord where RecipientCount matches the specified values (100, 200, ..., 1000) using the IN clause.  【step2】: Apply the AVG() function to calculate the average of the filtered RecipientCount values.  【step3】: Assign the calculated average to the alias \"AverageRecipientCount\" using the AS keyword.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 85,
    "question": "There is a record in the early warning notification log where the notification method is email and the recipient type is an enterprise. Based on common knowledge, what emergency response measures might such a notification include? Please make inferences in conjunction with the emergency management of email notifications.",
    "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'email' AND RecipientType = 'enterprise';",
    "step": "【step1】:Execute query to retrieve NotificationContent containing emergency instructions for enterprise email alerts  【step2】:Join WarningNotificationRecord with WarningEvent via EventId to obtain event specifics (SeverityLevel,Location,RadiusKm)  【step3】:Cross-reference with WarningRule through RuleId to determine applicable ActionType and Severity-based protocols",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 86,
    "question": "Assuming there is a record in the warning notification log with 1,000,000 recipients, which is an extreme outlier (normal range being 0-100,000 recipients). If the warning system records data once per second and these extreme values persist for 24 hours, how many times will the system trigger notifications? Assume the notification rule is triggered when the recipient count exceeds 100,000 and the count is for records within a specific 24-hour period starting from October 1, 2023.",
    "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 100000 AND NotificationTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
    "step": "【step1】: Filter records within the 24-hour time range (NotificationTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00').  【step2】: Apply the RecipientCount > 100,000 condition to identify extreme values.  【step3】: Count all qualifying rows (COUNT(*)) to determine the total notifications triggered (86,400 times, as 1 record/second × 86,400 seconds/day).",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 87,
    "question": "If there is a record in the warning notification log where the notification method is broadcast, the propagation speed of the broadcast signal is 3^8 (6561) units per second, and the receiver is 500 units away from the notification source, while also considering the signal attenuation with a factor of 0.0005 per unit distance at 500 units. Please calculate the time required for the broadcast signal to propagate from the notification source to the receiver and analyze the attenuation of the signal strength.",
    "query": "SELECT (500 * 1000) / POW(3, 8) AS PropagationTime, EXP(-0.0005 * 500) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';",
    "step": "【step1】: Filter records where NotificationMethod is 'Broadcast' using WHERE clause  【step2】: Calculate propagation time with (500,000 meters)/(3^8 m/s) using arithmetic operations  【step3】: Compute signal attenuation using EXP(-0.0005*500) exponential decay formula",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 88,
    "question": "There are 1,000 records in the WarningNotificationRecord table. Given that the recipient counts follow a normal distribution with a mean of 500,500 and a standard deviation of 288,675.1, calculate the percentage of notification records with recipient counts exceeding 800,000 out of the total number of notification records.",
    "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 800000;",
    "step": "【step1】: Execute the subquery `(SELECT COUNT(*) FROM WarningNotificationRecord)` to calculate the total number of notification records (1000).  【step2】: Filter records with `RecipientCount > 800000` and calculate the count using `COUNT(*)`.  【step3】: Compute the percentage by dividing the filtered count by the total count from Step 1 and multiplying by `100.0`.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 89,
    "question": "There is a record in the early warning notification log where the notification method is SMS and the recipient type is government. Based on common knowledge, what emergency response measures might this type of notification include? Please reason by considering the emergency management aspects of SMS notifications.",
    "query": "SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'government';",
    "step": "【step1】:【Filter records in WarningNotificationRecord where NotificationMethod is 'SMS' and RecipientType is 'government'】  【step2】:【Extract the NotificationContent field from the filtered records】  【step3】:【Return the emergency response measures described in the NotificationContent, which typically include evacuation orders, resource deployment instructions, emergency shelter locations, real-time monitoring updates, inter-departmental coordination directives, and public communication protocols based on government emergency management procedures】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 90,
    "question": "Assuming there is a record in the alert notification log with a recipient count of 100,000,000, which is an extreme outlier (normal range is 0-1,000,000 people). If the alert system records data once per second and these extreme values persist for 365 days, how many times will the system trigger notifications? The notification rule is set for recipient counts > 1,000,000 people, and the query counts notifications in the year 2023.",
    "query": "SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
    "step": "【step1】: Filter all records in WarningNotificationRecord where NotificationTime falls within the entire year of 2023 (2023-01-01 00:00:00 to 2023-12-31 23:59:59)  【step2】: Apply the condition RecipientCount > 1,000,000 to the filtered records  【step3】: Calculate the total count of qualifying records using COUNT(*) as NotificationCount",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 91,
    "question": "If there is a record in the historical data analysis table with the event type as flood, the average severity as 7, and the flood wave propagation speed recorded as 5 meters/second, please calculate the time required for the flood wave to propagate from the event location to a monitoring station 100 kilometers away.",
    "query": "SELECT (100 * 1000) / 5 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 7;",
    "step": "【step1】: Filter the HistoricalDataAnalysis table to retrieve records where EventType is 'flood' and AverageSeverity equals 7.  【step2】: Calculate the propagation time by dividing the distance (100 kilometers converted to 100,000 meters) by the given speed of 5 meters per second.  【step3】: Return the calculated result as the PropagationTime column in the output.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 92,
    "question": "Assuming the average severity follows a normal distribution with a mean of 5.5 and a standard deviation of 2.872, calculate the percentage of records whose average severity exceeds 8.0 relative to the total number of records.",
    "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;",
    "step": "【step1】: Calculate total number of records using subquery: (SELECT COUNT(*) FROM HistoricalDataAnalysis)  【step2】: Count records where AverageSeverity > 8.0 in main query: COUNT(*) FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0  【step3】: Calculate percentage by dividing qualified count (step2) by total count (step1), then multiply by 100.0",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 93,
    "question": "In the historical data analysis table, there is a record with an event type of earthquake, an average severity of 6, and a false alarm rate of 5. Based on common knowledge, what emergency response measures might be taken for such an event? Please reason by combining emergency management for earthquake disasters.",
    "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'earthquake' AND AverageSeverity = 6 AND FalseAlarmRate = 5;",
    "step": "【step1】: Filter records in HistoricalDataAnalysis table where EventType='earthquake', AverageSeverity=6, and FalseAlarmRate=5 using WHERE clause  【step2】: Select the AnalysisResult field from the filtered records  【step3】: Verify result uniqueness since multiple records might meet severe earthquake criteria with identical analysis parameters",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 94,
    "question": "How many records in the HistoricalDataAnalysis table have a TotalEvents value greater than 10,000 and an AnalysisTime within the year 2023?",
    "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
    "step": "【step1】: Filter all records in HistoricalDataAnalysis where AnalysisTime is within the specified year (2023-01-01 to 2023-12-31).  【step2】: Apply the condition TotalEvents > 10000 to identify extreme values.  【step3】: Count the number of matching records (31,536,000, equal to total seconds in 365 days) since every second's record satisfies the condition.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 95,
    "question": "If there is a record in the historical data analysis table where the event type is a tsunami and the maximum severity is 10, please calculate the time required for the tsunami wave to propagate 1000 kilometers at a speed of 200 meters/second and analyze the energy attenuation over 1000 kilometers with an attenuation coefficient of 0.01.",
    "query": "SELECT (1000 * 1000) / 200 AS PropagationTime, EXP(-0.01 * 1000) AS EnergyAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'tsunami' AND MaxSeverity = 10;",
    "step": "【step1】: Filter records from HistoricalDataAnalysis where EventType is 'tsunami' and MaxSeverity equals 10  【step2】: Calculate propagation time by converting 1000km to meters (1000*1000) and dividing by wave speed 200 m/s  【step3】: Compute energy attenuation using exponential decay formula EXP(-0.01*1000) based on given coefficient 0.01/km over 1000km distance",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 96,
    "question": "The historical data analysis table contains 10,000 records. The average severity (AverageSeverity) of each record follows a lognormal distribution, with a known log mean (μ_ln) of 1.5 and a log standard deviation (σ_ln) of 0.5. Please calculate the percentage of records with an average severity exceeding 8.0 out of the total number of records, and further compute the total sum of average severity for these records.",
    "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage, SUM(AverageSeverity) AS TotalAverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;",
    "step": "【step1】:【Filter records where AverageSeverity exceeds 8.0】  【step2】:【Calculate percentage using subquery (COUNT of filtered records ×100 / total COUNT)】  【step3】:【Compute total sum of qualifying AverageSeverity values and combine results】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 97,
    "question": "There is a record in the historical data analysis table with an event type of nuclear leak, a maximum severity level of 10, and a false alarm rate of 0.1. Based on common knowledge, what emergency response measures might be taken for such an event? Please reason in the context of emergency management for nuclear leakage disasters and analyze the long-term impacts of nuclear leakage on the environment and human health.",
    "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'nuclear leak' AND MaxSeverity = 10 AND FalseAlarmRate = 0.1;",
    "step": "【step1】: Access HistoricalDataAnalysis table with EventType='nuclear leak' filter  【step2】: Apply MaxSeverity=10 and FalseAlarmRate=0.1 filters on results  【step3】: Extract AnalysisResult column from fully filtered dataset",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 98,
    "question": "Suppose there is a record in the historical data analysis table with a total event count of 10,000,000,000, which is an extreme outlier (the normal range is 0-10,000). If the warning system logs data every millisecond and the event data remains at these extreme values for the entire year 2023, how many analyses will the system trigger? Assume the analysis rule is a total event count > 10,000.",
    "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';",
    "step": "【step1】: Filter all records in `HistoricalDataAnalysis` where `AnalysisTime` falls between '2023-01-01 00:00:00.000' and '2023-12-31 23:59:59.999'.  【step2】: Apply the condition `TotalEvents > 10000` to the filtered records.  【step3】: Calculate the total count of qualifying records using `COUNT(*)` and return it as `AnalysisCount`.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 99,
    "question": "If there is a record in the historical data analysis table with an event type of \"volcanic eruption\" and a maximum severity level of 9, calculate the time taken for volcanic ash to diffuse 500 kilometers at a speed of 10 meters per second and the resulting concentration attenuation.",
    "query": "SELECT (500 * 1000) / 10 AS DiffusionTime, EXP(-0.005 * ((500 * 1000) / 10)) AS ConcentrationAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'volcanic eruption' AND MaxSeverity = 9;",
    "step": "【step1】: Filter records in HistoricalDataAnalysis where EventType is 'volcanic eruption' and MaxSeverity equals 9  【step2】: Calculate diffusion time by dividing 500km (converted to 500,000 meters) by the speed of 10m/s: (500*1000)/10  【step3】: Compute concentration attenuation using exponential decay formula EXP(-0.005*diffusion_time) with the calculated time from Step 2",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 100,
    "question": "The historical data analysis table contains 1,000 records, with the maximum severity (MaxSeverity) of each record being 1.0, 2.0, 3.0, ..., 10.0. It is known that the overall average of the maximum severity is 5.5, and the overall standard deviation is 2.872. Assuming the maximum severity follows a normal distribution, calculate the percentage of records where the maximum severity exceeds 8.0 relative to the total number of records.",
    "query": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE MaxSeverity > 8.0;",
    "step": "【step1】: Calculate total record count using subquery (SELECT COUNT(*) FROM HistoricalDataAnalysis)  【step2】: Filter records with MaxSeverity > 8.0 and calculate matching count (COUNT(*))  【step3】: Compute percentage by dividing filtered count by total count and multiplying by 100",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 101,
    "question": "In the historical data analysis table, there is a record with the event type as tornado, a maximum severity of 8, and a false alarm rate of 2. What emergency response measures might be applicable for such an event based on the data? Please reason in conjunction with the emergency management of tornado disasters.",
    "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'tornado' AND MaxSeverity = 8 AND FalseAlarmRate = 2;",
    "step": "【step1】: Access HistoricalDataAnalysis table to retrieve analysis results for tornado events  【step2】: Filter records where EventType='tornado' (tornado) and MaxSeverity=8 (highest severity level in this context)  【step3】: Apply final filter with FalseAlarmRate=2% and extract AnalysisResult containing emergency response recommendations",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 102,
    "question": "If the system records data once per second and the event count consistently exceeds 10,000 for 365 days, how many times will the analysis be triggered?",
    "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';",
    "step": "【step1】: Filter records from HistoricalDataAnalysis where AnalysisTime falls within the 2023 calendar year  【step2】: Apply the condition TotalEvents > 10000 to the filtered records  【step3】: Count all remaining records with COUNT(*) and alias as AnalysisCount",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 103,
    "question": "If there is a record in the historical data analysis table with the event type being flood and an average severity of 5, calculate the time required for the flood wave to travel 50 kilometers.",
    "query": "SELECT (50 * 1000) / 2 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 5;",
    "step": "【step1】:【Filter records from HistoricalDataAnalysis where EventType is 'flood' and AverageSeverity equals 5】  【step2】:【Convert 50 kilometers to meters (50 * 1000) to align with the speed unit (meters/second)】  【step3】:【Calculate propagation time by dividing the converted distance (50,000 meters) by the given speed (2 m/s)】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 104,
    "question": "There are 10 records in the historical data analysis table, with each record's average severity (AverageSeverity) being 1.0, 2.0, 3.0, ..., 10.0 respectively. Please calculate the average severity of these records.",
    "query": "SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0);",
    "step": "【step1】:【Filter records with AverageSeverity between 1.0 to 10.0 using WHERE clause and IN operator】  【step2】:【Calculate mathematical average of the filtered AverageSeverity values using AVG() function】  【step3】:【Alias the calculated result as AverageSeverity using AS keyword for clear output labeling】",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 105,
    "question": "In the historical data analysis table, there is a record with an event type of fire, an average severity level of 4, and a false alarm rate of 3. Based on common knowledge, what emergency response measures might be applicable for such an event? Please reason by combining emergency management for fire disasters.",
    "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 4 AND FalseAlarmRate = 3;",
    "step": "【step1】: Filter the HistoricalDataAnalysis table by EventType='fire' to isolate fire-related historical records  【step2】: Apply additional filters for AverageSeverity=4 and FalseAlarmRate=3% to pinpoint the specific analysis record  【step3】: Retrieve the AnalysisResult field containing predefined emergency response recommendations tied to fire events with these parameters  【step1】: Activate evacuation protocols for affected areas (determined by RadiusKm and PopulationAffected) based on severity level 4  【step2】: Deploy firefighting resources and emergency medical teams using Location/Latitude/Longitude data from linked WarningEvent records  【step3】: Initiate public alerts via NotificationMethod=广播 (broadcast) to RecipientType=公众 while validating system accuracy through FalseAlarmRate analysis",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 106,
    "question": "Assuming there is a record in the historical data analysis table with a total event count of 100,000, which is an extreme outlier (the normal range is 0-10,000). If the alert system records data every second and the event data remains at these extreme values for 24 hours, how many times will the system trigger an analysis between '2023-10-01 00:00:00' and '2023-10-02 00:00:00'? Assume the analysis rule is that the total event count > 10,000.",
    "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
    "step": "【step1】: Filter records within the specified 24-hour time range using the `BETWEEN` condition on `AnalysisTime`.  【step2】: Apply the threshold condition `TotalEvents > 10000` to identify extreme values.  【step3】: Count the total matching records to determine the number of triggered analyses with `COUNT(*)`.",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "1",
    "idx": 107,
    "question": "If there is an earthquake event in the WarningEvent table with a radius of 20 kilometers, what is the propagation time of the seismic waves?",
    "query": "SELECT RadiusKm / 5 AS PropagationTime FROM WarningEvent WHERE EventType = 'earthquake';",
    "step": "【step1】: Access the WarningEvent table to retrieve earthquake-related records  【step2】: Filter records where EventType = 'earthquake' (Earthquake)  【step3】: Calculate PropagationTime using formula (RadiusKm / 5) from remaining record(s)",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "2",
    "idx": 108,
    "question": "There are 5 records in the historical data analysis table, with an average severity (AverageSeverity) of 1.0, 2.0, 3.0, 4.0, and 5.0 for each record respectively. Please calculate the average severity of these records.",
    "query": "SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0);",
    "step": "【step1】: Filter records from HistoricalDataAnalysis where AverageSeverity matches the specified values (1.0, 2.0, 3.0, 4.0, 5.0) using the IN clause  【step2】: Calculate the average of the filtered AverageSeverity values using the AVG aggregation function",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "3",
    "idx": 109,
    "question": "There is a record in the historical data analysis table with an event type of fire, an average severity level of 3, and a false alarm rate of 1. Based on common sense, what possible emergency response measures might be taken for such an event? Please reason accordingly in the context of emergency management for fire disasters.",
    "query": "SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 3 AND FalseAlarmRate = 1;",
    "step": "【step1】: Access HistoricalDataAnalysis table to filter records where EventType is 'fire' (fire)  【step2】: Apply compound conditions: AverageSeverity = 3 AND FalseAlarmRate = 1%  【step3】: Extract AnalysisResult column containing pre-concluded emergency protocols  Typical emergency responses inferred:  1. Activate fire containment protocols  2. Dispatch firefighting teams and EMS  3. Evacuate within radius per WarningRule.RadiusKm  4. Issue public alerts via WarningNotificationRecord methods  5. Coordinate with WarningRule.ActionType = 'evacuation' (evacuation)  6. Monitor via WarningTriggerRecord.TriggerValue thresholds  7. Validate using HistoricalDataAnalysis.FalseAlarmRate to optimize resource deployment",
    "format": "MySQL"
  },
  {
    "db_id": "AlarmSystem",
    "type": "4",
    "idx": 110,
    "question": "Assuming there is a record in the historical data analysis table with a total event count of 20,000 (normal range is 0-10,000) and the event data remains at this value for 24 hours, how many analyses would be counted for the period between 2023-10-01 00:00:00 and 2023-10-02 00:00:00 if the analysis rule is total event count > 10,000?",
    "query": "SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';",
    "step": "【step1】: Filter records from HistoricalDataAnalysis table where AnalysisTime falls within the 24-hour period between '2023-10-01 00:00:00' and '2023-10-02 00:00:00'.  【step2】: Apply the condition TotalEvents > 10000 to exclude records within the normal range (0-10,000 events).  【step3】: Count all remaining records using COUNT(*) to determine the number of times the analysis would be triggered, where each second's data point meeting the threshold counts as one trigger.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "1",
    "idx": 111,
    "question": "It is known that the Golden Gate Bridge has a vibration frequency of 0.2 Hz and a length of 2737 meters. The Moulin de Bruges has a blade length of 14 meters and a rotation speed of 20 revolutions per minute. Please calculate the maximum amplitude of the Golden Gate Bridge and the linear velocity of the blade tip of the Moulin de Bruges.",
    "query": "SELECT (20 / (2 * 3.14159 * (SELECT Vibration_Frequency FROM bridge WHERE Name = 'Golden Gate Bridge'))) * ((SELECT Length_Meters FROM bridge WHERE Name = 'Golden Gate Bridge') / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * (SELECT Blade_Length FROM mill WHERE Name = 'Moulin de Bruges') * ((SELECT Rotation_Speed FROM mill WHERE Name = 'Moulin de Bruges') / 60) AS Moulin_Tip_Speed;",
    "step": "【step1】: Retrieve Golden Gate Bridge's vibration frequency (0.2 Hz) and length (2737 m) via subqueries from the bridge table.  【step2】: Fetch Moulin de Bruges's blade length (14 m) and rotation speed (20 RPM) via subqueries from the mill table.  【step3】: Calculate max amplitude using (20/(2πf))*(L/1000) and tip speed using 2πr*(RPM/60) with the retrieved values.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "2",
    "idx": 112,
    "question": "It is known that the length of the Brooklyn Bridge is 1834 meters, with a maximum load-bearing capacity of 2,000,000 kilograms; the power output of Moulin de Fexhe is 7.5 kilowatts at a wind speed of 6 meters per second. Please calculate the average load-bearing weight per meter length of the Brooklyn Bridge, and the energy conversion efficiency of Moulin de Fexhe at a wind speed of 6 meters per second.",
    "query": "SELECT (Load_Capacity / Length_Meters) AS Avg_Load_Per_Meter, (Power_Output / (0.5 * 1.225 * (3.14159 * POW(Blade_Length, 2)) * POW(Wind_Speed, 3))) * 100 AS Energy_Efficiency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';",
    "step": "【step1】: Filter the Brooklyn Bridge record from the bridge table and calculate Load_Capacity / Length_Meters as Avg_Load_Per_Meter.  【step2】: Filter the Moulin de Fexhe record from the mill table and compute energy efficiency using Power_Output divided by theoretical wind power formula (0.5*air_density*rotor_area*wind_speed³).  【step3】: Perform an implicit CROSS JOIN between the two filtered results (since tables aren't relationally connected) to combine both calculations in a single row output.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "3",
    "idx": 113,
    "question": "It is known that the construction cost of the Millau Viaduct is $400,000,000, the annual maintenance cost is $2,000,000, and the maintenance period is 100 years; the construction cost of the Moulin de Momalle is $80,000, the annual maintenance cost is $3,000, and the maintenance period is 50 years. Please calculate the total costs of the Millau Viaduct and the Moulin de Momalle respectively.",
    "query": "SELECT Cost_Usd + (Maintenance_Cost * 100) AS Total_Cost_Millau_Viaduct, (SELECT Cost_Usd + (Maintenance_Cost * 50) FROM mill WHERE Name = 'Moulin de Momalle') AS Total_Cost_Moulin_de_Momalle FROM bridge WHERE Name = 'Millau Viaduct';",
    "step": "【step1】: Retrieve the Millau Viaduct's construction cost and calculate its total cost by adding 100 years of maintenance costs from the bridge table.  【step2】: Use a subquery to separately retrieve the Moulin de Momalle's construction cost and calculate its total cost with 50 years of maintenance costs from the mill table.  【step3】: Combine both calculations into a single result row by aligning the subquery result with the main query's output column.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "4",
    "idx": 114,
    "question": "Assuming the Golden Gate Bridge has a vibration frequency of 100 Hz and a length of 100,000 meters, and the blade length of the Moulin de Bruges is 1,000 meters with a rotation speed of 1,000 revolutions per minute, please calculate the maximum amplitude of the Golden Gate Bridge and the linear velocity at the blade tip of the Moulin de Bruges.",
    "query": "SELECT (1000 / (2 * 3.14159 * 100)) * (100000 / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * 1000 * (1000 / 60) AS Moulin_Tip_Speed;",
    "step": "【step1】: Calculate Golden Gate Bridge's maximum amplitude using formula: (wind_speed / (2π * vibration_frequency)) * (bridge_length / 1000). Substitute values (1000/(2π*100))*(100000/1000).  【step2】: Calculate Moulin de Bruges' blade tip speed using formula: 2π * blade_length * (rotation_speed/60). Substitute values 2π*1000*(1000/60).  【step3】: Combine both calculations into a single SELECT statement to output results as two separate columns.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "1",
    "idx": 115,
    "question": "It is known that the Millau Viaduct has a span of 342 meters, a height of 343 meters, and is made of concrete. Please calculate the wind load on the Millau Viaduct at a wind speed of 10 meters per second (assuming an air density of 1.225 kg/m³).",
    "query": "SELECT 0.5 * 1.225 * POW(10, 2) * Span_Length * Height_Meters AS Wind_Load, 0.5 * (14 * 50) * POW(2 * 3.14159 * 14 * (20 / 60), 2) AS Blade_Kinetic_Energy FROM bridge WHERE Name = 'Millau Viaduct';",
    "step": "【step1】: Retrieve the record for 'Millau Viaduct' from the bridge table using the WHERE clause.  【step2】: Calculate Wind_Load using the formula 0.5 * air_density * wind_speed² * Span_Length * Height_Meters with hardcoded values (1.225 kg/m³, 10 m/s) and columns span_length_meters/height_meters.  【step3】: Compute Blade_Kinetic_Energy via the formula 0.5 * mass * velocity², where mass is hardcoded (14m * 50 kg/m), and velocity derives from blade rotation parameters (blade length 14m, 20 RPM converted to angular speed).",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "2",
    "idx": 116,
    "question": "It is known that the construction cost of the Golden Gate Bridge is $35,000,000, with an annual maintenance cost of $1,000,000; the construction cost of the Moulin de Momalle is $80,000, with an annual maintenance cost of $3,000. Please calculate the ratio of the maintenance cost to the construction cost for both the Golden Gate Bridge and the Moulin de Momalle.",
    "query": "SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM bridge WHERE Name = 'Golden Gate Bridge' UNION ALL SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM mill WHERE Name = 'Moulin de Momalle';",
    "step": "【step1】: Retrieve maintenance ratio for 'Golden Gate Bridge' from bridge table by dividing Maintenance_Cost by Cost_USD.  【step2】: Retrieve maintenance ratio for 'Moulin de Momalle' from mill table using the same calculation.  【step3】: Combine both results using UNION ALL to display ratios side-by-side for comparison of maintenance burden.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "3",
    "idx": 117,
    "question": "The known construction year of Charles Bridge is 1402, with stone as its material and an annual maintenance cost of $100,000; the construction year of Moulin de Fexhe is 1843, with wood as its material and an annual maintenance cost of $2,200. Please analyze whether the difference in maintenance costs between these two structures is reasonable based on their materials, and explain the reasons.",
    "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN 'Wooden structures have lower maintenance costs but poorer durability' END AS Maintenance_Analysis FROM bridge WHERE Name = 'Charles Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN Stone structures are typically more durable, but they come with higher maintenance costs END AS Maintenance_Analysis FROM mill WHERE Name = 'Moulin de Fexhe';",
    "step": "【step1】: Retrieve data from 'bridge' table for 'Charles Bridge', apply CASE analysis based on material (stone).  【step2】: Retrieve data from 'mill' table for 'Moulin de Fexhe', apply CASE analysis based on material (wood).  【step3】: Combine both results using UNION ALL to display maintenance cost comparisons with material-based explanations.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "4",
    "idx": 118,
    "question": "Assuming the Akashi Kaikyō Bridge has a span of 100,000 meters, a height of 10,000 meters, and is made of steel; the Moulin de Bruges has blade lengths of 1,000 meters and a rotational speed of 10,000 revolutions per minute. Please calculate the wind load on the Akashi Kaikyō Bridge at a wind speed of 1,000 meters per second, as well as the kinetic energy of the Moulin de Bruges blades during rotation, assuming a blade mass of 50 kg per meter and a standard air density of 1.225 kg/m³.",
    "query": "SELECT 0.5 * 1.225 * POW(1000, 2) * 100000 * 10000 AS Wind_Load, 0.5 * (1000 * 50) * POW(2 * 3.14159 * 1000 * (10000 / 60), 2) AS Blade_Kinetic_Energy;",
    "step": "【step1】: Retrieve Akashi Kaikyō Bridge's span length (100000m) and height (10000m) from the bridge table. Use these values in the wind load formula: 0.5 * air density (1.225 kg/m³) * (wind speed)² * span * height.  【step2】: Extract Moulin de Bruges' blade length (1000m) and rotation speed (10000 RPM) from the mill table. Convert RPM to angular velocity (rad/s) and apply the kinetic energy formula: 0.5 * (blade mass approximated as length*50kg/m) * (angular velocity * blade length)².  【step3】: Combine both calculations using a CROSS JOIN since the bridge and mill datasets are independent, producing a single-row result with Wind_Load and Blade_Kinetic_Energy.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "1",
    "idx": 119,
    "question": "Given that Tower Bridge has a bascule arch shape, a height of 65 meters, and a vibration frequency of 0.25 Hz; and given that Moulin de Bruges has blade lengths of 14 meters and a rotation speed of 20 rpm. Please calculate the wind-induced vibration energy of Tower Bridge at a wind speed of 15 m/s (assuming the bridge mass is 500,000 kg), and the aerodynamic drag on Moulin de Bruges blades during rotation (assuming an air density of 1.225 kg/m³).",
    "query": "SELECT 0.5 * 500000 * POW(15 / (2 * 3.14159 * 0.25), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POW(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Drag FROM bridge WHERE Name = 'Tower Bridge';",
    "step": "【step1】: Filter the bridge table where Name is 'Tower Bridge' to access the relevant vibration frequency (0.25 Hz) and other static parameters.  【step2】: Calculate Wind_Induced_Vibration_Energy using the formula 0.5 * mass * (wind_speed/(2πf))², substituting mass=500000 kg, wind_speed=15 m/s, and f=0.25 Hz.  【step3】: Calculate Aerodynamic_Drag using the formula 0.5 * air_density * (angular_velocity * blade_length)² * total_surface_area, with air_density=1.225 kg/m³, blade_length=14 m, angular_velocity=20 RPM (converted to rad/s), and surface_area=14*2 (assuming two blades).",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "4",
    "idx": 120,
    "question": "Assuming the Golden Gate Bridge has a span of 100,000 meters, a height of 100,000 meters, is made of steel, and has a vibration frequency of 1000 Hz; the Moulin de Bruges has a blade length of 10,000 meters, a rotation speed of 100,000 revolutions per minute, and a power output of 1,000,000,000,000 watts. Please calculate the wind-induced vibration energy of the Golden Gate Bridge at a wind speed of 100,000 meters per second (assuming the bridge's mass is 1,000,000,000 kilograms), as well as the aerodynamic drag on the Moulin de Bruges blades during rotation (assuming the air density is 1.225 kg/m³).",
    "query": "SELECT 0.5 * 1000000000 * POW(100000 / (2 * 3.14159 * 1000), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POW(2 * 3.14159 * 10000 * (100000 / 60), 2) * (10000 * 2) AS Aerodynamic_Drag;",
    "step": "【step1】: Calculate Wind_Induced_Vibration_Energy using formula: 0.5 * mass * (wind_speed/(2πf))². Values substituted: 0.5*1e9*(1e5/(2π*1e3))²  【step2】: Calculate Aerodynamic_Drag using formula: 0.5 * air_density * (2πRPM/60 * blade_length)² * (2*blade_length). Values substituted: 0.5*1.225*(2π*1e5/60*1e4)²*(2e4)",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "1",
    "idx": 121,
    "question": "It is known that the Millau Viaduct has a height of 343 meters; the Moulin de Bruges has blades with a length of 14 meters and a rotation speed of 20 revolutions per minute. Please calculate the wind-induced vibration frequency of the Millau Viaduct at a wind speed of 10 meters/second, as well as the aerodynamic lift force of the Moulin de Bruges blades during rotation (assuming an air density of 1.225 kg/m³).",
    "query": "SELECT 10 / (2 * 3.14159 * 343) AS Wind_Induced_Vibration_Frequency, 0.5 * 1.225 * POW(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Lift FROM bridge WHERE Name = 'Millau Viaduct';",
    "step": "【step1】: Filter the bridge table for the record where Name = 'Millau Viaduct'  【step2】: Calculate Wind_Induced_Vibration_Frequency using the formula 10 / (2 * π * height_meters), substituting the given height of 343 meters  【step3】: Calculate Aerodynamic_Lift using the formula 0.5 * air_density * (2 * π * blade_length * (rotation_speed / 60))² * (blade_length * 2), substituting the provided blade length of 14 meters and rotation speed of 20 RPM",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "2",
    "idx": 122,
    "question": "The Forth Bridge has a length of 2467 meters and a maximum load capacity of 4,000,000 kilograms; the Moulin de Pousset has a power output of 7.8 kilowatts at a wind speed of 6.5 meters per second. Please calculate the load-bearing weight per square meter of the Forth Bridge (assuming the bridge is 20 meters wide), and the wind energy utilization rate of the Moulin de Pousset at a wind speed of 6.5 m/s (assuming an air density of 1.225 kg/m³).",
    "query": "SELECT Load_Capacity / (Length_Meters * 20) AS Load_Per_Square_Meter, Power_Output / (0.5 * 1.225 * POW(6.5, 3) * (3.14159 * POW(Blade_Length, 2))) AS Wind_Energy_Utilization FROM bridge, mill WHERE bridge.Name = 'Forth Bridge' AND mill.Name = 'Moulin de Pousset';",
    "step": "【step1】: Filter the 'bridge' table to retrieve the 'Forth Bridge' record and calculate Load_Per_Square_Meter using Load_Capacity divided by (Length_Meters * 20).  【step2】: Filter the 'mill' table to retrieve the 'Moulin de Pousset' record and compute Wind_Energy_Utilization via the formula with Power_Output, Blade_Length, and constants.  【step3】: Combine results via implicit cross-join (cartesian product) between the filtered bridge and mill tables to produce the final output.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "1",
    "idx": 123,
    "question": "Calculate the natural frequency of Charles Bridge based on its height and the linear velocity of the Moulin de Bruges mill blade tips.",
    "query": "SELECT (10 / (2 * 3.14159 * Height_Meters)) AS Natural_Frequency, (SELECT 2 * 3.14159 * Blade_Length * (Rotation_Speed / 60) FROM mill WHERE Name = 'Moulin de Bruges') AS Tip_Speed FROM bridge WHERE Name = 'Charles Bridge';",
    "step": "【step1】: Calculate the natural frequency of Charles Bridge using its height. Retrieve Height_Meters from the bridge table where Name='Charles Bridge', then apply the formula (10 / (2π * height)).  【step2】: Compute the tip speed of Moulin de Bruges' blades. Subquery selects Blade_Length and Rotation_Speed from the mill table where Name='Moulin de Bruges', then calculates 2π * blade length * (rotation speed converted to rotations per second).  【step3】: Combine results by executing the main query (natural frequency) and embedded subquery (tip speed) simultaneously, returning both calculated values in a single row.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "2",
    "idx": 124,
    "question": "The construction cost of the Akashi Kaikyō Bridge is $5,000,000,000, with a design life of 100 years and a total maintenance cost over the design life of $500,000,000; the construction cost of the Moulin de Momalle is $80,000, with a design life of 50 years and a total maintenance cost over the design life of $150,000. Please calculate the percentage of the total maintenance cost relative to the construction cost for both.",
    "query": "SELECT (Maintenance_Cost * 100) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM bridge WHERE Name = 'Akashi Kaikyō Bridge' UNION ALL SELECT (Maintenance_Cost * 50) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM mill WHERE Name = 'Moulin de Momalle';",
    "step": "【step1】: Calculate Akashi Kaikyō Bridge's total maintenance cost over its lifespan (100 years) as a percentage of construction cost: `(Maintenance_Cost * 100) / Cost_Usd * 100` from `bridge` table.  【step2】: Calculate Moulin de Momalle's total maintenance cost over its lifespan (50 years) as a percentage of construction cost: `(Maintenance_Cost * 50) / Cost_Usd * 100` from `mill` table.  【step3】: Combine results using `UNION ALL` to preserve duplicate entries (though no duplicates exist here), returning both percentages in a single column `Maintenance_Cost_Percentage`.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "3",
    "idx": 125,
    "question": "Given that the annual maintenance cost of Rialto Bridge (stone, built in 1591) is $50,000 and that of Moulin de Pousset (stone, built in 1819) is $2,400, why is there a significant difference in maintenance costs, considering factors such as usage intensity, environmental corrosion, or preservation requirements?",
    "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Rialto Bridge' THEN '高维护成本可能由于高使用强度、环境腐蚀或文物保护需求较高' WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Rialto Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin de Pousset';",
    "step": "【step1】: Retrieve Rialto Bridge data from 'bridge' table with maintenance cost analysis using CASE statement. Ensure column aliases match the UNION structure.  【step2】: Retrieve Moulin de Pousset data from 'mill' table with maintenance cost analysis. Convert 'Built_Year' to align with 'Construction_Year' naming for column consistency.  【step3】: Combine both results via UNION ALL to preserve duplicate entries and maintain distinct maintenance explanations.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "4",
    "idx": 126,
    "question": "Assuming the Golden Gate Bridge's span extends to 100,000 meters with a height of 100,000 meters and a vibration frequency of 100,000 Hz; the Moulin de Bruges' blade length increases to 10,000 meters with a rotation speed of 100,000 rpm. Calculate the vortex-induced vibration energy of the bridge at a wind speed of 100,000 m/s (assuming a mass of 1e12 kg) and the material's ultimate stress caused by the centrifugal force of the blades (assuming a blade density of 8,000 kg/m³).",
    "query": "SELECT 0.5 * 1e12 * POW(100000 / 1000, 2) AS Vortex_Induced_Vibration_Energy, 8000 * POW(2 * 3.14159 * 100000 / 60, 2) * POW(10000, 2) / 2 AS Centrifugal_Stress;",
    "step": "【step1】: Calculate vortex-induced vibration energy using the formula 0.5 * mass * (wind_speed / vibration_frequency)^2 with given parameters (mass=1e12 kg, wind_speed=100000 m/s, vibration_frequency=1000 Hz).  【step2】: Compute centrifugal stress via density * (angular_velocity)^2 * (blade_length)^2 / 2, deriving angular_velocity from rotation_speed (100000 RPM converted to rad/s using 2π/60).  【step3】: Combine both calculations in a single SELECT statement to output results as Vortex_Induced_Vibration_Energy and Centrifugal_Stress without table references.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "1",
    "idx": 127,
    "question": "It is known that the arch shape of the Brooklyn Bridge is suspension, with a span of 486 meters and a vibration frequency of 0.3 Hz; the Moulin de Fexhe has a blade length of 11 meters and a rotational speed of 28 rpm. Please calculate the harmonic number of the Brooklyn Bridge and the critical frequency of the mill.",
    "query": "SELECT (12 * Span_Length) / (Vibration_Frequency * 1000) AS Harmonic_Number, (Blade_Length * Rotation_Speed) / 60 AS Critical_Frequency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';",
    "step": "【step1】: Retrieve Brooklyn Bridge's span length and vibration frequency from the bridge table using the condition `bridge.Name = 'Brooklyn Bridge'`.  【step2】: Retrieve Moulin de Fexhe's blade length and rotation speed from the mill table using the condition `mill.Name = 'Moulin de Fexhe'`.  【step3】: Calculate `Harmonic_Number` via `(12 * Span_Length) / (Vibration_Frequency * 1000)` and `Critical_Frequency` via `(Blade_Length * Rotation_Speed) / 60` by combining the filtered results from both tables.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "2",
    "idx": 128,
    "question": "Given that the Golden Gate Bridge had an annual maintenance cost and a growth rate of 2%; the Moulin de Pousset had an annual maintenance cost and a growth rate of 5%. Please calculate the total cumulative maintenance cost for both after 50 years.",
    "query": "SELECT Maintenance_Cost * (POW(1 + 0.02, 50) - 1) / 0.02 AS Total_Maintenance_Cost_Golden_Gate, (SELECT Maintenance_Cost * (POW(1 + 0.05, 50) - 1) / 0.05 FROM mill WHERE Name = 'Moulin de Pousset') AS Total_Maintenance_Cost_Moulin FROM bridge WHERE Name = 'Golden Gate Bridge';",
    "step": "【step1】: Retrieve the initial annual maintenance cost for 'Golden Gate Bridge' from the bridge table and calculate its cumulative maintenance cost over 50 years using the geometric series formula: Maintenance_Cost * (POW(1 + 0.02, 50) - 1) / 0.02.  【step2】: Retrieve the initial annual maintenance cost for 'Moulin de Pousset' from the mill table via a subquery and calculate its cumulative maintenance cost over 50 years using the geometric series formula: Maintenance_Cost * (POW(1 + 0.05, 50) - 1) / 0.05.  【step3】: Combine both results into a single row output by executing the main query and subquery simultaneously, aligning their computed totals as separate columns.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "3",
    "idx": 129,
    "question": "Sydney Harbour Bridge (steel, built in 1932) has an annual maintenance cost of $800,000, while Moulin d'Amsterdam (wooden, built in 1805) costs $2,050 to maintain. Why is the maintenance cost higher for steel bridges?",
    "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'High maintenance costs may be due to anti-corrosion treatment, load monitoring, and higher structural complexity' WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Sydney Harbour Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin d''Amsterdam';",
    "step": "【step1】: Retrieve steel bridge data from \"bridge\" table with CASE analysis for maintenance costs, filtering by Sydney Harbour Bridge  【step2】: Retrieve wooden mill data from \"mill\" table with CASE analysis for maintenance costs, filtering by Moulin d'Amsterdam (note field name mismatch: Built_Year vs Construction_Year)  【step3】: Combine results using UNION ALL while maintaining column alignment (Name, Year, Material, Cost, Analysis) despite different source table structures",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "4",
    "idx": 130,
    "question": "Assuming the span of Millau Viaduct increases to 1e9 meters (approximately 2.6 times the Earth-Moon distance), with a vibration frequency of 1e6 Hz; and the blade length of Moulin de Bruges is 1e8 meters, rotating at 1e12 revolutions per minute. Please calculate: ① The number of vibration modes of the bridge; ② Whether the tip speed of the blade exceeds the speed of light and the relativistic correction factor.",
    "query": "SELECT (1e9 * 1e6) / (6.62607015e-34 * 1e34) AS Quantum_Vibration_Modes, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) >= 299792458 THEN 'Faster than light, correction factor cannot be calculated' ELSE 'Not exceeding the speed of light requires relativistic corrections' END AS Relativity_Check, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) < 299792458 THEN 1 / SQRT(1 - POW((2 * 3.14159 * 1e8 * (1e12 / 60)) / 299792458, 2)) ELSE 'N/A' END AS Relativity_Correction_Factor;",
    "step": "【step1】: Calculate Quantum_Vibration_Modes using formula (span_length × vibration_frequency) / (h × solar_wind_velocity): (1e9 * 1e6) / (6.62607015e-34 * 1e7)  【step2】: Calculate blade tip velocity via 2πr × (rotation_speed/60) and compare with light speed (299,792,458 m/s) for CASE condition in Relativity_Check  【step3】: Compute Relativity_Correction_Factor using Lorentz factor 1/√(1-(v²/c²)) only when blade tip velocity < light speed, else output 'N/A'",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "1",
    "idx": 131,
    "question": "Given that the Tower Bridge is a bascule arch with a span of 244 meters and a vibration frequency of 0.25 Hz; the Moulin de Bruges has blade lengths of 14 meters and a rotational speed of 20 revolutions per minute. Please calculate the vortex shedding frequency of the Tower Bridge and the wavelength of the infrasound generated by the rotation of the mill's blades.",
    "query": "SELECT (0.2 * Vibration_Frequency) / Span_Length AS Vortex_Shedding_Frequency, 343 / (Rotation_Speed / 60) AS Infrasound_Wavelength FROM bridge, mill WHERE bridge.Name = 'Tower Bridge' AND mill.Name = 'Moulin de Bruges';",
    "step": "【step1】: Retrieve Tower Bridge's Vibration_Frequency and Span_Length from the bridge table using the WHERE condition bridge.Name = 'Tower Bridge'.  【step2】: Retrieve Moulin de Bruges' Rotation_Speed from the mill table using the WHERE condition mill.Name = 'Moulin de Bruges'.  【step3】: Calculate Vortex_Shedding_Frequency via (0.2 * Vibration_Frequency) / Span_Length and Infrasound_Wavelength via 343 / (Rotation_Speed / 60), returning both results.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "2",
    "idx": 132,
    "question": "It is known that the Akashi Kaikyō Bridge has a construction cost of $5 billion, with annual maintenance costs increasing by 5%; the Moulin d'Amsterdam has a construction cost of $52,000, with annual maintenance costs increasing by 8%. Please calculate the percentage of maintenance costs relative to the original construction cost for both in the 25th year.",
    "query": "SELECT (Maintenance_Cost * POW(1 + 0.05, 25)) / Cost_Usd * 100 AS Maintenance_Cost_Percentage_Akashi, (SELECT Maintenance_Cost * POW(1 + 0.08, 25) / Cost_Usd * 100 FROM mill WHERE Name = 'Moulin d''Amsterdam') AS Maintenance_Cost_Percentage_Amsterdam FROM bridge WHERE Name = 'Akashi Kaikyō Bridge';",
    "step": "【step1】: Retrieve Akashi Kaikyō Bridge's initial maintenance cost and cost from the bridge table, calculate the 25th-year maintenance cost using 5% annual increase (POW(1+0.05,25)), then divide by construction cost and convert to percentage.  【step2】: Use subquery to fetch Moulin d'Amsterdam's data from mill table, compute 25th-year maintenance cost with 8% increment (POW(1+0.08,25)), calculate its percentage relative to its construction cost.  【step3】: Combine both results in a single row output by mapping bridge table's main calculation and mill table's subquery calculation as separate columns.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "3",
    "idx": 133,
    "question": "Ponte Vecchio (stone, built in 1345) and Forth Bridge (steel, built in 1890) have annual maintenance costs of $20,000 and $700,000, respectively. Please explain why the maintenance cost of stone is significantly lower than that of steel, despite stone having lower tensile strength.",
    "query": "SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Stone' THEN 'Stone maintenance costs are low due to its gradual failure mode and lack of need for complex anti-corrosion treatment' WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Ponte Vecchio' UNION ALL SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Forth Bridge';",
    "step": "【step1】: Retrieve Ponte Vecchio's data with maintenance cost analysis using CASE to explain stone's lower maintenance.  【step2】: Retrieve Forth Bridge's data with CASE to explain steel's higher maintenance costs.  【step3】: Combine both results using UNION ALL to display comparative maintenance cost reasons in a single output.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "4",
    "idx": 134,
    "question": "Assuming the material of the Golden Gate Bridge changes to degenerate matter (density 1e17 kg/m³), with a span of 1e25 meters; and the blades of Moulin de Bruges rotate at a speed of 1e40 revolutions per minute. Please calculate:  \n① The tidal resonance frequency of the bridge in the gravitational field of the Milky Way's spiral arm;  \n② The rate of spacetime curvature change induced by the blade rotation.",
    "query": "SELECT (6.67430e-11 * 1e41 * 1e17) / POW(1e25, 3) AS Tidal_Resonance_Frequency, POW(1e40 * 14 / 60, 2) / POW(299792458, 4) AS Spacetime_Curvature_Rate;",
    "step": "【step1】: Calculate Tidal Resonance Frequency using gravitational constant (6.67430e-11), mass (1e41 kg), density-derived volume (1e17 kg/m³), and span cubed (POW(1e25,3)).  【step2】: Compute Spacetime Curvature Rate by converting rotation speed (1e40 RPM) to RPS (1e40 * (14/60)), squaring it, then dividing by lightspeed⁴ (POW(299792458,4)).  【step3】: Combine both calculations in a single SELECT statement to output dual physics metrics.",
    "format": "MySQL"
  },
  {
    "db_id": "architect",
    "type": "2",
    "idx": 135,
    "question": "Given the Golden Gate Bridge has an annual maintenance cost growth rate of 2%, and the Moulin d'Amsterdam has an annual maintenance cost growth rate of 5%. Please calculate:  \n1. The number of years required for the maintenance costs of both structures to reach 10 times their current maintenance costs.  \n2. The ratio of the maintenance cost to the initial maintenance cost after 50 years.",
    "query": "SELECT (LN(10 * b.Cost_Usd / b.Maintenance_Cost) / LN(1.02)) AS Years_To_10x_GoldenGate, POW(1.02, 50) AS Multiplier_50y_GoldenGate, (LN(10 * m.Cost_Usd / m.Maintenance_Cost) / LN(1.05)) AS Years_To_10x_Amsterdam, POW(1.05, 50) AS Multiplier_50y_Amsterdam FROM bridge b, mill m WHERE b.Name = 'Golden Gate Bridge' AND m.Name = 'Moulin d''Amsterdam';",
    "step": "【step1】: Calculate years to reach 10x construction cost using logarithmic formula LN(10*Cost_Usd/Maintenance_Cost)/LN(1+growth_rate) for both structures.  【step2】: Compute 50-year maintenance cost multiplier via exponential function POW(1+annual_growth_rate, 50).  【step3】: Cross-join bridge and mill tables with WHERE filters to isolate 'Golden Gate Bridge' and 'Moulin d''Amsterdam' records respectively.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 136,
    "question": "Calculate the air resistance power of a carbon fiber road bike when traveling at its top speed.",
    "query": "SELECT 0.5 * p.AerodynamicDrag * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';",
    "step": "【step1】: Filter bicycles with 'Carbon fiber' frame and 'Road bike' type from Bicycle table  【step2】: Join filtered bicycles with BicyclePerformance table using BicycleID  【step3】: Calculate air resistance power using formula 0.5 * AerodynamicDrag * air_density * frontal_area * (speed^3) with unit conversion (km/h→m/s)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 137,
    "question": "Calculate the total energy consumption per bicycle, considering rider power output and motor efficiency, and group the results by riding style.",
    "query": "SELECT r.RidingStyle, (r.RiderPowerOutput + (t.MotorEfficiency / 100 * t.BatteryCapacity)) * 2 AS TotalEnergyConsumption FROM BicycleRider r JOIN BicycleThermodynamics t ON r.BicycleID = t.BicycleID;",
    "step": "【step1】: Perform an INNER JOIN between BicycleRider (r) and BicycleThermodynamics (t) using BicycleID to link rider data with thermodynamics data  【step2】: Calculate energy components: For each matched record, compute (RiderPowerOutput + (MotorEfficiency% × BatteryCapacity))  【step3】: Multiply the sum by 2 to get TotalEnergyConsumption per riding style and finalize the result projection",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 138,
    "question": "Based on the bicycle's weight, the rider's weight, and the maximum load capacity, determine whether tire pressure adjustments are needed by comparing the calculated required pressure to the current tire pressure.",
    "query": "SELECT b.BicycleID, CASE WHEN (b.Weight + r.RiderWeight + b.MaxLoad) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine bicycle specifications with rider weight data  【step2】: Calculate total load pressure requirement using formula (Bicycle.Weight + RiderWeight + MaxLoad) / 0.02 to determine required tire pressure  【step3】: Use CASE statement to compare calculated pressure with actual TirePressure, returning 'Needs adjustment' when required pressure exceeds stored value",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 139,
    "question": "Calculate the braking distance of a bicycle when the speed is 5 times the maximum speed.",
    "query": "SELECT b.BicycleID, POWER((p.TopSpeed * 5 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicyclePerformance tables using BicycleID to access speed data  【step2】: Convert TopSpeed from km/h to m/s (×1000/3600) then apply 5× speed multiplier  【step3】: Calculate braking distance using physics formula: (velocity²) / (2×friction×gravity) with assumed μ=0.7 and g=9.81m/s²",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 140,
    "question": "Calculate the power requirement for a mountain bike climbing a hill with a 10% gradient, given a rider weight of 75 kg and a bicycle weight of 15 kg.",
    "query": "SELECT b.BicycleID, (75 + 15) * 9.81 * (p.TopSpeed * 1000 / 3600) * 0.10 AS ClimbingPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'Mountain bike';",
    "step": "【step1】: Filter mountain bicycles by type  【step2】: Join performance data to get speed  【step3】: Calculate climbing power using (rider_weight + bike_weight)*g*speed*slope",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 141,
    "question": "Calculate the air resistance power for each carbon fiber road bike, where the power is computed as 0.5 * 0.9 * 1.225 * 0.5 * (top speed in km/h converted to m/s, then cubed), based on the bike's maximum speed.",
    "query": "SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';",
    "step": "【step1】: Filter carbon fiber road bikes from Bicycle table using WHERE FrameMaterial='Carbon fiber' AND Type='Road bike'  【step2】: Join with BicyclePerformance table via BicycleID to access TopSpeed value in km/h  【step3】: Calculate power using formula 0.5 * Cd * ρ * A * (v³) where ρ=1.225 kg/m³ and v converted to m/s via (TopSpeed*1000/3600)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 142,
    "question": "Calculate the battery life of an electric bicycle under different ambient temperatures, given a battery capacity of 500 watt-hours, motor efficiency of 85%, and rider power output of 250 watts.",
    "query": "SELECT t.AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;",
    "step": "【step1】: Filter records where battery capacity is 500 Wh from BicycleThermodynamics table.  【step2】: Calculate total power consumption using formula: (RiderPower + (MotorPower / MotorEfficiency)) = 100 + (250 / 0.85).  【step3】: Compute BatteryLife by dividing battery capacity (500 Wh) by total power consumption for each ambient temperature.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 143,
    "question": "Based on the total weight of the bicycle, rider, and load compared to the tire pressure, determine whether tire pressure adjustment is needed to ensure safe riding. The known conditions are: bicycle weight is 12 kg, rider's weight is 80 kg, load capacity is 30 kg, and tire contact area is 0.01 square meters.",
    "query": "SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
    "step": "【step1】: Perform JOIN operation between Bicycle and BicycleRider tables using BicycleID to link bike specifications with rider data.  【step2】: Calculate total pressure: (BikeWeight(12kg) + RiderWeight(80kg) + Load(30kg)) / (TireContactArea × 2) = 122kg / 0.02m² = 6100 kg/m².  【step3】: Use CASE to compare calculated pressure (6100 kg/m²) against stored TirePressure (PSI). Return adjustment requirement based on whether the value exceeds the tire's rated pressure.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 144,
    "question": "Calculate the braking distance for each bicycle using the formula based on top speed, with a friction coefficient of 0.7 and gravitational acceleration of 9.81 m/s².",
    "query": "SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
    "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID to access TopSpeed values  【step2】: Convert TopSpeed to m/s (km/h×1000/3600) and apply 10x multiplier for extreme condition  【step3】: Calculate braking distance using formula (v²)/(2×μ×g) with μ=0.7 and g=9.81 m/s²",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 145,
    "question": "Calculate the air resistance power for carbon fiber road bicycles using the formula 0.5 × air density (1.225) × air resistance coefficient (0.9) × projected area (0.5) × velocity cubed, where velocity is the top speed in meters per second.",
    "query": "SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicyclePerformance tables using BicycleID to link bicycle specifications with performance data  【step2】: Filter records where FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' to select carbon fiber road bikes  【step3】: Calculate air resistance power using formula 0.5*Cd*ρ*A*v³ with converted speed units (km/h→m/s), where Cd=0.9, ρ=1.225kg/m³, A=0.5m², and v=(TopSpeed*1000/3600)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 146,
    "question": "What is the battery life in hours for an electric bicycle under different ambient temperatures, given the battery capacity is 500 watt-hours, the motor efficiency is 85%, and the rider's power output is 100 watts?",
    "query": "SELECT t.AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;",
    "step": "【step1】: Filter records in BicycleThermodynamics where BatteryCapacity = 500 to isolate electric bicycles with the specified battery.  【step2】: Calculate total power consumption: 100W (rider output) + (250W / 0.85 motor efficiency) = 100 + ~294.12 = ~394.12W.  【step3】: Compute BatteryLife by dividing BatteryCapacity (500Wh) by total power consumption and output AmbientTemperature with the result.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 147,
    "question": "Based on the bike's weight, rider weight, and load, determine whether the tire pressure needs to be adjusted to ensure safe riding.",
    "query": "SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
    "step": "【step1】: Join Bicycle and BicycleRider tables via BicycleID to associate rider weight data with bicycle specifications  【step2】: Calculate total pressure requirement by dividing combined weight (12kg bike + 80kg rider + 30kg load) by total tire contact area (0.01m² × 2 tires)  【step3】: Compare calculated pressure with stored TirePressure using CASE to determine adjustment need",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 148,
    "question": "Calculating the braking distance of a bicycle at 10 times its maximum speed, given a friction coefficient of 0.7 and gravity acceleration of 9.81 m/s.",
    "query": "SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
    "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID to access TopSpeed data  【step2】: Convert TopSpeed from km/h to m/s (×1000/3600) and apply 10× multiplier for extreme speed  【step3】: Calculate braking distance using formula (v²)/(2μg) with μ=0.7 and g=9.81 m/s²",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 149,
    "question": "Calculate the kinetic energy of an electric bicycle at its top speed under standard conditions.",
    "query": "SELECT b.BicycleID, 0.5 * (b.Weight + b.MaxLoad) * POWER((p.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'electric vehicle';",
    "step": "【step1】: Filter electric bicycles by joining Bicycle and BicyclePerformance tables  【step2】: Calculate total mass (bike weight + max load) and convert speed from km/h to m/s  【step3】: Apply kinetic energy formula (0.5 * mass * velocity²) for qualified records",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 150,
    "question": "Calculate the actual power delivered to the wheels by multiplying the rider's power output and the bicycle's power transfer efficiency (divided by 100).",
    "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID;",
    "step": "【step1】: Join Bicycle and BicycleRider tables using BicycleID to associate rider power output with bicycle  【step2】: Join result with BicyclePerformance table using BicycleID to access power transfer efficiency  【step3】: Calculate ActualPower by multiplying RiderPowerOutput with PowerTransferEfficiency/100 and select required columns",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 151,
    "question": "Calculate the contact area of the bicycle tire based on the tire width.",
    "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleComponents tables using BicycleID to link tire properties.  【step2】: Calculate ContactArea using the formula **TireWidth * (TireWidth * 2)** for each bicycle.  【step3】: Select and output BicycleID with the computed ContactArea.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 152,
    "question": "If the wheel size of a bicycle increases to 100 inches, and the rider's height is used in the calculation along with a fixed weight contribution of 500, what is the new center of gravity height?",
    "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100;",
    "step": "【step1】: Perform INNER JOINs between Bicycle, BicycleDynamics, and BicycleRider tables using BicycleID to combine bicycle specifications, dynamics data, and rider information.  【step2】: Apply WHERE filter to select bicycles with WheelSize = 100 inches.  【step3】: Calculate NewCenterOfGravityHeight with formula: Original CenterOfGravityHeight + (500kg rider * RiderHeight) / (Bicycle.Weight + 500kg).",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 153,
    "question": "Calculate the kinetic energy of each electric bicycle when traveling at top speed with maximum load, and list the top 5 bicycles with the highest kinetic energy.",
    "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' ORDER BY KineticEnergy DESC LIMIT 5;",
    "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID, filtering only 'electric vehicle' type bicycles.  【step2】: Calculate kinetic energy with formula: 0.5*(Weight+MaxLoad)*(TopSpeed converted to m/s squared).  【step3】: Sort results by kinetic energy descending and limit to top 5 records.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 154,
    "question": "Compute the product of power transmission efficiency and rider power output divided by 100 for each bicycle to determine the actual power delivered to the wheels, and list the top 10 bicycles with the highest power.",
    "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID ORDER BY ActualPower DESC LIMIT 10;",
    "step": "【step1】: Perform INNER JOIN on Bicycle, BicycleRider, and BicyclePerformance tables using BicycleID to combine bicycle metadata, rider power output, and power transfer efficiency data.  【step2】: Calculate ActualPower by multiplying RiderPowerOutput (from BicycleRider) with PowerTransferEfficiency (from BicyclePerformance) divided by 100 to convert percentage efficiency.  【step3】: Sort results by ActualPower in descending order and apply LIMIT 10 to retrieve the top 10 bicycles with highest effective wheel power transmission.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 155,
    "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground, and list the top 5 bicycles with the smallest contact area.",
    "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID ORDER BY ContactArea ASC LIMIT 5;",
    "step": "【step1】: Perform an INNER JOIN between Bicycle and BicycleComponents tables using BicycleID to associate tire width data with each bicycle.  【step2】: Calculate the contact area using the formula (TireWidth × (TireWidth × 2)) for each bicycle.  【step3】: Sort results by ContactArea in ascending order and apply LIMIT 5 to retrieve the smallest 5 entries.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 156,
    "question": "If the wheel size is 100 inches and the rider's weight is 500 kilograms, calculate the center of gravity height for each bicycle and list the top 3 bicycles with the highest center of gravity height.",
    "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100 ORDER BY NewCenterOfGravityHeight DESC LIMIT 3;",
    "step": "【step1】: Perform JOIN operations across Bicycle, BicycleDynamics, and BicycleRider tables using BicycleID as the foreign key to combine bicycle technical specifications, dynamics data, and rider parameters.  【step2】: Apply conditional filtering (WHERE WheelSize=100) and calculate modified CenterOfGravityHeight using formula: Original height + (500kg rider weight × rider height) / (bicycle weight + 500kg).  【step3】: Sort results by NewCenterOfGravityHeight descending and implement LIMIT 3 to retrieve bicycles with highest adjusted center of gravity.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 157,
    "question": "Calculate the kinetic energy of each electric bicycle when traveling at maximum speed under maximum load, and identify the electric bicycles with kinetic energy higher than all mountain bikes.",
    "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Mountain bike');",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicyclePerformance tables to obtain electric bicycles' weight, max load, and top speed data. Convert speed from km/h to m/s using (TopSpeed * 1000 / 3600).  【step2】: Calculate kinetic energy for all mountain bikes through subquery: 0.5*(Weight+MaxLoad)*POWER((converted speed),2) after joining Bicycle and BicyclePerformance tables with Type='Mountain bike'.  【step3】: Filter electric bicycles using > ALL operator to ensure their kinetic energy exceeds all values from the mountain bike subquery results.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 158,
    "question": "Calculate the product of each bicycle’s drivetrain efficiency and the rider’s power output to determine the actual power delivered to the wheels, and identify hybrid bicycles with actual power higher than that of all road bikes.",
    "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Road bike');",
    "step": "【step1】: Join Bicycle, BicycleRider, and BicyclePerformance tables using BicycleID, filter records where bicycle type is 'Hybrid vehicle'  【step2】: Calculate ActualPower by multiplying RiderPowerOutput with PowerTransferEfficiency/100  【step3】: Use ALL operator to compare against subquery results calculating the same power metric for 'Road bike' type bicycles",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 159,
    "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground, and identify electric bikes with a contact area smaller than all BMX bikes.",
    "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX');",
    "step": "【step1】: Calculate ContactArea for all BMX bicycles by joining Bicycle and BicycleComponents tables, selecting TireWidth²*2.  【step2】: Calculate ContactArea for electric bicycles using the same formula, then filter by Type='electric vehicle'.  【step3】: Use ALL operator to compare electric bicycles' ContactArea with BMX results from step1, returning only electric bicycles with smaller values than all BMX entries.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 160,
    "question": "Calculate the center of gravity height for each bicycle using the adjusted rider weight of 500 kg and identify the full-suspension bicycles with a center of gravity height higher than all no-suspension bicycles.",
    "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'No suspension');",
    "step": "【step1】: Join Bicycle, BicycleDynamics, and BicycleRider tables to calculate the \"NewCenterOfGravityHeight\" for full-suspension bicycles using the formula: CenterOfGravityHeight + (500 * RiderHeight) / (Bicycle.Weight + 500).  【step2】: Compute the same \"NewCenterOfGravityHeight\" for non-suspension bicycles via a subquery using identical joins and formula.  【step3】: Filter results where full-suspension bicycles' NewCenterOfGravityHeight exceeds ALL values from the non-suspension subquery results using the > ALL operator.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 161,
    "question": "Calculate the kinetic energy of each electric vehicle when traveling at maximum speed under maximum load, and identify the electric vehicles with kinetic energy higher than all mountain bikes using a carbon fiber frame.",
    "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');",
    "step": "【step1】: Calculate kinetic energy for all electric bicycles by joining Bicycle, BicyclePerformance, and BicycleComponents tables using BicycleID, applying the formula 0.5*(Weight+MaxLoad)*(TopSpeed converted to m/s)^2 where Type='electric vehicle'.  【step2】: Compute maximum kinetic energy values for mountain bikes with carbon fiber frames by joining relevant tables, filtering WHERE Type='Mountain bike' AND BicycleComponents.FrameMaterial='Carbon fiber'.  【step3】: Filter electric bicycles from Step1 by comparing their kinetic energy to ALL results from Step2's subquery using the > ALL operator in the WHERE clause.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 162,
    "question": "Calculate the product of each bicycle's power transmission efficiency and the rider's power output to determine the actual power delivered to the wheels, and then identify the hybrid bicycles whose actual power is higher than the maximum actual power among all road bikes using aluminum alloy rims.",
    "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');",
    "step": "【step1】: Calculate ActualPower for all hybrid bicycles by multiplying RiderPowerOutput and PowerTransferEfficiency, then divide by 100 through joins between Bicycle, BicycleRider, and BicyclePerformance tables.  【step2】: Calculate comparison baseline by subquery - compute ActualPower for all road bicycles with aluminum rims through equivalent joins and filter conditions (Bicycle.Type='Road bike' AND BicycleComponents.RimMaterial='aluminum alloy').  【step3】: Filter hybrid bicycles (Bicycle.Type='Hybrid vehicle') using WHERE clause to retain only those whose ActualPower exceeds ALL values from the subquery result in Step 2.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 163,
    "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground (using the formula tire width multiplied by tire width multiplied by 2), and identify the electric bikes with a contact area smaller than all BMX bikes with steel chains.",
    "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');",
    "step": "【step1】: Calculate contact area for all BMX bikes with steel chains by joining Bicycle and BicycleComponents tables, using formula (TireWidth × 2 × TireWidth)  【step2】: Calculate contact area for electric bikes using the same formula, filtering by Type = 'electric vehicle' in the Bicycle table  【step3】: Compare electric bike contact areas against all values from step1 using < ALL operator to ensure they are smaller than every BMX contact area",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 164,
    "question": "If the rider's weight is fixed at 500 kg and the center of gravity height is calculated as BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500), identify the full-suspension bicycles with a center of gravity height higher than that of all rigid bicycles equipped with titanium alloy handlebars.",
    "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');",
    "step": "【step1】: Join tables (Bicycle, BicycleDynamics, BicycleRider, BicycleComponents) and filter for full-suspension bikes. Calculate new CenterOfGravityHeight with formula: OriginalHeight + (500*RiderHeight)/(BikeWeight+500).  【step2】: Create subquery to calculate same formula for rigid-frame bikes with titanium handlebars. Join identical tables and apply filters: SuspensionType='No suspension' AND HandlebarMaterial='Titanium alloy'.  【step3】: Compare main query's NewCenterOfGravityHeight against all values from subquery using > ALL operator to ensure superiority over every rigid titanium-handlebar bike's adjusted height.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 165,
    "question": "Calculate the kinetic energy of each electric bicycle when traveling at maximum speed under maximum load, and identify the electric bicycles with kinetic energy higher than the maximum kinetic energy among mountain bikes using carbon fiber frames.",
    "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');",
    "step": "【step1】: Calculate kinetic energy for all electric bicycles by joining Bicycle, BicyclePerformance, and BicycleComponents tables using the formula 0.5*(Weight+MaxLoad)*(TopSpeed converted to m/s)^2. Filter by 'electric vehicle' type.  【step2】: Calculate kinetic energy for all mountain bicycles with carbon fiber frames using the same formula by joining the same tables. Filter by 'Mountain bike' type and BicycleComponents.FrameMaterial='Carbon fiber'.  【step3】: Compare electric bicycle kinetic energy values against ALL carbon fiber mountain bicycle kinetic energy values using > ALL operator, returning electric bicycles exceeding all mountain bike kinetic energies.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 166,
    "question": "Calculate the product of each bicycle's rider power output and power transfer efficiency divided by 100 to determine the actual power delivered to the wheels, and identify hybrid bicycles where the actual power exceeds that of all road bikes using aluminum rims.",
    "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');",
    "step": "【step1】: Calculate the actual power (RiderPowerOutput * PowerTransferEfficiency/100) for all road bikes with aluminum rims by joining Bicycle, BicycleComponents, BicycleRider, and BicyclePerformance tables.【step2】: Calculate actual power for hybrid bikes using the same formula, while filtering bicycles where Type='Hybrid vehicle' through table joins.【step3】: Apply ALL operator to compare hybrid bikes' actual power against all road bike values from Step1, returning only hybrid bikes exceeding every road bike's actual power.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 167,
    "question": "Based on the tire width of each bicycle, calculate the contact area between the tire and the ground, and identify the electric bikes with a contact area smaller than all BMX bikes equipped with steel chains.",
    "query": "SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');",
    "step": "【step1】: Calculate contact areas for BMX bicycles with steel chains by joining Bicycle and BicycleComponents tables, filtering Type='BMX' and ChainMaterial='钢', then compute TireWidth²×2  【step2】: Calculate contact areas for electric bicycles by joining Bicycle and BicycleComponents tables, filtering Type='electric vehicle', compute TireWidth²×2 as ContactArea  【step3】: Compare electric bicycle ContactArea values against ALL BMX results from step1 using < ALL operator in WHERE clause, selecting qualifying electric bicycles",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 168,
    "question": "If the wheel diameter of all bicycles is increased to 100 inches and the rider's weight is set to a fixed value of 500 in the formula, calculate the adjusted center of gravity height for each bicycle, and identify the full-suspension bicycles whose adjusted center of gravity height is higher than that of all rigid bicycles using titanium alloy handlebars.",
    "query": "SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');",
    "step": "【step1】: Calculate the new center of gravity height for all full-suspension bicycles using the formula: Original CenterOfGravityHeight + (500 * RiderHeight) / (BicycleWeight + 500) after increasing wheel size to 100 inches and rider weight to 500kg.  【step2】: Calculate the new center of gravity heights for titanium-handlebar rigid-suspension bicycles using the same formula through a subquery.  【step3】: Filter results from Step1 where the calculated height exceeds ALL values from Step2 using > ALL comparison operator in the WHERE clause.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 169,
    "question": "Calculate the heat generated by the rider's power output adjusted for motor inefficiency for each electric vehicle bicycle, and identify the e-bikes with heat levels higher than all carbon fiber-framed mountain bikes.",
    "query": "SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) AS HeatGenerated FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) > ALL (SELECT BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');",
    "step": "【step1】: Calculate heat generated by all electric bicycles: Join Bicycle, BicycleRider, BicycleThermodynamics, and BicycleComponents tables. Filter bicycles of type 'electric vehicle' and compute RiderPowerOutput * (1 - MotorEfficiency/100) as HeatGenerated.  【step2】: Calculate maximum heat from carbon-fiber mountain bikes: Join the same tables but filter for 'Mountain bike' with BicycleComponents.FrameMaterial='Carbon fiber'. Compute the same heat formula for comparison.  【step3】: Filter electric bicycles with heat exceeding all mountain bike values: Use > ALL operator to compare Step1's HeatGenerated with the subquery results from Step2.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 170,
    "question": "Calculate the product of battery capacity and motor efficiency divided by 100 for each bicycle to determine the actual available energy, and identify hybrid bicycles whose actual available energy exceeds that of all road bikes using aluminum alloy rims.",
    "query": "SELECT Bicycle.BicycleID, BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 AS UsableEnergy FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 > ALL (SELECT BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');",
    "step": "【step1】: Join Bicycle, BicycleThermodynamics, and BicycleComponents tables to calculate UsableEnergy (BatteryCapacity*MotorEfficiency/100) for hybrid bikes  【step2】: Subquery calculates max UsableEnergy from road bikes with aluminum rims using same table joins  【step3】: Filter hybrid bikes where UsableEnergy exceeds ALL values from subquery results",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 171,
    "question": "Based on the heat dissipation rate of each bicycle and the ambient temperature, calculate the motor's operating temperature, and identify the electric vehicles with operating temperatures lower than the maximum operating temperature among BMX bikes that use steel chains.",
    "query": "SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) AS MotorTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) < ALL (SELECT BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');",
    "step": "【step1】: Filter electric bicycles and calculate their motor temperature using ambient temperature and heat dissipation rate divided by motor efficiency through JOINs with BicycleThermodynamics and BicycleComponents tables.  【step2】: Calculate motor temperatures for BMX bicycles with steel chains via a subquery using the same formula, ensuring type='BMX' and ChainMaterial='钢'.  【step3】: Compare electric bicycles' motor temperatures from Step1 against ALL BMX motor temperatures from Step2 using the < ALL operator to finalize the result set.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 172,
    "question": "If the battery capacity of all bicycles is increased to 1000 watt-hours and the ambient temperature reaches 50°C, calculate the battery temperature for each full-suspension bicycle, and identify which of these have battery temperatures higher than all no-suspension bicycles that use titanium alloy handlebars.",
    "query": "SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) AS BatteryTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) > ALL (SELECT BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');",
    "step": "【step1】: Calculate battery temperature for all full-suspension bicycles using formula: AmbientTemperature + (1000 / HeatDissipationRate) after joining Bicycle, BicycleThermodynamics, and BicycleComponents tables.  【step2】: Create subquery to calculate battery temperature for titanium-handlebar rigid bicycles using same formula through identical table joins.  【step3】: Filter results where full-suspension bicycles' battery temperature exceeds ALL values from subquery results through comparison operator.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 173,
    "question": "Calculate the motor temperature of an electric bicycle under different ambient temperatures, with a motor efficiency of 85%, a battery capacity of 500 watt-hours, a heat dissipation rate of 200 watts, and the ambient temperature varying from 10°C to 40°C. How does the motor temperature change?",
    "query": "SELECT AmbientTemperature, MotorTemperature FROM BicycleThermodynamics WHERE MotorEfficiency = 85 AND BatteryCapacity = 500 AND HeatDissipationRate = 200 AND AmbientTemperature BETWEEN 10 AND 40;",
    "step": "【step1】: Filter records from BicycleThermodynamics where MotorEfficiency = 85%, BatteryCapacity = 500 Wh, and HeatDissipationRate = 200 W  【step2】: Apply ambient temperature range filter (BETWEEN 10°C AND 40°C) to the pre-filtered dataset  【step3】: Extract the AmbientTemperature and MotorTemperature columns from the filtered results",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 174,
    "question": "Calculate the average power output for different types of bicycles under various riding styles, given a rider weight of 70 kg, height of 175 cm, age of 30 years, riding styles including leisure, competitive, and off-road, and bicycle types including road bikes, mountain bikes, and hybrid bikes.",
    "query": "SELECT Type, RidingStyle, AVG(RiderPowerOutput) AS AvgPowerOutput FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
    "step": "【step1】:【Join Bicycle and BicycleRider tables using BicycleID to combine bicycle specifications with rider data】  【step2】:【Filter records where RiderWeight=70kg, RiderHeight=175cm, RiderAge=30, RidingStyle in ('Leisure','Competitive','Off-road'), and Type in ('Road bike','Mountain bike','Hybrid vehicle')】  【step3】:【Group results by bicycle Type and RidingStyle, then calculate average RiderPowerOutput using AVG() aggregation】",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 175,
    "question": "Based on the bicycle's weight, tire pressure, and tire width, calculate the rolling resistance coefficient for a bicycle with a weight of 12 kg, tire pressure of 60 PSI, and tire width of 28 mm.",
    "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;",
    "step": "【step1】: Join Bicycle and BicycleComponents tables using BicycleID and filter with TirePressure=60, TireWidth=28mm, and Weight=12kg.  【step2】: Calculate rolling resistance coefficient using formula (Weight*9.81)/(TirePressure*TireWidth) for physics-based computation.  【step3】: Return Weight, TirePressure, TireWidth, and derived RollingResistanceCoefficient for the specified condition.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 176,
    "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 1000 watt-hours, motor efficiency of 90%, heat dissipation rate of 500 watts, ambient temperature of 50°C, motor temperature of 100°C, and rider power output of 500 watts.",
    "query": "SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 1000 AND MotorEfficiency = 90 AND HeatDissipationRate = 500 AND AmbientTemperature = 50 AND MotorTemperature = 100 AND RiderPowerOutput = 500;",
    "step": "【step1】: Perform INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to combine thermodynamic parameters with rider power output data  【step2】: Apply WHERE clause to filter records with BatteryCapacity=1000, MotorEfficiency=90, HeatDissipationRate=500, AmbientTemperature=50, MotorTemperature=100, and RiderPowerOutput=500  【step3】: Calculate BatteryLife using formula (BatteryCapacity / ((RiderPowerOutput/(MotorEfficiency/100)) + (HeatDissipationRate*(MotorTemperature-AmbientTemperature)))) and select required columns",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 177,
    "question": "Calculate the heat dissipation efficiency at different ambient temperatures between 15°C and 35°C for a bicycle with motor efficiency of 88%, battery capacity of 600 watt-hours, and heat dissipation rate of 250 watts.",
    "query": "SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;",
    "step": "【step1】: Filter records from BicycleThermodynamics where MotorEfficiency=88, BatteryCapacity=600, HeatDissipationRate=250, and AmbientTemperature is within 15-35°C.  【step2】: Calculate the HeatDissipationEfficiency using the formula (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100.  【step3】: Return the AmbientTemperature and corresponding calculated HeatDissipationEfficiency for analysis.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 178,
    "question": "Calculate the average energy consumption for different bicycle types under various riding styles, with the rider weighing 75 kg, height of 180 cm, age of 35 years. The riding styles include leisure, competitive, and off-road, and the bicycle types include road bikes, mountain bikes, and hybrid bikes.",
    "query": "SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
    "step": "【step1】: Join Bicycle and BicycleRider tables on BicycleID, filter for riders with 75kg/180cm/35 years old using WHERE clause, and limit to specified RidingStyles/Types  【step2】: Calculate individual energy consumption using (10*75 + 6.25*180 -5*35 +5) multiplied by RidingStyle coefficients (1.2/1.5/1.8) via CASE statement  【step3】: Group results by bicycle Type and RidingStyle, calculate average energy consumption for each group using AVG() aggregation",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 179,
    "question": "Calculate the rolling resistance coefficient for a bicycle with a weight of 15 kilograms, tire pressure of 65 PSI, and tire width of 30 millimeters.",
    "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;",
    "step": "【step1】:【Join Bicycle and BicycleComponents tables using BicycleID to establish component relationships】  【step2】:【Filter records where TirePressure=65 PSI, TireWidth=30mm, and Weight=15kg using WHERE clause】  【step3】:【Calculate RollingResistanceCoefficient using formula (Weight * 9.81) / (TirePressure * TireWidth) for qualifying entries】",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 180,
    "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 3000 watt-hours, motor efficiency of 98%, heat dissipation rate of 1500 watts, ambient temperature of 70°C, motor temperature of 200°C, and rider power output of 1500 watts.",
    "query": "SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;",
    "step": "【step1】: Perform INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to combine thermodynamic properties with rider power output data.  【step2】: Apply WHERE clause filters to select records with exact parameter values: BatteryCapacity=3000, MotorEfficiency=98, HeatDissipationRate=1500, AmbientTemperature=70, MotorTemperature=200, and RiderPowerOutput=1500.  【step3】: Calculate BatteryLife using the formula: BatteryCapacity divided by the sum of (RiderPowerOutput adjusted by MotorEfficiency percentage) and (HeatDissipationRate multiplied by temperature differential between MotorTemperature and AmbientTemperature).",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 181,
    "question": "Calculate the top speed of a bicycle with a power transmission efficiency of 95%, rider power output of 300 watts, tire pressure of 60 PSI, and tire width of 28 mm, for given aerodynamic drag and rolling resistance values.",
    "query": "SELECT AerodynamicDrag, RollingResistance, (300 * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance bp JOIN Bicycle b ON bp.BicycleID = b.BicycleID JOIN BicycleComponents bc ON b.BicycleID = bc.BicycleID WHERE bc.TireWidth = 28 AND b.TirePressure = 60;",
    "step": "【step1】: Perform a JOIN operation between BicyclePerformance, Bicycle, and BicycleComponents tables using BicycleID to link aerodynamic/rolling resistance data with tire specifications.  【step2】: Filter results where TirePressure = 60 PSI (from Bicycle) and TireWidth = 28mm (from BicycleComponents).  【step3】: Calculate TopSpeed using the formula (300 * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) while explicitly applying the 95% efficiency constraint.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 182,
    "question": "Calculate the climbing efficiency of different bicycle types under various riding styles, with the rider's weight at 70 kg, height at 175 cm, age at 30 years. Riding styles include leisure, competitive, and off-road, while bicycle types comprise road bikes, mountain bikes, and hybrid vehicles.",
    "query": "SELECT Type, RidingStyle, AVG((RiderPowerOutput / (RiderWeight * 9.81 * 0.1)) * 100) AS ClimbingEfficiency FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
    "step": "【step1】: Join `Bicycle` and `BicycleRider` tables using `BicycleID` to combine bicycle type data with rider performance parameters.  【step2】: Filter records where `RiderWeight=70`, `RiderHeight=175`, `RiderAge=30`, and restrict values in `RidingStyle`/`Type` to specified categories.  【step3】: Group results by `Type` and `RidingStyle`, then calculate the average climbing efficiency using the formula `(RiderPowerOutput/(RiderWeight×9.81×0.1))×100`.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 183,
    "question": "Based on the bike's weight, tire pressure, and tire width, calculate the braking distance, where the tire pressure is 60 PSI, the tire width is 28 mm, and the bike weight is 12 kg.",
    "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleComponents tables using BicycleID to combine weight, tire pressure, and tire width data.  【step2】: Apply WHERE clause to filter records with TirePressure=60 PSI, TireWidth=28mm, and Weight=12kg.  【step3】: Calculate BrakingDistance using the formula (Weight * gravitational acceleration) divided by (TirePressure * TireWidth) for qualified records.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 184,
    "question": "Calculate the braking distance for a bicycle with a weight of 20 kilograms, tire pressure of 70 PSI, tire width of 32 millimeters, and maximum load varying from 100 to 500 kilograms.",
    "query": "SELECT MaxLoad, ((Weight + MaxLoad) * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Weight = 20 AND TirePressure = 70 AND TireWidth = 32 AND MaxLoad BETWEEN 100 AND 500;",
    "step": "【step1】: Join Bicycle and BicycleComponents tables on BicycleID to combine bike specifications with component details  【step2】: Apply WHERE clause to filter records with Weight=20kg, TirePressure=70PSI, TireWidth=32mm, and MaxLoad between 100-500kg  【step3】: Calculate BrakingDistance using ((Weight + MaxLoad)*9.81)/(TirePressure*TireWidth) formula and select MaxLoad with computed values",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 185,
    "question": "Calculate the heat dissipation efficiency of an electric bicycle under different ambient temperatures, with a motor efficiency of 88%, a battery capacity of 600 watt-hours, a heat dissipation rate of 250 watts, and ambient temperatures ranging from 15°C to 35°C.",
    "query": "SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;",
    "step": "【step1】: Filter records from BicycleThermodynamics where MotorEfficiency = 88, BatteryCapacity = 600, HeatDissipationRate = 250, and AmbientTemperature is between 15°C and 35°C.  【step2】: Calculate the HeatDissipationEfficiency for each filtered record using the formula (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100.  【step3】: Output the AmbientTemperature and corresponding HeatDissipationEfficiency values.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 186,
    "question": "Calculate the average energy consumption for different types of bicycles under various riding styles, with the rider weighing 75 kg, height of 180 cm, and age of 35 years. The riding styles include leisure, competitive, and off-road, while the bicycle types consist of road bikes, mountain bikes, and hybrid bikes.",
    "query": "SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;",
    "step": "【step1】: Filter and join tables to select relevant records with specified rider attributes (weight=75kg, height=180cm, age=35) and valid riding styles/bike types.  【step2】: Calculate energy consumption per record using the formula:  `(10*75 + 6.25*180 - 5*35 +5) * style_multiplier` where multipliers are 1.2(休闲)/1.5(竞技)/1.8(越野).  【step3】: Group results by bike type and riding style to compute average energy consumption using AVG().",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 187,
    "question": "Calculate the rolling resistance coefficient for a bicycle with a weight of 15 kilograms, tire pressure of 65 PSI, and tire width of 30 millimeters.",
    "query": "SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;",
    "step": "",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 188,
    "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 3000 watt-hours, motor efficiency of 98%, heat dissipation rate of 1500 watts, ambient temperature of 70°C, motor temperature of 200°C, and rider power output of 1500 watts.",
    "query": "SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;",
    "step": "【step1】: Perform INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to combine thermodynamic parameters with rider's power output.  【step2】: Apply WHERE clause to filter records with BatteryCapacity=3000, MotorEfficiency=98, HeatDissipationRate=1500, AmbientTemperature=70, MotorTemperature=200, and RiderPowerOutput=1500.  【step3】: Calculate BatteryLife using formula (BatteryCapacity / ((RiderPowerOutput/(MotorEfficiency/100)) + (HeatDissipationRate*(MotorTemperature - AmbientTemperature)))) and select required columns.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 189,
    "question": "Calculate the top speed of a bicycle for each riding style and rider power output, with an air resistance coefficient of 0.5, rolling resistance coefficient of 0.01, and power transmission efficiency of 95%.",
    "query": "SELECT RidingStyle, RiderPowerOutput, (RiderPowerOutput * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance JOIN BicycleRider ON BicyclePerformance.BicycleID = BicycleRider.BicycleID WHERE AerodynamicDrag = 0.5 AND RollingResistance = 0.01 AND PowerTransferEfficiency = 95;",
    "step": "【step1】: Perform INNER JOIN between BicyclePerformance and BicycleRider tables using BicycleID to combine rider attributes with bicycle performance metrics.  【step2】: Filter records where AerodynamicDrag=0.5, RollingResistance=0.01, and PowerTransferEfficiency=95 to isolate specific physical conditions.  【step3】: Calculate TopSpeed using the formula (RiderPowerOutput * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance), then project RidingStyle, RiderPowerOutput, and the computed TopSpeed.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 190,
    "question": "Calculate the average cadence for riders of different age groups with various riding styles, where the riding styles include leisure, competitive, and off-road, and the age groups are categorized as 20-30 years old, 31-40 years old, and 41-50 years old.",
    "query": "SELECT CASE WHEN RiderAge BETWEEN 20 AND 30 THEN '20-30' WHEN RiderAge BETWEEN 31 AND 40 THEN '31-40' WHEN RiderAge BETWEEN 41 AND 50 THEN '41-50' END AS RiderAgeGroup, RidingStyle, AVG(RiderCadence) AS AvgCadence FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') GROUP BY RiderAgeGroup, RidingStyle;",
    "step": "【step1】: Filter records where RidingStyle is in ('Leisure', ‘Competitive’, 'Off-road') using WHERE clause  【step2】: Create age groups (20-30, 31-40, 41-50) using CASE expression on RiderAge  【step3】: Group by RiderAgeGroup and RidingStyle to calculate AVG(RiderCadence)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 191,
    "question": "Calculate the energy consumption under different cycling styles based on the rider's weight, height, and age. The cycling styles include leisure, competitive, and off-road, with a cycling duration of 1 hour.",
    "query": "SELECT RidingStyle, (10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END * 1 AS EnergyConsumption FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road');",
    "step": "【step1】: Filter riders with specified riding styles ('Leisure', ‘Competitive’, 'Off-road') and extract required fields (RidingStyle, RiderWeight, RiderHeight, RiderAge)  【step2】: Apply metabolic formula (10*RiderWeight + 6.25*RiderHeight - 5*RiderAge + 5) and calculate base energy expenditure  【step3】: Multiply by style-specific coefficients (1.2/1.5/1.8) using CASE expression to finalize EnergyConsumption",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 192,
    "question": "Calculate the battery life of an electric bicycle under extreme conditions, with a battery capacity of 5000 watt-hours, motor efficiency of 99%, a heat dissipation rate of 2000 watts, ambient temperature at 80°C, motor temperature at 250°C, and the rider's power output varying from 1000 watts to 5000 watts.",
    "query": "SELECT RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / MotorEfficiency) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 5000 AND MotorEfficiency = 99 AND HeatDissipationRate = 2000 AND AmbientTemperature = 80 AND MotorTemperature = 250 AND RiderPowerOutput BETWEEN 1000 AND 5000;",
    "step": "【step1】: Perform an INNER JOIN between BicycleThermodynamics and BicycleRider tables using BicycleID to link thermal properties with rider power output data.  【step2】: Apply WHERE clause to filter records with BatteryCapacity=5000, MotorEfficiency=99, HeatDissipationRate=2000, AmbientTemperature=80, MotorTemperature=250, and RiderPowerOutput between 1000-5000.  【step3】: Calculate BatteryLife using the formula: BatteryCapacity divided by the sum of (RiderPowerOutput divided by MotorEfficiency) and (HeatDissipationRate multiplied by temperature difference between MotorTemperature and AmbientTemperature).",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 193,
    "question": "Calculate the minimum power a rider must output when climbing a hill on a mountain bike, with a gradient of 10%, a total weight of the bike and rider of 100 kg, a rolling resistance coefficient of 0.005, an air resistance coefficient of 0.3, a frontal area of 0.5 m², a wind speed of 5 meters per second, and a climbing efficiency of 80%, for the bicycle's top speed in km/h.",
    "query": "SELECT ((100 * 9.81 * SIN(ATAN(0.1))) + (100 * 9.81 * 0.005 * COS(ATAN(0.1))) + (0.5 * 1.225 * 0.3 * 0.5 * POWER((5 + (TopSpeed * 0.277778)), 2))) * (TopSpeed * 0.277778) / 0.8 AS MinPower FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'Mountain bike')",
    "step": "【step1】: [Filter Mountain Bicycles] Execute subquery to select BicycleID from Bicycle table where Type = 'Mountain bike', establishing the target bicycle category.  【step2】: [Retrieve Performance Metrics] Access TopSpeed values from BicyclePerformance table for bicycles identified in Step 1.  【step3】: [Calculate Power Requirements] Apply the physics formula combining gravitational force (100kg × 9.81 × sin(arctan(0.1))), rolling resistance (100kg × 9.81 × 0.005 × cos(arctan(0.1))), aerodynamic drag (0.5 × 1.225 × 0.3 × frontal_area × (wind_speed + bike_speed)²), then multiply by speed (converted from km/h to m/s) and divide by 0.8 efficiency.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 194,
    "question": "Calculate the ratio of power transmission efficiency to aerodynamic drag for each bicycle and identify the top 3 bicycles with the highest ratio, with the requirement that these bicycles are priced below 10,000 yuan.",
    "query": "SELECT BicycleID, (PowerTransferEfficiency / AerodynamicDrag) AS EfficiencyRatio FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Price < 10000) ORDER BY EfficiencyRatio DESC LIMIT 3",
    "step": "【step1】: Filter BicycleIDs with Price < 10000 from Bicycle table using a subquery (SELECT BicycleID FROM Bicycle WHERE Price < 10000).  【step2】: Calculate EfficiencyRatio (PowerTransferEfficiency / AerodynamicDrag) in BicyclePerformance table for filtered BicycleIDs.  【step3】: Sort results by EfficiencyRatio in descending order and limit to top 3 records.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 195,
    "question": "Identify bicycles with carbon fiber frames and road bike type that have both weight and price below the average for bicycles with carbon fiber frames and road bike type.",
    "query": "SELECT BicycleID FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND Weight < (SELECT AVG(Weight) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike') AND Price < (SELECT AVG(Price) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike')",
    "step": "【step1】: Calculate the average weight and average price of all carbon fiber road bicycles using subqueries  【step2】: Filter bicycles with FrameMaterial = 'Carbon fiber' and Type = 'Road bike' in the main query  【step3】: Apply dual conditional filtering (Weight < calculated_avg_weight AND Price < calculated_avg_price) to select qualifying BicycleIDs",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 196,
    "question": "Calculate the percentage change in rolling resistance on different road surfaces (such as asphalt, gravel, and mud), with rolling resistance coefficients of 0.004, 0.02, and 0.05 respectively.",
    "query": "SELECT 'Asphalt road' AS Surface, ((0.004 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Gravel Road' AS Surface, ((0.02 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Muddy ground' AS Surface, ((0.05 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance",
    "step": "【step1】: Retrieve original rolling resistance coefficients from BicyclePerformance table for bicycles matching the modified specifications (WheelSize=50 inches and TirePressure=10 PSI in Bicycle table) through a JOIN operation.  【step2】: Calculate resistance change percentage for each surface type using formula ((new_coefficient - original_coefficient)/original_coefficient)*100 with hardcoded surface coefficients (0.004, 0.02, 0.05).  【step3】: Combine results for all three surfaces using UNION ALL to create unified output with Surface labels and corresponding percentage changes.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 197,
    "question": "Calculate the impact of the total weight of a bicycle (including the rider and the bicycle itself) on tire pressure, with the tire contact area remaining unchanged.",
    "query": "SELECT b.BicycleID, (b.Weight + r.RiderWeight) / (b.TirePressure * 0.07030695796) AS Tire_Pressure_Impact FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to link each bicycle with its corresponding rider data  【step2】: Calculate total system weight by summing bicycle's Weight and rider's RiderWeight for each BicycleID  【step3】: Compute tire pressure impact using formula (TotalWeight)/(TirePressure×0.07030695796), where 0.07030695796 converts PSI to kg/cm² for pressure-area relationship",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 198,
    "question": "Find the theoretical maximum speed for each bicycle based on the rider's power output, power transfer efficiency, aerodynamic drag, and rolling resistance.",
    "query": "SELECT b.BicycleID, (r.RiderPowerOutput * p.PowerTransferEfficiency) / (p.AerodynamicDrag * p.RollingResistance) AS TopSpeed_Theoretical FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID;",
    "step": "【step1】: Join Bicycle with BicyclePerformance to retrieve power transfer efficiency and resistance metrics (aerodynamic drag, rolling resistance) for each bicycle.  【step2】: Join Bicycle with BicycleRider to obtain rider power output values linked to each bicycle.  【step3】: Combine joined datasets and calculate theoretical top speed using the formula:  `(RiderPowerOutput * PowerTransferEfficiency) / (AerodynamicDrag * RollingResistance)` for each bicycle-rider pair.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 199,
    "question": "Based on the type of bicycle and the rider's cycling style, which combination has the highest count of matches?",
    "query": "SELECT b.Type, r.RidingStyle, COUNT(*) AS Match_Count FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID GROUP BY b.Type, r.RidingStyle ORDER BY Match_Count DESC;",
    "step": "【step1】: Join Bicycle and BicycleRider tables using BicycleID to associate bike types with rider styles  【step2】: Group results by bicycle Type and RidingStyle, count occurrences to determine popularity  【step3】: Sort matches in descending order by Match_Count to show most recommended combinations first",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 200,
    "question": "If the tire pressure of each bicycle is increased to 1000 PSI, calculate its impact on braking distance, with all other conditions remaining unchanged.",
    "query": "SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
    "step": "【step1】: Perform JOIN operation between Bicycle and BicyclePerformance tables using BicycleID to combine tire pressure and braking distance data.  【step2】: Calculate new braking distance by multiplying original BrakingDistance with the ratio (current TirePressure/1000 PSI).  【step3】: Select BicycleID and transformed Braking_Distance_New through the calculation in Step 2.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 201,
    "question": "Calculate the impact of the center of gravity height of each bicycle on cornering stability; during a turn, the center of gravity height is inversely proportional to cornering stability.",
    "query": "SELECT b.BicycleID, 1 / d.CenterOfGravityHeight AS Cornering_Stability_Impact FROM Bicycle b JOIN BicycleDynamics d ON b.BicycleID = d.BicycleID;",
    "step": "【step1】: Join Bicycle and BicycleDynamics tables using BicycleID to access the CenterOfGravityHeight metric  【step2】: Calculate the reciprocal value of CenterOfGravityHeight (1/CenterOfGravityHeight) to represent inverse proportionality  【step3】: Alias the calculated value as Cornering_Stability_Impact to reflect the stability indicator",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 202,
    "question": "Calculate the product of the power transmission efficiency of each bicycle and the rider's power output, and identify the bicycle with the highest product.",
    "query": "SELECT b.BicycleID, r.RiderPowerOutput * p.PowerTransferEfficiency AS Power_Output_Effective FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY Power_Output_Effective DESC LIMIT 1;",
    "step": "【step1】: Join Bicycle, BicyclePerformance and BicycleRider tables via BicycleID to associate bicycle data with performance metrics and rider power output.  【step2】: Calculate Power_Output_Effective by multiplying RiderPowerOutput from BicycleRider and PowerTransferEfficiency from BicyclePerformance for each bicycle.  【step3】: Sort results by Power_Output_Effective in descending order and select the top record with LIMIT 1 to find the maximum product.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 203,
    "question": "Based on the type of bicycle and the rider's weight, list the bicycle types and rider names where the bicycle's maximum load capacity exceeds the rider's weight.",
    "query": "SELECT b.Type, r.RiderName FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID WHERE b.MaxLoad > r.RiderWeight;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID as the linking field  【step2】: Apply WHERE filter condition to select records where bicycle's MaxLoad exceeds rider's RiderWeight  【step3】: Project final result columns by selecting Type from Bicycle and RiderName from BicycleRider",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 204,
    "question": "If the tire pressure of a bicycle is adjusted to match the value in the TirePressure field, calculate its impact on the braking distance by comparing the original braking distance with the new braking distance (calculated as the original braking distance multiplied by the tire pressure divided by 1000.0), and identify the bicycle with the largest absolute change in braking distance.",
    "query": "SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;",
    "step": "【step1】: Join the `Bicycle` and `BicyclePerformance` tables using `BicycleID` to associate each bike's tire pressure with its current braking distance.  【step2】: Calculate the **hypothetical new braking distance** by multiplying the original `BrakingDistance` by the ratio of the current `TirePressure` to 1000 PSI (`BrakingDistance * (TirePressure / 1000)`).  【step3】: Compute the **absolute change** between the original and new braking distances for each bicycle, then order the results by this change in descending order to identify the bicycle with the largest difference.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 205,
    "question": "Calculate the air resistance of an electric vehicle (bicycle) traveling at its top speed, with an air density of 1.225 kg/m³, a total frontal area of the bicycle and rider of 0.5 m², and an air drag coefficient of 0.9.",
    "query": "SELECT 0.5 * 1.225 * POWER(TopSpeed * 0.277778, 2) * 0.9 * 0.5 AS AirResistance FROM BicyclePerformance JOIN Bicycle ON BicyclePerformance.BicycleID = Bicycle.BicycleID WHERE Bicycle.Type = 'electric vehicle';",
    "step": "【step1】: Join BicyclePerformance and Bicycle tables using BicycleID to associate performance data with bicycle type  【step2】: Filter records where bicycle type is 'electric vehicle' (electric bicycle)  【step3】: Apply air resistance formula: 0.5 × air_density × (TopSpeed converted from km/h to m/s)² × drag_coefficient × frontal_area",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 206,
    "question": "Calculate the actual power delivered to the wheel for a bicycle with 85% power transmission efficiency, given that the rider's power output is 250 watts.",
    "query": "SELECT 250 * (PowerTransferEfficiency / 100) AS ActualPower FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);",
    "step": "【step1】: Execute the subquery to retrieve the BicycleID from BicycleRider where RiderPowerOutput = 250  【step2】: Query the BicyclePerformance table using the obtained BicycleID to fetch the PowerTransferEfficiency value  【step3】: Calculate ActualPower by multiplying 250W by the PowerTransferEfficiency (divided by 100 to convert percentage to decimal)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 207,
    "question": "Based on the weight of the bicycle and the rider's weight, determine whether this bicycle is suitable, with the maximum load limit being 120 kilograms.",
    "query": "SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 120 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine bicycle weight and rider weight data  【step2】: Calculate total load (Bicycle.Weight + BicycleRider.RiderWeight) and use CASE expression to compare against 120kg threshold  【step3】: Project BicycleID with suitability determination using CASE results aliased as 'Suitability' column",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 208,
    "question": "Calculate the braking distance of a road bike, with the bicycle's speed being 100 kilometers per hour converted to meters per second, the coefficient of friction between the tires and the ground at 2.0, and the gravitational acceleration at 9.8 m/s².",
    "query": "SELECT POWER(100 * 0.277778, 2) / (2 * 2.0 * 9.8 * 2) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');",
    "step": "【step1】: Execute subquery to retrieve BicycleID from Bicycle table where Type is 'Road bike'  【step2】: Convert bicycle speed from 100 km/h to m/s using 0.277778 conversion factor and apply braking distance formula: (v²)/(2*μ*g*efficiency)  【step3】: Combine subquery result with physics formula in main SELECT statement to calculate BrakingDistance from BicyclePerformance table",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 209,
    "question": "Calculate the kinetic energy of an electric bicycle when traveling at its maximum speed, given that the bicycle weighs 20 kilograms, the rider weighs 70 kilograms, and the maximum speed is 45 kilometers per hour.",
    "query": "SELECT 0.5 * (Bicycle.Weight + BicycleRider.RiderWeight) * POWER(BicyclePerformance.TopSpeed * 0.277778, 2) AS KineticEnergy FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine bicycle weight (20kg) and rider weight (70kg)  【step2】: INNER JOIN BicyclePerformance table using BicycleID to obtain TopSpeed (45 km/h) and convert speed to m/s via 45*0.277778  【step3】: Calculate kinetic energy using formula 0.5*(total_mass)*velocity² in SELECT clause and filter for 'electric vehicle' type in WHERE condition",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 210,
    "question": "Calculate the cost-benefit ratio of a bicycle, given the purchase price is 5000 yuan, the service life is 5 years, the annual riding distance is 2000 kilometers, and the cost per kilometer ridden is 0.5 yuan.",
    "query": "SELECT (Bicycle.Price + (2000 * 0.5 * 5)) / (2000 * 5) AS CostBenefitRatio FROM Bicycle WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);",
    "step": "【step1】: Execute the nested subquery to retrieve the BicycleID from BicycleRider where RiderPowerOutput equals 250  【step2】: Fetch the Price value from the Bicycle table using the obtained BicycleID  【step3】: Calculate CostBenefitRatio using formula: (Price + (annual_distance * cost_per_km * lifespan)) / (annual_distance * lifespan)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 211,
    "question": "Based on the bicycle's maximum load capacity and the rider's weight, determine whether this bicycle is suitable. The maximum load limit is 100 kilograms.",
    "query": "SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 100 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
    "step": "【step1】: Perform an INNER JOIN between the Bicycle and BicycleRider tables using BicycleID to link each bicycle with its corresponding rider data.  【step2】: Calculate the combined weight by adding Bicycle.Weight (bicycle's own weight) and BicycleRider.RiderWeight (rider's weight).  【step3】: Use a CASE statement to evaluate if the combined weight is ≤100 kg, assigning 'suitable' (suitable) or 'Not suitable' (unsuitable) based on the result.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 212,
    "question": "Calculate the braking distance of a road bike with a speed of 200 km/h, a tire-to-ground friction coefficient of 3.0, and gravitational acceleration of 9.8 m/s².",
    "query": "SELECT POWER(200 * 0.277778, 2) / (2 * 3.0 * 9.8 * 3) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');",
    "step": "【step1】: Execute the subquery `(SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike')` to retrieve the BicycleID of road bikes from the Bicycle table.  【step2】: Calculate the braking distance using the formula `POWER(200 * 0.277778, 2) / (2 * 3.0 * 9.8 * 3)`, converting speed from km/h to m/s, squaring it, and dividing by twice the product of friction coefficient, gravity, and brake efficiency (300% = 3x).  【step3】: Query the BicyclePerformance table with the retrieved BicycleID to return the calculated BrakingDistance result.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 213,
    "question": "Calculate the kinetic energy of an electric vehicle bicycle traveling at maximum speed under maximum load.",
    "query": "SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';",
    "step": "【step1】: Filter bicycles of type 'electric vehicle' from Bicycle table using WHERE clause to select relevant electric bicycles.  【step2】: JOIN BicyclePerformance table on BicycleID to access TopSpeed (converted from km/h to m/s via *1000/3600) and calculate total mass (Weight + MaxLoad).  【step3】: Apply kinetic energy formula 0.5 * total_mass * velocity² using POWER() function to compute final KineticEnergy value for each qualifying bicycle.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 214,
    "question": "Calculate the average power transmission efficiency for each type of bicycle and identify the type with the highest efficiency.",
    "query": "SELECT Type, AVG(PowerTransferEfficiency) AS AvgEfficiency FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgEfficiency DESC LIMIT 1;",
    "step": "【step1】: Perform an INNER JOIN between the 'Bicycle' and 'BicyclePerformance' tables using BicycleID to associate bicycle types with their performance metrics.  【step2】: Calculate the average PowerTransferEfficiency for each bicycle type using GROUP BY Type and AVG(PowerTransferEfficiency).  【step3】: Sort the results by AvgEfficiency in descending order and select the top result using ORDER BY and LIMIT 1 to identify the most efficient type.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 215,
    "question": "Find the average price of bicycles with a carbon fiber frame material for each manufacturer.",
    "query": "SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' GROUP BY Manufacturer;",
    "step": "【step1】: Filter Bicycle table to select records where FrameMaterial is 'Carbon fiber' using WHERE clause  【step2】: Group filtered records by Manufacturer and calculate average Price using GROUP BY and AVG()  【step3】: (Not required as query doesn't involve joins/subqueries/sorting)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 216,
    "question": "Calculate the new contact area between the tire and the ground, assuming the tire width remains unchanged.",
    "query": "SELECT Bicycle.BicycleID, (BicycleComponents.TireWidth * 1000) / 1000 AS NewContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;",
    "step": "【step1】: Join Bicycle and BicycleComponents tables via BicycleID to access tire width data  【step2】: Calculate new contact area using formula (TireWidth * 1000)/1000 (equivalent to original tire width)  【step3】: Present BicycleID with unchanged tire width values as \"NewContactArea\" due to canceled pressure ratio",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 217,
    "question": "Calculate the contact area between the bicycle tire and the ground for each bicycle and rider combination, using the formula (rider weight + bicycle weight) divided by tire pressure.",
    "query": "SELECT Bicycle.BicycleID, (BicycleRider.RiderWeight + Bicycle.Weight) / Bicycle.TirePressure AS ContactArea FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
    "step": "【step1】: Perform INNER JOIN between Bicycle and BicycleRider tables using BicycleID to combine rider and bicycle data  【step2】: Calculate total load by summing RiderWeight (rider's weight) and Weight (bicycle's weight)  【step3】: Compute contact area by dividing total load by TirePressure (using formula: ContactArea = Total_Weight / TirePressure)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 218,
    "question": "Calculate the average rolling resistance coefficient for each type of bicycle and identify the bicycle type with the lowest rolling resistance.",
    "query": "SELECT Type, AVG(RollingResistance) AS AvgRollingResistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgRollingResistance ASC LIMIT 1;",
    "step": "【step1】:Join Bicycle and BicyclePerformance tables using BicycleID to associate bicycle types with their rolling resistance data.  【step2】:Calculate average rolling resistance per bicycle type using GROUP BY Type and AVG(RollingResistance).  【step3】:Sort results by AvgRollingResistance in ascending order and select the top record using ORDER BY and LIMIT 1 to identify the type with minimal resistance.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 219,
    "question": "Find the average braking distance for bicycles with disc brakes, grouped by manufacturer.",
    "query": "SELECT Manufacturer, AVG(BrakingDistance) AS AvgBrakingDistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE BrakeType = 'Disc brakes' GROUP BY Manufacturer;",
    "step": "【step1】:【Join Bicycle table with BicyclePerformance table using BicycleID to associate braking distance data with bicycle specifications】  【step2】:【Filter records where BrakeType is 'Disc brakes' to isolate bicycles with disc brakes】  【step3】:【Group results by Manufacturer and calculate the average BrakingDistance for each group to compare braking performance】",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 220,
    "question": "If the battery capacity of a bicycle is increased to 100,000 watt-hours, calculate how much the range will increase per unit of rider power output, with motor efficiency and rider power output remaining unchanged.",
    "query": "SELECT Bicycle.BicycleID, (100000 - BicycleThermodynamics.BatteryCapacity) * BicycleThermodynamics.MotorEfficiency / BicycleRider.RiderPowerOutput AS RangeIncrease FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;",
    "step": "【step1】: Join Bicycle with BicycleThermodynamics using BicycleID to access BatteryCapacity and MotorEfficiency.  【step2】: Join the result with BicycleRider using BicycleID to obtain RiderPowerOutput.  【step3】: Calculate RangeIncrease via (100000 - BatteryCapacity) * MotorEfficiency / RiderPowerOutput for each BicycleID.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 221,
    "question": "Calculate the center of gravity height of a bicycle with a carbon fiber frame, with a rider weight of 75 kilograms, a bicycle weight of 10 kilograms, and a center of gravity height of 50 centimeters, using the formula (75 * 50 + 10 * 50) / (75 + 10 + MaxLoad).",
    "query": "SELECT BicycleID, Manufacturer, Model, (75 * 50 + 10 * 50) / (75 + 10 + MaxLoad) AS CenterOfGravityHeight FROM Bicycle WHERE FrameMaterial = 'Carbon fiber';",
    "step": "【step1】: Filter bicycles with carbon fiber frame using WHERE FrameMaterial = 'Carbon fiber'  【step2】: Calculate numerator (75kg rider * 50cm + 10kg bike * 50cm) and denominator (75+10+MaxLoad) for combined weight  【step3】: Compute CenterOfGravityHeight by dividing total moment (numerator) by total weight (denominator)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 222,
    "question": "Find the bicycle ID, manufacturer, model, and the product of the bicycle's power transfer efficiency and the rider's power output (actual power output), and list the top 5 ranked from highest to lowest actual power output.",
    "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, p.PowerTransferEfficiency * r.RiderPowerOutput AS ActualPowerOutput FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY ActualPowerOutput DESC LIMIT 5;",
    "step": "【step1】: JOIN tables Bicycle, BicyclePerformance, and BicycleRider using BicycleID to associate bicycle specifications, performance metrics, and rider data.  【step2】: Calculate ActualPowerOutput by multiplying PowerTransferEfficiency from BicyclePerformance and RiderPowerOutput from BicycleRider, then sort results in descending order.  【step3】: Limit the final output to the top 5 highest ActualPowerOutput values using the LIMIT clause.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 223,
    "question": "Retrieve all bicycles with tire pressure below 60 PSI, and list their manufacturer, model, and tire pressure.",
    "query": "SELECT Manufacturer, Model, TirePressure FROM Bicycle WHERE TirePressure < 60;",
    "step": "【step1】:【Filter records from the Bicycle table where TirePressure is below 60 PSI】  【step2】:【Select Manufacturer, Model, and TirePressure columns from the filtered records】",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 224,
    "question": "Calculate the braking distance of a bicycle with a maximum speed of 1000 m/s, a rolling resistance coefficient of 0.01, an air resistance coefficient of 0.5, a rider weight of 1000 kg, and a bicycle weight of 1000 kg.",
    "query": "SELECT BicycleID, Manufacturer, Model, (1000 * 1000) / (2 * (0.01 + 0.5) * 9.81) AS BrakingDistance FROM Bicycle;",
    "step": "【step1】: Join Bicycle table with BicyclePerformance to access rolling resistance and aerodynamic coefficients  【step2】: Calculate total mass (1000kg rider + 1000kg bicycle) and apply braking distance formula  【step3】: Final projection of BicycleID, Manufacturer, Model, and calculated BrakingDistance using physics formula with actual coefficient values",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 225,
    "question": "Identify the impact of wheelbase and rider weight on bicycle turning stability, and compute the theoretical minimum turning radius for each bicycle.",
    "query": "SELECT d.BicycleID, b.Manufacturer, b.Model, r.RiderWeight, d.Wheelbase, d.SteeringAngle, (d.Wheelbase / (2 * SIN(RADIANS(d.SteeringAngle)))) AS MinTurningRadius FROM BicycleDynamics d JOIN Bicycle b ON d.BicycleID = b.BicycleID JOIN BicycleRider r ON d.BicycleID = r.BicycleID;",
    "step": "【step1】: Join BicycleDynamics with Bicycle to get manufacturer/model and wheelbase/steering data  【step2】: Join result with BicycleRider to incorporate rider weight information  【step3】: Calculate minimum turning radius using formula (Wheelbase / (2*SIN(RADIANS(SteeringAngle)))) for each bicycle-rider combination",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 226,
    "question": "Calculate the average theoretical range of electric bicycles based on battery capacity, motor efficiency, and rider power output, grouped by ambient temperature.",
    "query": "SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency / 100) / (r.RiderPowerOutput / 1000) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;",
    "step": "【step1】: [Join tables with filtering] Connect BicycleThermodynamics to Bicycle and BicycleRider via BicycleID, filter bicycles where Type='electric vehicle'  【step2】: [Calculate theoretical range per bicycle] Compute (BatteryCapacity * MotorEfficiency/100)/(RiderPowerOutput/1000)*3.6 for each eligible bicycle  【step3】: [Aggregate by temperature] Group results by AmbientTemperature and calculate average range using AVG()",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 227,
    "question": "Find full-suspension mountain bikes that use aluminum rims and have tire widths exceeding 50mm, and calculate the average price for each manufacturer.",
    "query": "SELECT b.Manufacturer, AVG(b.Price) AS AvgPrice FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.SuspensionType = 'Full suspension' AND b.Type = 'Mountain bike' AND c.TireWidth > 50 AND c.RimMaterial = 'aluminum alloy' GROUP BY b.Manufacturer;",
    "step": "【step1】: JOIN Bicycle and BicycleComponents tables using BicycleID, filter records where SuspensionType='Full suspension', Type='Mountain bike', RimMaterial='aluminum alloy', and TireWidth > 50  【step2】: Group filtered records by Manufacturer  【step3】: Calculate AVG(Price) per group and select Manufacturer with AvgPrice",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 228,
    "question": "Calculate the required dissipation for each bicycle motor, where the motor temperature is below 100°C, based on the motor efficiency and a fixed ambient temperature scenario.",
    "query": "SELECT th.BicycleID, (5000 * (1 - th.MotorEfficiency/100) + (200 - 25) * 50) AS RequiredDissipation FROM BicycleThermodynamics th WHERE th.MotorTemperature < 100;",
    "step": "【step1】: Filter records from BicycleThermodynamics where MotorTemperature is below 100°C to ensure operational safety  【step2】: Calculate required heat dissipation using formula: (5000*(1-MotorEfficiency/100)) + ((200-25)*50), combining motor inefficiency heat and ambient thermal load",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 229,
    "question": "Calculate the aerodynamic drag power for each bicycle based on the drag coefficient, top speed, tire width, and handlebar width, and list the top 5 models with the highest aerodynamic drag power.",
    "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, 0.5 * p.AerodynamicDrag * 1.225 * POW(p.TopSpeed/3.6, 3) * (c.TireWidth/1000 * b.HandlebarWidth/100) AS AirPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleComponents c ON b.BicycleID = c.BicycleID ORDER BY AirPower DESC LIMIT 5;",
    "step": "【step1】: Join Bicycle, BicyclePerformance, and BicycleComponents tables using BicycleID to combine aerodynamic parameters, speed, tire width, and handlebar width.  【step2】: Calculate air resistance power using formula 0.5 * AerodynamicDrag * air density * (speed converted to m/s)^3 * cross-sectional area (TireWidth*HandlebarWidth converted to meters).  【step3】: Sort results by calculated AirPower in descending order and limit output to top 5 records.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 230,
    "question": "Calculate the average energy recovery efficiency for electric bicycles, based on battery capacity, motor efficiency, and rider power output, grouped by ambient temperature.",
    "query": "SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency/100) / r.RiderPowerOutput) AS EnergyRecovery FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;",
    "step": "【step1】: Join BicycleThermodynamics with Bicycle and BicycleRider tables through BicycleID, filtering only electric bicycles using WHERE clause  【step2】: Calculate energy recovery efficiency for each bicycle using formula (BatteryCapacity * MotorEfficiency/100) / RiderPowerOutput  【step3】: Group results by AmbientTemperature and compute average efficiency using AVG() function",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 231,
    "question": "Find all road bikes that use a carbon fiber frame and have tire pressure above 80 PSI, and calculate the average price by manufacturer.",
    "query": "SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND TirePressure > 80 GROUP BY Manufacturer;",
    "step": "【step1】: Filter records from Bicycle table where FrameMaterial is 'Carbon fiber', Type is 'Road bike', and TirePressure > 80 PSI  【step2】: Group the filtered records by Manufacturer  【step3】: Calculate average Price for each Manufacturer group using AVG(Price)",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 232,
    "question": "Calculate the percentage of battery capacity remaining for electric vehicle bicycles when the ambient temperature is -50°C, given the capacity decreases linearly with temperature by 0.5% for every 1°C drop from 25°C.",
    "query": "SELECT BicycleID, (100 - (25 - (-50)) * 0.5) AS CapacityRemaining FROM BicycleThermodynamics WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'electric vehicle');",
    "step": "【step1】: Retrieve all BicycleIDs from the Bicycle table where Type='electric vehicle' using a subquery.  【step2】: Filter BicycleThermodynamics records where BicycleID matches the electric bicycle IDs from step1.  【step3】: Calculate capacity percentage by applying the formula: 100 - (75 temperature delta × 0.5% degradation per °C) = 62.5%, hardcoding the initial temperature assumption as 25°C.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "1",
    "idx": 233,
    "question": "Calculate the percentage difference between the theoretical braking distance and the actual measured value for each bicycle, and list the models with a difference exceeding 10%.",
    "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance)*100 AS Deviation, p.BrakingDistance AS ActualDistance, POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) AS TheoreticalDistance FROM BicyclePerformance p JOIN Bicycle b ON p.BicycleID = b.BicycleID WHERE ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance) > 0.1",
    "step": "【step1】: Join Bicycle and BicyclePerformance tables using BicycleID to link bike metadata with performance metrics  【step2】: Calculate theoretical braking distance using the formula (TopSpeed²)/(2*(RollingResistance+AerodynamicDrag)*9.81) after converting km/h to m/s, then compute deviation percentage between theoretical and actual BrakingDistance  【step3】: Filter results where absolute deviation exceeds 10% using the condition (>0.1) in the WHERE clause, and project required columns with formatted deviation percentage",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "2",
    "idx": 234,
    "question": "Calculate the average driving range of electric bicycles across ambient temperature ranges from -20°C to 60°C, grouped in 10°C intervals, accounting for battery capacity decay based on temperature deviation from 25°C.",
    "query": "SELECT FLOOR(th.AmbientTemperature/10)*10 AS TempRange, AVG(th.BatteryCapacity * (1 - 0.005*POW(ABS(th.AmbientTemperature-25), 1.2)) * th.MotorEfficiency/100 / (r.RiderPowerOutput/1000) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY TempRange ORDER BY TempRange",
    "step": "【step1】: Filter electric bicycles by joining Bicycle table and apply temperature grouping using FLOOR(th.AmbientTemperature/10)*10  【step2】: Join Rider table to obtain power output data and calculate the battery decay formula: BatteryCapacity * (1 - 0.005*POW(ABS(Temp-25),1.2))  【step3】: Compute final range metric by incorporating MotorEfficiency and RiderPowerOutput, then aggregate averages per temperature group with sorting",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "3",
    "idx": 235,
    "question": "Find mountain bike models where the suspension type and tire width are mismatched (full suspension should have tire width >50mm, no suspension should have tire width <40mm).",
    "query": "SELECT b.BicycleID, b.Manufacturer, b.Model, b.SuspensionType, c.TireWidth FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.Type = 'Mountain bike' AND ((b.SuspensionType = 'Full suspension' AND c.TireWidth <= 50) OR (b.SuspensionType = 'No suspension' AND c.TireWidth >= 40))",
    "step": "【step1】: Join Bicycle and BicycleComponents tables on BicycleID, filtering for 'Mountain bike' type.  【step2】: Apply condition for full-suspension bikes with incompatible tire widths (SuspensionType='Full suspension' AND TireWidth ≤50mm).  【step3】: Add condition for hardtail bikes with incompatible tire widths (SuspensionType='No suspension' AND TireWidth ≥40mm), combining both cases with OR logic.",
    "format": "MySQL"
  },
  {
    "db_id": "bike",
    "type": "4",
    "idx": 236,
    "question": "Calculate the theoretical temperature rise of an electric vehicle motor when continuously operating at a load of 500 kg for 1 hour, with an ambient temperature of 60°C and no cooling system.",
    "query": "SELECT th.BicycleID, (r.RiderPowerOutput/(th.MotorEfficiency/100) * 3600 * (1 - th.MotorEfficiency/100)) / (500 * 0.9) + 60 AS TheoreticalTemp FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' AND b.MaxLoad >= 500",
    "step": "【step1】: Join BicycleThermodynamics, Bicycle, and BicycleRider tables on BicycleID to access motor efficiency, power output, and load capacity data  【step2】: Apply filters for electric bicycles (b.Type='electric vehicle') with maximum load ≥500kg (b.MaxLoad >= 500)  【step3】: Calculate theoretical temperature rise using formula: [(RiderPowerOutput/(MotorEfficiency/100) * 3600 * (1 - MotorEfficiency/100)) / (500*0.9)] + 60°C ambient temperature",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 237,
    "question": "Please query engine models with a compression ratio between 10:1 and 12:1, calculate their theoretical maximum thermal efficiency (based on the Otto cycle), and sort the results in ascending order by compression ratio.",
    "query": "SELECT Model, Compression_Ratio, (1 - (1/POW(Compression_Ratio, 0.4))) AS Thermal_Efficiency FROM engine WHERE Compression_Ratio BETWEEN 10 AND 12 AND Fuel_Type = 'Gasoline' ORDER BY Compression_Ratio ASC;",
    "step": "【step1】: Filter records from engine table where Fuel_Type is 'Gasoline' and Compression_Ratio between 10 and 12  【step2】: Calculate theoretical maximum thermal efficiency using the Otto cycle formula (1 - 1/POW(Compression_Ratio, 0.4)) for qualified engines  【step3】: Sort the results by Compression_Ratio in ascending order",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 238,
    "question": "Please calculate the single-cylinder displacement for all inline 6-cylinder engines, verify whether the total displacement equals the value in the Displacement field, and sort the top 5 by the absolute value of calculation error in descending order.",
    "query": "SELECT Model, Displacement, (PI() * POW(Bore/20, 2) * Stroke/10)/1000 AS 单缸排量, ABS(Displacement - (PI() * POW(Bore/20, 2) * Stroke/10)/1000 * Cylinders) AS error FROM engine WHERE Configuration = 'Inline' AND Cylinders = 6 ORDER BY error DESC LIMIT 5;",
    "step": "【step1】: Filter engines meeting criteria (Configuration='Inline' AND Cylinders=6) from engine table  【step2】: Calculate per-cylinder displacement using (π*(Bore/20)^2*Stroke/10)/1000 and compute error between calculated total displacement and Displacement field  【step3】: Sort results by absolute error descending and limit to top 5 records",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 239,
    "question": "Please list the top 10 engines that are turbocharged (Aspiration='Turbocharged') and use cast iron cylinder blocks (Block_Material='Cast Iron'), sorted in descending order by specific power (Specific_Power).",
    "query": "SELECT e.Model, e.Aspiration, ep.Specific_Power FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND m.Block_Material = 'Cast Iron' ORDER BY ep.Specific_Power DESC LIMIT 10;",
    "step": "【step1】: Join engine, enginematerials, and engineperformance tables via Engine_ID to combine engine attributes, material composition, and performance metrics  【step2】: Filter records where Aspiration='Turbocharged' and Block_Material='Cast Iron' using WHERE clause  【step3】: Sort results by Specific_Power in descending order and limit output to top 10 entries using ORDER BY and LIMIT",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 240,
    "question": "Assuming the redline speed (Redline) for all engines is increased to 100,000 RPM, calculate the piston speed (Piston_Speed=2*Stroke*RPM/60) at this condition and list the models that exceed the speed of sound (343 m/s), sorted in descending order by piston speed.",
    "query": "SELECT Model, Stroke, (2 * Stroke * 100000) / 60000 AS Piston_Speed FROM engine WHERE (2 * Stroke * 100000) / 60000 > 343 ORDER BY Piston_Speed DESC;",
    "step": "【step1】: Calculate piston speed using the formula (2*Stroke*100000)/60000 for all entries in the 'engine' table.  【step2】: Filter results where the calculated piston speed exceeds the speed of sound (343 m/s).  【step3】: Sort the remaining entries in descending order based on the calculated piston speed.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 241,
    "question": "Retrieve the top three engine models with the largest volume (length × width × height), sorted in descending order by volume, and provide their compression ratios.",
    "query": "SELECT e.Model, (ed.Length * ed.Width * ed.Height) AS Volume, e.Compression_Ratio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY Volume DESC LIMIT 3;",
    "step": "【step1】: Join the 'engine' and 'enginedimensions' tables using Engine_ID to combine engine specifications with dimensional data.  【step2】: Calculate engine volume (Length × Width × Height) for each model, sort results by volume in descending order.  【step3】: Limit output to top 3 records while retaining the Compression_Ratio from the engine table.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 242,
    "question": "Calculate the total surface area of cylinders for all V-type arrangement engines (assuming the cylinder is a cylinder, surface area = 2πr² + 2πrh), sort in ascending order by surface area and take the top five.",
    "query": "SELECT e.Model, (2 * PI() * POWER(e.Bore/2000, 2) + 2 * PI() * (e.Bore/2000) * (e.Stroke/1000)) * e.Cylinders * 2 AS TotalSurfaceArea FROM engine e WHERE e.Configuration LIKE 'V%%' ORDER BY TotalSurfaceArea ASC LIMIT 5;",
    "step": "【step1】: Filter engines with V-type configuration using WHERE clause on e.Configuration LIKE 'V%%'.  【step2】: Calculate total surface area per engine using cylindrical formula (2πr² + 2πrh), with Bore/2000 (radius in meters) and Stroke/1000 (height in meters), then multiply by Cylinders * 2 (assuming dual-bank arrangement in V-configuration).  【step3】: Sort results by TotalSurfaceArea in ascending order and apply LIMIT 5 to retrieve the top 5 entries.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 243,
    "question": "Query the engine models with a weight exceeding 150 kilograms and a length less than 600 millimeters, sorted in descending order by the power-to-weight ratio.",
    "query": "SELECT e.Model, (e.Horsepower / e.Weight) AS PowerWeightRatio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > 150 AND ed.Length < 600 ORDER BY PowerWeightRatio DESC;",
    "step": "【step1】: Perform an INNER JOIN between `engine` and `enginedimensions` tables using `Engine_ID`, then apply filters `Weight > 150` (from engine) and `Length < 600` (from enginedimensions).  【step2】: Calculate the derived metric `PowerWeightRatio` by dividing `Horsepower` by `Weight` for qualifying engine models.  【step3】: Sort the results in descending order of `PowerWeightRatio` using the calculated alias in the ORDER BY clause.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 244,
    "question": "Assuming the cylinder spacing is expanded to 10,000 mm (far exceeding the actual value), calculate the virtual total volume (Length × Width × Height + 10000 × Cylinders) for all engines, and select the top two with the largest volumes.",
    "query": "SELECT e.Model, (ed.Length * ed.Width * ed.Height) + (10000 * e.Cylinders) AS VirtualVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY VirtualVolume DESC LIMIT 2;",
    "step": "【step1】: JOIN 'engine' and 'enginedimensions' tables using Engine_ID to combine engine specifications with dimensional data.  【step2】: Calculate VirtualVolume for each engine using formula (Length×Width×Height) + (10000×Cylinders).  【step3】: Sort results by VirtualVolume descending and select top 2 entries with LIMIT 2.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 245,
    "question": "Calculate the average volume (in cubic decimeters) of engines for each manufacturer and identify the manufacturer with the largest average volume.",
    "query": "SELECT e.Manufacturer, AVG((ed.Length/100) * (ed.Width/100) * (ed.Height/100)) AS AvgVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Manufacturer ORDER BY AvgVolume DESC LIMIT 1;",
    "step": "【step1】: Join the 'engine' and 'enginedimensions' tables via Engine_ID to link manufacturers with dimensional data.  【step2】: Calculate volume (converted to cubic decimeters using (Length*Width*Height)/1000000 via (Length/100)*(Width/100)*(Height/100)) for each engine, then compute average volume per manufacturer using GROUP BY.  【step3】: Sort manufacturers by AvgVolume in descending order and select the top result using LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 246,
    "question": "Calculate the theoretical total length of inline engines, compare it with the actual Length, and output the 5 engines with the largest absolute differences, including the number of cylinders and the difference.",
    "query": "SELECT e.Cylinders, ABS(((e.Cylinders-1)*ed.Cylinder_Spacing + (e.Bore*e.Cylinders)) - ed.Length) AS DeltaL FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'Inline' ORDER BY DeltaL DESC LIMIT 5;",
    "step": "【step1】: Join engine and enginedimensions tables via Engine_ID, filter engines with 'Inline' configuration.  【step2】: Calculate theoretical length using formula ((Cylinders-1)*Cylinder_Spacing + Bore*Cylinders), compute absolute difference from actual Length as DeltaL.  【step3】: Order results by DeltaL descending, group by Cylinders, and limit to top 5 records with largest deviations.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 247,
    "question": "Identify engines whose weight exceeds the theoretical maximum volume assuming cast iron density (7.3 kg/dm³), and group and count the anomalies by manufacturer.",
    "query": "SELECT e.Manufacturer, COUNT(*) AS AnomalyCount FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > ((ed.Length/100)*(ed.Width/100)*(ed.Height/100))*7.3 GROUP BY e.Manufacturer;",
    "step": "【step1】: Join engine table with enginedimensions table on Engine_ID to establish dimensional relationships  【step2】: Calculate theoretical weight limit using (L/100 * W/100 * H/100)*7.3 (converting mm to dm³) and compare with actual Weight  【step3】: Filter engines exceeding theoretical weight, group by Manufacturer, and count anomalies per group",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 248,
    "question": "Assuming there exists an engine with cylinder spacing equal to the Earth's diameter, calculate the theoretical number of circumferences around the Earth's equator it could make, given the engine's bore, and output the result grouped by Engine_ID.",
    "query": "SELECT e.Engine_ID, ((10000-1)*12742000000 + e.Bore)/40075000000 AS Circles FROM engine e;",
    "step": "【step1】: Calculate theoretical engine length using (10000-1)*Earth diameter (12742000000 mm) + Bore for each engine.  【step2】: Divide the calculated length by Earth's equatorial circumference (40075000000 mm) to determine wrap circles.  【step3】: Group and output results by Engine_ID (implicit via primary key uniqueness, no explicit grouping needed).",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 249,
    "question": "Calculate the angular velocity of an engine at its maximum speed and filter out the engines whose angular velocity exceeds the material limit of the crankshaft.",
    "query": "SELECT e.Engine_ID, e.Model, (2 * PI() * ed.Max_turn) / 60 AS Angular_Velocity, em.Crankshaft_Material FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE ((2 * PI() * ed.Max_turn) / 60) > CASE WHEN em.Crankshaft_Material = 'Forged Steel' THEN 1000 WHEN em.Crankshaft_Material = 'Cast Iron' THEN 800 ELSE 500 END;",
    "step": "【step1】: Join engine, enginedynamics, and enginematerials tables through Engine_ID to combine core parameters  【step2】: Calculate angular velocity using formula (2π*max_turn)/60 in SELECT clause  【step3】: Apply CASE-based material threshold filtering in WHERE condition (Forged Steel:1000, Cast Iron:800, others:500)",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 250,
    "question": "Calculate the theoretical thermal efficiency of an engine at peak power speed, excluding models with a specific power output below 100 horsepower per liter.",
    "query": "SELECT e.Engine_ID, e.Model, (ep.BMEP * 1e5 * e.Displacement * ed.Peak_Power * 0.00001667) / (ep.Fuel_Consumption * 34.2e6) * 100 AS Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power >= 100;",
    "step": "【step1】: Join engine, enginedynamics, and engineperformance tables using Engine_ID to combine core parameters  【step2】: Filter records where Specific_Power ≥ 100 to exclude low power-to-displacement ratio engines  【step3】: Calculate thermal efficiency using formula: (BMEP × Displacement × Peak_Power × 0.001667) / (Fuel_Consumption × 34.2e6) × 100 at peak power RPM",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 251,
    "question": "Filter engines with a compression ratio exceeding 14:1 and using gasoline, as these engines may develop knocking issues.",
    "query": "SELECT Engine_ID, Model, Compression_Ratio, Fuel_Type FROM engine WHERE Compression_Ratio > 14 AND Fuel_Type = 'Gasoline';",
    "step": "【step1】: Select Engine_ID, Model, Compression_Ratio, and Fuel_Type columns from the engine table.  【step2】: Apply the filter condition Compression_Ratio > 14 to identify engines with high compression ratios.  【step3】: Further filter results by Fuel_Type = 'Gasoline' to isolate engines using standard gasoline.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 252,
    "question": "Find engines where the piston speed exceeds the material's threshold when the assumed rotation speed reaches 1,800,000,000 RPM (assuming piston material thresholds: aluminum 25 m/s, steel 30 m/s).",
    "query": "SELECT e.Engine_ID, e.Model, 2 * e.Stroke * (1800000000/60)/1000 AS Piston_Speed, em.Piston_Material FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE 2 * e.Stroke * (1800000000/60)/1000 > CASE WHEN em.Piston_Material = 'Aluminum' THEN 25 WHEN em.Piston_Material = 'Steel' THEN 30 ELSE 0 END;",
    "step": "【step1】: Join engine and enginematerials tables to associate engines with their piston material types  【step2】: Calculate piston speed using formula 2*Stroke*(crank_speed/60)/1000 (with assumed crank speed 1.8 billion RPM)  【step3】: Apply material-specific speed thresholds (Aluminum=25 m/s, Steel=30 m/s) using CASE statement in WHERE clause",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 253,
    "question": "Assuming the engine block materials are cast iron and aluminum alloy, which type of engine material and coating type combination has the highest average heat rejection rate?",
    "query": "SELECT m.Block_Material, m.Coating_Type, AVG(t.Heat_Rejection_Rate) AS Avg_Heat_Rejection_Rate FROM enginematerials m JOIN enginethermodynamics t ON m.Engine_ID = t.Engine_ID WHERE m.Block_Material IN ('Cast Iron', 'Aluminum') GROUP BY m.Block_Material, m.Coating_Type ORDER BY Avg_Heat_Rejection_Rate DESC;",
    "step": "【step1】: Filter engine materials to only include 'Cast Iron' or 'Aluminum' blocks, then JOIN with thermodynamics data using Engine_ID.  【step2】: Calculate average heat rejection rate for each group of Block_Material and Coating_Type.  【step3】: Sort results by Avg_Heat_Rejection_Rate in descending order to prioritize higher thermal rejection values.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 254,
    "question": "Count the number of different cylinder block materials in engines that use forged steel crankshafts and titanium connecting rods, and calculate their percentage of the total. Group by cylinder block material and connecting rod material.",
    "query": "WITH Total AS ( SELECT COUNT(*) AS TotalCount FROM enginematerials WHERE Crankshaft_Material = 'Forged Steel' AND Connecting_Rod_Material = 'Titanium' ) SELECT m.Block_Material, m.Connecting_Rod_Material, COUNT(*) AS Count, ROUND((COUNT(*) * 100.0 / (SELECT TotalCount FROM Total)), 2) AS Percentage FROM enginematerials m WHERE m.Crankshaft_Material = 'Forged Steel' AND m.Connecting_Rod_Material = 'Titanium' GROUP BY m.Block_Material, m.Connecting_Rod_Material;",
    "step": "【step1】: Calculate total number of engines meeting the condition using CTE: Filter records where Crankshaft_Material='Forged Steel' and Connecting_Rod_Material='Titanium', then COUNT(*) to get TotalCount.  【step2】: Group qualified records by Block_Material and Connecting_Rod_Material: Apply same material filters, then perform GROUP BY with COUNT(*) for each group.  【step3】: Calculate percentage using scalar subquery: Divide each group's count by pre-calculated TotalCount from CTE, multiply by 100 and round to 2 decimal places.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 255,
    "question": "Identify which engines use both cast iron cylinder blocks and aluminum alloy pistons, and group and count the quantities by compression ratio ranges.",
    "query": "SELECT CASE WHEN e.Compression_Ratio < 10 THEN 'Low (<10)' WHEN e.Compression_Ratio BETWEEN 10 AND 12 THEN 'Medium (10-12)' WHEN e.Compression_Ratio > 12 THEN 'High (>12)' END AS Compression_Ratio_Range, COUNT(*) AS Engine_Count FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND m.Piston_Material IN ('Aluminum', 'Forged Aluminum') GROUP BY Compression_Ratio_Range ORDER BY MIN(e.Compression_Ratio);",
    "step": "【step1】: Filter engines with Cast Iron block and Aluminum-based pistons using JOIN between engine and enginematerials tables, applying WHERE conditions for Block_Material = 'Cast Iron' AND Piston_Material IN ('Aluminum', 'Forged Aluminum').  【step2】: Categorize remaining engines into compression ratio ranges using CASE expression to create Compression_Ratio_Range groups (Low/Medium/High).  【step3】: Perform COUNT aggregation grouped by compression ranges and order results by MIN(Compression_Ratio) to maintain natural numerical sequence of range thresholds.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 256,
    "question": "Assuming the piston material of all engines is changed to a fictional ultra-heavy alloy with a density of 10,000 kg/m³, calculate the theoretical total weight of the pistons grouped by the number of cylinders (assuming a constant piston volume of 500 cm³).",
    "query": "SELECT Cylinders, SUM(10000 * 0.0005 * Cylinders) AS Total_Piston_Weight FROM engine GROUP BY Cylinders ORDER BY Cylinders;",
    "step": "【step1】: Calculate individual piston weight per engine: 10000 kg/m³ density * 0.0005 m³ (converted from 500 cm³) = 5 kg per piston  【step2】: Multiply by cylinder count per engine (5 * Cylinders) and aggregate by cylinders using SUM() with GROUP BY  【step3】: Sort results numerically using ORDER BY Cylinders",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 257,
    "question": "In the engine materials table, assuming that the cylinder block material of an engine is cast iron (Cast Iron) and the cylinder head material is aluminum alloy (Aluminum), with the thermal conductivity of cast iron known to be 80 W/m·K and that of aluminum alloy being 205 W/m·K. If the contact area between the cylinder block and cylinder head during engine operation is 0.5 square meters, with a temperature difference of 200°C, and the thickness is 0.01 meters, calculate the heat flow rate through the contact surface (in watts).",
    "query": "SELECT (2*(80*205)/(80+205)) * 0.5 * 200 / 0.01 AS Heat_Flow FROM enginematerials WHERE Block_Material = 'Cast Iron' AND Head_Material = 'Aluminum';",
    "step": "【step1】: Filter the enginematerials table to find entries where Block_Material is 'Cast Iron' and Head_Material is 'Aluminum'.  【step2】: Calculate the harmonic mean of thermal conductivities: (2 × 80 × 205) / (80 + 205).  【step3】: Multiply the harmonic mean by contact area (0.5), temperature difference (200), and divide by thickness (0.01) to compute Heat_Flow.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 258,
    "question": "The piston of a certain engine is made of forged aluminum alloy (density 2.7 g/cm³), and the connecting rod is made of titanium alloy (density 4.5 g/cm³). If the piston volume is 0.002 cubic meters and the connecting rod volume is 0.001 cubic meters, calculate the total mass of both (in kilograms). Does this meet the requirement if the total mass must not exceed 5 kilograms?",
    "query": "SELECT (0.002*2700 + 0.001*4500) AS Total_Mass, CASE WHEN (0.002*2700 + 0.001*4500) <= 5 THEN 'Satisfaction' ELSE 'Unsatisfied' END AS 质量判定 FROM enginematerials WHERE Piston_Material = 'Forged Aluminum' AND Connecting_Rod_Material = 'Titanium';",
    "step": "【step1】: Calculate total mass by converting volumes to kg: (0.002m³ * 2700kg/m³) + (0.001m³ * 4500kg/m³)  【step2】: Apply conditional logic with CASE to check if total ≤5kg  【step3】: Filter records in enginematerials table where Piston_Material = 'Forged Aluminum' AND Connecting_Rod_Material = 'Titanium'",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 259,
    "question": "Why do engines with a compression ratio of at least 12:1 that use aluminum for cylinder heads and have a thermal conductivity greater than 150 require the use of aluminum alloy for cylinder heads instead of cast iron?",
    "query": "SELECT e.Model, e.Compression_Ratio, em.Head_Material, et.Thermal_Conductivity FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Compression_Ratio >= 12 AND em.Head_Material = 'Aluminum' AND et.Thermal_Conductivity > 150;",
    "step": "【step1】: Filter engines with compression ratio ≥12:1 and join materials table to identify aluminum cylinder heads  【step2】: Join thermodynamics table to validate thermal conductivity >150 W/m·K  【step3】: Combine conditions to show models meeting both material and thermal requirements for high compression operation",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 260,
    "question": "If the thermal expansion coefficient of a certain crankshaft material is set to 1×10^-4 /°C (far exceeding the 1.2×10^-5 /°C for real steel), and the engine operating temperature rises from 20°C to 1000°C. Assuming the original length of the crankshaft is 500 millimeters, calculate the expanded length and determine whether the main bearing bore can fit the expanded crankshaft.",
    "query": "SELECT ed.Main_Bore_Diameter, 500*(1+0.0001*(1000-20)) AS 膨胀后长度, CASE WHEN 500*(1+0.0001*980) <= ed.Main_Bore_Diameter THEN '可配合' ELSE '不可配合' END AS 配合判定 FROM enginedimensions ed JOIN enginematerials em ON ed.Engine_ID = em.Engine_ID WHERE em.Crankshaft_Material = 'Forged Steel';",
    "step": "【step1】: Perform INNER JOIN between enginedimensions (aliased as ed) and enginematerials (aliased as em) using Engine_ID, filtering records where Crankshaft_Material is 'Forged Steel'.  【step2】: Calculate expanded length using formula: 500*(1+0.0001*(1000-20)), representing thermal expansion with given coefficient (ΔT=980°C).  【step3】: Execute CASE statement to compare expanded length against Main_Bore_Diameter, returning '可配合' if within tolerance or '不可配合' if exceeding dimensions.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 261,
    "question": "Calculate the angular velocity of each engine and identify the top three engine models with the highest angular velocity, sorted in descending order.",
    "query": "SELECT e.Model, ed.Angular_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID ORDER BY ed.Angular_Velocity DESC LIMIT 3;",
    "step": "【step1】: JOIN engine and enginedynamics tables using Engine_ID to link model and angular velocity  【step2】: Order results by Angular_Velocity in descending sequence  【step3】: Restrict output to top 3 records with LIMIT clause",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 262,
    "question": "Calculate the instantaneous speed of each engine piston at maximum RPM, identify the top 5 fastest engines, and sort them in descending order. Verify data consistency between calculated piston speed and Mean_Piston_Speed.",
    "query": "SELECT e.Model, (2 * e.Stroke/1000 * ed.Max_turn)/60 AS Calculated_Speed, ed.Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE ABS(((2 * e.Stroke/1000 * ed.Max_turn)/60 - ed.Mean_Piston_Speed)/ed.Mean_Piston_Speed) <= 0.02 ORDER BY Calculated_Speed DESC LIMIT 5;",
    "step": "【step1】: Join engine and enginedynamics tables to calculate instantaneous piston speed (2*Stroke/1000*Max_turn/60) and validate data consistency between the calculated value and Mean_Piston_Speed.  【step2】: Filter results where the relative difference between calculated speed and Mean_Piston_Speed is ≤2% using absolute error tolerance.  【step3】: Sort filtered engines by calculated speed descending, retain top5 entries, and output them in ascending order via reverse sorting.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 263,
    "question": "Find all diesel engine models with peak torque below 2000, sorted alphabetically by manufacturer.",
    "query": "SELECT e.Manufacturer, e.Model, ed.Peak_Torque FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Fuel_Type = 'Diesel' AND ed.Peak_Torque < 2000 ORDER BY e.Manufacturer ASC;",
    "step": "【step1】: Join 'engine' and 'enginedynamics' tables using Engine_ID to combine manufacturer data with torque performance metrics.  【step2】: Filter records where Fuel_Type is 'Diesel' and Peak_Torque < 2000 RPM using conditional clauses.  【step3】: Sort the final results alphabetically by Manufacturer using ORDER BY ASC.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 264,
    "question": "Assuming the existence of a rotary engine with a rotational speed of 100,000 RPM, calculate whether its piston speed exceeds 250 m/s, and list all hypothetical model variants where the calculated results exceed 250 m/s.",
    "query": "SELECT e.Model, (2 * e.Stroke/1000 * 100000)/60 AS Hypothetical_Speed FROM engine e WHERE e.Configuration = 'Rotary' AND (2 * e.Stroke/1000 * 100000)/60 > 250 ORDER BY Hypothetical_Speed DESC;",
    "step": "【step1】: Filter all rotary configuration engines from the 'engine' table using WHERE e.Configuration = 'Rotary'  【step2】: Calculate hypothetical piston speed (2*Stroke/1000*100000)/60 for each qualifying engine and filter results exceeding 250 m/s through the WHERE clause calculation  【step3】: Sort remaining records by descending Hypothetical_Speed and project Model with calculated speed using ORDER BY ... DESC and SELECT clause",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 265,
    "question": "Calculate the ratio of the engine's effective work to the input fuel heating value, and list the top 3 engine models with the highest thermal efficiency along with their respective thermal efficiency values and effective work ratios.",
    "query": "SELECT e.Model, ep.Thermal_Efficiency, (ep.Thermal_Efficiency / 100) AS Effective_Work_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID ORDER BY ep.Thermal_Efficiency DESC LIMIT 3;",
    "step": "【step1】: JOIN engine and engineperformance tables using Engine_ID to combine engine model and thermal efficiency data.  【step2】: Calculate Effective_Work_Ratio by converting Thermal_Efficiency percentage to decimal (dividing by 100).  【step3】: Sort results by Thermal_Efficiency in descending order and limit output to the top 3 records.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 266,
    "question": "Calculate the BMEP (Brake Mean Effective Pressure) for each engine and sort in descending order, where BMEP = (2×π×Torque×Cylinders) / (Displacement×1000). The output should include engine models and their BMEP values where BMEP exceeds 15 Bar.",
    "query": "SELECT e.Model, (2 * PI() * e.Torque * e.Cylinders) / (e.Displacement * 1000) AS BMEP FROM engine e WHERE (2 * PI() * e.Torque * e.Cylinders) / (e.Displacement * 1000) > 15 ORDER BY BMEP DESC;",
    "step": "【step1】: Select engine models and calculate BMEP using the formula (2*π*Torque*Cylinders)/(Displacement*1000) from the engine table.  【step2】: Filter results where the calculated BMEP exceeds 15 Bar.  【step3】: Sort the filtered results in descending order of BMEP values.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 267,
    "question": "Find engine models and their displacement and fuel consumption where the fuel consumption is lower than the average fuel consumption for engines with the same displacement, sorted in ascending order of displacement.",
    "query": "WITH displacement_avg AS (SELECT Displacement, AVG(Fuel_Consumption) AS avg_fuel FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY Displacement) SELECT e.Model, e.Displacement, ep.Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID JOIN displacement_avg da ON e.Displacement = da.Displacement WHERE ep.Fuel_Consumption < da.avg_fuel ORDER BY e.Displacement ASC;",
    "step": "【step1】: Calculate average fuel consumption per displacement using a CTE by joining engine and engineperformance tables, grouping results by Displacement.  【step2】: Join engine and engineperformance tables with the CTE to filter engines where actual fuel consumption is below their displacement group's average.  【step3】: Sort results by Displacement in ascending order to show engines with fuel efficiency anomalies relative to their displacement size.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 268,
    "question": "Assuming an engine's power-to-weight ratio (Power_To_Weight_Ratio) reaches 1000 horsepower per kilogram (far exceeding practical physical limits), its weight must approach zero. Please list all engine models where the Weight field is 0 and Power_To_Weight_Ratio > 500, sorted in ascending order by weight.",
    "query": "SELECT e.Model, e.Weight, ep.Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Weight = 0 AND ep.Power_To_Weight_Ratio > 500 ORDER BY e.Weight ASC;",
    "step": "",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 269,
    "question": "Identify engines in the `engineperformance` table where the BMEP exceeds 15 Bar and the thermal efficiency is below 30%.",
    "query": "SELECT Engine_ID FROM engineperformance WHERE BMEP > 15 AND Thermal_Efficiency < 30;",
    "step": "【step1】: Select Engine_ID from the engineperformance table  【step2】: Apply filter condition BMEP > 15  【step3】: Further filter results with Thermal_Efficiency < 30",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 270,
    "question": "Calculate the composite metric of power-to-weight ratio and specific power: (Power_To_Weight_Ratio × 1000) / Specific_Power, where the value must be greater than or equal to the square root of displacement (Displacement), and exclude electric engines (Fuel_Type='Electric').",
    "query": "SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE (ep.Power_To_Weight_Ratio * 1000) / ep.Specific_Power >= SQRT(e.Displacement) AND e.Fuel_Type != 'Electric';",
    "step": "【step1】: Perform INNER JOIN between engine and engineperformance tables using Engine_ID to combine engine specifications with performance metrics.  【step2】: Apply filtering conditions: exclude electric engines (Fuel_Type != 'Electric') and enforce (Power_To_Weight_Ratio * 1000 / Specific_Power) ≥ SQRT(Displacement).  【step3】: Select Engine_ID from the filtered results to output qualifying engine identifiers.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 271,
    "question": "Find gasoline engines with a fuel consumption rate lower than the industry benchmark value for engines of the same displacement (benchmark formula: 6 + 0.5 × Displacement) and a thermal efficiency higher than 35%.",
    "query": "SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type = 'Gasoline' AND ep.Fuel_Consumption < (6 + 0.5 * e.Displacement) AND ep.Thermal_Efficiency > 35;",
    "step": "【step1】: Join the 'engine' and 'engineperformance' tables using Engine_ID to access both displacement and performance metrics.  【step2】: Filter engines where Fuel_Type = 'Gasoline' to isolate gasoline-powered engines.  【step3】: Apply dual conditions: calculate the displacement-based benchmark (6 + 0.5 * Displacement) to compare with Fuel_Consumption, and require Thermal_Efficiency > 35%.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 272,
    "question": "Assume there exists an engine with a thermal efficiency exceeding 88%, and a specific torque reaching 10^6 N·m/L, please verify whether these engines also simultaneously meet BMEP exceeding 1000 Bar.",
    "query": "SELECT Engine_ID FROM engineperformance WHERE Thermal_Efficiency > 88 AND Specific_Torque >= 1000000 AND BMEP > 1000;",
    "step": "【step1】: Calculate the thermal efficiency threshold using the Carnot formula: η_limit = 1 - T_cold/T_hot = 1 - 300/2500 = 88%.  【step2】: Filter engines in engineperformance where Thermal_Efficiency > 88% (exceeding Carnot limit), Specific_Torque ≥ 1000000 N·m/L.  【step3】: Verify if the filtered engines from step 2 also have BMEP > 1000 Bar through the final AND condition in the WHERE clause.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 273,
    "question": "Calculate the average Brake Mean Effective Pressure (BMEP) and average thermal efficiency for different fuel types (Fuel_Type), grouped by fuel type.",
    "query": "SELECT e.Fuel_Type, AVG((2 * PI() * e.Torque) / (e.Displacement * 100000)) AS Avg_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Fuel_Type;",
    "step": "",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 274,
    "question": "Statistics on the weighted geometric mean of engine specific power (Specific_Power) and specific torque (Specific_Torque) by manufacturer (Manufacturer), grouped by manufacturer and sorted by the weighted geometric mean in descending order.",
    "query": "SELECT e.Manufacturer, EXP(SUM(e.Displacement * LN(ep.Specific_Power * ep.Specific_Torque)) / SUM(e.Displacement)) AS Weighted_Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power > 0 AND ep.Specific_Torque > 0 GROUP BY e.Manufacturer ORDER BY Weighted_Geometric_Mean DESC;",
    "step": "【step1】: Join the 'engine' and 'engineperformance' tables via Engine_ID, filtering entries where both Specific_Power and Specific_Torque are positive.  【step2】: Calculate the weighted geometric mean using displacement as weights via EXP(SUM(Displacement * LN(Specific_Power * Specific_Torque)) / SUM(Displacement)) grouped by Manufacturer.  【step3】: Sort results by the calculated weighted geometric mean in descending order per manufacturer group.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 275,
    "question": "Analyze the impact of the number of cylinders (Cylinders) on fuel consumption rate (Fuel_Consumption) and thermal efficiency (Thermal_Efficiency), and output the average fuel consumption rate and average thermal efficiency grouped by the number of cylinders.",
    "query": "SELECT e.Cylinders, AVG(ep.Fuel_Consumption) AS Avg_Fuel_Consumption, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Cylinders ORDER BY e.Cylinders;",
    "step": "【step1】: Join the 'engine' and 'engineperformance' tables using the shared 'Engine_ID' to combine cylinder data with performance metrics.  【step2】: Group the results by 'Cylinders' and calculate the average values for both 'Fuel_Consumption' and 'Thermal_Efficiency' using the AVG() function.  【step3】: Sort the grouped results in ascending order based on 'Cylinders' to provide a structured output.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 276,
    "question": "Assuming there are engines with a fuel consumption rate less than 0 or greater than 500 liters/100 km, group statistics by fuel type (Fuel_Type) to analyze the average power-to-weight ratio (Power_To_Weight_Ratio) for these outliers.",
    "query": "SELECT e.Fuel_Type, COUNT(*) AS Anomaly_Count, AVG(ep.Power_To_Weight_Ratio) AS Avg_Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Fuel_Consumption < 0 OR ep.Fuel_Consumption > 500 GROUP BY e.Fuel_Type;",
    "step": "【step1】: Join the 'engine' and 'engineperformance' tables using Engine_ID to link engine metadata with performance metrics.  【step2】: Filter records where Fuel_Consumption is < 0 or > 500 liters/100km to isolate anomalies.  【step3】: Group results by Fuel_Type, then calculate the count of anomalies and average Power_To_Weight_Ratio per group.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 277,
    "question": "Calculate the thermal efficiency of engines with different fuel types and analyze its relationship with displacement and horsepower, grouped by fuel type.",
    "query": "SELECT e.Fuel_Type, AVG((e.Horsepower * 0.7457 * 1000) / (ep.Fuel_Consumption * CASE WHEN e.Fuel_Type = 'Gasoline' THEN 34.2 WHEN e.Fuel_Type = 'Diesel' THEN 38.6 ELSE 0 END * 100) * 100) AS Thermal_Efficiency, AVG(e.Displacement) AS Avg_Displacement, AVG(e.Horsepower) AS Avg_Horsepower FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Gasoline', 'Diesel') GROUP BY e.Fuel_Type;",
    "step": "【step1】: Join engine table with engineperformance table using Engine_ID, filter records where Fuel_Type is Gasoline or Diesel.  【step2】: Calculate thermal efficiency using formula: (Horsepower converted to watts) / (Fuel_Consumption * fuel-specific energy density) * 100. Use CASE statement to apply energy density values (34.2 MJ/L for Gasoline, 38.6 MJ/L for Diesel).  【step3】: Group results by Fuel_Type and compute average values for Thermal_Efficiency, Displacement, and Horsepower using AVG() aggregation.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 278,
    "question": "Calculate the average percentage error between the actual displacement and the theoretical displacement (calculated from Bore, Stroke, and Cylinders), grouped by the number of cylinders.",
    "query": "SELECT Cylinders, AVG(ABS(Displacement - (PI()/4 * POWER(Bore/10,2) * Stroke/10 * Cylinders / 1000)) / Displacement * 100) AS Error_Percentage FROM engine GROUP BY Cylinders;",
    "step": "【step1】: Calculate theoretical displacement for each engine using (π/4) * (Bore/10)^2 * (Stroke/10) * Cylinders / 1000 formula, converting mm to cm.  【step2】: Compute absolute percentage error between actual Displacement and theoretical displacement via (ABS(Displacement - [step1 result])/Displacement)*100.  【step3】: Group results by Cylinders and calculate average error percentage with AVG() function.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 279,
    "question": "Calculate the average length and width of engines for each cylinder configuration (Configuration).",
    "query": "SELECT e.Configuration, AVG(d.Length) AS Avg_Length, AVG(d.Width) AS Avg_Width FROM engine e JOIN enginedimensions d ON e.Engine_ID = d.Engine_ID GROUP BY e.Configuration;",
    "step": "【step1】: JOIN engine and enginedimensions tables using Engine_ID to combine configuration data with dimensional measurements.  【step2】: GROUP the joined dataset by Configuration to organize engine records by their cylinder arrangement types.  【step3】: CALCULATE average length (AVG(d.Length)) and average width (AVG(d.Width)) for each group to analyze dimensional variations across configurations.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 280,
    "question": "Assuming the engine's redline speed (Redline) is 1,000,000 RPM, and the stroke is 1000 mm, calculate the Mach number (based on mean piston speed), grouped by cylinder arrangement.",
    "query": "SELECT Configuration, (2 * 1000 * 1000000 / 60 / 1000) / 343 AS Mach_Number FROM engine GROUP BY Configuration;",
    "step": "【step1】: Retrieve all rows from the 'engine' table and project the 'Configuration' column.  【step2】: Calculate the constant Mach_Number for every row using the formula (2 * 1000 * 1,000,000 / 60 / 1000) / 343 (fixed parameters, no dynamic field references).  【step3】: Group results by the 'Configuration' column and output one row per unique configuration with the calculated Mach_Number (identical for all groups due to hardcoded values).",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 281,
    "question": "Please find all engines that use cast iron (Cast Iron) as the block material but have a thermal efficiency (Thermal_Efficiency) higher than 35%, and return their engine ID, model, block material, and thermal efficiency.",
    "query": "SELECT e.Engine_ID, e.Model, m.Block_Material, p.Thermal_Efficiency FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND p.Thermal_Efficiency > 35;",
    "step": "【step1】: Join 'engine' table with 'enginematerials' on Engine_ID to filter engines where Block_Material is 'Cast Iron'.  【step2】: Join the result with 'engineperformance' on Engine_ID to apply Thermal_Efficiency > 35% condition.  【step3】: Select Engine_ID, Model, Block_Material, and Thermal_Efficiency from the combined dataset.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 282,
    "question": "Please verify whether there is a positive correlation between the BMEP of a turbocharged engine and its peak torque, and return the engines where BMEP is less than a calculated value based on peak torque and displacement.",
    "query": "SELECT e.Engine_ID, e.Model, d.Peak_Torque, p.BMEP FROM engine e JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND p.BMEP < (d.Peak_Torque / e.Displacement) * 0.12;",
    "step": "【step1】: Filter turbocharged engines from the 'engine' table using WHERE e.Aspiration = 'Turbocharged'.  【step2】: Join filtered engines with 'enginedynamics' (d) and 'engineperformance' (p) tables via Engine_ID to combine BMEP/Peak_Torque/Displacement data.  【step3】: Calculate (d.Peak_Torque / e.Displacement) * 0.12 as the BMEP threshold and select engines where p.BMEP < this threshold to identify non-compliant entries.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 283,
    "question": "Please find engines with a length greater than 1000 millimeters and a piston speed exceeding 25 meters per second, and return their engine ID, model, length, and piston speed.",
    "query": "SELECT e.Engine_ID, e.Model, ed.Length, d.Piston_Speed FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID WHERE ed.Length > 1000 AND d.Piston_Speed > 25;",
    "step": "【step1】: Perform INNER JOIN between engine and enginedimensions on Engine_ID, filter records where Length > 1000mm  【step2】: INNER JOIN result with enginedynamics on Engine_ID, apply Piston_Speed > 25m/s filter  【step3】: Project final columns (Engine_ID, Model, Length, Piston_Speed) from the combined dataset",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 284,
    "question": "Please verify if the displacement of all electric (Electric) engines is 0, and return the engine IDs and models of those with non-zero displacement.",
    "query": "SELECT Engine_ID, Model, Displacement FROM engine WHERE Fuel_Type = 'Electric' AND Displacement != 0;",
    "step": "【step1】: Filter all engines where Fuel_Type is 'Electric' from the engine table.  【step2】: Apply the condition Displacement != 0 to the filtered electric engines.  【step3】: Select and return the Engine_ID, Model, and Displacement columns for the mismatched records.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 285,
    "question": "Based on the Main_Bore_Diameter and Rod_Journal_Diameter in the enginedimensions table, calculate the stress on the main bearing for engines with a cast iron block and identify those where the stress exceeds 200.",
    "query": "SELECT ed.Engine_ID, PI() * (Main_Bore_Diameter/2) * (Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2) * (Rod_Journal_Diameter/2) AS Bearing_Area, (1.5 * edyn.Angular_Velocity * edyn.Angular_Velocity * (ed.Weight/1000) * (Rod_Journal_Diameter/2000)) / (PI() * (Main_Bore_Diameter/2)*(Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2)*(Rod_Journal_Diameter/2)) AS Stress FROM enginedimensions ed JOIN enginedynamics edyn USING(Engine_ID) JOIN enginematerials em USING(Engine_ID) WHERE em.Block_Material = 'Cast Iron' HAVING Stress > 200;",
    "step": "【step1】: Join enginedimensions, enginedynamics, enginematerials tables via Engine_ID and filter engines with Block_Material = 'Cast Iron'  【step2】: Calculate Bearing_Area (π(Main_Bore_Diameter²/4 - Rod_Journal_Diameter²/4)) and compute Stress using (1.5 × Angular_Velocity² × Weight × Rod_Journal_Diameter) / (Bearing_Area × 1e6)  【step3】: Filter results with HAVING clause to retain records where Stress exceeds 200 MPa requirement",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 286,
    "question": "Given the Bore=84mm, Stroke=90mm, and Cylinder_Spacing=120mm in the enginedimensions table, calculate the total length of an inline 6-cylinder engine and compare it to Length=800mm, taking into account an allowance of 20mm on each end of the engine block.",
    "query": "SELECT ed.Engine_ID, (Cylinder_Spacing*(6-1) + 2*20 + 6*Bore) AS Calculated_Length, Length, ABS((Cylinder_Spacing*5 + 40 + 504) - Length) AS Length_Deviation FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE e.Cylinders = 6 AND e.Configuration = 'Inline';",
    "step": "【step1】: Perform INNER JOIN between 'engine' and 'enginedimensions' tables using Engine_ID to combine cylinder configuration parameters with dimensional data.  【step2】: Apply WHERE filter to select only inline 6-cylinder engines (Cylinders=6 AND Configuration='Inline').  【step3】: Calculate theoretical engine length using formula: (Cylinder_Spacing×5) + 2×20 + 6×Bore, then compare with stored Length and compute absolute deviation.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 287,
    "question": "For an engine with Cylinder_Spacing=50mm and Width=600mm, can it be determined whether there are safety hazards in its cylinder arrangement? It is known that industry standards require the spacing between adjacent cylinders to be at least 1.2 times the cylinder bore diameter, and the safety status is determined by comparing the actual cylinder spacing to the minimum safe spacing.",
    "query": "SELECT ed.Engine_ID, Cylinder_Spacing, Bore, ROUND(1.2*Bore,1) AS Min_Safe_Spacing, CASE WHEN Cylinder_Spacing < 1.2*Bore THEN 'Danger' ELSE 'Safety' END AS Safety_Status FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE Cylinder_Spacing = 50 AND Width = 600;",
    "step": "【step1】: Perform INNER JOIN between engine and enginedimensions tables using Engine_ID to combine dimensional parameters with core engine specifications  【step2】: Calculate required safety parameters by processing Bore data (1.2×Bore) and comparing with actual Cylinder_Spacing using conditional logic in SELECT clause  【step3】: Apply filtration for specific dimensional criteria (Cylinder_Spacing=50 AND Width=600) and finalize safety status determination through CASE expression",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 288,
    "question": "Suppose there is an engine with a weight Weight=99999kg and a Power_To_Weight_Ratio=0.0001 horsepower/kg. Does this engine appear in the result of the given query?",
    "query": "SELECT Engine_ID FROM enginedimensions WHERE Weight > 10000 AND Engine_ID NOT IN (SELECT Engine_ID FROM engineperformance WHERE Power_To_Weight_Ratio < 0.001);",
    "step": "【step1】: Retrieve all Engine_IDs from enginedimensions where Weight exceeds 10000kg.  【step2】: Subquery to select Engine_IDs from engineperformance with Power_To_Weight_Ratio below 0.001.  【step3】: Use NOT IN operator to exclude Engine_IDs found in step2 from step1, identifying anomalies in enginedimensions not reflected in engineperformance.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 289,
    "question": "Find the engine models that use titanium valves and have cylinder heads made of cast iron, then calculate the theoretical heat transfer rate (in watts) between the cylinder head and the valve based on the material's thermal conductivity, and list the top 3 in descending order of heat transfer rate.",
    "query": "SELECT e.Model, (80 * 21.9 * 0.01 * 600) / (80 * 0.005 + 21.9 * 0.010) AS Q FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginethermodynamics t USING(Engine_ID) WHERE m.Valve_Material = 'Titanium' AND m.Head_Material = 'Cast Iron' ORDER BY Q DESC LIMIT 3;",
    "step": "【step1】: Join engine, enginematerials, and enginethermodynamics tables using Engine_ID, filter records where Valve_Material is 'Titanium' and Head_Material is 'Cast Iron'.  【step2】: Apply thermal conduction formula Q=(k1*k2*A*ΔT)/(k1*L2 + k2*L1) using fixed material parameters (80 W/m·K for cast iron, 21.9 W/m·K for titanium) with assumed dimensions (A=0.01m², L1=0.005m, L2=0.010m, ΔT=600K).  【step3】: Sort results by calculated Q in descending order and retain top 3 entries using ORDER BY Q DESC LIMIT 3.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 290,
    "question": "Calculate the piston inertial force (in Newtons) for all engines using aluminum pistons with connecting rods made of steel, then list the top 5 results sorted by inertial force in ascending order.",
    "query": "SELECT e.Engine_ID, 2700 * PI() * POWER(e.Bore/2000,2) * e.Stroke/1000 * POWER(d.Angular_Velocity,2) * (e.Stroke/2000) * (1 + 1/(2*1.5)) AS F FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginedynamics d USING(Engine_ID) WHERE m.Piston_Material = 'Aluminum' AND m.Connecting_Rod_Material = 'Steel' ORDER BY F ASC LIMIT 5;",
    "step": "【step1】: Join engine, enginematerials, and enginedynamics tables using Engine_ID  【step2】: Filter engines with Aluminum pistons and Steel connecting rods  【step3】: Calculate inertia force using formula, sort ascending, limit to top 5",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 291,
    "question": "List the top 3 gasoline engine models that use cast iron cylinder blocks and have a compression ratio greater than 10:1, sorted in descending order by specific power (horsepower per liter).",
    "query": "SELECT e.Model, p.Specific_Power FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN engineperformance p USING(Engine_ID) WHERE m.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Gasoline' AND e.Compression_Ratio > 10 ORDER BY p.Specific_Power DESC LIMIT 3;",
    "step": "【step1】: Join engine, enginematerials, and engineperformance tables using Engine_ID to combine material and performance data  【step2】: Filter for Cast Iron blocks, Gasoline fuel type, and Compression_Ratio > 10  【step3】: Sort results by Specific_Power (power-to-displacement ratio) in descending order and limit to top 3 entries",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 292,
    "question": "Assuming there exists a W-type 24-cylinder engine with a bore diameter of 5000 mm and a stroke of 3000 mm, and the crankshaft material is ceramic (assuming an elastic modulus of 300 GPa), find the natural frequency (Hz) of the crankshaft's torsional vibration, ordered by ascending frequency.",
    "query": "SELECT e.Engine_ID, (1/(2*PI())) * SQRT( (300e9/(2*(1+0.3)) * PI()*POWER(ed.Rod_Journal_Diameter/1000,4)/32) / (ed.Length/1000 * (e.Weight * POWER(ed.Rod_Journal_Diameter/2000,2)/4)) ) AS f FROM engine e JOIN enginedimensions ed USING(Engine_ID) WHERE e.Configuration = 'W' AND e.Cylinders = 24 AND e.Bore = 5000 AND e.Stroke = 3000 ORDER BY f ASC;",
    "step": "【step1】:Join engine and enginedimensions tables using Engine_ID to access geometric parameters (Rod_Journal_Diameter, Length) and engine specifications (Weight).  【step2】:Filter records with Configuration='W', Cylinders=24, Bore=5000, Stroke=3000 to isolate the target engine configuration.  【step3】:Calculate torsional natural frequency via formula:  - Shear modulus: 300e9/(2*(1+0.3))  - Polar moment (J): π*(Rod_Journal_Diameter/1000)^4/32  - Torsional stiffness (GJ/L): (Shear modulus * J)/(Length/1000)  - Mass moment (I): Weight * (Rod_Journal_Diameter/2000)^2 /4  - Frequency: (1/(2π)) * SQRT(Torsional_stiffness / Mass_moment)",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 293,
    "question": "Based on the engine and enginethermodynamics tables, calculate the ratio of combustion efficiency to heat rejection rate for each engine, and list the top 5 models with the highest ratio among engines with a displacement greater than 2.0 liters.",
    "query": "SELECT e.Model, (et.Combustion_Efficiency / et.Heat_Rejection_Rate) AS Ratio FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Displacement > 2.0 ORDER BY Ratio DESC LIMIT 5;",
    "step": "【step1】: Join 'engine' and 'enginethermodynamics' tables using Engine_ID to link combustion/thermal data with engine specifications.  【step2】: Apply WHERE filter to select engines with Displacement > 2.0 liters.  【step3】: Calculate efficiency-to-rejection ratio (Combustion_Efficiency/Heat_Rejection_Rate), sort results in descending order by Ratio, and return the top 5 Model entries.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 294,
    "question": "Combining the enginethermodynamics, enginematerials, enginedimensions, and engine tables, calculate the total heat transfer Q_total using the formula (thermal conductivity multiplied by the temperature difference between exhaust gas and coolant, divided by cylinder spacing, plus specific heat capacity multiplied by oil temperature), then list the top 3 engine models ranked in descending order of Q_total.",
    "query": "SELECT e.Model, (et.Thermal_Conductivity * (et.Exhaust_Gas_Temperature - et.Coolant_Temperature) / ed.Cylinder_Spacing + et.Specific_Heat_Capacity * et.Oil_Temperature) AS Q_total FROM enginethermodynamics et INNER JOIN enginematerials em ON et.Engine_ID = em.Engine_ID INNER JOIN enginedimensions ed ON et.Engine_ID = ed.Engine_ID INNER JOIN engine e ON et.Engine_ID = e.Engine_ID ORDER BY Q_total DESC LIMIT 3;",
    "step": "【step1】: Perform four-way JOIN between enginethermodynamics, enginematerials, enginedimensions, and engine tables using Engine_ID as the key relationship.【step2】: Calculate Q_total using formula (Thermal_Conductivity × (Exhaust_Gas_Temperature - Coolant_Temperature) / Cylinder_Spacing) + (Specific_Heat_Capacity × Oil_Temperature) for each engine model.【step3】: Sort results by Q_total in DESC order and select top 3 models using LIMIT clause.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 295,
    "question": "List the engine models where the coolant temperature (Coolant_Temperature) exceeds 100°C and the fuel type is gasoline (Gasoline), sorted in ascending order by displacement.",
    "query": "SELECT e.Model FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 100 AND e.Fuel_Type = 'Gasoline' ORDER BY e.Displacement ASC;",
    "step": "【step1】: JOIN engine and enginethermodynamics tables using Engine_ID as the relation  【step2】: Apply WHERE conditions Coolant_Temperature > 100 AND Fuel_Type = 'Gasoline'  【step3】: Sort results by Displacement in ascending ORDER",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 296,
    "question": "Assuming the exhaust gas temperature (Exhaust_Gas_Temperature) of an engine reaches 5000°C (far exceeding the melting point of conventional materials), calculate the minimum thermal conductivity (Thermal_Conductivity) value for each engine model based on cylinder spacing and surface area, and list the top 5 results sorted in ascending order by this minimum thermal conductivity value.",
    "query": "SELECT e.Model, (1000 * (ed.Cylinder_Spacing / 1000) ) / ( (2 * ((ed.Length / 1000) * (ed.Width / 1000) + (ed.Length / 1000) * (ed.Height / 1000) + (ed.Width / 1000) * (ed.Height / 1000))) * (5000 - 25) ) AS λ_min FROM enginedimensions ed INNER JOIN engine e ON ed.Engine_ID = e.Engine_ID ORDER BY λ_min ASC LIMIT 5;",
    "step": "【step1】: Perform INNER JOIN between 'engine' and 'enginedimensions' tables using Engine_ID to combine engine metadata with dimensional data.  【step2】: Calculate λ_min (minimum thermal conductivity) using formula:  λ_min = (1000 * Cylinder_Spacing/1000) / [2*(L*W + L*H + W*H) * (5000-25)]  Where L/W/H are converted from mm to meters (divided by 1000).  【step3】: Sort results by λ_min in ascending order and limit output to top 5 records where thermal conductivity requirements are lowest.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 297,
    "question": "Calculate the average combustion efficiency and total heat rejection rate for engines from different manufacturers, grouped by manufacturer.",
    "query": "SELECT e.Manufacturer, AVG(et.Combustion_Efficiency) AS Avg_Combustion_Efficiency, SUM(et.Heat_Rejection_Rate) AS Total_Heat_Rejection_Rate FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID GROUP BY e.Manufacturer;",
    "step": "【step1】: Join the 'engine' and 'enginethermodynamics' tables using Engine_ID to link combustion efficiency and heat rejection data to each manufacturer.  【step2】: Apply aggregate functions: calculate average combustion efficiency (AVG(et.Combustion_Efficiency)) and total heat rejection rate (SUM(et.Heat_Rejection_Rate)).  【step3】: Group results by Manufacturer to organize output per manufacturer and finalize grouped calculations.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 298,
    "question": "Calculate the weighted harmonic mean of the specific heat capacity and thermal conductivity for all electric engines, grouped by engine configuration.",
    "query": "SELECT e.Configuration, SUM(e.Weight)/(SUM(e.Weight/(0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity))) AS Weighted_Harmonic_Mean FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Fuel_Type = 'Electric' AND (0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity) > 0 GROUP BY e.Configuration;",
    "step": "【step1】: Filter and join data. Select electric engines with valid thermodynamic values (0.6*Specific_Heat_Capacity + 0.4*Thermal_Conductivity > 0) by joining engine and enginethermodynamics tables using Engine_ID.  【step2】: Calculate weight components. For each engine, compute (Weight / (0.6*Specific_Heat_Capacity + 0.4*Thermal_Conductivity)) and sum these values per configuration group.  【step3】: Compute harmonic mean. Divide the total weight sum by the summed weight ratios from step2, grouped by Configuration to produce the final weighted harmonic mean.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 299,
    "question": "Analyze engine models with coolant temperatures exceeding 120°C, and count the distinct quantities of models grouped by fuel type.",
    "query": "SELECT e.Fuel_Type, COUNT(DISTINCT e.Model) AS High_Temp_Models FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 120 GROUP BY e.Fuel_Type;",
    "step": "【step1】: Perform an INNER JOIN between the 'engine' and 'enginethermodynamics' tables using Engine_ID to access coolant temperature data.  【step2】: Filter rows where Coolant_Temperature > 120°C to isolate engines with elevated thermal conditions.  【step3】: Group results by Fuel_Type and calculate the count of DISTINCT Model values within each group to determine category-specific model frequencies.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 300,
    "question": "Assuming the exhaust temperature of a certain engine reaches 5273 K, calculate its thermal radiation power and infer material feasibility, grouped by the number of cylinders.",
    "query": "SELECT e.Cylinders, SUM(5.67E-8 * 0.9 * 2*(ed.Length*ed.Width + ed.Length*ed.Height + ed.Width*ed.Height) * (POWER(5273,4)-POWER(300,4))) AS Thermal_Radiation_Power FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Cylinders;",
    "step": "【step1】: Perform INNER JOIN between engine and enginedimensions tables using Engine_ID to associate physical dimensions with engine specifications.  【step2】: Apply Stefan-Boltzmann law formula (5.67E-8 * emissivity * surface area * ΔT⁴) to compute thermal radiation power for each engine, using derived surface area from dimensions and temperature difference (5273K⁴ - 300K⁴).  【step3】: Group aggregated results by Cylinders column and sum thermal radiation values within each group to analyze power distribution per cylinder configuration.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 301,
    "question": "Calculate whether the thermal emission rate of engine 12345 meets the first law of thermodynamics (energy conservation). Given that the total energy released by fuel combustion is 5000 kilowatts, the combustion efficiency is 35%, and the total heat carried away by the coolant and engine oil is 2500 kilowatts, what is the heat loss corresponding to the exhaust gas temperature?",
    "query": "SELECT Engine_ID, 5000 AS Total_Energy, Combustion_Efficiency, 2500 AS Cooling_Loss, (5000 - (5000 * Combustion_Efficiency / 100) - 2500) AS Calculated_Exhaust_Loss, Heat_Rejection_Rate AS Actual_Exhaust_Loss, CASE WHEN Heat_Rejection_Rate = (5000 - (5000 * Combustion_Efficiency / 100) - 2500) THEN '满足能量守恒' ELSE '不满足能量守恒' END AS Energy_Conservation_Status FROM enginethermodynamics WHERE Engine_ID = 12345;",
    "step": "【step1】: Filter engine thermodynamics data for Engine_ID 12345 using WHERE clause to isolate the target engine's record  【step2】: Calculate theoretical exhaust heat loss using formula (5000 - (5000 * 35% efficiency) - 2500 cooling loss), compare with actual Heat_Rejection_Rate from table  【step3】: Execute CASE statement to verify energy conservation by matching calculated vs actual exhaust loss, generating status indicator",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 302,
    "question": "If an engine with ID 12345 has oil temperature rising from 80°C to 120°C during operation, calculate the total stored heat (in joules). If this heat needs to be removed by the cooling system within 10 seconds, what cooling power in kilowatts must be achieved?",
    "query": "SELECT e.Engine_ID, e.Displacement, et.Specific_Heat_Capacity, (e.Displacement * 0.85) AS Mass_kg, (120 - 80) AS Temp_Diff_K, ROUND((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80), 2) AS Total_Heat_J, ROUND(((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80)) / 10 / 1000, 2) AS Required_Power_kW FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Engine_ID = 12345;",
    "step": "【step1】: Perform JOIN operation between engine and enginethermodynamics tables using Engine_ID to combine displacement and thermophysical properties  【step2】: Calculate intermediate values:  - Mass_kg = Displacement × 0.85 (conversion from liters to kg using oil density)  - Temp_Diff_K = 120 - 80 (temperature difference in Kelvin)  【step3】: Compute final results:  - Total_Heat_J = Mass × Specific_Heat_Capacity × Temp_Diff (Q=mcΔT formula)  - Required_Power_kW = (Total_Heat_J / 10) / 1000 (convert J/s to kW for 10-second duration)",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 303,
    "question": "Analyze whether the engine with an exhaust temperature of 950°C has a risk of catalytic converter failure.",
    "query": "SELECT Engine_ID, Exhaust_Gas_Temperature, CASE WHEN Exhaust_Gas_Temperature > 800 THEN '存在催化器失效风险' ELSE '工作状态正常' END AS Catalyst_Status FROM enginethermodynamics WHERE Exhaust_Gas_Temperature > 800;",
    "step": "【step1】: Filter engines with exhaust temperatures exceeding 800°C from the enginethermodynamics table  【step2】: Apply CASE statement to evaluate catalyst failure risk  【step3】: Return Engine_ID, temperature value, and risk classification based on threshold comparison",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 304,
    "question": "Assuming the combustion efficiency of an engine is 200% (far exceeding physical limits), and its heat rejection rate is -1000 kW (negative value indicates heat absorption). Please verify whether this engine is physically consistent under these conditions. If there is a contradiction, what is the contradiction point?",
    "query": "SELECT Engine_ID, Combustion_Efficiency, Heat_Rejection_Rate, CASE WHEN Combustion_Efficiency > 100 THEN 'Contradiction: Combustion efficiency exceeds physical limits' WHEN Heat_Rejection_Rate < 0 THEN 'Contradiction: Heat dissipation rate violates the second law of thermodynamics.' ELSE 'No contradiction' END AS Physical_Consistency FROM enginethermodynamics WHERE Combustion_Efficiency > 100 OR Heat_Rejection_Rate < 0;",
    "step": "【step1】: Retrieve engine thermodynamics data including Engine_ID, Combustion_Efficiency, and Heat_Rejection_Rate from the enginethermodynamics table.  【step2】: Filter records where Combustion_Efficiency exceeds 100% or Heat_Rejection_Rate is negative using the WHERE clause.  【step3】: Apply CASE logic to flag contradictions: \"矛盾：燃烧效率超过物理极限\" for efficiency violations and \"矛盾：熱排放率違反熱力学第二定律\" for negative heat rejection.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 305,
    "question": "The cylinder bore of an engine is 84 mm, the stroke is 90 mm, the compression ratio is 11.5:1, and the fuel is gasoline. Assuming standard atmospheric pressure, calculate the theoretical maximum combustion pressure (in Bar) in a single cylinder during one working cycle. The specific heat ratio of air is 1.4, and the standard atmospheric pressure is 1 Bar.",
    "query": "SELECT Engine_ID, Model, 1 * POW(CAST(SUBSTRING_INDEX(Compression_Ratio, ':', 1) AS DECIMAL), 1.4) AS Theoretical_Max_Pressure_Bar FROM engine WHERE Bore = 84 AND Stroke = 90 AND Compression_Ratio = '11.5:1' AND Fuel_Type = 'Gasoline';",
    "step": "【step1】: Filter records from the 'engine' table where Bore=84, Stroke=90, Compression_Ratio='11.5:1', and Fuel_Type='Gasoline' using WHERE clause.  【step2】: Extract the first part (11.5) from the string '11.5:1' in Compression_Ratio using SUBSTRING_INDEX, then cast it to DECIMAL for calculation.  【step3】: Calculate theoretical max pressure using the formula 1 Bar × (compression_ratio)^1.4 via POW() function and alias the result as Theoretical_Max_Pressure_Bar.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 306,
    "question": "An eight-cylinder V-engine (V8) has a crankshaft angular velocity of 400 radians/second, a piston stroke of 86 millimeters, and a connecting rod length of 150 millimeters. Calculate the instantaneous velocity of the piston (in meters/second) when the crankshaft angle is 70 degrees, accurate to four decimal places.",
    "query": "SELECT e.Engine_ID, e.Model, ed.Angular_Velocity, (ed.Angular_Velocity * (e.Stroke/2000)) * (SIN(RADIANS(70)) + ((e.Stroke/2000)/(2*0.15))*SIN(RADIANS(140))) AS Instantaneous_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Cylinders = 8 AND e.Configuration = 'V' AND e.Stroke = 86;",
    "step": "【step1】: Perform an INNER JOIN between 'engine' (e) and 'enginedynamics' (ed) tables using Engine_ID, filtering for V8 engines with 86mm stroke (WHERE e.Cylinders=8 AND e.Configuration='V' AND e.Stroke=86).  【step2】: Extract Angular_Velocity and compute the base term *ω*(Stroke/2000)*, where Stroke/2000 converts 86mm stroke to 0.043m radius (half of stroke).  【step3】: Apply the velocity formula: Multiply the base term by **[sin(70°) + (radius/0.15m)*sin(140°)]**, with 0.15m hardcoded as the rod length (150mm). RADIANS() converts degrees to radians, and SIN() calculates trigonometric values. Precision is enforced via floating-point arithmetic.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 307,
    "question": "A turbocharged diesel engine (Compression_Ratio=18:1, Fuel_Type=Diesel, Aspiration=Turbocharged) experiences severe power loss at a plateau altitude of 4500 meters. Please explain the phenomenon using Bernoulli's principle and the gas state equation, and propose improvement measures.",
    "query": "SELECT Engine_ID, Model, Compression_Ratio, Aspiration FROM engine WHERE Fuel_Type = 'Diesel' AND Aspiration = 'Turbocharged' AND Compression_Ratio = '18:1';",
    "step": "",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 308,
    "question": "Assuming a 24-cylinder W-type engine with a redline speed of 30,000 RPM, a bore of 200 mm, and a stroke of 500 mm, calculate the inertial force (in Newtons) experienced by the connecting rod, given a piston assembly mass of 2.5 kg.",
    "query": "SELECT e.Engine_ID, e.Model, 2.5 * POW(2*PI()*e.Redline/60, 2) * (e.Stroke/2000) * (1 + (e.Stroke/2000)/0.15) AS Inertial_Force FROM engine e WHERE e.Cylinders = 24 AND e.Configuration = 'W' AND e.Bore = 200 AND e.Stroke = 500;",
    "step": "【step1】: Filter engines with 24 W-type cylinders, 200mm bore, and 500mm stroke using WHERE conditions on `Cylinders`, `Configuration`, `Bore`, and `Stroke` columns.  【step2】: Calculate inertial force with `2.5 * POW(2*PI()*e.Redline/60, 2) * (e.Stroke/2000) * (1 + (e.Stroke/2000)/0.15)`, converting RPM to rad/s and stroke to meters.  【step3】: Extract `Engine_ID`, `Model`, and the calculated `Inertial_Force` for the qualified engine.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 309,
    "question": "A V-type engine has a main bearing bore diameter of 80 mm. Assuming the engine crankshaft is a uniform steel cylinder with a weight of 50 kg, calculate the moment of inertia of the crankshaft at its maximum rotational speed of 8000 RPM (ignoring the effect of the journals).",
    "query": "SELECT 0.5 * 50 * POWER((Main_Bore_Diameter/2/1000),2) AS 转动惯量, (2 * PI() * Max_turn)/60 AS 角速度 FROM enginedimensions JOIN enginedynamics USING(Engine_ID) WHERE Main_Bore_Diameter=80 AND Engine_ID IN (SELECT Engine_ID FROM engine WHERE Configuration='V')",
    "step": "【step1】: Execute subquery to retrieve Engine_IDs for V-configuration engines: SELECT Engine_ID FROM engine WHERE Configuration='V'  【step2】: Join enginedimensions and enginedynamics tables using Engine_ID, filtering by Main_Bore_Diameter=80 and matching Engine_IDs from step1's result  【step3】: Calculate rotational inertia using formula 0.5*mass*(radius²) and angular velocity using (2π*Max_turn)/60, with unit conversions (mm→m, RPM→rad/s)",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 310,
    "question": "A straight-six engine has a length of 600 mm, a width of 500 mm, and a height of 400 mm. It has 6 cylinders with a bore of 84 mm and a stroke of 90 mm. Calculate the percentage of volume in the engine's total volume that is not occupied by the cylinders (retain 3 decimal places).",
    "query": "SELECT ROUND((Length*Width*Height - Cylinders*PI()*POWER(Bore/2,2)*Stroke)/(Length*Width*Height)*100,3) AS 剩余空间占比 FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='Inline' AND Cylinders=6 AND Length=600 AND Width=500 AND Height=400",
    "step": "【step1】: Join the 'engine' and 'enginedimensions' tables using Engine_ID to combine dimensional data with cylinder parameters.  【step2】: Filter records where Configuration='Inline', Cylinders=6, and dimensions exactly match 600x500x400mm.  【step3】: Calculate unoccupied space by subtracting total cylinder volume (6×π×(84/2)²×90) from engine exterior volume (600×500×400), then compute percentage using (unoccupied/exterior)×100 with 3 decimal rounding.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 311,
    "question": "An engine has a width of 800 millimeters, and the maximum allowable installation width in the vehicle's front compartment is 900 millimeters. According to the automotive production line assembly specifications, at least 10% width margin must be reserved on each side between the engine and the compartment. Does this engine meet the installation requirements?",
    "query": "SELECT Width, CASE WHEN Width <= 900*(1-0.1) THEN 'conforms to' ELSE 'does not meet the requirements' END AS Installation Status FROM enginedimensions WHERE Width=800",
    "step": "【step1】: Filter the engine dimensions table to find records where Width is exactly 800mm using WHERE Width=800  【step2】: Calculate the maximum allowable width after reserving 10% total margin (5% on both sides): 900*(1-0.10)=810mm  【step3】: Use CASE statement to compare actual width (800mm) against calculated maximum (810mm), returning 'conforms to' when compliant or 'does not meet the requirements' otherwise",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 312,
    "question": "Assuming a W-type 24-cylinder engine has a cylinder spacing of 5,000 millimeters. If the diameter of the connecting rod journal must be maintained at 1/100 of the cylinder spacing, determine:  \n1) The theoretical length of the engine  \n2) The diameter of the connecting rod journal  \n3) Given that the crankshaft material has a yield strength of 800 MPa, calculate whether the shear stress on the journal under a torque of 20,000 N·m exceeds the limit.",
    "query": "SELECT (24/4)*Cylinder_Spacing AS 理论长度, Cylinder_Spacing/100 AS 轴颈直径, CASE WHEN (16*20000)/(PI()*POWER(Cylinder_Spacing/100/1000,3)) > 800e6 THEN 'exceed' ELSE 'not exceeding' END AS Stress state FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='W' AND Cylinders=24 AND Cylinder_Spacing=5000",
    "step": "【step1】: Perform INNER JOIN between 'enginedimensions' and 'engine' tables using Engine_ID, filtering records with WHERE clause (Configuration='W', Cylinders=24, Cylinder_Spacing=5000)  【step2】: Calculate engine length via (24/4)*Cylinder_Spacing and journal diameter via Cylinder_Spacing/100  【step3】: Compute shear stress using τ=(16*T)/(πd³) formula with unit conversion (mm to meters), then apply CASE statement to compare with 800MPa yield strength",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 313,
    "question": "The maximum rotation speed (Max_turn) of an engine is 8500 RPM, and the recorded Angular_Velocity is 890 rad/s. Please verify whether the angular velocity data satisfies the calculated value from the physical formula?",
    "query": "SELECT Engine_ID, Max_turn, Angular_Velocity, (PI() * Max_turn / 30) AS Formula_Value, ROUND(Angular_Velocity,2) = ROUND((PI() * Max_turn / 30),2) AS Data_Consistency FROM enginedynamics WHERE Max_turn = 8500 AND Angular_Velocity = 890;",
    "step": "【step1】: Filter records from enginedynamics table where Max_turn=8500 RPM and Angular_Velocity=890 rad/s  【step2】: Calculate theoretical value using formula π×Max_turn/30, round both Angular_Velocity and formula result to 2 decimal places  【step3】: Compare rounded values to generate Data_Consistency flag (1=valid, 0=invalid)",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 314,
    "question": "The Mean_Piston_Speed of a certain V-type engine is labeled as 25.4 m/s, with a Max_turn of 6800 RPM. Given that Stroke = 86 mm, please verify whether the labeled Mean_Piston_Speed matches the calculated value from the formula for engines with Configuration = 'V型'.",
    "query": "SELECT e.Engine_ID, ed.Mean_Piston_Speed, (2 * (e.Stroke/1000) * ed.Max_turn)/60 AS Calculated_Speed, ROUND(ed.Mean_Piston_Speed,1) = ROUND((2 * (e.Stroke/1000) * ed.Max_turn)/60,1) AS Validation FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'V型' AND ed.Max_turn = 6800 AND e.Stroke = 86;",
    "step": "【step1】: Join 'engine' and 'enginedynamics' tables using Engine_ID, filter for V-type engines with Stroke=86mm and Max_turn=6800 RPM.  【step2】: Calculate theoretical piston speed using formula (2*(Stroke/1000)*Max_turn/60), convert Stroke from mm to meters.  【step3】: Compare rounded values (1 decimal) between database's Mean_Piston_Speed and calculated value, output boolean Validation result.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 315,
    "question": "The peak torque of a certain turbocharged engine is marked within the 1500-4000 RPM range, with the lower bound being 1500 RPM and the upper bound being 4000 RPM, while the peak power is marked at 5500 RPM. Does this comply with conventional power characteristics?",
    "query": "SELECT Engine_ID, Peak_Torque, Peak_Power, CAST(SUBSTRING_INDEX(Peak_Torque,'-',-1) AS UNSIGNED) < CAST(Peak_Power AS UNSIGNED) AS Logic_Validation FROM enginedynamics WHERE Engine_ID IN (SELECT Engine_ID FROM engine WHERE Aspiration = 'Turbocharged');",
    "step": "",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 316,
    "question": "What is the angular velocity in rad/s of a rotor engine crankshaft rotating at 1,500,000 RPM, and will it fracture under centrifugal stress given a yield strength of 3000 MPa, material density of 7850 kg/m³, and radius of 50 mm?",
    "query": "SELECT PI() * 1500000 / 30 AS Angular_Velocity, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 AS Centrifugal_Stress, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 > 3e9 AS Will_Break FROM engine WHERE Configuration = 'rotor' LIMIT 1;",
    "step": "【step1】: Join 'engine' with 'enginedynamics' to obtain Max_turn from enginedynamics where Configuration='rotor'  【step2】: Calculate Angular_Velocity (PI()*Max_turn/30) and Centrifugal_Stress formula: (density * Angular_Velocity² * radius²)/3  【step3】: Compare calculated Centrifugal_Stress with 3e9 Pa yield strength using conditional check in SELECT clause",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 317,
    "question": "The engine block is made of aluminum alloy, and the cylinder head is made of cast iron. When the engine is running, the block temperature reaches 200°C while the cylinder head temperature reaches 300°C. How much heat is conducted per hour at the interface between the two materials?",
    "query": "SELECT ((300-200)*0.5)/((0.01/80)+(0.01/205))*3600 AS Heat_Joules_Per_Hour FROM enginematerials WHERE Block_Material='Aluminum' AND Head_Material='Cast Iron'",
    "step": "【step1】: Filter the enginematerials table where Block_Material is 'Aluminum' and Head_Material is 'Cast Iron' to verify material compatibility and obtain base parameters  【step2】: Apply Fourier's Law formula with hardcoded thermal conductivity values (80 W/m·K for Aluminum, 205 W/m·K for Cast Iron), temperature difference (300-200°C), contact area (0.5 m²), and thickness (0.01 m) to calculate thermal resistance and heat flux  【step3】: Multiply the derived power (watts) by 3600 seconds to convert to hourly heat transfer in joules, returning the final result as Heat_Joules_Per_Hour",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 318,
    "question": "A certain titanium alloy connecting rod material has a tensile strength of 900 MPa and a density of 4.5 g/cm³. If the connecting rod is required to have a safety factor of 2 when subjected to a tensile force of 50,000 N, calculate the minimum cross-sectional area and the maximum allowable weight assuming a length of 150 mm.",
    "query": "SELECT (2*50000)/(900e6) AS Min_Area_m2, (2*50000)/(900e6) * 0.15 * (4.5*1000) AS Max_Weight_kg FROM enginematerials WHERE Connecting_Rod_Material='Titanium'",
    "step": "【step1】: Filter engine materials where connecting rod material is Titanium using WHERE clause  【step2】: Calculate minimum cross-sectional area using formula (2×Force)/(Strength) converted to m² units  【step3】: Compute maximum weight by multiplying area by length constraint (0.15m) and material density (4500 kg/m³)",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 319,
    "question": "When an engine uses a cast iron cylinder block, its weight is 120kg. After switching to a magnesium alloy, the weight is reduced by 35%, but a 2mm-thick steel reinforcement layer (steel density 7800 kg/m³) needs to be added to the surface. Assuming the cylinder block volume is 0.015 cubic meters, is the final weight lower than the original cast iron solution?",
    "query": "SELECT CASE WHEN (0.015*1800*0.65) + (2*(e.Length*e.Width + e.Width*e.Height + e.Height*e.Length)/1e6 * 0.002 * 7800) < 120 THEN 'Yes' ELSE 'No' END FROM engine en JOIN enginedimensions e ON en.Engine_ID = e.Engine_ID JOIN enginematerials em ON en.Engine_ID = em.Engine_ID WHERE en.Weight = 120 AND em.Block_Material = 'Cast Iron';",
    "step": "【step1】: Join engine, enginedimensions, and enginematerials tables to filter engine records where Weight=120kg and Block_Material='Cast Iron', obtaining dimensional parameters.  【step2】: Calculate magnesium alloy block weight (0.015m³ × 1800kg/m³ × 65%) and steel reinforcement layer weight via surface area formula (2×(L×W + W×H + H×L)/1e6 × 0.002m × 7800kg/m³) using dimensions from enginedimensions.  【step3】: Compare total weight (magnesium + steel) with original 120kg using CASE statement to determine final weight status.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 320,
    "question": "If a certain crankshaft material is set as a hypothetical material with a density of 0.01 kg/m³, calculate whether the centrifugal force at 6000 RPM would cause structural failure of the material. It is known that the crankshaft arm length is 80 mm, the cross-sectional area is 200 mm², and the material's tensile strength is maintained at 900 MPa.",
    "query": "SELECT CASE WHEN (0.5 * (0.01 * 0.0002 * 0.08) * POWER((6000*2*PI()/60),2) * 0.08)/200e-6 > 900e6 THEN 'expired' ELSE 'Safety' END FROM enginematerials WHERE Crankshaft_Material='Hypothetical Materials'",
    "step": "【step1】: Calculate the angular velocity ω (6000 RPM → 6000×2π/60 rad/s)  【step2】: Compute centrifugal force using F=0.5×mass×ω²×radius (mass=0.01kg/m³×0.0002m²×0.08m)  【step3】: Compare stress (F/200e-6m²) against tensile strength (900MPa) via CASE conditional logic",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 321,
    "question": "Calculate the average brake mean effective pressure (BMEP) and average thermal efficiency for each engine configuration (cylinder arrangement).",
    "query": "SELECT e.Configuration, AVG((e.Torque * 2 * PI() * ed.Peak_Torque) / (e.Displacement * 1000) * 60 / 100000) AS Calculated_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Configuration ORDER BY e.Configuration;",
    "step": "【step1】: Perform multi-table JOIN operation between engine, enginedynamics, and engineperformance tables using Engine_ID as the foreign key.  【step2】: Calculate group-wise averages for BMEP (using torque/displacement formula) and Thermal Efficiency through GROUP BY on Configuration.  【step3】: Sort results alphabetically by Configuration using ORDER BY clause.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 322,
    "question": "Calculate the geometric mean of the product of specific power and specific torque for each manufacturer, and sort the results in descending order by the geometric mean.",
    "query": "SELECT e.Manufacturer, SQRT(AVG(ep.Specific_Power * ep.Specific_Torque)) AS Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Manufacturer ORDER BY Geometric_Mean DESC;",
    "step": "【step1】: Join the 'engine' and 'engineperformance' tables using Engine_ID to associate each engine's manufacturer with its performance data.  【step2】: Group the results by Manufacturer and calculate the geometric mean using SQRT(AVG(Specific_Power * Specific_Torque)) for each group.  【step3】: Order the final output by the calculated geometric mean in descending order.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 323,
    "question": "Group by displacement intervals (<2.0L, 2.0-3.0L, >3.0L) to calculate the median fuel consumption rate (Fuel_Consumption), verifying whether the common knowledge that 'larger displacement leads to higher fuel consumption' holds true.",
    "query": "SELECT Displacement_Group, AVG(Fuel_Consumption) AS Median_Fuel_Consumption FROM (SELECT e.Engine_ID, ep.Fuel_Consumption, CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END AS Displacement_Group, ROW_NUMBER() OVER (PARTITION BY CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END ORDER BY ep.Fuel_Consumption) AS RowAsc, ROW_NUMBER() OVER (PARTITION BY CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END ORDER BY ep.Fuel_Consumption DESC) AS RowDesc FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID) AS Ranked WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc GROUP BY Displacement_Group ORDER BY MIN(Ranked.Displacement_Group);",
    "step": "【step1】: Create displacement groups and calculate dual row numbers for fuel consumption rankings within each group using window functions. The CASE statement categorizes engines into three displacement groups, while ROW_NUMBER() creates ascending and descending rankings based on Fuel_Consumption.  【step2】: Identify median positions by filtering rows where ascending and descending ranks match (odd counts) or differ by 1 (even counts). This WHERE clause (RowAsc = RowDesc OR RowAsc + 1 = RowDesc) isolates median candidate records in each displacement group.  【step3】: Calculate final median values by averaging paired middle values (for even-numbered groups) or taking single middle values (for odd-numbered groups) using AVG(), then sort results logically by displacement group size through MIN(Displacement_Group) ordering.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 324,
    "question": "Assuming the thermal efficiency (Thermal_Efficiency) of an electric engine (Fuel_Type='Electric') is 120%, calculate the theoretical fuel consumption rate (Theoretical_Fuel_Consumption) and compare it with the average fuel consumption of gasoline engines, grouped by fuel type.",
    "query": "SELECT e.Fuel_Type, CASE WHEN e.Fuel_Type = 'Electric' THEN (100 / 120) * 100 ELSE AVG(ep.Fuel_Consumption) END AS Theoretical_Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Electric', 'Gasoline') GROUP BY e.Fuel_Type;",
    "step": "【step1】: Perform an INNER JOIN between the 'engine' and 'engineperformance' tables using Engine_ID, filtering only Electric and Gasoline fuel types.  【step2】: Apply conditional logic with CASE to calculate theoretical fuel consumption for Electric engines ((100/120)*100) while retaining Gasoline engine data for aggregation.  【step3】: Group results by Fuel_Type and compute AVG(Fuel_Consumption) for Gasoline engines while preserving the calculated Electric value through the CASE expression.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 325,
    "question": "Calculate the total heat capacity per degree Celsius for engines with combustion efficiency exceeding 30% by different manufacturers, and identify the manufacturer with the highest total heat capacity per degree.",
    "query": "SELECT e.Manufacturer, SUM(et.Heat_Rejection_Rate * 1000 / (et.Specific_Heat_Capacity * (et.Coolant_Temperature - 25))) AS Total_Heat_Capacity_Per_Degree FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Combustion_Efficiency > 30 GROUP BY e.Manufacturer ORDER BY Total_Heat_Capacity_Per_Degree DESC LIMIT 1;",
    "step": "【step1】: Filter engines with combustion efficiency over 30% using JOIN between engine and enginethermodynamics tables via Engine_ID.  【step2】: Calculate heat capacity per °C for each manufacturer using formula (Heat_Rejection_Rate*1000)/(Specific_Heat_Capacity*(Coolant_Temperature-25)) and aggregate via SUM with GROUP BY Manufacturer.  【step3】: Sort results by Total_Heat_Capacity_Per_Degree in descending order and select the top manufacturer using LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 326,
    "question": "Statistics on all engines with a compression ratio greater than 10:1, calculating the product of specific power (Specific_Power) and thermal efficiency (Thermal_Efficiency), and filtering for engine models where this product exceeds the average product value among all engines with a compression ratio greater than 10:1.",
    "query": "SELECT e.Model, (ep.Specific_Power * ep.Thermal_Efficiency) AS Efficiency_Product FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE CAST(SUBSTRING_INDEX(e.Compression_Ratio, ':', 1) AS UNSIGNED) > 10 AND (ep.Specific_Power * ep.Thermal_Efficiency) > (SELECT AVG(ep2.Specific_Power * ep2.Thermal_Efficiency) FROM engineperformance ep2 JOIN engine e2 ON ep2.Engine_ID = e2.Engine_ID WHERE CAST(SUBSTRING_INDEX(e2.Compression_Ratio, ':', 1) AS UNSIGNED) > 10);",
    "step": "【step1】: Filter engines with compression ratio >10:1 by extracting the numeric part before colon and join with engineperformance to get efficiency metrics  【step2】: Calculate overall average of (Specific_Power * Thermal_Efficiency) across filtered engines using a subquery  【step3】: Select engine models where efficiency product exceeds the calculated average from step2",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 327,
    "question": "Identify engines with exhaust gas temperature exceeding 900°C and cylinder block material as cast iron.",
    "query": "SELECT e.Engine_ID, et.Exhaust_Gas_Temperature, em.Block_Material FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE et.Exhaust_Gas_Temperature > 900 AND em.Block_Material = 'Cast Iron';",
    "step": "【step1】: Execute INNER JOIN between engine, enginethermodynamics, and enginematerials tables using Engine_ID to combine thermodynamic data with material specifications.  【step2】: Apply WHERE clause to filter engines with Exhaust_Gas_Temperature > 900°C and Block_Material = 'Cast Iron'.  【step3】: Compare filtered results against material science standards (typical cast iron withstands ≤800°C) to identify potential design flaws or measurement errors.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 328,
    "question": "Assuming the existence of an engine with a rotational speed of 100,000 RPM, calculate whether its piston speed exceeds 7,000 m/s and return the overspeed ratio.",
    "query": "SELECT e.Model, (2 * e.Stroke * 100000) / 60000 AS Hypothetical_Piston_Speed, ((2 * e.Stroke * 100000) / 60000 - 7000) / 7000 * 100 AS Over_Speed_Percentage FROM engine e HAVING Hypothetical_Piston_Speed > 7000;",
    "step": "【step1】: Calculate hypothetical piston speed for each engine model using the formula (2 * Stroke * 100000)/60000  【step2】: Derive over-speed percentage by comparing the calculated piston speed to 7000 m/s threshold  【step3】: Filter results to only show engines where piston speed exceeds missile re-entry speed using HAVING clause",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 329,
    "question": "Assuming the engine block height (DeckHeight) is 200 millimeters, the bore (Bore) is 90 millimeters, the stroke (Stroke) is 100 millimeters, and the compression ratio (Compression_Ratio) is 11:1. Please calculate the combustion chamber volume (in liters) for this engine and verify if the compression ratio of 11 is less than or equal to 13?",
    "query": "SELECT ROUND((PI() * POW(90/2,2) * 100) / (11-1) / 1000000, 4) AS Combustion_Chamber_Volume_L, CASE WHEN 11 <= 13 THEN 'conforms to' ELSE 'does not meet the requirements' END AS Compression_Ratio_Check FROM DUAL;",
    "step": "【step1】: Calculate cylinder displacement volume: π × (Bore/2)² × Stroke = π × (90/2)² × 100 (in mm³)  【step2】: Compute combustion chamber volume: (Cylinder displacement) / (Compression_Ratio-1) / 1000000 converts mm³ to liters  【step3】: Validate compression ratio against gasoline engine standards (typically ≤13:1) using CASE conditional check",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 330,
    "question": "Please calculate the weighted composite score (with weights of 0.6 and 0.4, respectively) of specific power and thermal efficiency for all engines that use an aluminum alloy cylinder block and are turbocharged, rounding the result to two decimal places.",
    "query": "SELECT ROUND((ep.Specific_Power*0.6 + ep.Thermal_Efficiency*0.4),2) AS Comprehensive_Score FROM engine e JOIN enginematerials em ON e.Engine_ID=em.Engine_ID JOIN engineperformance ep ON e.Engine_ID=ep.Engine_ID WHERE em.Block_Material='Aluminum' AND e.Aspiration='Turbocharged' AND ep.Specific_Power IS NOT NULL AND ep.Thermal_Efficiency IS NOT NULL;",
    "step": "【step1】: Filter engines with Aluminum block material and Turbocharged aspiration by joining engine and enginematerials tables.  【step2】: Join engineperformance table to access power/thermal metrics, ensuring non-null values for Specific_Power and Thermal_Efficiency.  【step3】: Calculate weighted composite score (0.6*Specific_Power + 0.4*Thermal_Efficiency) and apply ROUND() to two decimal places.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 331,
    "question": "A manufacturer needs to design a V-type engine with a length not exceeding 600 millimeters. Given that the cylinder spacing is 120 millimeters and the rows are offset by a factor of 0.866 (representing a 30-degree V angle), calculate the maximum number of cylinders this engine can accommodate, taking into account the staggered arrangement characteristic of the two rows of cylinders in a V-type engine.",
    "query": "SELECT FLOOR(600 / (120 * 0.866)) * 2 AS Max_Cylinders FROM engine WHERE Configuration = 'V' LIMIT 1;",
    "step": "【step1】: Calculate the effective length occupied by each cylinder bank using the trigonometric relationship (cylinder spacing * cos(30°) ≈ 120 * 0.866) due to the staggered V-configuration.  【step2】: Determine single bank capacity with FLOOR(600 / (120*0.866)) to find 5 cylinders, as 5×103.92mm ≤600mm while 6×103.92mm exceeds the limit.  【step3】: Double the result (5×2=10) to account for both banks in V-type engines, achieving maximum cylinder count while maintaining spatial constraints.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 332,
    "question": "Assuming that the piston speed of a certain electric engine reaches 50 meters per second (far exceeding the physical limit), with a stroke of 200 millimeters, please calculate the RPM, the angular velocity of the engine at peak power speed, and determine how many times greater the centrifugal force acting on the crankshaft is compared to that of a conventional engine.",
    "query": "SELECT ROUND((50*60)/(2*0.2),0) AS RPM_假设, ROUND((50*60)/(2*0.2)*PI()/30,2) AS Angular_Velocity, ROUND(POW((50*60)/(2*0.2)/6000,2),2) AS Centrifugal_Force_Multiplier FROM engine WHERE Fuel_Type='Electric' AND Stroke=200 LIMIT 1;",
    "step": "【step1】: Filter electric engines with 200mm stroke using WHERE clause to isolate the target engine configuration.  【step2】: Calculate hypothetical RPM using formula (piston_speed*60)/(2*stroke_in_meters), then derive angular velocity via RPM*(π/30).  【step3】: Compute centrifugal force multiplier by squaring the ratio of hypothetical RPM to 6000 RPM (conventional baseline).",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "1",
    "idx": 333,
    "question": "Calculate the mean piston speed of engine models at maximum RPM, and identify all engine models with a mean piston speed exceeding 25 meters per second along with their manufacturers.",
    "query": "SELECT e.Manufacturer, e.Model, (2 * e.Stroke * ed.Max_turn) / 60000 AS Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE (2 * e.Stroke * ed.Max_turn) / 60000 > 25;",
    "step": "【step1】: Join the 'engine' and 'enginedynamics' tables using Engine_ID to access Stroke (from engine) and Max_turn (from enginedynamics).  【step2】: Calculate Mean_Piston_Speed via formula (2 * Stroke * Max_turn) / 60000, converting units appropriately.  【step3】: Filter results where Mean_Piston_Speed exceeds 25 m/s, then output Manufacturer and Model.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "2",
    "idx": 334,
    "question": "Calculate the standard deviation of angular velocity for V and inline engines, excluding those with a compression ratio less than 10.",
    "query": "SELECT e.Configuration, STDDEV((ed.Max_turn * 2 * PI()) / 60) AS Angular_Velocity_StdDev FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Compression_Ratio >= 10 AND e.Configuration IN ('V', 'Inline') GROUP BY e.Configuration;",
    "step": "【step1】: Perform an INNER JOIN between `engine` and `enginedynamics` tables on `Engine_ID`, filtering engines with `Compression_Ratio >= 10` and configurations of 'V' or 'Inline'.  【step2】: Calculate angular velocity using `(ed.Max_turn * 2 * PI()) / 60` to convert RPM to rad/s.  【step3】: Group results by `Configuration` and compute the standard deviation of angular velocity using `STDDEV()` for comparison between V-type and Inline engines.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "3",
    "idx": 335,
    "question": "Find all diesel engines that use cast iron cylinder blocks but have a thermal efficiency exceeding 40%, and sort them by specific power from highest to lowest.",
    "query": "SELECT e.Model, e.Manufacturer, ep.Specific_Power FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE em.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Diesel' AND ep.Thermal_Efficiency > 40 ORDER BY ep.Specific_Power DESC;",
    "step": "【step1】: Join three tables (engine, enginematerials, engineperformance) using Engine_ID to establish relationships between core specifications, material properties, and performance metrics.  【step2】: Apply filters for 'Cast Iron' block material, 'Diesel' fuel type, and thermal efficiency exceeding 40% to target specific engine qualifications.  【step3】: Sort results by Specific_Power in descending order and project Model, Manufacturer, and Specific_Power as final output columns.",
    "format": "MySQL"
  },
  {
    "db_id": "car_engine",
    "type": "4",
    "idx": 336,
    "question": "What are the connecting rod materials for engines with a rod journal diameter exceeding 500 millimeters?",
    "query": "SELECT DISTINCT em.Connecting_Rod_Material FROM enginematerials em JOIN enginedimensions ed ON em.Engine_ID = ed.Engine_ID WHERE ed.Rod_Journal_Diameter > 500;",
    "step": "【step1】: Perform JOIN operation between enginematerials (em) and enginedimensions (ed) tables using Engine_ID to combine material and dimensional data.  【step2】: Apply WHERE clause to filter records where Rod_Journal_Diameter exceeds 500 millimeters.  【step3】: Extract DISTINCT Connecting_Rod_Material values from the filtered joined dataset.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 337,
    "question": "Calculate the total energy consumption of a car for 50 liters of fuel, given city fuel efficiency is 10km/L and highway fuel efficiency is 15km/L.",
    "query": "SELECT (50 * 10) + (50 * 15) AS Total_Energy_Consumption;",
    "step": "【step1】: Retrieve the vehicle's fuel efficiency and tank capacity from the 'cars' table using the specific model identification.  【step2】: Calculate city energy consumption (Fuel_Tank_Capacity * Fuel_Efficiency_City) and highway energy consumption (Fuel_Tank_Capacity * Fuel_Efficiency_Highway).  【step3】: Sum both values to derive the total energy consumption using arithmetic addition.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 338,
    "question": "Calculate the average power-to-weight ratio of all cars from a certain manufacturer and identify the top 5 cars with the highest power-to-weight ratio.",
    "query": "SELECT AVG(engine_specs.Horsepower / dimensions.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123; SELECT cars.Model, (engine_specs.Horsepower / dimensions.Curb_Weight) AS Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123 ORDER BY Power_to_Weight_Ratio DESC LIMIT 5;",
    "step": "【step1】: Join 'cars', 'engine_specs', and 'dimensions' tables using Car_ID, filter by Manufacturer_ID=123 to gather required data.  【step2】: Calculate average power-to-weight ratio using AVG() on the horsepower/curb_weight ratio from the joined dataset.  【step3】: Extract top 5 models by calculating individual power-to-weight ratios, sorting DESC, and applying LIMIT 5 from the same joined dataset.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 339,
    "question": "Find all cars produced in 2020 with more than 5 seats and calculate their average cargo capacity.",
    "query": "SELECT AVG(Cargo_Capacity) AS Avg_Cargo_Capacity FROM cars WHERE Year = 2020 AND Seating_Capacity > 5;",
    "step": "【step1】: Filter cars produced in 2020 with seating capacity exceeding 5 using WHERE Year = 2020 AND Seating_Capacity > 5  【step2】: Calculate the average value of the Cargo_Capacity field from the filtered dataset using AVG(Cargo_Capacity)",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 340,
    "question": "A certain car has a battery capacity of 1000 kWh and a range of 10,000 km. Calculate its energy consumption per kilometer, and find all electric vehicles with energy consumption lower than that value.",
    "query": "SELECT 1000 / 10000 AS Energy_Consumption_Per_km; SELECT * FROM cars WHERE Battery_Capacity / Range < (1000 / 10000);",
    "step": "【step1】:Calculate the reference energy consumption per km: 1000 kWh / 10,000 km = 0.1 kWh/km.  【step2】Retrieve all electric vehicles (implied by Battery_Capacity/Range fields) from the cars table.  【step3】Filter vehicles where Battery_Capacity/Range < 0.1 to select those with lower energy consumption.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 341,
    "question": "Calculate the air resistance for the car model 'Corolla' when driving at its maximum speed, given the air density is 1.225 kg/m³, the car's drag coefficient is 0.3, and the frontal area is 2.5 m².",
    "query": "SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Corolla';",
    "step": "【step1】: Join cars, performance_metrics, and engine_specs tables using Car_ID to consolidate required data (top speed, horsepower)  【step2】: Apply WHERE filter to select specific car model and convert top speed from km/h to m/s via division by 3.6 in POWER() function  【step3】: Calculate air resistance using formula (0.5 * density * (speed²) * drag_coefficient * area) and compare with horsepower value",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 342,
    "question": "Calculate the average fuel efficiency for each car model from a certain manufacturer and identify the top three models with the highest average fuel efficiency.",
    "query": "SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'A certain manufacturer' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;",
    "step": "【step1】: Join the 'cars' and 'manufacturers' tables using Manufacturer_ID, filter records where manufacturer name is 'A certain manufacturer'.  【step2】: Calculate average fuel efficiency for each model by averaging Fuel_Efficiency_City and Fuel_Efficiency_Highway.  【step3】: Order results by average fuel efficiency in descending order and retain the top 3 models using LIMIT.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 343,
    "question": "Estimate the per-kilometer fuel cost for the Corolla in urban and highway conditions based on its fuel efficiency, with the fuel price set at $1.2 per liter.",
    "query": "SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = 'Corolla';",
    "step": "【step1】: Filter the 'cars' table to select the specific car model using WHERE clause.  【step2】: Calculate city fuel cost per kilometer by inverting Fuel_Efficiency_City (km/L), then multiplying by fuel price (1.2 USD/L).  【step3】: Calculate highway fuel cost per kilometer using the same logic with Fuel_Efficiency_Highway.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 344,
    "question": "If the battery capacity of a Toyota Corolla is increased to 1000 kWh, calculate whether its range will exceed 10,000 km, given an electricity consumption of 0.2 kWh per kilometer.",
    "query": "SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = 'Corolla';",
    "step": "【step1】: Filter the 'cars' table to retrieve the specific model using WHERE c.Model = 'Corolla'.  【step2】: Calculate theoretical range with formula 1000 kWh / 0.2 kWh per km, aliased as Theoretical_Range.  【step3】: Compare the calculated value to determine if it exceeds 10,000 km (implicit in result interpretation).",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 345,
    "question": "Calculate the total energy consumption (in kilowatt-hours) of the car with Car_ID '1' for driving 100 kilometers in the city and 200 kilometers on the highway.",
    "query": "SELECT ((100 / Fuel_Efficiency_City) + (200 / Fuel_Efficiency_Highway)) * 8.9 AS Total_Energy_Consumption FROM cars WHERE Car_ID = '1';",
    "step": "【step1】: Retrieve the city and highway fuel efficiency values (Fuel_Efficiency_City and Fuel_Efficiency_Highway) for the specified Car_ID from the 'cars' table.  【step2】: Calculate fuel consumption for both city (100 km / Fuel_Efficiency_City) and highway (200 km / Fuel_Efficiency_Highway) segments.  【step3】: Sum the fuel consumption values and multiply by 8.9 to convert the total fuel volume to energy in kilowatt-hours (kWh), then output as Total_Energy_Consumption.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 346,
    "question": "Calculate the average power-to-weight ratio for each car model from manufacturer with ID 1 and identify the top 5 models with the highest power-to-weight ratios.",
    "query": "SELECT c.Model, AVG(e.Horsepower / d.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN dimensions d ON c.Car_ID = d.Car_ID WHERE c.Manufacturer_ID = 1 GROUP BY c.Model ORDER BY Avg_Power_to_Weight_Ratio DESC LIMIT 5;",
    "step": "【step1】: Join tables `cars`, `engine_specs`, and `dimensions` via `Car_ID` and filter by `Manufacturer_ID = 1` to gather required horsepower and curb weight data.  【step2】: Calculate the average power-to-weight ratio (`Horsepower/Curb_Weight`) for each model using `AVG()` and group results by `c.Model`.  【step3】: Sort models by `Avg_Power_to_Weight_Ratio` in descending order and limit output to the top 5 records using `ORDER BY ... DESC LIMIT 5`.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 347,
    "question": "Find all car models produced in 2020 with a fuel tank capacity greater than 50 liters and city fuel efficiency below 10 km/L, sorted in descending order by production volume.",
    "query": "SELECT Model FROM cars WHERE Year = 2020 AND Fuel_Tank_Capacity > 50 AND Fuel_Efficiency_City < 10 ORDER BY Production_Volume DESC",
    "step": "【step1】: Filter the 'cars' table to include only records where Year is 2020.  【step2】: Apply additional filters for Fuel_Tank_Capacity > 50 and Fuel_Efficiency_City < 10 to the results from step1.  【step3】: Sort the remaining entries by Production_Volume in descending order and extract the Model names.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 348,
    "question": "Calculate the amount of fuel required for a car to travel 1000 kilometers with a fuel efficiency of 0.1 km/L, and determine its carbon dioxide emissions.",
    "query": "SELECT (1000 / 0.1) AS Fuel_Consumption, (1000 / 0.1) * 2.31 AS CO2_Emissions",
    "step": "【step1】: Calculate fuel consumption by dividing distance by fuel efficiency: 1000km / 0.1km/L = 10,000L  【step2】: Multiply fuel consumption by CO2 emission factor (2.31g/L) to get total emissions: 10,000L * 2.31 = 23,100g",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 349,
    "question": "If the fuel efficiency of a car decreases by 10%, what is the percentage change in its fuel efficiency in both city and highway driving?",
    "query": "SELECT Model, ((Fuel_Efficiency_City * 0.9 - Fuel_Efficiency_City) / Fuel_Efficiency_City) * 100 AS City_Efficiency_Change_Percent, ((Fuel_Efficiency_Highway * 0.9 - Fuel_Efficiency_Highway) / Fuel_Efficiency_Highway) * 100 AS Highway_Efficiency_Change_Percent FROM cars;",
    "step": "【step1】: Select the Model and original fuel efficiency values (Fuel_Efficiency_City and Fuel_Efficiency_Highway) from the cars table.  【step2】: Calculate the percentage change for city fuel efficiency using the formula ((Fuel_Efficiency_City * 0.9 - Fuel_Efficiency_City) / Fuel_Efficiency_City) * 100.  【step3】: Calculate the percentage change for highway fuel efficiency analogously and output both results with the Model.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 350,
    "question": "Identify the car models from a certain manufacturer that have a production volume greater than the average production volume of cars from that manufacturer.",
    "query": "SELECT Model FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer') AND Production_Volume > (SELECT AVG(Production_Volume) FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer'));",
    "step": "【step1】: Retrieve the Manufacturer_ID from the 'manufacturers' table where the manufacturer name matches 'A certain manufacturer'.  【step2】: Calculate the average Production_Volume of all cars produced by this manufacturer using the Manufacturer_ID obtained in Step 1.  【step3】: Select car models from the 'cars' table where the Manufacturer_ID matches the result from Step 1 and Production_Volume exceeds the average value calculated in Step 2.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 351,
    "question": "Find which cars have a fuel tank capacity that is less than the amount of fuel required for city fuel consumption multiplied by 10, and list the manufacturers and models of these cars.",
    "query": "SELECT m.Name, c.Model FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity < (e.Fuel_Consumption_City * 10);",
    "step": "【step1】: Join cars table with manufacturers and engine_specs tables using Manufacturer_ID and Car_ID respectively to connect vehicle data.  【step2】: Apply WHERE filter condition comparing Fuel_Tank_Capacity against (Fuel_Consumption_City * 10) which represents 1000km fuel requirement.  【step3】: Select and output manufacturer Name and car Model fields from the filtered results.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 352,
    "question": "If a car has a maximum speed of 1000 km/h, what would its hypothetical braking distance be, assuming it follows the same braking performance relationship as the cars in the database?",
    "query": "SELECT c.Model, (p.Braking_Distance * POWER(1000, 2) / POWER(p.Top_Speed, 2)) AS Hypothetical_Braking_Distance FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID;",
    "step": "【step1】: Join `cars` and `performance_metrics` tables via `Car_ID` to associate car models with their original braking distance and top speed data.  【step2】: Apply proportional calculation using the formula: `(original_braking_distance * (1000² / original_top_speed²))` to derive the hypothetical braking distance.  【step3】: Select the car model and the calculated hypothetical braking distance for final output.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 353,
    "question": "If a car with a weight of 1500kg is traveling at a speed of 100km/h, and the query uses a formula that calculates kinetic energy as 0.5 * weight * (speed in m/s squared), what is the kinetic energy in joules?",
    "query": "SELECT 0.5 * Weight * POWER((100 * 1000 / 3600), 2) AS Kinetic_Energy FROM cars WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the weight (in kg) of the car with Car_ID=1 from the cars table.  【step2】: Convert the given speed from km/h to m/s by applying the formula (100 * 1000 / 3600), then square the result.  【step3】: Compute kinetic energy using the formula 0.5 * Weight * squared_speed and alias the result as Kinetic_Energy.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 354,
    "question": "Calculate the average fuel efficiency (average of city and highway) for all car models from a certain manufacturer, and identify the model with the highest average fuel efficiency.",
    "query": "SELECT Model, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2) AS Avg_Fuel_Efficiency FROM cars WHERE Manufacturer_ID = 1 GROUP BY Model ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;",
    "step": "【step1】: Filter cars by Manufacturer_ID=1 to focus on the target manufacturer's vehicles.  【step2】: Calculate the average fuel efficiency ((City + Highway)/2) for each model using AVG and GROUP BY Model.  【step3】: Sort results by Avg_Fuel_Efficiency in descending order and select the top model with LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 355,
    "question": "If a car has a fuel tank capacity of 50L, city fuel consumption of 8L/100km, and highway fuel consumption of 6L/100km, how many kilometers can it travel in the city and on the highway respectively?",
    "query": "SELECT Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Car_ID = 1;",
    "step": "【step1】: JOIN cars and engine_specs tables via Car_ID to combine fuel capacity and consumption data  【step2】: Filter for Car_ID=1 using WHERE clause to isolate the target vehicle  【step3】: Calculate range by dividing Fuel_Tank_Capacity by fuel consumption (L/100km) then multiplying by 100 for unit conversion",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 356,
    "question": "If a car's engine has a maximum speed of 10,000 RPM and consumes 0.1L of fuel per minute at maximum speed, how much fuel will it consume when running at maximum speed for 1 hour?",
    "query": "SELECT Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the Max_RPM value from the engine_specs table for Car_ID = 1.  【step2】: Calculate fuel consumption by multiplying Max_RPM (per minute) by 60 (minutes) and 0.1 (liters per RPM).  【step3】: Output the computed Fuel_Consumption value directly from the calculation.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 357,
    "question": "Calculate the kinetic energy of each car at its maximum speed and identify the model with the highest kinetic energy.",
    "query": "SELECT Model, 0.5 * Weight * POWER((Top_Speed * 1000 / 3600), 2) AS Kinetic_Energy FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID ORDER BY Kinetic_Energy DESC LIMIT 1;",
    "step": "【step1】: JOIN cars and performance_metrics tables using Car_ID to combine vehicle weight and top speed data  【step2】: Calculate kinetic energy using formula 0.5 * Weight * (Top_Speed converted to m/s) squared  【step3】: Sort results by kinetic energy in descending order and select the top model using LIMIT 1",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 358,
    "question": "Calculate the average fuel efficiency (mean of city and highway) for all manufacturers' cars, and identify the manufacturer with the highest fuel efficiency.",
    "query": "SELECT manufacturers.Name, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2) AS Avg_Fuel_Efficiency FROM cars JOIN manufacturers ON cars.Manufacturer_ID = manufacturers.Manufacturer_ID GROUP BY manufacturers.Name ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;",
    "step": "【step1】: Join 'cars' with 'manufacturers' using Manufacturer_ID to associate vehicles with their makers  【step2】: Calculate average fuel efficiency per manufacturer by taking (City + Highway)/2 for each car, then AVG() across all models  【step3】: Order results by Avg_Fuel_Efficiency descending and select top result using LIMIT 1",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 359,
    "question": "Calculate the car model with the highest driving mileage in both urban and highway conditions.",
    "query": "SELECT c.Model, c.Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID ORDER BY City_Range DESC, Highway_Range DESC LIMIT 1;",
    "step": "【step1】: Join 'cars' and 'engine_specs' tables via Car_ID to combine fuel capacity and consumption data.  【step2】: Calculate City_Range (Fuel_Tank_Capacity / Fuel_Consumption_City * 100) and Highway_Range (Fuel_Tank_Capacity / Fuel_Consumption_Highway * 100) for each vehicle.  【step3】: Sort results by City_Range and Highway_Range descendingly, then return the top-ranked model with LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 360,
    "question": "Calculate the fuel consumption of all cars running at maximum RPM for 1 hour, and list the model with the highest fuel consumption.",
    "query": "SELECT cars.Model, Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs JOIN cars ON engine_specs.Car_ID = cars.Car_ID ORDER BY Fuel_Consumption DESC LIMIT 1;",
    "step": "【step1】: Join cars and engine_specs tables using Car_ID to associate engine specifications with vehicle models.  【step2】: Calculate hourly fuel consumption at max RPM using formula (Max_RPM * 60 * 0.1) and alias as Fuel_Consumption.  【step3】: Sort results by Fuel_Consumption in descending order and select the top entry with LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 361,
    "question": "If a car weighs 1500 kg and its 0-100 acceleration time is 8 seconds, what is its average acceleration?",
    "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE Weight = 1500;",
    "step": "【step1】: Perform an INNER JOIN between `cars` and `performance_metrics` tables using the shared `Car_ID` column to combine car weight and acceleration data.  【step2】: Apply a filter with `WHERE Weight = 1500` to isolate records matching the specified weight.  【step3】: Select the `Weight` and `Acceleration_0_to_100` columns from the filtered result.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 362,
    "question": "A car has a fuel efficiency of 10 km/L in the city, with a fuel tank capacity of 50 L. If it travels 30 km per day, how many consecutive days can the car drive before needing to refuel?",
    "query": "SELECT Fuel_Efficiency_City, Fuel_Tank_Capacity FROM cars WHERE Fuel_Efficiency_City = 10 AND Fuel_Tank_Capacity = 50;",
    "step": "【step1】:【Filter cars with Fuel_Efficiency_City = 10 km/L and Fuel_Tank_Capacity = 50 L using the WHERE clause】  【step2】:【Select the Fuel_Efficiency_City and Fuel_Tank_Capacity columns from the filtered records】",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 363,
    "question": "If a car has a cargo capacity of 500L, and each transport requires 300L of cargo, what is the maximum number of times this car can transport?",
    "query": "SELECT Cargo_Capacity FROM cars WHERE Cargo_Capacity = 500;",
    "step": "【step1】: Retrieve the Cargo_Capacity value from the cars table where the capacity is exactly 500L using the filter condition: SELECT Cargo_Capacity FROM cars WHERE Cargo_Capacity = 500  【step2】: Calculate the maximum number of transports by performing integer division (500L ÷ 300L per trip) using FLOOR() or DIV operator  【step3】: Return the result as an integer alias (e.g., Max_Transport_Times) with SELECT FLOOR(Cargo_Capacity/300) FROM cars WHERE Cargo_Capacity=500",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 364,
    "question": "If a car's engine has a maximum RPM of 10000, what is its horsepower?",
    "query": "SELECT Max_RPM, Horsepower FROM engine_specs WHERE Max_RPM = 10000;",
    "step": "【step1】:【Retrieve all records from the 'engine_specs' table where the Max_RPM equals 10000】  【step2】:【Extract the Horsepower field from the filtered records】",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 365,
    "question": "If a car with ID 1 weighs 1500kg and takes 8 seconds to accelerate from 0 to 100 km/h, what is the average power it generates during the acceleration process?",
    "query": "SELECT Weight, Acceleration_0_to_100 FROM performance_metrics JOIN cars ON performance_metrics.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;",
    "step": "【step1】: Join the `cars` and `performance_metrics` tables via `Car_ID` to retrieve weight and acceleration data.  【step2】: Calculate average power using the formula: \\( \\text{Power} = \\frac{\\text{Weight} \\times (100/3.6)^2}{2 \\times \\text{Acceleration\\_0\\_to\\_100}} \\), converting velocity to m/s (100 km/h ≈ 27.78 m/s).  【step3】: Convert the result from watts to horsepower (1 HP ≈ 745.7 W) and alias the output as `Average_Power`.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 366,
    "question": "A car's fuel tank capacity is 60L, with urban fuel efficiency of 10km/L and highway fuel efficiency of 15km/L. If this car travels 200km in the city and 200km on the highway, how many liters of fuel does it consume in total?",
    "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE cars.Car_ID = 1;",
    "step": "【step1】: Retrieve the car's city and highway fuel efficiency values from the 'cars' table using Car_ID=1.  【step2】: Calculate city fuel consumption as 200km / Fuel_Efficiency_City and highway fuel consumption as 200km / Fuel_Efficiency_Highway.  【step3】: Sum both calculated fuel consumption values to get total liters consumed.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 367,
    "question": "A car has a cargo capacity of 500L and a trunk capacity of 300L. If the owner needs to transport a batch of goods, with each item having a volume of 50L, what is the maximum number of items this car can transport?",
    "query": "SELECT (dimensions.Cargo_Capacity + dimensions.Trunk_Capacity) / 50 AS Max_Cargo_Items FROM dimensions JOIN cars ON dimensions.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;",
    "step": "【step1】: Join the 'dimensions' and 'cars' tables using Car_ID to retrieve cargo capacity data.  【step2】: Filter the joined dataset to target the specific vehicle with Car_ID = 1.  【step3】: Compute the maximum cargo items by adding Cargo_Capacity and Trunk_Capacity from the dimensions table, then dividing by 50 (per-item volume).",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 368,
    "question": "If a car with a battery capacity of 100 kWh and a range of 500 km changes its battery capacity to 1000 kWh while all other conditions remain the same, what is the new range?",
    "query": "SELECT `Range` * (1000 / `Battery_Capacity`) AS New_Range FROM cars WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the original `Range` and `Battery_Capacity` values for Car_ID=1 from the `cars` table.  【step2】: Calculate the hypothetical new range by scaling proportionally using the formula `New_Range = Range * (1000 / Battery_Capacity)`.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 369,
    "question": "What are the car's weight and 0-100 acceleration time?",
    "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
    "step": "【step1】: JOIN cars and performance_metrics tables using Car_ID to retrieve specific car's Weight and Acceleration_0_to_100 data  【step2】: Filter results using WHERE cars.Car_ID = 1 to isolate the target vehicle's records  【step3】: Extract Weight (1500kg) and Acceleration_0_to_100 (8s) values for physics calculations (executed outside SQL)",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 370,
    "question": "An automobile manufacturer with a Manufacturer_ID of 1 produces three car models, with annual sales of 5,000 units, 3,000 units, and 2,000 units respectively, and the average selling prices for each model are $30,000, $40,000, and $50,000 respectively. Calculate the manufacturer's total annual revenue.",
    "query": "SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue FROM manufacturers WHERE Manufacturer_ID = 1;",
    "step": "【step1】: Filter the manufacturers table to select the row where Manufacturer_ID = 1.  【step2】: Calculate the product of Annual_Sales and Average_Price for the filtered record, then sum the result to produce Total_Revenue.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 371,
    "question": "A car has a fuel tank capacity of 60L, with urban fuel efficiency of 10km/L and highway fuel efficiency of 15km/L. If the owner drives 200km in the city and 200km on the highway, how much fuel does the car consume in total?",
    "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the car's fuel efficiency data from the 'cars' table  【step2】: Filter the record where Car_ID = 1 and extract Fuel_Efficiency_City (10 km/L) and Fuel_Efficiency_Highway (15 km/L)  【step3】: Calculate total fuel consumption: (200km / 10km/L) + (200km / 15km/L) = 20L + 13.33L = 33.33L",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 372,
    "question": "If a car has a battery capacity of 1000kWh, travels at a top speed of 300km/h, and has an energy consumption of 500Wh/km at top speed, calculate the endurance time of the car when driving at top speed with a full battery.",
    "query": "SELECT cars.Car_ID, (cars.Battery_Capacity * 1000) / (500 * performance_metrics.Top_Speed) AS Max_Speed_Range_Time FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
    "step": "【step1】: JOIN cars and performance_metrics tables via Car_ID to access Battery_Capacity and Top_Speed.  【step2】: Calculate energy consumption rate at max speed: 500 Wh/km * Top_Speed (km/h) = 500*Top_Speed (Wh/h).  【step3】: Compute runtime by converting Battery_Capacity (kWh) to Wh (×1000), then divide by energy consumption rate: (Battery_Capacity*1000)/(500*Top_Speed).",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 373,
    "question": "If a car weighs 1500kg and its 0-100 acceleration time is 8 seconds, what is the car's average acceleration and the required average traction force?",
    "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
    "step": "【step1】: Join cars and performance_metrics tables using Car_ID to combine vehicle weight and acceleration data.  【step2】: Filter the joined dataset to retrieve records where Car_ID = 1.  【step3】: Select the Weight and Acceleration_0_to_100 fields from the filtered result.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 374,
    "question": "What is the total profit for BMW?",
    "query": "SELECT Annual_Sales, Profit_Margin, Average_Price FROM manufacturers WHERE Name = 'Tesla';",
    "step": "【step1】: Retrieve the manufacturer's annual sales, profit margin, and average price using SELECT Annual_Sales, Profit_Margin, Average_Price FROM manufacturers WHERE Name = 'Tesla'.  【step2】: Calculate total profit per model: (Annual_Sales * Average_Price * Profit_Margin / 100).  【step3】: Sum profit values across all models (A+B+C) using derived calculations from step2.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 375,
    "question": "A car's fuel tank has a capacity of 60L, with a city fuel consumption of 10L/100km and highway fuel consumption of 7L/100km. If the car owner drives 200km in the city and 200km on the highway, how much fuel does the car consume in total?",
    "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the car's city and highway fuel efficiency (in km/L) from the 'cars' table using WHERE Car_ID=1.  【step2】: Calculate city fuel consumption: 200km ÷ Fuel_Efficiency_City (km/L) to get liters used in city driving.  【step3】: Calculate highway fuel consumption: 200km ÷ Fuel_Efficiency_Highway (km/L) to get liters used on highway, then sum both values for total consumption.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 376,
    "question": "If a car with battery capacity of 1000 kWh and maximum power of 500 kW drives continuously at maximum power, what is the minimum time it takes for the battery to be depleted?",
    "query": "SELECT c.Battery_Capacity, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;",
    "step": "【step1】: Filter the cars table to retrieve the specific car with Car_ID = 1.  【step2】: Join the performance_metrics table using Car_ID to access the electric range data.  【step3】: Select the Battery_Capacity from cars and Range_Electric from performance_metrics for the specified vehicle.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 377,
    "question": "If a car weighs 1500kg and its 0 to 100 km/h acceleration time is 8 seconds, what is its average acceleration in m/s²?",
    "query": "SELECT (100 * 1000 / 3600) / 8 AS average_acceleration FROM cars WHERE Weight = 1500;",
    "step": "【step1】: JOIN cars and performance_metrics tables using Car_ID to access both Weight and Acceleration_0_to_100 data  【step2】: FILTER records where Weight=1500 AND Acceleration_0_to_100=8  【step3】: CALCULATE average acceleration using (100*1000/3600)/8 and return the result",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 378,
    "question": "If a car has a fuel tank capacity of 60L, an urban fuel efficiency of 10km/L, and a highway fuel efficiency of 15km/L, what is the vehicle's total range under mixed driving conditions (with 50% city driving and 50% highway driving)?",
    "query": "SELECT (Fuel_Tank_Capacity * Fuel_Efficiency_City * 0.5) + (Fuel_Tank_Capacity * Fuel_Efficiency_Highway * 0.5) AS total_range FROM cars WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the necessary fuel efficiency and tank capacity data for Car_ID=1 from the cars table.  【step2】: Calculate the city driving range component (50% of 60L * 10km/L) and highway driving range component (50% of 60L * 15km/L) separately.  【step3】: Sum the two components to derive the total range under mixed driving conditions.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 379,
    "question": "If a car has a base price and an annual maintenance cost, and an annual depreciation rate of 15%, what will be the total maintenance cost and the depreciated value of the car after 5 years, assuming the maintenance cost is constant each year?",
    "query": "SELECT Maintenance_Cost * 5 AS total_maintenance_cost, Base_Price * POWER(1 - Depreciation_Rate, 5) AS depreciated_value FROM prices WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the car's annual maintenance cost and base price with depreciation rate from the 'prices' table using WHERE Car_ID=1 filter  【step2】: Calculate total maintenance cost by multiplying annual maintenance cost by 5 years  【step3】: Compute depreciated value using compound depreciation formula: Base_Price × (1 - Depreciation_Rate)⁵ via POWER() function",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 380,
    "question": "If a car has a battery capacity of 1000kWh and a range of 1000km, what is the calculated extended range using the formula (100000 / Battery_Capacity) * Range?",
    "query": "SELECT (100000 / Battery_Capacity) * `Range` AS extended_range FROM cars WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the original Battery_Capacity (1000kWh) and corresponding Range (1000km) for Car_ID=1 from the cars table.  【step2】: Calculate hypothetical extended_range by scaling proportionally: (100000 / 1000) * 1000 = 100000km.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 381,
    "question": "If a car with ID 1 weighs 1500kg and its 0-100 acceleration time is 8 seconds, what are the car's average acceleration and the required average thrust?",
    "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;",
    "step": "【step1】: Perform an INNER JOIN between 'cars' and 'performance_metrics' tables using the shared 'Car_ID' field to link vehicle specifications with performance data.  【step2】: Apply a WHERE clause to filter results for the specific vehicle with 'Car_ID = 1'.  【step3】: Extract the 'Weight' (kg) and 'Acceleration_0_to_100' (seconds) values from the joined tables to calculate average acceleration (using *a = Δv/Δt*) and average thrust (using *F = m·a*).",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 382,
    "question": "An automobile manufacturer with ID 1 produces three car models with annual sales of 5,000, 7,000, and 9,000 units, and average selling prices of $30,000, $40,000, and $50,000, respectively. Calculate the manufacturer's total annual revenue and the average price per car sold.",
    "query": "SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue, SUM(Annual_Sales) AS Total_Sales, SUM(Annual_Sales * Average_Price) / SUM(Annual_Sales) AS Average_Price_Per_Car FROM manufacturers WHERE Manufacturer_ID = 1;",
    "step": "【step1】: Filter the target manufacturer by Manufacturer_ID=1 from the manufacturers table to isolate relevant sales data  【step2】: Calculate Total_Revenue by multiplying Annual_Sales and Average_Price for all models under this manufacturer, then sum the results  【step3】: Compute Average_Price_Per_Car using summed values through (Total_Revenue / Total_Sales) formula, ensuring correct aggregate calculation order",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 383,
    "question": "A car has a fuel tank capacity of 60L, with an urban fuel efficiency of 10km/L and a highway fuel efficiency of 15km/L. If the car owner drove 200km in the city and 200km on the highway, how much fuel did the car consume in total?",
    "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve the car's fuel efficiency data from the 'cars' table using the given query to obtain Fuel_Efficiency_City (10 km/L) and Fuel_Efficiency_Highway (15 km/L).  【step2】: Calculate city fuel consumption: 200 km ÷ 10 km/L = 20 L.  【step3】: Calculate highway fuel consumption: 200 km ÷ 15 km/L ≈13.33 L, then sum both values: 20 L + 13.33 L = 33.33 L total fuel consumed.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 384,
    "question": "If a car's engine has a maximum RPM of 10,000 and a cylinder count of 4, with each cylinder burning 100 times per minute at maximum RPM, calculate the total combustion per minute and per hour for the engine at maximum RPM.",
    "query": "SELECT Max_RPM, Cylinder_Count FROM engine_specs WHERE Car_ID = 1;",
    "step": "【step1】: Retrieve Cylinder_Count from engine_specs table for Car_ID=1  【step2】: Calculate total combustion per minute: Cylinder_Count × 100  【step3】: Calculate total combustion per hour: total_per_minute × 60",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 385,
    "question": "If a car weighs 1500kg and its 0-100 acceleration time is 8 seconds, what is the average power generated during the acceleration process?",
    "query": "SELECT (0.5 * Weight * POWER(27.78, 2)) / Acceleration_0_to_100 AS Average_Power FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;",
    "step": "【step1】: Perform INNER JOIN between `cars` and `performance_metrics` tables using `Car_ID` to merge car weight and acceleration data.  【step2】: Apply WHERE clause to filter records where `Weight`=1500kg and `Acceleration_0_to_100`=8 seconds.  【step3】: Calculate kinetic energy formula `(0.5 * Weight * POWER(27.78, 2)) / Acceleration_0_to_100` to derive average power in watts.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 386,
    "question": "If a car with ID 1 has a fuel tank capacity of 50L, with urban fuel consumption of 8L/100km and highway fuel consumption of 6L/100km, how many kilometers will the car travel before the tank becomes empty, respectively, in urban and highway conditions?",
    "query": "SELECT cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_City / 100) AS City_Distance, cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_Highway / 100) AS Highway_Distance FROM cars JOIN engine_specs ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Car_ID = 1;",
    "step": "【step1】: Perform INNER JOIN between cars and engine_specs tables using Car_ID to access fuel consumption data  【step2】: Filter the combined dataset using WHERE cars.Car_ID = 1 to select specific vehicle  【step3】: Calculate City_Distance by dividing Fuel_Tank_Capacity by (Fuel_Consumption_City/100), and Highway_Distance using (Fuel_Consumption_Highway/100) to convert L/100km unit to distance coverage",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 387,
    "question": "If a car has a cargo capacity of 500 liters and its trunk capacity is 300 liters, what is the maximum cargo weight it can carry?",
    "query": "SELECT Cargo_Capacity * 1 AS Max_Cargo_Weight FROM dimensions WHERE Cargo_Capacity = 500 AND Trunk_Capacity = 300;",
    "step": "【step1】: Filter records in dimensions table where Cargo_Capacity equals 500L and Trunk_Capacity equals 300L  【step2】: Multiply Cargo_Capacity by 1 (assuming 1L cargo volume = 1kg weight conversion) to calculate Max_Cargo_Weight  【step3】: Output the calculated Max_Cargo_Weight value directly from the filtered record",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 388,
    "question": "If a car has an engine displacement of 2.0L, a maximum speed of 8000 RPM, 4 cylinders, and a compression ratio of 10:1, how many combustion events occur per minute at maximum speed?",
    "query": "SELECT Max_RPM / 2 * Cylinder_Count AS Combustion_Per_Minute FROM engine_specs WHERE Displacement = 2.0 AND Max_RPM = 8000 AND Cylinder_Count = 4 AND Compression_Ratio = 10;",
    "step": "【step1】: Filter engine specifications matching parameters (2.0L displacement, 8000 RPM, 4 cylinders, 10:1 compression ratio)  【step2】: Calculate combustion events per cylinder per minute using Max_RPM/2 (four-stroke engines fire once every 2 revolutions)  【step3】: Multiply by cylinder count to derive total combustion events per minute across all cylinders",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 389,
    "question": "A vehicle with a curb weight of 1200 kg, a braking distance of 36 meters, a brake assist response time of 0.2 seconds, and an engine torque of 250 Nm is braking from 100 km/h to a complete stop. With a recovery efficiency of 60% and uniform deceleration during braking, calculate the maximum electrical energy that can be stored by the regenerative braking system.",
    "query": "SELECT c.Weight, pm.Braking_Distance, sf.Brake_Assist_Response_Time, es.Torque FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID JOIN safety_features sf ON c.Car_ID = sf.Car_ID JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Car_ID = 1;",
    "step": "【step1】: Retrieve base vehicle data from 'cars' table by filtering Car_ID=1  【step2】: Join with 'performance_metrics' using Car_ID to access Braking_Distance  【step3】: Join with 'safety_features' and 'engine_specs' via Car_ID to obtain Brake_Assist_Response_Time and Torque",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 390,
    "question": "A hybrid vehicle has a fuel tank capacity of 45L, a battery capacity of 18kWh, an electric-only range of 80km, and a fuel range of 600km. If the user has a total weekly commute of 840km (120km daily), with 40% on urban roads and 60% on highways, calculate the minimum number of times they need to refuel and recharge per week.",
    "query": "SELECT c.Fuel_Tank_Capacity, c.Battery_Capacity, pm.Range_Hybrid, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;",
    "step": "【step1】: Join the 'cars' and 'performance_metrics' tables using Car_ID to combine technical specifications and range data.  【step2】: Apply the WHERE clause to filter results for Car_ID = 1, targeting the specific hybrid vehicle.  【step3】: Select the required columns (Fuel_Tank_Capacity, Battery_Capacity, Range_Hybrid, Range_Electric) to retrieve core parameters for calculation.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 391,
    "question": "An MPV has 7 seats, with a standard trunk capacity of 500L and a maximum expanded capacity of 1800L. When transporting 20 boxes measuring 0.6m × 0.4m × 0.3m each, how should the seating layout be adjusted to optimize loading?",
    "query": "SELECT c.Seating_Capacity, d.Trunk_Capacity, d.Cargo_Capacity FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID WHERE c.Car_ID = 1;",
    "step": "【step1】: JOIN cars and dimensions tables using Car_ID to access seating and cargo data  【step2】: Filter records for specific vehicle (Car_ID=1) using WHERE clause  【step3】: Select critical capacity metrics - Seating_Capacity, Trunk_Capacity, Cargo_Capacity",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 392,
    "question": "A certain car has a maximum engine speed of 9000 RPM, with 8 cylinders, and a fuel tank capacity of 70 liters. If it continuously travels at its top speed (with a fuel consumption of 45 liters per 100 km under these conditions), calculate how many fuel tanker trucks are needed to support its journey across the Taklamakan Desert (approximately 1000 km in length).",
    "query": "SELECT es.Max_RPM, es.Cylinder_Count, c.Fuel_Tank_Capacity, es.Fuel_Consumption_Highway FROM engine_specs es JOIN cars c ON es.Car_ID=c.Car_ID JOIN performance_metrics pm ON c.Car_ID=pm.Car_ID WHERE c.Car_ID=123;",
    "step": "【step1】: Filter the cars table to retrieve fuel tank capacity for car ID 123  【step2】: Join engine_specs to get max RPM, cylinder count, and highway fuel consumption  【step3】: Join performance_metrics (though unused in SELECT) to maintain query structure alignment",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 393,
    "question": "When a certain car with ID 123 is traveling at its top speed under maximum power, what is the total resistance that the engine's traction force needs to overcome?",
    "query": "SELECT e.Horsepower, p.Top_Speed, d.Length, d.Width, d.Curb_Weight FROM engine_specs e JOIN performance_metrics p ON e.Car_ID = p.Car_ID JOIN dimensions d ON e.Car_ID = d.Car_ID WHERE e.Car_ID = 123;",
    "step": "【step1】: Join engine_specs with performance_metrics using Car_ID to link horsepower and top_speed  【step2】: Join result with dimensions table via Car_ID to obtain vehicle physical parameters  【step3】: Filter combined data by Car_ID=123 to retrieve specific vehicle's resistance-related metrics",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 394,
    "question": "What is the proportion of the total profit of the top 5 best-selling car models by a manufacturer to the manufacturer's annual profit?",
    "query": "SELECT c.Model, c.Production_Volume, p.Total_Price, m.Profit_Margin FROM cars c JOIN prices p ON c.Car_ID = p.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Manufacturer_ID = 123 ORDER BY c.Production_Volume DESC LIMIT 5;",
    "step": "【step1】: Retrieve the manufacturer's total annual profit from the 'manufacturers' table using Profit_Margin and Revenue.  【step2】: Calculate the total profit of the top 5 models by joining 'cars', 'prices', and 'manufacturers', then summing (Production_Volume × Total_Price × Profit_Margin) for the top-ranked models.  【step3】: Divide the top 5 models' total profit by the manufacturer's total annual profit to get the percentage.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 395,
    "question": "After a conventional fuel-powered car's tank is fully filled, what is the maximum number of hours it can sustain continuous driving on a highway, given the car's fuel tank capacity and highway fuel efficiency?",
    "query": "SELECT c.Fuel_Tank_Capacity, c.Fuel_Efficiency_Highway FROM cars c WHERE c.Car_ID = 123;",
    "step": "",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 396,
    "question": "What is the braking distance for the car with Car_ID 123, given its airbag count and curb weight?",
    "query": "SELECT s.Airbag_Count, d.Curb_Weight, p.Braking_Distance FROM safety_features s JOIN dimensions d ON s.Car_ID = d.Car_ID JOIN performance_metrics p ON s.Car_ID = p.Car_ID WHERE s.Car_ID = 123;",
    "step": "【step1】: Retrieve the car's airbag count from the safety_features table for Car_ID=123.  【step2】: Join with dimensions table via Car_ID to get curb_weight.  【step3】: Join with performance_metrics table via Car_ID to fetch braking_distance.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 397,
    "question": "If a car weighs 1500kg and its 0-100 acceleration time is 8 seconds, what is its weight and 0-100 acceleration time?",
    "query": "SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;",
    "step": "【step1】: JOIN the `cars` table with `performance_metrics` using `Car_ID` to link the vehicle's basic information and performance data.  【step2】: Filter the results using `WHERE` to match entries where `Weight` is 1500 kg and `Acceleration_0_to_100` is 8 seconds.  【step3】: Select the specific columns `Weight` and `Acceleration_0_to_100` from the joined tables to retrieve the required data.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 398,
    "question": "A car manufacturer has a total production quantity of 500,000 vehicles, annual sales of 450,000 vehicles, R&D expenditures of $200 million, and a profit margin of 8%. Calculate the manufacturer's revenue, total profit, and the average R&D cost per vehicle.",
    "query": "SELECT Production_Volume_Total, Annual_Sales, `R&D_Spending`, Profit_Margin FROM manufacturers WHERE Production_Volume_Total = 500000 AND Annual_Sales = 450000 AND `R&D_Spending` = 200000000 AND Profit_Margin = 8;",
    "step": "【step1】: Filter the manufacturers table to find the record matching the given criteria (Production_Volume_Total=500000, Annual_Sales=450000, R&D_Spending=200000000, Profit_Margin=8%) using the WHERE clause.  【step2】: Calculate Total Revenue by multiplying Annual_Sales with Average_Price from the filtered record.  【step3】: Compute Total Profit as Total_Revenue × (Profit_Margin/100) and Average R&D Cost per vehicle as R&D_Spending ÷ Production_Volume_Total using arithmetic operations.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 399,
    "question": "A car has a fuel tank capacity of 60L, with a city fuel efficiency of 10km/L and a highway fuel efficiency of 15km/L. If the owner drives 200km in the city and 200km on the highway, how much fuel is consumed in total?",
    "query": "SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Fuel_Tank_Capacity = 60 AND Fuel_Efficiency_City = 10 AND Fuel_Efficiency_Highway = 15;",
    "step": "【step1】:【Filter cars with specified fuel parameters】 SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Fuel_Tank_Capacity = 60 AND Fuel_Efficiency_City = 10 AND Fuel_Efficiency_Highway = 15  【step2】:【Calculate fuel consumption components】 SELECT (200 / Fuel_Efficiency_City) AS City_Consumption, (200 / Fuel_Efficiency_Highway) AS Highway_Consumption FROM filtered_cars  【step3】:【Sum total fuel consumption】 SELECT City_Consumption + Highway_Consumption AS Total_Fuel_Used FROM consumption_components",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 400,
    "question": "If a car's engine has a maximum RPM of 10000 and a torque of 500 Nm, running continuously at maximum RPM for 1 hour, what is the total mechanical energy output?",
    "query": "SELECT Max_RPM, Torque FROM engine_specs WHERE Max_RPM = 10000 AND Torque = 500;",
    "step": "【step1】: Access the 'engine_specs' table to retrieve engine performance data.  【step2】: Apply the filter condition `WHERE Max_RPM = 10000 AND Torque = 500` to isolate the specific engine configuration.  【step3】: Select the `Max_RPM` and `Torque` fields from the filtered records for energy calculation.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 401,
    "question": "A car has a top speed of 240 km/h and a curb weight of 1800 kg. If it comes to a complete stop during emergency braking, what is the amount of kinetic energy reduction in joules?",
    "query": "SELECT ROUND(0.5 * d.Curb_Weight * POWER(p.Top_Speed/3.6, 2)) AS KineticEnergy_J FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID WHERE p.Top_Speed = 240 AND d.Curb_Weight = 1800;",
    "step": "【step1】: JOIN performance_metrics and dimensions tables via Car_ID to combine vehicle speed and weight data  【step2】: Filter records where Top_Speed=240 km/h AND Curb_Weight=1800 kg  【step3】: Calculate kinetic energy reduction using formula: ROUND(0.5 × mass × (speed_in_m/s)^2) with unit conversions (km/h→m/s via ÷3.6)",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 402,
    "question": "A manufacturer produces 100,000 cars with an average selling price of $35,000 and a profit margin of 15%. If research and development expenses account for 15% of the revenue, what is the actual net profit?",
    "query": "SELECT (m.Production_Volume_Total * m.Average_Price * 0.85 * m.Profit_Margin/100) AS NetProfit FROM manufacturers m WHERE m.Name = '某制造商' AND m.Production_Volume_Total = 100000 AND m.Average_Price = 35000;",
    "step": "【step1】: Filter the manufacturer's record with specified production volume and price  【step2】: Calculate gross revenue (100,000 × $35,000)  【step3】: Deduct 15% R&D spending and apply 8% profit margin to derive net profit: (Gross Revenue × 0.85 × 0.08)",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 403,
    "question": "The ABS efficiency of a certain car is 95%, and its base braking distance is 40 meters. How much will the actual braking distance increase in meters when accounting for a 30% reduction in road friction?",
    "query": "SELECT s.ABS_Effectiveness, p.Braking_Distance, ROUND((p.Braking_Distance/(s.ABS_Effectiveness/100) * 1.3) - p.Braking_Distance, 1) AS RainIncrease_m FROM safety_features s JOIN performance_metrics p USING(Car_ID) WHERE s.ABS_Effectiveness = 95 AND p.Braking_Distance = 40;",
    "step": "【step1】: Perform JOIN operation between safety_features and performance_metrics tables using Car_ID to combine ABS effectiveness and braking distance data  【step2】: Apply WHERE clause to filter records where ABS_Effectiveness = 95% AND Braking_Distance = 40 meters  【step3】: Calculate increased braking distance using formula: (Base_Distance/(ABS_Efficiency/100)*1.3) - Base_Distance, then round result to 1 decimal place",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 404,
    "question": "If an engine has a displacement of 100L with 16 cylinders, and runs at 6000 revolutions per minute, what is its theoretical hourly fuel consumption in liters? (Each cycle consumes 1.2 times the displacement of fuel.)",
    "query": "SELECT e.Displacement, e.Cylinder_Count, (e.Displacement * e.Max_RPM * e.Cylinder_Count * 1.2 * 60)/1000 AS TheoreticalFuel_L_h FROM engine_specs e WHERE e.Displacement = 100 AND e.Cylinder_Count = 16 AND e.Max_RPM = 6000;",
    "step": "【step1】: Filter engine_specs records where Displacement=100L, Cylinder_Count=16, and Max_RPM=6000  【step2】: Calculate fuel consumption per engine cycle: (Displacement × 1.2) for all cylinders  【step3】: Multiply by RPM cycles per minute and convert to hourly liters: (result × Cylinder_Count × Max_RPM × 60)/1000",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 405,
    "question": "The top speed of a certain car is 210 km/h, with a curb weight of 1500 kg. When traveling at high speed, it has a drag coefficient of 0.28, a frontal area of 2.3 m², and an air density of 1.225 kg/m³. Calculate the power required to overcome air resistance to maintain this speed?",
    "query": "SELECT  (0.5 * 1.225 * pm.Drag_Coefficient * 2.3 * POWER((pm.Top_Speed*1000/3600),3)) AS Air_Power FROM performance_metrics pm JOIN dimensions d ON pm.Car_ID = d.Car_ID WHERE pm.Top_Speed = 210 AND d.Curb_Weight = 1500 AND pm.Drag_Coefficient = 0.28 LIMIT 1;",
    "step": "【step1】: Filter performance_metrics and dimensions tables to find the car with Top_Speed=210km/h, Curb_Weight=1500kg, and Drag_Coefficient=0.28  【step2】: Join the filtered tables using Car_ID to combine required parameters  【step3】: Calculate air resistance power using formula 0.5*ρ*Cd*A*v³, converting speed units from km/h to m/s and applying cubic power",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 406,
    "question": "A manufacturer produces cars with an average weight of 1800 kg. When a fleet of 500 of these models travels at a constant speed of 120 km/h, with a rolling resistance coefficient of 0.015, air density of 1.225 kg/m³, drag coefficient of 0.3, and frontal area of 2.5 m², calculate the total energy consumed (in joules) by the fleet after continuously traveling 100 kilometers?",
    "query": "SELECT   ( (1800*9.8*0.015 + 0.5*1.225*0.3*2.5*POWER(120/3.6,2)) * 100000 ) * 500 AS Total_Energy FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = '某制造商' GROUP BY m.Name LIMIT 1;",
    "step": "【step1】: Join the `dimensions`, `cars`, and `manufacturers` tables to filter vehicles from the specified manufacturer.  【step2】: Calculate energy per vehicle using the formula: `(weight×gravity×rolling_coeff + 0.5×air_density×drag_coeff×frontal_area×velocity²) × distance`, then multiply by 500 vehicles.  【step3】: Aggregate and return the total energy by grouping on the manufacturer name, enforcing a single result with `LIMIT 1`.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 407,
    "question": "A fuel car has a fuel tank capacity of 60L, with a highway fuel consumption of 6.5L/100km. When the fuel gauge shows 15% remaining, what is the maximum distance it can continue to travel on a highway?",
    "query": "SELECT  (c.Fuel_Tank_Capacity*0.15 / es.Fuel_Consumption_Highway)*100 AS Remaining_Range FROM cars c JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Fuel_Tank_Capacity = 60 AND es.Fuel_Consumption_Highway = 6.5 AND c.Battery_Capacity IS NULL LIMIT 1;",
    "step": "【step1】: JOIN cars and engine_specs tables using Car_ID to combine vehicle configuration and fuel consumption data  【step2】: Filter records matching Fuel_Tank_Capacity=60L, Fuel_Consumption_Highway=6.5L/100km, and Battery_Capacity IS NULL to isolate gasoline-powered vehicles  【step3】: Calculate remaining range using formula (60*0.15/6.5)*100 and return single result with LIMIT 1",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 408,
    "question": "If the battery capacity of an electric vehicle is 99999 kWh, with the curb weight remaining at 2000 kg, a drag coefficient of 0.21, and an energy consumption of 15 kWh per 100 km, how many theoretical laps around the equator (which has a circumference of 40075 km) can it complete?",
    "query": "SELECT  (99999/(15/100))/40075 AS Theoretical_Laps FROM cars c JOIN dimensions d ON c.Car_ID = d.Car_ID JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Battery_Capacity IS NOT NULL AND d.Curb_Weight = 2000 AND pm.Drag_Coefficient = 0.21 LIMIT 1;",
    "step": "【step1】: Join the 'cars', 'dimensions', and 'performance_metrics' tables using Car_ID to link vehicle specifications, filtering records where Battery_Capacity is not NULL, Curb_Weight equals 2000kg, and Drag_Coefficient equals 0.21.  【step2】: Calculate total theoretical range using formula: (99999 kWh capacity) / (15 kWh/100km consumption) = total range in kilometers.  【step3】: Divide the total range by Earth's equatorial circumference (40075 km) to get laps, and output the result as Theoretical_Laps with LIMIT 1 constraint.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 409,
    "question": "What is the kinetic energy of a certain fuel-powered vehicle when traveling at its top speed? This requires calculating based on the vehicle's curb weight and top speed, and the query only considers vehicles with a displacement above 0 and highway fuel consumption above 0.",
    "query": "SELECT d.Curb_Weight, p.Top_Speed, 0.5 * d.Curb_Weight * POWER((p.Top_Speed/3.6),2) AS Kinetic_Energy_J FROM dimensions d JOIN performance_metrics p ON d.Car_ID = p.Car_ID JOIN engine_specs e ON d.Car_ID = e.Car_ID WHERE e.Displacement > 0 AND e.Fuel_Consumption_Highway > 0;",
    "step": "【step1】: Join the dimensions table with performance_metrics using Car_ID to access curb weight and top speed values.  【step2】: Further join engine_specs using Car_ID to filter vehicles with displacement > 0 and fuel consumption data (indicating fuel-powered engines).  【step3】: Calculate kinetic energy using the formula 0.5 * Curb_Weight * (Top_Speed converted to m/s)^2 and return results.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 410,
    "question": "Calculate the total cost of ownership over five years for a vehicle model, taking into account the base price, annual maintenance costs, depreciation rate, and insurance expenses, while also considering the impact of tax rates.",
    "query": "SELECT pr.Base_Price, pr.Maintenance_Cost, pr.Depreciation_Rate, pr.Insurance_Cost, pr.Tax_Rate, (pr.Total_Price*(1+pr.Tax_Rate/100)) + (pr.Maintenance_Cost*5) + (pr.Base_Price*(1-POWER(1-pr.Depreciation_Rate/100,5))) - pr.Insurance_Cost AS Total_5yr_Cost FROM prices pr JOIN cars c ON pr.Car_ID = c.Car_ID WHERE c.Range IS NOT NULL;",
    "step": "【step1】: Join the `prices` table with the `cars` table using `Car_ID` to retrieve pricing data and vehicle specifications.  【step2】: Filter results where `Range` is not null to focus on electric/hybrid vehicles.  【step3】: Calculate the 5-year total ownership cost by combining taxed total price, cumulative maintenance costs, depreciation-adjusted base price, and subtracting insurance costs.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 411,
    "question": "What is the maximum distance in kilometers that a full tank of fuel allows a car to travel under pure urban road conditions, given the car's fuel tank capacity and city fuel consumption?",
    "query": "SELECT c.Model, c.Fuel_Tank_Capacity, e.Fuel_Consumption_City, (c.Fuel_Tank_Capacity * (100 / e.Fuel_Consumption_City)) AS City_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity > 0 AND e.Fuel_Consumption_City > 0;",
    "step": "【step1】: Perform INNER JOIN between cars and engine_specs tables using Car_ID to combine fuel capacity and consumption data  【step2】: Filter records where Fuel_Tank_Capacity > 0 AND Fuel_Consumption_City > 0 to ensure valid calculation inputs  【step3】: Calculate City_Range by multiplying Fuel_Tank_Capacity with (100 / Fuel_Consumption_City) to convert consumption (L/100km) to range (km)",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 412,
    "question": "A certain vehicle is equipped with at least a 2.0L displacement engine but has at most a 2L fuel tank, with a high-speed fuel consumption of at least 50L/100km. How many meters can it continuously drive at full fuel?",
    "query": "SELECT c.Model, e.Displacement, c.Fuel_Tank_Capacity, e.Fuel_Consumption_Highway, (c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway) * 100000 AS Absurd_Range_m FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE e.Displacement >= 20 AND c.Fuel_Tank_Capacity <= 2 AND e.Fuel_Consumption_Highway >= 50;",
    "step": "【step1】: JOIN cars and engine_specs tables using Car_ID to combine vehicle data with engine specifications.  【step2】: Apply WHERE conditions (Displacement ≥ 20L, Fuel_Tank_Capacity ≤ 2L, Fuel_Consumption_Highway ≥ 50L/100km) to filter absurd parameter mismatches.  【step3】: Calculate range by (Fuel_Tank_Capacity / Fuel_Consumption_Highway) * 100000 (unit conversion from 100km to meters) and select output fields.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 413,
    "question": "The engine torque of a certain car model is 450 Nm, the curb weight is 1500 kg, and the electronic stability control system efficiency is 95%. Calculate the theoretical acceleration of the vehicle during full-throttle acceleration.",
    "query": "SELECT (e.Torque * (s.ESC_Effectiveness / 100)) / (d.Curb_Weight * 0.3) AS Acceleration FROM engine_specs e JOIN dimensions d ON e.Car_ID = d.Car_ID JOIN safety_features s ON e.Car_ID = s.Car_ID WHERE e.Torque = 450 AND d.Curb_Weight = 1500 AND s.ESC_Effectiveness = 95",
    "step": "【step1】: Join three tables (engine_specs, dimensions, safety_features) using Car_ID to access torque, curb weight, and ESC effectiveness data  【step2】: Filter records where engine torque equals 450 Nm, curb weight equals 1500 kg, and ESC effectiveness equals 95%  【step3】: Calculate acceleration using formula (Torque × ESC_efficiency%) / (Curb_weight × wheel_radius) with unit conversions applied",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 414,
    "question": "The car's urban fuel consumption is 8 L/100km, highway fuel consumption is 6 L/100km, and fuel tank capacity is 60 L. The crash test rating is 4.5 points (out of 5), and the proportion of city driving is 60% plus 10% for every point above 0, with 4.5 points used in the calculation. Calculate its combined fuel consumption and maximum range.",
    "query": "SELECT (8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1))) AS Combined_Fuel, 60 / ((8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1)))/100) AS `Range`;",
    "step": "【step1】: Retrieve base parameters by joining relevant tables: `engine_specs.Fuel_Consumption_City`, `engine_specs.Fuel_Consumption_Highway`, `safety_features.Crash_Test_Rating`, and `cars.Fuel_Tank_Capacity` via `Car_ID`  【step2】: Calculate urban driving ratio adjustment: `0.6 + (Crash_Test_Rating/5)*0.1`  【step3】: Compute final metrics using derived ratio:  - `Combined_Fuel = (Urban_Fuel * Adjusted_Ratio) + (Highway_Fuel * (1 - Adjusted_Ratio))`  - `Range = Fuel_Tank_Capacity / (Combined_Fuel/100)`",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 415,
    "question": "Is there a correlation between the number of airbags and the crash test rating across all car models?",
    "query": "SELECT (SUM(Airbag_Count * Crash_Test_Rating) - (SUM(Airbag_Count) * SUM(Crash_Test_Rating)) / COUNT(*)) / (COUNT(*) * (SUM(Airbag_Count * Airbag_Count) - POW(SUM(Airbag_Count),2)/COUNT(*))) AS Correlation FROM safety_features",
    "step": "【step1】: Calculate covariance between Airbag_Count and Crash_Test_Rating using formula: SUM(Airbag_Count * Crash_Test_Rating) - (SUM(Airbag_Count) * SUM(Crash_Test_Rating)) / COUNT(*)  【step2】: Compute variance of Airbag_Count using formula: COUNT(*) * (SUM(Airbag_Count * Airbag_Count) - POW(SUM(Airbag_Count),2)/COUNT(*))  【step3】: Divide covariance by Airbag_Count variance to calculate correlation coefficient, which measures linear relationship strength but cannot confirm causation or exclusivity of factors.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 416,
    "question": "A car has an engine horsepower of 100,000 HP and a curb weight of 1 kg. Calculate its power-to-weight ratio and estimate the 0-100 km/h acceleration time (ignoring air resistance and friction).",
    "query": "SELECT e.Horsepower / d.Curb_Weight AS Power_Ratio, (100/3.6) / ((e.Horsepower / d.Curb_Weight) * 745.7 / (100/3.6)) AS Acceleration_Time FROM engine_specs e JOIN dimensions d USING(Car_ID) WHERE e.Horsepower = 100000 AND d.Curb_Weight = 1",
    "step": "【step1】: JOIN engine_specs and dimensions tables via Car_ID to combine horsepower and curb weight data  【step2】: Filter records where horsepower equals 100000 HP and curb weight equals 1 kg  【step3】: Calculate power-to-weight ratio (Horsepower/Curb_Weight) and derive acceleration time using kinematic formula (velocity divided by acceleration derived from power-to-weight ratio converted to watts/kg)",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 417,
    "question": "For a Tesla Model S, what is the air resistance in newtons that the vehicle needs to overcome when it reaches its top speed?",
    "query": "SELECT    p.Top_Speed,   d.Width,   d.Height,   0.5 * 1.225 * p.Drag_Coefficient * (d.Width * d.Height) * POWER(p.Top_Speed/3.6, 2) AS Air_Resistance_Newtons FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID JOIN cars c ON p.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' AND c.Model = 'Tesla Model S'",
    "step": "【step1】: Join manufacturers, cars, performance_metrics and dimensions tables to filter records where manufacturer name and model match specifications.  【step2】: Retrieve necessary calculation parameters: Top_Speed, Drag_Coefficient from performance_metrics, Width and Height from dimensions.  【step3】: Apply air resistance formula: 0.5 * air density (1.225 kg/m³) * drag coefficient * frontal area (width×height) * (speed in m/s)². Convert km/h to m/s via ÷3.6.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 418,
    "question": "Calculate the total annual carbon emissions in tonnes for Tesla's vehicle models.",
    "query": "SELECT    SUM(e.CO2_Emissions * m.Annual_Sales * 15000 / 1000000) AS Total_CO2_Tonnes FROM manufacturers m JOIN cars c ON m.Manufacturer_ID = c.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE m.Name = 'Tesla'",
    "step": "【step1】: Filter manufacturers by name and join with cars to get all vehicle models under the specified manufacturer.  【step2】: Join the result with engine_specs to obtain CO2 emissions data per vehicle.  【step3】: Sum the product of CO2 emissions (g/km), annual sales, and average annual driving distance (15,000 km), then convert to tonnes by dividing by 1,000,000.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 419,
    "question": "Can a Tesla Model S pass a bridge with a weight limit of 2.5 tons when fully loaded?",
    "query": "SELECT    d.Curb_Weight,   d.Cargo_Capacity,   (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) AS Total_Weight,   CASE WHEN (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) <= 2500 THEN '安全' ELSE 'overweight' END AS Safety_Status FROM dimensions d JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S'",
    "step": "【step1】: Join cars and dimensions tables to retrieve weight-related data for the specified SUV model  【step2】: Calculate total weight using formula: Curb_Weight + 350kg (passengers/luggage) + (Cargo_Capacity * 0.7kg/L conversion)  【step3】: Compare total weight against 2500kg threshold and generate safety status using CASE statement",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 420,
    "question": "Does the Tesla Model S's G-force exceed 3G when its power-to-weight ratio is 10 times the norm?",
    "query": "SELECT    p.Power_to_Weight_Ratio,   c.Weight,   (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) AS G_Force,   CASE WHEN (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) > 3 THEN '超过' ELSE '未超过' END AS Comparison FROM performance_metrics p JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S'",
    "step": "【step1】: Join `performance_metrics` and `cars` tables via `Car_ID`, filter for `c.Model = '指定跑车型号'` to isolate the target car.  【step2】: Calculate the G-force using the formula `(Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * Weight)`, where 745.7 converts horsepower to watts and 9.8 represents gravitational acceleration.  【step3】: Apply a `CASE` statement to classify results as \"超过\" (exceeds) or \"未超过\" (does not exceed) based on whether the calculated G-force surpasses 3G.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 421,
    "question": "Calculate whether the horsepower of a Tesla Model S's engine, when traveling at its top speed on a highway, is sufficient to overcome air resistance, given an air density of 1.225 kg/m³, a drag coefficient of 0.3, and a frontal area of 2.5 m² for the car.",
    "query": "SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Tesla Model S';",
    "step": "【step1】: Filter cars table to retrieve target model's Car_ID and join performance_metrics to get Top_Speed  【step2】: Join engine_specs to obtain Horsepower value for the selected Car_ID  【step3】: Calculate air resistance using physics formula with Top_Speed (converted to m/s), fixed air density (1.225), drag coefficient (0.3), and frontal area (2.5)",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 422,
    "question": "Calculate the average fuel efficiency of all cars from Tesla and identify the top three models with the highest fuel efficiency.",
    "query": "SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;",
    "step": "【step1】: Join cars and manufacturers tables to filter vehicles from the specified manufacturer.  【step2】: Calculate average fuel efficiency using (Fuel_Efficiency_City + Fuel_Efficiency_Highway)/2 and sort results in descending order.  【step3】: Limit output to top 3 models with the highest average fuel efficiency using ORDER BY and LIMIT clauses.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 423,
    "question": "Estimate the per-kilometer fuel cost of the Tesla Model S in city and highway driving, with the fuel price at $1.2 per liter.",
    "query": "SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = '某款汽车';",
    "step": "【step1】: Access the 'cars' table and filter records where Model is '某款汽车' using WHERE clause  【step2】: Calculate City_Cost_Per_KM via (1 / Fuel_Efficiency_City) * 1.2 and Highway_Cost_Per_KM via (1 / Fuel_Efficiency_Highway) * 1.2 in SELECT clause  【step3】: Project Model, City_Cost_Per_KM, and Highway_Cost_Per_KM as final output",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 424,
    "question": "If the battery capacity of a Tesla Model S is increased to 1000 kWh, calculate whether its range will exceed 10,000 km, given an energy consumption of 0.2 kWh per kilometer.",
    "query": "SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = '某款汽车';",
    "step": "【step1】: Filter the '某款汽车' record from the cars table using WHERE c.Model = 'Tesla Model S'.  【step2】: Calculate the theoretical range by dividing the hypothetical battery capacity (1000 kWh) by the energy consumption per km (0.2 kWh/km) with 1000 / 0.2 AS Theoretical_Range.  【step3】: Output the Model and the calculated Theoretical_Range to verify if it exceeds 10,000 km (the result will be 5,000 km, so no).",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 425,
    "question": "Calculate the rolling resistance for the Tesla Model S using the formula 0.015 multiplied by its weight multiplied by 9.81, and compare it with the engine torque to determine if the torque is sufficient to overcome the rolling resistance.",
    "query": "SELECT c.Model, e.Torque, (0.015 * c.Weight * 9.81) AS Rolling_Resistance FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = '某款汽车';",
    "step": "【step1】: Perform an INNER JOIN between `cars` and `engine_specs` tables using `Car_ID` to combine vehicle specifications with engine torque data.  【step2】: Apply a WHERE filter to select only the row where `Model` equals '某款汽车', narrowing the dataset to the specific vehicle.  【step3】: Calculate the rolling resistance value `(0.015 * Weight * 9.81)` and project the result alongside the engine torque for direct comparison of torque vs. resistance.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 426,
    "question": "Calculate the average carbon dioxide emissions of Tesla cars and identify the top three models with the lowest emissions.",
    "query": "SELECT c.Model, AVG(e.CO2_Emissions) AS Avg_CO2_Emissions FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' GROUP BY c.Model ORDER BY Avg_CO2_Emissions ASC LIMIT 3;",
    "step": "【step1】: Join cars, engine_specs, and manufacturers tables using Car_ID and Manufacturer_ID to link CO2 emissions data with specific models and manufacturer info.  【step2】: Filter by 'Tesla', calculate average CO2 emissions per model via GROUP BY c.Model, and compute AVG(e.CO2_Emissions).  【step3】: Sort results by Avg_CO2_Emissions in ascending order and apply LIMIT 3 to retrieve the top 3 lowest-emitting models.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 427,
    "question": "Estimate the per-kilometer carbon dioxide emissions of a Tesla Model S in urban and highway conditions based on the car's fuel efficiency, with each liter of fuel producing 2.31 kg of carbon dioxide.",
    "query": "SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 2.31 AS City_CO2_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 2.31 AS Highway_CO2_Per_KM FROM cars c WHERE c.Model = '某款汽车';",
    "step": "【step1】:【Filter the 'cars' table to find the specific model '某款汽车' using WHERE clause】  【step2】:【Calculate CO2 emissions per kilometer by inverting fuel efficiency values (km/L) to get L/km, then multiplying by 2.31 kg/L (City_CO2_Per_KM and Highway_CO2_Per_KM)】",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 428,
    "question": "If the battery capacity of a Tesla Model S increases to 5000 kWh, calculate whether its range will exceed 50,000 km, with an energy consumption of 0.1 kWh per kilometer.",
    "query": "SELECT c.Model, 5000 / 0.1 AS Theoretical_Range FROM cars c WHERE c.Model = '某款汽车';",
    "step": "【step1】: Filter the cars table to retrieve the target model using `WHERE c.Model = '某款汽车'`.  【step2】: Calculate the theoretical range by dividing the hypothetical battery capacity (5000 kWh) by the energy consumption per kilometer (0.1 kWh/km) via `5000 / 0.1`.  【step3】: Return the model name and the computed theoretical range to verify if it exceeds 50,000 km.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 429,
    "question": "Calculate the total fuel consumption of a certain car for 100 kilometers driven on city roads and 100 kilometers driven on highways.",
    "query": "SELECT Car_ID, Model, (100 / Fuel_Efficiency_City) + (100 / Fuel_Efficiency_Highway) AS Total_Fuel_Consumption FROM cars;",
    "step": "【step1】: Retrieve vehicle identifiers and efficiency metrics from the cars table  【step2】: Calculate city fuel consumption using (100 / Fuel_Efficiency_City)  【step3】: Calculate highway fuel consumption using (100 / Fuel_Efficiency_Highway) and sum both values as Total_Fuel_Consumption",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 430,
    "question": "Calculate the ratio of the gross weight to the curb weight for each car model, and identify the top 5 car models with the highest ratio.",
    "query": "SELECT d.Car_ID, c.Model, d.Gross_Weight / d.Curb_Weight AS Weight_Ratio FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID ORDER BY Weight_Ratio DESC LIMIT 5;",
    "step": "【step1】: Join 'dimensions' and 'cars' tables using Car_ID to combine weight attributes with car model information.  【step2】: Calculate Gross_Weight/Curb_Weight ratio as Weight_Ratio for each car.  【step3】: Sort results by Weight_Ratio in descending order and limit to the top 5 records.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 431,
    "question": "Find the top 10 cars with the highest average fuel efficiency among all cars produced in 2020, sorted by average fuel efficiency in descending order.",
    "query": "SELECT Car_ID, Model, (Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars WHERE Year = 2020 ORDER BY Avg_Fuel_Efficiency DESC LIMIT 10;",
    "step": "【step1】: Filter cars produced in 2020 using WHERE Year = 2020  【step2】: Calculate average fuel efficiency using (Fuel_Efficiency_City + Fuel_Efficiency_Highway)/2  【step3】: Sort results by Avg_Fuel_Efficiency DESC and limit to top 10 records",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 432,
    "question": "If the fuel tank capacity of a certain car is 1,000 liters and its urban fuel efficiency is 1 km/L, what is the amount of fuel required for the car to travel 10,000 kilometers in the city?",
    "query": "SELECT Car_ID, Model, 10000 / 1 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 1;",
    "step": "【step1】: Filter cars table to find vehicles with Fuel_Tank_Capacity=1000L and Fuel_Efficiency_City=1 km/L using WHERE clause  【step2】: Calculate required fuel by performing division operation 10000 / Fuel_Efficiency_City (implicitly 10000/1)  【step3】: Project Car_ID, Model, and calculated Required_Fuel column through SELECT clause",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "1",
    "idx": 433,
    "question": "Calculate the power-to-weight ratio (HP/kg) of cars and identify the top 5 car models with the highest power-to-weight ratio.",
    "query": "SELECT p.Car_ID, c.Model, p.Power_to_Weight_Ratio FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID ORDER BY p.Power_to_Weight_Ratio DESC LIMIT 5;",
    "step": "【step1】: Join the `performance_metrics` table with the `cars` table using `Car_ID` to combine car models with their power-to-weight ratios.  【step2】: Order the results by `Power_to_Weight_Ratio` in descending order to prioritize higher values.  【step3】: Limit the output to the top 5 records using `LIMIT 5` to fulfill the \"highest\" requirement.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "2",
    "idx": 434,
    "question": "Calculate the carbon dioxide emissions of each car model after driving 100 kilometers in urban conditions and 100 kilometers in highway conditions.",
    "query": "SELECT e.Car_ID, c.Model, (e.Fuel_Consumption_City * 100 / 100) * e.CO2_Emissions + (e.Fuel_Consumption_Highway * 100 / 100) * e.CO2_Emissions AS Total_CO2_Emissions FROM engine_specs e JOIN cars c ON e.Car_ID = c.Car_ID;",
    "step": "【step1】: Perform an INNER JOIN between `engine_specs` and `cars` tables using `Car_ID` to link engine specifications with car model information.  【step2】: Calculate CO₂ emissions for 100km city driving (`Fuel_Consumption_City * CO2_Emissions`) and 100km highway driving (`Fuel_Consumption_Highway * CO2_Emissions`).  【step3】: Sum the two calculated values to produce the final `Total_CO2_Emissions` for the combined 200km distance.",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "3",
    "idx": 435,
    "question": "Find the top 10 cars produced in 2020 with the highest number of airbags, sorted in descending order by the number of airbags.",
    "query": "SELECT s.Car_ID, c.Model, s.Airbag_Count FROM safety_features s JOIN cars c ON s.Car_ID = c.Car_ID WHERE c.Year = 2020 ORDER BY s.Airbag_Count DESC LIMIT 10;",
    "step": "【step1】: Perform INNER JOIN between 'safety_features' and 'cars' tables using Car_ID to combine safety data with vehicle production year  【step2】: Apply WHERE clause to filter records where cars.Year = 2020  【step3】: Execute ORDER BY Airbag_Count DESC with LIMIT 10 to retrieve top 10 results",
    "format": "MySQL"
  },
  {
    "db_id": "car",
    "type": "4",
    "idx": 436,
    "question": "If a car has a fuel tank capacity of 1000 liters and its urban fuel efficiency is 0.5 km/L, what is the required amount of fuel for the car to travel 10,000 kilometers in the city?",
    "query": "SELECT Car_ID, Model, 10000 / 0.5 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 0.5;",
    "step": "【step1】: Filter cars with Fuel_Tank_Capacity = 1000L and Fuel_Efficiency_City = 0.5 km/L using the WHERE clause.  【step2】: Calculate Required_Fuel by dividing 10000 km by Fuel_Efficiency_City (0.5 km/L), resulting in 20,000 liters.  【step3】: Return Car_ID, Model, and the computed Required_Fuel for the matched vehicles.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 437,
    "question": "Calculate the theoretical maximum power output for all solar energy devices, and sort the results in ascending order by device name.",
    "query": "SELECT deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = solar ORDER BY deviceName ASC;",
    "step": "【step1】: Filter solar devices from EnergyDevices table using WHERE deviceType = solar  【step2】: Calculate theoreticalMaxOutput by multiplying powerRating with efficiency then dividing by 100  【step3】: Sort results in ascending order by deviceName using ORDER BY clause",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 438,
    "question": "Find the total energy savings for each device over the past year, sorted in descending order by the amount of energy saved, and take the top 5.",
    "query": "SELECT deviceId, SUM(energySaved) AS totalEnergySaved FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId ORDER BY totalEnergySaved DESC LIMIT 5;",
    "step": "【step1】: Filter records from EnergyEfficiency table where timestamp falls within the past year using WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)  【step2】: Group filtered records by deviceId and calculate total energy saved using SUM(energySaved) with GROUP BY deviceId  【step3】: Sort results by totalEnergySaved in descending order and select top 5 entries using ORDER BY totalEnergySaved DESC LIMIT 5",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 439,
    "question": "Find all currently operating devices where the last maintenance date is more than one year ago, and sort them in ascending order by device name.",
    "query": "SELECT deviceId, deviceName, lastMaintenanceDate FROM EnergyDevices WHERE status = 'operating' AND lastMaintenanceDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) ORDER BY deviceName ASC;",
    "step": "【step1】: Filter records from EnergyDevices where status is 'operating' to focus on active devices.  【step2】: Apply date condition (lastMaintenanceDate older than 1 year) to identify overdue maintenance devices.  【step3】: Sort results by deviceName in ascending order to organize the output alphabetically.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 440,
    "question": "Assuming all devices suddenly achieve 100% efficiency, what are the device IDs, device names, and total energy saved per year for the top 10 devices ranked by total energy saved in descending order?",
    "query": "SELECT deviceId, deviceName, (powerRating * 24 * 365) AS totalEnergySaved FROM EnergyDevices ORDER BY totalEnergySaved DESC LIMIT 10;",
    "step": "【step1】: Retrieve deviceId, deviceName, and powerRating from the EnergyDevices table.  【step2】: Calculate the theoretical annual energy saving (totalEnergySaved) for each device using the formula: powerRating * 24 hours/day * 365 days/year.  【step3】: Sort the results by totalEnergySaved in descending order and limit the output to the top 10 entries.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 441,
    "question": "Calculate the total energy generated by solar devices produced by SolarTech based on their power rating, efficiency, and actual energy consumed.",
    "query": "SELECT SUM(ed.powerRating * ed.efficiency / 100 * ec.energyConsumed) AS totalEnergyGenerated FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE m.manufacturerName = '制造商A' AND ed.deviceType = 'solar';",
    "step": "【step1】: Join EnergyDevices with Manufacturers and EnergyConsumption tables using manufacturerId and deviceId to link device specifications, manufacturer details, and consumption data.  【step2】: Apply filters for manufacturerName = '制造商A' and deviceType = 'solar' to isolate relevant solar panels under standard test conditions.  【step3】: Aggregate results by calculating SUM(ed.powerRating * ed.efficiency / 100 * ec.energyConsumed) to compute total energy generated at maximum efficiency.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 442,
    "question": "Find the average energy consumption of wind turbines produced by manufacturer B over the past year and calculate its difference in energy consumption compared to those produced by manufacturer C.",
    "query": "WITH ManufacturerB_Consumption AS (SELECT AVG(ec.energyConsumed) AS avg_energy_consumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'B' AND ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)), ManufacturerC_Consumption AS (SELECT AVG(ec.energyConsumed) AS avg_energy_consumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'C' AND ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)) SELECT (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) AS avg_energy_consumed_B, (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS avg_energy_consumed_C, (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) - (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS energy_consumption_difference;",
    "step": "【step1】: Calculate the average energy consumption for Manufacturer B's wind turbines over the past year by joining EnergyConsumption, EnergyDevices, and Manufacturers tables, filtering for 'B', 'wind', and timestamp within 1 year.  【step2】: Repeat step 1 for Manufacturer C using the same logic but filtering for 'C' instead of 'B'.  【step3】: Extract the calculated averages from both CTEs (ManufacturerB_Consumption and ManufacturerC_Consumption) and compute their difference in the final SELECT statement.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 443,
    "question": "Determine the difference in average energy consumption between winter and summer for fossil fuel equipment produced by Manufacturer D, including the specific values for winter average, summer average, and their difference.",
    "query": "SELECT winter.avg_winter_consumption AS Winter_Avg_Consumption, summer.avg_summer_consumption AS Summer_Avg_Consumption, (winter.avg_winter_consumption - summer.avg_summer_consumption) AS Consumption_Difference FROM (SELECT AVG(ec.energyConsumed) AS avg_winter_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND MONTH(ec.timestamp) IN (12, 1, 2)) AS winter, (SELECT AVG(ec.energyConsumed) AS avg_summer_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND MONTH(ec.timestamp) IN (6, 7, 8)) AS summer;",
    "step": "【step1】: Calculate winter average consumption - Join EnergyConsumption, EnergyDevices, and Manufacturers tables to filter records from manufacturer D's fossil fuel devices during winter months (Dec, Jan, Feb), then compute AVG(energyConsumed).  【step2】: Calculate summer average consumption - Repeat the same join logic for summer months (Jun, Jul, Aug) to compute AVG(energyConsumed) separately.  【step3】: Compare seasonal averages - Combine the two subquery results in the FROM clause, then calculate the numerical difference between winter and summer averages in the final projection.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 444,
    "question": "Assuming that WindPower's annual revenue suddenly increases to 1,000,000 yuan, calculate what its annual profit would be if it maintains the current profit margin.",
    "query": "WITH CurrentProfitMargin AS (SELECT (profit / revenue) * 100 AS profitMargin FROM Manufacturers WHERE manufacturerName = '制造商E'), FutureProfit AS (SELECT 1000000 * (profitMargin / 100) AS futureProfit FROM CurrentProfitMargin) SELECT futureProfit FROM FutureProfit;",
    "step": "【step1】: Retrieve the current profit margin of 'Manufacturer E' from the Manufacturers table by calculating **(profit / revenue) * 100**.  【step2】: Multiply the new annual revenue (100 billion) by the profit margin obtained in Step 1 to derive the projected future profit.  【step3】: The query returns the calculated future profit value, but sustainability analysis requires external factors (e.g., cost trends, market constraints) not covered in the provided database schema.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 445,
    "question": "Calculate the total energy consumption and power factor for device '1' during the year 2023, along with its average power usage, voltage, and current.",
    "query": "WITH DeviceConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.powerUsage) AS avgPowerUsage, AVG(ec.voltage) AS avgVoltage, AVG(ec.current) AS avgCurrent FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT dc.deviceId, dc.totalEnergyConsumed, dc.avgPowerUsage, dc.avgVoltage, dc.avgCurrent, (dc.avgPowerUsage / (dc.avgVoltage * dc.avgCurrent)) AS powerFactor FROM DeviceConsumption dc WHERE dc.deviceId = '1';",
    "step": "【step1】: Filter and aggregate data from EnergyConsumption table for the specified time period, grouping by deviceId to calculate total energy consumed and average power usage, voltage, and current.  【step2】: Compute the power factor for each device using the formula (avgPowerUsage / (avgVoltage * avgCurrent)) in the main query.  【step3】: Apply a WHERE clause to filter results for the specific deviceId, finalizing the output for targeted analysis.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 446,
    "question": "Calculate the total energy consumption of all devices over the past year, grouped by device type, and identify the device type with the highest energy consumption.",
    "query": "SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;",
    "step": "【step1】: Filter the EnergyConsumption records from the past year using WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR).  【step2】: Join EnergyConsumption with EnergyDevices via deviceId to map consumption data to device types.  【step3】: Group results by deviceType, calculate total energy consumed with SUM(), order descending by totalEnergyConsumed, and select the top result with LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 447,
    "question": "Analyze the energy consumption changes of equipment under the highest and lowest humidity levels and identify the impact patterns of humidity on energy consumption by calculating the rate of change between these extremes.",
    "query": "SELECT hc.deviceId, ed.deviceName, hc.highHumidityEnergy, hc.lowHumidityEnergy, (hc.highHumidityEnergy - hc.lowHumidityEnergy) / hc.lowHumidityEnergy * 100 AS energyChangeRate FROM (SELECT deviceId, MAX(CASE WHEN humidity = (SELECT MAX(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS highHumidityEnergy, MAX(CASE WHEN humidity = (SELECT MIN(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS lowHumidityEnergy FROM (SELECT deviceId, humidity, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption GROUP BY deviceId, humidity) AS he GROUP BY deviceId) AS hc JOIN EnergyDevices ed ON hc.deviceId = ed.deviceId;",
    "step": "【step1】: Calculate average energy consumption grouped by device and humidity from EnergyConsumption table using subquery he  【step2】: Extract max/min humidity's energy values per device via correlated subqueries and CASE statements in hc subquery  【step3】: Join with EnergyDevices to get names and calculate percentage change between high/low humidity energy consumption",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 448,
    "question": "Assuming the power of a certain device suddenly increases to 10 times its rated power, calculate its energy consumption under extreme conditions and analyze its impact on the power grid for device ID 11.",
    "query": "WITH ExtremePower AS (SELECT deviceId, deviceName, powerRating * 10 AS extremePower, powerRating FROM EnergyDevices WHERE deviceId = 11), ExtremeEnergyConsumption AS (SELECT ep.deviceId, ep.deviceName, ep.extremePower, ep.powerRating, ec.timestamp, ec.energyConsumed, ec.powerUsage, ec.voltage, ec.current, ec.temperature, ec.humidity, ec.dataQuality, ep.extremePower * (ec.timestamp - LAG(ec.timestamp) OVER (PARTITION BY ec.deviceId ORDER BY ec.timestamp)) / 3600 AS extremeEnergyConsumed FROM EnergyConsumption ec JOIN ExtremePower ep ON ec.deviceId = ep.deviceId) SELECT eec.deviceId, eec.deviceName, eec.extremePower, eec.powerRating, eec.timestamp, eec.energyConsumed, eec.powerUsage, eec.voltage, eec.current, eec.temperature, eec.humidity, eec.dataQuality, eec.extremeEnergyConsumed, eec.extremeEnergyConsumed / 100 AS gridImpact FROM ExtremeEnergyConsumption eec;",
    "step": "【step1】: Calculate 10x rated power for deviceID 11 using CTE ExtremePower, joining EnergyDevices to get base powerRating.  【step2】: Compute time-diff energy consumption using LAG window function in ExtremeEnergyConsumption CTE, joining EnergyConsumption data to calculate extremeEnergyConsumed = extremePower * time_diff_in_hours.  【step3】: Final SELECT calculates grid impact (extremeEnergyConsumed/100) and returns all fields with extreme power metrics and impact analysis.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 449,
    "question": "Calculate the total carbon emissions of each device during the specific time period, and identify the device with the highest carbon emissions.",
    "query": "WITH DeviceCarbonFootprint AS (SELECT ec.deviceId, SUM(ec.energyConsumed * ef.carbonFootprint) AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ef ON ec.deviceId = ef.deviceId AND ec.timestamp = ef.timestamp WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT dcf.deviceId, ed.deviceName, dcf.totalCarbonEmission FROM DeviceCarbonFootprint dcf JOIN EnergyDevices ed ON dcf.deviceId = ed.deviceId ORDER BY dcf.totalCarbonEmission DESC LIMIT 1;",
    "step": "【step1】: Calculate total carbon emission per device by joining EnergyConsumption and EnvironmentalImpact tables, multiplying energyConsumed by carbonFootprint, and aggregating within the specified time range.  【step2】: Enrich results by joining with EnergyDevices table to obtain deviceName through deviceId association.  【step3】: Sort devices by totalCarbonEmission in descending order and select the highest-emission device using LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 450,
    "question": "Calculate the average energy efficiency of all equipment over the past year and identify the equipment with efficiency below this average.",
    "query": "SELECT ae.deviceId, ae.avgEfficiency FROM (SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId) AS ae JOIN (SELECT AVG(efficiency) AS overallAvgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)) AS oa WHERE ae.avgEfficiency < oa.overallAvgEfficiency;",
    "step": "【step1】: Calculate the average efficiency for each device over the past year using a subquery (aliased as \"ae\") that groups EnergyEfficiency data by deviceId and filters records with timestamp in the last year.  【step2】: Compute the overall average efficiency across all devices in the same period via a separate subquery (aliased as \"oa\").  【step3】: Join the two subqueries and filter devices where the device-specific average efficiency (ae.avgEfficiency) is lower than the overall average (oa.overallAvgEfficiency).",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 451,
    "question": "Find equipment that has not undergone maintenance in the past year and list the detailed information of these devices.",
    "query": "SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.powerRating, ed.efficiency, ed.installationDate, ed.status, ed.location, ed.manufacturerId, ed.lastMaintenanceDate, ed.nextMaintenanceDate FROM EnergyDevices ed WHERE ed.deviceId NOT IN (SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR))",
    "step": "【step1】: Retrieve device IDs from MaintenanceRecords that had maintenance in the past year using a subquery: `SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)`.  【step2】: Filter EnergyDevices by excluding devices found in Step 1 using `NOT IN` clause.  【step3】: Select required fields from EnergyDevices where the deviceId does not appear in the subquery results, ensuring only non-maintained devices are listed.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 452,
    "question": "Assuming a device's environmental impact suddenly increases to 100 times its normal value, calculate its impact on the environment and identify the most affected environmental indicator.",
    "query": "DROP TEMPORARY TABLE IF EXISTS NormalImpact; DROP TEMPORARY TABLE IF EXISTS ExtremeImpact; CREATE TEMPORARY TABLE NormalImpact AS SELECT deviceId, AVG(carbonFootprint) AS avgCarbonFootprint, AVG(pollutionLevel) AS avgPollutionLevel, AVG(waterUsage) AS avgWaterUsage, AVG(landUsage) AS avgLandUsage FROM EnvironmentalImpact GROUP BY deviceId; CREATE TEMPORARY TABLE ExtremeImpact AS SELECT deviceId, avgCarbonFootprint * 100 AS extremeCarbonFootprint, avgPollutionLevel * 100 AS extremePollutionLevel, avgWaterUsage * 100 AS extremeWaterUsage, avgLandUsage * 100 AS extremeLandUsage FROM NormalImpact; SELECT deviceId, CASE WHEN extremeCarbonFootprint = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'carbonFootprint' WHEN extremePollutionLevel = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'pollutionLevel' WHEN extremeWaterUsage = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'waterUsage' WHEN extremeLandUsage = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'landUsage' END AS maxImpactIndicator, GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) AS maxImpactValue FROM ExtremeImpact; DROP TEMPORARY TABLE IF EXISTS NormalImpact; DROP TEMPORARY TABLE IF EXISTS ExtremeImpact;",
    "step": "【step1】: Create temporary table NormalImpact by calculating average environmental metrics (carbonFootprint, pollutionLevel, waterUsage, landUsage) per device from EnvironmentalImpact table using GROUP BY deviceId.  【step2】: Create temporary table ExtremeImpact by multiplying NormalImpact's metrics by 100 to simulate 100x energy consumption surge.  【step3】: Compare scaled metrics in ExtremeImpact using GREATEST() and CASE statements to identify the maximum impacted environmental indicator per device.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 453,
    "question": "Calculate the actual output power of solar devices and identify the top 5 devices with the highest actual output power.",
    "query": "SELECT deviceId, deviceName, powerRating * efficiency / 100 AS P_actual FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY P_actual DESC LIMIT 5;",
    "step": "【step1】: Filter devices of type 'solar' from EnergyDevices table using WHERE clause  【step2】: Calculate actual power output (P_actual) by multiplying powerRating with efficiency then dividing by 100  【step3】: Sort results by P_actual in descending order and retrieve top 5 devices using ORDER BY and LIMIT",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 454,
    "question": "Calculate the total energy cost savings for each device over the past year, sort them in descending order by savings, and identify the top 10 devices with the highest savings.",
    "query": "SELECT ed.deviceId, ed.deviceName, SUM(ee.energySaved) * 0.5 AS total_cost_savings FROM EnergyEfficiency ee JOIN EnergyDevices ed ON ee.deviceId = ed.deviceId WHERE ee.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceName ORDER BY total_cost_savings DESC LIMIT 10;",
    "step": "【step1】: Join EnergyEfficiency and EnergyDevices tables using deviceId, filter records from the past year using WHERE ee.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR).  【step2】: Aggregate energy savings per device using GROUP BY ed.deviceId, calculate total_cost_savings as SUM(ee.energySaved)*0.5.  【step3】: Sort results by total_cost_savings in descending order and limit output to top 10 devices using ORDER BY + LIMIT.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 455,
    "question": "Find all devices with efficiency below the target efficiency, sort them in ascending order of efficiency, and identify the 10 least efficient devices.",
    "query": "SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency FROM EnergyDevices ed JOIN EnergyPolicies ep ON ed.efficiency < ep.targetEfficiency ORDER BY ed.efficiency ASC LIMIT 10;",
    "step": "【step1】: Perform an inner join between EnergyDevices and EnergyPolicies tables using the condition where device efficiency is less than policy target efficiency.  【step2】: Sort the combined results by device efficiency in ascending order.  【step3】: Apply LIMIT 10 to retrieve the 10 devices with the lowest efficiency values.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 456,
    "question": "Assuming the efficiency of all equipment is 100%, calculate the actual output power of each device and identify the top 5 devices with the highest actual output power.",
    "query": "SELECT deviceId, deviceName, powerRating * 1.0 AS P_actual FROM EnergyDevices ORDER BY P_actual DESC LIMIT 5;",
    "step": "【step1】: Retrieve deviceId, deviceName, and calculate theoretical maximum output power (P_actual) by multiplying powerRating by 1.0 (100% efficiency assumption) from EnergyDevices table.  【step2】: Sort results in descending order based on P_actual to prioritize highest output devices.  【step3】: Apply LIMIT 5 to filter the top 5 devices with maximum theoretical output power.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 457,
    "question": "Calculate the total energy consumption of each device during the specified time period and identify the device with the highest total energy consumption.",
    "query": "SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY TotalEnergyConsumed DESC LIMIT 1;",
    "step": "【step1】: Join EnergyConsumption and EnergyDevices tables using deviceId to associate consumption data with device names.  【step2】: Filter records by the 2023 timestamp range, calculate total energy consumed per device using SUM(), and group results by deviceId/deviceName.  【step3】: Order results in descending order by TotalEnergyConsumed and select the top record using LIMIT 1 to identify the highest-consuming device.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 458,
    "question": "Calculate the total and average energy consumption for each device type over the past year.",
    "query": "SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= NOW() - INTERVAL 1 YEAR GROUP BY ed.deviceType;",
    "step": "【step1】: Filter the EnergyConsumption records from the past year using the WHERE clause on timestamp.  【step2】: Join the filtered EnergyConsumption data with EnergyDevices via deviceId to associate each consumption entry with its device type.  【step3】: Group the joined dataset by deviceType and calculate both total (SUM) and average (AVG) energyConsumed for each group.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 459,
    "question": "Find the device with the highest total maintenance cost and show its maintenance frequency and parts replaced list.",
    "query": "WITH MaintenanceCosts AS (SELECT deviceId, SUM(cost) AS totalMaintenanceCost, COUNT(*) AS maintenanceFrequency, GROUP_CONCAT(partsReplaced SEPARATOR ', ') AS partsReplacedList FROM MaintenanceRecords GROUP BY deviceId) SELECT ED.deviceId, ED.deviceName, ED.deviceType, MC.totalMaintenanceCost, MC.maintenanceFrequency, MC.partsReplacedList FROM EnergyDevices ED JOIN MaintenanceCosts MC ON ED.deviceId = MC.deviceId ORDER BY MC.totalMaintenanceCost DESC LIMIT 1;",
    "step": "【step1】: Create a CTE (MaintenanceCosts) to calculate total maintenance cost, maintenance frequency, and concatenated replaced parts list per device from MaintenanceRecords table.  【step2】: Join EnergyDevices table with the CTE to get device details (name/type) alongside maintenance metrics.  【step3】: Sort results by totalMaintenanceCost descending and select the top record to identify the device with highest maintenance cost.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 460,
    "question": "Assuming the power rating of the specified device is 1,000,000 kilowatts, calculate its total energy consumption in one year and analyze its impact on the environment.",
    "query": "WITH DeviceEnergy AS (  SELECT     deviceId,    1000000 AS powerRating,    8760 AS hoursInYear,    1000000 * 8760 AS totalEnergyConsumed  FROM     EnergyDevices  WHERE     deviceId = 12345 ), EnvironmentalImpactAnalysis AS (  SELECT     deviceId,    totalEnergyConsumed,    totalEnergyConsumed * 0.85 AS carbonFootprint,    totalEnergyConsumed * 0.001 AS waterUsage,    totalEnergyConsumed * 0.0001 AS landUsage  FROM     DeviceEnergy ) SELECT   DE.deviceId,  DE.powerRating,  DE.totalEnergyConsumed,  EIA.carbonFootprint,  EIA.waterUsage,  EIA.landUsage FROM   DeviceEnergy DE JOIN   EnvironmentalImpactAnalysis EIA ON   DE.deviceId = EIA.deviceId;",
    "step": "【step1】: Calculate annual energy consumption using hard-coded power rating (1,000,000 kW) and fixed operational hours (8,760 hours/year) for deviceID 12345 from EnergyDevices table.  【step2】: Compute environmental impact metrics (carbon footprint, water usage, land usage) by applying conversion factors to the calculated total energy consumption.  【step3】: Combine energy consumption data with environmental impact analysis through deviceID join between the two CTE results.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 461,
    "question": "Calculate the total energy consumption of each device over the year 2023 and identify the device with the highest energy consumption.",
    "query": "SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;",
    "step": "【step1】: Join EnergyConsumption and EnergyDevices tables using deviceId to combine consumption data with device metadata.  【step2】: Filter records within 2023-01-01 to 2023-12-31, then calculate total energy consumption per device using SUM() and GROUP BY deviceId/deviceName.  【step3】: Sort results by totalEnergyConsumed in descending order and return the top record using ORDER BY and LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 462,
    "question": "Calculate the average efficiency of each device over a specific time period and identify devices with efficiency below the overall average efficiency across all devices.",
    "query": "WITH DeviceEfficiency AS (SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY deviceId), OverallAverageEfficiency AS (SELECT AVG(avgEfficiency) AS overallAvgEfficiency FROM DeviceEfficiency) SELECT de.deviceId, de.avgEfficiency FROM DeviceEfficiency de, OverallAverageEfficiency oae WHERE de.avgEfficiency < oae.overallAvgEfficiency;",
    "step": "【step1】: Calculate the average efficiency per device within the specified timeframe using a CTE (DeviceEfficiency). This filters EnergyEfficiency records between '2023-01-01' and '2023-12-31', grouping by deviceId and computing AVG(efficiency).  【step2】: Compute the global average efficiency across all devices using a second CTE (OverallAverageEfficiency). This aggregates the avgEfficiency values from the DeviceEfficiency CTE.  【step3】: Join the two CTEs and filter devices where avgEfficiency is below the global average. This final SELECT compares device-level averages against the overall threshold.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 463,
    "question": "Find the total energy consumption for devices operating in high-temperature environments (above 30 degrees).",
    "query": "SELECT SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.temperature > 30;",
    "step": "【step1】: Filter all energy consumption records where temperature exceeds 30 from the EnergyConsumption table.  【step2】: Join the filtered EnergyConsumption records with EnergyDevices to ensure device validity via deviceId.  【step3】: Aggregate the energyConsumed values using SUM() to calculate total energy consumption.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 464,
    "question": "Assuming the power rating of the device with ID 123 is 1,000,000 kilowatts, calculate its total energy consumption over a year and determine the related environmental impacts.",
    "query": "WITH DeviceEnergy AS (SELECT deviceId, 1000000 AS powerRating, 8760 AS hoursInYear FROM EnergyDevices WHERE deviceId = 123) SELECT de.deviceId, de.powerRating * de.hoursInYear AS totalEnergyConsumed, ei.carbonFootprint, ei.pollutionLevel, ei.waterUsage, ei.landUsage FROM DeviceEnergy de JOIN EnvironmentalImpact ei ON de.deviceId = ei.deviceId WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = de.deviceId);",
    "step": "【step1】: Create CTE to set hypothetical power rating (1,000,000 kW) and annual hours (8,760) for device ID 123 from EnergyDevices table.  【step2】: Join EnvironmentalImpact table using deviceId, filtering only the latest impact record via subquery (SELECT MAX(timestamp)).  【step3】: Calculate total annual energy consumption (powerRating × hoursInYear) and return environmental metrics (carbonFootprint, pollutionLevel, etc.) from the joined result.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 465,
    "question": "Calculate the average power output of solar devices within the time period from 2023-01-01 to 2023-12-31 and identify the device with the highest average power output.",
    "query": "SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) / (TIMESTAMPDIFF(HOUR, MIN(ec.timestamp), MAX(ec.timestamp))) AS averagePowerOutput FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY averagePowerOutput DESC LIMIT 1;",
    "step": "【step1】: Join EnergyDevices and EnergyConsumption tables on deviceId, filter solar devices and timestamp range  【step2】: Calculate average power output per device using SUM(energyConsumed)/TIMESTAMPDIFF(HOUR) grouped by device  【step3】: Sort results by averagePowerOutput descending and select top record with LIMIT 1",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 466,
    "question": "Calculate the ratio of total energy consumption to total power generation for each wind turbine device, and sort the results in ascending order by the ratio.",
    "query": "SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ef.forecastValue) AS totalEnergyGenerated, (SUM(ec.energyConsumed) / SUM(ef.forecastValue)) AS energyConsumptionToGenerationRatio FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyForecasts ef ON ed.deviceId = ef.deviceId WHERE ed.deviceType = 'wind' AND ef.forecastType = '5000000.00' GROUP BY ed.deviceId, ed.deviceName ORDER BY energyConsumptionToGenerationRatio ASC;",
    "step": "【step1】: Join EnergyDevices with EnergyConsumption and EnergyForecasts on deviceId, filtering for wind energy devices and generation forecasts.  【step2】: Aggregate total energy consumed and generated per device, calculate consumption-to-generation ratio.  【step3】: Sort results by the calculated ratio in ascending order.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 467,
    "question": "Find all devices installed in 2022 that have efficiency below the target efficiency, sorted in descending order of efficiency.",
    "query": "SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency FROM EnergyDevices ed JOIN EnergyPolicies ep ON ed.installationDate >= '2022-01-01' AND ed.installationDate <= '2022-12-31' WHERE ed.efficiency < ep.targetEfficiency ORDER BY ed.efficiency DESC;",
    "step": "【step1】: Join EnergyDevices and EnergyPolicies tables, filtering devices installed in 2022 via the ON clause (ed.installationDate between '2022-01-01' and '2022-12-31').  【step2】: Apply WHERE condition to select devices where actual efficiency (ed.efficiency) is lower than policy target efficiency (ep.targetEfficiency).  【step3】: Sort the final results by ed.efficiency in descending order using ORDER BY.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 468,
    "question": "Assuming the efficiency of all equipment is 100%, calculate the ratio of total energy consumption to total energy generated for each equipment, and sort the results in ascending order by the ratio.",
    "query": "WITH DeviceEfficiency AS (SELECT deviceId, 100 AS efficiency FROM EnergyDevices), TotalEnergy AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed / (de.efficiency / 100.0)) AS totalEnergyGenerated FROM EnergyConsumption ec JOIN DeviceEfficiency de ON ec.deviceId = de.deviceId GROUP BY ec.deviceId) SELECT te.deviceId, (te.totalEnergyConsumed / te.totalEnergyGenerated) AS energyRatio FROM TotalEnergy te ORDER BY energyRatio ASC;",
    "step": "【step1】: Create a CTE named DeviceEfficiency to override all device efficiencies to 100%, ensuring a hypothetical scenario where all devices operate at maximum efficiency.  【step2】: Calculate total energy consumption and generated energy for each device by joining EnergyConsumption with DeviceEfficiency, using the formula *energyConsumed / (efficiency/100)* to derive generated energy. Group results by deviceId.  【step3】: Compute the energy consumption-to-generation ratio for each device from the aggregated data and sort the results in ascending order of this ratio.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 469,
    "question": "Calculate the average efficiency of all solar energy devices and identify the device with the highest efficiency.",
    "query": "WITH SolarDeviceEfficiency AS (SELECT deviceId, efficiency FROM EnergyDevices WHERE deviceType = 'solar') SELECT AVG(efficiency) AS average_efficiency, (SELECT deviceId FROM SolarDeviceEfficiency ORDER BY efficiency DESC LIMIT 1) AS most_efficient_device FROM SolarDeviceEfficiency;",
    "step": "【step1】: Filter solar devices from EnergyDevices table using WHERE deviceType='solar', creating CTE SolarDeviceEfficiency with deviceId and efficiency  【step2】: Calculate average efficiency using AVG(efficiency) on SolarDeviceEfficiency CTE  【step3】: Retrieve most efficient device via subquery (SELECT deviceId FROM SolarDeviceEfficiency ORDER BY efficiency DESC LIMIT 1)",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 470,
    "question": "Calculate the total energy saved by each wind energy device over the past year, sorted in descending order by the amount of energy saved.",
    "query": "SELECT ed.deviceId, ed.deviceName, SUM(ed.powerRating * ed.efficiency * ec.energyConsumed) AS totalEnergySaved FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergySaved DESC;",
    "step": "【step1】: Join EnergyDevices and EnergyConsumption tables using deviceId, filter for wind energy devices and consumption records from the past year  【step2】: Calculate total energy saved per device using formula (powerRating × efficiency × energyConsumed) aggregation  【step3】: Sort results by totalEnergySaved in descending order and finalize device grouping",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 471,
    "question": "Find all devices installed in 2022 and calculate their total energy consumption.",
    "query": "SELECT ed.deviceId, ed.deviceName, ed.powerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE YEAR(ed.installationDate) = 2022 GROUP BY ed.deviceId, ed.deviceName, ed.powerRating;",
    "step": "【step1】: Filter devices installed in 2022 from the EnergyDevices table using WHERE YEAR(installationDate) = 2022.  【step2】: Join the filtered devices with the EnergyConsumption table using deviceId to access all energy consumption records for these devices.  【step3】: Group the joined results by deviceId, deviceName, and powerRating, then calculate the total energy consumption using SUM(energyConsumed).",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 472,
    "question": "Assuming all devices operate at less than 100% efficiency, calculate the energy saved by each device in one year and identify the device that saves the most energy.",
    "query": "WITH DeviceEnergySavings AS (SELECT ed.deviceId, ed.deviceName, ed.powerRating * (100 - ed.efficiency) / 100 * 365 * 24 AS energySaved FROM EnergyDevices ed) SELECT des.deviceId, des.deviceName, des.energySaved FROM DeviceEnergySavings des ORDER BY des.energySaved DESC LIMIT 1;",
    "step": "【step1】: Calculate hypothetical annual energy savings per device when efficiency reaches 100% using formula:  `powerRating * (100 - efficiency)/100 * 365*24` via CTE DeviceEnergySavings.  【step2】: Sort all devices by calculated energy savings in descending order.  【step3】: Retrieve the top-ranked device with maximum energy savings using LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 473,
    "question": "Calculate the theoretical maximum power output for all solar energy devices, sorted by device ID in ascending order.",
    "query": "SELECT deviceId, deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceId ASC;",
    "step": "【step1】: Filter rows from EnergyDevices where deviceType is 'solar' using the WHERE clause.  【step2】: Calculate theoreticalMaxOutput by multiplying powerRating with efficiency and dividing by 100 for the filtered rows.  【step3】: Sort the results by deviceId in ascending order using ORDER BY.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 474,
    "question": "Calculate the total energy consumption for each device over the past year, sorted in descending order by total energy consumption, and take the top 5 devices.",
    "query": "SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption WHERE timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY deviceId ORDER BY totalEnergyConsumed DESC LIMIT 5",
    "step": "【step1】: Filter the EnergyConsumption table to include only records from the past year using the WHERE clause with timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR).  【step2】: Group the filtered records by deviceId and calculate the total energy consumption for each device using SUM(energyConsumed) with GROUP BY deviceId.  【step3】: Sort the aggregated results by totalEnergyConsumed in descending order and limit the output to the top 5 records using ORDER BY and LIMIT.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 475,
    "question": "Find the devices and their maintenance counts, sorted in descending order by the number of maintenance occurrences.",
    "query": "SELECT deviceId, COUNT(maintenanceId) AS maintenanceCount FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenanceCount DESC;",
    "step": "【step1】: Aggregate maintenance records by deviceId and calculate the count of maintenanceId for each device using GROUP BY and COUNT().  【step2】: Sort the aggregated results in descending order based on maintenanceCount using ORDER BY.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 476,
    "question": "Assuming the efficiency of all devices is increased to 100%, calculate the total energy savings these devices would achieve in one year, and sort them in descending order by the amount of energy saved.",
    "query": "SELECT deviceId, SUM(energySaved * (100 / efficiency)) AS totalEnergySaved FROM EnergyEfficiency WHERE efficiency < 100 GROUP BY deviceId ORDER BY totalEnergySaved DESC;",
    "step": "【step1】: Filter devices with efficiency below 100% from EnergyEfficiency table using WHERE efficiency < 100.  【step2】: Calculate potential energy saved by scaling current savings to 100% efficiency via SUM(energySaved * (100 / efficiency)) for each deviceId using GROUP BY.  【step3】: Sort results in descending order of totalEnergySaved with ORDER BY totalEnergySaved DESC.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 477,
    "question": "Calculate the daily energy output in kWh of the solar panel at maximum efficiency, assuming a solar radiation intensity of 1000 watts per square meter, a solar panel area of 2 square meters, an efficiency of 20%, and 24 hours of operation.",
    "query": "SELECT (1000 * 2 * 0.20 * 24) / 1000 AS daily_energy_output_kWh;",
    "step": "【step1】: Collect fixed parameters: Solar radiation intensity (1000W/m²), panel area (2m²), efficiency (20%), and duration (24 hours).  【step2】: Apply formula: (1000 * 2 * 0.20 * 24) to calculate watt-hours, then divide by 1000 for kWh conversion.  【step3】: Output calculated value with alias **daily_energy_output_kWh**.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 478,
    "question": "Calculate the output power of the wind turbine in kilowatts at a wind speed of 12 meters per second, assuming a power coefficient of 0.4 for the wind turbine, an air density of 1.225 kilograms per cubic meter, and a blade radius of 30 meters.",
    "query": "SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(12, 3) * 0.4 / 1000 AS output_power_kw;",
    "step": "【step1】: Calculate the swept area of wind turbine blades using formula: 0.5 * air_density * π * radius² → 0.5*1.225*PI()*POWER(30,2)  【step2】: Compute wind power by multiplying swept area with wind_speed³ → ...*POWER(12,3)  【step3】: Apply power coefficient and convert watts to kilowatts: multiply by 0.4 and divide by 1000 → ...*0.4/1000 AS output_power_kw",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 479,
    "question": "Calculate the total energy consumption and total cost of the equipment over a month based on its rated power and operating time, assuming the equipment runs for 8 hours per day, with an electricity price of 0.5 yuan per kilowatt-hour.",
    "query": "SELECT deviceId, deviceName, powerRating * 8 * 30 AS totalEnergyConsumed, powerRating * 8 * 30 * 0.5 AS totalCost FROM EnergyDevices;",
    "step": "【step1】: Select deviceId and deviceName from EnergyDevices table.  【step2】: Calculate monthly energy consumption using powerRating * 8 hours/day * 30 days as totalEnergyConsumed.  【step3】: Compute total cost by multiplying totalEnergyConsumed by the electricity rate (0.5) as totalCost.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 480,
    "question": "Assuming the blade radius of a wind turbine increases to 1000 meters with a wind speed of 50 meters per second, calculate its output power in kilowatts, given an air density of 1.225 kg/m³, a power coefficient of 0.4, and using the formula for wind power.",
    "query": "SELECT 0.5 * 1.225 * PI() * POWER(1000, 2) * POWER(50, 3) * 0.4 / 1000 AS output_power_kw;",
    "step": "【step1】: Calculate blade area using PI()*POWER(1000,2) to compute rotor swept area  【step2】: Apply wind power formula components: 0.5 * air_density * area * POWER(50,3)  【step3】: Multiply by efficiency (0.4) and convert to kilowatts via division by 1000",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 481,
    "question": "Calculate the average efficiency of all devices produced by SolarTech and identify the devices with efficiency below the average.",
    "query": "WITH ManufacturerDevices AS (SELECT ed.deviceId, ed.efficiency FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), AverageEfficiency AS (SELECT AVG(efficiency) AS avgEfficiency FROM ManufacturerDevices) SELECT md.deviceId, md.efficiency FROM ManufacturerDevices md, AverageEfficiency ae WHERE md.efficiency < ae.avgEfficiency;",
    "step": "【step1】: Filter devices from the specified manufacturer by joining EnergyDevices and Manufacturers tables, selecting deviceId and efficiency.  【step2】: Calculate the average efficiency of these filtered devices using AVG() aggregation.  【step3】: Compare each device's efficiency against the calculated average, returning devices with below-average efficiency through a cross-join between filtered devices and the average value.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 482,
    "question": "Calculate the total energy consumption for each device produced by SolarTech and identify the device with the highest total energy consumption.",
    "query": "WITH ManufacturerDevices AS (SELECT ed.deviceId FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), TotalEnergyConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec WHERE ec.deviceId IN (SELECT deviceId FROM ManufacturerDevices) GROUP BY ec.deviceId) SELECT tec.deviceId, tec.totalEnergyConsumed FROM TotalEnergyConsumption tec ORDER BY tec.totalEnergyConsumed DESC LIMIT 1;",
    "step": "【step1】: [Retrieve all device IDs associated with the specified manufacturer from EnergyDevices and Manufacturers tables using JOIN]  【step2】: [Calculate total energy consumption per device by aggregating energyConsumed values from EnergyConsumption table, filtered using Step1 results]  【step3】: [Sort devices by totalEnergyConsumed in descending order and select the top record with LIMIT 1]",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 483,
    "question": "Find all equipment produced by SolarTech where the maintenance cost is higher than the average maintenance cost for SolarTech equipment.",
    "query": "WITH ManufacturerDevices AS (SELECT ed.deviceId, ed.deviceName, ed.manufacturerId FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), AverageMaintenanceCost AS (SELECT AVG(mr.cost) AS avgCost FROM MaintenanceRecords mr JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId) SELECT md.deviceId, md.deviceName, mr.cost FROM MaintenanceRecords mr JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId CROSS JOIN AverageMaintenanceCost amc WHERE mr.cost > amc.avgCost;",
    "step": "【step1】: Filter devices from 'EnergyDevices' belonging to the specified manufacturer by joining with 'Manufacturers' table, creating a CTE (ManufacturerDevices) with deviceId, deviceName, and manufacturerId.  【step2】: Calculate the average maintenance cost for all devices in ManufacturerDevices by joining with 'MaintenanceRecords', creating a second CTE (AverageMaintenanceCost).  【step3】: Retrieve devices from ManufacturerDevices with maintenance costs (via 'MaintenanceRecords') exceeding the calculated avgCost using a CROSS JOIN to apply the single avgCost value across all rows for comparison.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 484,
    "question": "Assuming the rated power of all devices produced by a certain manufacturer has been converted from kilowatts to watts (multiplied by 1000), calculate the total energy consumption of these devices and identify the device with the highest energy consumption.",
    "query": "WITH IncreasedPower AS (SELECT deviceId, powerRating * 1000 AS increasedPowerRating FROM EnergyDevices WHERE manufacturerId = '1') SELECT ec.deviceId, SUM(ec.energyConsumed * ip.increasedPowerRating) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN IncreasedPower ip ON ec.deviceId = ip.deviceId GROUP BY ec.deviceId ORDER BY totalEnergyConsumed DESC LIMIT 1;",
    "step": "【step1】: Create a CTE named IncreasedPower to calculate the adjusted power rating (powerRating*1000) for all devices of manufacturerId='1' from EnergyDevices  【step2】: Join EnergyConsumption with the CTE on deviceId, calculate total energy consumed by multiplying energyConsumed with increasedPowerRating for each record, then aggregate using SUM() grouped by deviceId  【step3】: Order results by totalEnergyConsumed in descending order and select the top record using LIMIT 1 to find the device with highest energy consumption",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 485,
    "question": "Calculate the total energy consumption and average power usage of device '1' between June 15, 2023 and December 15, 2023.",
    "query": "SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed) / (MAX(ec.timestamp) - MIN(ec.timestamp)) AS averagePowerUsage FROM EnergyConsumption ec WHERE ec.deviceId = '特定设备的deviceId' AND ec.timestamp BETWEEN '开始时间' AND '结束时间' GROUP BY ec.deviceId;",
    "step": "【step1】: Filter records from EnergyConsumption table where deviceId matches the specific device and timestamp falls within the defined time range.  【step2】: Aggregate the filtered data by deviceId, calculate total energy consumed (SUM(energyConsumed)), and determine the time duration (MAX(timestamp) - MIN(timestamp)).  【step3】: Compute average power usage by dividing total energy consumed by the calculated time duration. Return deviceId, totalEnergyConsumed, and averagePowerUsage.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 486,
    "question": "Calculate the total energy consumption of all devices over the past year, grouped by device type, and identify the device type with the highest energy consumption.",
    "query": "SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;",
    "step": "【step1】: Join EnergyConsumption and EnergyDevices tables on deviceId, filter records from the last year using WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR).  【step2】: Group the joined data by deviceType and calculate total energy consumption using SUM(energyConsumed).  【step3】: Order grouped results by totalEnergyConsumed in descending order and select the top result with LIMIT 1.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 487,
    "question": "Analyze the energy consumption differences between high humidity and low humidity conditions and identify the impact of humidity levels on total energy consumption.",
    "query": "SELECT CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END AS humidity_level, SUM(energyConsumed) AS total_energy_consumed FROM EnergyConsumption GROUP BY CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END;",
    "step": "【step1】: Categorize humidity levels using CASE expression to split records into 'high humidity' (>60) and 'low humidity' (≤60).  【step2】: Group records by the calculated humidity_level column.  【step3】: Calculate total energy consumption with SUM(energyConsumed) for each humidity group.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 488,
    "question": "Assuming the power consumption of a certain device suddenly increases to 10 times its recorded power usage, calculate its energy consumption under extreme conditions and analyze its impact on the environment.",
    "query": "WITH TimeDifferences AS ( SELECT deviceId, timestamp, powerUsage, TIMESTAMPDIFF(SECOND, timestamp, LEAD(timestamp) OVER (PARTITION BY deviceId ORDER BY timestamp)) AS timeDiff FROM EnergyConsumption ), ExtremeEnergyConsumption AS ( SELECT deviceId, SUM(powerUsage * 10 * (timeDiff / 3600)) AS extremeEnergyConsumed FROM TimeDifferences WHERE timeDiff IS NOT NULL GROUP BY deviceId ), EnvironmentalImpactAnalysis AS ( SELECT ei.deviceId, SUM(ei.carbonFootprint) AS totalCarbonFootprint FROM EnvironmentalImpact ei JOIN EnergyConsumption ec ON ei.deviceId = ec.deviceId GROUP BY ei.deviceId ) SELECT eec.deviceId, eec.extremeEnergyConsumed, eia.totalCarbonFootprint FROM ExtremeEnergyConsumption eec JOIN EnvironmentalImpactAnalysis eia ON eec.deviceId = eia.deviceId;",
    "step": "【step1】: Calculate time differences between consecutive energy consumption records using window functions. Use LEAD() to get next timestamp for each device, compute interval in seconds with TIMESTAMPDIFF, and filter out NULL intervals.【step2】: Compute extreme energy consumption by multiplying original power usage by 10, convert time intervals to hours, then aggregate total energy per device through SUM(powerUsage * 10 * (timeDiff/3600)) with GROUP BY deviceId.【step3】: Calculate total carbon footprint by joining EnvironmentalImpact with EnergyConsumption tables, aggregate per device, then combine with extreme energy results through deviceId JOIN to produce final environmental impact analysis.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 489,
    "question": "Calculate the total carbon emissions for device ID '1' between January 1, 2023 and December 31, 2023, where emissions are calculated by multiplying total energy consumption by a carbon footprint coefficient.",
    "query": "SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, ei.carbonFootprint AS carbonFootprintCoefficient, SUM(ec.energyConsumed) * ei.carbonFootprint AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ei ON ec.deviceId = ei.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' AND ec.deviceId = '特定设备的deviceId' GROUP BY ec.deviceId, ei.carbonFootprint;",
    "step": "【step1】: Filter energy consumption records for the specific device within the given timestamp range using WHERE clause on EnergyConsumption.  【step2】: Join EnvironmentalImpact table via deviceId to obtain carbon footprint coefficient corresponding to the device.  【step3】: Aggregate filtered data using SUM(energyConsumed), multiply by carbonFootprint coefficient, and return total emissions via GROUP BY and aliasing.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 490,
    "question": "Calculate the average efficiency for each device type over the past year.",
    "query": "WITH DeviceEfficiency AS ( SELECT ed.deviceId, ed.deviceType, AVG(ee.efficiency) AS avgEfficiency FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId WHERE ee.timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceType ) SELECT deviceType, AVG(avgEfficiency) AS avgEfficiencyByType FROM DeviceEfficiency GROUP BY deviceType;",
    "step": "【step1】: Filter EnergyEfficiency data from the past year and join with EnergyDevices to associate each device's efficiency records with its corresponding device type.  【step2】: Calculate the average efficiency for each individual device (grouped by deviceId and deviceType) using the filtered data.  【step3】: Aggregate the per-device average efficiencies by deviceType to determine the overall average efficiency for each device category.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 491,
    "question": "Analyze the energy consumption changes of device '1' under different environmental humidity levels to infer the impact of humidity on energy consumption.",
    "query": "SELECT ec.deviceId, AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) AS high_humidity_energy, AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END) AS low_humidity_energy, (AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) - AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END)) AS energy_change FROM EnergyConsumption ec WHERE ec.deviceId = '1' GROUP BY ec.deviceId;",
    "step": "【step1】: Filter records for specified deviceId in EnergyConsumption table  【step2】: Calculate average energy consumption for high (>70) and low (<30) humidity conditions using conditional CASE statements  【step3】: Compute difference between high/low humidity averages as energy_change metric",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 492,
    "question": "Assuming the carbon footprint coefficient of a certain device is 100 times its normal value, calculate its total carbon emissions within a year and analyze its environmental impact.",
    "query": "WITH AnnualEnergyConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec WHERE ec.timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY ec.deviceId), CarbonFootprintAnalysis AS (SELECT aec.deviceId, aec.totalEnergyConsumed, aec.totalEnergyConsumed * (ei.carbonFootprint * 100) AS totalCarbonEmission, ei.pollutionLevel, ei.waterUsage, ei.landUsage FROM AnnualEnergyConsumption aec JOIN EnvironmentalImpact ei ON aec.deviceId = ei.deviceId WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = aec.deviceId)) SELECT cfa.deviceId, cfa.totalEnergyConsumed, cfa.totalCarbonEmission, cfa.pollutionLevel, cfa.waterUsage, cfa.landUsage, CASE WHEN cfa.totalCarbonEmission > (SELECT AVG(totalCarbonEmission) FROM CarbonFootprintAnalysis) THEN 'High Impact' ELSE 'Normal Impact' END AS environmentalImpact FROM CarbonFootprintAnalysis cfa;",
    "step": "【step1】: Calculate annual energy consumption per device using a CTE by summing energyConsumed from EnergyConsumption table filtered for the past year.  【step2】: Join with EnvironmentalImpact table to calculate amplified carbon emissions (using 100x carbonFootprint) and extract environmental metrics, using the latest impact record per device via subquery.  【step3】: Perform final analysis by comparing each device's carbon emissions against the average using CASE expression in the main query, categorizing environmental impact.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 493,
    "question": "Calculate the total energy consumption and efficiency change for each device over the year 2023.",
    "query": "SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-12-31 23:59:59') - (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-01-01 00:00:00') AS efficiencyChange FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId;",
    "step": "【step1】: Filter and aggregate total energy consumption per device within the specified time range from the EnergyConsumption table.  【step2】: Retrieve efficiency values at the start ('2023-01-01 00:00:00') and end ('2023-12-31 23:59:59') of the period for each device via subqueries on the EnergyEfficiency table.  【step3】: Combine aggregated consumption data with calculated efficiency changes (end efficiency - start efficiency) for final output.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 494,
    "question": "Calculate the total energy savings and total cost savings for all devices over the past year, grouped by device type.",
    "query": "SELECT deviceType, SUM(energySaved) AS totalEnergySaved, SUM(costSavings) AS totalCostSavings FROM EnergyEfficiency JOIN EnergyDevices ON EnergyEfficiency.deviceId = EnergyDevices.deviceId WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceType;",
    "step": "【step1】: Join the EnergyEfficiency and EnergyDevices tables using deviceId to associate efficiency data with device types. Apply a WHERE filter to select records from the past year based on the timestamp field in EnergyEfficiency.  【step2】: Group the filtered results by deviceType from the EnergyDevices table.  【step3】: Calculate the sum of energySaved and costSavings for each deviceType group using aggregation functions.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 495,
    "question": "Analyze the relationship between equipment maintenance frequency and average equipment efficiency.",
    "query": "SELECT MR.deviceId, COUNT(MR.maintenanceDate) AS maintenanceFrequency, AVG(EE.efficiency) AS averageEfficiency FROM MaintenanceRecords MR JOIN EnergyEfficiency EE ON MR.deviceId = EE.deviceId GROUP BY MR.deviceId ORDER BY maintenanceFrequency, averageEfficiency;",
    "step": "【step1】: Join `MaintenanceRecords` (MR) with `EnergyEfficiency` (EE) using `deviceId` to link maintenance events and efficiency data.  【step2】: Group results by `MR.deviceId`, calculate maintenance frequency via `COUNT(MR.maintenanceDate)` and average efficiency via `AVG(EE.efficiency)`.  【step3】: Sort the grouped results first by maintenance frequency and then by average efficiency in ascending order.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 496,
    "question": "Assuming a device with ID 123 improves to 1000% efficiency, calculate its annual energy savings and cost savings, and analyze its environmental impact.",
    "query": "SELECT ed.deviceId, ed.deviceName, ed.deviceType, (ee.energySaved * 10) AS annualEnergySaved, (ee.costSavings * 10) AS annualCostSavings, env.carbonFootprint, env.pollutionLevel FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId JOIN EnvironmentalImpact env ON ed.deviceId = env.deviceId WHERE ed.deviceId = 123;",
    "step": "【step1】: Join EnergyDevices with EnergyEfficiency on deviceId to calculate annual energy/cost savings by multiplying energySaved and costSavings by 10 (assuming 10x efficiency improvement from 1000% increase).  【step2】: Join the result with EnvironmentalImpact on deviceId to incorporate carbonFootprint and pollutionLevel data.  【step3】: Apply WHERE clause filtering for deviceId=123 to isolate calculations and analysis for the specific target device.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "1",
    "idx": 497,
    "question": "Calculate the total energy consumption for each device during the time period from 2023-01-01 to 2023-12-31 and analyze the percentage change in efficiency for each device.",
    "query": "WITH DeviceEnergy AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, MIN(ee.efficiency) AS efficiency_start, MAX(ee.efficiency) AS efficiency_end FROM EnergyConsumption ec JOIN EnergyEfficiency ee ON ec.deviceId = ee.deviceId WHERE ec.timestamp BETWEEN '2023-01-01' AND '2023-12-31' AND ee.timestamp BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY ec.deviceId) SELECT de.deviceId, de.totalEnergyConsumed, (de.efficiency_end - de.efficiency_start) / de.efficiency_start * 100 AS efficiency_change_percentage FROM DeviceEnergy de;",
    "step": "【step1】: Filter and join EnergyConsumption (ec) and EnergyEfficiency (ee) tables by deviceId, limiting data to timestamps between 2023-01-01 and 2023-12-31 for both tables.  【step2】: Aggregate data by deviceId to calculate total energy consumption (SUM), initial efficiency (MIN), and final efficiency (MAX) within the time range.  【step3】: Calculate efficiency change percentage using formula ((efficiency_end - efficiency_start)/efficiency_start * 100) in final output.",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "2",
    "idx": 498,
    "question": "Calculate the average maintenance cost for equipment from the manufacturer 'SolarTech' grouped by device type.",
    "query": "SELECT ed.deviceType, AVG(mr.cost) AS avgMaintenanceCost FROM MaintenanceRecords mr JOIN EnergyDevices ed ON mr.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech' GROUP BY ed.deviceType;",
    "step": "【step1】: Filter the Manufacturers table to find the specific manufacturer's ID using WHERE manufacturerName = 'SolarTech'.  【step2】: Join EnergyDevices with MaintenanceRecords via deviceId, filtered by the manufacturerId from step 1.  【step3】: Group the results by deviceType and calculate the average maintenance cost using AVG(mr.cost).",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "3",
    "idx": 499,
    "question": "Analyze the average energy consumption of device '1' across different humidity ranges (0-30%, 31-60%, 61-90%, 91-100%) and provide energy-saving recommendations.",
    "query": "SELECT humidity_range, AVG(energyConsumed) AS avg_energy_consumed FROM (SELECT CASE WHEN humidity BETWEEN 0 AND 30 THEN '0-30%' WHEN humidity BETWEEN 31 AND 60 THEN '31-60%' WHEN humidity BETWEEN 61 AND 90 THEN '61-90%' ELSE '91-100%' END AS humidity_range, energyConsumed FROM EnergyConsumption WHERE deviceId = '1') AS subquery GROUP BY humidity_range ORDER BY humidity_range;",
    "step": "【step1】: Classify humidity into predefined ranges (0-30%, 31-60%, 61-90%, 91-100%) using CASE WHEN in a subquery, while filtering data for a specific device from EnergyConsumption table.  【step2】: Calculate average energy consumption (AVG(energyConsumed)) for each humidity range using GROUP BY on the derived humidity_range categories.  【step3】: Sort results by humidity_range to show energy consumption progression from low to high humidity, enabling identification of efficiency patterns for targeted节能建议 (e.g., optimize operation in high-humidity ranges where avg_energy_consumed peaks).",
    "format": "MySQL"
  },
  {
    "db_id": "EnergyManagementDB",
    "type": "4",
    "idx": 500,
    "question": "Assuming the power rating of a certain device is 1,000,000 watts, calculate its total energy consumption within one year and its carbon footprint based on the average carbon footprint for devices of that power rating.",
    "query": "WITH DevicePower AS (SELECT 1000000 AS powerRating), TotalEnergyConsumed AS (SELECT powerRating * 24 * 365 AS totalEnergyConsumed FROM DevicePower), EnvironmentalImpact AS (SELECT totalEnergyConsumed * (SELECT AVG(carbonFootprint) FROM EnvironmentalImpact WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE powerRating = 1000000)) AS carbonFootprint FROM TotalEnergyConsumed) SELECT totalEnergyConsumed, carbonFootprint FROM TotalEnergyConsumed, EnvironmentalImpact;",
    "step": "【step1】: Calculate annual energy consumption: Use CTE `DevicePower` to define the device's power rating (1,000,000 kW). Compute total yearly energy by multiplying power rating × 24 hours × 365 days in CTE `TotalEnergyConsumed`.  【step2】: Retrieve carbon footprint coefficient: Query the average `carbonFootprint` from the `EnvironmentalImpact` table for devices with matching `deviceId` (subquery linking `EnergyDevices` where `powerRating` = 1,000,000).  【step3】: Combine results: Multiply total energy consumption by the carbon footprint coefficient in CTE `EnvironmentalImpact`, then output `totalEnergyConsumed` and calculated `carbonFootprint` via cross-joining the two CTEs.",
    "format": "MySQL"
  }
]