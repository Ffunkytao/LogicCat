SELECT Total_Disk_Area * Max_Disk_Loading AS Lift FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	1
SELECT (Max_Gross_Weight * 1.2) / Total_Disk_Area AS New_Max_Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	2
SELECT CASE WHEN Max_disk_Loading * Total_disk_area * 0.75 < Max_Gross_Weight THEN 'Not Suitable' ELSE 'Suitable' END AS Suitability FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	3
SELECT 10000 / Total_Disk_Area AS Extreme_Disk_Loading, 'The aircraft will likely stall or crash due to insufficient lift.' AS Consequence FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	4
SELECT ROUND((International_Passengers * 100.0 / Total_Passengers), 2) AS International_Passenger_Percentage FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Freight_Tonnes / Aircraft_Movements AS Average_Freight_Per_Movement FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	3
SELECT (Total_Passengers * 2 * 20) AS Total_Luggage_Weight, CEIL((Total_Passengers * 2 * 20) / 635) AS Required_Flights FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	4
SELECT (International_Passengers * POWER(1 + 0.015, 5) + Domestic_Passengers * POWER(1 + 0.02, 5) + Transit_Passengers * POWER(1 - 0.005, 5)) AS Total_Passengers_After_5_Years FROM airport WHERE Airport_Name = 'London Heathrow';	AirCraft	2
SELECT CASE WHEN Age + 7 <= 30 THEN 'may maintain the same level of competitive performance' ELSE 'may not maintain the same level of competitive performance' END AS Competitive_Status FROM pilot WHERE Name = 'Prof. Zackery Collina';	AirCraft	3
SELECT Aircraft, Max_Gross_Weight, Total_Disk_Area, Max_Disk_Loading FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT Total_Passengers / (1 + Change_2019 / 100) AS Total_Passengers_2019 FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Domestic_Passengers / 0.80 AS Total_Passengers FROM airport;	AirCraft	3
SELECT Max_Gross_Weight / Total_Disk_Area AS Max_Disk_Loading, Max_Gross_Weight / 10000000 AS Max_Disk_Loading_New FROM aircraft WHERE Max_Gross_Weight = 1000000 AND Total_Disk_Area = 1000000;	AirCraft	4
SELECT Max_Gross_Weight / Total_Disk_Area AS Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	1
SELECT strftime('%Y', 'now') - (Age - 17) AS Earliest_License_Year FROM pilot WHERE Age = 23;	AirCraft	4
SELECT Aircraft, CAST(SUBSTR(Max_Gross_Weight, INSTR(Max_Gross_Weight, '(') + 1, INSTR(Max_Gross_Weight, 'kg') - INSTR(Max_Gross_Weight, '(') - 1) AS REAL) * 9.81 AS Lift_Required FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT SUM(a.Total_Disk_Area) AS Total_Disk_Area, AVG(a.Total_Disk_Area) AS Avg_Disk_Area FROM "match" m JOIN aircraft a ON m.Winning_Aircraft = a.Aircraft_ID WHERE m.Location = 'MiraZayd, Abu Dhabi';	AirCraft	2
SELECT Airport_Name, (International_Passengers * 100.0 / Total_Passengers) AS International_Percentage, CASE WHEN (International_Passengers * 100.0 / Total_Passengers) > 90 THEN 'Yes' ELSE 'No' END AS Exceeds_90_Percent FROM airport WHERE Airport_Name = 'London Heathrow';	AirCraft	3
SELECT Aircraft, (Max_Gross_Weight/Total_Disk_Area) AS Calculated_Loading, Max_Disk_Loading, CASE WHEN (Max_Gross_Weight/Total_Disk_Area) > Max_Disk_Loading THEN 'Exceeded' ELSE 'Within Limit' END FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT (SUM(a.Freight_Tonnes * 1000) / SUM(a.Aircraft_Movements)) / COUNT(DISTINCT aa.Aircraft_ID) FROM airport a JOIN airport_aircraft aa ON a.Airport_ID = aa.Airport_ID WHERE a.Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Total_Passengers, (International_Passengers + Domestic_Passengers + Transit_Passengers) AS Sum_Passengers, CASE WHEN Total_Passengers = International_Passengers + Domestic_Passengers + Transit_Passengers THEN 'Match' ELSE 'Mismatch' END FROM airport;	AirCraft	3
SELECT (600000*9.8)/0.01/101325 AS Atmospheric_Pressure_Multiples;	AirCraft	4
SELECT 0.5*(0.3*Max_Gross_Weight)*POWER(5,2)*POWER((2*3.141592653589793*300/60),2) AS Rotational_Energy FROM aircraft WHERE Aircraft='RobinsonR-22';	AirCraft	1
WITH cte AS (SELECT COUNT(*) AS total, SUM(CASE WHEN p.Age=23 THEN 1 ELSE 0 END) AS wins FROM match m JOIN pilot p ON m.Winning_Pilot = p.Pilot_id WHERE strftime('%Y', m.Date) = '2023') SELECT ROUND(wins*1.0/total,3) AS p_value, ROUND(1.96 * SQRT((wins*1.0/total) * (1 - wins*1.0/total) / total), 3) AS margin FROM cte;	AirCraft	2
SELECT Transit_Passengers / (Aircraft_Movements / 365.0) AS Daily_Transit_Per_Movement FROM airport;	AirCraft	3
SELECT (1e15 * 0.5) / (5.1e14) AS Earth_Surface_Multiples;	AirCraft	4
SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;	AlarmSystem	1
WITH FilteredData AS (     SELECT SeverityLevel      FROM WarningEvent      WHERE SeverityLevel > 8 )  SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold,      AVG(SeverityLevel) - (2.576 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound,      AVG(SeverityLevel) + (2.576 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound  FROM FilteredData;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR PopulationAffected > 1000000 OR EstimatedDamageUSD > 10000000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (RadiusKm * 1000) / 10 AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 50;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 20000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'tornado' AND SeverityLevel = 6;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 50000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 5.0 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'earthquake' AND RadiusKm = 100;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 8000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 0.1 AS SpreadTimeMinutes FROM WarningEvent WHERE EventType = 'fire' AND RadiusKm = 2;	AlarmSystem	1
SELECT AVG(PopulationAffected) AS AveragePopulationAffected FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'typhoon' AND SeverityLevel = 5;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD BETWEEN 3000000.00 AND 7000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageWithinRange FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'earthquake' AND SeverityLevel = 7;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (20 / 0.01) * (1 - EXP(-0.01 * (500 * 1000 / 20))) AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 500;	AlarmSystem	1
WITH FilteredEvents AS (SELECT EstimatedDamageUSD FROM WarningEvent WHERE EstimatedDamageUSD > 1000000000.00) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, SUM(EstimatedDamageUSD) AS TotalDamageAboveThreshold FROM FilteredEvents;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'nuclear leak' AND SeverityLevel = 10;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT ThresholdValue / 10 AS TimeToThresholdHours FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;	AlarmSystem	1
SELECT (COUNT(CASE WHEN ThresholdValue > 8000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningRule;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 1000 AND ActionType = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'nuclear leak' AND ThresholdValue > 100 AND ThresholdUnit = 'millisieverts') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT 100 / 5 AS PropagationTimeSeconds, POWER(10, 1.5 * ThresholdValue + 4.8) AS EarthquakeEnergy FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue = 5.0;	AlarmSystem	1
WITH FilteredRules AS (     SELECT ThresholdValue      FROM WarningRule      WHERE ThresholdValue > 800.0 )  SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningRule)) AS PercentageAboveThreshold,      SUM(ThresholdValue) AS TotalThresholdAbove  FROM FilteredRules;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'tsunami' AND ThresholdValue = 10 AND ActionType = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'volcanic eruption' AND ThresholdValue > 100 AND ThresholdUnit = 'kilometer') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT ThresholdValue AS RequiredRainfall FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;	AlarmSystem	1
SELECT AVG(ThresholdValue) AS AverageThresholdValue FROM WarningRule;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 100 AND ActionType = 'notification';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue > 9.0 AND ThresholdUnit = 'Richter scale') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT TriggerValue / 50 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 1000;	AlarmSystem	1
SELECT (COUNT(CASE WHEN TriggerValue > 80000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningTriggerRecord;	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT LN(TriggerValue / 0.0001) / 0.1 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 5000;	AlarmSystem	1
WITH FilteredRecords AS (     SELECT TriggerValue      FROM WarningTriggerRecord      WHERE TriggerValue > 100000 )  SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningTriggerRecord)) AS PercentageAboveThreshold,      SUM(TriggerValue) AS TotalTriggerValueAbove  FROM FilteredRecords;	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	3
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	4
SELECT TriggerValue / 10 AS RequiredTime FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'millimeters';	AlarmSystem	1
SELECT AVG(TriggerValue) AS AverageTriggerValue FROM WarningTriggerRecord WHERE TriggerValue IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 50 AND TriggerUnit = 'Celsius' AND ActionTaken = 'notification';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount  FROM WarningTriggerRecord  WHERE TriggerValue > 100  AND TriggerUnit = 'millisieverts'  AND TriggerTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (100 * 1000) / POWER(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 80000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'people';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (1000 * 1000) / POWER(3, 8) AS PropagationTime, EXP(-0.001 * 1000) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage, SUM(RecipientCount) AS TotalRecipients FROM WarningNotificationRecord WHERE RecipientCount > 1000000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast' AND RecipientType = 'people';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';	AlarmSystem	4
SELECT (10 * 1000) / POWER(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS';	AlarmSystem	1
SELECT AVG(RecipientCount) AS AverageRecipientCount FROM WarningNotificationRecord WHERE RecipientCount IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'email' AND RecipientType = 'enterprise';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 100000 AND NotificationTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (500 * 1000) / POWER(3, 8) AS PropagationTime, EXP(-0.0005 * 500) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 800000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'government';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (100 * 1000) / 5 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 7;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'earthquake' AND AverageSeverity = 6 AND FalseAlarmRate = 5;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (1000 * 1000) / 200 AS PropagationTime, EXP(-0.01 * 1000) AS EnergyAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'tsunami' AND MaxSeverity = 10;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage, SUM(AverageSeverity) AS TotalAverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'nuclear leak' AND MaxSeverity = 10 AND FalseAlarmRate = 0.1;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';	AlarmSystem	4
SELECT (500 * 1000) / 10 AS DiffusionTime, EXP(-0.005 * ((500 * 1000) / 10)) AS ConcentrationAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'volcanic eruption' AND MaxSeverity = 9;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE MaxSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'tornado' AND MaxSeverity = 8 AND FalseAlarmRate = 2;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (50 * 1000) / 2 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 5;	AlarmSystem	1
SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0);	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 4 AND FalseAlarmRate = 3;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 5 AS PropagationTime FROM WarningEvent WHERE EventType = 'earthquake';	AlarmSystem	1
SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0);	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 3 AND FalseAlarmRate = 1;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (20.0 / (2 * 3.14159 * (SELECT Vibration_Frequency FROM bridge WHERE Name = 'Golden Gate Bridge'))) * ((SELECT Length_Meters FROM bridge WHERE Name = 'Golden Gate Bridge') / 1000.0) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * (SELECT Blade_Length FROM mill WHERE Name = 'Moulin de Bruges') * ((SELECT Rotation_Speed FROM mill WHERE Name = 'Moulin de Bruges') / 60.0) AS Moulin_Tip_Speed;	architect	1
SELECT (Load_Capacity / Length_Meters) AS Avg_Load_Per_Meter, (Power_Output / (0.5 * 1.225 * (3.14159 * (Blade_Length * Blade_Length)) * (Wind_Speed * Wind_Speed * Wind_Speed))) * 100 AS Energy_Efficiency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';	architect	2
SELECT Cost_Usd + (Maintenance_Cost * 100) AS Total_Cost_Millau_Viaduct, (SELECT Cost_Usd + (Maintenance_Cost * 50) FROM mill WHERE Name = 'Moulin de Momalle') AS Total_Cost_Moulin_de_Momalle FROM bridge WHERE Name = 'Millau Viaduct';	architect	3
SELECT (1000 / (2 * 3.14159 * 100)) * (100000 / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * 1000 * (1000 / 60) AS Moulin_Tip_Speed;	architect	4
SELECT 0.5 * 1.225 * POWER(10, 2) * span_length_meters * height_meters AS Wind_Load, 0.5 * (14 * 50) * POWER(2 * 3.14159 * 14 * (20.0 / 60), 2) AS Blade_Kinetic_Energy FROM bridge WHERE name = 'Millau Viaduct';	architect	1
SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM bridge WHERE Name = 'Golden Gate Bridge' UNION ALL SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM mill WHERE Name = 'Moulin de Momalle';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN 'Wooden structures have lower maintenance costs but poorer durability' END AS Maintenance_Analysis FROM bridge WHERE Name = 'Charles Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN 'Wooden structures have lower maintenance costs but poorer durability' END AS Maintenance_Analysis FROM mill WHERE Name = 'Moulin de Fexhe';	architect	3
SELECT 0.5 * 1.225 * POWER(1000, 2) * 100000 * 10000 AS Wind_Load, 0.5 * (1000 * 50) * POWER(2 * 3.14159 * 1000 * (10000 / 60), 2) AS Blade_Kinetic_Energy;	architect	4
SELECT 0.5 * 500000 * POWER(15 / (2 * 3.14159 * 0.25), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POWER(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Drag FROM bridge WHERE Name = 'Tower Bridge';	architect	1
SELECT 0.5 * 1000000000 * POWER(100000 / (2 * 3.14159 * 1000), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POWER(2 * 3.14159 * 10000 * (100000 / 60), 2) * (10000 * 2) AS Aerodynamic_Drag;	architect	4
SELECT 10.0 / (2.0 * 3.14159 * 343.0) AS Wind_Induced_Vibration_Frequency, 0.5 * 1.225 * POWER(2.0 * 3.14159 * 14.0 * (20.0 / 60.0), 2) * (14.0 * 2.0) AS Aerodynamic_Lift FROM bridge WHERE Name = 'Millau Viaduct';	architect	1
SELECT Load_Capacity / (Length_Meters * 20) AS Load_Per_Square_Meter, Power_Output / (0.5 * 1.225 * POWER(6.5, 3) * (3.14159 * POWER(Blade_Length, 2))) AS Wind_Energy_Utilization FROM bridge, mill WHERE bridge.Name = 'Forth Bridge' AND mill.Name = 'Moulin de Pousset';	architect	2
SELECT (10 / (2 * 3.14159 * Height_Meters)) AS Natural_Frequency, (SELECT 2 * 3.14159 * Blade_Length_Meters * (Rotation_Speed / 60) FROM mill WHERE Name = 'Moulin de Bruges') AS Tip_Speed FROM bridge WHERE Name = 'Charles Bridge';	architect	1
SELECT (Maintenance_Cost * 100) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM bridge WHERE Name = 'Akashi Kaikyō Bridge' UNION ALL SELECT (Maintenance_Cost * 50) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM mill WHERE Name = 'Moulin de Momalle';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Rialto Bridge' THEN '高维护成本可能由于高使用强度、环境腐蚀或文物保护需求较高' WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Rialto Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin de Pousset';	architect	3
SELECT 0.5 * 1e12 * POW(100000 / 1000, 2) AS Vortex_Induced_Vibration_Energy, 8000 * POW(2 * 3.14159 * 100000 / 60, 2) * POW(10000, 2) / 2 AS Centrifugal_Stress;	architect	4
SELECT (12 * Span_Length) / (Vibration_Frequency * 1000) AS Harmonic_Number, (Blade_Length * Rotation_Speed) / 60 AS Critical_Frequency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';	architect	1
SELECT Maintenance_Cost * (POWER(1.02, 50) - 1) / 0.02 AS Total_Maintenance_Cost_Golden_Gate, (SELECT Maintenance_Cost * (POWER(1.05, 50) - 1) / 0.05 FROM mill WHERE Name = 'Moulin de Pousset') AS Total_Maintenance_Cost_Moulin FROM bridge WHERE Name = 'Golden Gate Bridge';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'High maintenance costs may be due to anti-corrosion treatment, load monitoring, and higher structural complexity' WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Sydney Harbour Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin d''Amsterdam';	architect	3
SELECT (1e9 * 1e6) / (6.62607015e-34 * 1e34) AS Quantum_Vibration_Modes, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) >= 299792458 THEN 'Faster than light, correction factor cannot be calculated' ELSE 'Not exceeding the speed of light requires relativistic corrections' END AS Relativity_Check, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) < 299792458 THEN 1 / SQRT(1 - ((2 * 3.14159 * 1e8 * (1e12 / 60)) / 299792458) * ((2 * 3.14159 * 1e8 * (1e12 / 60)) / 299792458)) ELSE 'N/A' END AS Relativity_Correction_Factor;	architect	4
SELECT (0.2 * Vibration_Frequency) / span_length_meters AS Vortex_Shedding_Frequency, 343 / (Rotation_Speed / 60) AS Infrasound_Wavelength FROM bridge, mill WHERE bridge.name = 'Tower Bridge' AND mill.name = 'Moulin de Bruges';	architect	1
SELECT (Maintenance_Cost * POWER(1 + 0.05, 25)) / Cost_Usd * 100 AS Maintenance_Cost_Percentage_Akashi, (SELECT Maintenance_Cost * POWER(1 + 0.08, 25) / Cost_Usd * 100 FROM mill WHERE Name = 'Moulin d''Amsterdam') AS Maintenance_Cost_Percentage_Amsterdam FROM bridge WHERE Name = 'Akashi Kaikyō Bridge';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Stone' THEN 'Stone maintenance costs are low due to its gradual failure mode and lack of need for complex anti-corrosion treatment' WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Ponte Vecchio' UNION ALL SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Forth Bridge';	architect	3
SELECT (6.67430e-11 * 1e41 * 1e17) / (1e25 * 1e25 * 1e25) AS Tidal_Resonance_Frequency, (1e40 * 14 / 60) * (1e40 * 14 / 60) / (299792458 * 299792458 * 299792458 * 299792458) AS Spacetime_Curvature_Rate;	architect	4
SELECT (LN(10.0 * b.Cost_Usd / b.Maintenance_Cost) / LN(1.02)) AS Years_To_10x_GoldenGate, POWER(1.02, 50) AS Multiplier_50y_GoldenGate, (LN(10.0 * m.Cost_Usd / m.Maintenance_Cost) / LN(1.05)) AS Years_To_10x_Amsterdam, POWER(1.05, 50) AS Multiplier_50y_Amsterdam FROM bridge b, mill m WHERE b.Name = 'Golden Gate Bridge' AND m.Name = 'Moulin d''Amsterdam';	architect	2
SELECT 0.5 * p.AerodynamicDrag * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT r.RidingStyle, (r.RiderPowerOutput + (t.MotorEfficiency / 100.0 * t.BatteryCapacity)) * 2 AS TotalEnergyConsumption FROM BicycleRider r JOIN BicycleThermodynamics t ON r.BicycleID = t.BicycleID;	bike	2
SELECT b.BicycleID, CASE WHEN (b.Weight + r.RiderWeight + b.MaxLoad) / 0.02 > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 5 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, (75 + 15) * 9.81 * (p.TopSpeed * 1000 / 3600) * 0.10 AS ClimbingPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'Mountain bike';	bike	1
SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER(p.TopSpeed * 1000.0 / 3600.0, 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics WHERE BatteryCapacity = 500;	bike	2
SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000.0 / 3600.0), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT t.AmbientTemperature, 500.0 / (100 + (250.0 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;	bike	2
SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000.0 / 3600.0), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 0.5 * (b.Weight + b.MaxLoad) * ((p.TopSpeed * 1000.0 / 3600.0) * (p.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'electric vehicle';	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID;	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100;	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' ORDER BY KineticEnergy DESC LIMIT 5;	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID ORDER BY ActualPower DESC LIMIT 10;	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID ORDER BY ContactArea ASC LIMIT 5;	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100 ORDER BY NewCenterOfGravityHeight DESC LIMIT 3;	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) > (SELECT MAX(0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0))) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Mountain bike');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > (SELECT MAX(BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100) FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Road bike');	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < (SELECT MIN(BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2)) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX');	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > (SELECT MAX(BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500)) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'No suspension');	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) > (SELECT MAX(0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0))) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 AS ActualPower  FROM Bicycle  JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID  JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.Type = 'Hybrid vehicle'  AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100.0 > (     SELECT MAX(sub.RiderPowerOutput * sub.PowerTransferEfficiency / 100.0)      FROM Bicycle AS b      JOIN BicycleRider AS sub ON b.BicycleID = sub.BicycleID      JOIN BicyclePerformance AS perf ON b.BicycleID = perf.BicycleID      JOIN BicycleComponents AS comp ON b.BicycleID = comp.BicycleID      WHERE b.Type = 'Road bike' AND comp.RimMaterial = 'aluminum alloy' );	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < (     SELECT MIN(BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2))     FROM Bicycle     JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID     WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢' );	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight  FROM Bicycle  JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID  JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.SuspensionType = 'Full suspension'  AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > (     SELECT MAX(BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500))      FROM Bicycle      JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID      JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID      JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID      WHERE Bicycle.SuspensionType = 'No suspension'      AND BicycleComponents.HandlebarMaterial = 'Titanium alloy' );	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0)) > (SELECT MAX(0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * ((BicyclePerformance.TopSpeed * 1000.0 / 3600.0) * (BicyclePerformance.TopSpeed * 1000.0 / 3600.0))) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > (SELECT MAX(BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100) FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < (SELECT MIN(BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2)) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > (SELECT MAX(BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500)) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');	bike	4
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) AS HeatGenerated  FROM Bicycle  JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID  JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.Type = 'electric vehicle'  AND BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) > (     SELECT MAX(BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100))      FROM Bicycle      JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID      JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID      JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID      WHERE Bicycle.Type = 'Mountain bike'      AND BicycleComponents.FrameMaterial = 'Carbon fiber' );	bike	1
SELECT Bicycle.BicycleID, BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 AS UsableEnergy FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 > (SELECT MAX(BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');	bike	2
SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) AS MotorTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) < (SELECT MAX(BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency)) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');	bike	3
SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (1000.0 / BicycleThermodynamics.HeatDissipationRate) AS BatteryTemperature  FROM Bicycle  JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID  JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID  WHERE Bicycle.SuspensionType = 'Full suspension'  AND BicycleThermodynamics.AmbientTemperature + (1000.0 / BicycleThermodynamics.HeatDissipationRate) > (     SELECT MAX(BicycleThermodynamics.AmbientTemperature + (1000.0 / BicycleThermodynamics.HeatDissipationRate))      FROM Bicycle      JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID      JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID      WHERE Bicycle.SuspensionType = 'No suspension'      AND BicycleComponents.HandlebarMaterial = 'Titanium alloy' );	bike	4
SELECT AmbientTemperature, MotorTemperature FROM BicycleThermodynamics WHERE MotorEfficiency = 85 AND BatteryCapacity = 500 AND HeatDissipationRate = 200 AND AmbientTemperature BETWEEN 10 AND 40;	bike	1
SELECT Type, RidingStyle, AVG(RiderPowerOutput) AS AvgPowerOutput FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100.0)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 1000 AND MotorEfficiency = 90 AND HeatDissipationRate = 500 AND AmbientTemperature = 50 AND MotorTemperature = 100 AND RiderPowerOutput = 500;	bike	4
SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100.0))) * 100.0 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;	bike	1
SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100.0)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;	bike	4
SELECT AerodynamicDrag, RollingResistance, (300 * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance bp JOIN Bicycle b ON bp.BicycleID = b.BicycleID JOIN BicycleComponents bc ON b.BicycleID = bc.BicycleID WHERE bc.TireWidth = 28 AND b.TirePressure = 60;	bike	1
SELECT Type, RidingStyle, AVG((RiderPowerOutput / (RiderWeight * 9.81 * 0.1)) * 100) AS ClimbingEfficiency FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;	bike	3
SELECT MaxLoad, ((Weight + MaxLoad) * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Weight = 20 AND TirePressure = 70 AND TireWidth = 32 AND MaxLoad BETWEEN 100 AND 500;	bike	4
SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100.0))) * 100.0 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;	bike	1
SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100.0)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;	bike	4
SELECT RidingStyle, RiderPowerOutput, (RiderPowerOutput * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance JOIN BicycleRider ON BicyclePerformance.BicycleID = BicycleRider.BicycleID WHERE AerodynamicDrag = 0.5 AND RollingResistance = 0.01 AND PowerTransferEfficiency = 95;	bike	1
SELECT CASE WHEN RiderAge BETWEEN 20 AND 30 THEN '20-30' WHEN RiderAge BETWEEN 31 AND 40 THEN '31-40' WHEN RiderAge BETWEEN 41 AND 50 THEN '41-50' END AS RiderAgeGroup, RidingStyle, AVG(RiderCadence) AS AvgCadence FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') GROUP BY RiderAgeGroup, RidingStyle;	bike	2
SELECT RidingStyle, (10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END * 1 AS EnergyConsumption FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road');	bike	3
SELECT RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / MotorEfficiency) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 5000 AND MotorEfficiency = 99 AND HeatDissipationRate = 2000 AND AmbientTemperature = 80 AND MotorTemperature = 250 AND RiderPowerOutput BETWEEN 1000 AND 5000;	bike	4
SELECT ((100 * 9.81 * SIN(ATAN(0.1))) + (100 * 9.81 * 0.005 * COS(ATAN(0.1))) + (0.5 * 1.225 * 0.3 * 0.5 * POWER((5 + (TopSpeed * 0.277778)), 2))) * (TopSpeed * 0.277778) / 0.8 AS MinPower FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'Mountain bike');	bike	1
SELECT BicycleID, (PowerTransferEfficiency / AerodynamicDrag) AS EfficiencyRatio FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Price < 10000) ORDER BY EfficiencyRatio DESC LIMIT 3;	bike	2
SELECT BicycleID FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND Weight < (SELECT AVG(Weight) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike') AND Price < (SELECT AVG(Price) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike');	bike	3
SELECT 'Asphalt road' AS Surface, ((0.004 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Gravel Road' AS Surface, ((0.02 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Muddy ground' AS Surface, ((0.05 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance;	bike	4
SELECT b.BicycleID, (b.Weight + r.RiderWeight) / (b.TirePressure * 0.07030695796) AS Tire_Pressure_Impact FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	1
SELECT b.BicycleID, (r.RiderPowerOutput * p.PowerTransferEfficiency) / (p.AerodynamicDrag * p.RollingResistance) AS TopSpeed_Theoretical FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	2
SELECT b.Type, r.RidingStyle, COUNT(*) AS Match_Count FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID GROUP BY b.Type, r.RidingStyle ORDER BY Match_Count DESC;	bike	3
SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 1.0 / d.CenterOfGravityHeight AS Cornering_Stability_Impact FROM Bicycle b JOIN BicycleDynamics d ON b.BicycleID = d.BicycleID;	bike	1
SELECT b.BicycleID, r.RiderPowerOutput * p.PowerTransferEfficiency AS Power_Output_Effective FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY Power_Output_Effective DESC LIMIT 1;	bike	2
SELECT b.Type, r.RiderName FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID WHERE b.MaxLoad > r.RiderWeight;	bike	3
SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000.0) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID ORDER BY ABS(p.BrakingDistance - (p.BrakingDistance * (b.TirePressure / 1000.0))) DESC LIMIT 1;	bike	4
SELECT 0.5 * 1.225 * POWER(TopSpeed * 0.277778, 2) * 0.9 * 0.5 AS AirResistance FROM BicyclePerformance JOIN Bicycle ON BicyclePerformance.BicycleID = Bicycle.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT 250 * (PowerTransferEfficiency / 100) AS ActualPower FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);	bike	2
SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 120 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	3
SELECT POWER(100 * 0.277778, 2) / (2 * 2.0 * 9.8 * 2) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');	bike	4
SELECT 0.5 * (Bicycle.Weight + BicycleRider.RiderWeight) * POWER(BicyclePerformance.TopSpeed * 0.277778, 2) AS KineticEnergy FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT (Bicycle.Price + (2000 * 0.5 * 5)) / (2000 * 5) AS CostBenefitRatio FROM Bicycle WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);	bike	2
SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.MaxLoad + BicycleRider.RiderWeight) <= 100 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	3
SELECT POWER(200 * 0.277778, 2) / (2 * 3.0 * 9.8 * 3) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000.0 / 3600.0), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT Type, AVG(PowerTransferEfficiency) AS AvgEfficiency FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgEfficiency DESC LIMIT 1;	bike	2
SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' GROUP BY Manufacturer;	bike	3
SELECT Bicycle.BicycleID, (BicycleComponents.TireWidth * 1000) / 1000 AS NewContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;	bike	4
SELECT Bicycle.BicycleID, (BicycleRider.RiderWeight + Bicycle.Weight) / Bicycle.TirePressure AS ContactArea FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	1
SELECT Type, AVG(RollingResistance) AS AvgRollingResistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgRollingResistance ASC LIMIT 1;	bike	2
SELECT Manufacturer, AVG(BrakingDistance) AS AvgBrakingDistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE BrakeType = 'Disc brakes' GROUP BY Manufacturer;	bike	3
SELECT Bicycle.BicycleID, (100000 - BicycleThermodynamics.BatteryCapacity) * BicycleThermodynamics.MotorEfficiency / BicycleRider.RiderPowerOutput AS RangeIncrease FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	4
SELECT BicycleID, Manufacturer, Model, (75 * 50 + 10 * 50) / (75 + 10 + MaxLoad) AS CenterOfGravityHeight FROM Bicycle WHERE FrameMaterial = 'Carbon fiber';	bike	1
SELECT b.BicycleID, b.Manufacturer, b.Model, p.PowerTransferEfficiency * r.RiderPowerOutput AS ActualPowerOutput FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY ActualPowerOutput DESC LIMIT 5;	bike	2
SELECT Manufacturer, Model, TirePressure FROM Bicycle WHERE TirePressure < 60;	bike	3
SELECT BicycleID, Manufacturer, Model, (1000.0 * 1000.0) / (2.0 * (0.01 + 0.5) * 9.81) AS BrakingDistance FROM Bicycle;	bike	4
SELECT d.BicycleID, b.Manufacturer, b.Model, r.RiderWeight, d.Wheelbase, d.SteeringAngle, (d.Wheelbase / (2 * SIN(d.SteeringAngle * PI() / 180))) AS MinTurningRadius FROM BicycleDynamics d JOIN Bicycle b ON d.BicycleID = b.BicycleID JOIN BicycleRider r ON d.BicycleID = r.BicycleID;	bike	1
SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency / 100) / (r.RiderPowerOutput / 1000.0) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;	bike	2
SELECT b.Manufacturer, AVG(b.Price) AS AvgPrice FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.SuspensionType = 'Full suspension' AND b.Type = 'Mountain bike' AND c.TireWidth > 50 AND c.RimMaterial = 'aluminum alloy' GROUP BY b.Manufacturer;	bike	3
SELECT th.BicycleID, (5000 * (1 - th.MotorEfficiency/100) + (200 - 25) * 50) AS RequiredDissipation FROM BicycleThermodynamics th WHERE th.MotorTemperature < 100;	bike	4
SELECT b.BicycleID, b.Manufacturer, b.Model, 0.5 * p.AerodynamicDrag * 1.225 * POWER(p.TopSpeed/3.6, 3) * (c.TireWidth/1000 * b.HandlebarWidth/100) AS AirPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleComponents c ON b.BicycleID = c.BicycleID ORDER BY AirPower DESC LIMIT 5;	bike	1
SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency / 100.0) / r.RiderPowerOutput) AS EnergyRecovery FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;	bike	2
SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND TirePressure > 80 GROUP BY Manufacturer;	bike	3
SELECT BicycleID, (100 - (25 - (-50)) * 0.5) AS CapacityRemaining FROM BicycleThermodynamics WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'electric vehicle');	bike	4
SELECT b.BicycleID, b.Manufacturer, b.Model, ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance)*100 AS Deviation, p.BrakingDistance AS ActualDistance, POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) AS TheoreticalDistance FROM BicyclePerformance p JOIN Bicycle b ON p.BicycleID = b.BicycleID WHERE ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance) > 0.1;	bike	1
SELECT CAST(th.AmbientTemperature / 10 AS INTEGER) * 10 AS TempRange, AVG(th.BatteryCapacity * (1 - 0.005 * POWER(ABS(th.AmbientTemperature - 25), 1.2)) * th.MotorEfficiency / 100 / (r.RiderPowerOutput / 1000.0) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY TempRange ORDER BY TempRange;	bike	2
SELECT b.BicycleID, b.Manufacturer, b.Model, b.SuspensionType, c.TireWidth  FROM Bicycle b  JOIN BicycleComponents c ON b.BicycleID = c.BicycleID  WHERE b.Type = 'Mountain bike'  AND ((b.SuspensionType = 'Full suspension' AND c.TireWidth <= 50) OR (b.SuspensionType = 'No suspension' AND c.TireWidth >= 40));	bike	3
SELECT th.BicycleID, (r.RiderPowerOutput/(th.MotorEfficiency/100.0) * 3600 * (1 - th.MotorEfficiency/100.0)) / (500 * 0.9) + 60 AS TheoreticalTemp FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' AND b.MaxLoad >= 500;	bike	4
SELECT Model, Compression_Ratio, (1 - (1/POWER(Compression_Ratio, 0.4))) AS Thermal_Efficiency FROM engine WHERE Compression_Ratio BETWEEN 10 AND 12 AND Fuel_Type = 'Gasoline' ORDER BY Compression_Ratio ASC;	car_engine	1
SELECT Model, Displacement, (3.141592653589793 * (Bore/20.0) * (Bore/20.0) * Stroke/10.0)/1000.0 AS 单缸排量, ABS(Displacement - (3.141592653589793 * (Bore/20.0) * (Bore/20.0) * Stroke/10.0)/1000.0 * Cylinders) AS error FROM engine WHERE Configuration = 'Inline' AND Cylinders = 6 ORDER BY error DESC LIMIT 5;	car_engine	2
SELECT e.Model, e.Aspiration, ep.Specific_Power FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND m.Block_Material = 'Cast Iron' ORDER BY ep.Specific_Power DESC LIMIT 10;	car_engine	3
SELECT Model, Stroke, (2 * Stroke * 100000) / 60000 AS Piston_Speed FROM engine WHERE (2 * Stroke * 100000) / 60000 > 343 ORDER BY Piston_Speed DESC;	car_engine	4
SELECT e.Model, (ed.Length * ed.Width * ed.Height) AS Volume, e.Compression_Ratio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY Volume DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * 3.141592653589793 * POWER(e.Bore/2000.0, 2) + 2 * 3.141592653589793 * (e.Bore/2000.0) * (e.Stroke/1000.0)) * e.Cylinders * 2 AS TotalSurfaceArea FROM engine e WHERE e.Configuration LIKE 'V%' ORDER BY TotalSurfaceArea ASC LIMIT 5;	car_engine	2
SELECT e.Model, (e.Horsepower / e.Weight) AS PowerWeightRatio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > 150 AND ed.Length < 600 ORDER BY PowerWeightRatio DESC;	car_engine	3
SELECT e.Model, (ed.Length * ed.Width * ed.Height) + (10000 * e.Cylinders) AS VirtualVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY VirtualVolume DESC LIMIT 2;	car_engine	4
SELECT e.Manufacturer, AVG((ed.Length / 100.0) * (ed.Width / 100.0) * (ed.Height / 100.0)) AS AvgVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Manufacturer ORDER BY AvgVolume DESC LIMIT 1;	car_engine	1
SELECT e.Cylinders, ABS(((e.Cylinders - 1) * ed.Cylinder_Spacing + (e.Bore * e.Cylinders)) - ed.Length) AS DeltaL FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'Inline' ORDER BY DeltaL DESC LIMIT 5;	car_engine	2
SELECT e.Manufacturer, COUNT(*) AS AnomalyCount FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > ((ed.Length / 100.0) * (ed.Width / 100.0) * (ed.Height / 100.0)) * 7.3 GROUP BY e.Manufacturer;	car_engine	3
SELECT e.Engine_ID, ((10000-1)*12742000000 + e.Bore)/40075000000.0 AS Circles FROM engine e;	car_engine	4
SELECT e.Engine_ID, e.Model, (2 * PI() * ed.Max_turn) / 60 AS Angular_Velocity, em.Crankshaft_Material FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE ((2 * PI() * ed.Max_turn) / 60) > CASE WHEN em.Crankshaft_Material = 'Forged Steel' THEN 1000 WHEN em.Crankshaft_Material = 'Cast Iron' THEN 800 ELSE 500 END;	car_engine	1
SELECT e.Engine_ID, e.Model, (ep.BMEP * 100000.0 * e.Displacement * ed.Peak_Power * 0.00001667) / (ep.Fuel_Consumption * 34200000.0) * 100.0 AS Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power >= 100;	car_engine	2
SELECT Engine_ID, Model, Compression_Ratio, Fuel_Type FROM engine WHERE Compression_Ratio > 14 AND Fuel_Type = 'Gasoline';	car_engine	3
SELECT e.Engine_ID, e.Model, 2 * e.Stroke * (1800000000/60)/1000 AS Piston_Speed, em.Piston_Material FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE 2 * e.Stroke * (1800000000/60)/1000 > CASE WHEN em.Piston_Material = 'Aluminum' THEN 25 WHEN em.Piston_Material = 'Steel' THEN 30 ELSE 0 END;	car_engine	4
SELECT m.Block_Material, m.Coating_Type, AVG(t.Heat_Rejection_Rate) AS Avg_Heat_Rejection_Rate FROM enginematerials m JOIN enginethermodynamics t ON m.Engine_ID = t.Engine_ID WHERE m.Block_Material IN ('Cast Iron', 'Aluminum') GROUP BY m.Block_Material, m.Coating_Type ORDER BY Avg_Heat_Rejection_Rate DESC;	car_engine	1
WITH Total AS (   SELECT COUNT(*) AS TotalCount    FROM enginematerials    WHERE Crankshaft_Material = 'Forged Steel' AND Connecting_Rod_Material = 'Titanium' ) SELECT m.Block_Material,         m.Connecting_Rod_Material,         COUNT(*) AS Count,         ROUND((COUNT(*) * 100.0 / (SELECT TotalCount FROM Total)), 2) AS Percentage  FROM enginematerials m  WHERE m.Crankshaft_Material = 'Forged Steel' AND m.Connecting_Rod_Material = 'Titanium'  GROUP BY m.Block_Material, m.Connecting_Rod_Material;	car_engine	2
SELECT CASE WHEN e.Compression_Ratio < 10 THEN 'Low (<10)' WHEN e.Compression_Ratio BETWEEN 10 AND 12 THEN 'Medium (10-12)' WHEN e.Compression_Ratio > 12 THEN 'High (>12)' END AS Compression_Ratio_Range, COUNT(*) AS Engine_Count FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND m.Piston_Material IN ('Aluminum', 'Forged Aluminum') GROUP BY Compression_Ratio_Range ORDER BY MIN(e.Compression_Ratio);	car_engine	3
SELECT Cylinders, SUM(10000 * 0.0005 * Cylinders) AS Total_Piston_Weight FROM engine GROUP BY Cylinders ORDER BY Cylinders;	car_engine	4
SELECT (2*(80*205)/(80+205)) * 0.5 * 200 / 0.01 AS Heat_Flow FROM enginematerials WHERE Block_Material = 'Cast Iron' AND Head_Material = 'Aluminum';	car_engine	1
SELECT (0.002*2700 + 0.001*4500) AS Total_Mass, CASE WHEN (0.002*2700 + 0.001*4500) <= 5 THEN 'Satisfaction' ELSE 'Unsatisfied' END AS 质量判定 FROM enginematerials WHERE Piston_Material = 'Forged Aluminum' AND Connecting_Rod_Material = 'Titanium';	car_engine	2
SELECT e.Model, e.Compression_Ratio, em.Head_Material, et.Thermal_Conductivity FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Compression_Ratio >= 12 AND em.Head_Material = 'Aluminum' AND et.Thermal_Conductivity > 150;	car_engine	3
SELECT ed.Main_Bore_Diameter, 500*(1+0.0001*(1000-20)) AS 膨胀后长度, CASE WHEN 500*(1+0.0001*980) <= ed.Main_Bore_Diameter THEN '可配合' ELSE '不可配合' END AS 配合判定 FROM enginedimensions ed JOIN enginematerials em ON ed.Engine_ID = em.Engine_ID WHERE em.Crankshaft_Material = 'Forged Steel';	car_engine	4
SELECT e.Model, ed.Angular_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID ORDER BY ed.Angular_Velocity DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * e.Stroke / 1000.0 * ed.Max_turn) / 60.0 AS Calculated_Speed, ed.Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE ABS(((2 * e.Stroke / 1000.0 * ed.Max_turn) / 60.0 - ed.Mean_Piston_Speed) / ed.Mean_Piston_Speed) <= 0.02 ORDER BY Calculated_Speed DESC LIMIT 5;	car_engine	2
SELECT e.Manufacturer, e.Model, ed.Peak_Torque FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Fuel_Type = 'Diesel' AND ed.Peak_Torque < 2000 ORDER BY e.Manufacturer ASC;	car_engine	3
SELECT e.Model, (2 * e.Stroke / 1000.0 * 100000) / 60.0 AS Hypothetical_Speed FROM engine e WHERE e.Configuration = 'Rotary' AND (2 * e.Stroke / 1000.0 * 100000) / 60.0 > 250 ORDER BY Hypothetical_Speed DESC;	car_engine	4
SELECT e.Model, ep.Thermal_Efficiency, (ep.Thermal_Efficiency / 100.0) AS Effective_Work_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID ORDER BY ep.Thermal_Efficiency DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * 3.141592653589793 * e.Torque * e.Cylinders) / (e.Displacement * 1000) AS BMEP FROM engine e WHERE (2 * 3.141592653589793 * e.Torque * e.Cylinders) / (e.Displacement * 1000) > 15 ORDER BY BMEP DESC;	car_engine	2
WITH displacement_avg AS (     SELECT Displacement, AVG(Fuel_Consumption) AS avg_fuel      FROM engine e      JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID      GROUP BY Displacement ) SELECT e.Model, e.Displacement, ep.Fuel_Consumption  FROM engine e  JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID  JOIN displacement_avg da ON e.Displacement = da.Displacement  WHERE ep.Fuel_Consumption < da.avg_fuel  ORDER BY e.Displacement ASC;	car_engine	3
SELECT e.Model, e.Weight, ep.Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Weight = 0 AND ep.Power_To_Weight_Ratio > 500 ORDER BY e.Weight ASC;	car_engine	4
SELECT Engine_ID FROM engineperformance WHERE BMEP > 15 AND Thermal_Efficiency < 30;	car_engine	1
SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE (ep.Power_To_Weight_Ratio * 1000) / ep.Specific_Power >= SQRT(e.Displacement) AND e.Fuel_Type != 'Electric';	car_engine	2
SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type = 'Gasoline' AND ep.Fuel_Consumption < (6 + 0.5 * e.Displacement) AND ep.Thermal_Efficiency > 35;	car_engine	3
SELECT Engine_ID FROM engineperformance WHERE Thermal_Efficiency > 88 AND Specific_Torque >= 1000000 AND BMEP > 1000;	car_engine	4
SELECT e.Fuel_Type, AVG((2 * 3.141592653589793 * e.Torque) / (e.Displacement * 100000)) AS Avg_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Fuel_Type;	car_engine	1
SELECT e.Manufacturer, EXP(SUM(e.Displacement * LN(ep.Specific_Power * ep.Specific_Torque)) / SUM(e.Displacement)) AS Weighted_Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power > 0 AND ep.Specific_Torque > 0 GROUP BY e.Manufacturer ORDER BY Weighted_Geometric_Mean DESC;	car_engine	2
SELECT e.Cylinders, AVG(ep.Fuel_Consumption) AS Avg_Fuel_Consumption, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Cylinders ORDER BY e.Cylinders;	car_engine	3
SELECT e.Fuel_Type, COUNT(*) AS Anomaly_Count, AVG(ep.Power_To_Weight_Ratio) AS Avg_Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Fuel_Consumption < 0 OR ep.Fuel_Consumption > 500 GROUP BY e.Fuel_Type;	car_engine	4
SELECT e.Fuel_Type, AVG((e.Horsepower * 0.7457 * 1000) / (ep.Fuel_Consumption * CASE WHEN e.Fuel_Type = 'Gasoline' THEN 34.2 WHEN e.Fuel_Type = 'Diesel' THEN 38.6 ELSE 0 END * 100) * 100) AS Thermal_Efficiency, AVG(e.Displacement) AS Avg_Displacement, AVG(e.Horsepower) AS Avg_Horsepower FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Gasoline', 'Diesel') GROUP BY e.Fuel_Type;	car_engine	1
SELECT Cylinders, AVG(ABS(Displacement - (PI() / 4 * POWER(Bore / 10.0, 2) * Stroke / 10.0 * Cylinders / 1000.0)) / Displacement * 100.0) AS Error_Percentage FROM engine GROUP BY Cylinders;	car_engine	2
SELECT e.Configuration, AVG(d.Length) AS Avg_Length, AVG(d.Width) AS Avg_Width FROM engine e JOIN enginedimensions d ON e.Engine_ID = d.Engine_ID GROUP BY e.Configuration;	car_engine	3
SELECT Configuration, (2.0 * 1000000 * 1000 / 60.0 / 1000.0) / 343.0 AS Mach_Number FROM engine GROUP BY Configuration;	car_engine	4
SELECT e.Engine_ID, e.Model, m.Block_Material, p.Thermal_Efficiency  FROM engine e  JOIN enginematerials m ON e.Engine_ID = m.Engine_ID  JOIN engineperformance p ON e.Engine_ID = p.Engine_ID  WHERE m.Block_Material = 'Cast Iron' AND p.Thermal_Efficiency > 35;	car_engine	1
SELECT e.Engine_ID, e.Model, d.Peak_Torque, p.BMEP FROM engine e JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND p.BMEP < (d.Peak_Torque / e.Displacement) * 0.12;	car_engine	2
SELECT e.Engine_ID, e.Model, ed.Length, d.Piston_Speed FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID WHERE ed.Length > 1000 AND d.Piston_Speed > 25;	car_engine	3
SELECT Engine_ID, Model, Displacement FROM engine WHERE Fuel_Type = 'Electric' AND Displacement != 0;	car_engine	4
SELECT ed.Engine_ID, PI() * (Main_Bore_Diameter/2) * (Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2) * (Rod_Journal_Diameter/2) AS Bearing_Area, (1.5 * edyn.Angular_Velocity * edyn.Angular_Velocity * (ed.Weight/1000) * (Rod_Journal_Diameter/2000)) / (PI() * (Main_Bore_Diameter/2)*(Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2)*(Rod_Journal_Diameter/2)) AS Stress FROM enginedimensions ed JOIN enginedynamics edyn USING(Engine_ID) JOIN enginematerials em USING(Engine_ID) WHERE em.Block_Material = 'Cast Iron' HAVING Stress > 200;	car_engine	1
SELECT ed.Engine_ID, (Cylinder_Spacing * 5 + 40 + 6 * Bore) AS Calculated_Length, Length, ABS((Cylinder_Spacing * 5 + 40 + 6 * Bore) - Length) AS Length_Deviation FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE e.Cylinders = 6 AND e.Configuration = 'Inline';	car_engine	2
SELECT ed.Engine_ID, Cylinder_Spacing, Bore, ROUND(1.2*Bore,1) AS Min_Safe_Spacing, CASE WHEN Cylinder_Spacing < 1.2*Bore THEN 'Danger' ELSE 'Safety' END AS Safety_Status FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE Cylinder_Spacing = 50 AND Width = 600;	car_engine	3
SELECT Engine_ID FROM enginedimensions WHERE Weight > 10000 AND Engine_ID NOT IN (SELECT Engine_ID FROM engineperformance WHERE Power_To_Weight_Ratio < 0.001);	car_engine	4
SELECT e.Model, (80 * 21.9 * 0.01 * 600) / (80 * 0.005 + 21.9 * 0.010) AS Q FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN enginethermodynamics t ON e.Engine_ID = t.Engine_ID WHERE m.Valve_Material = 'Titanium' AND m.Head_Material = 'Cast Iron' ORDER BY Q DESC LIMIT 3;	car_engine	1
SELECT e.Engine_ID, 2700 * PI() * POWER(e.Bore/2000.0, 2) * e.Stroke/1000.0 * POWER(d.Angular_Velocity, 2) * (e.Stroke/2000.0) * (1 + 1/(2*1.5)) AS F FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginedynamics d USING(Engine_ID) WHERE m.Piston_Material = 'Aluminum' AND m.Connecting_Rod_Material = 'Steel' ORDER BY F ASC LIMIT 5;	car_engine	2
SELECT e.Model, p.Specific_Power  FROM engine e  JOIN enginematerials m ON e.Engine_ID = m.Engine_ID  JOIN engineperformance p ON e.Engine_ID = p.Engine_ID  WHERE m.Block_Material = 'Cast Iron'    AND e.Fuel_Type = 'Gasoline'    AND e.Compression_Ratio > 10  ORDER BY p.Specific_Power DESC  LIMIT 3;	car_engine	3
SELECT e.Engine_ID, (1.0/(2.0*PI())) * SQRT( (300e9/(2.0*(1.0+0.3)) * PI()*POWER(ed.Rod_Journal_Diameter/1000.0,4)/32.0) / (ed.Length/1000.0 * (e.Weight * POWER(ed.Rod_Journal_Diameter/2000.0,2)/4.0)) ) AS f FROM engine e JOIN enginedimensions ed USING(Engine_ID) WHERE e.Configuration = 'W' AND e.Cylinders = 24 AND e.Bore = 5000 AND e.Stroke = 3000 ORDER BY f ASC;	car_engine	4
SELECT e.Model, (et.Combustion_Efficiency / et.Heat_Rejection_Rate) AS Ratio FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Displacement > 2.0 ORDER BY Ratio DESC LIMIT 5;	car_engine	1
SELECT e.Model, (et.Thermal_Conductivity * (et.Exhaust_Gas_Temperature - et.Coolant_Temperature) / ed.Cylinder_Spacing + et.Specific_Heat_Capacity * et.Oil_Temperature) AS Q_total FROM enginethermodynamics et INNER JOIN enginematerials em ON et.Engine_ID = em.Engine_ID INNER JOIN enginedimensions ed ON et.Engine_ID = ed.Engine_ID INNER JOIN engine e ON et.Engine_ID = e.Engine_ID ORDER BY Q_total DESC LIMIT 3;	car_engine	2
SELECT e.Model FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 100 AND e.Fuel_Type = 'Gasoline' ORDER BY e.Displacement ASC;	car_engine	3
SELECT e.Model, (1000 * (ed.Cylinder_Spacing / 1000)) / ((2 * ((ed.Length / 1000) * (ed.Width / 1000) + (ed.Length / 1000) * (ed.Height / 1000) + (ed.Width / 1000) * (ed.Height / 1000))) * (5000 - 25)) AS λ_min FROM enginedimensions ed INNER JOIN engine e ON ed.Engine_ID = e.Engine_ID ORDER BY λ_min ASC LIMIT 5;	car_engine	4
SELECT e.Manufacturer, AVG(et.Combustion_Efficiency) AS Avg_Combustion_Efficiency, SUM(et.Heat_Rejection_Rate) AS Total_Heat_Rejection_Rate FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID GROUP BY e.Manufacturer;	car_engine	1
SELECT e.Configuration, SUM(e.Weight)/(SUM(e.Weight/(0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity))) AS Weighted_Harmonic_Mean FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Fuel_Type = 'Electric' AND (0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity) > 0 GROUP BY e.Configuration;	car_engine	2
SELECT e.Fuel_Type, COUNT(DISTINCT e.Model) AS High_Temp_Models FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 120 GROUP BY e.Fuel_Type;	car_engine	3
SELECT e.Cylinders, SUM(5.67E-8 * 0.9 * 2*(ed.Length*ed.Width + ed.Length*ed.Height + ed.Width*ed.Height) * (POWER(5273,4)-POWER(300,4))) AS Thermal_Radiation_Power FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Cylinders;	car_engine	4
SELECT Engine_ID, 5000 AS Total_Energy, Combustion_Efficiency, 2500 AS Cooling_Loss, (5000 - (5000 * Combustion_Efficiency / 100) - 2500) AS Calculated_Exhaust_Loss, Heat_Rejection_Rate AS Actual_Exhaust_Loss, CASE WHEN Heat_Rejection_Rate = (5000 - (5000 * Combustion_Efficiency / 100) - 2500) THEN '满足能量守恒' ELSE '不满足能量守恒' END AS Energy_Conservation_Status FROM enginethermodynamics WHERE Engine_ID = 12345;	car_engine	1
SELECT e.Engine_ID, e.Displacement, et.Specific_Heat_Capacity, (e.Displacement * 0.85) AS Mass_kg, (120 - 80) AS Temp_Diff_K, ROUND((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80), 2) AS Total_Heat_J, ROUND(((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80)) / 10 / 1000, 2) AS Required_Power_kW FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Engine_ID = 12345;	car_engine	2
SELECT Engine_ID, Exhaust_Gas_Temperature, CASE WHEN Exhaust_Gas_Temperature > 800 THEN '存在催化器失效风险' ELSE '工作状态正常' END AS Catalyst_Status FROM enginethermodynamics WHERE Exhaust_Gas_Temperature > 800;	car_engine	3
SELECT Engine_ID, Combustion_Efficiency, Heat_Rejection_Rate, CASE WHEN Combustion_Efficiency > 100 THEN 'Contradiction: Combustion efficiency exceeds physical limits' WHEN Heat_Rejection_Rate < 0 THEN 'Contradiction: Heat dissipation rate violates the second law of thermodynamics.' ELSE 'No contradiction' END AS Physical_Consistency FROM enginethermodynamics WHERE Combustion_Efficiency > 100 OR Heat_Rejection_Rate < 0;	car_engine	4
SELECT Engine_ID, Model, 1 * POWER(CAST(SUBSTR(Compression_Ratio, 1, INSTR(Compression_Ratio, ':') - 1) AS REAL), 1.4) AS Theoretical_Max_Pressure_Bar FROM engine WHERE Bore = 84 AND Stroke = 90 AND Compression_Ratio = '11.5:1' AND Fuel_Type = 'Gasoline';	car_engine	1
SELECT e.Engine_ID, e.Model, ed.Angular_Velocity, ROUND((ed.Angular_Velocity * (e.Stroke/2000.0)) * (SIN(RADIANS(70)) + ((e.Stroke/2000.0)/(2*0.15))*SIN(RADIANS(140))), 4) AS Instantaneous_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Cylinders = 8 AND e.Configuration = 'V' AND e.Stroke = 86;	car_engine	2
SELECT Engine_ID, Model, Compression_Ratio, Aspiration FROM engine WHERE Fuel_Type = 'Diesel' AND Aspiration = 'Turbocharged' AND Compression_Ratio = '18:1';	car_engine	3
SELECT e.Engine_ID, e.Model, 2.5 * POW(2*PI()*e.Redline/60, 2) * (e.Stroke/2000) * (1 + (e.Stroke/2000)/0.15) AS Inertial_Force FROM engine e WHERE e.Cylinders = 24 AND e.Configuration = 'W' AND e.Bore = 200 AND e.Stroke = 500;	car_engine	4
SELECT 0.5 * 50 * POWER((Main_Bore_Diameter/2/1000.0),2) AS 转动惯量, (2 * PI() * Max_turn)/60 AS 角速度 FROM enginedimensions JOIN enginedynamics USING(Engine_ID) WHERE Main_Bore_Diameter=80 AND Engine_ID IN (SELECT Engine_ID FROM engine WHERE Configuration='V');	car_engine	1
SELECT ROUND((Length*Width*Height - Cylinders*3.141592653589793*POWER(Bore/2,2)*Stroke)/(Length*Width*Height)*100,3) AS 剩余空间占比 FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='Inline' AND Cylinders=6 AND Length=600 AND Width=500 AND Height=400;	car_engine	2
SELECT Width, CASE WHEN Width <= 900 * (1 - 0.1) THEN 'conforms to' ELSE 'does not meet the requirements' END AS Installation Status FROM enginedimensions WHERE Width = 800;	car_engine	3
SELECT (24/4)*Cylinder_Spacing AS 理论长度, Cylinder_Spacing/100 AS 轴颈直径, CASE WHEN (16*20000)/(PI()*POWER(Cylinder_Spacing/100/1000,3)) > 800e6 THEN 'exceed' ELSE 'not exceeding' END AS Stress state FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='W' AND Cylinders=24 AND Cylinder_Spacing=5000;	car_engine	4
SELECT Engine_ID, Max_turn, Angular_Velocity, (PI() * Max_turn / 30) AS Formula_Value, ROUND(Angular_Velocity,2) = ROUND((PI() * Max_turn / 30),2) AS Data_Consistency FROM enginedynamics WHERE Max_turn = 8500 AND Angular_Velocity = 890;	car_engine	1
SELECT e.Engine_ID, ed.Mean_Piston_Speed, (2 * (e.Stroke / 1000.0) * ed.Max_turn) / 60.0 AS Calculated_Speed, ROUND(ed.Mean_Piston_Speed, 1) = ROUND((2 * (e.Stroke / 1000.0) * ed.Max_turn) / 60.0, 1) AS Validation FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'V型' AND ed.Max_turn = 6800 AND e.Stroke = 86;	car_engine	2
SELECT Engine_ID, Peak_Torque, Peak_Power, CAST(SUBSTR(Peak_Torque, INSTR(Peak_Torque, '-') + 1) AS INTEGER) < CAST(Peak_Power AS INTEGER) AS Logic_Validation FROM enginedynamics WHERE Engine_ID IN (SELECT Engine_ID FROM engine WHERE Aspiration = 'Turbocharged');	car_engine	3
SELECT PI() * 1500000 / 30 AS Angular_Velocity, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 AS Centrifugal_Stress, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 > 3e9 AS Will_Break FROM engine WHERE Configuration = 'rotor' LIMIT 1;	car_engine	4
SELECT ((300-200)*0.5)/((0.01/80)+(0.01/205))*3600 AS Heat_Joules_Per_Hour FROM enginematerials WHERE Block_Material='Aluminum' AND Head_Material='Cast Iron';	car_engine	1
SELECT (2*50000)/(900e6) AS Min_Area_m2, (2*50000)/(900e6) * 0.15 * (4.5*1000) AS Max_Weight_kg FROM enginematerials WHERE Connecting_Rod_Material='Titanium';	car_engine	2
SELECT CASE WHEN (0.015*1800*0.65) + (2*(e.Length*e.Width + e.Width*e.Height + e.Height*e.Length)/1000000.0 * 0.002 * 7800) < 120 THEN 'Yes' ELSE 'No' END FROM engine en JOIN enginedimensions e ON en.Engine_ID = e.Engine_ID JOIN enginematerials em ON en.Engine_ID = em.Engine_ID WHERE en.Weight = 120 AND em.Block_Material = 'Cast Iron';	car_engine	3
SELECT CASE WHEN (0.5 * (0.01 * 0.0002 * 0.08) * POWER((6000*2*3.141592653589793/60),2) * 0.08)/200e-6 > 900e6 THEN 'expired' ELSE 'Safety' END FROM enginematerials WHERE Crankshaft_Material='Hypothetical Materials';	car_engine	4
SELECT e.Configuration, AVG((e.Torque * 2 * PI() * ed.Peak_Torque) / (e.Displacement * 1000) * 60 / 100000) AS Calculated_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Configuration ORDER BY e.Configuration;	car_engine	1
SELECT e.Manufacturer, EXP(AVG(LN(ep.Specific_Power * ep.Specific_Torque)) / 2) AS Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Manufacturer ORDER BY Geometric_Mean DESC;	car_engine	2
WITH Ranked AS (     SELECT          e.Engine_ID,          ep.Fuel_Consumption,         CASE              WHEN e.Displacement < 2.0 THEN '<2.0L'              WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L'              ELSE '>3.0L'          END AS Displacement_Group,         ROW_NUMBER() OVER (PARTITION BY              CASE                  WHEN e.Displacement < 2.0 THEN '<2.0L'                  WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L'                  ELSE '>3.0L'              END              ORDER BY ep.Fuel_Consumption         ) AS RowAsc,         ROW_NUMBER() OVER (PARTITION BY              CASE                  WHEN e.Displacement < 2.0 THEN '<2.0L'                  WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L'                  ELSE '>3.0L'              END              ORDER BY ep.Fuel_Consumption DESC         ) AS RowDesc     FROM engine e      JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID ) SELECT      Displacement_Group,      AVG(Fuel_Consumption) AS Median_Fuel_Consumption  FROM Ranked  WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc  GROUP BY Displacement_Group  ORDER BY MIN(Displacement_Group);	car_engine	3
SELECT e.Fuel_Type, CASE WHEN e.Fuel_Type = 'Electric' THEN (100.0 / 120.0) * 100.0 ELSE AVG(ep.Fuel_Consumption) END AS Theoretical_Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Electric', 'Gasoline') GROUP BY e.Fuel_Type;	car_engine	4
SELECT e.Manufacturer, SUM(et.Heat_Rejection_Rate * 1000.0 / (et.Specific_Heat_Capacity * (et.Coolant_Temperature - 25.0))) AS Total_Heat_Capacity_Per_Degree FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Combustion_Efficiency > 30.0 GROUP BY e.Manufacturer ORDER BY Total_Heat_Capacity_Per_Degree DESC LIMIT 1;	car_engine	1
SELECT e.Model, (ep.Specific_Power * ep.Thermal_Efficiency) AS Efficiency_Product  FROM engine e  JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID  WHERE CAST(SUBSTR(e.Compression_Ratio, 1, INSTR(e.Compression_Ratio, ':') - 1) AS INTEGER) > 10  AND (ep.Specific_Power * ep.Thermal_Efficiency) > (     SELECT AVG(ep2.Specific_Power * ep2.Thermal_Efficiency)      FROM engineperformance ep2      JOIN engine e2 ON ep2.Engine_ID = e2.Engine_ID      WHERE CAST(SUBSTR(e2.Compression_Ratio, 1, INSTR(e2.Compression_Ratio, ':') - 1) AS INTEGER) > 10 );	car_engine	2
SELECT e.Engine_ID, et.Exhaust_Gas_Temperature, em.Block_Material FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE et.Exhaust_Gas_Temperature > 900 AND em.Block_Material = 'Cast Iron';	car_engine	3
SELECT e.Model, (2 * e.Stroke * 100000) / 60000 AS Hypothetical_Piston_Speed, ((2 * e.Stroke * 100000) / 60000 - 7000) * 100.0 / 7000 AS Over_Speed_Percentage FROM engine e WHERE (2 * e.Stroke * 100000) / 60000 > 7000;	car_engine	4
SELECT ROUND((3.141592653589793 * POWER(90.0/2.0, 2) * 100.0) / (11-1) / 1000000.0, 4) AS Combustion_Chamber_Volume_L, CASE WHEN 11 <= 13 THEN 'conforms to' ELSE 'does not meet the requirements' END AS Compression_Ratio_Check;	car_engine	1
SELECT ROUND((ep.Specific_Power * 0.6 + ep.Thermal_Efficiency * 0.4), 2) AS Comprehensive_Score FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE em.Block_Material = 'Aluminum' AND e.Aspiration = 'Turbocharged' AND ep.Specific_Power IS NOT NULL AND ep.Thermal_Efficiency IS NOT NULL;	car_engine	2
SELECT FLOOR(600 / (120 * 0.866)) * 2 AS Max_Cylinders FROM engine WHERE Configuration = 'V' LIMIT 1;	car_engine	3
SELECT ROUND((50*60)/(2*0.2),0) AS RPM_假设, ROUND((50*60)/(2*0.2)*3.141592653589793/30,2) AS Angular_Velocity, ROUND(POW((50*60)/(2*0.2)/6000,2),2) AS Centrifugal_Force_Multiplier FROM engine WHERE Fuel_Type='Electric' AND Stroke=200 LIMIT 1;	car_engine	4
SELECT e.Manufacturer, e.Model, (2 * e.Stroke * ed.Max_turn) / 60000 AS Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE (2 * e.Stroke * ed.Max_turn) / 60000 > 25;	car_engine	1
SELECT e.Configuration, STDEV((ed.Max_turn * 2 * PI()) / 60) AS Angular_Velocity_StdDev FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Compression_Ratio >= 10 AND e.Configuration IN ('V', 'Inline') GROUP BY e.Configuration;	car_engine	2
SELECT e.Model, e.Manufacturer, ep.Specific_Power FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE em.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Diesel' AND ep.Thermal_Efficiency > 40 ORDER BY ep.Specific_Power DESC;	car_engine	3
SELECT DISTINCT em.Connecting_Rod_Material FROM enginematerials em JOIN enginedimensions ed ON em.Engine_ID = ed.Engine_ID WHERE ed.Rod_Journal_Diameter > 500;	car_engine	4
SELECT (50 * 10) + (50 * 15) AS Total_Energy_Consumption;	car	1
SELECT AVG(engine_specs.Horsepower / dimensions.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123; SELECT cars.Model, (engine_specs.Horsepower / dimensions.Curb_Weight) AS Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123 ORDER BY Power_to_Weight_Ratio DESC LIMIT 5;	car	2
SELECT AVG(Cargo_Capacity) AS Avg_Cargo_Capacity FROM cars WHERE Year = 2020 AND Seating_Capacity > 5;	car	3
SELECT 1000.0 / 10000.0 AS Energy_Consumption_Per_km; SELECT * FROM cars WHERE Battery_Capacity / Range < (1000.0 / 10000.0);	car	4
SELECT c.Model, e.Horsepower, (0.5 * 1.225 * ((p.Top_Speed / 3.6) * (p.Top_Speed / 3.6)) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Corolla';	car	1
SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'A certain manufacturer' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;	car	2
SELECT c.Model, (1.0 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1.0 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = 'Corolla';	car	3
SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = 'Corolla';	car	4
SELECT ((100 / Fuel_Efficiency_City) + (200 / Fuel_Efficiency_Highway)) * 8.9 AS Total_Energy_Consumption FROM cars WHERE Car_ID = '1';	car	1
SELECT c.Model, AVG(e.Horsepower / d.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN dimensions d ON c.Car_ID = d.Car_ID WHERE c.Manufacturer_ID = 1 GROUP BY c.Model ORDER BY Avg_Power_to_Weight_Ratio DESC LIMIT 5;	car	2
SELECT Model FROM cars WHERE Year = 2020 AND Fuel_Tank_Capacity > 50 AND Fuel_Efficiency_City < 10 ORDER BY Production_Volume DESC;	car	3
SELECT (1000 / 0.1) AS Fuel_Consumption, (1000 / 0.1) * 2.31 AS CO2_Emissions;	car	4
SELECT Model, ((Fuel_Efficiency_City * 0.9 - Fuel_Efficiency_City) / Fuel_Efficiency_City) * 100 AS City_Efficiency_Change_Percent, ((Fuel_Efficiency_Highway * 0.9 - Fuel_Efficiency_Highway) / Fuel_Efficiency_Highway) * 100 AS Highway_Efficiency_Change_Percent FROM cars;	car	1
SELECT Model FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer') AND Production_Volume > (SELECT AVG(Production_Volume) FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer'));	car	2
SELECT m.Name, c.Model FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity < (e.Fuel_Consumption_City * 10);	car	3
SELECT c.Model, (p.Braking_Distance * (1000.0 * 1000.0) / (p.Top_Speed * p.Top_Speed)) AS Hypothetical_Braking_Distance FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID;	car	4
SELECT 0.5 * Weight * POWER((100 * 1000.0 / 3600.0), 2) AS Kinetic_Energy FROM cars WHERE Car_ID = 1;	car	1
SELECT Model, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2.0) AS Avg_Fuel_Efficiency FROM cars WHERE Manufacturer_ID = 1 GROUP BY Model ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;	car	2
SELECT Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Car_ID = 1;	car	3
SELECT Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs WHERE Car_ID = 1;	car	4
SELECT Model, 0.5 * Weight * ((Top_Speed * 1000.0 / 3600.0) * (Top_Speed * 1000.0 / 3600.0)) AS Kinetic_Energy FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID ORDER BY Kinetic_Energy DESC LIMIT 1;	car	1
SELECT manufacturers.Name, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2.0) AS Avg_Fuel_Efficiency FROM cars JOIN manufacturers ON cars.Manufacturer_ID = manufacturers.Manufacturer_ID GROUP BY manufacturers.Name ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;	car	2
SELECT c.Model, c.Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID ORDER BY City_Range DESC, Highway_Range DESC LIMIT 1;	car	3
SELECT cars.Model, Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs JOIN cars ON engine_specs.Car_ID = cars.Car_ID ORDER BY Fuel_Consumption DESC LIMIT 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE Weight = 1500;	car	1
SELECT Fuel_Efficiency_City, Fuel_Tank_Capacity FROM cars WHERE Fuel_Efficiency_City = 10 AND Fuel_Tank_Capacity = 50;	car	2
SELECT Cargo_Capacity FROM cars WHERE Cargo_Capacity = 500;	car	3
SELECT Max_RPM, Horsepower FROM engine_specs WHERE Max_RPM = 10000;	car	4
SELECT Weight, Acceleration_0_to_100 FROM performance_metrics JOIN cars ON performance_metrics.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE cars.Car_ID = 1;	car	2
SELECT (dimensions.Cargo_Capacity + dimensions.Trunk_Capacity) / 50 AS Max_Cargo_Items FROM dimensions JOIN cars ON dimensions.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;	car	3
SELECT "Range" * (1000.0 / "Battery_Capacity") AS New_Range FROM cars WHERE Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue FROM manufacturers WHERE Manufacturer_ID = 1;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT cars.Car_ID, (cars.Battery_Capacity * 1000.0) / (500.0 * performance_metrics.Top_Speed) AS Max_Speed_Range_Time FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT (Annual_Sales * Profit_Margin * Average_Price / 100) AS Total_Profit FROM manufacturers WHERE Name = 'BMW';	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT c.Battery_Capacity, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;	car	4
SELECT (100 * 1000 / 3600) / 8 AS average_acceleration FROM cars WHERE Weight = 1500;	car	1
SELECT (Fuel_Tank_Capacity * Fuel_Efficiency_City * 0.5) + (Fuel_Tank_Capacity * Fuel_Efficiency_Highway * 0.5) AS total_range FROM cars WHERE Car_ID = 1;	car	2
SELECT Maintenance_Cost * 5 AS total_maintenance_cost, Base_Price * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) * (1 - Depreciation_Rate) AS depreciated_value FROM prices WHERE Car_ID = 1;	car	3
SELECT (100000 / Battery_Capacity) * "Range" AS extended_range FROM cars WHERE Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue, SUM(Annual_Sales) AS Total_Sales, SUM(Annual_Sales * Average_Price) / SUM(Annual_Sales) AS Average_Price_Per_Car FROM manufacturers WHERE Manufacturer_ID = 1;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT Max_RPM, Cylinder_Count FROM engine_specs WHERE Car_ID = 1;	car	4
SELECT (0.5 * Weight * POWER(27.78, 2)) / Acceleration_0_to_100 AS Average_Power FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;	car	1
SELECT cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_City / 100.0) AS City_Distance, cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_Highway / 100.0) AS Highway_Distance FROM cars JOIN engine_specs ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Car_ID = 1;	car	2
SELECT Cargo_Capacity * 1 AS Max_Cargo_Weight FROM dimensions WHERE Cargo_Capacity = 500 AND Trunk_Capacity = 300;	car	3
SELECT Max_RPM / 2 * Cylinder_Count AS Combustion_Per_Minute FROM engine_specs WHERE Displacement = 2.0 AND Max_RPM = 8000 AND Cylinder_Count = 4 AND Compression_Ratio = 10;	car	4
SELECT c.Weight, pm.Braking_Distance, sf.Brake_Assist_Response_Time, es.Torque FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID JOIN safety_features sf ON c.Car_ID = sf.Car_ID JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Car_ID = 1;	car	1
SELECT c.Fuel_Tank_Capacity, c.Battery_Capacity, pm.Range_Hybrid, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;	car	2
SELECT c.Seating_Capacity, d.Trunk_Capacity, d.Cargo_Capacity FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID WHERE c.Car_ID = 1;	car	3
SELECT es.Max_RPM, es.Cylinder_Count, c.Fuel_Tank_Capacity, es.Fuel_Consumption_Highway FROM engine_specs es JOIN cars c ON es.Car_ID=c.Car_ID JOIN performance_metrics pm ON c.Car_ID=pm.Car_ID WHERE c.Car_ID=123;	car	4
SELECT e.Horsepower, p.Top_Speed, d.Length, d.Width, d.Curb_Weight FROM engine_specs e JOIN performance_metrics p ON e.Car_ID = p.Car_ID JOIN dimensions d ON e.Car_ID = d.Car_ID WHERE e.Car_ID = 123;	car	1
SELECT c.Model, c.Production_Volume, p.Total_Price, m.Profit_Margin FROM cars c JOIN prices p ON c.Car_ID = p.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Manufacturer_ID = 123 ORDER BY c.Production_Volume DESC LIMIT 5;	car	2
SELECT c.Fuel_Tank_Capacity, c.Fuel_Efficiency_Highway FROM cars c WHERE c.Car_ID = 123;	car	3
SELECT s.Airbag_Count, d.Curb_Weight, p.Braking_Distance FROM safety_features s JOIN dimensions d ON s.Car_ID = d.Car_ID JOIN performance_metrics p ON s.Car_ID = p.Car_ID WHERE s.Car_ID = 123;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;	car	1
SELECT Revenue, Revenue * (Profit_Margin / 100.0) AS Total_Profit, `R&D_Spending` / CAST(Production_Volume_Total AS REAL) AS Avg_RD_Per_Car FROM manufacturers WHERE Production_Volume_Total = 500000 AND Annual_Sales = 450000 AND `R&D_Spending` = 200000000 AND Profit_Margin = 8;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Fuel_Tank_Capacity = 60 AND Fuel_Efficiency_City = 10 AND Fuel_Efficiency_Highway = 15;	car	3
SELECT Max_RPM, Torque FROM engine_specs WHERE Max_RPM = 10000 AND Torque = 500;	car	4
SELECT ROUND(0.5 * d.Curb_Weight * POWER(p.Top_Speed/3.6, 2)) AS KineticEnergy_J FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID WHERE p.Top_Speed = 240 AND d.Curb_Weight = 1800;	car	1
SELECT (m.Production_Volume_Total * m.Average_Price * 0.85 * m.Profit_Margin / 100) AS NetProfit FROM manufacturers m WHERE m.Name = 'BMW' AND m.Production_Volume_Total = 100000 AND m.Average_Price = 35000;	car	2
SELECT s.ABS_Effectiveness, p.Braking_Distance, ROUND((p.Braking_Distance / (s.ABS_Effectiveness / 100.0) * 1.3) - p.Braking_Distance, 1) AS RainIncrease_m FROM safety_features s JOIN performance_metrics p USING(Car_ID) WHERE s.ABS_Effectiveness = 95 AND p.Braking_Distance = 40;	car	3
SELECT e.Displacement, e.Cylinder_Count, (e.Displacement * e.Max_RPM * e.Cylinder_Count * 1.2 * 60)/1000 AS TheoreticalFuel_L_h FROM engine_specs e WHERE e.Displacement = 100 AND e.Cylinder_Count = 16 AND e.Max_RPM = 6000;	car	4
SELECT (0.5 * 1.225 * pm.Drag_Coefficient * 2.3 * (POWER((pm.Top_Speed*1000/3600),3))) AS Air_Power FROM performance_metrics pm JOIN dimensions d ON pm.Car_ID = d.Car_ID WHERE pm.Top_Speed = 210 AND d.Curb_Weight = 1500 AND pm.Drag_Coefficient = 0.28 LIMIT 1;	car	1
SELECT ((1800 * 9.8 * 0.015 + 0.5 * 1.225 * 0.3 * 2.5 * POWER(120 / 3.6, 2)) * 100000) * 500 AS Total_Energy FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' GROUP BY m.Name LIMIT 1;	car	2
SELECT (c.Fuel_Tank_Capacity * 0.15 / es.Fuel_Consumption_Highway) * 100 AS Remaining_Range FROM cars c JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Fuel_Tank_Capacity = 60 AND es.Fuel_Consumption_Highway = 6.5 AND c.Battery_Capacity IS NULL LIMIT 1;	car	3
SELECT (99999/(15/100))/40075 AS Theoretical_Laps FROM cars c JOIN dimensions d ON c.Car_ID = d.Car_ID JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Battery_Capacity IS NOT NULL AND d.Curb_Weight = 2000 AND pm.Drag_Coefficient = 0.21 LIMIT 1;	car	4
SELECT d.Curb_Weight, p.Top_Speed, 0.5 * d.Curb_Weight * (p.Top_Speed/3.6) * (p.Top_Speed/3.6) AS Kinetic_Energy_J FROM dimensions d JOIN performance_metrics p ON d.Car_ID = p.Car_ID JOIN engine_specs e ON d.Car_ID = e.Car_ID WHERE e.Displacement > 0 AND e.Fuel_Consumption_Highway > 0;	car	1
SELECT pr.Base_Price, pr.Maintenance_Cost, pr.Depreciation_Rate, pr.Insurance_Cost, pr.Tax_Rate, (pr.Total_Price*(1+pr.Tax_Rate/100)) + (pr.Maintenance_Cost*5) + (pr.Base_Price*(1-POW(1-pr.Depreciation_Rate/100,5))) - pr.Insurance_Cost AS Total_5yr_Cost FROM prices pr JOIN cars c ON pr.Car_ID = c.Car_ID WHERE c.Range IS NOT NULL;	car	2
SELECT c.Model, c.Fuel_Tank_Capacity, e.Fuel_Consumption_City, (c.Fuel_Tank_Capacity * (100.0 / e.Fuel_Consumption_City)) AS City_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity > 0 AND e.Fuel_Consumption_City > 0;	car	3
SELECT c.Model, e.Displacement, c.Fuel_Tank_Capacity, e.Fuel_Consumption_Highway, (c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway) * 100000 AS Absurd_Range_m FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE e.Displacement >= 20 AND c.Fuel_Tank_Capacity <= 2 AND e.Fuel_Consumption_Highway >= 50;	car	4
SELECT (e.Torque * (s.ESC_Effectiveness / 100.0)) / (d.Curb_Weight * 0.3) AS Acceleration FROM engine_specs e JOIN dimensions d ON e.Car_ID = d.Car_ID JOIN safety_features s ON e.Car_ID = s.Car_ID WHERE e.Torque = 450 AND d.Curb_Weight = 1500 AND s.ESC_Effectiveness = 95;	car	1
SELECT (8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1))) AS Combined_Fuel, 60 / ((8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1)))/100) AS "Range";	car	2
SELECT (SUM(Airbag_Count * Crash_Test_Rating) - (SUM(Airbag_Count) * SUM(Crash_Test_Rating)) / COUNT(*)) / (COUNT(*) * (SUM(Airbag_Count * Airbag_Count) - (SUM(Airbag_Count) * SUM(Airbag_Count)) / COUNT(*))) AS Correlation FROM safety_features;	car	3
SELECT e.Horsepower / d.Curb_Weight AS Power_Ratio, (100/3.6) / ((e.Horsepower / d.Curb_Weight) * 745.7 / (100/3.6)) AS Acceleration_Time FROM engine_specs e JOIN dimensions d USING(Car_ID) WHERE e.Horsepower = 100000 AND d.Curb_Weight = 1;	car	4
SELECT p.Top_Speed, d.Width, d.Height, 0.5 * 1.225 * p.Drag_Coefficient * (d.Width * d.Height) * (p.Top_Speed/3.6 * p.Top_Speed/3.6) AS Air_Resistance_Newtons FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID JOIN cars c ON p.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' AND c.Model = 'Tesla Model S';	car	1
SELECT SUM(e.CO2_Emissions * m.Annual_Sales * 15000 / 1000000) AS Total_CO2_Tonnes FROM manufacturers m JOIN cars c ON m.Manufacturer_ID = c.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE m.Name = 'Tesla';	car	2
SELECT d.Curb_Weight, d.Cargo_Capacity, (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) AS Total_Weight, CASE WHEN (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) <= 2500 THEN 'safe' ELSE 'overweight' END AS Safety_Status FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID WHERE c.Model = 'Tesla Model S';	car	3
SELECT p.Power_to_Weight_Ratio, c.Weight, (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) AS G_Force, CASE WHEN (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) > 3 THEN 'exceeds' ELSE 'does not exceed' END AS Comparison FROM performance_metrics p JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S';	car	4
SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Tesla Model S';	car	1
SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2.0 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;	car	2
SELECT c.Model, (1.0 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1.0 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = 'Tesla Model S';	car	3
SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = 'Tesla Model S';	car	4
SELECT c.Model, e.Torque, (0.015 * c.Weight * 9.81) AS Rolling_Resistance FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Tesla Model S';	car	1
SELECT c.Model, AVG(e.CO2_Emissions) AS Avg_CO2_Emissions FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' GROUP BY c.Model ORDER BY Avg_CO2_Emissions ASC LIMIT 3;	car	2
SELECT c.Model, (1.0 / c.Fuel_Efficiency_City) * 2.31 AS City_CO2_Per_KM, (1.0 / c.Fuel_Efficiency_Highway) * 2.31 AS Highway_CO2_Per_KM FROM cars c WHERE c.Model = 'Tesla Model S';	car	3
SELECT c.Model, 5000 / 0.1 AS Theoretical_Range FROM cars c WHERE c.Model = 'Tesla Model S';	car	4
SELECT Car_ID, Model, (100.0 / Fuel_Efficiency_City) + (100.0 / Fuel_Efficiency_Highway) AS Total_Fuel_Consumption FROM cars;	car	1
SELECT d.Car_ID, c.Model, d.Gross_Weight * 1.0 / d.Curb_Weight AS Weight_Ratio FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID ORDER BY Weight_Ratio DESC LIMIT 5;	car	2
SELECT Car_ID, Model, (Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars WHERE Year = 2020 ORDER BY Avg_Fuel_Efficiency DESC LIMIT 10;	car	3
SELECT Car_ID, Model, 10000 / 1 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 1;	car	4
SELECT p.Car_ID, c.Model, p.Power_to_Weight_Ratio  FROM performance_metrics p  JOIN cars c ON p.Car_ID = c.Car_ID  ORDER BY p.Power_to_Weight_Ratio DESC  LIMIT 5;	car	1
SELECT e.Car_ID, c.Model, (e.Fuel_Consumption_City * 100.0 / 100.0) * e.CO2_Emissions + (e.Fuel_Consumption_Highway * 100.0 / 100.0) * e.CO2_Emissions AS Total_CO2_Emissions FROM engine_specs e JOIN cars c ON e.Car_ID = c.Car_ID;	car	2
SELECT s.Car_ID, c.Model, s.Airbag_Count FROM safety_features s JOIN cars c ON s.Car_ID = c.Car_ID WHERE c.Year = 2020 ORDER BY s.Airbag_Count DESC LIMIT 10;	car	3
SELECT Car_ID, Model, 10000 / 0.5 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 0.5;	car	4
SELECT deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = solar ORDER BY deviceName ASC;	EnergyManagementDB	1
SELECT deviceId, SUM(energySaved) AS totalEnergySaved FROM EnergyEfficiency WHERE timestamp >= date('now', '-1 year') GROUP BY deviceId ORDER BY totalEnergySaved DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceId, deviceName, lastMaintenanceDate FROM EnergyDevices WHERE status = 'operating' AND lastMaintenanceDate < date('now', '-1 year') ORDER BY deviceName ASC;	EnergyManagementDB	3
SELECT deviceId, deviceName, (powerRating * 24 * 365) AS totalEnergySaved FROM EnergyDevices ORDER BY totalEnergySaved DESC LIMIT 10;	EnergyManagementDB	4
SELECT SUM(ed.powerRating * ed.efficiency / 100 * ec.energyConsumed) AS totalEnergyGenerated  FROM EnergyDevices ed  JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId  JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId  WHERE m.manufacturerName = 'SolarTech' AND ed.deviceType = 'solar';	EnergyManagementDB	1
WITH ManufacturerB_Consumption AS (     SELECT AVG(ec.energyConsumed) AS avg_energy_consumed      FROM EnergyConsumption ec      JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'B'      AND ed.deviceType = 'wind'      AND ec.timestamp >= date('now', '-1 year') ),  ManufacturerC_Consumption AS (     SELECT AVG(ec.energyConsumed) AS avg_energy_consumed      FROM EnergyConsumption ec      JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'C'      AND ed.deviceType = 'wind'      AND ec.timestamp >= date('now', '-1 year') )  SELECT      (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) AS avg_energy_consumed_B,      (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS avg_energy_consumed_C,      (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) - (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS energy_consumption_difference;	EnergyManagementDB	2
SELECT winter.avg_winter_consumption AS Winter_Avg_Consumption, summer.avg_summer_consumption AS Summer_Avg_Consumption, (winter.avg_winter_consumption - summer.avg_summer_consumption) AS Consumption_Difference FROM (SELECT AVG(ec.energyConsumed) AS avg_winter_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND strftime('%m', ec.timestamp) IN ('12', '01', '02')) AS winter, (SELECT AVG(ec.energyConsumed) AS avg_summer_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND strftime('%m', ec.timestamp) IN ('06', '07', '08')) AS summer;	EnergyManagementDB	3
WITH CurrentProfitMargin AS (   SELECT (profit * 1.0 / revenue) * 100 AS profitMargin    FROM Manufacturers    WHERE manufacturerName = 'WindPower' ),  FutureProfit AS (   SELECT 1000000 * (profitMargin / 100) AS futureProfit    FROM CurrentProfitMargin )  SELECT futureProfit  FROM FutureProfit;	EnergyManagementDB	4
WITH DeviceConsumption AS (     SELECT          ec.deviceId,          SUM(ec.energyConsumed) AS totalEnergyConsumed,          AVG(ec.powerUsage) AS avgPowerUsage,          AVG(ec.voltage) AS avgVoltage,          AVG(ec.current) AS avgCurrent      FROM EnergyConsumption ec      WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'      GROUP BY ec.deviceId )  SELECT      dc.deviceId,      dc.totalEnergyConsumed,      dc.avgPowerUsage,      dc.avgVoltage,      dc.avgCurrent,      (dc.avgPowerUsage / (dc.avgVoltage * dc.avgCurrent)) AS powerFactor  FROM DeviceConsumption dc  WHERE dc.deviceId = '1';	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= date('now', '-1 year') GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	2
SELECT hc.deviceId, ed.deviceName, hc.highHumidityEnergy, hc.lowHumidityEnergy, (hc.highHumidityEnergy - hc.lowHumidityEnergy) * 100.0 / hc.lowHumidityEnergy AS energyChangeRate FROM (SELECT deviceId, MAX(CASE WHEN humidity = (SELECT MAX(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS highHumidityEnergy, MAX(CASE WHEN humidity = (SELECT MIN(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS lowHumidityEnergy FROM (SELECT deviceId, humidity, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption GROUP BY deviceId, humidity) AS he GROUP BY deviceId) AS hc JOIN EnergyDevices ed ON hc.deviceId = ed.deviceId;	EnergyManagementDB	3
WITH ExtremePower AS (     SELECT deviceId, deviceName, powerRating * 10 AS extremePower, powerRating      FROM EnergyDevices      WHERE deviceId = 11 ),  ExtremeEnergyConsumption AS (     SELECT          ep.deviceId,          ep.deviceName,          ep.extremePower,          ep.powerRating,          ec.timestamp,          ec.energyConsumed,          ec.powerUsage,          ec.voltage,          ec.current,          ec.temperature,          ec.humidity,          ec.dataQuality,          ep.extremePower *          (julianday(ec.timestamp) - julianday(LAG(ec.timestamp) OVER (PARTITION BY ec.deviceId ORDER BY ec.timestamp))) * 24 AS extremeEnergyConsumed      FROM EnergyConsumption ec      JOIN ExtremePower ep ON ec.deviceId = ep.deviceId )  SELECT      eec.deviceId,      eec.deviceName,      eec.extremePower,      eec.powerRating,      eec.timestamp,      eec.energyConsumed,      eec.powerUsage,      eec.voltage,      eec.current,      eec.temperature,      eec.humidity,      eec.dataQuality,      eec.extremeEnergyConsumed,      eec.extremeEnergyConsumed / 100 AS gridImpact  FROM ExtremeEnergyConsumption eec;	EnergyManagementDB	4
WITH DeviceCarbonFootprint AS (     SELECT          ec.deviceId,          SUM(ec.energyConsumed * ef.carbonFootprint) AS totalCarbonEmission      FROM          EnergyConsumption ec      JOIN          EnvironmentalImpact ef      ON          ec.deviceId = ef.deviceId AND ec.timestamp = ef.timestamp      WHERE          ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'      GROUP BY          ec.deviceId )  SELECT      dcf.deviceId,      ed.deviceName,      dcf.totalCarbonEmission  FROM      DeviceCarbonFootprint dcf  JOIN      EnergyDevices ed  ON      dcf.deviceId = ed.deviceId  ORDER BY      dcf.totalCarbonEmission DESC  LIMIT 1;	EnergyManagementDB	1
SELECT ae.deviceId, ae.avgEfficiency  FROM (     SELECT deviceId, AVG(efficiency) AS avgEfficiency      FROM EnergyEfficiency      WHERE timestamp >= date('now', '-1 year')      GROUP BY deviceId ) AS ae  JOIN (     SELECT AVG(efficiency) AS overallAvgEfficiency      FROM EnergyEfficiency      WHERE timestamp >= date('now', '-1 year') ) AS oa  WHERE ae.avgEfficiency < oa.overallAvgEfficiency;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.powerRating, ed.efficiency, ed.installationDate, ed.status, ed.location, ed.manufacturerId, ed.lastMaintenanceDate, ed.nextMaintenanceDate FROM EnergyDevices ed WHERE ed.deviceId NOT IN (SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= date('now', '-1 year'))	EnergyManagementDB	3
DROP TABLE IF EXISTS NormalImpact;  DROP TABLE IF EXISTS ExtremeImpact;  CREATE TEMPORARY TABLE NormalImpact AS  SELECT deviceId,         AVG(carbonFootprint) AS avgCarbonFootprint,         AVG(pollutionLevel) AS avgPollutionLevel,         AVG(waterUsage) AS avgWaterUsage,         AVG(landUsage) AS avgLandUsage  FROM EnvironmentalImpact  GROUP BY deviceId;  CREATE TEMPORARY TABLE ExtremeImpact AS  SELECT deviceId,         avgCarbonFootprint * 100 AS extremeCarbonFootprint,         avgPollutionLevel * 100 AS extremePollutionLevel,         avgWaterUsage * 100 AS extremeWaterUsage,         avgLandUsage * 100 AS extremeLandUsage  FROM NormalImpact;  SELECT deviceId,         CASE             WHEN extremeCarbonFootprint = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'carbonFootprint'             WHEN extremePollutionLevel = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'pollutionLevel'             WHEN extremeWaterUsage = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'waterUsage'             WHEN extremeLandUsage = MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'landUsage'         END AS maxImpactIndicator,         MAX(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) AS maxImpactValue  FROM ExtremeImpact;  DROP TABLE IF EXISTS NormalImpact;  DROP TABLE IF EXISTS ExtremeImpact;	EnergyManagementDB	4
SELECT deviceId, deviceName, powerRating * efficiency / 100 AS P_actual FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY P_actual DESC LIMIT 5;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ee.energySaved) * 0.5 AS total_cost_savings  FROM EnergyEfficiency ee  JOIN EnergyDevices ed ON ee.deviceId = ed.deviceId  WHERE ee.timestamp >= date('now', '-1 year')  GROUP BY ed.deviceId, ed.deviceName  ORDER BY total_cost_savings DESC  LIMIT 10;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency  FROM EnergyDevices ed  JOIN EnergyPolicies ep ON ed.efficiency < ep.targetEfficiency  ORDER BY ed.efficiency ASC  LIMIT 10;	EnergyManagementDB	3
SELECT deviceId, deviceName, powerRating * 1.0 AS P_actual FROM EnergyDevices ORDER BY P_actual DESC LIMIT 5;	EnergyManagementDB	4
SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY TotalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= datetime('now', '-1 year') GROUP BY ed.deviceType;	EnergyManagementDB	2
WITH MaintenanceCosts AS (     SELECT          deviceId,          SUM(cost) AS totalMaintenanceCost,          COUNT(*) AS maintenanceFrequency,          GROUP_CONCAT(partsReplaced, ', ') AS partsReplacedList      FROM MaintenanceRecords      GROUP BY deviceId )  SELECT      ED.deviceId,      ED.deviceName,      ED.deviceType,      MC.totalMaintenanceCost,      MC.maintenanceFrequency,      MC.partsReplacedList  FROM EnergyDevices ED  JOIN MaintenanceCosts MC ON ED.deviceId = MC.deviceId  ORDER BY MC.totalMaintenanceCost DESC  LIMIT 1;	EnergyManagementDB	3
WITH DeviceEnergy AS (   SELECT      deviceId,      1000000 AS powerRating,      8760 AS hoursInYear,      1000000 * 8760 AS totalEnergyConsumed    FROM      EnergyDevices    WHERE      deviceId = 12345  ),  EnvironmentalImpactAnalysis AS (   SELECT      deviceId,      totalEnergyConsumed,      totalEnergyConsumed * 0.85 AS carbonFootprint,      totalEnergyConsumed * 0.001 AS waterUsage,      totalEnergyConsumed * 0.0001 AS landUsage    FROM      DeviceEnergy  )  SELECT    DE.deviceId,    DE.powerRating,    DE.totalEnergyConsumed,    EIA.carbonFootprint,    EIA.waterUsage,    EIA.landUsage  FROM    DeviceEnergy DE  JOIN    EnvironmentalImpactAnalysis EIA  ON    DE.deviceId = EIA.deviceId;	EnergyManagementDB	4
SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
WITH DeviceEfficiency AS (     SELECT deviceId, AVG(efficiency) AS avgEfficiency      FROM EnergyEfficiency      WHERE timestamp BETWEEN '2023-01-01' AND '2023-12-31'      GROUP BY deviceId ),  OverallAverageEfficiency AS (     SELECT AVG(avgEfficiency) AS overallAvgEfficiency      FROM DeviceEfficiency )  SELECT de.deviceId, de.avgEfficiency  FROM DeviceEfficiency de  CROSS JOIN OverallAverageEfficiency oae  WHERE de.avgEfficiency < oae.overallAvgEfficiency;	EnergyManagementDB	2
SELECT SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.temperature > 30;	EnergyManagementDB	3
WITH DeviceEnergy AS (   SELECT deviceId, 1000000 AS powerRating, 8760 AS hoursInYear    FROM EnergyDevices    WHERE deviceId = 123 )  SELECT    de.deviceId,    de.powerRating * de.hoursInYear AS totalEnergyConsumed,    ei.carbonFootprint,    ei.pollutionLevel,    ei.waterUsage,    ei.landUsage  FROM DeviceEnergy de  JOIN EnvironmentalImpact ei ON de.deviceId = ei.deviceId  WHERE ei.timestamp = (   SELECT MAX(timestamp)    FROM EnvironmentalImpact    WHERE deviceId = de.deviceId );	EnergyManagementDB	4
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) / ((JULIANDAY(MAX(ec.timestamp)) - JULIANDAY(MIN(ec.timestamp))) * 24) AS averagePowerOutput FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY averagePowerOutput DESC LIMIT 1;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ef.forecastValue) AS totalEnergyGenerated, (SUM(ec.energyConsumed) / SUM(ef.forecastValue)) AS energyConsumptionToGenerationRatio FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyForecasts ef ON ed.deviceId = ef.deviceId WHERE ed.deviceType = 'wind' AND ef.forecastType = '5000000.00' GROUP BY ed.deviceId, ed.deviceName ORDER BY energyConsumptionToGenerationRatio ASC;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency  FROM EnergyDevices ed  JOIN EnergyPolicies ep  WHERE ed.installationDate >= '2022-01-01' AND ed.installationDate <= '2022-12-31' AND ed.efficiency < ep.targetEfficiency  ORDER BY ed.efficiency DESC;	EnergyManagementDB	3
WITH DeviceEfficiency AS (   SELECT deviceId, 100 AS efficiency    FROM EnergyDevices ),  TotalEnergy AS (   SELECT      ec.deviceId,      SUM(ec.energyConsumed) AS totalEnergyConsumed,      SUM(ec.energyConsumed / (de.efficiency / 100.0)) AS totalEnergyGenerated    FROM EnergyConsumption ec    JOIN DeviceEfficiency de ON ec.deviceId = de.deviceId    GROUP BY ec.deviceId )  SELECT    te.deviceId,    (te.totalEnergyConsumed / te.totalEnergyGenerated) AS energyRatio  FROM TotalEnergy te  ORDER BY energyRatio ASC;	EnergyManagementDB	4
WITH SolarDeviceEfficiency AS (     SELECT deviceId, efficiency      FROM EnergyDevices      WHERE deviceType = 'solar' ) SELECT      AVG(efficiency) AS average_efficiency,     (SELECT deviceId FROM SolarDeviceEfficiency ORDER BY efficiency DESC LIMIT 1) AS most_efficient_device  FROM SolarDeviceEfficiency;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ed.powerRating * ed.efficiency * ec.energyConsumed) AS totalEnergySaved FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp >= date('now', '-1 year') GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergySaved DESC;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.powerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed  FROM EnergyDevices ed  JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId  WHERE strftime('%Y', ed.installationDate) = '2022'  GROUP BY ed.deviceId, ed.deviceName, ed.powerRating;	EnergyManagementDB	3
WITH DeviceEnergySavings AS (   SELECT      ed.deviceId,      ed.deviceName,      ed.powerRating * (100 - ed.efficiency) / 100 * 365 * 24 AS energySaved    FROM EnergyDevices ed )  SELECT    des.deviceId,    des.deviceName,    des.energySaved  FROM DeviceEnergySavings des  ORDER BY des.energySaved DESC  LIMIT 1;	EnergyManagementDB	4
SELECT deviceId, deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceId ASC;	EnergyManagementDB	1
SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption WHERE timestamp >= date('now', '-1 year') GROUP BY deviceId ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceId, COUNT(maintenanceId) AS maintenanceCount FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenanceCount DESC;	EnergyManagementDB	3
SELECT deviceId, SUM(energySaved * (100.0 / efficiency)) AS totalEnergySaved FROM EnergyEfficiency WHERE efficiency < 100 GROUP BY deviceId ORDER BY totalEnergySaved DESC;	EnergyManagementDB	4
SELECT (1000 * 2 * 0.20 * 24) / 1000 AS daily_energy_output_kWh;	EnergyManagementDB	1
SELECT 0.5 * 1.225 * 3.141592653589793 * POWER(30, 2) * POWER(12, 3) * 0.4 / 1000 AS output_power_kw;	EnergyManagementDB	2
SELECT deviceId, deviceName, powerRating * 8 * 30 AS totalEnergyConsumed, powerRating * 8 * 30 * 0.5 AS totalCost FROM EnergyDevices;	EnergyManagementDB	3
SELECT 0.5 * 1.225 * PI() * POWER(1000, 2) * POWER(50, 3) * 0.4 / 1000 AS output_power_kw;	EnergyManagementDB	4
WITH ManufacturerDevices AS (     SELECT ed.deviceId, ed.efficiency      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'SolarTech' ),  AverageEfficiency AS (     SELECT AVG(efficiency) AS avgEfficiency      FROM ManufacturerDevices )  SELECT md.deviceId, md.efficiency  FROM ManufacturerDevices md, AverageEfficiency ae  WHERE md.efficiency < ae.avgEfficiency;	EnergyManagementDB	1
WITH ManufacturerDevices AS (     SELECT ed.deviceId      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'SolarTech' ), TotalEnergyConsumption AS (     SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed      FROM EnergyConsumption ec      WHERE ec.deviceId IN (SELECT deviceId FROM ManufacturerDevices)      GROUP BY ec.deviceId ) SELECT tec.deviceId, tec.totalEnergyConsumed  FROM TotalEnergyConsumption tec  ORDER BY tec.totalEnergyConsumed DESC  LIMIT 1;	EnergyManagementDB	2
WITH ManufacturerDevices AS (     SELECT ed.deviceId, ed.deviceName, ed.manufacturerId      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'SolarTech' ),  AverageMaintenanceCost AS (     SELECT AVG(mr.cost) AS avgCost      FROM MaintenanceRecords mr      JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId )  SELECT md.deviceId, md.deviceName, mr.cost  FROM MaintenanceRecords mr  JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId  CROSS JOIN AverageMaintenanceCost amc  WHERE mr.cost > amc.avgCost;	EnergyManagementDB	3
WITH IncreasedPower AS (     SELECT          deviceId,          powerRating * 1000 AS increasedPowerRating      FROM EnergyDevices      WHERE manufacturerId = '1' )  SELECT      ec.deviceId,      SUM(ec.energyConsumed * ip.increasedPowerRating) AS totalEnergyConsumed  FROM EnergyConsumption ec  JOIN IncreasedPower ip ON ec.deviceId = ip.deviceId  GROUP BY ec.deviceId  ORDER BY totalEnergyConsumed DESC  LIMIT 1;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed) / (MAX(ec.timestamp) - MIN(ec.timestamp)) AS averagePowerUsage FROM EnergyConsumption ec WHERE ec.deviceId = '1' AND ec.timestamp BETWEEN '2023-06-15' AND '2023-12-15' GROUP BY ec.deviceId;	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= date('now','-1 year') GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	2
SELECT CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END AS humidity_level, SUM(energyConsumed) AS total_energy_consumed FROM EnergyConsumption GROUP BY humidity_level;	EnergyManagementDB	3
WITH TimeDifferences AS (   SELECT      deviceId,      timestamp,      powerUsage,      (LEAD(timestamp) OVER (PARTITION BY deviceId ORDER BY timestamp) - timestamp) AS timeDiff    FROM EnergyConsumption ),  ExtremeEnergyConsumption AS (   SELECT      deviceId,      SUM(powerUsage * 10 * (timeDiff / 3600.0)) AS extremeEnergyConsumed    FROM TimeDifferences    WHERE timeDiff IS NOT NULL    GROUP BY deviceId ),  EnvironmentalImpactAnalysis AS (   SELECT      ei.deviceId,      SUM(ei.carbonFootprint) AS totalCarbonFootprint    FROM EnvironmentalImpact ei    JOIN EnergyConsumption ec ON ei.deviceId = ec.deviceId    GROUP BY ei.deviceId )  SELECT    eec.deviceId,    eec.extremeEnergyConsumed,    eia.totalCarbonFootprint  FROM ExtremeEnergyConsumption eec  JOIN EnvironmentalImpactAnalysis eia ON eec.deviceId = eia.deviceId;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, ei.carbonFootprint AS carbonFootprintCoefficient, SUM(ec.energyConsumed) * ei.carbonFootprint AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ei ON ec.deviceId = ei.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' AND ec.deviceId = '1' GROUP BY ec.deviceId, ei.carbonFootprint;	EnergyManagementDB	1
WITH DeviceEfficiency AS (   SELECT      ed.deviceId,      ed.deviceType,      AVG(ee.efficiency) AS avgEfficiency    FROM EnergyDevices ed    JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId    WHERE ee.timestamp >= date('now', '-1 year')    GROUP BY ed.deviceId, ed.deviceType  )  SELECT    deviceType,    AVG(avgEfficiency) AS avgEfficiencyByType  FROM DeviceEfficiency  GROUP BY deviceType;	EnergyManagementDB	2
SELECT ec.deviceId, AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) AS high_humidity_energy, AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END) AS low_humidity_energy, (AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) - AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END)) AS energy_change FROM EnergyConsumption ec WHERE ec.deviceId = '1' GROUP BY ec.deviceId;	EnergyManagementDB	3
WITH AnnualEnergyConsumption AS (     SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed      FROM EnergyConsumption ec      WHERE ec.timestamp >= date('now', '-1 year')      GROUP BY ec.deviceId ),  CarbonFootprintAnalysis AS (     SELECT aec.deviceId, aec.totalEnergyConsumed,             aec.totalEnergyConsumed * (ei.carbonFootprint * 100) AS totalCarbonEmission,             ei.pollutionLevel, ei.waterUsage, ei.landUsage      FROM AnnualEnergyConsumption aec      JOIN EnvironmentalImpact ei ON aec.deviceId = ei.deviceId      WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = aec.deviceId) )  SELECT cfa.deviceId, cfa.totalEnergyConsumed, cfa.totalCarbonEmission,         cfa.pollutionLevel, cfa.waterUsage, cfa.landUsage,         CASE WHEN cfa.totalCarbonEmission > (SELECT AVG(totalCarbonEmission) FROM CarbonFootprintAnalysis)              THEN 'High Impact' ELSE 'Normal Impact' END AS environmentalImpact  FROM CarbonFootprintAnalysis cfa;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-12-31 23:59:59') - (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-01-01 00:00:00') AS efficiencyChange FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId;	EnergyManagementDB	1
SELECT deviceType, SUM(energySaved) AS totalEnergySaved, SUM(costSavings) AS totalCostSavings FROM EnergyEfficiency JOIN EnergyDevices ON EnergyEfficiency.deviceId = EnergyDevices.deviceId WHERE timestamp >= date('now', '-1 year') GROUP BY deviceType;	EnergyManagementDB	2
SELECT MR.deviceId, COUNT(MR.maintenanceDate) AS maintenanceFrequency, AVG(EE.efficiency) AS averageEfficiency FROM MaintenanceRecords MR JOIN EnergyEfficiency EE ON MR.deviceId = EE.deviceId GROUP BY MR.deviceId ORDER BY maintenanceFrequency, averageEfficiency;	EnergyManagementDB	3
SELECT ed.deviceId, ed.deviceName, ed.deviceType, (ee.energySaved * 10) AS annualEnergySaved, (ee.costSavings * 10) AS annualCostSavings, env.carbonFootprint, env.pollutionLevel FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId JOIN EnvironmentalImpact env ON ed.deviceId = env.deviceId WHERE ed.deviceId = 123;	EnergyManagementDB	4
WITH DeviceEnergy AS (     SELECT          ec.deviceId,          SUM(ec.energyConsumed) AS totalEnergyConsumed,          MIN(ee.efficiency) AS efficiency_start,          MAX(ee.efficiency) AS efficiency_end      FROM          EnergyConsumption ec      JOIN          EnergyEfficiency ee ON ec.deviceId = ee.deviceId      WHERE          ec.timestamp BETWEEN '2023-01-01' AND '2023-12-31'          AND ee.timestamp BETWEEN '2023-01-01' AND '2023-12-31'      GROUP BY          ec.deviceId )  SELECT      de.deviceId,      de.totalEnergyConsumed,      (de.efficiency_end - de.efficiency_start) * 100.0 / de.efficiency_start AS efficiency_change_percentage  FROM      DeviceEnergy de;	EnergyManagementDB	1
SELECT ed.deviceType, AVG(mr.cost) AS avgMaintenanceCost FROM MaintenanceRecords mr JOIN EnergyDevices ed ON mr.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech' GROUP BY ed.deviceType;	EnergyManagementDB	2
SELECT humidity_range, AVG(energyConsumed) AS avg_energy_consumed FROM (SELECT CASE WHEN humidity BETWEEN 0 AND 30 THEN '0-30%' WHEN humidity BETWEEN 31 AND 60 THEN '31-60%' WHEN humidity BETWEEN 61 AND 90 THEN '61-90%' ELSE '91-100%' END AS humidity_range, energyConsumed FROM EnergyConsumption WHERE deviceId = '1') AS subquery GROUP BY humidity_range ORDER BY humidity_range;	EnergyManagementDB	3
WITH DevicePower AS (     SELECT 1000000 AS powerRating ), TotalEnergyConsumed AS (     SELECT powerRating * 24 * 365 AS totalEnergyConsumed FROM DevicePower ), EnvironmentalImpact AS (     SELECT totalEnergyConsumed * (         SELECT AVG(carbonFootprint)          FROM EnvironmentalImpact          WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE powerRating = 1000000)     ) AS carbonFootprint      FROM TotalEnergyConsumed )  SELECT totalEnergyConsumed, carbonFootprint  FROM TotalEnergyConsumed, EnvironmentalImpact;	EnergyManagementDB	4
SELECT (800 * 2 * 0.20 * ((julianday('2023-10-01 12:00:00') - julianday('2023-10-01 00:00:00')) * 24)) / 1000 AS total_energy_output FROM EnergyDevices WHERE deviceType = 'solar';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;	EnergyManagementDB	2
SELECT 0.5 * 100000 AS total_carbon_footprint;	EnergyManagementDB	3
SELECT (2000 * 1000 * 1 * 24) / 1000 AS total_energy_output_kWh;	EnergyManagementDB	4
SELECT SUM((1000 * 2 * 0.2 * (strftime('%s', '2023-10-31 23:59:59') - strftime('%s', '2023-10-01 00:00:00')) / 3600.0)) AS total_energy_generated FROM EnergyConsumption WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE deviceName = 'Solar Panel') AND timestamp BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(80 / 2, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output;	EnergyManagementDB	2
SELECT powerRating * 8 * 365 AS totalEnergyConsumption FROM EnergyDevices WHERE deviceId = '1';	EnergyManagementDB	3
SELECT (powerRating * efficiency * 24 * 365 / 100) AS totalEnergyOutput FROM EnergyDevices WHERE deviceId = '6';	EnergyManagementDB	4
SELECT SUM((ed.powerRating * ed.efficiency * 1000 * (strftime('%s', ec_end.timestamp) - strftime('%s', ec.timestamp)) / 3600)) / 1000 AS totalEnergyGenerated FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyConsumption ec_end ON ec.deviceId = ec_end.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp >= '2023-01-01 00:00:00' AND ec_end.timestamp <= '2023-01-31 23:59:59' GROUP BY ed.deviceId;	EnergyManagementDB	1
WITH PowerData AS (SELECT deviceId, timestamp, powerUsage FROM EnergyConsumption WHERE deviceId = '1' AND timestamp >= '2022-01-01' AND timestamp < '2023-01-01'), EnergyCalculation AS (SELECT deviceId, SUM(powerUsage * 1) AS totalEnergyGenerated FROM PowerData GROUP BY deviceId) SELECT deviceId, totalEnergyGenerated FROM EnergyCalculation;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.nextMaintenanceDate, ec.temperature, CASE WHEN ec.temperature > 30 THEN 'need to increase maintenance frequency' ELSE 'no need to increase maintenance frequency' END AS maintenanceFrequencyRecommendation FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ec.timestamp = (SELECT MAX(timestamp) FROM EnergyConsumption WHERE deviceId = ed.deviceId);	EnergyManagementDB	3
SELECT 10000000 AS power_kw, 10000000 * 24 * 365 AS total_energy_consumption_kwh;	EnergyManagementDB	4
SELECT (efficiency * powerRating * 800 * (strftime('%s', '2023-01-01 12:00:00') - strftime('%s', '2023-01-01 00:00:00')) / 3600) / 1000 AS totalEnergyGenerated FROM EnergyDevices WHERE deviceName = 'Solar Panel';	EnergyManagementDB	1
WITH DeviceInfo AS (     SELECT deviceId, powerRating, efficiency      FROM EnergyDevices      WHERE deviceType = 'wind' AND deviceName = 'FutureDeviceA' ),  EnergyData AS (     SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed      FROM EnergyConsumption      WHERE deviceId = (SELECT deviceId FROM DeviceInfo)      AND timestamp >= datetime('now', '-1 year')      GROUP BY deviceId )  SELECT d.deviceId, d.powerRating * d.efficiency / 100 * 8760 AS estimatedTotalEnergyOutput  FROM DeviceInfo d;	EnergyManagementDB	2
SELECT deviceId, deviceName, 12 / 6 AS maintenanceCount, 12 / 6 * 5000 AS estimatedMaintenanceCost FROM EnergyDevices;	EnergyManagementDB	3
SELECT powerRating * 24 * 365 AS maxEnergyOutput FROM EnergyDevices WHERE deviceId = '1';	EnergyManagementDB	4
SELECT deviceName, powerRating * efficiency AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceName ASC;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	2
SELECT status, COUNT(*) AS device_count FROM EnergyDevices WHERE nextMaintenanceDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status;	EnergyManagementDB	3
SELECT deviceId, deviceName, (100 - efficiency) * powerRating * 8760 AS energySaved FROM EnergyDevices ORDER BY energySaved DESC LIMIT 10;	EnergyManagementDB	4
WITH GreenTechDevices AS (     SELECT ed.deviceId, ed.efficiency      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar' ) SELECT AVG(efficiency) AS average_efficiency FROM GreenTechDevices;  WITH GreenTechDevices AS (     SELECT ed.deviceId, ed.efficiency      FROM EnergyDevices ed      JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId      WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar' ) SELECT deviceId, efficiency FROM GreenTechDevices ORDER BY efficiency DESC LIMIT 5;	EnergyManagementDB	1
SELECT SUM(ed.powerRating) AS total_power, ed.deviceId, ed.powerRating FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'EcoPower' AND ed.deviceType = 'wind' GROUP BY ed.deviceId, ed.powerRating ORDER BY ed.powerRating DESC LIMIT 3;	EnergyManagementDB	2
SELECT AVG(mr.cost) AS average_maintenance_cost FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId JOIN MaintenanceRecords mr ON ed.deviceId = mr.deviceId WHERE m.manufacturerName = 'SunEnergy' AND ed.installationDate < '2020-01-01';	EnergyManagementDB	3
WITH IncreasedPower AS (   SELECT ed.deviceId, ed.powerRating * 1000 AS increasedPowerRating    FROM EnergyDevices ed    JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId    WHERE m.manufacturerName = 'FutureEnergy' )  SELECT deviceId, increasedPowerRating AS powerRating  FROM IncreasedPower  ORDER BY increasedPowerRating DESC  LIMIT 10;	EnergyManagementDB	4
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
WITH AverageEfficiency AS (SELECT AVG(efficiency) AS avg_efficiency FROM EnergyEfficiency) SELECT ed.deviceId, ed.deviceName, ed.efficiency FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId CROSS JOIN AverageEfficiency WHERE ee.efficiency < AverageEfficiency.avg_efficiency;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE lastMaintenanceDate < date('now','-1 year') OR lastMaintenanceDate IS NULL;	EnergyManagementDB	3
WITH AbnormalPowerUsage AS (     SELECT deviceId, timestamp, powerUsage, energyConsumed, temperature, humidity      FROM EnergyConsumption      WHERE powerUsage >= 10000 )  SELECT AP.deviceId, AP.timestamp, AP.powerUsage, AP.energyConsumed, AP.temperature, AP.humidity,         ED.deviceName, ED.deviceType, ED.powerRating, ED.efficiency, ED.status, ED.location,         MR.maintenanceType, MR.maintenanceDescription, MR.nextMaintenanceDate  FROM AbnormalPowerUsage AP  JOIN EnergyDevices ED ON AP.deviceId = ED.deviceId  LEFT JOIN MaintenanceRecords MR ON AP.deviceId = MR.deviceId  ORDER BY AP.timestamp DESC;	EnergyManagementDB	4
SELECT SUM((800 * 2 * 0.2 * (julianday('2023-01-31 23:59:59') - julianday('2023-01-01 00:00:00')) * 24) / 1000) AS total_energy_generated FROM EnergyDevices WHERE deviceType = 'solar';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;	EnergyManagementDB	2
WITH MaxEnergyConsumption AS (     SELECT deviceId, MAX(energyConsumed) AS maxEnergyConsumed      FROM EnergyConsumption      GROUP BY deviceId )  SELECT ec.deviceId, ed.deviceName, mec.maxEnergyConsumed, (mec.maxEnergyConsumed * 0.5) AS hourlyCost  FROM EnergyConsumption ec  JOIN MaxEnergyConsumption mec ON ec.deviceId = mec.deviceId AND ec.energyConsumed = mec.maxEnergyConsumed  JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId  ORDER BY mec.maxEnergyConsumed DESC  LIMIT 1;	EnergyManagementDB	3
WITH EfficiencyData AS (   SELECT 20 AS originalEfficiency,           1000 AS newEfficiency,           100000 AS annualEnergyConsumption,           0.5 AS electricityPrice ) SELECT annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency AS energySaved,         annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency * electricityPrice AS costSavings  FROM EfficiencyData;	EnergyManagementDB	4
WITH DeviceEnergy AS (     SELECT          ec.deviceId,          SUM(ec.powerUsage * (julianday((SELECT MIN(ec2.timestamp) FROM EnergyConsumption ec2 WHERE ec2.deviceId = ec.deviceId AND ec2.timestamp > ec.timestamp)) - julianday(ec.timestamp)) * 86400) / 3600 AS totalEnergyConsumption      FROM EnergyConsumption ec      WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'      GROUP BY ec.deviceId )  SELECT de.deviceId, ed.deviceName, de.totalEnergyConsumption  FROM DeviceEnergy de  JOIN EnergyDevices ed ON de.deviceId = ed.deviceId  ORDER BY de.totalEnergyConsumption DESC  LIMIT 1;	EnergyManagementDB	1
WITH DeviceYearlyEfficiency AS (     SELECT deviceId, AVG(efficiency) AS avgEfficiency      FROM EnergyEfficiency      WHERE timestamp >= date('now','-1 year')      GROUP BY deviceId  ),  OverallAverageEfficiency AS (     SELECT AVG(avgEfficiency) AS overallAvgEfficiency      FROM DeviceYearlyEfficiency  )  SELECT ed.deviceId, ed.deviceName, ed.deviceType, dye.avgEfficiency  FROM DeviceYearlyEfficiency dye  JOIN EnergyDevices ed ON dye.deviceId = ed.deviceId  JOIN OverallAverageEfficiency oae ON dye.avgEfficiency < oae.overallAvgEfficiency;	EnergyManagementDB	2
SELECT ed.deviceName, ed.location  FROM EnergyDevices ed  WHERE ed.deviceId NOT IN (   SELECT mr.deviceId    FROM MaintenanceRecords mr    WHERE mr.maintenanceDate >= date('now', '-1 year') );	EnergyManagementDB	3
WITH DeviceEnergy AS (     SELECT deviceId, powerRating * 24 * 365 AS totalEnergyConsumption     FROM EnergyDevices     WHERE deviceId = '1' ), AllDevicesEnergy AS (     SELECT SUM(powerRating * 24 * 365) AS totalEnergyConsumptionAll     FROM EnergyDevices ) SELECT      DE.totalEnergyConsumption AS SpecificDeviceEnergy,      ADE.totalEnergyConsumptionAll AS AllDevicesEnergy,      DE.totalEnergyConsumption - ADE.totalEnergyConsumptionAll AS EnergyDifference FROM DeviceEnergy DE, AllDevicesEnergy ADE;	EnergyManagementDB	4
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Fuel_Type = 'gasoline' AND Stock_Liters = 10000;	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Profits, (Sales * Net_Profit_Margin / 100) * (Debt_Equity_Ratio + 1) AS Assets FROM company WHERE Sales = 500;	gas	2
SELECT (Minimum_Stock_Liters - Stock_Liters) / 1000 AS Days_Until_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	3
SELECT gs.Capacity_Liters * (g.Price_Liter + g.Tax_per_Liter) AS Total_Revenue FROM gas_station gs JOIN gas g ON gs.Station_ID = g.Station_ID WHERE gs.Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	4
SELECT 50000 * 0.85 AS TotalMass;	gas	1
SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales, Sales * (1 + Revenue_Growth_Rate / 100) * Net_Profit_Margin / 100 AS Projected_Profit FROM company WHERE Company = 'BP China';	gas	2
SELECT CASE WHEN (Stock_Liters - Minimum_Stock_Liters) / 2000 <= 0 THEN 'need to immediately refuel' ELSE 'no need to immediately refuel' END AS RefuelNeeded FROM gas WHERE Station_ID = '1';	gas	3
SELECT 100000 * (5 + 1) AS DailyRevenue, 100000 * 2.5 AS TotalCarbonEmission;	gas	4
SELECT Stock_Liters * Sulfur_Content * 0.001 AS Total_Sulfur_Content_Grams FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	1
SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT CASE WHEN Stock_Liters - ((Stock_Liters - Minimum_Stock_Liters) / 3 * 3) < Minimum_Stock_Liters THEN 'need to replenish in advance' ELSE 'no need to replenish in advance' END AS Need_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	3
SELECT Capacity_Liters * 2.31 AS Total_Carbon_Emission_Grams, (Capacity_Liters * 2.31) / 1000 / 4000 AS Equivalent_Car_Emissions FROM gas_station WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000) AND Stock_Liters = 80000;	gas	1
SELECT Sales * Net_Profit_Margin / 100.0 AS Current_Profits, (Sales * Net_Profit_Margin / 100.0) / 0.20 AS Required_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000.0 AS Remaining_Days FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Minimum_Stock_Liters = 10000) AND Stock_Liters = 9500;	gas	3
SELECT (Stock_Liters - Minimum_Stock_Liters) / 1 AS Required_Time_Seconds FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;	gas	4
SELECT 5000 * Sulfur_Content * 0.001 AS Sulfur_Total_Grams FROM gas WHERE Fuel_Type = 'diesel';	gas	1
SELECT Sales * POWER(1 + Revenue_Growth_Rate / 100.0, 5) AS Future_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT Stock_Liters - Minimum_Stock_Liters AS Max_Sellable_Liters FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 20000 AND gas.Stock_Liters = 5000 AND gas.Minimum_Stock_Liters = 1000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas JOIN gas_station ON gas.Station_ID = gas_station.Station_ID WHERE gas_station.Capacity_Liters = 20000;	gas	4
SELECT Stock_Liters * 35.8 AS Total_Energy_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000 LIMIT 1);	gas	1
SELECT (Debt_Equity_Ratio * (Sales * Net_Profit_Margin / 100.0)) - (0.5 * (Sales * Net_Profit_Margin / 100.0)) AS Debt_Repayment FROM company WHERE Sales = 300 AND Net_Profit_Margin = 12 AND Debt_Equity_Ratio = 0.8;	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Days_Remaining FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 20000 LIMIT 1);	gas	3
SELECT (Stock_Liters * Carbon_Emission) AS Single_Station_Emissions, (Stock_Liters * Carbon_Emission * 1000000) AS Global_Emissions FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000 LIMIT 1);	gas	4
SELECT (50000 * 0.45) AS total_mass_kg, (50000 * 0.45 * 50) AS total_energy_MJ, (50000 * 0.45 * 50 * 0.4) AS electrical_energy_MJ FROM gas WHERE Fuel_Type = 'liquefied natural gas' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000);	gas	1
SELECT (Assets * (2.0 / 3.0)) AS Debt, (Assets * (1.0 / 3.0)) AS Equity, (Assets * (2.0 / 3.0) - (Assets / 2.0)) AS Debt_Repayment FROM company WHERE Assets = 800;	gas	2
WITH daily_consumption AS (     SELECT 1500 AS daily_sales, 20000 AS replenishment_amount, 3 AS replenishment_interval ), inventory_trend AS (     SELECT          30000 AS current_stock,          10000 AS minimum_stock,          (1500 - (20000.0 / 3)) AS net_daily_consumption,          (30000 - 10000 + (20000 * (CAST((30000 - 10000) / (1500 - (20000.0 / 3)) AS INTEGER) / 3))) AS inventory_change      FROM daily_consumption ) SELECT      CASE WHEN inventory_change < 0 THEN 'Yes' ELSE 'No' END AS shortage_occurrence,      CASE WHEN inventory_change < 0 THEN ABS(inventory_change) / net_daily_consumption ELSE 0 END AS shortage_duration_days  FROM inventory_trend;	gas	3
WITH carbon_data AS (   SELECT      50000000 AS daily_sales_liters,      2.31 AS carbon_emission_per_liter_kg,      20 AS carbon_absorption_per_tree_kg,      10 AS land_area_per_tree_sqm ),  total_emission AS (   SELECT      (daily_sales_liters * carbon_emission_per_liter_kg * 365) AS total_carbon_emission_kg    FROM      carbon_data ),  trees_needed AS (   SELECT      (total_carbon_emission_kg / carbon_absorption_per_tree_kg) AS trees_required    FROM      total_emission,      carbon_data ),  land_required AS (   SELECT      (trees_required * land_area_per_tree_sqm / 1000000) AS land_area_sqkm    FROM      trees_needed,      carbon_data )  SELECT    trees_required,    land_area_sqkm  FROM    trees_needed,    land_required;	gas	4
SELECT Capacity_Liters * 0.75 AS Total_Mass_Kg, (Capacity_Liters * 0.75) * 45 AS Total_Energy_MJ FROM gas_station WHERE Station_ID = '1';	gas	1
SELECT (5000 * 5000 * 365 * 0.5) * (1 - 0.3) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';	gas	2
SELECT (2000 * 7) + (5000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';	gas	3
SELECT (1000000 * 2.31 * 10000 * 365) AS Total_Carbon_Emission_Kg, ((1000000 * 2.31 * 10000 * 365) / 10000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';	gas	4
SELECT Stock_Liters * 0.8 AS Total_Mass_Kg, (Stock_Liters * 0.8) * 42 AS Total_Energy_MJ FROM gas WHERE Station_ID = '1';	gas	1
SELECT (8000 * 4000 * 365 * 0.4) * (1 - 0.2) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';	gas	2
SELECT (3000 * 5) + (10000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';	gas	3
SELECT (2000000 * 2.5 * 20000 * 365) AS Total_Carbon_Emission_Kg, ((2000000 * 2.5 * 20000 * 365) / 20000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';	gas	4
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 50000 AND Carbon_Emission = 2.5;	gas	1
SELECT Sales * (Net_Profit_Margin / 100.0) AS Net_Profit, 50.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Sales = 500 AND Net_Profit_Margin = 8;	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000.0 AS Operational_Days FROM gas WHERE Stock_Liters = 15000 AND Minimum_Stock_Liters = 10000;	gas	3
SELECT MIN(1000000, Stock_Liters) AS Available_Stock FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;	gas	4
SELECT Stock_Liters * 0.85 * 45 AS Total_Energy FROM gas WHERE Stock_Liters = 80000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100.0) AS Net_Profit, (Sales * (Net_Profit_Margin / 100.0)) / Assets AS ROA, 100.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Sales = 750 AND Net_Profit_Margin = 12 AND Assets = 2000;	gas	2
SELECT CASE WHEN (Stock_Liters - (3000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning FROM gas WHERE Stock_Liters = 25000 AND Minimum_Stock_Liters = 15000;	gas	3
SELECT CASE WHEN 1500001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete, MIN(1500001, Stock_Liters) AS Max_Sellable FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1500000) AND Stock_Liters = 1499999;	gas	4
SELECT Stock_Liters * 35 * 0.85 AS Available_Energy FROM gas WHERE Stock_Liters = 120000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 150 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 900 AND Net_Profit_Margin = 15 AND Assets = 3000 AND Debt_Equity_Ratio = 1200;	gas	2
SELECT CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 5000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 40000 AND Minimum_Stock_Liters = 25000;	gas	3
SELECT CASE WHEN 3000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(3000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 5000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 3000000) AND Stock_Liters = 2999999;	gas	4
SELECT Stock_Liters * 38 * 0.9 AS Available_Energy FROM gas WHERE Stock_Liters = 200000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 300 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 1500 AND Net_Profit_Margin = 20 AND Assets = 5000 AND Debt_Equity_Ratio = 2000;	gas	2
SELECT CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 6000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 50000 AND Minimum_Stock_Liters = 30000;	gas	3
SELECT CASE WHEN 5000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(5000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 10000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 5000000) AND Stock_Liters = 4999999;	gas	4
SELECT Stock_Liters * 42 * 0.88 AS Available_Energy FROM gas WHERE Stock_Liters = 300000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 500 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 2000 AND Net_Profit_Margin = 25 AND Assets = 6000 AND Debt_Equity_Ratio = 2500;	gas	2
SELECT CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 8000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 70000 AND Minimum_Stock_Liters = 40000;	gas	3
SELECT CASE WHEN 10000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(10000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 20000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 10000000) AND Stock_Liters = 9999999;	gas	4
SELECT Stock_Liters * 46 * 0.92 AS Available_Energy, Stock_Liters * 2.8 AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 500000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 1200 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 4000 AND Net_Profit_Margin = 28 AND Assets = 10000 AND Debt_Equity_Ratio = 4000;	gas	2
SELECT CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 15000 ELSE 0 END AS Days_To_Advance, CASE WHEN (Stock_Liters - (20000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_New_Sales FROM gas WHERE Stock_Liters = 150000 AND Minimum_Stock_Liters = 80000;	gas	3
SELECT CASE WHEN 20000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, MIN(20000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 50000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2, 50000000 * 10 AS Order_Total_Amount FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 20000000) AND Stock_Liters = 19999999;	gas	4
SELECT Stock_Liters * 0.83 * 47 AS Total_Energy, Stock_Liters * 50 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100.0 AS Net_Profit, (Sales * Net_Profit_Margin / 100.0) / Assets AS ROA, (Sales * Net_Profit_Margin / 100.0) / (Assets - 550) AS ROE, 550.0 / (Assets - 550) AS Debt_to_Equity_Ratio, 1800.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 20000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (25000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 30000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, MIN(30000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 60000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 60000000 * 12 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.85 * 45 AS Total_Energy, Stock_Liters * 40 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100.0 AS Net_Profit, (Sales * Net_Profit_Margin / 100.0) / Assets AS ROA, (Sales * Net_Profit_Margin / 100.0) / (Assets - 600) AS ROE, 600.0 / (Assets - 600) AS Debt_to_Equity_Ratio, 2000.0 / (Net_Profit_Margin / 100.0) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 25000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (30000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 50000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, MIN(50000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 100000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 100000000 * 15 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.86 * 49 AS Total_Energy, Stock_Liters * 60 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 900) AS ROE, 900.0 / (Assets - 900) AS Debt_to_Equity_Ratio, 3500.0 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 24000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (29000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 80000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, MIN(80000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 160000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 160000000 * 25 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000 AND Stock_Liters = 80000);	gas	1
SELECT Sales * (Net_Profit_Margin / 100.0) AS Net_Profit FROM company WHERE Sales = 500 AND Net_Profit_Margin = 15;	gas	2
SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters AND Next_Delivery_Date > date('now', '+7 days'));	gas	3
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 1000000000 AND Carbon_Emission = 2.5;	gas	4
SELECT Stock_Liters * 35 AS Total_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 150000 AND Stock_Liters = 120000);	gas	1
SELECT Assets * (Debt_Equity_Ratio / (1.0 + Debt_Equity_Ratio)) AS Total_Liabilities FROM company WHERE Assets = 1500 AND Debt_Equity_Ratio = 0.6;	gas	2
SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters * 1.1 AND Next_Delivery_Date = date('now', '+5 days'));	gas	3
SELECT Stock_Liters * Sulfur_Content AS Total_Sulfur_Content FROM gas WHERE Stock_Liters = 50000000000 AND Sulfur_Content = 50;	gas	4
SELECT Stock_Liters * 40 * 0.85 AS Effective_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 200000 AND Stock_Liters = 180000);	gas	1
SELECT (5 * 500) / Sales * 100 AS Target_Net_Profit_Margin FROM company WHERE Sales = 1200;	gas	2
SELECT Station_ID, Manager_Name  FROM gas_station  WHERE Station_ID IN (     SELECT Station_ID      FROM gas      WHERE Stock_Liters < Minimum_Stock_Liters * 1.1      AND Next_Delivery_Date = date('now', '+3 days') );	gas	3
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 100000000000 AND Carbon_Emission = 5;	gas	4
SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT Capacity_Liters * Carbon_Emission * 365 AS Annual_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT Stock_Liters * 0.85 AS Total_Mass_kg, (Stock_Liters * 0.85) * 45.5 AS Total_Heat_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = '1';	gas	1
SELECT Sales * 1.08 AS Projected_Sales, (Sales * 1.08) * 0.12 AS Projected_Profits FROM company WHERE Company_ID = '104';	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000.0 AS Days_Remaining FROM gas WHERE Station_ID = '1';	gas	3
SELECT 5000000 * 2.31 * 365 AS Annual_Carbon_Emission, 5000000 * 2.31 * 365 * 1000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_kg, (Stock_Liters * 0.75) * 42 AS Total_Heat_MJ FROM gas WHERE Station_ID = '1';	gas	1
SELECT Sales * 1.10 AS Projected_Sales, (Sales * 1.10) * 0.15 AS Projected_Profits, ((Sales * 1.10) * 0.15) * 1.5 AS Total_Debt FROM company WHERE Company_ID = '104';	gas	2
SELECT (30000 - 10000) / 2500 AS Days_Remaining, CASE WHEN 30000 < 10000 THEN 'Yes' ELSE 'No' END AS Need_Refill FROM gas WHERE Station_ID = '1';	gas	3
SELECT 10000000 * 2.5 * 365 AS Annual_Carbon_Emission, 10000000 * 2.5 * 365 * 2000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';	gas	4
SELECT (950.0 / 1050.0) * 100 AS Efficiency FROM generators WHERE GeneratorID = 1001;	generators	1
SELECT SUM(RatedPower) AS TotalPower FROM generators WHERE ManufacturerID = 2001;	generators	2
SELECT GeneratorID, GeneratorName, CASE WHEN ContinualTime > 1000 AND Status = 1 THEN 'need maintenance' ELSE 'no need maintenance' END AS MaintenanceStatus FROM generators WHERE GeneratorID = 1002;	generators	3
SELECT GeneratorID, GeneratorName, CASE WHEN 10000 > RatedRotationSpeed * 1.2 THEN  'exceeds safe range' ELSE 'within safe range' END AS RotationSafetyStatus FROM generators WHERE GeneratorID = 1003;	generators	4
SELECT RatedPower / (RatedVoltage * 1500) AS PowerFactor FROM generators WHERE GeneratorID = 1001;	generators	1
```sql SELECT c.Customer_ID, c.Name, CASE WHEN l.Power_Source = 'Gasoline' THEN (l.Engine_Power * 745.7 * 3600 / 1000) + (pm.Fuel_Consumption * 34.2 * 1000) WHEN l.Power_Source IN ('Electric', 'Battery') THEN (l.Battery_Capacity * 12 * 3.6 * 60) / NULLIF(l.Run_Time, 0) ELSE 0 END AS Total_Energy_kJh FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN performance_metrics pm ON l.Mower_ID = pm.Mower_ID ORDER BY pm.Energy_Efficiency DESC LIMIT 5; ```	lawnmower	1
SELECT Customer_ID, Name, Purchase_Power_Index FROM (SELECT c.Customer_ID, c.Name, log10(c.Annual_Purchase_Volume / AVG(c.Annual_Purchase_Volume) OVER (PARTITION BY c.State)) AS Purchase_Power_Index FROM customers c) AS sub WHERE Purchase_Power_Index > 1.5 ORDER BY Purchase_Power_Index DESC;	lawnmower	2
SELECT DISTINCT c.Customer_ID, c.Name, c.Annual_Purchase_Volume  FROM customers c  JOIN sales s ON c.Customer_ID = s.Customer_ID  JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID  WHERE c.Annual_Purchase_Volume > 500000  AND l.Power_Source = 'Manual'  ORDER BY c.Annual_Purchase_Volume DESC;	lawnmower	3
SELECT m.Name AS Manufacturer_Name, (SUM(s.Quantity) * 100.0 / m.Production_Volume_Total) AS Percentage FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID WHERE c.Annual_Purchase_Volume = 999000000 GROUP BY m.Manufacturer_ID, m.Production_Volume_Total ORDER BY Percentage DESC LIMIT 3;	lawnmower	4
SELECT Country, (SUM(Annual_Purchase_Volume) / 100) * 0.001 AS Total_Mass_kg FROM customers GROUP BY Country;	lawnmower	1
WITH StateTotal AS (     SELECT State, SUM(Annual_Purchase_Volume) AS State_Total      FROM customers      GROUP BY State )  SELECT c.State, c.Customer_Type,         (SUM(c.Annual_Purchase_Volume) * 100.0 / st.State_Total) AS Percentage  FROM customers c  JOIN StateTotal st ON c.State = st.State  GROUP BY c.State, c.Customer_Type  HAVING Percentage > 50;	lawnmower	2
SELECT strftime('%Y', Registration_Date) AS Reg_Year, COUNT(Customer_ID) AS New_Customers FROM customers GROUP BY Reg_Year ORDER BY New_Customers DESC;	lawnmower	3
SELECT Country, AVG(Annual_Purchase_Volume) AS Avg_Purchase FROM customers GROUP BY Country ORDER BY Avg_Purchase DESC;	lawnmower	4
SELECT c.Customer_ID, c.Name FROM customers c WHERE EXISTS (SELECT 1 FROM lawn_mowers lm INNER JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Torque * (c.Annual_Purchase_Volume / lm.Price) > 1000);	lawnmower	1
SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Individual' AND c.Annual_Purchase_Volume > 3 * (SELECT AVG(Annual_Purchase_Volume) FROM customers WHERE Customer_Type = 'Business') AND (SELECT COUNT(*) FROM customers c2 WHERE c2.State = c.State) < 50;	lawnmower	2
SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume < (SELECT AVG(Annual_Purchase_Volume) FROM customers c2 WHERE c2.Customer_Type = 'Individual' AND c2.Country = c.Country);	lawnmower	3
SELECT Customer_ID, Name FROM customers WHERE Annual_Purchase_Volume > (SELECT 10 * SUM(Annual_Purchase_Volume) FROM customers) AND Registration_Date < date('now', '-100 years');	lawnmower	4
SELECT (c.Annual_Purchase_Volume / lm.Price) * lm.Weight * 9.8 * 2 AS Total_Work_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price = 2000 AND lm.Weight = 50 WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume = 1000000;	lawnmower	1
WITH SalesCTE AS (   SELECT      CAST(strftime('%Y', Sale_Date) AS INTEGER) AS yr,      SUM(Total_Price) AS vol    FROM sales    WHERE Customer_ID='2'      AND CAST(strftime('%Y', Sale_Date) AS INTEGER) BETWEEN 2020 AND 2022    GROUP BY yr ),  CAGRData AS (   SELECT      (MAX(CASE WHEN yr=2022 THEN vol END) / MAX(CASE WHEN yr=2020 THEN vol END)) ^ (1.0/2) - 1 AS cagr,      MAX(CASE WHEN yr=2022 THEN vol END) AS end_val    FROM SalesCTE )  SELECT    (cagr * 100) || '%' AS CAGR,    end_val * (1 + cagr) * (1 + cagr) * (1 + cagr) AS Projection_2025  FROM CAGRData;	lawnmower	2
SELECT lm.Power_Source, COUNT(*) AS purchase_count FROM sales s JOIN customers c ON s.Customer_ID = c.Customer_ID JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID WHERE c.State='AK' GROUP BY lm.Power_Source ORDER BY purchase_count DESC LIMIT 1;	lawnmower	3
SELECT 0.5*(c.Annual_Purchase_Volume/lm.Price)*lm.Weight*POWER(11186,2) AS Energy_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price=1 AND lm.Weight=1000000 WHERE c.Annual_Purchase_Volume=1000000000000;	lawnmower	4
SELECT lm.Model, ROUND(lm.Engine_Power / (pm.Blade_Speed * 3.141592653589793 / 30), 2) AS Torque FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' ORDER BY Torque DESC LIMIT 3;	lawnmower	1
SELECT c.Customer_ID, c.Name, ROUND((s.Total_Price + s.Shipping_Cost - (s.Total_Price * s.Discount/100) + (s.Total_Price * s.Tax_Rate/100)), 2) AS Total_Cost FROM sales s JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE c.Customer_Type = 'Business' ORDER BY c.Annual_Purchase_Volume ASC LIMIT 5;	lawnmower	2
SELECT mt.Maintenance_Type, ROUND(AVG(mt.Cost), 2) AS Avg_Cost FROM maintenance mt JOIN lawn_mowers m ON mt.Mower_ID = m.Mower_ID WHERE m.Power_Source = 'Manual' GROUP BY mt.Maintenance_Type ORDER BY Avg_Cost ASC;	lawnmower	3
SELECT lm.Model, pm.Cutting_Efficiency * (lm.Run_Time/60) AS Coverage_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 1 AND pm.Cutting_Efficiency * (lm.Run_Time/60) >= 7140 ORDER BY Coverage_Area DESC LIMIT 1;	lawnmower	4
SELECT Battery_Capacity * 12 * 3600 AS Total_Energy_J, (Battery_Capacity * 12 * 3600) / (Run_Time * 60) AS Avg_Power_W FROM lawn_mowers WHERE Power_Source IN ('Electric','Battery') AND Battery_Capacity = 5 AND Run_Time = 60;	lawnmower	1
SELECT (Engine_Power * 745.7) / Weight AS Power_Density, (Engine_Power * 745.7 * 3600) / 1000000 AS Total_Work_MJ FROM lawn_mowers WHERE Power_Source = 'Gasoline' AND Engine_Power = 5 AND Weight = 50;	lawnmower	2
SELECT lm.Wheel_Size, AVG(pm.Slope_Handling) AS Avg_Slope_Handling FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID=pm.Mower_ID WHERE lm.Wheel_Size IN (6,10) GROUP BY lm.Wheel_Size ORDER BY Wheel_Size DESC;	lawnmower	3
SELECT 0.5*(0.5*lm.Blade_Weight*POWER(lm.Blade_Length/200,2))*POWER(2*PI()*pm.Blade_Speed/60,2) AS Rotational_Energy_J, (0.5*(0.5*lm.Blade_Weight*POWER(lm.Blade_Length/200,2))*POWER(2*PI()*pm.Blade_Speed/60,2))/4184 AS TNT_Equivalent_g FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight=2000 AND pm.Blade_Speed=100000;	lawnmower	4
SELECT Power_Source, AVG(Engine_Power * 745.7 * 3600 / 1000000) AS Avg_Energy_Consumption_MJ FROM lawn_mowers WHERE Power_Source = 'Gasoline' GROUP BY Power_Source;	lawnmower	1
SELECT lm.Model, SUM(pm.Cutting_Efficiency * (lm.Run_Time / 60) * pm.Battery_Life) AS Total_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Electric' GROUP BY lm.Model;	lawnmower	2
SELECT lm.Power_Source, MAX(pm.Cutting_Efficiency * (lm.Run_Time / 60.0)) AS Max_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID GROUP BY lm.Power_Source ORDER BY Max_Area DESC LIMIT 1;	lawnmower	3
SELECT 'Electric' AS Power_Source, (1000 * 10000 / 60 / 1000000) AS Area_km2;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, (lm.Battery_Capacity * 24 * 3600) / (0.5 * 0.5 * lm.Blade_Weight * POWER(lm.Blade_Length/200, 2) * POWER(2 * PI() * pm.Blade_Speed/60, 2) * 60) AS Theoretical_Run_Time_Minutes FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery');	lawnmower	1
SELECT lm.Mower_ID, lm.Model, 2 * 365 * pm.Fuel_Consumption * 3.5 AS Annual_Fuel_Cost FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline';	lawnmower	2
SELECT lm.Mower_ID, lm.Model, lm.Run_Time AS Recorded_Run_Time, (lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) AS Theoretical_Run_Time FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ABS((lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) - lm.Run_Time) / lm.Run_Time > 0.5;	lawnmower	3
SELECT Mower_ID, Model, Weight, Power_Source, Turning_Radius, Blade_Length FROM lawn_mowers WHERE (Power_Source = 'Manual' AND Weight > 1000) OR (Turning_Radius < Blade_Length / 200);	lawnmower	4
SELECT 2.5 * 9.8 * (AVG(Ground_Clearance) / 100.0) AS Work_Joules FROM lawn_mowers;	lawnmower	1
SELECT ROUND((SELECT SUM(Parts_Cost) FROM maintenance WHERE Maintenance_Type='Replacement') * 100.0 / SUM(Parts_Cost), 2) AS Cost_Percentage FROM maintenance;	lawnmower	2
SELECT CASE WHEN (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Routine') < (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Repair') THEN 'conforms to common sense' ELSE 'abnormal' END AS Cost_Comparison;	lawnmower	3
SELECT CASE WHEN 1000000 * (50000 + 1000000) > (SELECT MAX(Revenue) * 10 FROM manufacturers) THEN 'yes' ELSE 'no' END AS Is_Exceed;	lawnmower	4
SELECT Maintenance_ID, (Labor_Cost + Parts_Cost) / (JULIANDAY(Next_Maintenance_Date) - JULIANDAY(Maintenance_Date)) AS Daily_Cost FROM maintenance WHERE Next_Maintenance_Date IS NOT NULL ORDER BY Daily_Cost DESC LIMIT 5;	lawnmower	1
SELECT Maintenance_Type, AVG(Parts_Cost * 100.0 / (Labor_Cost + Parts_Cost)) AS Avg_Parts_Percentage FROM maintenance GROUP BY Maintenance_Type ORDER BY Avg_Parts_Percentage DESC;	lawnmower	2
SELECT * FROM maintenance WHERE Maintenance_Type = 'Replacement' ORDER BY (Labor_Cost + Parts_Cost) DESC LIMIT 5;	lawnmower	3
SELECT * FROM maintenance WHERE Cost > 1000000 ORDER BY Cost DESC LIMIT 3;	lawnmower	4
SELECT m.Service_Center, AVG((1 - POWER(0.8, 2)) * 100) AS Avg_Energy_Reduction_Percent FROM maintenance m JOIN performance_metrics pm ON m.Mower_ID = pm.Mower_ID GROUP BY m.Service_Center;	lawnmower	1
SELECT Service_Center, Maintenance_Type, SUM(Labor_Cost) * 1.0 / NULLIF(SUM(Parts_Cost), 0) AS Labor_Parts_Ratio FROM maintenance GROUP BY Service_Center, Maintenance_Type HAVING SUM(Labor_Cost) * 1.0 / NULLIF(SUM(Parts_Cost), 0) > 2;	lawnmower	2
SELECT c.Customer_Type, COUNT(*) AS Overpriced_Count  FROM maintenance m  JOIN lawn_mowers lm ON m.Mower_ID = lm.Mower_ID  JOIN sales s ON m.Mower_ID = s.Mower_ID  JOIN customers c ON s.Customer_ID = c.Customer_ID  WHERE m.Cost > 0.5 * lm.Price  GROUP BY c.Customer_Type;	lawnmower	3
SELECT Maintenance_Type, 100 * (POWER(1.1, 100) - 1) / 0.1 AS Cumulative_Cost FROM maintenance GROUP BY Maintenance_Type;	lawnmower	4
SELECT m_new.Maintenance_ID, m_new.Mower_ID, (1.0/6) * lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * 3.141592653589793 / 30), 2) AS new_kinetic, (1.0/6) * lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * 3.141592653589793 / 30), 2) AS old_kinetic, (1.0/6) * (lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * 3.141592653589793 / 30), 2) - lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * 3.141592653589793 / 30), 2)) AS energy_diff FROM maintenance m_new JOIN maintenance m_prev ON m_new.Mower_ID = m_prev.Mower_ID AND m_prev.Maintenance_Date = (SELECT MAX(Maintenance_Date) FROM maintenance WHERE Mower_ID = m_new.Mower_ID AND Maintenance_Date < m_new.Maintenance_Date) JOIN lawn_mowers lm_new ON m_new.Mower_ID = lm_new.Mower_ID JOIN lawn_mowers lm_prev ON m_prev.Mower_ID = lm_prev.Mower_ID JOIN performance_metrics pm ON m_new.Mower_ID = pm.Mower_ID JOIN performance_metrics pm_prev ON m_prev.Mower_ID = pm_prev.Mower_ID WHERE m_new.Maintenance_Type = 'Replacement';	lawnmower	1
WITH Stats AS (     SELECT          AVG((Cost - Parts_Cost) * 100.0 / Cost) AS avg_ratio,          STDEV((Cost - Parts_Cost) * 100.0 / Cost) AS std_ratio      FROM maintenance      WHERE Maintenance_Type = 'Repair' ) SELECT      Service_Center,      Maintenance_ID,      (Cost - Parts_Cost) * 100.0 / Cost AS cost_ratio  FROM maintenance  CROSS JOIN Stats  WHERE      Maintenance_Type = 'Repair'      AND (Cost - Parts_Cost) * 100.0 / Cost > (avg_ratio + 3.0 * std_ratio);	lawnmower	2
SELECT Maintenance_ID, Mower_ID, Maintenance_Date, Next_Maintenance_Date FROM maintenance WHERE Maintenance_Type = 'Replacement' AND (julianday(Next_Maintenance_Date) - julianday(Maintenance_Date)) / 30.44 < 6;	lawnmower	3
SELECT m1.Maintenance_ID, m1.Mower_ID, m1.Labor_Cost  FROM maintenance m1  WHERE m1.Labor_Cost > 10 * (SELECT AVG(Cost) * COUNT(*) * 1000 FROM maintenance m2 WHERE m2.Mower_ID = m1.Mower_ID);	lawnmower	4
SELECT (lm.Engine_Power * 5252) / pm.Torque AS Blade_Speed_RPM FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND lm.Engine_Power = 5 AND pm.Torque = 10;	lawnmower	1
SELECT ((m.Revenue * (m.Profit_Margin / 100)) - m.[R&D_Spending]) / m.Employee_Count AS Net_Profit_Per_Employee FROM manufacturers m WHERE m.Revenue = 1000000000 AND m.Profit_Margin = 5 AND m.[R&D_Spending] = 50000000 AND m.Employee_Count = 5000;	lawnmower	2
SELECT CASE WHEN m.Production_Volume_Total > 500000 AND (strftime('%Y', 'now') - m.Founded_Year) = 1 THEN 'unreasonable' ELSE  'reasonable'  END AS Production_Feasibility FROM manufacturers m WHERE m.Production_Volume_Total = 1000000 AND (strftime('%Y', 'now') - m.Founded_Year) = 1;	lawnmower	3
SELECT (m.Revenue * (m.Profit_Margin / 100)) - m.[R&D_Spending] AS New_Net_Profit FROM manufacturers m WHERE m.Revenue = 100000000 AND m.Profit_Margin = 10000 AND m.[R&D_Spending] = 100000000;	lawnmower	4
SELECT Name, (Production_Volume_Total / "R&D_Spending") AS RD_Efficiency FROM manufacturers WHERE "R&D_Spending" > 0 ORDER BY RD_Efficiency DESC LIMIT 5;	lawnmower	1
SELECT Name, (Revenue / NULLIF(Employee_Count, 0)) AS Per_Capita_Output FROM manufacturers WHERE Employee_Count > 0 ORDER BY Per_Capita_Output DESC LIMIT 5;	lawnmower	2
SELECT Country, AVG(2024 - Founded_Year) AS Avg_Years FROM manufacturers GROUP BY Country ORDER BY Avg_Years DESC LIMIT 3;	lawnmower	3
SELECT Name, "R&D_Spending", Revenue FROM manufacturers WHERE "R&D_Spending" > Revenue * 100 ORDER BY "R&D_Spending" DESC LIMIT 5;	lawnmower	4
SELECT Country, SUM("R&D_Spending") * 1.0 / SUM(Employee_Count) AS R_D_Density FROM manufacturers GROUP BY Country ORDER BY R_D_Density DESC;	lawnmower	1
SELECT ROIRatio, COUNT(Country) AS CountryCount FROM (SELECT Country, SUM(Revenue * Profit_Margin / 100.0) / SUM("R&D_Spending") AS ROIRatio FROM manufacturers GROUP BY Country) AS SubQuery GROUP BY ROIRatio;	lawnmower	2
SELECT Country, AVG(Founded_Year) AS AvgFoundedYear, AVG(Employee_Count) AS AvgEmployeeCount FROM manufacturers GROUP BY Country;	lawnmower	3
SELECT Country, AVG((1 - "R&D_Spending" / Revenue) * 100) AS AvgProfitMargin FROM manufacturers WHERE "R&D_Spending" = Revenue * 1000 GROUP BY Country;	lawnmower	4
SELECT Manufacturer_ID, Name FROM manufacturers WHERE ((Revenue * Profit_Margin / 100.0) / (2023 - Founded_Year)) / 31536000.0 BETWEEN 1 AND 10;	lawnmower	1
SELECT Manufacturer_ID, Name FROM manufacturers WHERE (R&D_Spending * 100.0 / Revenue) > 5 AND (Revenue * 1.0 / Employee_Count) > 1000000;	lawnmower	2
SELECT Manufacturer_ID, Name FROM manufacturers WHERE Founded_Year <= 1993 AND Profit_Margin < 15;	lawnmower	3
SELECT Manufacturer_ID, Name FROM manufacturers WHERE R&D_Spending > Market_Cap * 10;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, (pm.Torque * (2 * PI() * pm.Blade_Speed / 60) / 745.7) AS Engine_Power_HP, pm.Cutting_Efficiency FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Cutting_Efficiency = 500;	lawnmower	1
SELECT lm.Mower_ID, lm.Model, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) AS Actual_Energy_Wh, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) / (lm.Run_Time / 60) AS Avg_Power_W, ROUND(pm.Battery_Life / ((2 * 60) / lm.Run_Time) / 365, 1) AS Battery_Life_Years FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND lm.Battery_Capacity = 5 AND pm.Energy_Efficiency = 85 AND lm.Run_Time = 60;	lawnmower	2
SELECT lm.Mower_ID, lm.Model, pm.Noise_Level, CASE WHEN pm.Noise_Level BETWEEN 55 AND 65 THEN 'Compliant' ELSE 'Non-Compliant' END AS Compliance_Status FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND pm.Noise_Level = 95;	lawnmower	3
SELECT lm.Mower_ID, lm.Model, '∞' AS Min_Friction_Coefficient, (lm.Wheel_Size * 0.0254 / 2) * lm.Weight * (9.8 + pm.Acceleration) AS Required_Torque_Nm FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE pm.Slope_Handling = 90 AND lm.Weight = 50 AND lm.Ground_Clearance = 20 AND pm.Acceleration = 10;	lawnmower	4
SELECT pm.Mower_ID, (pm.Torque / (lm.Weight * 0.2)) AS Torque_Acceleration_Ratio FROM performance_metrics pm JOIN lawn_mowers lm ON pm.Mower_ID = lm.Mower_ID ORDER BY Torque_Acceleration_Ratio DESC LIMIT 5;	lawnmower	1
SELECT lm.Mower_ID, (pm.Battery_Life * lm.Run_Time * pm.Energy_Efficiency) / (60.0 * 100.0) AS Total_Hours FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') ORDER BY Total_Hours DESC LIMIT 3;	lawnmower	2
SELECT Mower_ID, Noise_Level, Cutting_Efficiency FROM performance_metrics WHERE Noise_Level < 75 AND Cutting_Efficiency > 200 ORDER BY Noise_Level ASC LIMIT 5;	lawnmower	3
SELECT Mower_ID, Acceleration, Deceleration FROM performance_metrics WHERE Acceleration >= 98 AND Deceleration >= 98 ORDER BY Acceleration DESC LIMIT 3;	lawnmower	4
SELECT m.Name AS Manufacturer, MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) AS Max_Velocity, CASE WHEN MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) > 300 THEN 'Yes' ELSE 'No' END AS Safety_Status FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID GROUP BY m.Name;	lawnmower	1
SELECT p.Fuel_Consumption, SUM(p.Fuel_Consumption * 8 * 0.74 * 44 * 1000000 * 0.22) AS Total_Energy_J FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE l.Power_Source = 'Gasoline' GROUP BY p.Fuel_Consumption;	lawnmower	2
SELECT l.Power_Source, COUNT(*) AS Machine_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE p.Noise_Level > 75 AND p.Mulching_Capability = 1 GROUP BY l.Power_Source;	lawnmower	3
SELECT CASE WHEN p.Acceleration <= 500 THEN '0-500 m/s²' WHEN p.Acceleration <= 1000 THEN '501-1000 m/s²' ELSE '>1000 m/s²' END AS Acceleration_Range, CASE WHEN (l.Blade_Weight * p.Acceleration) / (5 * 0.0001) > 880000000 THEN 'Exceeded' ELSE 'Safe' END AS Strength_Status, COUNT(*) AS Case_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID GROUP BY Acceleration_Range, Strength_Status;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, 0.5 * lm.Blade_Weight * (POW((lm.Blade_Length/100 * 3.141592653589793 * pm.Blade_Speed/60), 2)) AS Kinetic_Energy FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND 0.5 * lm.Blade_Weight * (POW((lm.Blade_Length/100 * 3.141592653589793 * pm.Blade_Speed/60), 2)) > 1000 AND pm.Energy_Efficiency < 80;	lawnmower	1
SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ((pm.Battery_Life * lm.Battery_Capacity * lm.Run_Time / 60 * 48 / 1000) * (pm.Energy_Efficiency / 100) > (SELECT MAX(pm_gas.Fuel_Consumption * 10 * 200 * 34.2 * 0.3) FROM performance_metrics pm_gas JOIN lawn_mowers lm_gas ON pm_gas.Mower_ID = lm_gas.Mower_ID WHERE lm_gas.Power_Source = 'Gasoline'));	lawnmower	2
SELECT lm.Mower_ID, lm.Model  FROM lawn_mowers lm  JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID  WHERE pm.Noise_Level <= 55 AND pm.Vibration_Level < 2.5;	lawnmower	3
SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Battery' AND pm.Battery_Life >= 109500 AND lm.Run_Time >= 1000000 AND lm.Battery_Capacity >= 2500 AND pm.Energy_Efficiency >= 100;	lawnmower	4
SELECT SUM(s.Quantity * lm.Weight) * 9.8 * 1000 AS Total_Work FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID;	lawnmower	1
SELECT ROUND( ( (SELECT SUM(lm.Price * 500 * 0.85) FROM lawn_mowers lm) * 1.085 ) + (50 * 500), 2 ) AS Total_Payment;	lawnmower	2
SELECT ROUND( (500 * 3 * 0.9 * 1.06), 2 ) AS Actual_Payment;	lawnmower	3
SELECT ( ( (SELECT lm.Price FROM lawn_mowers lm LIMIT 1) * 1000000 * (1 - 120/100) ) * (1 + 250/100) ) + (0.01 * 1000000) AS Theoretical_Total_Price;	lawnmower	4
SELECT s.Sale_ID, 0.5 * 0.5 * lm.Blade_Weight * POWER((lm.Blade_Length/200),2) * POWER(2*3.141592653589793*pm.Blade_Speed/60,2) * s.Quantity AS Kinetic_Energy FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID ORDER BY Kinetic_Energy DESC LIMIT 5;	lawnmower	1
SELECT Customer_ID, SUM( (Sale_Price * Quantity * (1 - Discount/100.0) * (1 + Tax_Rate/100.0)) + Shipping_Cost ) AS Total_Payment FROM sales GROUP BY Customer_ID ORDER BY Total_Payment DESC LIMIT 10;	lawnmower	2
WITH Manufacturer_Avg AS (SELECT Manufacturer_ID, AVG(Price) * 0.8 AS Threshold FROM lawn_mowers GROUP BY Manufacturer_ID) SELECT lm.Model, SUM(s.Quantity) AS Total_Sales, CASE WHEN lm.Price < ma.Threshold THEN 'Qualified' ELSE 'Not Qualified' END AS Price_Status FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN Manufacturer_Avg ma ON lm.Manufacturer_ID = ma.Manufacturer_ID GROUP BY lm.Model, lm.Price, ma.Threshold ORDER BY Total_Sales DESC LIMIT 3;	lawnmower	3
SELECT s.Sale_ID, s.Shipping_Cost * 10000 AS Scaled_Shipping, m.Market_Cap FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers m ON lm.Manufacturer_ID = m.Manufacturer_ID WHERE s.Shipping_Cost * 10000 > m.Market_Cap ORDER BY Scaled_Shipping DESC LIMIT 5;	lawnmower	4
SELECT s.Customer_ID, SUM(s.Quantity * lm.Weight) * 9.8 * 1 AS Work_Joules FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID GROUP BY s.Customer_ID;	lawnmower	1
SELECT Payment_Method, (SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) - SUM(sale_price * quantity * 0.6)) / SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) * 100 AS Gross_Profit_Margin FROM sales GROUP BY Payment_Method;	lawnmower	2
SELECT Customer_ID, COUNT(Sale_ID) AS Abnormal_Transactions  FROM sales  WHERE shipping_cost > (Sale_Price * Quantity * 0.1)  GROUP BY Customer_ID;	lawnmower	3
SELECT Sale_Price * 2147483647 * (1 + Tax_Rate/100) AS Total_Price_Validation FROM sales WHERE Customer_ID IN (SELECT Customer_ID FROM customers WHERE Customer_Type = 'Business') LIMIT 1;	lawnmower	4
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND (lm.Engine_Power * 745.7) * (lm.Run_Time * 60) >= 1000 AND NOT EXISTS (SELECT 1 FROM performance_metrics pm WHERE pm.Mower_ID = lm.Mower_ID AND pm.Vibration_Level > 5);	lawnmower	1
SELECT c.Customer_ID, (SUM(m.Cost) / SUM(s.Total_Price)) * 100 AS maintenance_percentage  FROM customers c  JOIN sales s ON c.Customer_ID = s.Customer_ID  JOIN maintenance m ON s.Mower_ID = m.Mower_ID  WHERE c.Customer_Type = 'Business'  AND c.Annual_Purchase_Volume > 50000  AND m.Maintenance_Date BETWEEN s.Sale_Date AND date(s.Sale_Date, '+' || s.Warranty_Period || ' months')  GROUP BY c.Customer_ID  HAVING maintenance_percentage < 15;	lawnmower	2
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE lm.Power_Source = 'Manual' AND lm.Blade_Angle > 35 AND lm.Cutting_Height_Adjustment = 'Mechanical' AND c.City = 'Seattle';	lawnmower	3
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers mf ON lm.Manufacturer_ID = mf.Manufacturer_ID WHERE s.Quantity > mf.Production_Volume_Total * 5 AND s.Shipping_Cost < lm.Price * 0.001;	lawnmower	4
SELECT CEIL( (pm.Torque * pm.Blade_Speed * 3) / ((pm.Energy_Efficiency / 100.0) * 9549) / (lm.Battery_Capacity * 12) ) AS Batteries_Needed FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 10 AND pm.Energy_Efficiency = 85 AND pm.Blade_Speed = 3000 AND pm.Torque = 15;	lawnmower	1
SELECT m.Manufacturer_ID, m.Name, SUM(s.Total_Price * (m.Profit_Margin / 100.0)) / SUM(s.Total_Price) AS Avg_Profit_Margin FROM manufacturers m JOIN lawn_mowers lm ON m.Manufacturer_ID = lm.Manufacturer_ID JOIN sales s ON lm.Mower_ID = s.Mower_ID WHERE m.`R&D_Spending`/ m.Revenue > 0.05 AND m.Revenue > 100000000 AND strftime('%Y', s.Sale_Date) = '2023' GROUP BY m.Manufacturer_ID, m.Name;	lawnmower	2
SELECT CASE WHEN (1.5 * 2 * 4 * 13 * 1.2) > 200 THEN 'Yes' ELSE 'No' END AS Exceeds_200;	lawnmower	3
SELECT CASE WHEN (lm.Weight * 9.8) / (4 * 3.141592653589793 * ((lm.Wheel_Size * 0.0254 / 2) * (lm.Wheel_Size * 0.0254 / 2))) > 200000 THEN 'Yes' ELSE 'No' END AS Exceeds_Pressure FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight = 1000 AND lm.Wheel_Size = 2 AND pm.Slope_Handling >= 30;	lawnmower	4
SELECT m.Model FROM mice m JOIN (SELECT Mouse_ID, SUM(Distance_Moved_Meters) AS total_dist, SUM(Energy_Consumed_Joules) AS total_energy FROM usage_records GROUP BY Mouse_ID) u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND (u.total_dist * m.Weight_Grams) / (u.total_energy / 1000.0) < 5 AND m.Weight_Grams > 100;	mouse	1
WITH CalibrationData AS (     SELECT          Sensor_Id,          Last_Calibration_Date,          LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date      FROM sensor_data )  SELECT      m.Model,      ma.Market_Share_Percent  FROM CalibrationData cd  JOIN sensor_data sd ON cd.Sensor_Id = sd.Sensor_Id  JOIN mice m ON sd.Mouse_Id = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE julianday(cd.Last_Calibration_Date) - julianday(cd.prev_date) < 30  GROUP BY m.Model, ma.Market_Share_Percent  HAVING COUNT(*) > 5;	mouse	2
SELECT u.User_ID, m.Weight_Grams FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id WHERE u.Max_Dpi > 16000 AND u.Usage_Duration_Minutes > 120;	mouse	3
SELECT 0.62 * (Weight_Grams/1000.0) * (24.79 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'G502 HERO';	mouse	4
WITH EfficiencyData AS (   SELECT      m.Mouse_Id,      m.Model,      m.Weight_Grams,      AVG((u.Distance_Moved_Meters * m.Weight_Grams) / (u.Energy_Consumed_Joules / 1000.0)) AS normal_efficiency    FROM mice m    JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID    WHERE m.Is_Wireless = 1 AND m.Acceleration_G < 10    GROUP BY m.Mouse_Id, m.Model, m.Weight_Grams ),  ExtremeEfficiency AS (   SELECT      m.Mouse_Id,      (u.Distance_Moved_Meters * m.Weight_Grams) / (u.Energy_Consumed_Joules / 1000.0) AS extreme_efficiency    FROM mice m    JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID    WHERE m.Is_Wireless = 1 AND m.Acceleration_G > 50 )  SELECT e.Model  FROM EfficiencyData e  JOIN ExtremeEfficiency ex ON e.Mouse_Id = ex.Mouse_Id  WHERE (e.normal_efficiency - ex.extreme_efficiency) / e.normal_efficiency * 100.0 > 30.0 AND e.Weight_Grams > 100;	mouse	1
WITH ClickFrequency AS (     SELECT          User_ID,          Mouse_ID,          Clicks,          Usage_Duration_Minutes,          Clicks / (Usage_Duration_Minutes / 60.0) AS click_freq,          SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_clicks,          SUM(Usage_Duration_Minutes) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_duration      FROM usage_records )  SELECT DISTINCT cf.User_ID, m.Model  FROM ClickFrequency cf  JOIN mice m ON cf.Mouse_ID = m.Mouse_Id  WHERE cf.click_freq > 600 AND cf.total_duration > 5;	mouse	2
WITH CalibrationIntervals AS (     SELECT Sensor_Id, Last_Calibration_Date,             LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date      FROM sensor_data ) SELECT m.Model, ma.Profit_Usd  FROM CalibrationIntervals ci  JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id  JOIN mice m ON sd.Mouse_Id = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_ID  WHERE (julianday(ci.Last_Calibration_Date) - julianday(ci.prev_date)) < 7  AND ur.Mouse_ID IN (     SELECT Mouse_ID      FROM usage_records      WHERE EXISTS (         SELECT 1          FROM sensor_data sd2          JOIN mice m2 ON sd2.Mouse_Id = m2.Mouse_Id          WHERE m2.Mouse_Id = ur.Mouse_ID          AND sd2.Sensor_Type LIKE '%CMOS%'          AND ur.Average_Dpi > 0      )     GROUP BY Mouse_ID      HAVING AVG(ur.Energy_Consumed_Joules / ur.Usage_Duration_Minutes) * 60 > 45  );	mouse	3
SELECT 0.0001 * (Weight_Grams/1000) * (274 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'DeathAdder V2';	mouse	4
SELECT m.Model FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Tracking_Speed_Ips > 400 AND m.Polling_Rate_Hz > 1000 AND (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules * 100 < 60;	mouse	1
WITH ClickFrequency AS (     SELECT          User_ID,          Mouse_ID,          Start_Time,          Clicks,          SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS 4 PRECEDING) / 5.0 AS window_freq      FROM usage_records ),  ConsecutiveHighFreq AS (     SELECT          User_ID,          Mouse_ID,          window_freq,          LAG(window_freq, 1) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq1,          LAG(window_freq, 2) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq2      FROM ClickFrequency      WHERE window_freq > 1200 )  SELECT DISTINCT chf.User_ID, m.Acceleration_G  FROM ConsecutiveHighFreq chf  JOIN mice m ON chf.Mouse_ID = m.Mouse_Id  WHERE chf.window_freq > 1200 AND chf.prev_freq1 > 1200 AND chf.prev_freq2 > 1200;	mouse	2
SELECT m.Model, ma.Founded_year FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE sd.Lift_Off_Distance_Mm < 1.5 AND sd.Max_Dpi > 18000;	mouse	3
SELECT (2.3e-5 * 10 * 600) / SQRT(10 * 5) * 100 AS precision_error FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	4
SELECT m.Model  FROM mice m  JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID  WHERE ((u.Distance_Moved_Meters * m.Weight_Grams * POW((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Distance_Moved_Meters / 1000)) / (u.Usage_Duration_Minutes * 60) > 10  AND (u.Distance_Moved_Meters * m.Weight_Grams * POW((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Energy_Consumed_Joules * 1000) * 100 < 40;	mouse	1
WITH ClickPatterns AS (     SELECT User_ID, Mouse_ID, Clicks, (log(Clicks) / log(2)) AS log2_clicks      FROM usage_records      WHERE Clicks > 0 AND (log(Clicks) / log(2)) % 1 = 0 ) SELECT cp.User_ID, m.Polling_Rate_Hz  FROM ClickPatterns cp  JOIN mice m ON cp.Mouse_ID = m.Mouse_Id;	mouse	2
SELECT u.User_ID, ma.Market_Share_Percent FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE m.Weight_Grams > 150 AND (u.Usage_Duration_Minutes / 60.0) / 7.0 > 8;	mouse	3
SELECT (6.626e-34 / (2 * ("Weight_Grams"/1000.0) * SQRT(2 * ("Weight_Grams"/1000.0) * 1.6e-19))) * ("Weight_Grams"/1000.0) * 9.8e12 * 0.001 AS Energy_Joules FROM mice WHERE "Is_Wireless" = 1;	mouse	4
SELECT m.Model FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Acceleration_G > 80 AND ((m.Weight_Grams / 1000.0) * (m.Tracking_Speed_Ips * 0.0254) * m.Polling_Rate_Hz) > 1;	mouse	1
WITH ClickSequences AS (   SELECT      User_ID,      Mouse_ID,      Start_Time,      Clicks,      LAG(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_clicks    FROM usage_records ),  TransitionMatrix AS (   SELECT      User_ID,      Mouse_ID,      COUNT(*) AS total_transitions,      SUM(CASE WHEN Clicks = prev_clicks THEN 1 ELSE 0 END) AS same_state_count    FROM ClickSequences    GROUP BY User_ID, Mouse_ID )  SELECT tm.User_ID, sd.Sensor_Life_Hours  FROM TransitionMatrix tm  JOIN sensor_data sd ON tm.Mouse_ID = sd.Mouse_Id  WHERE (CAST(same_state_count AS REAL) / total_transitions) > 0.5;	mouse	2
WITH CalibrationIntervals AS (     SELECT          Sensor_Id,          Last_Calibration_Date,          LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date      FROM sensor_data     WHERE EMI_Level > 30 ) SELECT      m.Model,      ma.Founded_year  FROM CalibrationIntervals ci  JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id  JOIN mice m ON sd.Mouse_Id = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE m.Is_Wireless = 1  AND julianday(ci.Last_Calibration_Date) - julianday(ci.prev_date) < 3;	mouse	3
SELECT (2 * 1e8 * 0.01) AS Photon_Force_N FROM mice WHERE Is_Wireless = 1;	mouse	4
WITH EnergyAnalysis AS (     SELECT          m.Mouse_Id,          m.Model,          m.Acceleration_G,          m.Weight_Grams,          u.Energy_Consumed_Joules,          u.Distance_Moved_Meters      FROM mice m      JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID      JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id      WHERE ABS(u.Max_Dpi - u.Average_Dpi) > 8000 )  SELECT ea.Model  FROM EnergyAnalysis ea  WHERE (1.0 - ((ea.Distance_Moved_Meters * ea.Weight_Grams * 9.8) / ea.Energy_Consumed_Joules)) * 100.0 > 25.0  AND ea.Acceleration_G > 50.0;	mouse	1
WITH ClickIntervals AS (     SELECT          User_ID,          Mouse_ID,          Start_Time,          LAG(Start_Time) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_time      FROM usage_records ), RS_Analysis AS (     SELECT          User_ID,          Mouse_ID,          LOG(MAX(Start_Time) - MIN(Start_Time) + 1) / LOG(COUNT(*) + 1) AS Hurst_Index      FROM ClickIntervals      GROUP BY User_ID, Mouse_ID      HAVING COUNT(*) >= 10 ) SELECT rs.User_ID, ma.Market_Share_Percent  FROM RS_Analysis rs  JOIN mice m ON rs.Mouse_ID = m.Mouse_Id  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE rs.Hurst_Index > 0.8;	mouse	2
SELECT m.Model, ma.Complaint_Rate  FROM mice m  JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID  JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id  WHERE (u.Usage_Duration_Minutes / 60.0) / m.Battery_Life_Hours < 0.5  AND m.Is_Wireless = 1;	mouse	3
SELECT ( (20 * LOG(160 / 1e6) / LOG(10) + 50) - 10 * LOG(1.6e6 / (2 * PI() * 160 * 1e-4)) / LOG(10) ) / (4 * PI() * SQRT(PI() * 160 * 1e-4 * 1.6e6)) AS Shield_Thickness_m FROM mice WHERE Sensor_Type = 'Laser';	mouse	4
SELECT 0.5 * 0.133 * POWER(40 * 9.8 * 7200, 2) AS Kinetic_Energy_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
SELECT ma.Manufacturer_Name, AVG(CASE WHEN m.Is_Wireless = 1 THEN m.Price_Usd END) / AVG(CASE WHEN m.Is_Wireless = 0 THEN m.Price_Usd END) AS Wireless_Wired_Ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name ORDER BY Wireless_Wired_Ratio DESC LIMIT 5;	mouse	2
SELECT DISTINCT m.Model, 'High Risk' AS Risk_Level FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Tracking_Speed_Ips > 0.9 * sd.Tracking_Speed_Ips;	mouse	3
SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT m.Weight_Grams / 1000.0 * (50.0 * 9.8) * (50.0 * 9.8 * 150.0 * 60.0) AS Power_W FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'DeathAdder V2' AND u.User_ID = 102;	mouse	1
SELECT m.Model, (m.Price_Usd / m.Dpi) AS Usd_Per_Dpi FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE ma.Revenue_Usd > 1000000000 AND ma.Market_Share_Percent > 10 ORDER BY Usd_Per_Dpi ASC LIMIT 3;	mouse	2
SELECT m.Model, (u.Usage_Duration_Minutes - m.Battery_Life_Hours * 60) * 1.0 / u.Usage_Duration_Minutes AS Shortage_Ratio FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND u.Usage_Duration_Minutes > m.Battery_Life_Hours * 60;	mouse	3
SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'Dark Core RGB Pro';	mouse	4
SELECT (m.Weight_Grams / 1000.0) * (m.Acceleration_G * 9.8) * u.Distance_Moved_Meters AS Mechanical_Work_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
WITH MarketShare AS (     SELECT Country, SUM(Market_Share_Percent) AS Total_Market_Share      FROM manufacturers      GROUP BY Country      ORDER BY Total_Market_Share DESC      LIMIT 3 ),  TopManufacturers AS (     SELECT ma.Manufacturer_Id, ma.Manufacturer_Name      FROM manufacturers ma      JOIN MarketShare ms ON ma.Country = ms.Country      ORDER BY (ma.Profit_Usd * 1.0 / ma.Employees) DESC      LIMIT 1 )  SELECT m.Model, (m.Dpi * m.Dpi * 1.0 / m.Price_Usd) AS Dpi2_Per_Usd  FROM mice m  JOIN TopManufacturers tm ON m.Manufacturer_Id = tm.Manufacturer_Id;	mouse	2
WITH CalibrationIntervals AS (     SELECT          Sensor_Id,          (julianday(Last_Calibration_Date) - julianday(LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date))) AS Calibration_Interval      FROM sensor_data ),  ClickStats AS (     SELECT          Mouse_ID,          AVG(Clicks / (julianday(End_Time) - julianday(Start_Time))) AS Avg_Clicks_Per_Day,          (SELECT STDEV(Clicks / (julianday(End_Time) - julianday(Start_Time))) FROM usage_records WHERE Mouse_ID = ur.Mouse_ID) AS Std_Clicks_Per_Day      FROM usage_records ur      GROUP BY Mouse_ID )  SELECT m.Model  FROM mice m  JOIN CalibrationIntervals ci ON m.Mouse_Id = ci.Sensor_Id  JOIN ClickStats cs ON m.Mouse_Id = cs.Mouse_ID  WHERE ci.Calibration_Interval > 30  AND (cs.Avg_Clicks_Per_Day > (SELECT AVG(Avg_Clicks_Per_Day) + 2 * (SELECT STDEV(Avg_Clicks_Per_Day) FROM ClickStats) FROM ClickStats));	mouse	3
SELECT Tracking_Speed_Ips * Polling_Rate_Hz AS Interrupts_Per_Second FROM mice WHERE Model = 'G502 HERO';	mouse	4
SELECT ((m.Weight_Grams / 1000.0) * m.Acceleration_G * 9.8 * u.Distance_Moved_Meters) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
SELECT Manufacturer_Name, Market_Share_Percent * (Profit_Usd / Employees) AS Composite_Index FROM manufacturers WHERE Market_Share_Percent * (Profit_Usd / Employees) > 100 AND Founded_year < (strftime('%Y', 'now') - 20) ORDER BY Composite_Index DESC LIMIT 5;	mouse	2
SELECT m.Model, ROUND(m.Battery_Life_Hours / (AVG(u.Usage_Duration_Minutes) / 60.0), 2) AS Max_Usage_Days FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Battery_Life_Hours HAVING m.Battery_Life_Hours < AVG(u.Usage_Duration_Minutes) / 60.0;	mouse	3
SELECT Polling_Rate_Hz * Acceleration_G AS Packets_Per_Second FROM mice WHERE Polling_Rate_Hz = 2000 AND Acceleration_G = 50;	mouse	4
SELECT (u.Distance_Moved_Meters / (sd.Lift_Off_Distance_Mm / 1000.0)) * 0.5 * 1e-3 AS Total_Energy_Loss_J FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
WITH ManufacturerStats AS (     SELECT          ma.Manufacturer_Id,          (STDEV(m.Price_Usd) / AVG(m.Price_Usd)) AS Price_CV,          ma.Market_Share_Percent      FROM          manufacturers ma      JOIN          mice m ON ma.Manufacturer_Id = m.Manufacturer_Id      WHERE          (strftime('%Y', 'now') - ma.Founded_year) > 25          AND m.Is_Wireless = 1      GROUP BY          ma.Manufacturer_Id, ma.Market_Share_Percent ) SELECT      Manufacturer_Id,      (SUM(Price_CV * Market_Share_Percent) - SUM(Price_CV) * SUM(Market_Share_Percent) / COUNT(*)) / COUNT(*) AS Covariance  FROM      ManufacturerStats  GROUP BY      Manufacturer_Id  ORDER BY      ABS(Covariance) DESC;	mouse	2
SELECT m.Model, SUM(u.Clicks) * 1.0 / SUM(u.Usage_Duration_Minutes) AS Click_Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 0 AND m.Weight_Grams > 100 AND m.Cable_Length_Meters < 1.5 GROUP BY m.Model;	mouse	3
SELECT (1 / 5.39e-44) * (18000 / 25.4) * 8 / pow(10, 24) AS Data_Volume_YB FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	4
SELECT (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
SELECT ma.Manufacturer_Name, AVG(CAST(m.Dpi AS REAL) / m.Price_Usd) AS Dpi_Per_Usd FROM manufacturers ma JOIN mice m ON ma.Manufacturer_Id = m.Manufacturer_Id WHERE 2023 - ma.Founded_year > 20 AND (CAST(ma.Profit_Usd AS REAL) / ma.Employees) > 200000 GROUP BY ma.Manufacturer_Name;	mouse	2
SELECT m.Model, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS Daily_Clicks, CASE WHEN SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) > 8000 AND m.Weight_Grams > 120 THEN 'High Risk' ELSE 'Normal' END AS Risk_Level FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Weight_Grams;	mouse	3
SELECT sd.Tracking_Speed_Ips * sd.Max_Dpi AS Data_Points_Per_Second FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro';	mouse	4
SELECT (m.Weight_Grams/1000.0) * POWER(2 * 3.141592653589793 * sd.Polling_Rate_Hz, 2) * (sd.Acceleration_G * 9.8 / SQRT(2)) AS Inertial_Force FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Model = 'G502 HERO' AND ur.User_ID = 101 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');	mouse	1
WITH Market_HHI AS (     SELECT SUM(Market_Share_Percent * Market_Share_Percent) AS HHI     FROM manufacturers ), Manufacturer_DPI AS (     SELECT Manufacturer_Id, Dpi,             CAST(COUNT(*) AS REAL) / SUM(COUNT(*)) OVER(PARTITION BY Manufacturer_Id) AS ratio     FROM mice     GROUP BY Manufacturer_Id, Dpi ), Entropy_Calc AS (     SELECT Manufacturer_Id,             -SUM(ratio * (CASE WHEN ratio > 0 THEN ln(ratio) ELSE 0 END)) AS entropy     FROM Manufacturer_DPI     GROUP BY Manufacturer_Id ) SELECT (AVG(mh.HHI * ec.entropy) - AVG(mh.HHI) * AVG(ec.entropy)) /         (STDDEV_SAMP(mh.HHI) * STDDEV_SAMP(ec.entropy)) AS Pearson_Correlation FROM Market_HHI mh, Entropy_Calc ec;	mouse	2
WITH Efficiency_Data AS (SELECT m.Model, ur.Clicks/ur.Usage_Duration_Minutes AS current_efficiency, MAX(ur.Clicks/ur.Usage_Duration_Minutes) OVER() AS max_efficiency FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Weight_Grams > 100 AND m.Buttons < 6) SELECT Model, ROUND(max_efficiency - current_efficiency, 4) AS efficiency_decay FROM Efficiency_Data;	mouse	3
WITH constants AS (   SELECT 6.67430e-11 AS G, 1.989e30 AS M, 299792458 AS c, 0.9 AS factor ), sqrt_part AS (   SELECT SQRT(POWER(M, 2) - POWER(factor * M, 2)) AS sqrt_value   FROM constants ), numerator AS (   SELECT 1 - SQRT(1 - (2 * G * M) / (POWER(c, 2) * (M + sqrt_value))) AS num   FROM constants, sqrt_part ), denominator AS (   SELECT 1 + (factor * c * POWER(M + sqrt_value, 3)) / POWER(c, 3) AS denom   FROM constants, sqrt_part ) SELECT m.Dpi * (num / denom) AS DPI_Error FROM mice m, numerator, denominator WHERE m.Model = 'DeathAdder V2'   AND m.Manufacturer_Id = (     SELECT Manufacturer_Id     FROM manufacturers     WHERE Manufacturer_Name = 'Razer'   );	mouse	4
SELECT (ur.Clicks * 0.0002) + (m.Weight_Grams/1000 * 9.8 * 0.003 * ur.Clicks) AS Total_Energy_J FROM usage_records ur JOIN mice m ON ur.Mouse_Id = m.Mouse_Id JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'DeathAdder V2' AND ur.User_ID = 102 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');	mouse	1
WITH YearSeries AS (     SELECT 0 AS year      UNION ALL SELECT 1      UNION ALL SELECT 2 ),  MarketData AS (     SELECT m.Manufacturer_Id,             CAST(strftime('%Y', date('now')) AS INTEGER) - ys.year AS Year,             COALESCE(m.Market_Share_Percent, 0) AS Share      FROM manufacturers m      CROSS JOIN YearSeries ys      WHERE m.Founded_year <= CAST(strftime('%Y', date('now')) AS INTEGER) - ys.year ),  TransProb AS (     SELECT curr.Manufacturer_Id,             (curr.Share - prev.Share) / NULLIF(prev.Share, 0) AS Prob      FROM MarketData curr      JOIN MarketData prev ON curr.Manufacturer_Id = prev.Manufacturer_Id AND curr.Year = prev.Year + 1 ),  Entropy AS (     SELECT Manufacturer_Id,             -SUM((cnt * 1.0 / total) * (CASE WHEN cnt * 1.0 / total = 0 THEN 0 ELSE LN(cnt * 1.0 / total) END)) AS entropy      FROM (         SELECT Manufacturer_Id,                 Dpi,                 COUNT(*) AS cnt,                 SUM(COUNT(*)) OVER (PARTITION BY Manufacturer_Id) AS total          FROM mice          GROUP BY Manufacturer_Id, Dpi     ) t      GROUP BY Manufacturer_Id )  SELECT t.Manufacturer_Id,         SUM(t.Prob * (CASE WHEN t.Prob * 1.0 / NULLIF(e.entropy, 0) = 0 THEN 0 ELSE LN(t.Prob * 1.0 / NULLIF(e.entropy, 0)) END)) AS KL_Divergence  FROM TransProb t  JOIN Entropy e ON t.Manufacturer_Id = e.Manufacturer_Id  GROUP BY t.Manufacturer_Id;	mouse	2
SELECT m.Model, (ur.Scrolls/ur.Usage_Duration_Minutes) * POW(m.Weight_Grams/1000.0,2)/NULLIF(m.Cable_Length_Meters,0) AS Fatigue_Factor FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Cable_Length_Meters < 1 AND m.Weight_Grams > 150;	mouse	3
SELECT m.Dpi * (1.0 * 1e43 * 1e-43) / 1.32934 AS Effective_DPI FROM mice m WHERE m.Model = 'G502 HERO' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');	mouse	4
SELECT (m.Weight_Grams/1000.0 * POWER(sd.Acceleration_G * 9.8, 2)) / 3000.0 * (m.Cable_Length_Meters / (0.2 * 3.141592653589793 * POWER(0.001, 2))) AS Thermal_Power_W FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Corsair');	mouse	1
WITH Market_Share_Data AS (     SELECT          Manufacturer_Id,          Market_Share_Percent,          ROW_NUMBER() OVER (PARTITION BY Manufacturer_Id ORDER BY Founded_year) AS rn      FROM manufacturers ),  GM_Model AS (     SELECT          Manufacturer_Id,          (FIRST_VALUE(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id ORDER BY rn) -          (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) * 1.0 / COUNT(*) OVER (PARTITION BY Manufacturer_Id))) * EXP(-0.5 * (rn-1)) +          (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) * 1.0 / COUNT(*) OVER (PARTITION BY Manufacturer_Id)) AS Predicted_Share      FROM Market_Share_Data ),  Mouse_Matrix AS (     SELECT          Manufacturer_Id,          AVG(Dpi) AS avg_dpi,          AVG(Price_Usd) AS avg_price,          AVG(Weight_Grams) AS avg_weight      FROM mice      GROUP BY Manufacturer_Id ),  SVD_Decomp AS (     SELECT          Manufacturer_Id,          avg_dpi / SQRT(avg_dpi*avg_dpi + avg_price*avg_price + avg_weight*avg_weight) AS u1,          avg_price / SQRT(avg_dpi*avg_dpi + avg_price*avg_price + avg_weight*avg_weight) AS u2,          avg_weight / SQRT(avg_dpi*avg_dpi + avg_price*avg_price + avg_weight*avg_weight) AS u3      FROM Mouse_Matrix ),  Covariance_Matrix AS (     SELECT          gm.Manufacturer_Id,          gm.Predicted_Share * svd.u1 AS cov1,          gm.Predicted_Share * svd.u2 AS cov2,          gm.Predicted_Share * svd.u3 AS cov3      FROM GM_Model gm      JOIN SVD_Decomp svd ON gm.Manufacturer_Id = svd.Manufacturer_Id )  SELECT      AVG(cov1) / SQRT(AVG(gm.Predicted_Share * gm.Predicted_Share) * AVG(svd.u1 * svd.u1)) AS rho1,      AVG(cov2) / SQRT(AVG(gm.Predicted_Share * gm.Predicted_Share) * AVG(svd.u2 * svd.u2)) AS rho2,      AVG(cov3) / SQRT(AVG(gm.Predicted_Share * gm.Predicted_Share) * AVG(svd.u3 * svd.u3)) AS rho3  FROM Covariance_Matrix cm  JOIN GM_Model gm ON cm.Manufacturer_Id = gm.Manufacturer_Id  JOIN SVD_Decomp svd ON cm.Manufacturer_Id = svd.Manufacturer_Id;	mouse	2
SELECT m.Model, (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 AS Efficiency_Percent FROM mice m WHERE m.Is_Wireless = 1 AND EXISTS (SELECT 1 FROM sensor_data sd WHERE sd.Mouse_Id = m.Mouse_Id AND sd.Max_Dpi > 16000) AND (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 < 80;	mouse	3
SELECT m.Dpi * (1 + 1100) / (70 * 4.4e26 / 3.086e19) * LN(1.6e-35/1.6e-35) AS Effective_DPI FROM mice m WHERE m.Model = 'DeathAdder V2' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');	mouse	4
SELECT 20*(LOG10(4*PI()*1*(2.4e9/3e8)))/LOG(10) - 2 - 2 AS Path_Loss_dB FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Is_Wireless = 1;	mouse	1
CREATE TEMPORARY TABLE BaseData AS SELECT mf.Market_Share_Percent AS Y, md.Dpi AS X1, md.Price_Usd AS X2 FROM mice md JOIN manufacturers mf ON md.Manufacturer_Id = mf.Manufacturer_Id; CREATE TEMPORARY TABLE Stats AS SELECT AVG(Y) AS y_bar, AVG(X1) AS x1_bar, AVG(X2) AS x2_bar, AVG(Y * X1) - AVG(Y) * AVG(X1) AS cov_yx1, AVG(Y * X2) - AVG(Y) * AVG(X2) AS cov_yx2, AVG(X1 * X1) - AVG(X1) * AVG(X1) AS var_x1, AVG(X2 * X2) - AVG(X2) * AVG(X2) AS var_x2, AVG(X1 * X2) - AVG(X1) * AVG(X2) AS cov_x1x2 FROM BaseData; CREATE TEMPORARY TABLE Coefficients AS SELECT (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) AS beta1, (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) AS beta2, y_bar - ( (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) ) * x1_bar - ( (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - (cov_x1x2 * cov_x1x2)) ) * x2_bar AS beta0 FROM Stats; CREATE TEMPORARY TABLE Predicted AS SELECT b.Y, c.beta0 + c.beta1 * b.X1 + c.beta2 * b.X2 AS Y_hat FROM BaseData b CROSS JOIN Coefficients c; SELECT 1 - SUM((Y - Y_hat) * (Y - Y_hat)) / SUM((Y - (SELECT y_bar FROM Stats)) * (Y - (SELECT y_bar FROM Stats))) AS R_squared FROM Predicted;	mouse	2
SELECT m.Model, (ur.Energy_Consumed_Joules / (3600 * 1000)) * 18 * 365 * 0.85 AS Annual_CO2_kg FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Is_Wireless = 1 AND (ur.Energy_Consumed_Joules / (3600 * ur.Usage_Duration_Minutes * 60)) > 0.5;	mouse	3
SELECT m.Dpi * POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000.0 * 100.0))/(1e-6), 2.0) * LN(1e-4/(PI()*POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000.0 * 100.0)),2.0))) AS DPI_Error FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT ROUND( (0.5 * (m.Weight_Grams / 1000.0) * POWER(s.Tracking_Speed_Ips * 0.0254, 2) - 0.2 * (m.Weight_Grams / 1000.0) * 9.8 * u.Distance_Moved_Meters * SIN(RADIANS(15.0))) / (u.Usage_Duration_Minutes * 60.0), 6 ) AS Kinetic_Energy_Change FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
WITH PriceWeightRatio AS (   SELECT      man.Manufacturer_Name,      CAST(m.Price_Usd AS REAL) / m.Weight_Grams AS Ratio,      man.Market_Share_Percent    FROM mice m    JOIN manufacturers man ON m.Manufacturer_Id = man.Manufacturer_Id ),  Stats AS (   SELECT      Manufacturer_Name,      STDEV(Ratio) AS StdDev,      AVG(Ratio) AS Mean,      Market_Share_Percent    FROM PriceWeightRatio    GROUP BY Manufacturer_Name, Market_Share_Percent )  SELECT    Manufacturer_Name,    ROUND(CAST(StdDev AS REAL) / Mean, 4) AS CV,    CASE WHEN Market_Share_Percent > 25 THEN 1 ELSE 0 END AS Segment  FROM Stats  ORDER BY CV DESC;	mouse	2
SELECT DISTINCT m.Model FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE (CAST(u.Usage_Duration_Minutes AS REAL) / 60.0) / 8.0 / s.Sensor_Life_Hours > 0.9;	mouse	3
SELECT ROUND(0.5 * (1e-12 * 2 * 10 / (m.Weight_Grams / 1000.0)) * POWER(1.0 / 1000, 2), 12) AS Trajectory_Offset FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT (0.3 * (m.Weight_Grams/1000.0) * 9.81 * u.Distance_Moved_Meters + 0.5 * (m.Weight_Grams/1000.0) * POWER(u.Distance_Moved_Meters/(u.Usage_Duration_Minutes*60.0), 2)) / (u.Usage_Duration_Minutes*60.0) * 1000.0 AS power_mw FROM usage_records u JOIN mice m ON u.Mouse_Id = m.Mouse_Id WHERE m.Model = 'G502 HERO' AND DATE(u.Start_Time) = '2023-10-01';	mouse	1
WITH IndexCalc AS (     SELECT          m.Model,          (AVG(s.Sensor_Life_Hours) * m.Dpi) / (m.Price_Usd * m.Weight_Grams) AS efficacy_index      FROM mice m      JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id      GROUP BY m.Model, m.Dpi, m.Price_Usd, m.Weight_Grams )  SELECT Model, efficacy_index  FROM IndexCalc  ORDER BY efficacy_index DESC  LIMIT 3;	mouse	2
SELECT m.Model, MAX(s.Lift_Off_Distance_Mm) AS current_lift, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS daily_clicks, JULIANDAY('now') - JULIANDAY(MAX(s.Last_Calibration_Date)) AS days_since_calib FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id GROUP BY m.Model HAVING current_lift < 2 AND daily_clicks > 1000 AND days_since_calib > 90;	mouse	3
SELECT (6.626e-34 * 3e8) / (500e-9 * POWER(1.0e6 / m.Dpi, 2)) AS photons_per_pixel, CASE WHEN (1.0e6 / m.Dpi) < (6.626e-34 / (2 * 3.141592653589793)) THEN 'Breakthrough Heisenberg Limit' ELSE 'Theoretically Feasible' END AS quantum_status FROM mice m CROSS JOIN (SELECT 1000000 AS target_dpi) WHERE m.Is_Wireless = 1;	mouse	4
SELECT 0.5 * (Weight_Grams / 1000.0) * POWER((400 * 0.0254), 2) AS Kinetic_Energy_Joules FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	1
WITH FilteredData AS (     SELECT          Country,          Market_Share_Percent,          CAST(Profit_Usd AS REAL) / Employees AS Profit_Per_Employee      FROM manufacturers      WHERE Founded_year > 1993 )  SELECT      Country,      AVG((Market_Share_Percent - mean_ms) * (Market_Share_Percent - mean_ms)) AS Market_Share_Variance,     (AVG(Market_Share_Percent * Profit_Per_Employee) - AVG(Market_Share_Percent) * AVG(Profit_Per_Employee)) AS Covariance  FROM      FilteredData,      (SELECT AVG(Market_Share_Percent) AS mean_ms FROM FilteredData)  GROUP BY Country  ORDER BY Covariance DESC;	mouse	2
SELECT Model, Battery_Life_Hours, Price_Usd, Battery_Life_Hours / Price_Usd AS Value_Per_USD FROM mice WHERE Is_Wireless = 1 AND Battery_Life_Hours > Price_Usd;	mouse	3
SELECT (2997924.58 / 0.0254) * 16000 / 1000000 AS Packets_Per_Second;	mouse	4
SELECT Energy_Consumed_Joules / (Usage_Duration_Minutes * 60) AS power_watts FROM usage_records WHERE User_Id = 101 AND Mouse_Id = (SELECT Mouse_Id FROM mice WHERE Model = 'G502 HERO') AND Distance_Moved_Meters = 1500.5 AND Energy_Consumed_Joules = 5000 AND Usage_Duration_Minutes = 120;	mouse	1
SELECT Manufacturer_Name, ROUND((Revenue_Usd*0.3 + Profit_Usd*0.4 + Market_Share_Percent*2 + Employees*0.1)/1000, 3) AS composite_score FROM manufacturers ORDER BY composite_score DESC;	mouse	2
SELECT m.Model, m.Battery_Life_Hours, (SELECT MAX(u.Usage_Duration_Minutes)/60.0 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id) AS max_usage_hours FROM mice m WHERE m.Is_Wireless = 1 AND m.Battery_Life_Hours < (SELECT MAX(u.Usage_Duration_Minutes)/60.0 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id);	mouse	3
SELECT (3 * 9.461e15) / (450 * 0.0254) / (365*24*3600) AS time_years;	mouse	4
SELECT (m.Weight_Grams / 1000.0) * (50 * 9.8) AS force_newton FROM mice m WHERE m.Model = 'DeathAdder V2';	mouse	1
SELECT ma.Manufacturer_Name, (MAX(m.Dpi) / m.Price_Usd) * 1000 AS dpi_ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name, m.Price_Usd ORDER BY dpi_ratio DESC LIMIT 3;	mouse	2
SELECT m.Model, s.Lift_Off_Distance_Mm, m.Cable_Length_Meters FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Is_Wireless = 0 AND s.Lift_Off_Distance_Mm > 2 AND m.Cable_Length_Meters < 1.5;	mouse	3
SELECT (299792458 / 0.0254) * 8 / 1e15 AS data_pb;	mouse	4
SELECT 0.5 * (m.Weight_Grams/1000.0) * (0.8 * 0.8) AS kinetic_energy_joules FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id WHERE m.Model = 'G502 HERO' AND u.User_Id = 101 AND u.Distance_Moved_Meters = 1500.5;	mouse	1
SELECT Manufacturer_Name, ROUND((Profit_Usd/Employees)/(SELECT AVG(Profit_Usd/Employees) FROM manufacturers), 2) AS profit_ratio FROM manufacturers ORDER BY profit_ratio DESC;	mouse	2
SELECT s.*, t.total_hours FROM sensor_data s JOIN (SELECT Mouse_Id, SUM(Usage_Duration_Minutes)/60.0 AS total_hours FROM usage_records GROUP BY Mouse_Id) t ON s.Mouse_Id = t.Mouse_Id WHERE s.Sensor_Life_Hours < t.total_hours;	mouse	3
SELECT (0.9 * 3e8) / (20000 * 9.8) / 3.15e7 AS time_years;	mouse	4
SELECT ROUND((0.121 * 40 * 9.8) * (1500.5 / (120 * 60)), 4) AS Instantaneous_Power FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Logitech' AND mc.Model = 'G502 HERO' AND ur.User_ID = 101;	mouse	1
SELECT mf.Manufacturer_Name, ROUND((MAX(mc.Price_Usd) - MIN(mc.Price_Usd)) / AVG(mc.Price_Usd), 3) AS price_dispersion, mf.Market_Share_Percent FROM manufacturers mf JOIN mice mc ON mf.Manufacturer_Id = mc.Manufacturer_Id GROUP BY mf.Manufacturer_Id ORDER BY price_dispersion DESC, mf.Market_Share_Percent DESC;	mouse	2
SELECT * FROM sensor_data WHERE Calibration_Count > (Sensor_Life_Hours / 100);	mouse	3
SELECT (8.8e26 / (0.0254 / 1e18)) AS movement_times, ROUND(( (8.8e26 / (0.0254 / 1e18)) * 1 * 1000 * 3.154e7 * 1000 ) / 1e24, 3) AS data_yb;	mouse	4
SELECT ROUND((82.0/1000.0) * (450*0.0254), 4) AS Momentum_Change FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Razer' AND mc.Model = 'DeathAdder V2';	mouse	1
SELECT Manufacturer_Name, ROUND((POWER(Profit_Usd, 1.0 / (2023 - Founded_year)) - 1) * 100, 2) AS CAGR FROM manufacturers ORDER BY CAGR DESC;	mouse	2
SELECT * FROM mice WHERE (Is_Wireless=1 AND Battery_Life_Hours IS NULL) OR (Is_Wireless=0 AND Battery_Life_Hours IS NOT NULL);	mouse	3
SELECT (0.0254 / 1e6) AS Min_Movement_Distance, ROUND((30720 * 17280 * 10 * 6 * 3600 * 365 * 8 / 1e8), 2) AS Annual_Data_Volume_EB;	mouse	4
SELECT (1000.25 / (120 * 60)) / 0.0254 AS Actual_IPS, CASE WHEN (1000.25 / (120 * 60)) / 0.0254 > 400 THEN 'Exceeds Max Tracking Speed' ELSE 'Within Max Tracking Speed' END AS Speed_Status FROM usage_records ur JOIN mice mc ON ur.Mouse_ID = mc.Mouse_Id JOIN manufacturers mf ON mc.Manufacturer_Id = mf.Manufacturer_Id WHERE mf.Manufacturer_Name = 'Corsair' AND mc.Model = 'Dark Core RGB Pro' AND ur.User_ID = 103;	mouse	1
SELECT Manufacturer_Name, ROUND((Market_Share_Percent / 100.0) * (Profit_Usd / Employees), 4) AS efficiency_index FROM manufacturers ORDER BY efficiency_index DESC;	mouse	2
SELECT * FROM sensor_data WHERE Max_Dpi > 15000 AND Polling_Rate_Hz < 1000;	mouse	3
SELECT (7680 * 4320 * 10 * 6 * 31536000 * 10) / 1e30 AS Data_Volume_BB;	mouse	4
SELECT v.Vehicle_Id, v.Model, ROUND(dr.Distance_Km / dr.Energy_Consumed_Kwh, 2) AS energy_efficiency, dr.Average_Speed_Kmh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Average_Speed_Kmh > 60 GROUP BY v.Vehicle_Id HAVING energy_efficiency < 4 ORDER BY energy_efficiency ASC;	new_energy_vehicles	1
SELECT cs.Station_Name, ROUND(SUM(cr.Cost_Usd) / MAX(JULIANDAY(MAX(cr.End_Time)) - JULIANDAY(MIN(cr.Start_Time)) + 1, 1), 2) AS daily_revenue, cs.Number_Of_Chargers FROM charging_stations cs JOIN charging_records cr ON cs.Station_Id = cr.Station_Id GROUP BY cs.Station_Id HAVING daily_revenue > 500 AND cs.Number_Of_Chargers > 5 ORDER BY daily_revenue DESC LIMIT 3;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Model, (SELECT MAX(cr.End_Time) FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id) AS last_charge_date, (SELECT cr.Charging_Type FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id ORDER BY cr.End_Time DESC LIMIT 1) AS last_charge_type FROM vehicles v WHERE v.Battery_Capacity_Kwh > 100 AND EXISTS (SELECT 1 FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id AND cr.Energy_Consumed_Kwh < 20);	new_energy_vehicles	3
WITH RECURSIVE charging_sim AS (SELECT 10.0 AS soc, CAST(0.0 AS REAL) AS elapsed_time, 1 AS phase UNION ALL SELECT CASE phase WHEN 1 THEN MIN(soc + 5.0, 50.0) ELSE MIN(soc + 0.5, 80.0) END, elapsed_time + (100 * CASE phase WHEN 1 THEN 5.0 ELSE 0.5 END) / MAX(600 - 0.2 * POWER((-60 + 273), 3), 1), CASE WHEN soc >= 50.0 THEN 2 ELSE phase END FROM charging_sim WHERE soc < 80.0) SELECT MAX(elapsed_time) AS total_hours, FLOOR(MAX(elapsed_time)) || ' hours ' || ROUND((MAX(elapsed_time) % 1) * 60) || ' minutes' AS formatted_time FROM charging_sim;	new_energy_vehicles	4
SELECT cs.Station_Name, cr.Charging_Type, ROUND(AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time)) / 3600)) * 100, 2) AS efficiency_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, cr.Charging_Type HAVING efficiency_rate < 85 AND charge_count > 10 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
SELECT v.Manufacturer, ROUND(SUM(dr.Distance_Km) * 1.0 / COUNT(DISTINCT date(dr.Start_Time)), 2) AS daily_avg_km, COUNT(DISTINCT v.Vehicle_Id) AS vehicle_count FROM vehicles v JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id GROUP BY v.Manufacturer HAVING daily_avg_km > 150 AND vehicle_count >= 3 ORDER BY daily_avg_km DESC;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Model, MAX(cr.End_Time) AS last_charge_date, v.Battery_Health FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE cr.Temperature_Celsius > 30 AND cr.Charging_Type = 'Ultra-Fast' AND v.Battery_Health < 90 GROUP BY v.Vehicle_Id;	new_energy_vehicles	3
WITH RECURSIVE polar_charging AS (SELECT 0 AS soc, CAST(0.0 AS REAL) AS elapsed_time, 120 * 0.2 * 0.6 AS actual_power, 0.2 * 5 * POWER(-50 + 50, 2) AS heat_loss UNION ALL SELECT soc + 5, elapsed_time + (100 * 5) / MAX(actual_power - (heat_loss / 1000), 1), actual_power, 0.2 * 5 * POWER((-50 + (soc/100.0)*130) + 50, 2) FROM polar_charging WHERE soc < 100) SELECT MAX(elapsed_time) AS total_hours, FLOOR(MAX(elapsed_time)) || ' hours ' || ROUND((MAX(elapsed_time) - FLOOR(MAX(elapsed_time))) * 60) || ' minutes' AS formatted_time FROM polar_charging;	new_energy_vehicles	4
WITH normal_efficiency AS (     SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS normal_eff      FROM driving_records dr      WHERE dr.Weather_Conditions IN ('Sunny', 'Cloudy')      GROUP BY dr.Vehicle_Id ),  extreme_efficiency AS (     SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS extreme_eff      FROM driving_records dr      WHERE dr.Weather_Conditions IN ('Snow', 'Heatwave')      GROUP BY dr.Vehicle_Id )  SELECT v.Model, ROUND(((ne.normal_eff - ee.extreme_eff) * 100.0 / ne.normal_eff), 2) AS efficiency_decay_rate  FROM vehicles v  JOIN normal_efficiency ne ON v.Vehicle_Id = ne.Vehicle_Id  JOIN extreme_efficiency ee ON v.Vehicle_Id = ee.Vehicle_Id  WHERE ((ne.normal_eff - ee.extreme_eff) * 100.0 / ne.normal_eff) > 15  ORDER BY efficiency_decay_rate DESC;	new_energy_vehicles	1
WITH weekly_utilization AS (   SELECT      cs.Station_Id,      CAST(strftime('%W', cr.Start_Time) AS INTEGER) AS week_num,      SUM((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 86400) / (cs.Number_Of_Chargers * CASE WHEN cs.Is_24_Hours = 1 THEN 604800 ELSE (julianday(cs.Opening_Hours) - julianday('00:00:00')) * 86400 * 7 END) AS utilization_rate    FROM charging_stations cs    JOIN charging_records cr ON cs.Station_Id = cr.Station_Id    GROUP BY cs.Station_Id, week_num ),  consecutive_weeks AS (   SELECT      Station_Id,      week_num,      utilization_rate,      LAG(utilization_rate) OVER (PARTITION BY Station_Id ORDER BY week_num) AS prev_week_rate    FROM weekly_utilization )  SELECT DISTINCT cs.Station_Name  FROM consecutive_weeks cw  JOIN charging_stations cs ON cw.Station_Id = cs.Station_Id  WHERE cw.utilization_rate > 0.8 AND cw.prev_week_rate > 0.8;	new_energy_vehicles	2
SELECT dr.Record_Id, 'Starting elevation change:' || dr.Elevation_Gain_M || 'm; Ending elevation change:' || dr.Elevation_Loss_M || 'm' AS elevation_change, dr.Weather_Conditions, v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100 AS theoretical_energy, dr.Energy_Consumed_Kwh AS actual_energy FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE (dr.Elevation_Gain_M + dr.Elevation_Loss_M) > 500 AND dr.Energy_Consumed_Kwh > 1.2 * (v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100);	new_energy_vehicles	3
WITH RECURSIVE poisson_cdf AS (     SELECT 0 AS k, EXP(-5) * POWER(5, 0) / 1 AS prob, EXP(-5) * POWER(5, 0) / 1 AS cdf      UNION ALL      SELECT k + 1, EXP(-5) * POWER(5, k + 1) / (k + 1), cdf + EXP(-5) * POWER(5, k + 1) / (k + 1)      FROM poisson_cdf      WHERE k < 7 ) SELECT ROUND(1 - MAX(cdf), 3) AS probability_at_least_8_hours  FROM poisson_cdf;	new_energy_vehicles	4
SELECT dr.Record_Id, v.Model, ROUND(v.Weight_Kg * 9.8 * dr.Elevation_Loss_M, 2) AS theoretical_energy, ROUND(dr.Energy_Consumed_Kwh * 0.9 * 3600000, 2) AS recovered_energy, ROUND((dr.Energy_Consumed_Kwh * 0.9 * 3600000) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS efficiency_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Elevation_Loss_M > 200 AND (dr.Energy_Consumed_Kwh * 0.9 * 3600000) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 50 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
WITH RECURSIVE hourly_usage AS (     SELECT cs.Station_Id,             CAST(strftime('%H', cr.Start_Time) AS INTEGER) AS hour_slot,             CAST(COUNT(*) AS REAL) / cs.Number_Of_Chargers AS utilization_rate,             date(cr.Start_Time) AS date      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cs.Station_Id, date, hour_slot      HAVING utilization_rate > 0.9 ),  peak_groups AS (     SELECT *,             hour_slot - ROW_NUMBER() OVER (PARTITION BY Station_Id, date ORDER BY hour_slot) AS grp      FROM hourly_usage )  SELECT cs.Station_Name,         MIN(date) AS start_date,         MAX(date) AS end_date  FROM peak_groups pg  JOIN charging_stations cs ON pg.Station_Id = cs.Station_Id  GROUP BY pg.Station_Id, pg.grp  HAVING COUNT(*) >= 3 AND MAX(hour_slot) - MIN(hour_slot) < 5;	new_energy_vehicles	2
WITH health_change AS (     SELECT          cr.Vehicle_Id,          cr.End_Time,          v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY cr.Vehicle_Id ORDER BY cr.End_Time) AS health_drop      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE cr.Temperature_Celsius < 5 AND cr.Charging_Type = 'Ultra-Fast' )  SELECT      v.Model,      cs.Operator,      hc.health_drop,      cr.End_Time AS charge_time  FROM health_change hc  JOIN charging_records cr ON hc.Vehicle_Id = cr.Vehicle_Id AND hc.End_Time = cr.End_Time  JOIN vehicles v ON hc.Vehicle_Id = v.Vehicle_Id  JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id  WHERE hc.health_drop > 2;	new_energy_vehicles	3
SELECT 0.95 * 5.67e-8 * 3 * (POWER(60+273, 4) - POWER(3, 4)) / 0.9 AS max_power_kw;	new_energy_vehicles	4
SELECT cr.Record_Id, v.Model, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Charging_Type IN ('Fast', 'Ultra-Fast') AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0 < 90.0 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
WITH hourly_peak AS (     SELECT cs.Station_Id,             DATE(cr.Start_Time) AS date,             CAST(strftime('%H', cr.Start_Time) AS INTEGER) AS hour_slot,             COUNT(*) * 1.0 / cs.Number_Of_Chargers AS utilization_rate      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cs.Station_Id, date, hour_slot      HAVING utilization_rate > 0.95 ),  peak_dates AS (     SELECT date,             COUNT(DISTINCT Station_Id) AS peak_station_count      FROM hourly_peak      GROUP BY date      HAVING COUNT(DISTINCT Station_Id) >= 3 )  SELECT date, peak_station_count  FROM peak_dates  ORDER BY date DESC;	new_energy_vehicles	2
SELECT cs.Operator, cs.Location, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast' AND ((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100) < 85;	new_energy_vehicles	3
WITH RECURSIVE monte_carlo AS (     SELECT 1 AS iter,             ROUND(70.0 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1.0 + (RANDOM() - 0.5) * 1.0)), 2) AS charge_time      UNION ALL      SELECT iter + 1,             ROUND(70.0 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1.0 + (RANDOM() - 0.5) * 1.0)), 2)      FROM monte_carlo      WHERE iter < 1000 )  SELECT COUNT(*) * 100.0 / 1000 AS probability_over_1_5t  FROM monte_carlo  WHERE charge_time > 1.5 * (70.0 / (SELECT AVG(Charging_Speed_Kw) FROM charging_stations));	new_energy_vehicles	4
SELECT dr.Record_Id, v.Model, ROUND((dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS recovery_rate  FROM driving_records dr  JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id  WHERE dr.Elevation_Loss_M > 300 AND (dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 45  ORDER BY recovery_rate ASC;	new_energy_vehicles	1
WITH daily_charge AS (     SELECT          cr.Vehicle_Id,          DATE(cr.Start_Time) AS charge_date,          SUM(cr.Energy_Consumed_Kwh) AS daily_energy,          MAX(cs.Station_Id) AS last_station_id      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cr.Vehicle_Id, charge_date ),  growth_trend AS (     SELECT          Vehicle_Id,          charge_date,          daily_energy,          last_station_id,          LAG(daily_energy, 2) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n,          LAG(daily_energy, 1) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n_plus_1,          daily_energy AS day_n_plus_2      FROM daily_charge ),  valid_growth AS (     SELECT          Vehicle_Id,          MAX(last_station_id) AS last_station_id,          (MAX(day_n_plus_2) - MIN(day_n)) / 2.0 AS slope      FROM growth_trend      WHERE day_n < day_n_plus_1 AND day_n_plus_1 < day_n_plus_2      GROUP BY Vehicle_Id )  SELECT      v.Model,      cs.Location AS last_location,      vg.slope  FROM valid_growth vg  JOIN vehicles v ON vg.Vehicle_Id = v.Vehicle_Id  JOIN charging_stations cs ON vg.last_station_id = cs.Station_Id;	new_energy_vehicles	2
SELECT cs.Station_Name, cs.Opening_Hours, cs.Is_Covered, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 AND cr.Charging_Type = 'Ultra-Fast' AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) / cr.Energy_Consumed_Kwh * 100.0 < 80;	new_energy_vehicles	3
SELECT ROUND((0.85 * 5.67e-8 * 2.5 * (POWER(283, 4) - POWER(35, 4))) / 0.9, 2) AS max_power_kw;	new_energy_vehicles	4
SELECT cs.Station_Name, ROUND((1 - AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * (julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24))) * 100, 2) AS loss_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 GROUP BY cs.Station_Id HAVING loss_rate > 20 AND charge_count > 5 ORDER BY loss_rate DESC;	new_energy_vehicles	1
WITH weekday_charging AS (     SELECT          v.Model,         SUM(cr.Energy_Consumed_Kwh) AS weekday_energy     FROM charging_records cr     JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id     WHERE strftime('%w', cr.Start_Time) NOT IN ('0', '6')     GROUP BY v.Model ), weekend_charging AS (     SELECT          v.Model,         SUM(cr.Energy_Consumed_Kwh) AS weekend_energy     FROM charging_records cr     JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id     WHERE strftime('%w', cr.Start_Time) IN ('0', '6')     GROUP BY v.Model ) SELECT      wd.Model,     wd.weekday_energy,     we.weekend_energy,     ROUND(we.weekend_energy / wd.weekday_energy, 2) AS ratio FROM weekday_charging wd JOIN weekend_charging we ON wd.Model = we.Model WHERE we.weekend_energy / wd.weekday_energy > 1.3;	new_energy_vehicles	2
WITH high_altitude_stations AS (     SELECT cs.Station_Id, cs.Operator, cs.Is_Covered      FROM charging_stations cs      WHERE EXISTS (         SELECT 1          FROM (             SELECT MakePoint(0, 0) AS Location, 2500 AS Altitude              UNION ALL              SELECT MakePoint(1, 1) AS Location, 1500 AS Altitude         ) AS ad          WHERE Distance(cs.Location, ad.Location) < 1000          AND ad.Altitude > 2000          AND Y(cs.Location) BETWEEN -90 AND 90          AND X(cs.Location) BETWEEN -180 AND 180     ) ),  low_efficiency_records AS (     SELECT cr.Station_Id,             ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100 / cr.Energy_Consumed_Kwh * 100), 2) AS efficiency_rate      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 75 )  SELECT has.Operator, has.Is_Covered, COUNT(*) AS record_count  FROM high_altitude_stations has  JOIN low_efficiency_records ler ON has.Station_Id = ler.Station_Id  GROUP BY has.Operator, has.Is_Covered;	new_energy_vehicles	3
SELECT ROUND(0.2 * 3 * POW(50 - 4, 1.5), 2) AS max_power_kw;	new_energy_vehicles	4
WITH health_change AS (     SELECT          dr.Vehicle_Id,          dr.End_Time,          v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY dr.Vehicle_Id ORDER BY dr.End_Time) AS health_drop      FROM driving_records dr      JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id ) SELECT      dr.Record_Id,      v.Model,      ROUND(dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600.0), 2) AS energy_density,      hc.health_drop  FROM driving_records dr  JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id  JOIN health_change hc ON dr.Vehicle_Id = hc.Vehicle_Id AND dr.End_Time = hc.End_Time  WHERE v.Acceleration_0_To_100_Sec < 2  AND dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600.0) > 500  AND hc.health_drop > 5;	new_energy_vehicles	1
WITH abnormal_charge AS (     SELECT          cr.Vehicle_Id,          date(cr.Start_Time) AS charge_date,          cr.Energy_Consumed_Kwh      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE cr.Energy_Consumed_Kwh > 3 * v.Battery_Capacity_Kwh ),  no_driving_records AS (     SELECT          ac.Vehicle_Id,          ac.charge_date      FROM abnormal_charge ac      LEFT JOIN driving_records dr ON ac.Vehicle_Id = dr.Vehicle_Id          AND date(dr.Start_Time) = ac.charge_date      WHERE dr.Record_Id IS NULL )  SELECT Vehicle_Id, charge_date  FROM no_driving_records;	new_energy_vehicles	2
SELECT v.Manufacturer, cs.Is_Covered, COUNT(*) AS record_count FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE dr.Weather_Conditions = 'Blizzard' AND v.Is_Autonomous = 1 AND dr.Average_Speed_Kmh > 100 GROUP BY v.Manufacturer, cs.Is_Covered;	new_energy_vehicles	3
SELECT v.Model, v.Charging_Time_Hours / 707.0 AS subjective_time_hours, v.Charging_Time_Hours AS earth_time_hours FROM vehicles v WHERE v.Model = 'Model S';	new_energy_vehicles	4
SELECT ROUND((v.Battery_Capacity_Kwh * (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) * (1 - 0.05)) / NULLIF(c.Energy_Consumed_Kwh, 0) * 100, 2) AS Charging_Efficiency FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Record_Id = 1 AND v.Model = 'Model S' AND c.Final_Battery_Percentage IS NOT NULL AND c.Initial_Battery_Percentage IS NOT NULL AND c.Energy_Consumed_Kwh IS NOT NULL;	new_energy_vehicles	1
WITH StationStats AS (   SELECT      Cost_Per_Kwh,      Charging_Speed_Kw,     (Cost_Per_Kwh - (SELECT AVG(Cost_Per_Kwh) FROM charging_stations)) *      (Charging_Speed_Kw - (SELECT AVG(Charging_Speed_Kw) FROM charging_stations)) AS Covariance,     POWER(Cost_Per_Kwh - (SELECT AVG(Cost_Per_Kwh) FROM charging_stations), 2) AS VarX,     POWER(Charging_Speed_Kw - (SELECT AVG(Charging_Speed_Kw) FROM charging_stations), 2) AS VarY   FROM charging_stations ) SELECT ROUND(SUM(Covariance) / (SQRT(SUM(VarX)) * SQRT(SUM(VarY))), 4) AS Pearson_Correlation FROM StationStats ORDER BY ABS(Pearson_Correlation) DESC;	new_energy_vehicles	2
SELECT Station_Id, ROUND(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 8, 2) AS Daily_Revenue FROM charging_stations WHERE Cost_Per_Kwh > 0.25 AND Charging_Speed_Kw < 100;	new_energy_vehicles	3
SELECT Station_Id, ROUND(Charging_Speed_Kw * 6 * 0.2 * 0.9, 2) AS Max_Charging_Capacity FROM charging_stations;	new_energy_vehicles	4
SELECT ROUND(d.Distance_Km / (d.Energy_Consumed_Kwh + (d.Elevation_Gain_M / 100.0 * 0.5)), 2) AS Energy_Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 2 AND v.Model = 'ET7';	new_energy_vehicles	1
WITH Efficiency AS (     SELECT          Operator,          SUM(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 24) / SUM(Number_Of_Chargers) AS Operational_Efficiency,          AVG(Charging_Speed_Kw) AS Avg_Charging_Speed      FROM          charging_stations      GROUP BY          Operator ) SELECT      Operator,      (SELECT STDEV(Operational_Efficiency) FROM Efficiency) AS Std_Efficiency,      Operational_Efficiency,      POWER(Operational_Efficiency, 2) AS Efficiency_Squared,      Avg_Charging_Speed,      POWER(Avg_Charging_Speed, 2) AS Speed_Squared  FROM      Efficiency  ORDER BY      Operator;	new_energy_vehicles	2
SELECT c.Record_Id, ROUND(c.Energy_Consumed_Kwh * c.Temperature_Celsius / 100.0, 2) AS Risk_Factor FROM charging_records c JOIN charging_stations s ON c.Station_Id = s.Station_Id WHERE s.Is_24_Hours = 0 AND s.Is_Covered = 0 AND c.Weather_Conditions = 'Rainy' AND c.Energy_Consumed_Kwh > 50;	new_energy_vehicles	3
SELECT Station_Id, ROUND(1000 * Number_Of_Chargers * 0.8 / 0.9, 2) AS Grid_Impact FROM charging_stations;	new_energy_vehicles	4
SELECT ROUND( ( (0.5 * v.Weight_Kg * POWER((d.Distance_Km / ((strftime('%s', d.End_Time) - strftime('%s', d.Start_Time)) / 3600.0) / 3.6, 2)) + (v.Weight_Kg * 9.8 * d.Elevation_Gain_M / 1000) ) / (d.Energy_Consumed_Kwh * 3600000) * 100, 2 ) AS Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 3 AND v.Manufacturer = 'BYD' AND v.Model = 'Han EV';	new_energy_vehicles	1
WITH ranked_data AS (     SELECT Operator, Number_Of_Chargers, Charging_Speed_Kw,         RANK() OVER (PARTITION BY Operator ORDER BY Number_Of_Chargers) AS rank_chargers,         RANK() OVER (PARTITION BY Operator ORDER BY Charging_Speed_Kw) AS rank_speed     FROM charging_stations     WHERE Number_Of_Chargers IS NOT NULL AND Charging_Speed_Kw IS NOT NULL ), diff_data AS (     SELECT Operator, (rank_chargers - rank_speed) * (rank_chargers - rank_speed) AS d_squared     FROM ranked_data ), correlation_data AS (     SELECT Operator, 1.0 - (6.0 * SUM(d_squared)) / (COUNT(*) * (COUNT(*) * COUNT(*) - 1)) AS spearman_correlation     FROM diff_data     GROUP BY Operator ) SELECT Operator, spearman_correlation FROM correlation_data ORDER BY ABS(spearman_correlation) DESC;	new_energy_vehicles	2
SELECT c.Record_Id, ROUND( ((c.Final_Battery_Percentage - c.Initial_Battery_Percentage) / 100.0 * v.Battery_Capacity_Kwh * c.Temperature_Celsius) / v.Battery_Capacity_Kwh, 2 ) AS Risk_Index FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Charging_Type = 'Fast' AND c.Temperature_Celsius > 40 AND (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) > 80;	new_energy_vehicles	3
SELECT v.Vehicle_Id, ROUND( (v.Range_Km + (1000.0*0.95*1.0)/(d.Energy_Consumed_Kwh/d.Distance_Km)) / v.Range_Km, 2 ) AS Range_Boost FROM vehicles v JOIN driving_records d ON v.Vehicle_Id = d.Vehicle_Id WHERE d.Record_Id = 3;	new_energy_vehicles	4
SELECT cr.Vehicle_Id, ROUND(cr.Energy_Consumed_Kwh / ((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24), 2) AS P_avg_kW, ROUND((cr.Energy_Consumed_Kwh * 3600000) / (POWER(400,2) * ((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 86400) * 0.05*(25/cr.Temperature_Celsius)/3600), 4) AS Efficiency_Rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE v.Manufacturer = 'Tesla' AND cr.Charging_Type = 'Fast';	new_energy_vehicles	1
WITH CostBenefit AS (     SELECT          v.Manufacturer,          v.Model,          SUM(dr.Distance_Km * v.Range_Km) / SUM(cr.Energy_Consumed_Kwh * cr.Cost_Usd) AS Benefit_Ratio      FROM driving_records dr      JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE dr.Weather_Conditions = 'Sunny'      GROUP BY v.Manufacturer, v.Model )  SELECT *  FROM (     SELECT          *,          RANK() OVER (ORDER BY Benefit_Ratio DESC) AS Ranking      FROM CostBenefit )  WHERE Ranking <= 3;	new_energy_vehicles	2
SELECT cr.Record_Id, cs.Station_Name, cs.Opening_Hours, cr.Start_Time FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cs.Opening_Hours != '00:00-23:59' AND (time(cr.Start_Time) < substr(cs.Opening_Hours, 1, instr(cs.Opening_Hours, '-') - 1) OR time(cr.End_Time) > substr(cs.Opening_Hours, instr(cs.Opening_Hours, '-') + 1));	new_energy_vehicles	3
SELECT ROUND((0.5 * 50000 * POWER(29979245.8,2)) / (10000000), 2) AS Time_Seconds, ROUND((0.5 * 50000 * POWER(29979245.8,2)) / (50000 * POWER(299792458,2)), 12) AS MassEnergy_Ratio;	new_energy_vehicles	4
WITH RainyDrives AS (   SELECT      dr.Record_Id,      v.Weight_Kg,      dr.Elevation_Gain_M - dr.Elevation_Loss_M AS elevation_diff_m,      dr.Energy_Consumed_Kwh    FROM      driving_records dr      JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id    WHERE      dr.Weather_Conditions = 'Rainy' ) SELECT    Record_Id,    ROUND(      (Weight_Kg * 9.8 * elevation_diff_m / 1000) / (Energy_Consumed_Kwh * 3600000) * 100,      2    ) AS efficiency_percent  FROM    RainyDrives  WHERE    Energy_Consumed_Kwh > 0;	new_energy_vehicles	1
WITH PeakHours AS (     SELECT          cs.Operator,          cs.Number_Of_Chargers,          SUM(cr.Energy_Consumed_Kwh * cs.Cost_Per_Kwh) AS total_revenue,          SUM((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24) AS total_hours      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      WHERE cr.Charging_Type = 'Fast'          AND CAST(strftime('%H', cr.Start_Time) AS INTEGER) BETWEEN 18 AND 22      GROUP BY cs.Operator, cs.Number_Of_Chargers  )  SELECT      Operator,      ROUND(total_revenue / (Number_Of_Chargers * total_hours), 2) AS efficiency_ratio,      RANK() OVER(ORDER BY (total_revenue / (Number_Of_Chargers * total_hours)) DESC) AS efficiency_rank  FROM PeakHours;	new_energy_vehicles	2
WITH RangeAnalysis AS (     SELECT v.Vehicle_Id, v.Manufacturer, v.Model, v.Battery_Capacity_Kwh, v.Range_Km, dr.End_Battery_Percentage      FROM vehicles v      LEFT JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id      WHERE v.Range_Km < v.Battery_Capacity_Kwh * 5  ) SELECT Vehicle_Id, Manufacturer, Model, Battery_Capacity_Kwh, Range_Km, ROUND(CAST(Range_Km AS REAL) / Battery_Capacity_Kwh, 2) AS actual_range_factor, End_Battery_Percentage  FROM RangeAnalysis;	new_energy_vehicles	3
WITH PhysicsConstants AS ( SELECT 1.225 AS air_density, 2.5 AS frontal_area, 900 / 3.6 AS speed_mps ), VehicleEnergy AS ( SELECT Battery_Capacity_Kwh * 1000 AS battery_joules FROM vehicles WHERE Model = 'Model S' LIMIT 1 ), AirResistance AS ( SELECT 0.5 * air_density * frontal_area * (speed_mps * speed_mps * speed_mps) AS power_watts FROM PhysicsConstants ) SELECT power_watts, battery_joules / (power_watts * 3600) AS endurance_hours, CASE WHEN battery_joules / (power_watts * 3600) < 1 THEN 'Breakthrough' ELSE 'Safe' END AS status FROM AirResistance, VehicleEnergy;	new_energy_vehicles	4
WITH SnowDrives AS (   SELECT      dr.Record_Id,      v.Weight_Kg,      dr.Elevation_Gain_M,      dr.Average_Speed_Kmh,      0.6 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.9 AS torque_front,      0.4 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.85 AS torque_rear    FROM driving_records dr    JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id    WHERE v.Drivetrain = 'AWD' AND dr.Weather_Conditions = 'Snow' ) SELECT Record_Id, ROUND(torque_front / torque_rear, 2) AS torque_ratio  FROM SnowDrives;	new_energy_vehicles	1
WITH ServiceEfficiency AS (   SELECT      cs.Station_Id,      cs.Number_Of_Chargers,      cs.Parking_Fee_Usd,      cs.Is_Solar_Powered,      CAST(strftime('%m', cr.Start_Time) AS INTEGER) + 2 / 3 AS quarter,      SUM(cr.Energy_Consumed_Kwh * CASE WHEN cs.Is_Solar_Powered THEN 1.2 ELSE 1 END) AS adjusted_energy    FROM charging_records cr    JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id    GROUP BY cs.Station_Id, cs.Number_Of_Chargers, cs.Parking_Fee_Usd, cs.Is_Solar_Powered, quarter ) SELECT    Station_Id,    quarter,    ROUND(adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd), 2) AS efficiency_ratio,    RANK() OVER(PARTITION BY quarter ORDER BY adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd) DESC) AS efficiency_rank  FROM ServiceEfficiency;	new_energy_vehicles	2
WITH FastChargeAnalysis AS ( SELECT cr.Record_Id, cr.Temperature_Celsius, (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / ((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24) AS soc_rate FROM charging_records cr WHERE cr.Charging_Type = 'Fast' ) SELECT Record_Id, soc_rate, Temperature_Celsius, CASE WHEN soc_rate > 70 OR Temperature_Celsius > 40 THEN 'Abnormal' ELSE 'Normal' END AS health_status FROM FastChargeAnalysis;	new_energy_vehicles	3
WITH QuantumConstants AS ( SELECT 1.0545718e-34 AS h_bar, 1e-9 AS barrier_thickness, 5 * 1.6e-19 AS barrier_energy ), TunnelingProbability AS ( SELECT EXP(-2 * barrier_thickness * SQRT(2 * 9.11e-31 * barrier_energy) / h_bar) AS p_tunnel FROM QuantumConstants ), EnergyLoss AS ( SELECT cr.Record_Id, cr.Energy_Consumed_Kwh * 1000 * p_tunnel AS energy_loss_joules FROM charging_records cr, TunnelingProbability ) SELECT Record_Id, energy_loss_joules, CASE WHEN energy_loss_joules > 100 THEN 'Exceeds Quantum Limit' ELSE 'Safe' END AS quantum_status FROM EnergyLoss;	new_energy_vehicles	4
WITH ChargingPhysics AS (SELECT cr.Record_Id, cr.Energy_Consumed_Kwh, cs.Charging_Speed_Kw, cr.Temperature_Celsius, (cs.Charging_Speed_Kw * 1000 / 400) AS I, (1.68e-8 * 5) / (3.141592653589793 * POWER(0.005, 2)) AS R, (POWER(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (3.141592653589793 * POWER(0.005, 2)) * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time))) / 3.6e6 AS Q, ((POWER(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (3.141592653589793 * POWER(0.005, 2)) * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time))) / 3.6e6 * 3.6e6) / (100 * 385) AS ΔT FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Charging_Type = 'fast') SELECT Record_Id, ΔT AS Temperature_Rise, (Energy_Consumed_Kwh - Q) / Energy_Consumed_Kwh * 100 AS Efficiency_Loss_Percent FROM ChargingPhysics	new_energy_vehicles	1
WITH RangeAnalysis AS (     SELECT          dr.Vehicle_Id,          v.Manufacturer,          dr.Distance_Km / (v.Range_Km * (dr.Start_Battery_Percentage - dr.End_Battery_Percentage) / 100) AS Range_Ratio      FROM          driving_records dr      JOIN          vehicles v ON dr.Vehicle_Id = v.Vehicle_Id      WHERE          dr.Weather_Conditions IN ('Rainy','Snow') )  SELECT      Manufacturer,      (STDEV(Range_Ratio) / AVG(Range_Ratio)) AS Volatility_Rate  FROM      RangeAnalysis  GROUP BY      Manufacturer  HAVING      (STDEV(Range_Ratio) / AVG(Range_Ratio)) > 0.2;	new_energy_vehicles	2
WITH StationSessions AS (     SELECT          Station_Id,          Start_Time,          End_Time,          (julianday(Start_Time) - julianday(LAG(End_Time) OVER (PARTITION BY Station_Id ORDER BY Start_Time))) * 24 AS Rest_Hours      FROM charging_records ) SELECT      Station_Id,      SUM((julianday(End_Time) - julianday(Start_Time)) * 24) AS Total_Operating_Hours  FROM StationSessions  WHERE Rest_Hours > 24  AND Station_Id NOT IN (SELECT Station_Id FROM charging_stations WHERE Is_24_Hours = 1) GROUP BY Station_Id  HAVING SUM((julianday(End_Time) - julianday(Start_Time)) * 24) > 72;	new_energy_vehicles	3
SELECT SQRT(1.625 / 2) AS ω_min_rads, SQRT(1.625 / 2) * 60 / (2 * PI()) AS Critical_RPM, (1200 * (1.625 / 2) * POW(2, 3)) / 3 AS Material_Stress, CASE WHEN (1200 * (1.625 / 2) * POW(2, 3)) / 3 > 500e6 THEN 'Exceeds Limit' ELSE 'Safe' END AS Safety_Status;	new_energy_vehicles	4
SELECT Energy_Consumed_Kwh / (100 * (Final_Battery_Percentage - Initial_Battery_Percentage) / 100) AS efficiency FROM charging_records WHERE Vehicle_Id = 1 AND date(Start_Time) = '2023-10-01';	new_energy_vehicles	1
SELECT cs.Station_Name, SUM(cr.Energy_Consumed_Kwh) / SUM((julianday(cr.End_Time) - julianday(cr.Start_Time)) * 24) AS efficiency FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id ORDER BY efficiency DESC LIMIT 5;	new_energy_vehicles	2
SELECT cr.Vehicle_Id, cs.Station_Name FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast';	new_energy_vehicles	3
SELECT 1000 * 1000 / 400 AS current_strength;	new_energy_vehicles	4
SELECT (0.7 * (2300 * 9.81 * 30) / 3600000) AS regenerative_energy_kwh, Energy_Consumed_Kwh, CASE WHEN (0.7 * (2300 * 9.81 * 30) / 3600000) > Energy_Consumed_Kwh * 0.15 THEN 1 ELSE 0 END AS is_over_15percent FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 5 AND date(dr.Start_Time) = '2023-10-05';	new_energy_vehicles	1
SELECT Operator, (SUM(Energy_Consumed_Kwh) / MAX(Number_Of_Chargers)) * (1 + SUM(CASE WHEN CAST(strftime('%H', Start_Time) AS INTEGER) >= 20 OR CAST(strftime('%H', Start_Time) AS INTEGER) < 6 THEN Energy_Consumed_Kwh ELSE 0 END) / SUM(Energy_Consumed_Kwh)) AS efficiency_index FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY Operator ORDER BY efficiency_index DESC LIMIT 3;	new_energy_vehicles	2
SELECT v.Model, MAX(cs.Is_Covered) AS has_covered  FROM vehicles v  JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id  JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id  JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id  WHERE v.Range_Km > 500  AND v.Drivetrain = 'AWD'  AND v.Is_Autonomous = 1  AND dr.Weather_Conditions IN ('Rainy','Cloudy')  GROUP BY v.Model  HAVING AVG(dr.Average_Speed_Kmh) > 80;	new_energy_vehicles	3
SELECT (100 * 200 * 3600) / 180 - (100 * 200 * 2.1 * 50) AS required_cooling_kj;	new_energy_vehicles	4
SELECT (0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) AS regenerated_kwh, dr.Energy_Consumed_Kwh, cr.Energy_Consumed_Kwh AS charged_kwh, ((0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) / dr.Energy_Consumed_Kwh) * 100 AS contribution_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id AND DATE(cr.Start_Time) = '2023-10-02' WHERE dr.Vehicle_Id = 2 AND dr.Road_Type = 'City' AND DATE(dr.Start_Time) = '2023-10-02';	new_energy_vehicles	1
WITH peak_energy AS (     SELECT          Station_Id,          SUM(CASE WHEN CAST(strftime('%H', Start_Time) AS INTEGER) BETWEEN 7 AND 9 OR CAST(strftime('%H', Start_Time) AS INTEGER) BETWEEN 17 AND 19 THEN Energy_Consumed_Kwh ELSE 0 END) AS peak_energy,          SUM(Energy_Consumed_Kwh) AS total_energy,          SUM(Cost_Usd) AS total_revenue,          SUM((julianday(End_Time) - julianday(Start_Time)) * 24) AS total_hours      FROM charging_records      GROUP BY Station_Id )  SELECT      cs.Station_Name,      (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) AS health_index  FROM peak_energy pe  JOIN charging_stations cs ON pe.Station_Id = cs.Station_Id  WHERE (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) > 0.7;	new_energy_vehicles	2
WITH charge_cycles AS (     SELECT Vehicle_Id, SUM((Final_Battery_Percentage - Initial_Battery_Percentage) / 100.0) AS cycles      FROM charging_records      GROUP BY Vehicle_Id ),  fast_charge_stats AS (     SELECT Vehicle_Id,             CAST(COUNT(CASE WHEN Charging_Type = 'Fast' THEN 1 END) AS REAL) / COUNT(*) AS fast_ratio      FROM charging_records      GROUP BY Vehicle_Id ),  high_temp_records AS (     SELECT DISTINCT Vehicle_Id      FROM charging_records      WHERE Temperature_Celsius > 35 )  SELECT v.Vehicle_Id, v.Model  FROM vehicles v  JOIN charge_cycles cc ON v.Vehicle_Id = cc.Vehicle_Id  JOIN fast_charge_stats fcs ON v.Vehicle_Id = fcs.Vehicle_Id  JOIN high_temp_records htr ON v.Vehicle_Id = htr.Vehicle_Id  WHERE cc.cycles > 500 AND fcs.fast_ratio > 0.7;	new_energy_vehicles	3
SELECT 500000/(4*3.141592653589793*POWER(0.1,2)) AS radiation_intensity, CASE WHEN 500000/(4*3.141592653589793*POWER(0.1,2)) > 100*87 THEN 'Thermal Effects Discussion Required' ELSE 'Safe' END AS safety_status;	new_energy_vehicles	4
SELECT dr.Record_Id, 0.5 * (1.225 - 1.204) * 0.28 * 2.5 * POWER((dr.Average_Speed_Kmh / 3.6), 3) * (dr.Distance_Km / (dr.Average_Speed_Kmh / 3.6)) / 3600 AS energy_difference_kwh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE v.Model = 'Model S' AND strftime('%Y', dr.Start_Time) = '2023' AND strftime('%m', dr.Start_Time) = '10';	new_energy_vehicles	1
WITH charge_cycles AS (     SELECT          cr.Vehicle_Id,          SUM((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0) AS cycles,          AVG(v.Battery_Capacity_Kwh - (cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100.0))) AS capacity      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      WHERE (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) != 0      GROUP BY cr.Vehicle_Id )  SELECT Vehicle_Id, cycles, capacity  FROM charge_cycles  WHERE capacity > 0.05;	new_energy_vehicles	2
SELECT DISTINCT dr.Vehicle_Id FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id LEFT JOIN (     SELECT DISTINCT Vehicle_Id     FROM driving_records     WHERE Weather_Conditions LIKE '%snow%' AND Road_Type LIKE '%winter tires%' ) wt ON dr.Vehicle_Id = wt.Vehicle_Id WHERE dr.Weather_Conditions LIKE '%snow%'   AND wt.Vehicle_Id IS NULL   AND v.Drivetrain LIKE '%ABS%abnormal%';	new_energy_vehicles	3
SELECT 'Theoretical eddy current losses are zero under zero resistance, but geomagnetic field variations may cause superconductor quenching.' AS analysis_result;	new_energy_vehicles	4
SELECT dr.Energy_Consumed_Kwh, (0.6*0.4*2000*9.81*dr.Distance_Km/3600) AS theoretical_loss, (dr.Energy_Consumed_Kwh - (0.6*0.4*2000*9.81*dr.Distance_Km/3600))/dr.Energy_Consumed_Kwh*100 AS deviation_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 3 AND DATE(dr.Start_Time) = '2023-10-03' AND dr.Weather_Conditions = 'Rainy';	new_energy_vehicles	1
WITH risk_data AS (     SELECT          cs.Station_Id,          (COUNT(CASE WHEN cr.Temperature_Celsius > 25 THEN 1 END) * 1.0 / COUNT(*) * 0.4) +          (COUNT(CASE WHEN CAST(strftime('%H', cr.Start_Time) AS INTEGER) BETWEEN 18 AND 23 THEN 1 END) * 1.0 / COUNT(*) * 0.6)          AS risk_score      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      GROUP BY cs.Station_Id )  SELECT Station_Id, risk_score  FROM risk_data  WHERE risk_score > 0.4;	new_energy_vehicles	2
WITH battery_health AS (     SELECT          cr.Vehicle_Id,          (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage + 1) / 100.0))) / v.Battery_Capacity_Kwh * 100.0 AS health      FROM charging_records cr      JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id      GROUP BY cr.Vehicle_Id ) SELECT bh.Vehicle_Id  FROM battery_health bh  JOIN (     SELECT Vehicle_Id, AVG(Average_Speed_Kmh) AS avg_speed      FROM driving_records      GROUP BY Vehicle_Id      HAVING avg_speed > 80.0 ) dr ON bh.Vehicle_Id = dr.Vehicle_Id  WHERE bh.health < 80.0;	new_energy_vehicles	3
SELECT (5E-3 * POWER(5E3,2) * 10 * 3600) / NULLIF(2000E3,0) AS energy_loss_rate;	new_energy_vehicles	4
SELECT dr.Record_Id, 0.5 * 1.225 * 0.24 * 2.34 * (POWER(dr.Average_Speed_Kmh/3.6, 3) - POWER(100/3.6, 3)) * (dr.Distance_Km/(dr.Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE v.Model = 'Model S' AND dr.Road_Type = 'Highway' AND strftime('%Y', dr.Start_Time) = '2023' AND strftime('%m', dr.Start_Time) = '10';	new_energy_vehicles	1
WITH temp_effect AS (   SELECT      Vehicle_Id,      AVG(1.1 * POWER(1.05, (Temperature_Celsius - 25) / 10)) AS temp_factor    FROM charging_records    WHERE Temperature_Celsius IS NOT NULL    GROUP BY Vehicle_Id ) SELECT    v.Vehicle_Id,    (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100))) / v.Battery_Capacity_Kwh * 100 AS capacity_loss  FROM charging_records cr  JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id  JOIN temp_effect te ON v.Vehicle_Id = te.Vehicle_Id  GROUP BY v.Vehicle_Id, v.Battery_Capacity_Kwh  HAVING capacity_loss > 20;	new_energy_vehicles	2
WITH deep_charge AS (     SELECT Vehicle_Id      FROM charging_records      WHERE Final_Battery_Percentage > 90      AND Start_Time >= date('now', '-3 months')      GROUP BY Vehicle_Id      HAVING COUNT(*) > 10 )  SELECT v.Vehicle_Id  FROM vehicles v  JOIN deep_charge dc ON v.Vehicle_Id = dc.Vehicle_Id  WHERE v.Drivetrain = 'PHEV';	new_energy_vehicles	3
SELECT 1e6 * 7.8e3 / 3e8 * COS(RADIANS(45)) * SQRT((1 + 7.8e3/3e8)/(1 - 7.8e3/3e8)) AS doppler_shift;	new_energy_vehicles	4
SELECT 0.5 * (1.225*(1+0.12*1.5) - 1.225) * 0.28 * 2.5 * (Average_Speed_Kmh/3.6 * Average_Speed_Kmh/3.6 * Average_Speed_Kmh/3.6) * (Distance_Km/(Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records WHERE Vehicle_Id = 2 AND date(Start_Time) = '2023-10-02' AND Weather_Conditions LIKE '%Rain%';	new_energy_vehicles	1
WITH heat_data AS (     SELECT          Vehicle_Id,          COUNT(CASE WHEN Temperature_Celsius > 35 THEN 1 END) AS heat_count,          SUM(Elevation_Gain_M) / 1000.0 AS total_elevation      FROM          charging_records      JOIN          driving_records USING (Vehicle_Id)      GROUP BY          Vehicle_Id ) SELECT      Vehicle_Id,      heat_count / (total_elevation * 0.1 + 1) AS thermal_index  FROM      heat_data  WHERE      thermal_index < 2.5;	new_energy_vehicles	2
SELECT Vehicle_Id, (0.3*(Temperature_Celsius-25)*((julianday(End_Time) - julianday(Start_Time)) * 86400)/3600 - 2.1e-4*(Temperature_Celsius-25)*50) AS evaporation_mm  FROM charging_records  JOIN vehicles USING (Vehicle_Id)  WHERE Model = 'Model S' AND Temperature_Celsius > 35  AND julianday(End_Time) > julianday(Start_Time);	new_energy_vehicles	3
SELECT 24e-6 * 200e9 * (ABS(-180 - 100)) * SQRT(PI() * 0.01) AS crack_growth_rate;	new_energy_vehicles	4
WITH RegenerativeEnergy AS (     SELECT 80 * 0.5 * v.Weight_Kg * ((d.Average_Speed_Kmh / 3.6) * (d.Average_Speed_Kmh / 3.6)) * 0.65 / 3600 AS Regenerated_Energy_Kwh      FROM driving_records d      JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id      WHERE d.Vehicle_Id = 2 AND DATE(d.Start_Time) = '2023-10-02' ),  ChargingEnergy AS (     SELECT SUM(c.Energy_Consumed_Kwh) AS Charged_Energy_Kwh      FROM charging_records c      WHERE c.Vehicle_Id = 2 AND DATE(c.Start_Time) = '2023-10-02' )  SELECT r.Regenerated_Energy_Kwh, c.Charged_Energy_Kwh, (r.Regenerated_Energy_Kwh - c.Charged_Energy_Kwh) * 100.0 / r.Regenerated_Energy_Kwh AS Deviation_Percent  FROM RegenerativeEnergy r, ChargingEnergy c;	new_energy_vehicles	1
WITH PeakPowerUtil AS (     SELECT          cs.Station_Id,          SUM(cr.Energy_Consumed_Kwh) / (cs.Charging_Speed_Kw * 3) AS Utilization      FROM charging_records cr      JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id      WHERE strftime('%H:%M:%S', cr.Start_Time) BETWEEN '18:00:00' AND '21:00:00'      GROUP BY cs.Station_Id )  SELECT      cs.Station_Id,      (ppu.Utilization * 0.7) AS Performance_Index,      cs.Is_Solar_Powered  FROM charging_stations cs  JOIN PeakPowerUtil ppu ON cs.Station_Id = ppu.Station_Id  WHERE (ppu.Utilization * 0.7) > 0.8;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Production_Year, AVG(cr.Temperature_Celsius) AS Avg_Temp FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE (CAST(strftime('%Y', 'now') AS INTEGER) - v.Production_Year) > 3 AND cr.Charging_Type = 'Standard' GROUP BY v.Vehicle_Id, v.Production_Year HAVING AVG(cr.Temperature_Celsius) < 5;	new_energy_vehicles	3
SELECT v.Vehicle_Id, (POWER(5,2)*0.01)/(2*4*PI()*POWER(10,-7)) AS Lorentz_Force FROM vehicles v WHERE v.Weight_Kg > 0;	new_energy_vehicles	4
SELECT dr.Distance_Km, dr.Elevation_Gain_M, (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000) / 3600 AS theory_energy, dr.Energy_Consumed_Kwh AS actual_energy, (dr.Energy_Consumed_Kwh - (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000)/3600) AS deviation FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 5 AND dr.Start_Time >= '2023-10-05' AND dr.End_Time < '2023-10-06' AND dr.Road_Type = 'Rural';	new_energy_vehicles	1
WITH station_stats AS (     SELECT          v.Manufacturer,          cs.Station_Id,          AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time)) / 3600)) AS efficiency      FROM charging_records cr      JOIN vehicles v USING(Vehicle_Id)      JOIN charging_stations cs USING(Station_Id)      WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31'      GROUP BY v.Manufacturer, cs.Station_Id )  SELECT      Manufacturer,      (STDEV(efficiency) / AVG(efficiency)) AS anomaly_index  FROM station_stats  GROUP BY Manufacturer  HAVING anomaly_index > 0.15;	new_energy_vehicles	2
SELECT cr.Vehicle_Id, COUNT(CASE WHEN cr.Charging_Type = 'Fast' THEN 1 END) * 1.0 / COUNT(*) AS fast_charge_ratio, AVG(cr.Temperature_Celsius) AS avg_temp FROM charging_records cr WHERE cr.Start_Time BETWEEN '2023-07-01' AND '2023-10-31' GROUP BY cr.Vehicle_Id HAVING fast_charge_ratio > 0.5 AND avg_temp > 30;	new_energy_vehicles	3
SELECT CASE WHEN dr.Weather_Conditions = 'Snowstorm' THEN 1 ELSE 0 END AS is_snow, AVG(cr.Energy_Consumed_Kwh/(cs.Charging_Speed_Kw * (strftime('%s', cr.End_Time) - strftime('%s', cr.Start_Time))/3600)) AS efficiency FROM charging_records cr JOIN charging_stations cs USING(Station_Id) JOIN driving_records dr USING(Vehicle_Id) WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31' GROUP BY is_snow;	new_energy_vehicles	4
```sql SELECT dr.Vehicle_Id, (( (dr.End_Battery_Percentage - dr.Start_Battery_Percentage)/100.0 * v.Battery_Capacity_Kwh + dr.Energy_Consumed_Kwh ) / (v.Weight_Kg * 9.81 * (dr.Elevation_Loss_M - dr.Elevation_Gain_M))) * 100.0 AS efficiency, v.Battery_Capacity_Kwh FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE (dr.Elevation_Loss_M - dr.Elevation_Gain_M) >= 500 AND dr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31 23:59:59' ORDER BY efficiency ASC LIMIT 3; ```	new_energy_vehicles	1
WITH Stats AS (     SELECT          v.Manufacturer,          (STDEV(dr.Energy_Consumed_Kwh * 1.0 / dr.Distance_Km) / AVG(dr.Energy_Consumed_Kwh * 1.0 / dr.Distance_Km)) AS cv,          COUNT(*) AS cnt      FROM driving_records dr      JOIN vehicles v USING(Vehicle_Id)      WHERE dr.Road_Type = 'Highway' AND dr.Distance_Km > 0      GROUP BY v.Manufacturer      HAVING cv > 0.25 AND cnt >= 5 )  SELECT      s.Manufacturer,      MAX(cs.Charging_Speed_Kw) AS max_power,      AVG(cs.Charging_Speed_Kw) AS avg_power  FROM Stats s  JOIN vehicles v USING(Manufacturer)  JOIN charging_records cr USING(Vehicle_Id)  JOIN charging_stations cs USING(Station_Id)  GROUP BY s.Manufacturer;	new_energy_vehicles	2
SELECT v.Vehicle_Id,         COUNT(DISTINCT CASE WHEN cr.Charging_Type IN ('Fast','Ultra-Fast') THEN cr.Record_Id END)*1.0 / COUNT(DISTINCT cr.Record_Id) AS fast_ratio,         COUNT(DISTINCT CASE WHEN dr.Weather_Conditions = 'Rainy' THEN dr.Record_Id END) AS rainy_count  FROM vehicles v  LEFT JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id  LEFT JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id  GROUP BY v.Vehicle_Id  HAVING fast_ratio > 0.5 AND rainy_count >= 1;	new_energy_vehicles	3
SELECT cs.Station_Id, POWER(500000.0/5, 3) AS power_factor, (2 * 3.141592653589793 * SQRT(POW((1.0003-1)*100000,2) + 2*100000*6371000)) / (300000000/(SELECT MAX(Charging_Speed_Kw)*1000 FROM charging_stations)) AS phase_jitter, CASE WHEN EXISTS(SELECT 1 FROM vehicles v JOIN charging_records cr USING(Vehicle_Id) WHERE v.Motor_Power_Kw > 500 AND cr.Station_Id = cs.Station_Id ) THEN 'Quantum' ELSE 'Classic' END AS qec_type FROM charging_stations cs WHERE EXISTS(SELECT 1 FROM charging_records WHERE Station_Id = cs.Station_Id AND Weather_Conditions = 'Magnetic_Storm' AND CAST(strftime('%d', Start_Time) AS INTEGER) BETWEEN 20 AND 25 ) GROUP BY cs.Station_Id HAVING phase_jitter > 3.141592653589793/2;	new_energy_vehicles	4
WITH ScreenArea AS (   SELECT phone_id, (screen_resolution_width / pixel_density_ppi) * (screen_resolution_height / pixel_density_ppi) AS screen_area_sq_inches    FROM phones ) SELECT p.phone_id, sa.screen_area_sq_inches  FROM phones p  JOIN ScreenArea sa ON p.phone_id = sa.phone_id  ORDER BY sa.screen_area_sq_inches DESC  LIMIT 5;	phone	1
SELECT p.phone_id, p.weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7) / (p.weight_grams / 1000) AS energy_density_wh_per_kg FROM phones p ORDER BY energy_density_wh_per_kg DESC LIMIT 3;	phone	2
SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND thickness_mm < 8 ORDER BY battery_capacity_mAh DESC;	phone	3
SELECT phone_id, (battery_capacity_mAh * 3.7) / (0.5 * 1000.0) AS battery_life_hours FROM phones WHERE (battery_capacity_mAh * 3.7) / (0.5 * 1000.0) > 1000.0;	phone	4
WITH ScreenArea AS (   SELECT      phone_id,      (screen_size_inches * screen_resolution_width / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) *       screen_size_inches * screen_resolution_height / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height)) AS screen_area_sq_inches    FROM phones ) SELECT sa.phone_id, sa.screen_area_sq_inches  FROM ScreenArea sa  ORDER BY sa.screen_area_sq_inches DESC  LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;	phone	2
SELECT AVG(battery_life_hours) AS average_battery_life FROM (SELECT battery_life_hours FROM hardware_specs ORDER BY battery_life_hours DESC LIMIT 5);	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3.6) > (1000000 * 3.7 * 3.6);	phone	4
WITH ScreenDimensions AS (   SELECT      phone_id,      screen_size_inches * (screen_resolution_width / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height)) AS screen_width_inches,      screen_size_inches * (screen_resolution_height / SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height)) AS screen_height_inches    FROM phones )  SELECT p.phone_id, p.screen_size_inches, sd.screen_width_inches * sd.screen_height_inches AS screen_area_square_inches  FROM phones p  JOIN ScreenDimensions sd ON p.phone_id = sd.phone_id  ORDER BY screen_area_square_inches DESC  LIMIT 5;	phone	1
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, p.price_usd, pm.battery_life_video_playback_hours  FROM phones p  JOIN performance_metrics pm ON p.phone_id = pm.phone_id  WHERE p.battery_capacity_mAh > 4000 AND p.price_usd < 500  ORDER BY pm.battery_life_video_playback_hours DESC  LIMIT 10;	phone	3
WITH hypothetical_phone AS (   SELECT (100000 * 3.7) / (screen_size_inches * screen_resolution_width * screen_resolution_height * 0.1) AS hypothetical_battery_life    FROM phones    WHERE battery_capacity_mAh = 100000 ) SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours  FROM phones p  JOIN performance_metrics pm ON p.phone_id = pm.phone_id  CROSS JOIN hypothetical_phone hp  WHERE p.battery_capacity_mAh < 100000  AND pm.battery_life_video_playback_hours > hp.hypothetical_battery_life;	phone	4
SELECT p.phone_id AS model, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022 ORDER BY battery_energy_joules DESC LIMIT 1;	phone	1
SELECT p.phone_id, (p.price_usd / s.units_sold) * s.customer_satisfaction_score AS product_value FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 ORDER BY product_value DESC LIMIT 5;	phone	2
WITH AvgReturnRate AS (   SELECT AVG(return_rate_percentage) AS avg_return_rate    FROM sales_data    WHERE sale_year = 2020 )  SELECT p.phone_id, p.phone_id AS model, sd.return_rate_percentage, sd.sale_year  FROM phones p  JOIN sales_data sd ON p.phone_id = sd.phone_id  CROSS JOIN AvgReturnRate arr  WHERE sd.sale_year = 2020 AND sd.return_rate_percentage > arr.avg_return_rate  ORDER BY sd.return_rate_percentage DESC;	phone	3
SELECT p.phone_id, (1000000 * 3.7 * 3.6) AS battery_energy_joules, ((1000000.0 / sd.units_sold) * sd.customer_satisfaction_score) AS unit_price_satisfaction_product FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id WHERE p.battery_capacity_mAh = 1000000 AND p.price_usd = 1000000 ORDER BY battery_energy_joules DESC;	phone	4
SELECT p.phone_id, np.download_speed_mbps, np.signal_strength_dbm  FROM phones p  JOIN network_performance np ON p.phone_id = np.phone_id  WHERE np.download_speed_mbps > 2000000  ORDER BY np.download_speed_mbps DESC  LIMIT 5;	phone	1
SELECT p.phone_id, (p.battery_capacity_mAh / 1000.0 / hs.battery_life_hours) AS efficiency_ratio FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.release_year = 2022 ORDER BY efficiency_ratio DESC LIMIT 3;	phone	2
SELECT p.phone_id AS model, SUM(s.units_sold) AS total_units_sold FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 AND s.customer_satisfaction_score > 8 AND s.return_rate_percentage < 5 GROUP BY p.phone_id ORDER BY total_units_sold DESC;	phone	3
SELECT (1000000 * 1 / 8 / 1000) AS download_data_gb FROM network_performance WHERE signal_strength_dbm = -30;	phone	4
SELECT phone_id, weight_grams, battery_capacity_mAh, (battery_capacity_mAh / weight_grams) AS energy_density FROM phones ORDER BY energy_density ASC, weight_grams ASC LIMIT 1;	phone	1
SELECT phone_id, screen_size_inches, pixel_density_ppi, (PI() * POWER(screen_size_inches / 2, 2)) * pixel_density_ppi AS product FROM phones ORDER BY product DESC LIMIT 5;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.battery_capacity_mAh, (CAST(h.battery_life_hours AS REAL) / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY efficiency_ratio DESC, h.battery_life_hours DESC;	phone	3
SELECT p.phone_id, p.weight_grams * 1000 AS new_weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh / (p.weight_grams * 1000)) AS energy_density FROM phones p ORDER BY energy_density ASC, new_weight_grams ASC LIMIT 1;	phone	4
WITH ScreenArea AS (     SELECT          phone_id,          screen_size_inches,          (screen_size_inches * COS(ATAN(9.0/16.0))) * (screen_size_inches * SIN(ATAN(9.0/16.0))) AS screen_area_sq_inches      FROM phones      WHERE screen_size_inches > 6 )  SELECT phone_id, screen_size_inches, screen_area_sq_inches  FROM ScreenArea  ORDER BY screen_area_sq_inches ASC  LIMIT 5;	phone	1
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 10;	phone	2
SELECT phone_id FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh ASC LIMIT 3;	phone	3
WITH HypotheticalScreen AS (SELECT 100 * COS(ATAN(9.0/16.0)) AS screen_width, 100 * SIN(ATAN(9.0/16.0)) AS screen_height), HypotheticalArea AS (SELECT screen_width * screen_height AS screen_area FROM HypotheticalScreen), PhoneScreenAreas AS (SELECT p.phone_id, p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_width, p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_height, (p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) * (p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) AS screen_area FROM phones p) SELECT p.phone_id, p.screen_area FROM PhoneScreenAreas p, HypotheticalArea h WHERE p.screen_area < h.screen_area ORDER BY p.screen_area DESC LIMIT 5;	phone	4
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones WHERE screen_resolution_width > 1080 ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, h.battery_life_hours, (CAST(h.battery_life_hours AS REAL) / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh > 4000 ORDER BY efficiency_ratio ASC LIMIT 10;	phone	2
SELECT p.phone_id, p.screen_size_inches, p.price_usd, p.pixel_density_ppi FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500 ORDER BY p.screen_size_inches ASC;  SELECT AVG(p.pixel_density_ppi) AS average_pixel_density FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500;	phone	3
SELECT phone_id, screen_resolution_width, screen_resolution_height, screen_size_inches, pixel_density_ppi FROM phones WHERE pixel_density_ppi > 10000 ORDER BY pixel_density_ppi DESC;	phone	4
SELECT (battery_capacity_mAh * 3.7) / (5 * 1000) AS discharge_time_hours FROM phones WHERE battery_capacity_mAh = 5000;	phone	1
SELECT AVG(hs.battery_life_hours) AS average_battery_life_hours FROM (SELECT p.phone_id, p.battery_capacity_mAh FROM phones p WHERE p.release_year = 2022 ORDER BY p.battery_capacity_mAh DESC LIMIT 5) AS top_phones JOIN hardware_specs hs ON top_phones.phone_id = hs.phone_id ORDER BY average_battery_life_hours DESC;	phone	2
SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh DESC;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh < 10000 AND hs.charging_speed_watts > 50;	phone	4
SELECT phone_id, (battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones ORDER BY battery_energy_joules DESC LIMIT 5;	phone	1
SELECT phone_id, (screen_resolution_width * screen_resolution_height) AS pixel_count FROM phones ORDER BY pixel_count DESC LIMIT 10;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3600) / 1000 > (1000000 * 3.7 * 3600) / 1000;	phone	4
WITH PixelDensity AS (     SELECT          phone_id,          screen_resolution_width,          screen_resolution_height,          screen_size_inches,          SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS PPI      FROM phones ) SELECT      p.phone_id,      p.screen_resolution_width,      p.screen_resolution_height,      p.screen_size_inches,      pd.PPI,      (25.4 / pd.PPI) * 1000 AS pixel_size_micrometers  FROM phones p  JOIN PixelDensity pd ON p.phone_id = pd.phone_id  ORDER BY pd.PPI DESC  LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, (p.battery_capacity_mAh / hs.battery_life_hours) AS hourly_consumption_mAh_per_hour FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY (p.battery_capacity_mAh / hs.battery_life_hours) DESC LIMIT 10;	phone	2
SELECT * FROM phones WHERE screen_size_inches > 6 AND weight_grams < 150 ORDER BY screen_size_inches ASC;	phone	3
SELECT (25.4 / pixel_density_ppi) * 1000000 AS pixel_size_nm FROM phones WHERE pixel_density_ppi = 10000 AND screen_size_inches = 10;	phone	4
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY hs.battery_life_hours DESC;	phone	3
WITH AdjustedScores AS (   SELECT p.phone_id,           (100 / hs.cpu_clock_speed_ghz) * pm.geekbench_multi_core_score AS adjusted_geekbench_multi_core_score    FROM phones p    JOIN hardware_specs hs ON p.phone_id = hs.phone_id    JOIN performance_metrics pm ON p.phone_id = pm.phone_id ) SELECT phone_id, adjusted_geekbench_multi_core_score  FROM AdjustedScores  ORDER BY adjusted_geekbench_multi_core_score DESC  LIMIT 5;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh, h.cpu_clock_speed_ghz, h.ram_gb, (h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) AS total_power_watts, (p.battery_capacity_mAh / ((h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) * 1000 / 3.7)) AS battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.cpu_clock_speed_ghz = 2.5 AND h.ram_gb = 8 AND p.battery_capacity_mAh = 4000;	phone	1
SELECT ((storage_read_speed_mbps + storage_write_speed_mbps) * 3600 / 1024) AS max_data_volume_gb FROM hardware_specs WHERE ram_gb = 12 AND storage_read_speed_mbps = 500 AND storage_write_speed_mbps = 300;	phone	2
SELECT (5000 / ((6.5 * 1080 * 2340 * 0.000001) * 1000 / 3.7)) AS battery_life_hours FROM phones WHERE screen_size_inches = 6.5 AND screen_resolution_width = 1080 AND screen_resolution_height = 2340 AND battery_capacity_mAh = 5000;	phone	3
WITH max_data AS (SELECT (storage_read_speed_mbps / 1000.0 + storage_write_speed_mbps / 1000.0) AS max_data_processed_tb FROM hardware_specs WHERE ram_gb = 1024) SELECT max_data_processed_tb, (battery_capacity_mAh / (cpu_clock_speed_ghz * 10.0 + ram_gb * 0.1 + storage_gb * 0.05) * 1000.0 / 3.7) AS battery_life_hours FROM max_data, hardware_specs JOIN phones ON hardware_specs.phone_id = phones.phone_id WHERE hardware_specs.ram_gb = 1024;	phone	4
SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY charging_time_hours ASC LIMIT 5;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;	phone	2
SELECT phone_id, battery_capacity_mAh, price_usd FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh DESC LIMIT 10;	phone	3
SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000.0) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh = 100000 AND hs.charging_speed_watts = 1000;	phone	4
SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_WhL FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches > 6 ORDER BY energy_density_WhL DESC LIMIT 5;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC LIMIT 10;	phone	3
WITH phone_energy_density AS (     SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_wh_per_l      FROM phones ),  average_energy_density AS (     SELECT AVG(energy_density_wh_per_l) AS avg_energy_density      FROM phone_energy_density ) SELECT CASE      WHEN (100000 * 3.7) / (100 * 200 * 300 * 0.001) > (SELECT avg_energy_density FROM average_energy_density) * 10      THEN 'Yes'      ELSE 'No'  END AS is_10x_higher;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours, (p.battery_capacity_mAh * 3.7 * 3.6) / (pm.battery_life_video_playback_hours * 3600) AS average_power_consumption_watts FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;	phone	1
SELECT phone_id, (battery_capacity_mAh / weight_grams) AS battery_density_mAh_g FROM phones ORDER BY battery_density_mAh_g ASC LIMIT 5;	phone	2
SELECT p.phone_id, pm.battery_life_video_playback_hours, p.price_usd FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE pm.battery_life_video_playback_hours > 20 AND p.price_usd < 500 ORDER BY pm.battery_life_video_playback_hours DESC;	phone	3
SELECT (1000000 * 3.7 * 3.6) / (1000 * 3600) AS average_power_consumption_watts FROM phones WHERE battery_capacity_mAh = 1000000 AND EXISTS (SELECT 1 FROM performance_metrics WHERE performance_metrics.phone_id = phones.phone_id AND battery_life_video_playback_hours = 1000);	phone	4
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / pm.gfxbench_fps AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = '1';	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / (pm.gfxbench_fps * pm.gfxbench_fps) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = 'specific_phone_id';	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000.0 / 5.0)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
SELECT p.battery_capacity_mAh / (h.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh = 100000;	phone	4
SELECT (2 * (500 / 250)) AS max_power_consumption_watts FROM phones WHERE phone_id = '1';	phone	1
SELECT (battery_capacity_mAh * 3.7) / 1000 AS total_energy_Wh, ((battery_capacity_mAh * 3.7) / 1000) / 10 AS avg_power_consumption_W FROM phones WHERE phone_id = '1';	phone	2
SELECT phone_id, battery_capacity_mAh FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh ASC;	phone	3
SELECT pm.phone_id, (pm.thermal_throttling_percentage - 100) AS performance_loss_percentage FROM performance_metrics pm WHERE pm.thermal_throttling_percentage > 150;	phone	4
SELECT (MAX(p.battery_capacity_mAh) / 1000.0) * 3.7 * 3600 AS total_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022;	phone	1
WITH yearly_revenue AS (     SELECT p.phone_id, sd.sale_year, SUM(sd.revenue_usd) AS total_revenue      FROM phones p      JOIN sales_data sd ON p.phone_id = sd.phone_id      WHERE sd.sale_year IN (2021, 2022)      GROUP BY p.phone_id, sd.sale_year ),  max_revenue_per_year AS (     SELECT sale_year, MAX(total_revenue) AS max_revenue      FROM yearly_revenue      GROUP BY sale_year ),  top_phones AS (     SELECT yr.phone_id, yr.sale_year, yr.total_revenue      FROM yearly_revenue yr      JOIN max_revenue_per_year mrpy ON yr.sale_year = mrpy.sale_year AND yr.total_revenue = mrpy.max_revenue )  SELECT      tp2021.phone_id AS top_phone_2021,      tp2021.total_revenue AS revenue_2021,      tp2022.phone_id AS top_phone_2022,      tp2022.total_revenue AS revenue_2022,      ((tp2022.total_revenue - tp2021.total_revenue) * 1.0 / tp2021.total_revenue) * 100 AS growth_rate_percentage  FROM top_phones tp2021  JOIN top_phones tp2022  WHERE tp2021.sale_year = 2021 AND tp2022.sale_year = 2022;	phone	2
WITH top_selling_phone_2022 AS (     SELECT sd.phone_id, SUM(sd.units_sold) AS total_units_sold      FROM sales_data sd      WHERE sd.sale_year = 2022      GROUP BY sd.phone_id      ORDER BY total_units_sold DESC      LIMIT 1 )  SELECT p.phone_id, hs.battery_life_hours, AVG(sd.customer_satisfaction_score) AS avg_customer_satisfaction_score  FROM phones p  JOIN hardware_specs hs ON p.phone_id = hs.phone_id  JOIN sales_data sd ON p.phone_id = sd.phone_id  JOIN top_selling_phone_2022 tsp ON p.phone_id = tsp.phone_id  GROUP BY p.phone_id, hs.battery_life_hours;	phone	3
SELECT (battery_capacity_mAh / 1000.0) * 3.7 / 5.0 AS video_playback_hours FROM phones WHERE battery_capacity_mAh = 100000;	phone	4
SELECT (10 * 1024) / (download_speed_mbps * 8) AS download_time_seconds FROM network_performance WHERE phone_id = 2;	phone	1
SELECT n.phone_id, ((n.download_speed_mbps + n.upload_speed_mbps) * 3600 * 24 * 365 / 8 / 1024) AS total_data_gb FROM network_performance n;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, np.download_speed_mbps, (p.battery_capacity_mAh * 3.7) / (np.download_speed_mbps * 0.1) AS battery_life_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;	phone	3
SELECT (1000000 * 3600 * 24 * 365 / 8 / 1024 / 1024 / 1024) AS total_download_data_eb;	phone	4
SELECT phone_id, screen_size_inches, screen_resolution_width, screen_resolution_height, pixel_density_ppi, (screen_size_inches * screen_size_inches / (1 + (screen_resolution_height * 1.0 / screen_resolution_width) * (screen_resolution_height * 1.0 / screen_resolution_width)) * (screen_resolution_width * 1.0 / screen_resolution_height)) AS screen_area_square_inches, (25.4 / pixel_density_ppi) AS pixel_width_mm, (25.4 / pixel_density_ppi) AS pixel_height_mm FROM phones;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, hs.charging_speed_watts, (p.battery_capacity_mAh * 3.7 * 3600 / 1000) AS battery_energy_joules, ((p.battery_capacity_mAh * 3.7 * 3600 / 1000) / (hs.battery_life_hours * 3600)) AS average_power_consumption_watts, ((p.battery_capacity_mAh / (hs.charging_speed_watts * 1000 / 3.7)) * 100) AS charging_efficiency_percentage FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id;	phone	2
SELECT phone_id, weight_grams, width_mm, thickness_mm, CASE WHEN weight_grams < 200 AND width_mm < 75 AND thickness_mm < 10 THEN 'Suitable' ELSE 'Not Suitable' END AS one_handed_operation_suitability FROM phones;	phone	3
SELECT phones.phone_id, battery_capacity_mAh, charging_speed_watts, (battery_capacity_mAh * 3.7) / (charging_speed_watts * 1000) AS charge_time_hours, CASE WHEN battery_life_hours > 100 * 365 * 24 THEN 'Yes' ELSE 'No' END AS is_permanent_device FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 1000000 AND charging_speed_watts = 100;	phone	4
WITH PixelDensity AS (     SELECT phone_id,             SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS ppi      FROM phones )  SELECT phone_id, ppi  FROM PixelDensity  WHERE ppi = (SELECT MAX(ppi) FROM PixelDensity);	phone	1
SELECT p.phone_id, (h.storage_read_speed_mbps + h.storage_write_speed_mbps) AS total_storage_bandwidth_mbps FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY total_storage_bandwidth_mbps DESC LIMIT 1;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY p.battery_capacity_mAh DESC, h.charging_speed_watts DESC LIMIT 1;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts, (p.battery_capacity_mAh / hs.charging_speed_watts) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh > 100000 AND hs.charging_speed_watts > 1000;	phone	4
SELECT (p.battery_capacity_mAh * 3.7) / (4 * 1000) AS battery_life_hours FROM phones p WHERE p.phone_id = 1;	phone	1
SELECT p.phone_id, (h.cpu_clock_speed_ghz * 2.5 + h.gpu_cores * 1.2 + (p.screen_size_inches * 0.1) + 0.5) * h.battery_life_hours AS total_energy_consumption_wh FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.phone_id = 'specific_phone_id';	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000.0)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
SELECT (battery_capacity_mAh / (charging_speed_watts * 1000)) AS charging_time_hours FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 100000 AND charging_speed_watts = 1000;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh / (pm.battery_life_video_playback_hours * 1000.0) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;	phone	1
WITH MonthlySales AS (     SELECT          phone_id,          sale_year,          sale_month,          SUM(units_sold) AS total_units_sold      FROM          sales_data      WHERE          phone_id = '1'          AND sale_year = '2022'      GROUP BY          phone_id,          sale_year,          sale_month ),  GrowthRates AS (     SELECT          ms1.phone_id,          ms1.sale_year,          ms1.sale_month,          ms1.total_units_sold AS current_month_sales,          ms2.total_units_sold AS previous_month_sales,          ((ms1.total_units_sold - ms2.total_units_sold) * 100.0 / ms2.total_units_sold) AS growth_rate      FROM          MonthlySales ms1      LEFT JOIN          MonthlySales ms2      ON          ms1.phone_id = ms2.phone_id          AND ms1.sale_year = ms2.sale_year          AND ms1.sale_month = ms2.sale_month + 1 )  SELECT      sale_month,      growth_rate  FROM      GrowthRates  WHERE      growth_rate IS NOT NULL  ORDER BY      growth_rate DESC  LIMIT 1;	phone	2
SELECT phone_id, SQRT(screen_resolution_width * screen_resolution_width + screen_resolution_height * screen_resolution_height) / screen_size_inches AS pixel_density_ppi FROM phones;	phone	3
SELECT 100000 / (10000 / 1000) AS battery_life_hours;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 / 1000 AS battery_energy_Wh, np.download_speed_mbps * 0.1 AS download_power_W, (p.battery_capacity_mAh * 3.7 / 1000) / (np.download_speed_mbps * 0.1) AS discharge_time_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels, (screen_resolution_width * screen_resolution_height) / (screen_size_inches * screen_size_inches) AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC;	phone	2
SELECT p.phone_id, p.screen_size_inches, h.cpu_clock_speed_ghz, p.battery_capacity_mAh, h.battery_life_hours, (p.battery_capacity_mAh / (p.screen_size_inches * h.cpu_clock_speed_ghz * 0.1)) AS calculated_battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
WITH phone_data AS (   SELECT      p.phone_id,      p.battery_capacity_mAh,      np.download_speed_mbps,      hs.battery_life_hours,      hs.charging_speed_watts    FROM phones p    JOIN hardware_specs hs ON p.phone_id = hs.phone_id    JOIN network_performance np ON p.phone_id = np.phone_id    WHERE np.download_speed_mbps = 1000 ) SELECT    phone_id,    (download_speed_mbps * 30 * 24 * 60 * 60) / (8 * 1024 * 1024) AS total_data_tb,    (charging_speed_watts * 30 * 24) / (battery_capacity_mAh * 3.7 / 1000) * 100 AS battery_loss_percentage  FROM phone_data;	phone	4
SELECT r.researcherName, COUNT(e.experimentId) AS experimentCount FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = 'Spectrometer' GROUP BY r.researcherId ORDER BY experimentCount DESC LIMIT 5;	PhysicsLabDB	1
WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount ORDER BY equipmentCount DESC;	PhysicsLabDB	2
SELECT researcherName, joinDate FROM Researchers WHERE strftime('%Y', joinDate) = '2023' ORDER BY joinDate ASC LIMIT 10;	PhysicsLabDB	3
SELECT SUM(capacity) + (COUNT(labId) * 1000) AS new_total_capacity FROM Labs;	PhysicsLabDB	4
SELECT labName, equipmentCount, (equipmentCount * 500) AS totalPower FROM Labs WHERE equipmentCount = (SELECT MAX(equipmentCount) FROM Labs);	PhysicsLabDB	1
WITH TopMeasurements AS (     SELECT measurementValue      FROM ExperimentData      ORDER BY measurementValue DESC      LIMIT 10 )  SELECT      AVG(measurementValue) AS average_value,      AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue) AS variance_value,      SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS stddev_value  FROM TopMeasurements;	PhysicsLabDB	2
SELECT Labs.labName, Labs.location, Experiments.experimentName FROM Labs JOIN Experiments ON Labs.labId = Experiments.labId WHERE Labs.capacity > 100 AND Experiments.status = 'ongoing';	PhysicsLabDB	3
SELECT Experiments.experimentId, Experiments.experimentName, AVG(ExperimentData.measurementValue) AS averageMeasurementValue FROM Experiments JOIN ExperimentData ON Experiments.experimentId = ExperimentData.experimentId WHERE Experiments.status = 'ongoing' GROUP BY Experiments.experimentId, Experiments.experimentName ORDER BY averageMeasurementValue ASC;	PhysicsLabDB	1
SELECT result FROM Calculations WHERE experimentId IN (SELECT experimentId FROM Experiments WHERE status = 'completed') ORDER BY result DESC LIMIT 5;	PhysicsLabDB	2
SELECT labId, labName, capacity, equipmentCount, (equipmentCount * 1.0 / capacity) AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC;	PhysicsLabDB	3
WITH ExaggeratedMeasurements AS (     SELECT experimentId, AVG(measurementValue * 1000) AS exaggeratedAvg      FROM ExperimentData      GROUP BY experimentId      ORDER BY exaggeratedAvg ASC )  SELECT * FROM ExaggeratedMeasurements  WHERE exaggeratedAvg NOT IN (     SELECT exaggeratedAvg FROM ExaggeratedMeasurements );	PhysicsLabDB	4
SELECT deviceId, deviceName, calibrationDate,         julianday('now') - julianday(calibrationDate) AS calibrationIntervalDays  FROM Devices  ORDER BY calibrationIntervalDays ASC  LIMIT 5;	PhysicsLabDB	1
SELECT labId, labName, equipmentCount * 1.0 / capacity AS densityRatio FROM Labs ORDER BY densityRatio DESC LIMIT 3;	PhysicsLabDB	2
SELECT deviceType, COUNT(*) AS faultCount FROM Devices WHERE status = 'fault' GROUP BY deviceType;	PhysicsLabDB	3
SELECT deviceId, deviceName, calibrationDate, date(calibrationDate, '+100 years') AS extendedCalibrationDate FROM Devices ORDER BY extendedCalibrationDate DESC LIMIT 10;	PhysicsLabDB	4
WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') ORDER BY measurementValue DESC LIMIT 5) SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM TopMeasurements;	PhysicsLabDB	1
WITH LogTransformedData AS (SELECT LOG10(measurementValue) AS logValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'oscilloscope') AND unit = 'V') SELECT AVG(logValue) AS logAverage, SQRT(AVG(logValue * logValue) - AVG(logValue) * AVG(logValue)) AS logStandardDeviation FROM LogTransformedData;	PhysicsLabDB	2
SELECT AVG(measurementValue) AS mean, SQRT(AVG((measurementValue - (SELECT AVG(measurementValue) FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'thermometer'))) * (measurementValue - (SELECT AVG(measurementValue) FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'thermometer'))))) AS stddev FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'thermometer');	PhysicsLabDB	3
SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM ExperimentData WHERE measurementValue > 1000000 AND unit = 'lm' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer');	PhysicsLabDB	4
SELECT (3 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') AND measurementValue = 500 AND unit = 'nanometer';	PhysicsLabDB	1
WITH RECURSIVE VariableCalculation AS (     SELECT variableId, variableName, initialValue AS currentValue, unit, dataQuality      FROM Variables      WHERE experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = 'a certain experiment')     UNION ALL     SELECT v.variableId, v.variableName,             CASE                 WHEN v.variableName = 'A' THEN SQRT(vc.currentValue)                 WHEN v.variableName = 'B' THEN 2 * vc.currentValue             END AS currentValue,             v.unit, v.dataQuality      FROM Variables v      JOIN VariableCalculation vc ON v.experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = 'a certain experiment')     WHERE (v.variableName = 'A' AND vc.variableName = 'B') OR (v.variableName = 'B' AND vc.variableName = 'A') )  SELECT * FROM VariableCalculation;	PhysicsLabDB	2
SELECT deviceId, deviceName, deviceType, calibrationDate, status, labId FROM Devices WHERE calibrationDate < date('now', '-1 year') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT * FROM Calculations WHERE result > 1e300 ORDER BY result DESC;	PhysicsLabDB	4
WITH SpectralData AS (     SELECT          ed.dataId,          ed.experimentId,          ed.deviceId,          ed.timestamp,          ed.measurementValue AS lightIntensity,          ed.unit,          ed.dataQuality,          ed.environmentalConditions      FROM          ExperimentData ed      JOIN          Devices d ON ed.deviceId = d.deviceId      WHERE          d.deviceType = 'spectrometer'          AND ed.experimentId = 'specific experiment ID' ),  EnergyCalculations AS (     SELECT          sd.dataId,          sd.experimentId,          sd.deviceId,          sd.timestamp,          sd.lightIntensity,          sd.unit,          sd.dataQuality,          sd.environmentalConditions,          (6.62607015e-34 * 299792458 / sd.lightIntensity) AS energy      FROM          SpectralData sd )  SELECT      ec.dataId,      ec.experimentId,      ec.deviceId,      ec.timestamp,      ec.lightIntensity,      ec.energy,      ec.unit,      ec.dataQuality,      ec.environmentalConditions  FROM      EnergyCalculations ec  ORDER BY      ec.energy ASC  LIMIT 10;	PhysicsLabDB	1
SELECT e.experimentId, e.experimentName, AVG(sa.sensitivityValue) AS avgSensitivityValue FROM Experiments e JOIN SensitivityAnalysis sa ON e.experimentId = sa.experimentId WHERE sa.impact = 'High' GROUP BY e.experimentId, e.experimentName;	PhysicsLabDB	2
SELECT d.deviceType, COUNT(ed.deviceId) AS usageCount FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId JOIN Experiments e ON ed.experimentId = e.experimentId WHERE e.status = 'Completed' GROUP BY d.deviceType ORDER BY usageCount DESC;	PhysicsLabDB	3
SELECT labId, labName, (10000.0 / equipmentCount) AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS average_wavelength FROM (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') AND unit = 'nanometers' ORDER BY measurementValue DESC LIMIT 5);	PhysicsLabDB	1
SELECT * FROM Calculations WHERE result > 1000 ORDER BY result DESC LIMIT 10;	PhysicsLabDB	2
SELECT labId, labName, location, capacity, equipmentCount, status FROM Labs WHERE capacity > 50 ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 10000 ORDER BY initialValue DESC LIMIT 5;	PhysicsLabDB	4
SELECT deviceId, AVG(measurementValue) AS averageMeasurementValue FROM ExperimentData GROUP BY deviceId ORDER BY averageMeasurementValue ASC;	PhysicsLabDB	1
WITH TopMeasurements AS (     SELECT measurementValue      FROM ExperimentData      ORDER BY measurementValue DESC      LIMIT 5 )  SELECT      AVG(measurementValue) AS average_value,      SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation  FROM TopMeasurements;	PhysicsLabDB	2
SELECT deviceType, GROUP_CONCAT(deviceName, ', ') AS deviceNames, GROUP_CONCAT(calibrationDate, ', ') AS calibrationDates FROM Devices WHERE (julianday('now') - julianday(calibrationDate)) > 365 GROUP BY deviceType;	PhysicsLabDB	3
SELECT h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult  FROM Hypotheses h  JOIN ExperimentData ed ON h.experimentId = ed.experimentId  WHERE h.verificationResult = 'False'  AND ed.measurementValue > (SELECT initialValue FROM Variables WHERE experimentId = h.experimentId AND variableName = 'Normal Value') * 100  GROUP BY h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult;	PhysicsLabDB	4
SELECT e.experimentId, AVG(ed.measurementValue) AS average_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = 'spectrometer' GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	1
WITH OscilloscopeExperiments AS (     SELECT ed.experimentId, ed.measurementValue      FROM ExperimentData ed      JOIN Devices d ON ed.deviceId = d.deviceId      WHERE d.deviceType = 'oscilloscope' ),  ExperimentStats AS (     SELECT experimentId, AVG(measurementValue) AS avg_value, COUNT(measurementValue) AS count_value      FROM OscilloscopeExperiments      GROUP BY experimentId )  SELECT oe.experimentId, SQRT(SUM((oe.measurementValue - es.avg_value) * (oe.measurementValue - es.avg_value)) / es.count_value) AS std_deviation  FROM OscilloscopeExperiments oe  JOIN ExperimentStats es ON oe.experimentId = es.experimentId  GROUP BY oe.experimentId  ORDER BY oe.experimentId ASC;	PhysicsLabDB	2
SELECT e.experimentId, SUM(ed.measurementValue) AS total_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType NOT IN ('spectrometer', 'oscilloscope') GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	3
SELECT e.experimentId, MAX(ed.measurementValue) AS max_measurement_value FROM Experiments e JOIN Labs l ON e.labId = l.labId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE l.equipmentCount > 1000 GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	4
SELECT L.labId, L.labName, L.location, L.capacity, COUNT(R.researcherId) AS currentResearchers, (L.capacity >= COUNT(R.researcherId) * 2) AS isCapacitySufficient FROM Labs L JOIN Experiments E ON L.labId = E.labId JOIN Researchers R ON E.researcherId = R.researcherId WHERE E.status = 'in progress' GROUP BY L.labId, L.labName, L.location, L.capacity;	PhysicsLabDB	1
SELECT labId, labName, CAST(equipmentCount AS REAL) / capacity AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC LIMIT 1;	PhysicsLabDB	2
SELECT AVG(JULIANDAY('now') - JULIANDAY(e.startDate)) AS averageVerificationTime FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId WHERE h.status = 'Unverified';	PhysicsLabDB	3
SELECT labId, labName, (capacity / 0.1) AS maxResearchers FROM Labs;	PhysicsLabDB	4
SELECT SUM(POWER(equipmentCount, 2) * 10) AS total_power_consumption FROM Labs;	PhysicsLabDB	1
WITH ExperimentDurations AS (     SELECT experimentId, experimentName, (julianday(endDate) - julianday(startDate)) AS duration      FROM Experiments      WHERE status = 'Completed' )  SELECT AVG(duration) AS average_duration, MAX(duration) AS max_duration  FROM ExperimentDurations;	PhysicsLabDB	2
SELECT      (COUNT(CASE WHEN status = 'fault' THEN 1 END) * 100.0 / COUNT(*)) AS fault_percentage FROM Devices;	PhysicsLabDB	3
SELECT 10000 / 1000 AS lab_density;	PhysicsLabDB	4
SELECT e.experimentName AS experiment_name, e.startDate AS experiment_start_time, e.endDate AS experiment_end_time, AVG(ed.measurementValue) AS average_gravitational_acceleration FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = 'Measuring Gravitational Acceleration' GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	1
SELECT e.experimentName, e.startDate, e.endDate, AVG(ed1.measurementValue * 1.0 / ed2.measurementValue) AS averageResistance FROM Experiments e JOIN ExperimentData ed1 ON e.experimentId = ed1.experimentId AND ed1.unit = 'V' JOIN ExperimentData ed2 ON e.experimentId = ed2.experimentId AND ed2.unit = 'A' AND ed1.timestamp = ed2.timestamp GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	2
SELECT e.experimentName, e.startDate, e.endDate, MAX(ed.measurementValue) AS maxTemperature, MIN(ed.measurementValue) AS minTemperature FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = 'Celsius' OR ed.unit = 'Fahrenheit' GROUP BY e.experimentId;	PhysicsLabDB	3
SELECT e.experimentName, e.startDate, e.endDate, AVG(ed.measurementValue) AS averageSpeed FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = 'Measuring Speed of Light Experiment' AND ed.measurementValue > 1000000000 GROUP BY e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	4
SELECT SUM(500 * 8) AS total_energy_consumption_kWh FROM Devices WHERE deviceType = 'spectrometer';	PhysicsLabDB	1
SELECT AVG(JULIANDAY('2023-10-01') - JULIANDAY(calibrationDate)) AS average_calibration_interval FROM Devices;	PhysicsLabDB	2
SELECT deviceName, calibrationDate FROM Devices WHERE status = 'faulty';	PhysicsLabDB	3
WITH DevicePower AS (   SELECT deviceId, deviceName,           CASE             WHEN deviceType = 'oscilloscope' THEN 500             WHEN deviceType = 'spectrometer' THEN 700             ELSE 300           END AS basePower    FROM Devices    WHERE labId = (SELECT labId FROM Labs WHERE labName = 'target laboratory name') ), MaxPower AS (   SELECT deviceId, deviceName, basePower * 1000 AS maxPower    FROM DevicePower ), TotalEnergy AS (   SELECT SUM(maxPower * 24) AS totalEnergy    FROM MaxPower ) SELECT    CASE      WHEN totalEnergy > 1000 THEN 'exceeds grid capacity'      ELSE 'does not exceed grid capacity'    END AS result  FROM TotalEnergy;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS averageLightIntensity FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'spectrometer') AND unit = 'Lux';	PhysicsLabDB	1
WITH HighTempData AS (     SELECT measurementValue      FROM ExperimentData      WHERE environmentalConditions = 'high temperature' AND unit = '°C' ),  AverageValue AS (     SELECT AVG(measurementValue) AS avgValue      FROM HighTempData )  SELECT SQRT(SUM(POWER(measurementValue - avgValue, 2)) / COUNT(*)) AS standardDeviation  FROM HighTempData, AverageValue;	PhysicsLabDB	2
SELECT SUM(measurementValue) AS totalCurrent FROM ExperimentData WHERE dataQuality = 'high' AND unit = 'A';	PhysicsLabDB	3
SELECT SUM(measurementValue * 1000) * 1000 AS totalVoltage FROM ExperimentData WHERE unit = 'V';	PhysicsLabDB	4
SELECT experimentId, experimentName, (3.00 * POWER(10, 8)) / (5.00 * POWER(10, 14)) AS wavelength, 'm' AS unit FROM Experiments WHERE experimentName = 'Spectrometer Measurement Experiment';	PhysicsLabDB	1
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES ((SELECT experimentId FROM Experiments WHERE experimentName = 'Complex Circuit Experiment'), '1/Req = 1/R1 + 1/R2 + 1/R3 + 1/R4 + 1/R5', 'R1=10Ω, R2=20Ω, R3=30Ω, R4=40Ω, R5=50Ω', 1.0 / (1.0/10 + 1.0/20 + 1.0/30 + 1.0/40 + 1.0/50), 'Ω', 'High');	PhysicsLabDB	2
WITH DevicePower AS (SELECT 10 * 500 AS total_power),  DailyEnergy AS (SELECT total_power * 8 / 1000.0 AS daily_energy FROM DevicePower),  MonthlyCost AS (SELECT daily_energy * 30 * 0.5 AS monthly_cost FROM DailyEnergy)  SELECT monthly_cost FROM MonthlyCost;	PhysicsLabDB	3
WITH DevicePower AS (SELECT SUM(10000) AS total_power FROM Devices WHERE labId = (SELECT labId FROM Labs WHERE labName = 'Very Large Laboratory')), DailyEnergy AS (SELECT total_power * 24 AS daily_energy FROM DevicePower), AnnualCost AS (SELECT daily_energy * 365 * 0.1 AS annual_cost FROM DailyEnergy) SELECT annual_cost FROM AnnualCost;	PhysicsLabDB	4
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) SELECT experimentId, 'P = V * I', 'V=' || measurementValue || ', I=2', measurementValue * 2, 'Watt', 'High' FROM ExperimentData WHERE unit = 'V' AND environmentalConditions = '25°C';	PhysicsLabDB	1
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES (1, 'F = m * a', 'm=5kg, a=9.8m/s²', 49, 'N', 'High');	PhysicsLabDB	2
SELECT equipmentCount / CAST(capacity AS REAL) AS avg_equipment_per_researcher FROM Labs WHERE capacity = 50 AND equipmentCount = 100;	PhysicsLabDB	3
SELECT hypothesisId, hypothesisText, verificationResult, verificationDate, CASE WHEN DATE(verificationDate, '+10000 years') > DATE('now') THEN 'valid' ELSE 'invalid' END AS validity FROM Hypotheses WHERE verificationResult = 'true' AND verificationDate = '2023-10-01';	PhysicsLabDB	4
SELECT AVG(measurementValue) AS averageVoltage, experimentId FROM ExperimentData WHERE unit = 'V' GROUP BY experimentId HAVING MAX(measurementValue) > 10000;	PhysicsLabDB	1
SELECT SUM(initialValue) AS totalInitialValue, variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 1000;	PhysicsLabDB	2
SELECT labId, labName, equipmentCount / capacity AS equipmentPerPerson FROM Labs WHERE equipmentCount / capacity < 2;	PhysicsLabDB	3
SELECT (julianday(verificationDate) - julianday('now')) / 365.25 AS dateDifference, h.* FROM Hypotheses h WHERE h.verificationResult = 'True'   AND julianday(verificationDate) > julianday('now', '+100 years')   AND (julianday(verificationDate) - julianday('now')) / 365.25 > 100;	PhysicsLabDB	4
WITH EnvironmentalCoefficients AS (SELECT 0.01 AS temperature_coefficient, 0.005 AS humidity_coefficient), StandardConditions AS (SELECT 20 AS standard_temperature, 40 AS standard_humidity), ExperimentData AS (SELECT measurementValue, environmentalConditions FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5 AND environmentalConditions LIKE '%25°C%' AND environmentalConditions LIKE '%50%') SELECT measurementValue * ((SELECT temperature_coefficient FROM EnvironmentalCoefficients) * (25 - (SELECT standard_temperature FROM StandardConditions)) + (SELECT humidity_coefficient FROM EnvironmentalCoefficients) * (50 - (SELECT standard_humidity FROM StandardConditions))) AS error_range FROM ExperimentData;	PhysicsLabDB	1
SELECT SUM(s.sensitivityValue * v.initialValue) AS totalImpact FROM SensitivityAnalysis s JOIN Variables v ON s.variableId = v.variableId WHERE v.variableName IN ('A', 'B', 'C');	PhysicsLabDB	2
SELECT deviceId, deviceName, calibrationDate, CASE WHEN DATE(calibrationDate, '+1 year') < '2023-05-01' THEN 'Needs recalibration' ELSE 'Does not need recalibration' END AS recalibrationStatus FROM Devices WHERE calibrationDate = '2022-01-01';	PhysicsLabDB	3
SELECT 10000 / 10 AS max_equipment_capacity;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS average_voltage FROM ExperimentData WHERE environmentalConditions = 'temperature:25°C, humidity:60%' AND unit = 'V';	PhysicsLabDB	1
WITH TemperatureData AS (     SELECT measurementValue      FROM ExperimentData      WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31'      AND unit = 'Celsius' ) SELECT SQRT(AVG(POWER(measurementValue - (SELECT AVG(measurementValue) FROM TemperatureData), 2))) AS standard_deviation  FROM TemperatureData;	PhysicsLabDB	2
SELECT MAX(measurementValue) AS max_humidity FROM ExperimentData WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31' AND unit = '%';	PhysicsLabDB	3
SELECT AVG(measurementValue) AS average_pressure FROM ExperimentData WHERE environmentalConditions LIKE '%temperature=1000°C%' AND environmentalConditions LIKE '%humidity=100%' AND unit = 'Pa';	PhysicsLabDB	4
SELECT r.researcherName, e.experimentName FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = 'Volts (V)' AND e.startDate > '2022-01-01' ORDER BY r.researcherName ASC;	PhysicsLabDB	1
SELECT labId, labName, equipmentCount * 1.0 / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;	PhysicsLabDB	2
SELECT e.experimentId, e.experimentName, e.startDate, e.endDate, e.status, h.verificationResult FROM Experiments e JOIN Hypotheses h ON e.experimentId = h.experimentId WHERE e.status = 'Completed' AND h.verificationResult = 'True' AND e.endDate <= '2021-12-31' ORDER BY e.experimentName ASC;	PhysicsLabDB	3
SELECT labId, labName, CAST(equipmentCount AS REAL) / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 10;	PhysicsLabDB	4
SELECT labName, equipmentCount FROM Labs ORDER BY equipmentCount DESC LIMIT 1;	PhysicsLabDB	1
SELECT labName, AVG(equipmentCount) AS avgEquipmentCount FROM Labs GROUP BY labName HAVING AVG(equipmentCount) > (SELECT AVG(equipmentCount) FROM Labs);	PhysicsLabDB	2
SELECT labName, capacity FROM Labs WHERE status = 'open' ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT labName, capacity FROM Labs WHERE capacity > 1000 ORDER BY capacity DESC;	PhysicsLabDB	4
SELECT deviceType, deviceName, MIN(calibrationDate) AS earliestCalibrationDate FROM Devices GROUP BY deviceType;	PhysicsLabDB	1
WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount;	PhysicsLabDB	2
SELECT deviceType, COUNT(*) AS deviceCount FROM Devices WHERE status = 'normal' GROUP BY deviceType;	PhysicsLabDB	3
SELECT labName, equipmentCount FROM Labs WHERE equipmentCount > 1000 ORDER BY equipmentCount DESC;	PhysicsLabDB	4
SELECT * FROM ExperimentData WHERE measurementValue > 1000 AND dataQuality = 'High' ORDER BY measurementValue ASC LIMIT 10;	PhysicsLabDB	1
SELECT experimentId, AVG(measurementValue) AS averageValue FROM ExperimentData GROUP BY experimentId HAVING AVG(measurementValue) > 500 ORDER BY averageValue DESC;	PhysicsLabDB	2
SELECT labName, location FROM Labs WHERE capacity > 50 AND equipmentCount > 100 ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT labName, location FROM Labs WHERE capacity > 1000000 ORDER BY capacity DESC LIMIT 5;	PhysicsLabDB	4
SELECT (3.00 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM Experiments e JOIN Devices d ON e.labId = d.labId WHERE d.deviceType = 'spectrometer' AND e.status = 'in progress';	PhysicsLabDB	1
SELECT measurementValue / 10.0 AS current FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5;	PhysicsLabDB	2
SELECT deviceId, deviceName, calibrationDate, CASE WHEN date(calibrationDate, '+1 year') < '2023-01-01' THEN 'requires recalibration' ELSE 'does not require recalibration' END AS calibrationStatus FROM Devices WHERE calibrationDate = '2020-01-01';	PhysicsLabDB	3
SELECT variableId, variableName, initialValue * 100 AS maximumValue, unit FROM Variables WHERE variableId IN (SELECT variableId FROM SensitivityAnalysis WHERE sensitivityValue = 1000 AND impact = 'High') AND initialValue = 1000 AND unit = 'meters(m)';	PhysicsLabDB	4
SELECT (p.Power_Consumption * (j.Page_Count / p.Print_Speed) / 60) AS Total_Energy_Wh FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE j.Color_Usage = 'Monochrome' AND j.Page_Count = 150 AND p.Power_Consumption = 500 AND p.Print_Speed = 30;	printer	1
SELECT (Revenue * Profit_Margin / 100) - (Revenue * R&D_Spending / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND R&D_Spending = 8;	printer	2
SELECT CASE WHEN (Capacity * (Current_Level / 100.0)) >= 800 THEN 'No' ELSE 'Yes' END AS Need_Replacement FROM consumables WHERE Type = 'Toner' AND Capacity = 5000 AND Current_Level = 5;	printer	3
SELECT (Revenue * Profit_Margin / 100) - (Revenue * [R&D_Spending] / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND [R&D_Spending] = 8;	printer	4
SELECT Consumable_ID, (Capacity * 0.3 * 5) / 1000 AS Total_Weight_KG FROM consumables WHERE Type = 'Paper' ORDER BY Total_Weight_KG DESC LIMIT 5;	printer	1
SELECT Printer_ID, SUM(CASE WHEN Type IN ('Toner', 'Ink') THEN Capacity * (Current_Level / 100.0) ELSE Capacity - (Capacity * (Current_Level / 100.0)) END) AS Total_Remaining_Pages FROM consumables GROUP BY Printer_ID ORDER BY Total_Remaining_Pages DESC LIMIT 3;	printer	2
SELECT Consumable_ID, (100 - Current_Level) / (julianday(Next_Replacement_Date) - julianday('now')) AS Daily_Usage_Percent FROM consumables WHERE (julianday(Next_Replacement_Date) - julianday('now')) > 0 HAVING Daily_Usage_Percent > 1 ORDER BY Daily_Usage_Percent ASC LIMIT 10;	printer	3
SELECT Consumable_ID, Capacity * (Current_Level / 100) AS Theoretical_Pages FROM consumables WHERE Current_Level > 100 ORDER BY Theoretical_Pages DESC;	printer	4
SELECT c.Type, (c.Capacity * (c.Current_Level / 100.0) / (p.Print_Speed * 60.0)) AS "耗尽时间_小时" FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Toner' GROUP BY c.Type;	printer	1
SELECT c.Printer_ID, SUM(c.Capacity) / SUM(c.Cost) AS 'Total Cost Efficiency' FROM consumables c WHERE c.Type IN ('Ink', 'Drum') GROUP BY c.Printer_ID ORDER BY 'Total Cost Efficiency' DESC;	printer	2
SELECT c.Type, COUNT(*) AS below_20_percent_count FROM consumables c WHERE c.Current_Level < 20 GROUP BY c.Type ORDER BY below_20_percent_count DESC;	printer	3
SELECT p.Type, CASE WHEN (1000000 * 0.0001) > p.Tray_Capacity THEN 1 ELSE 0 END AS contradiction_detection FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Drum' AND c.Capacity = 1000000 AND c.Current_Level = 0.01 GROUP BY p.Type;	printer	4
SELECT c.* FROM consumables c INNER JOIN printers p ON c.Printer_ID = p.Printer_ID LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement' WHERE c.Type = 'Toner' AND c.Current_Level < 30 AND p.Power_Consumption > 1000 AND ml.Maintenance_ID IS NULL;	printer	1
SELECT      c.Consumable_ID,      c.Printer_ID,      c.Type,      c.Model,      c.Capacity,      c.Current_Level,      c.Last_Replacement_Date,      c.Next_Replacement_Date,      c.Cost,     (c.Capacity * (c.Current_Level / 100.0)) / (julianday('now') - julianday(c.Last_Replacement_Date)) AS Daily_Wear_Rate,     (c.Capacity * (c.Current_Level / 100.0)) / ((c.Capacity * (c.Current_Level / 100.0)) / (julianday('now') - julianday(c.Last_Replacement_Date))) AS Predicted_Lifespan_Days FROM      consumables c JOIN      printers p ON c.Printer_ID = p.Printer_ID WHERE      c.Type = 'Drum'      AND julianday('now') - julianday(c.Last_Replacement_Date) <= 90     AND (c.Capacity * (c.Current_Level / 100.0)) / ((c.Capacity * (c.Current_Level / 100.0)) / (julianday('now') - julianday(c.Last_Replacement_Date))) < 7     AND c.Consumable_ID NOT IN (         SELECT DISTINCT m.Consumable_ID          FROM maintenance_logs m          WHERE m.Maintenance_Type = 'Replacement'          AND m.Maintenance_Date >= date('now', '-90 days')     ) GROUP BY      c.Consumable_ID;	printer	2
SELECT c.*  FROM consumables c  INNER JOIN printers p ON c.Printer_ID = p.Printer_ID  LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement'  WHERE c.Type = 'Fuser'  AND c.Current_Level < 15  AND p.Installation_Date < date('now', '-3 years')  AND ml.Maintenance_ID IS NULL;	printer	3
SELECT c.* FROM consumables c LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID WHERE (c.Capacity > 100000000 OR c.Current_Level > 200) AND ml.Maintenance_ID IS NULL GROUP BY c.Consumable_ID HAVING COUNT(ml.Maintenance_ID) = 0;	printer	4
SELECT (1500 * 8 * 30) / 1000 AS Total_Energy_kWh, (1500 * 8 * 30) / 1000 * 0.92 AS CO2_Emissions_kg FROM printers WHERE Printer_ID = 'Specific_Printer_ID';	printer	1
WITH Theoretical AS (     SELECT (0.6 * 200.0 / 5000.0) + (0.4 * 150.0 / 10000.0) AS TheoreticalCost ), Actual AS (     SELECT (3.0 * 200.0 + 2.0 * 150.0) / (3.0 * 5000.0 + 2.0 * 10000.0) AS ActualCost ) SELECT ((ActualCost - TheoreticalCost) / TheoreticalCost) * 100.0 AS DifferenceRate FROM Theoretical, Actual;	printer	2
SELECT Printer_ID, 'Root Cause: Extended maintenance intervals have led to wear and tear of mechanical parts' AS RootCause, 'Recommendation: Immediately perform preventive maintenance, replace worn parts, and restore the recommended maintenance schedule' AS Recommendation FROM (SELECT Printer_ID, AVG(julianday(Maintenance_Date) - julianday(LAG(Maintenance_Date) OVER (PARTITION BY Printer_ID ORDER BY Maintenance_Date))) AS AvgInterval FROM maintenance_logs GROUP BY Printer_ID HAVING COUNT(*) >= 3) t WHERE AvgInterval > (SELECT recommended_cycle FROM printers WHERE printers.Printer_ID = t.Printer_ID) * 1.5;	printer	3
SELECT 9.9E15 / 2999 AS NumberOfPrinters;	printer	4
SELECT Printer_ID,         SUM((Power_Consumption * 2) / 1000.0) AS TotalPowerConsumption_kWh  FROM maintenance_logs ml JOIN printers p ON ml.Printer_ID = p.Printer_ID WHERE Maintenance_Type = 'Repair' GROUP BY ml.Printer_ID ORDER BY TotalPowerConsumption_kWh DESC LIMIT 5;	printer	1
WITH RECURSIVE months(month) AS (     SELECT 1     UNION ALL     SELECT month + 1 FROM months WHERE month < 12 ), monthly_cost AS (     SELECT months.month, COALESCE(SUM(ml.Cost),0) AS total_cost     FROM months     LEFT JOIN maintenance_logs ml ON strftime('%Y', ml.Maintenance_Date) = '2023' AND strftime('%m', ml.Maintenance_Date) = printf('%02d', months.month)     GROUP BY months.month ) SELECT current_month,        CASE WHEN previous_month_cost = 0 THEN 0 ELSE ROUND(((current_month_cost - previous_month_cost) * 100.0 / previous_month_cost), 2) END AS growth_rate FROM (     SELECT month AS current_month,            total_cost AS current_month_cost,            LAG(total_cost, 1, 0) OVER (ORDER BY month) AS previous_month_cost     FROM monthly_cost ) t ORDER BY growth_rate ASC;	printer	2
WITH global_avg AS ( SELECT AVG(Cost) AS avg_cost FROM maintenance_logs ) SELECT Printer_ID, COUNT(*) AS maintenance_count FROM maintenance_logs WHERE Cost < (SELECT avg_cost FROM global_avg) GROUP BY Printer_ID HAVING COUNT(*) > 3 ORDER BY maintenance_count DESC LIMIT 10;	printer	3
WITH RECURSIVE months(month) AS (     SELECT 1     UNION ALL     SELECT month + 1 FROM months WHERE month < 12 ), monthly_cost AS (     SELECT months.month, COALESCE(SUM(ml.Cost), 0) AS total_cost     FROM months     LEFT JOIN maintenance_logs ml ON strftime('%Y', ml.Maintenance_Date) = '2023' AND strftime('%m', ml.Maintenance_Date) = printf('%02d', months.month)     GROUP BY months.month ) SELECT current_month,        CASE            WHEN previous_month_cost = 0 THEN 0            ELSE ROUND(((current_month_cost - previous_month_cost) * 100.0 / previous_month_cost), 2)        END AS growth_rate FROM (     SELECT month AS current_month,            total_cost AS current_month_cost,            LAG(total_cost, 1, 0) OVER (ORDER BY month) AS previous_month_cost     FROM monthly_cost ) t ORDER BY growth_rate ASC;	printer	4
SELECT m.Printer_ID, SUM((julianday(m.Next_Maintenance_Date) - julianday(m.Maintenance_Date)) * 24 * (p.Power_Consumption * 0.2) / 1000) AS Total_Standby_Energy_kWh FROM maintenance_logs m JOIN printers p ON m.Printer_ID = p.Printer_ID GROUP BY m.Printer_ID;	printer	1
WITH MaintenanceTypeStats AS (   SELECT      Maintenance_Type,     AVG(Cost) AS avg_cost,     STDEV(Cost) AS cost_stddev   FROM maintenance_logs   GROUP BY Maintenance_Type ) SELECT    Maintenance_Type,   avg_cost,   cost_stddev,   ROUND((cost_stddev / avg_cost) * 100, 4) AS cost_coefficient_of_variation FROM MaintenanceTypeStats;	printer	2
SELECT      CAST((strftime('%m', Maintenance_Date) + 2) / 3 AS INTEGER) AS Quarter,      Maintenance_Type,      COUNT(*) AS Frequency,      (SUM(CASE WHEN Maintenance_Type = 'Routine' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS Preventive_Ratio  FROM maintenance_logs  WHERE Maintenance_Type IN ('Routine','Repair')  GROUP BY Quarter, Maintenance_Type  ORDER BY Quarter;	printer	3
SELECT Technician, MAX(Cost) AS Actual_Max_Cost, (SELECT SUM(Cost)*0.95 FROM maintenance_logs) AS Theoretical_Max_Cost FROM maintenance_logs GROUP BY Technician;	printer	4
SELECT 850 * 3 * 3600 AS Total_Energy_Joules;	printer	1
SELECT ROUND( (COUNT(CASE WHEN Cost > (SELECT AVG(Cost) FROM maintenance_logs WHERE Maintenance_Type = 'Repair') THEN 1 END) * 100.0 / COUNT(*)), 2 ) AS Repair_Proportion FROM maintenance_logs WHERE Maintenance_Type = 'Repair';	printer	2
SELECT ml.* FROM maintenance_logs ml JOIN printers p ON ml.Printer_ID = p.Printer_ID WHERE ml.Maintenance_Date < p.Installation_Date;	printer	3
SELECT * FROM maintenance_logs WHERE Cost > 1e18 AND Next_Maintenance_Date > '3000-01-01';	printer	4
SELECT (400 * 18 * 365 / 1000) * Production_Volume_Total AS Total_Power_Consumption_kWh FROM manufacturers WHERE Manufacturer_ID = 'MAN001';	printer	1
SELECT R&D_Spending / Employee_Count AS Per_Capita_RD, (R&D_Spending / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND R&D_Spending = 800000000 AND Employee_Count = 10000;	printer	2
SELECT Founded_Year, R&D_Spending, CASE WHEN Founded_Year < 1900 AND R&D_Spending > 500000000 THEN 'Unreasonable' ELSE 'Reasonable' END AS Validity FROM manufacturers WHERE Founded_Year = 1700 AND R&D_Spending = 500000000;	printer	3
SELECT "R&D_Spending" / Employee_Count AS Per_Capita_RD, ("R&D_Spending" / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND "R&D_Spending" = 800000000 AND Employee_Count = 10000;	printer	4
SELECT Manufacturer_ID, Name, (Total_Energy / Production_Volume_Total) AS Energy_Consumption_Ratio FROM (     SELECT m.Manufacturer_ID, m.Name, m.Production_Volume_Total,             m.Production_Volume_Total * 0.5 AS Total_Energy     FROM manufacturers m ) ORDER BY Energy_Consumption_Ratio ASC LIMIT 3;	printer	1
SELECT Name, (R&D_Spending / Revenue) * 100 AS R_D_Percent FROM manufacturers ORDER BY R_D_Percent DESC LIMIT 5;	printer	2
SELECT Name, Founded_Year, Profit_Margin FROM manufacturers WHERE Founded_Year < 1950 AND Profit_Margin > 15 ORDER BY Founded_Year ASC;	printer	3
SELECT Name, (Revenue / Employee_Count) AS Per_Capita_Output FROM manufacturers UNION ALL SELECT 'Hypothetical Manufacturer' AS Name, 1000000000000 / 1 AS Per_Capita_Output ORDER BY Per_Capita_Output DESC;	printer	4
SELECT Country, SUM(Production_Volume_Total * 50 * 0.5) AS Total_Carbon_Emission FROM manufacturers GROUP BY Country;	printer	1
SELECT (R&D_Spending / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY Comprehensive_Index;	printer	2
SELECT Country, COUNT(*) AS Abnormal_Company_Count FROM manufacturers WHERE Founded_Year <= 1973 AND Market_Cap < (Revenue * 2) GROUP BY Country;	printer	3
SELECT ('R&D_Spending' / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY ('R&D_Spending' / Revenue) * (Profit_Margin / 100);	printer	4
SELECT m.Name, (m.Production_Volume_Total * 300 * 8 * 365 / 1000) AS Total_Annual_Power_Consumption_kWh FROM manufacturers m GROUP BY m.Manufacturer_ID;	printer	1
SELECT m.Name, ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m WHERE ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) > 10;	printer	2
SELECT Name, Founded_Year, Employee_Count FROM manufacturers WHERE (strftime('%Y', 'now') - Founded_Year) > 50 AND Employee_Count < 1000;	printer	3
SELECT m.Name, ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m WHERE ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) > 10;	printer	4
SELECT (Power_Consumption * (500.0 / (Print_Speed * 60)) / 1000) AS Total_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome' AND Power_Consumption = 800 AND Print_Speed = 30;	printer	1
SELECT CASE WHEN (2000*0.05 + 5000*0.02) <= (Capacity * (Current_Level/100.0)) THEN 'sufficient' ELSE 'not sufficient' END AS is_sufficient FROM consumables WHERE Type = 'Ink' AND Capacity = 100 AND Current_Level = 60;	printer	2
SELECT CEIL(7.0 / 2) AS Actual_Sheets FROM print_jobs WHERE Duplex = 1 AND Page_Count = 7;	printer	3
SELECT (POWER(10, 18) * 0.1 / 1000) / (500 * 0.1 / 1000 * 24 * 365) AS Years FROM printers WHERE Type = '3D' AND Tray_Capacity = 500;	printer	3
SELECT p.Model, SUM((j.Page_Count / CAST(SUBSTR(p.Print_Speed, 1, INSTR(p.Print_Speed, 'ppm') - 1) AS REAL)) * 60 * p.Power_Consumption * 1000) AS Total_Energy FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE p.Type = 'Laser' GROUP BY p.Model ORDER BY Total_Energy DESC LIMIT 5;	printer	1
SELECT c.Model, (SUM(CASE WHEN j.Color_Usage = 'Color' THEN j.Page_Count * 3 * (c.Cost/c.Capacity) ELSE 0 END) / SUM(CASE WHEN j.Color_Usage = 'Monochrome' THEN j.Page_Count * (c.Cost/c.Capacity) ELSE 0 END)) AS Cost_Ratio FROM consumables c JOIN print_jobs j ON c.Printer_ID = j.Printer_ID WHERE c.Type = 'Ink' GROUP BY c.Model HAVING Cost_Ratio IS NOT NULL ORDER BY Cost_Ratio DESC LIMIT 3;	printer	2
SELECT u.Name, SUM(j.Page_Count * 0.5) AS Saved_Paper  FROM users u  JOIN print_jobs j ON u.User_ID = j.User_ID  WHERE j.Duplex = 1  GROUP BY u.User_ID  ORDER BY Saved_Paper DESC  LIMIT 10;	printer	3
SELECT Model, (1000000000.0 / CAST(SUBSTR(Print_Speed, 1, INSTR(Print_Speed, 'ppm') - 1) AS REAL)) / 525600.0 AS Years FROM printers ORDER BY Years DESC LIMIT 5;	printer	4
SELECT Paper_Size, SUM(Page_Count * 80 * 0.06237 * (CASE WHEN Duplex=1 THEN 0.5 ELSE 1.0 END)) / 1000.0 AS Total_Mass_Kg FROM print_jobs GROUP BY Paper_Size;	printer	1
SELECT Duplex, SUM(Page_Count) - SUM(CEIL(Page_Count / (CASE WHEN Duplex = 1 THEN 2.0 ELSE 1.0 END))) AS Saved_Pages FROM print_jobs GROUP BY Duplex;	printer	2
SELECT Color_Usage, SUM(Page_Count * (CASE WHEN Color_Usage='Color' THEN 3 ELSE 1 END)) AS Consumption_Ratio FROM print_jobs GROUP BY Color_Usage;	printer	3
SELECT Duplex, CASE WHEN (100000000 / (CASE WHEN Duplex=1 THEN 2 ELSE 1 END)) > 2147483647 THEN 1 ELSE 0 END AS Crash_Condition FROM (SELECT 0 AS Duplex UNION SELECT 1) AS modes;	printer	4
SELECT pj.*  FROM print_jobs pj  JOIN printers pr ON pj.Printer_ID = pr.Printer_ID  WHERE pj.Paper_Size = 'A4'  AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(REPLACE(pr.Print_Speed, '^0-9', '') AS INTEGER), 0))) > (pr.Power_Consumption * 0.1);	printer	1
SELECT pj.Job_ID, pj.Page_Count * 0.05 * (c.Cost / 250) AS Total_Ink_Cost FROM print_jobs pj JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE pj.Color_Usage = 'Color' AND c.Type = 'Ink';	printer	2
SELECT pj.*  FROM print_jobs pj  JOIN printers pr ON pj.Printer_ID = pr.Printer_ID  WHERE pj.Paper_Size = 'A4'  AND pj.Duplex = 1  AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(SUBSTR(pr.Print_Speed, 1, INSTR(pr.Print_Speed, 'ppm') - 1) AS INTEGER), 0))) > (pr.Power_Consumption * 0.1);	printer	3
SELECT * FROM print_jobs WHERE Page_Count > 8848000000 / (0.1 * 0.001);	printer	4
SELECT ((800 * 4 + 50 * 20) * 30) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser';	printer	1
SELECT ((5000 * 0.3 - (1200 * 1 + (800 * 0.4 * 2.5 + 800 * 0.6 * 1) + (500 * 0.5))) / 5000 * 100) AS Remaining_Percent FROM consumables WHERE Type = 'Toner' AND Model = 'Certain Model';	printer	2
WITH drum_cost AS (SELECT Cost FROM consumables WHERE Type = 'Drum' LIMIT 1),       fuser_cost AS (SELECT Cost FROM consumables WHERE Type = 'Fuser' LIMIT 1)  SELECT (200 * 48 + 500 * 16) AS Annual_Budget  FROM drum_cost, fuser_cost;	printer	3
SELECT (100 * 365 * 24 * 60 / 5) AS Max_Tasks, (100 * 365 * 24 / 1000) * 1500 AS Maintenance_Cost, (100 * 365 * 24 * 60 / 5) * 0.2 AS Total_Weight FROM printers WHERE Type = '3D' LIMIT 1;	printer	4
SELECT Printer_ID, Model, (Power_Consumption * (julianday('now') - julianday(Installation_Date)) * 24) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser' AND Installation_Date >= date('now', '-1 year') ORDER BY Total_kWh DESC LIMIT 3;	printer	1
SELECT m.Name, m.Profit_Margin FROM manufacturers m WHERE m.Profit_Margin < 15 AND m.Employee_Count > 10000 ORDER BY m.Profit_Margin ASC;	printer	2
SELECT Consumable_ID, Printer_ID, Current_Level, Last_Replacement_Date FROM consumables WHERE Type = 'Toner' AND Current_Level < 20 AND julianday('now') - julianday(Last_Replacement_Date) > 90 ORDER BY Current_Level ASC;	printer	3
SELECT (100000000 / 2) AS Saved_Pages, ((100000000 / 2) * 4.5) / 1000000 AS Saved_Weight_Tons ORDER BY Saved_Weight_Tons DESC;	printer	4
SELECT Printer_ID, (Power_Consumption * 24 * 0.65 / 1000) AS Total_Energy_kWh FROM printers WHERE Type = 'laser' GROUP BY Printer_ID;	printer	1
SELECT c.Model, (c.Capacity * (c.Current_Level / 100) / 3) / (SUM(p.Page_Count * 3) / 30) AS Remaining_Days FROM consumables c JOIN printers pr ON c.Printer_ID = pr.Printer_ID JOIN print_jobs p ON pr.Printer_ID = p.Printer_ID WHERE c.Type = 'toner' AND p.Job_Date >= date('now', '-30 days') GROUP BY c.Model;	printer	2
SELECT u.Department, SUM(p.Page_Count - (p.Page_Count + 1) / 2) AS Saved_Papers FROM print_jobs p JOIN users u ON p.User_ID = u.User_ID WHERE u.Department = 'Sales Department' AND p.Duplex = 1 AND strftime('%Y', p.Job_Date) = '2023' AND ((strftime('%m', p.Job_Date) - 1) / 3 + 1) = 4 GROUP BY u.Department;	printer	3
SELECT Printer_ID, ((c.Capacity * (c.Current_Level / 100.0) / 3.0) / (SUM(p.Page_Count * 3.0) / 30.0) / (60.0 * 60.0 * 24.0 * 365.25)) / (1.38e10) AS Universe_Ages FROM consumables c JOIN print_jobs p ON c.Printer_ID = p.Printer_ID WHERE c.Type = '3D' AND c.Capacity = 1e18 AND c.Current_Level = 0.1 AND p.Job_Date >= date('now', '-30 days') GROUP BY Printer_ID;	printer	4
SELECT Printer_ID, ((Power_Consumption * (86400 - 5) + Power_Consumption * 1.2 * 5) / 1000.0) AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Power_Consumption = 800;	printer	1
SELECT p.Printer_ID, (p.Weight + (p.Tray_Capacity * 365 * 0.0045)) * (strftime('%Y', 'now') - p.Year) AS Composite_Value FROM printers p WHERE p.Printer_ID IN (SELECT DISTINCT j.Printer_ID FROM print_jobs j JOIN users u ON j.User_ID = u.User_ID WHERE u.Department = 'a certain department');	printer	2
SELECT p.Printer_ID, p.Location  FROM printers p  WHERE NOT EXISTS (     SELECT 1      FROM print_jobs j      JOIN users u ON j.User_ID = u.User_ID      WHERE j.Printer_ID = p.Printer_ID      AND LOWER(u.Department) LIKE '%' || LOWER(p.Location) || '%' );	printer	3
SELECT ((1e8 * 100 * 365 * 24 * 3600) / (POWER(3e8, 2))) / 7.342e22 AS Equivalent_Moon_Masses;	printer	4
SELECT (Power_Consumption * 23.75 + 200 * 0.25) / 1000 AS Total_Energy_KWh FROM printers WHERE Type = 'Laser' AND Max_Resolution = 'Maximum_Resolution_Value';	printer	1
SELECT Name, ROUND((SUM(RD_Spending) / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;	printer	2
SELECT CASE WHEN (SUM(Page_Count * 2 - Page_Count) / SUM(Page_Count * 2) * 100) BETWEEN 45 AND 47.5 THEN 'Complies' ELSE 'Does not comply' END AS Compliance FROM print_jobs WHERE Duplex = 1 AND Paper_Size = 'A4';	printer	3
SELECT Name, ROUND((SUM(RD_Spending) / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;	printer	4
SELECT users.User_ID, SUM(printers.Power_Consumption / 1000.0 * 24) AS total_energy_kWh FROM users JOIN print_jobs ON users.User_ID = print_jobs.User_ID JOIN printers ON print_jobs.Printer_ID = printers.Printer_ID WHERE users.Role = 'Admin' AND printers.Type = 'Laser' GROUP BY users.User_ID ORDER BY total_energy_kWh DESC LIMIT 3;	printer	1
SELECT u.Department, (SUM(CASE WHEN pj.Color_Usage = 'Monochrome' THEN pj.Page_Count ELSE 0 END) * 1.0 / SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END)) AS ratio FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Color_Usage IN ('Monochrome', 'Color') GROUP BY u.Department HAVING SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END) > 0 ORDER BY ratio ASC LIMIT 5;	printer	2
SELECT u.*, pj.* FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE u.Role = 'Guest' AND pj.Page_Count > 50 ORDER BY pj.Page_Count DESC LIMIT 10;	printer	3
SELECT u.Department, SUM(pj.Page_Count) AS total_pages FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Page_Count >= 1000000 GROUP BY u.Department ORDER BY total_pages DESC LIMIT 5;	printer	4
SELECT u.Department, SUM((p.Page_Count / (1 + p.Duplex) / pr.Print_Speed / 60) * (pr.Power_Consumption / 1000)) AS Total_Energy_kWh FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Department;	printer	1
SELECT u.Role, SUM(p.Page_Count * (CASE WHEN p.Color_Usage = 'Color' THEN 1.2 ELSE 1 END) / pr.Print_Speed * 60) / SUM(p.Page_Count) AS Avg_Time_Per_Page FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Role ORDER BY Avg_Time_Per_Page;	printer	2
SELECT u.Department, p.Paper_Size, COUNT(*) AS Usage_Count FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID GROUP BY u.Department, p.Paper_Size ORDER BY u.Department, Usage_Count DESC;	printer	3
SELECT 10000000 * 0.05 * 2 AS Total_Ink_ml, ((10000000 * 0.05 * 2) + 499) / 500 AS Replacement_Count;	printer	4
SELECT u.User_ID, u.Name  FROM users u  JOIN print_jobs pj ON u.User_ID = pj.User_ID  JOIN printers pr ON pj.Printer_ID = pr.Printer_ID  WHERE pr.Power_Consumption * 1.2 * SUM(pj.Page_Count) / pr.Print_Speed > pr.Power_Consumption * 10  AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = pr.Printer_ID)  GROUP BY u.User_ID, u.Name  HAVING SUM(pj.Page_Count) > 0;	printer	1
WITH DeptCost AS (     SELECT          u.Department,          SUM(c.Cost / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg      FROM users u      JOIN print_jobs pj ON u.User_ID = pj.User_ID      JOIN consumables c ON pj.Printer_ID = c.Printer_ID      WHERE c.Type IN ('Toner', 'Ink')      GROUP BY u.Department ) SELECT      u.User_ID,      u.Name  FROM users u  JOIN DeptCost dc ON u.Department = dc.Department  WHERE (SELECT c.Cost / c.Capacity FROM consumables c WHERE c.Printer_ID IN (SELECT pj.Printer_ID FROM print_jobs pj WHERE pj.User_ID = u.User_ID) AND c.Type IN ('Toner', 'Ink') LIMIT 1) < dc.DeptAvg  AND NOT EXISTS (     SELECT 1      FROM maintenance_logs ml      JOIN print_jobs pj2 ON ml.Printer_ID = pj2.Printer_ID      WHERE pj2.User_ID = u.User_ID      AND ml.Maintenance_Type = 'Replacement' );	printer	2
SELECT u.User_ID, u.Name  FROM users u  WHERE u.Department IN (     SELECT p.Location      FROM printers p      WHERE p.Tray_Capacity < (SELECT AVG(Tray_Capacity) FROM printers) )  AND NOT EXISTS (     SELECT 1      FROM print_jobs pj      WHERE pj.User_ID = u.User_ID AND pj.Duplex = 1 )  AND NOT EXISTS (     SELECT 1      FROM print_jobs pj2      INNER JOIN printers pr ON pj2.Printer_ID = pr.Printer_ID      INNER JOIN consumables c ON pr.Printer_ID = c.Printer_ID      WHERE pj2.User_ID = u.User_ID      AND c.Last_Replacement_Date IS NOT NULL )  GROUP BY u.User_ID, u.Name  HAVING SUM(pj.Page_Count) > 0;	printer	3
WITH DeptCost AS (     SELECT          u.Department,          SUM(c.Cost * 1.0 / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg      FROM          users u          JOIN print_jobs pj ON u.User_ID = pj.User_ID          JOIN consumables c ON pj.Printer_ID = c.Printer_ID      WHERE          c.Type IN ('Toner', 'Ink')      GROUP BY          u.Department ) SELECT      u.User_ID,      u.Name  FROM      users u      JOIN DeptCost dc ON u.Department = dc.Department      JOIN print_jobs pj ON u.User_ID = pj.User_ID      JOIN consumables c ON pj.Printer_ID = c.Printer_ID  WHERE      (c.Cost * 1.0 / c.Capacity) < dc.DeptAvg      AND c.Current_Level <= 0.1      AND NOT EXISTS (         SELECT 1          FROM maintenance_logs ml          WHERE              ml.Printer_ID = c.Printer_ID              AND ml.Maintenance_Type = 'Replacement'             AND ml.Maintenance_Date <= c.Next_Replacement_Date     );	printer	4
SELECT Printer_ID, Model, (1000.0 / CAST(SUBSTR(Print_Speed, 1, LENGTH(Print_Speed) - 3) AS REAL)) * Power_Consumption / 1000.0 / 60.0 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';	printer	1
SELECT m.Manufacturer_ID, m.Name, ((m.Revenue - (COALESCE(c.TotalConsumableCost,0) + COALESCE(ml.TotalMaintenanceCost,0))) / m.Revenue * 100) AS Profit_Margin_Percent FROM manufacturers m LEFT JOIN (SELECT p.Manufacturer_ID, SUM(c.Cost) AS TotalConsumableCost FROM printers p JOIN consumables c ON p.Printer_ID = c.Printer_ID GROUP BY p.Manufacturer_ID) c ON m.Manufacturer_ID = c.Manufacturer_ID LEFT JOIN (SELECT p.Manufacturer_ID, SUM(ml.Cost) AS TotalMaintenanceCost FROM printers p JOIN maintenance_logs ml ON p.Printer_ID = ml.Printer_ID GROUP BY p.Manufacturer_ID) ml ON m.Manufacturer_ID = ml.Manufacturer_ID;	printer	2
SELECT Printer_ID, Model, (1000.0 / CAST(SUBSTR(Print_Speed, 1, LENGTH(Print_Speed)-3) AS REAL)) * Power_Consumption / 1000.0 / 60.0 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';	printer	3
WITH RECURSIVE YearlyCost(Year, Annual_Cost) AS (     SELECT 1, 1000.0     UNION ALL     SELECT Year + 1, Annual_Cost * 3.0 FROM YearlyCost WHERE Year < 100 ) SELECT Annual_Cost AS Year_100_Cost FROM YearlyCost WHERE Year = 100;	printer	4
SELECT c.Consumable_ID,         (c.Capacity - SUM(pj.Page_Count)) /         (AVG(pj.Page_Count / NULLIF((JULIANDAY((SELECT MAX(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID)) - JULIANDAY((SELECT MIN(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID))), 0)) * (1 + AVG(pj.Duplex)*0.5)) AS Remaining_Days  FROM consumables c  JOIN print_jobs pj ON c.Printer_ID = pj.Printer_ID  WHERE c.Type = 'Drum' AND c.Model = 'X-DrumUltra'  GROUP BY c.Consumable_ID, c.Capacity;	printer	1
WITH RECURSIVE YearlyCost (Year, Annual_Cost) AS (     SELECT 1, 1000.0      UNION ALL      SELECT Year+1, Annual_Cost*3      FROM YearlyCost      WHERE Year < 100 ) SELECT Annual_Cost AS Year_100_Cost  FROM YearlyCost  WHERE Year = 100;	printer	2
SELECT u.Department, (SUM(CASE WHEN pj.Paper_Size = 'A4' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.7 + SUM(CASE WHEN pj.Paper_Size = 'Letter' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.3) AS Predicted_Sheets FROM print_jobs pj JOIN users u ON pj.User_ID = u.User_ID WHERE u.Department = 'Sales' GROUP BY u.Department;	printer	3
SELECT ((5000 * 0.99) - 1e18) / 5000.0 * 100;	printer	4
SELECT 1, SUM(RainfallMm) AS TotalRainfallMm FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59' GROUP BY 1;	RainGauge	1
SELECT 1, AnalysisTime, DataStartTime, DataEndTime, (AverageRainfallIntensityMmH * 1.0 / MaxRainfallIntensityMmH) AS IntensityRatio, AnalysisResult FROM HistoricalRainfallAnalysis WHERE DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59' ORDER BY AnalysisTime;	RainGauge	2
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 2 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN 'extreme weather event' ELSE 'non-extreme weather event' END AS WeatherEventType FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN TotalRainfallMm >= 10000 THEN 'May cause environmental impacts such as flooding and soil erosion' ELSE 'Environmental impact is minimal' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND TotalRainfallMm >= 10000;	RainGauge	4
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (TotalRainfallMm * 1 * 1000 / 1000) AS WaterMassKg FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	1
SELECT t1.GaugeId, t1.CollectionTime AS Time1, t2.CollectionTime AS Time2, t1.RainfallIntensityMmH AS Intensity1, t2.RainfallIntensityMmH AS Intensity2, (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) / (strftime('%s', t2.CollectionTime) - strftime('%s', t1.CollectionTime)) * 3600 AS ChangeRate FROM RainfallData t1 JOIN RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime WHERE t1.GaugeId = 1 AND t1.CollectionTime >= '2023-01-01 00:00:00' AND t2.CollectionTime <= '2023-12-31 23:59:59' ORDER BY t1.CollectionTime;	RainGauge	2
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 3 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN 'May cause flooding' ELSE 'Low flood risk' END AS FloodRisk FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, DataStartTime, DataEndTime, MaxRainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN MaxRainfallIntensityMmH >= 1000 THEN 'May cause environmental impacts such as flooding and soil erosion' ELSE 'Minimal environmental impact' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 2 AND MaxRainfallIntensityMmH >= 1000;	RainGauge	4
SELECT RG.Id, RG.ElevationMeters, 1013.25 * EXP(-RG.ElevationMeters / 8400) AS CalculatedPressure, RD.AtmosphericPressureHpa  FROM RainGauge RG  JOIN RainfallData RD ON RG.Id = RD.GaugeId  WHERE RG.Id = 1;	RainGauge	1
WITH Data AS (SELECT TemperatureCelsius AS X, RainfallMm AS Y FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(X) AS X_avg, AVG(Y) AS Y_avg, SUM((X - X_avg) * (Y - Y_avg)) / SUM((X - X_avg) * (X - X_avg)) AS slope, AVG(Y) - (SUM((X - X_avg) * (Y - Y_avg)) / SUM((X - X_avg) * (X - X_avg))) * AVG(X) AS intercept FROM Data, (SELECT AVG(X) AS X_avg, AVG(Y) AS Y_avg FROM Data)) SELECT slope, intercept, slope * 25 + intercept AS PredictedRainfall FROM Stats;	RainGauge	2
SELECT Id, GaugeModel, ManufactureDate, InstallationDate,         (julianday('now') - julianday(ManufactureDate)) / 365 AS UsageYears,         CASE WHEN (julianday('now') - julianday(ManufactureDate)) / 365 > 10              THEN 'Likely to affect data accuracy due to aging'              ELSE 'Has not reached the age affecting accuracy'         END AS AgingImpact  FROM RainGauge;	RainGauge	3
SELECT Id, GaugeModel, ElevationMeters, 1013.25 * EXP(-10000 / 8400) AS CalculatedPressure, CASE WHEN 1013.25 * EXP(-10000 / 8400) < 300 THEN 'May cause data distortion or equipment failure' ELSE 'Impact is minor' END AS ImpactAnalysis FROM RainGauge WHERE Id = 2;	RainGauge	4
SELECT Id, ElevationMeters, 1013.25 * EXP(-ElevationMeters / 8400) AS AtmosphericPressureHpa FROM RainGauge WHERE Id = 2;	RainGauge	1
WITH RainfallLatitude AS (     SELECT rg.Latitude AS Latitude, rd.RainfallMm AS Rainfall      FROM RainGauge rg      JOIN RainfallData rd ON rg.Id = rd.GaugeId      WHERE rg.Id = 2 AND rd.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' ), Stats AS (     SELECT AVG(Latitude) AS AvgLatitude, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N      FROM RainfallLatitude ), Slope AS (     SELECT SUM((Latitude - AvgLatitude) * (Rainfall - AvgRainfall)) / SUM((Latitude - AvgLatitude) * (Latitude - AvgLatitude)) AS Slope      FROM RainfallLatitude, Stats ), Intercept AS (     SELECT AvgRainfall - Slope * AvgLatitude AS Intercept      FROM Stats, Slope ) SELECT Slope, Intercept  FROM Slope, Intercept;	RainGauge	2
SELECT Id, ElevationMeters, CASE WHEN ElevationMeters >= 0 AND ElevationMeters <= 5000 THEN 'Suitable for installation' ELSE 'Not suitable for installation' END AS InstallationSuitability FROM RainGauge WHERE Id = 2;	RainGauge	3
SELECT GaugeId, CollectionTime, TemperatureCelsius, HumidityPercent, CASE WHEN TemperatureCelsius >= 100 AND HumidityPercent >= 200 THEN 'May cause device sensor damage, data distortion, or complete unavailability' ELSE 'Data collection is normal' END AS ImpactAnalysis FROM RainfallData WHERE TemperatureCelsius >= 100 AND HumidityPercent >= 200;	RainGauge	4
SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, (SUM(RainfallMm) * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	1
WITH RainfallTemperature AS (SELECT TemperatureCelsius AS Temperature, RainfallMm AS Rainfall FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(Temperature) AS AvgTemperature, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N FROM RainfallTemperature), Slope AS (SELECT SUM((Temperature - AvgTemperature) * (Rainfall - AvgRainfall)) / SUM((Temperature - AvgTemperature) * (Temperature - AvgTemperature)) AS Slope FROM RainfallTemperature, Stats), Intercept AS (SELECT AvgRainfall - Slope * AvgTemperature AS Intercept FROM Stats, Slope) SELECT Slope, Intercept FROM Slope, Intercept;	RainGauge	2
SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, CASE WHEN SUM(RainfallMm) > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'Rainfall' AND ConditionOperator = '>' AND IsActive = 1) THEN 'May Cause Flood' ELSE 'Low Flood Risk' END AS FloodRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	3
SELECT GaugeId, CollectionTime, RainfallMm, (10000.0 * 1000.0 * 9.81 / 1000.0) AS PressurePa, CASE WHEN RainfallMm >= 10000 THEN 'May cause environmental impacts such as flooding and soil erosion' ELSE 'Minimal environmental impact' END AS EnvironmentalImpact FROM RainfallData WHERE GaugeId = 2 AND RainfallMm >= 10000;	RainGauge	4
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (RainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
WITH RainfallIntensityChange AS (     SELECT          t1.CollectionTime AS Time1,          t2.CollectionTime AS Time2,          t1.RainfallIntensityMmH AS Intensity1,          t2.RainfallIntensityMmH AS Intensity2,          (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) /          (strftime('%s', t2.CollectionTime) - strftime('%s', t1.CollectionTime)) * 3600 AS ChangeRate      FROM          RainfallData t1      JOIN          RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime      WHERE          t1.GaugeId = 3          AND t1.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' )  SELECT      Time1,      Time2,      Intensity1,      Intensity2,      ChangeRate  FROM      RainfallIntensityChange  ORDER BY      Time1;	RainGauge	2
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, CASE WHEN RainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'rainfall intensity' AND ConditionOperator = '>' AND IsActive = 1) THEN 'may trigger flash flood' ELSE 'low flash flood risk' END AS FloodRisk FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND RainfallIntensityMmH = 1000;	RainGauge	4
SELECT GaugeId, CollectionTime, TemperatureCelsius, (TemperatureCelsius + 273.15) * 287 * 1.225 / 0.02896 AS AtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(TemperatureCelsius) AS AvgTemperature, COUNT(*) AS N FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT GaugeId, CollectionTime, TemperatureCelsius, CASE WHEN TemperatureCelsius >= -20 AND TemperatureCelsius <= 50 THEN 'Normal Operation' ELSE 'May Affect Operation' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, TemperatureCelsius, (73.15 * 287 * 1.225 / 0.02896) AS AtmosphericPressureHpa, CASE WHEN TemperatureCelsius <= -200 THEN 'may cause equipment freezing and data distortion' ELSE 'data collection is normal' END AS ImpactAnalysis FROM RainfallData WHERE GaugeId = 2 AND TemperatureCelsius <= -200;	RainGauge	4
SELECT GaugeId, CollectionTime, HumidityPercent, (HumidityPercent * 0.01 * 23.76) + (AtmosphericPressureHpa - (HumidityPercent * 0.01 * 23.76)) AS AdjustedAtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(HumidityPercent) AS AvgHumidity, MIN(HumidityPercent) AS MinHumidity, MAX(HumidityPercent) AS MaxHumidity FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT GaugeId, CollectionTime, HumidityPercent, CASE WHEN HumidityPercent >= 0 AND HumidityPercent <= 90 THEN 'Normal Operation' ELSE 'Likely to Cause Failure' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, HumidityPercent, AtmosphericPressureHpa, (200 * AtmosphericPressureHpa * 0.01) + (AtmosphericPressureHpa * 0.99) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(WindSpeedMps) AS AvgWindSpeed, MIN(WindSpeedMps) AS MinWindSpeed, MAX(WindSpeedMps) AS MaxWindSpeed FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, WindSpeedMps, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 THEN 'May Cause Equipment Failure' ELSE 'Wind Speed Within Normal Range' END AS FaultRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT CollectionTime, RainfallMm, 100 AS AssumedWindSpeedMps, RainfallMm * (1 + 100 / 10) AS AdjustedRainfallMm, CASE WHEN 100 > 20 THEN 'May cause equipment failure or data distortion' ELSE 'Wind speed within normal range' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, WindDirectionDegrees, RainfallMm * (1 + WindDirectionDegrees / 360.0) AS AdjustedRainfallDistribution FROM RainfallData WHERE GaugeId = 4 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT AVG(WindDirectionDegrees) AS AverageWindDirection, COUNT(*) AS DataPoints FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	2
SELECT GaugeId, CollectionTime, WindDirectionDegrees, CASE WHEN WindDirectionDegrees >= 0 AND WindDirectionDegrees <= 360 THEN 'Normal Operation' ELSE 'May Affect Operation' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, WindDirectionDegrees, RainfallMm, (RainfallMm * (1 + 720 / 360)) AS EstimatedRainfallDistribution, CASE WHEN WindDirectionDegrees = 720 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - AtmosphericPressureHpa) / 1013.25) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(AtmosphericPressureHpa) AS AvgPressure, MIN(AtmosphericPressureHpa) AS MinPressure, MAX(AtmosphericPressureHpa) AS MaxPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'May cause equipment failure' ELSE 'Atmospheric pressure is within normal range' END AS FaultRisk FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT CollectionTime, RainfallMm, 2000 AS AssumedAtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - 2000) / 1013.25) AS AdjustedRainfallMm, CASE WHEN 2000 < 800 OR 2000 > 1100 THEN 'May cause equipment failure or data distortion' ELSE 'Atmospheric pressure within normal range' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, TemperatureCelsius, AtmosphericPressureHpa, TemperatureCelsius * (1 + AtmosphericPressureHpa / 1013.25) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, MAX(AtmosphericPressureHpa) AS MaxPressure, MIN(AtmosphericPressureHpa) AS MinPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'May affect normal equipment operation' ELSE 'Atmospheric pressure within normal range' END AS OperationalImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, AtmosphericPressureHpa, TemperatureCelsius, (TemperatureCelsius * (1 + 3000 / 1013.25)) AS EstimatedTemperature, CASE WHEN AtmosphericPressureHpa = 3000 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT RuleName, ThresholdValue, RainfallMm, (RainfallMm * (1 + ThresholdValue / 100)) AS EstimatedRainfall FROM RainfallWarningRule JOIN RainfallData ON RainfallWarningRule.ParameterType = 'Rainfall' AND RainfallData.RainfallMm > RainfallWarningRule.ThresholdValue WHERE RainfallWarningRule.RuleName = 'Heavy Rainfall Alert';	RainGauge	1
WITH ThresholdData AS (     SELECT ThresholdValue      FROM RainfallWarningRule      WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = 'Rainfall Amount' ),  IntensityData AS (     SELECT RainfallIntensityMmH      FROM RainfallData )  SELECT (     SUM((ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData)) * (RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData))) /      (SQRT(SUM(POWER(ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData), 2)) * SUM(POWER(RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData), 2))) ) AS PearsonCorrelation  FROM ThresholdData, IntensityData;	RainGauge	2
SELECT RuleName, ThresholdValue, CASE WHEN ThresholdValue >= 0 AND ThresholdValue <= 1000 THEN 'Normal Operation' ELSE 'May Cause Equipment Failure' END AS DeviceStatus FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert';	RainGauge	3
SELECT CollectionTime, RainfallMm, 10000 AS AssumedThresholdValue, RainfallMm * (1 + 10000 / 100) AS AdjustedRainfallMm, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = 'Rainfall') THEN 'May cause equipment failure or data distortion' ELSE 'Rainfall threshold within normal range' END AS PotentialImpact FROM RainfallData;	RainGauge	4
SELECT RuleName, TotalRainfallMm, (TotalRainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Low Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(TotalRainfallMm - (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT AnalysisTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Flood Warning' AND ParameterType = 'Rainfall') THEN 'May Trigger Flood' ELSE 'Total Rainfall Within Safe Range' END AS FloodRisk FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, TotalRainfallMm, -1000 AS AssumedTotalRainfallMm, (-1000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Low Rainfall Alert' AND ParameterType = '降雨量') THEN 'May lead to drought or soil cracking' ELSE 'Rainfall within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, AverageRainfallIntensityMmH, (AverageRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Extreme Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(AverageRainfallIntensityMmH - (SELECT AVG(AverageRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT AnalysisTime, AverageRainfallIntensityMmH, CASE WHEN AverageRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May trigger urban waterlogging' ELSE 'Rainfall intensity is within safe range' END AS FloodRisk FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, AverageRainfallIntensityMmH, 1000 AS AssumedRainfallIntensity, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 1000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May cause flooding or soil erosion' ELSE 'Rainfall intensity is within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, MaxRainfallIntensityMmH, (MaxRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Light Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(MaxRainfallIntensityMmH - (SELECT AVG(MaxRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT AnalysisTime, MaxRainfallIntensityMmH, CASE WHEN MaxRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = 'rainfall intensity') THEN 'may affect outdoor activities' ELSE 'rainfall intensity within safe range' END AS OutdoorActivityImpact FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, MaxRainfallIntensityMmH, 10000 AS AssumedMaxRainfallIntensity, (10000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May cause flooding or soil erosion' ELSE 'Rainfall intensity is within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, MinRainfallIntensityMmH, (MinRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Moderate Rainfall Intensity Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(MinRainfallIntensityMmH - (SELECT AVG(MinRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = 'operational');	RainGauge	2
SELECT HRA.AnalysisResult FROM HistoricalRainfallAnalysis HRA JOIN RainfallWarningRule RWR ON HRA.GaugeId = RWR.Id WHERE RWR.RuleName = 'Moderate Rainfall Intensity Alert' AND HRA.MinRainfallIntensityMmH < 5;	RainGauge	3
SELECT AnalysisTime, MinRainfallIntensityMmH, -1000 AS AssumedMinRainfallIntensity, (-1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Moderate Rainfall Intensity Alert' AND ParameterType = 'Rainfall Intensity') THEN 'May lead to drought or soil cracking' ELSE 'Rainfall intensity within normal range' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT CollectionTime, RainfallMm, (RainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData;	RainGauge	1
WITH RainfallStats AS (SELECT RainfallMm AS X, RainfallIntensityMmH AS Y, AVG(RainfallMm) OVER () AS X_avg, AVG(RainfallIntensityMmH) OVER () AS Y_avg FROM RainfallData) SELECT (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM((X - X_avg) * (X - X_avg)) * SQRT(SUM((Y - Y_avg) * (Y - Y_avg))))) AS PearsonCorrelation FROM RainfallStats;	RainGauge	2
SELECT CollectionTime, RainfallMm, CASE WHEN RainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'Rainfall' AND RuleName = 'Flood Warning') THEN 'Likely to cause flooding' ELSE 'Lower flood risk' END AS FloodRisk FROM RainfallData;	RainGauge	3
SELECT CollectionTime, RainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = 'precipitation' AND ConditionOperator = '>' AND IsActive = 1) THEN 'may cause flooding or soil erosion' ELSE 'rainfall within normal range' END AS EnvironmentalImpact FROM RainfallData WHERE RainfallMm >= 10000;	RainGauge	4
SELECT CollectionTime, HumidityPercent, AtmosphericPressureHpa, (HumidityPercent * 0.01 * AtmosphericPressureHpa) + ((1 - HumidityPercent * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa FROM RainfallData;	RainGauge	1
WITH HumidityWindStats AS (     SELECT          HumidityPercent AS X,          WindSpeedMps AS Y,          AVG(HumidityPercent) OVER () AS X_avg,          AVG(WindSpeedMps) OVER () AS Y_avg      FROM RainfallData ) SELECT      (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM((X - X_avg) * (X - X_avg)) * SUM((Y - Y_avg) * (Y - Y_avg))))) AS PearsonCorrelation  FROM HumidityWindStats;	RainGauge	2
SELECT GaugeId, CollectionTime, HumidityPercent, WindSpeedMps, CASE WHEN HumidityPercent > 90 OR WindSpeedMps > 20 THEN 'May trigger equipment failure' ELSE 'Equipment operating normally' END AS FaultRisk FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, WindSpeedMps, AtmosphericPressureHpa, (200 * 0.01 * AtmosphericPressureHpa) + ((1 - 200 * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 OR WindSpeedMps = 100 THEN 'May affect data collection' ELSE 'Data collection normal' END AS DataImpact FROM RainfallData;	RainGauge	4
SELECT RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfall FROM RainfallData WHERE GaugeId = 'Specific Rainfall Gauge ID';	RainGauge	1
WITH WindSpeedStats AS (   SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints    FROM RainfallData ),  WindSpeedTrend AS (   SELECT CollectionTime, WindSpeedMps,          AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg    FROM RainfallData ) SELECT AvgWindSpeed, MovingAvg  FROM WindSpeedStats, WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, WindSpeedMps, WindDirectionDegrees, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN 'Likely to cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, RainfallMm, (RainfallMm * (1 + 100 / 10)) AS AdjustedRainfallMm, CASE WHEN WindSpeedMps >= 100 OR WindDirectionDegrees >= 720 THEN 'May cause equipment damage or data distortion' ELSE 'Wind speed and direction within normal range' END AS DataImpact FROM RainfallData WHERE WindSpeedMps >= 100 OR WindDirectionDegrees >= 720;	RainGauge	4
SELECT WindDirectionDegrees, AtmosphericPressureHpa, AtmosphericPressureHpa * (1 + WindDirectionDegrees / 360.0) AS AdjustedPressure FROM RainfallData WHERE GaugeId = 'Specific Rainfall Gauge ID';	RainGauge	1
WITH WindDirectionStats AS (     SELECT AVG(WindDirectionDegrees) AS AvgWindDirection, COUNT(*) AS DataPoints      FROM RainfallData ),  WindDirectionTrend AS (     SELECT CollectionTime, WindDirectionDegrees,             AVG(WindDirectionDegrees) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgWindDirection, MovingAvg  FROM WindDirectionStats, WindDirectionTrend;	RainGauge	2
SELECT CollectionTime, WindDirectionDegrees, AtmosphericPressureHpa, CASE WHEN WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'May cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa * (1 + 720.0 / 360.0)) AS AdjustedAtmosphericPressureHpa, CASE WHEN WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000 THEN 'may cause equipment damage or data distortion' ELSE 'wind direction and atmospheric pressure within normal range' END AS DataImpact FROM RainfallData WHERE WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000;	RainGauge	4
SELECT RainfallMm, TemperatureCelsius, TemperatureCelsius - (RainfallMm / 10) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH RainfallStats AS (     SELECT AVG(RainfallMm) AS AvgRainfall, COUNT(*) AS DataPoints      FROM RainfallData ),  RainfallTrend AS (     SELECT CollectionTime, RainfallMm,      AVG(RainfallMm) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgRainfall, MovingAvg  FROM RainfallStats, RainfallTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, TemperatureCelsius, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR TemperatureCelsius < -20 OR TemperatureCelsius > 50 THEN 'Likely to cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, TemperatureCelsius, (TemperatureCelsius - (10000 / 10)) AS AdjustedTemperatureCelsius, CASE WHEN RainfallMm >= 10000 OR TemperatureCelsius >= 1000 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and temperature within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR TemperatureCelsius >= 1000;	RainGauge	4
SELECT RainfallMm, HumidityPercent, HumidityPercent + (RainfallMm / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH HumidityStats AS (     SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints      FROM RainfallData ),  HumidityTrend AS (     SELECT CollectionTime, HumidityPercent,             AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgHumidity, MovingAvg  FROM HumidityStats, HumidityTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, HumidityPercent, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN 'May trigger equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, (HumidityPercent + (10000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallMm >= 10000 OR HumidityPercent >= 200 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and humidity within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR HumidityPercent >= 200;	RainGauge	4
SELECT RainfallMm, WindSpeedMps, WindSpeedMps + (RainfallMm / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH WindSpeedStats AS (   SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints    FROM RainfallData ),  WindSpeedTrend AS (   SELECT CollectionTime, WindSpeedMps,           AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg    FROM RainfallData )  SELECT AvgWindSpeed, MovingAvg  FROM WindSpeedStats, WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, WindSpeedMps, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN 'May cause equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (10000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallMm >= 10000 OR WindSpeedMps >= 100 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and wind speed within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindSpeedMps >= 100;	RainGauge	4
SELECT RainfallMm, WindDirectionDegrees, WindDirectionDegrees + (RainfallMm / 10) AS AdjustedWindDirection FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH RainfallTotal AS (   SELECT SUM(RainfallMm) AS TotalRainfall    FROM RainfallData ),  RainfallTrend AS (   SELECT      CollectionTime,      RainfallMm,      SUM(RainfallMm) OVER (ORDER BY CollectionTime ROWS UNBOUNDED PRECEDING) AS CumulativeRainfall    FROM RainfallData )  SELECT TotalRainfall, CumulativeRainfall  FROM RainfallTotal, RainfallTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, WindDirectionDegrees, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN 'May trigger equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindDirectionDegrees, (WindDirectionDegrees + (10000 / 10)) AS AdjustedWindDirectionDegrees, CASE WHEN RainfallMm >= 10000 OR WindDirectionDegrees >= 720 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and wind direction within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindDirectionDegrees >= 720;	RainGauge	4
SELECT RainfallMm, AtmosphericPressureHpa, AtmosphericPressureHpa - (RainfallMm / 10) AS AdjustedPressure FROM RainfallData WHERE GaugeId = 'specific rain gauge ID';	RainGauge	1
WITH PressureStats AS (     SELECT AVG(AtmosphericPressureHpa) AS AvgPressure, COUNT(*) AS DataPoints      FROM RainfallData ),  PressureTrend AS (     SELECT CollectionTime, AtmosphericPressureHpa,             AVG(AtmosphericPressureHpa) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgPressure, MovingAvg  FROM PressureStats, PressureTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN 'Likely to cause equipment failure' ELSE 'Equipment operating normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa - (10000.0 / 10.0)) AS AdjustedAtmosphericPressureHpa, CASE WHEN RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall and atmospheric pressure within normal range' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000;	RainGauge	4
SELECT RainfallIntensityMmH, HumidityPercent, HumidityPercent + (RainfallIntensityMmH / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '2';	RainGauge	1
WITH HumidityStats AS (     SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints      FROM RainfallData ),  HumidityTrend AS (     SELECT CollectionTime, HumidityPercent,             AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg      FROM RainfallData )  SELECT AvgHumidity, MovingAvg  FROM HumidityStats, HumidityTrend;	RainGauge	2
SELECT CollectionTime, RainfallIntensityMmH, HumidityPercent, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN 'May trigger equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, (HumidityPercent + (1000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall intensity and humidity within normal range' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200;	RainGauge	4
SELECT RainfallIntensityMmH, WindSpeedMps, WindSpeedMps + (RainfallIntensityMmH / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '2';	RainGauge	1
WITH WindSpeedStats AS          (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints           FROM RainfallData),      WindSpeedTrend AS          (SELECT CollectionTime,                  WindSpeedMps,                  AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg           FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats,      WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, RainfallIntensityMmH, WindSpeedMps, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN 'May cause equipment failure' ELSE 'Equipment running normally' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (1000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100 THEN 'May cause equipment damage or data distortion' ELSE 'Rainfall intensity and wind speed within normal range' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100;	RainGauge	4
SELECT RainfallMm, RainfallIntensityMmH, ThresholdValue FROM RainfallData JOIN RainfallWarningRule ON RainfallData.GaugeId = '3' AND RainfallWarningRule.ParameterType = 'Rainfall' WHERE RainfallMm > ThresholdValue AND RainfallIntensityMmH = 100;	RainGauge	1
WITH RainfallData AS (     SELECT 50 AS RainfallMm     UNION ALL SELECT 60     UNION ALL SELECT 70     UNION ALL SELECT 80     UNION ALL SELECT 90 ) SELECT AVG(RainfallMm) AS AvgRainfallIntensity, SUM(RainfallMm) AS TotalRainfall FROM RainfallData;	RainGauge	2
SELECT InstallationLocation, ElevationMeters, (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) AS AvgAnnualRainfall, CASE WHEN ElevationMeters = 1000 AND (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) >= 1500 THEN 'Suitable for long-term monitoring' ELSE 'Not suitable for long-term monitoring' END AS Suitability FROM RainGauge WHERE ElevationMeters = 1000;	RainGauge	3
SELECT RuleName, ThresholdValue, CASE WHEN 1000 > ThresholdValue THEN 'Threshold cannot effectively determine, need to adjust warning rules' ELSE 'Threshold can still effectively determine' END AS WarningEffectiveness FROM RainfallWarningRule WHERE ParameterType = 'Rainfall intensity' AND IsActive = 1;	RainGauge	4
SELECT id, model, brand, power_rating, voltage_rating, (power_rating / voltage_rating) AS current_strength FROM rice_cooker_info;	rice_cooker	1
WITH avg_energy_consumption AS (     SELECT rice_cooker_id, AVG(energy_consumption) AS avg_energy      FROM performance_tests      GROUP BY rice_cooker_id )  SELECT rci.model, aec.avg_energy  FROM rice_cooker_info rci  JOIN avg_energy_consumption aec ON rci.id = aec.rice_cooker_id  ORDER BY aec.avg_energy ASC  LIMIT 1;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, rci.capacity, ur.rice_quantity, ur.water_quantity, (ur.rice_quantity + ur.water_quantity) AS total_quantity, CASE WHEN (ur.rice_quantity + ur.water_quantity) <= rci.capacity THEN 'No' ELSE 'Yes' END AS exceeded_capacity FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	3
SELECT model, (10 * power_rating * 24) / 1000000 AS daily_energy_mwh FROM rice_cooker_info WHERE (10 * power_rating * 24) / 1000000 > 1;	rice_cooker	4
WITH energy_efficiency AS (     SELECT          rci.model,          pt.time_to_boil,          (pt.water_evaporation_rate / 100.0 * 1.5) AS water_quantity,          ((pt.water_evaporation_rate / 100.0 * 1.5 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000.0) / (rci.power_rating * pt.time_to_boil / 60.0)) * 100.0 AS efficiency      FROM          performance_tests pt      JOIN          rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE          pt.test_type = 'Boiling' )  SELECT      model,      efficiency  FROM      energy_efficiency  WHERE      efficiency < 60.0      AND time_to_boil > 15  ORDER BY      efficiency ASC;	rice_cooker	1
WITH usage_counts AS (     SELECT rice_cooker_id, COUNT(id) AS total_usage      FROM usage_records      GROUP BY rice_cooker_id ),  maintenance_costs AS (     SELECT rice_cooker_id, SUM(maintenance_cost) AS total_cost      FROM maintenance_records      GROUP BY rice_cooker_id ),  cost_benefit AS (     SELECT          rci.model,          uc.total_usage,          mc.total_cost,          CASE WHEN mc.total_cost = 0 THEN NULL ELSE CAST(uc.total_usage AS REAL) / mc.total_cost END AS cost_benefit_ratio      FROM rice_cooker_info rci      JOIN usage_counts uc ON rci.id = uc.rice_cooker_id      JOIN maintenance_costs mc ON rci.id = mc.rice_cooker_id ),  percentile_rank AS (     SELECT          *,          CAST((SELECT COUNT(*) FROM cost_benefit cb2 WHERE cb2.cost_benefit_ratio >= cb1.cost_benefit_ratio) * 100.0 / (SELECT COUNT(*) FROM cost_benefit) AS INTEGER) AS percentile_rank      FROM cost_benefit cb1 ) SELECT model, total_usage, total_cost, cost_benefit_ratio  FROM percentile_rank  WHERE percentile_rank <= 50;	rice_cooker	2
WITH defect_models AS (     SELECT rice_cooker_id      FROM performance_tests      WHERE final_temperature < 0.9 * 100      AND rice_quality_score < 8      GROUP BY rice_cooker_id      HAVING COUNT(*) >= 3 ),  repaired_models AS (     SELECT DISTINCT rice_cooker_id      FROM maintenance_records      WHERE maintenance_type = 'Repair' )  SELECT rci.model  FROM defect_models dm  JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id  WHERE dm.rice_cooker_id NOT IN (     SELECT rice_cooker_id      FROM repaired_models );	rice_cooker	3
SELECT model, power_rating, CASE WHEN power_rating > (50 * 0.12 * 150) THEN (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 ELSE NULL END AS boil_time_hours FROM rice_cooker_info WHERE (power_rating - (50 * 0.12 * 150)) > 0 AND (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 > 24;	rice_cooker	4
SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;	rice_cooker	1
SELECT brand, ROUND((total_incidents * 5.0 / observation_years / 100 * 100), 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;	rice_cooker	2
WITH defect_models AS (     SELECT pt.rice_cooker_id     FROM performance_tests pt     WHERE pt.water_evaporation_rate > 15 AND pt.rice_quality_score < 8 ) SELECT      rci.model,      rci.production_date,      CASE          WHEN date(rci.production_date, '+' || rci.warranty_period || ' months') > '2023-12-01' THEN 'In Warranty'          ELSE 'Out of Warranty'      END AS warranty_status FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;	rice_cooker	4
SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;	rice_cooker	1
SELECT brand, ROUND((total_incidents * 5.0 / observation_years) * 100.0, 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;	rice_cooker	2
WITH defect_models AS (     SELECT pt.rice_cooker_id      FROM performance_tests pt      WHERE pt.water_evaporation_rate > 15      AND pt.rice_quality_score < 8 )  SELECT rci.model, rci.production_date,         CASE             WHEN date(rci.production_date, '+' || rci.warranty_period || ' months') > '2023-12-01'             THEN 'In Warranty'             ELSE 'Out of Warranty'         END AS warranty_status  FROM defect_models dm  JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;	rice_cooker	4
WITH heat_efficiency AS (     SELECT          rci.model,          2 AS water_quantity,          pt.final_temperature,          pt.initial_temperature,          pt.energy_consumption,          pt.water_evaporation_rate,          (2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption * 100 AS efficiency      FROM performance_tests pt      JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE pt.test_type = 'Boiling' ) SELECT model, efficiency  FROM heat_efficiency  WHERE efficiency < 65 AND water_evaporation_rate > 10  ORDER BY efficiency ASC;	rice_cooker	1
WITH maintenance_summary AS (     SELECT          rci.id,          rci.model,          rci.production_date,          SUM(mr.maintenance_cost) AS total_cost,          MAX(mr.maintenance_date) AS last_maintenance_date      FROM rice_cooker_info rci      JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id      GROUP BY rci.id, rci.model, rci.production_date      HAVING last_maintenance_date IS NOT NULL ) SELECT      model,      total_cost,      ROUND((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0, 1) AS service_months,      ROUND(total_cost / ((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0), 2) AS cost_rate  FROM maintenance_summary  WHERE ((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0) > 12      AND (total_cost / ((JULIANDAY(last_maintenance_date) - JULIANDAY(production_date)) / 30.0)) > 5  ORDER BY cost_rate DESC  LIMIT 3;	rice_cooker	2
WITH qualified_models AS (     SELECT rci.id, rci.brand, rci.model      FROM rice_cooker_info rci      WHERE rci.capacity < 4      AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.rice_quantity >= 1.5)      AND NOT EXISTS (SELECT 1 FROM usage_records ur2 WHERE ur2.rice_cooker_id = rci.id AND ur2.rice_quantity >= 1.5 AND ur2.water_quantity < 2.25) ) SELECT qm.brand, qm.model, MAX(ur.end_time) AS last_usage_date  FROM qualified_models qm  JOIN usage_records ur ON qm.id = ur.rice_cooker_id  GROUP BY qm.brand, qm.model;	rice_cooker	3
SELECT (2 * (4186 * (100 - 20) + 2260000)) / (0.5 * 700 * 0.1) AS total_seconds, ROUND((2 * (4186 * 80 + 2260000)) / (0.5 * 700 * 0.1) / 3600.0, 1) AS hours;	rice_cooker	4
WITH efficiency_calc AS (     SELECT          rci.model,          pt.initial_temperature,          pt.energy_consumption,          pt.time_to_boil,          pt.water_evaporation_rate,          (2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) AS eta_max,          pt.energy_consumption AS eta_real,          ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) - pt.energy_consumption) / ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000)) * 100 AS deviation      FROM          performance_tests pt      JOIN          rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE          pt.test_type = 'Boiling' ) SELECT      model,      deviation,      water_evaporation_rate  FROM      efficiency_calc  WHERE      deviation > 15      AND water_evaporation_rate > 12  ORDER BY      deviation DESC;	rice_cooker	1
WITH model_maintenance AS (   SELECT rci.brand, rci.model, COUNT(*) AS maintenance_count    FROM maintenance_records mr    JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id    GROUP BY rci.brand, rci.model ),  brand_recurrence AS (   SELECT brand,           CAST(SUM(CASE WHEN maintenance_count > 1 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS recurrence_rate,           SUM(maintenance_count) AS total_maintenance    FROM model_maintenance    GROUP BY brand    HAVING SUM(maintenance_count) >= 2 )  SELECT brand,         ROUND(recurrence_rate * 100, 2) AS recurrence_rate_percent,         total_maintenance  FROM brand_recurrence  WHERE recurrence_rate > 0.3  ORDER BY recurrence_rate DESC  LIMIT 3;	rice_cooker	2
WITH qualified_models AS (     SELECT rci.id, rci.model      FROM rice_cooker_info rci      WHERE rci.capacity >= 5      AND EXISTS (         SELECT 1          FROM usage_records ur          WHERE ur.rice_cooker_id = rci.id          AND ur.rice_quantity < 0.5     ) ), recent_scores AS (     SELECT qm.model, pt.rice_quality_score,             ROW_NUMBER() OVER (PARTITION BY qm.id ORDER BY pt.test_date DESC) AS rn      FROM qualified_models qm      JOIN performance_tests pt ON qm.id = pt.rice_cooker_id ) SELECT model, ROUND(AVG(rice_quality_score), 2) AS avg_rice_quality  FROM recent_scores  WHERE rn <= 3  GROUP BY model;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 0.08 * 0.2 * POWER(280 - 2, 4) AS max_heat_loss), boil_time_calc AS (SELECT (3 * 4186 * (280 - 5)) / (1.5 * 900 - (SELECT max_heat_loss FROM heat_loss_calc)) / 3600 AS boil_time_hours) SELECT boil_time_hours FROM boil_time_calc;	rice_cooker	4
WITH efficiency_calc AS (     SELECT          rci.model,          pt.final_temperature,          pt.initial_temperature,          pt.energy_consumption,          pt.water_evaporation_rate,          (2.0 * 4186.0 * (pt.final_temperature - pt.initial_temperature) / 3600000.0) / pt.energy_consumption AS eta_actual,          1.0 - (298.15 / (pt.final_temperature + 273.15)) AS eta_theoretical,          (((2.0 * 4186.0 * (pt.final_temperature - pt.initial_temperature) / 3600000.0) / pt.energy_consumption) - (1.0 - (298.15 / (pt.final_temperature + 273.15)))) * 100.0 AS efficiency_diff      FROM          performance_tests pt      JOIN          rice_cooker_info rci ON pt.rice_cooker_id = rci.id      WHERE          pt.test_type = 'Boiling' )  SELECT      model,      efficiency_diff,      water_evaporation_rate  FROM      efficiency_calc  WHERE      efficiency_diff > 10.0      AND water_evaporation_rate > 8.0  ORDER BY      efficiency_diff DESC;	rice_cooker	1
WITH cost_benefit AS (     SELECT          rci.model,          SUM(ur.rice_quantity) AS total_rice,          SUM(pt.energy_consumption) AS total_energy,          COUNT(*) AS usage_count,          SUM(ur.rice_quantity) / SUM(pt.energy_consumption) AS benefit_ratio      FROM usage_records ur      JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id      JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id      GROUP BY rci.model      HAVING COUNT(*) > 5 )  SELECT model, ROUND(benefit_ratio, 2) AS benefit_ratio  FROM cost_benefit  WHERE benefit_ratio < 0.8  ORDER BY benefit_ratio ASC  LIMIT 2;	rice_cooker	2
WITH repaired_in_warranty AS (     SELECT          rci.id,          rci.model,          mr.technician_name,          date(rci.production_date, '+' || rci.warranty_period || ' months') AS warranty_end_date,          mr.maintenance_date      FROM          maintenance_records mr      JOIN          rice_cooker_info rci ON mr.rice_cooker_id = rci.id      WHERE          mr.maintenance_type = 'Repair'          AND mr.maintenance_date <= date(rci.production_date, '+' || rci.warranty_period || ' months') ),  last_usage AS (     SELECT          ur.rice_cooker_id,          MAX(ur.end_time) AS last_usage_date      FROM          usage_records ur      GROUP BY          ur.rice_cooker_id )  SELECT      riw.model,      riw.technician_name,      lu.last_usage_date  FROM      repaired_in_warranty riw  JOIN      last_usage lu ON riw.id = lu.rice_cooker_id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 0.2 * 0.3 AS heat_loss_coeff),  boil_time_calc AS (SELECT (5 * (4186 * (500 - 300) + 2260000 * (1 + 400/500))) / (5 * 800 - (SELECT heat_loss_coeff * (POWER(500,4) - POWER(300,4)) FROM heat_loss_calc)) / 3600 AS boil_time_hours)  SELECT boil_time_hours FROM boil_time_calc;	rice_cooker	4
SELECT rci.model,         ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 AS thermal_efficiency  FROM performance_tests pt  JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id  JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id AND date(pt.test_date) = date(ur.start_time)  WHERE pt.test_type = 'Boiling'  AND pt.time_to_boil > 18  AND ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 < 50  ORDER BY thermal_efficiency ASC;	rice_cooker	1
SELECT rci.brand,         (JULIANDAY(MAX(ur.end_time)) - JULIANDAY(MIN(rci.production_date))) / 30 AS total_service_months,         COUNT(DISTINCT mr.maintenance_date) AS total_faults,         ((JULIANDAY(MAX(ur.end_time)) - JULIANDAY(MIN(rci.production_date))) / 30) / COUNT(DISTINCT mr.maintenance_date) AS fault_interval  FROM rice_cooker_info rci  LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id  LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id  GROUP BY rci.brand  HAVING total_faults > 0  ORDER BY fault_interval ASC  LIMIT 3;	rice_cooker	2
SELECT rci.model, COUNT(mr.id) AS maintenance_count,         (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id = rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_maintenance_type  FROM rice_cooker_info rci  LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id  WHERE rci.capacity > 4    AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.water_quantity < 1)  GROUP BY rci.id;	rice_cooker	3
WITH RECURSIVE heating_time AS (     SELECT 300 AS start_temp,             300 + 50 AS end_temp,             CAST(0.0 AS REAL) AS elapsed_time      UNION ALL      SELECT end_temp,             MIN(end_temp + CASE WHEN end_temp < 4000 THEN 50 WHEN end_temp < 4900 THEN 10 ELSE 1 END, 5000),             CAST(elapsed_time AS REAL) + CAST( (10 * 4186 * (end_temp - start_temp)) / MAX(7000 - 10 * POWER((start_temp + end_temp)/2 - 5000, 3), 1) AS REAL)      FROM heating_time      WHERE end_temp < 5000  )  SELECT MAX(elapsed_time) AS total_seconds  FROM heating_time;	rice_cooker	4
SELECT rci.model, ROUND(((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature)) / (pt.time_to_boil * 60 * rci.power_rating)) * 100, 2) AS efficiency_rate FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE (ur.temperature_setting - ur.actual_max_temperature) > 5 GROUP BY rci.model HAVING efficiency_rate < 40 ORDER BY efficiency_rate ASC;	rice_cooker	1
SELECT rci.brand, ROUND(SUM(COALESCE(pt.energy_consumption,0)+COALESCE(ur.energy_consumption,0))*0.6/MAX(JULIANDAY(MAX(ur.end_time))-JULIANDAY(MIN(ur.start_time)),1),2) AS daily_cost FROM rice_cooker_info rci LEFT JOIN performance_tests pt ON rci.id=pt.rice_cooker_id LEFT JOIN usage_records ur ON rci.id=ur.rice_cooker_id GROUP BY rci.brand HAVING daily_cost>2 AND MAX(JULIANDAY(ur.end_time))-JULIANDAY(MIN(ur.start_time))>30 ORDER BY daily_cost DESC LIMIT 2;	rice_cooker	2
SELECT rci.model,         (SELECT MAX(maintenance_date) FROM maintenance_records WHERE rice_cooker_id=rci.id) AS last_date,         (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id=rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_type  FROM rice_cooker_info rci  WHERE warranty_period > 18  AND (julianday('now') - julianday(production_date)) / 365.25 > 3  AND EXISTS (SELECT 1 FROM maintenance_records WHERE rice_cooker_id=rci.id);	rice_cooker	3
WITH RECURSIVE heating_sim(current_temp, elapsed_time) AS (     SELECT -273.0, 0.0     UNION ALL     SELECT          MIN(current_temp + CASE              WHEN current_temp < -173 THEN 10              WHEN current_temp < 0 THEN 1              ELSE 0.1          END, 100.0),         elapsed_time + (10 * 4186 * CASE              WHEN current_temp < -173 THEN 10              WHEN current_temp < 0 THEN 1              ELSE 0.1          END) / MAX(2700 - 0.5 * (current_temp + 273.0) * (current_temp + 273.0) * (current_temp + 273.0) * (current_temp + 273.0), 1)     FROM heating_sim      WHERE current_temp < 100 )  SELECT      MAX(elapsed_time) AS total_seconds,      MAX(elapsed_time) / 3600.0 AS total_hours  FROM heating_sim;	rice_cooker	4
SELECT ur.rice_cooker_id, rci.model, ur.rice_quantity, ur.water_quantity, ur.energy_consumption AS E_actual, (ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600 AS E_theory, ((ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600) / ur.energy_consumption * 100 AS efficiency_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	1
WITH RECURSIVE heating_sim AS (     SELECT -273.0 AS current_temp, 0.0 AS elapsed_time     UNION ALL     SELECT MIN(current_temp + CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END, 100),             elapsed_time + (10*4186*(CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END)) / MAX(2700 - 0.5*POWER((current_temp + 273),4), 1)     FROM heating_sim     WHERE current_temp < 100 ) SELECT MAX(elapsed_time) AS total_seconds, MAX(elapsed_time)/3600 AS total_hours FROM heating_sim;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.temperature_setting, ur.actual_max_temperature, ABS(ur.actual_max_temperature - ur.temperature_setting) AS temperature_deviation, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Heating%') THEN 'Heating element replaced' ELSE 'Heating element not replaced' END AS heating_element_status FROM usage_records ur WHERE ABS(ur.actual_max_temperature - ur.temperature_setting) > 5;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.time_to_boil * (373.0 / 344.0) AS mount_everest_time, (pt.time_to_boil * (373.0 / 344.0)) / pt.time_to_boil - 1.0 AS time_increase_ratio, pt.energy_consumption * (373.0 / 344.0 - 1.0) AS energy_loss FROM performance_tests pt	rice_cooker	4
SELECT rci.id AS rice_cooker_id, rci.model, rci.material, rci.power_rating, ur.temperature_setting, ur.actual_max_temperature, CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END AS k, (CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002 AS ΔQ, ((CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002) / rci.power_rating * 100 AS heat_loss_rate_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	1
WITH MaintenanceAnalysis AS (     SELECT          rci.model,          strftime('%Y', mr.maintenance_date) AS year,          rci.warranty_period,          AVG(pt.rice_quality_score) AS avg_quality_score,          SUM(mr.maintenance_cost) AS total_maintenance_cost,          COUNT(ur.id) AS usage_count      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id      LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id      LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id      GROUP BY rci.model, strftime('%Y', mr.maintenance_date), rci.warranty_period ) SELECT      model,      year,      (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) AS cost_benefit_ratio,      RANK() OVER (PARTITION BY year ORDER BY (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) DESC) AS annual_rank  FROM MaintenanceAnalysis;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.energy_consumption, ur.rice_quantity, ur.energy_consumption / ur.rice_quantity AS energy_per_kg, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN 'Rice quality below average' ELSE 'Rice quality normal' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.energy_consumption / ur.rice_quantity > 0.8;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.time_to_boil AS earth_time,         SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) AS v_earth,         SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) AS v_space,         pt.time_to_boil * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01))) AS space_time,         (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) * 100 AS time_increase_percent,         pt.energy_consumption * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) AS energy_loss  FROM performance_tests pt;	rice_cooker	4
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373.0 / 363.0 - 1) AS energy_increase, (373.0 / 363.0 - 1) * 100.0 AS efficiency_loss_percent FROM performance_tests pt;	rice_cooker	1
WITH MaintenanceAnalysis AS (     SELECT          rci.brand,          CAST(strftime('%m', mr.maintenance_date) AS INTEGER) / 3 + 1 AS quarter,          CAST(COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) AS REAL) / COUNT(*) AS failure_rate,          SUM(mr.maintenance_cost) / COUNT(*) AS avg_maintenance_cost      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id      GROUP BY rci.brand, quarter ), CorrelationCalculation AS (     SELECT          brand,          quarter,          failure_rate,          avg_maintenance_cost,          AVG(failure_rate) OVER(PARTITION BY brand) AS mean_failure_rate,          AVG(avg_maintenance_cost) OVER(PARTITION BY brand) AS mean_avg_maintenance_cost,          (failure_rate - AVG(failure_rate) OVER(PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand)) AS covariance_term,          POWER(failure_rate - AVG(failure_rate) OVER(PARTITION BY brand), 2) AS variance_failure_rate,          POWER(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand), 2) AS variance_avg_maintenance_cost      FROM MaintenanceAnalysis ) SELECT      brand,      quarter,      failure_rate,      avg_maintenance_cost,      SUM(covariance_term) OVER(PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER(PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER(PARTITION BY brand))) AS correlation_coefficient  FROM CorrelationCalculation  GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN 'Rice quality below average' ELSE 'Rice quality normal' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt;	rice_cooker	4
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373.0 / 363.0 - 1) AS energy_increase, (373.0 / 363.0 - 1) * 100 AS efficiency_loss_percent FROM performance_tests pt;	rice_cooker	1
WITH MaintenanceAnalysis AS (     SELECT          rci.brand,          CAST((STRFTIME('%m', mr.maintenance_date) + 2) / 3 AS INTEGER) AS quarter,          CAST(COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) AS REAL) / COUNT(*) AS failure_rate,          CAST(SUM(mr.maintenance_cost) AS REAL) / COUNT(*) AS avg_maintenance_cost      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id      GROUP BY rci.brand, quarter ), CorrelationCalculation AS (     SELECT          brand,          quarter,          failure_rate,          avg_maintenance_cost,          AVG(failure_rate) OVER (PARTITION BY brand) AS mean_failure_rate,          AVG(avg_maintenance_cost) OVER (PARTITION BY brand) AS mean_avg_maintenance_cost,          (failure_rate - AVG(failure_rate) OVER (PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER (PARTITION BY brand)) AS covariance_term,          POW(failure_rate - AVG(failure_rate) OVER (PARTITION BY brand), 2) AS variance_failure_rate,          POW(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER (PARTITION BY brand), 2) AS variance_avg_maintenance_cost      FROM MaintenanceAnalysis ) SELECT      brand,      quarter,      failure_rate,      avg_maintenance_cost,      SUM(covariance_term) OVER (PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER (PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER (PARTITION BY brand))) AS correlation_coefficient  FROM CorrelationCalculation  GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN 'Rice quality below average' ELSE 'Rice quality normal' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8;	rice_cooker	3
SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt;	rice_cooker	4
SELECT rci.id AS rice_cooker_id, rci.model, rci.material, pt.final_temperature, CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END AS thermal_stress, CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END AS tensile_strength, CASE WHEN CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END < CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END THEN 'Safe' ELSE 'Unsafe' END AS safety_status FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id;	rice_cooker	1
WITH LifecycleCost AS (     SELECT          rci.brand,          rci.price + SUM(mr.maintenance_cost) AS total_cost,          COUNT(ur.id) AS usage_count,          AVG(pt.rice_quality_score) AS avg_quality_score      FROM rice_cooker_info rci      LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id      LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id      LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id      GROUP BY rci.brand, rci.price ), MinMax AS (     SELECT          MIN(total_cost / POWER(usage_count * avg_quality_score, 0.5)) AS min_cost,         MAX(total_cost / POWER(usage_count * avg_quality_score, 0.5)) AS max_cost     FROM LifecycleCost ), NormalizedCost AS (     SELECT          brand,          total_cost / POWER(usage_count * avg_quality_score, 0.5) AS lifecycle_cost,         (total_cost / POWER(usage_count * avg_quality_score, 0.5) - (SELECT min_cost FROM MinMax)) /          ((SELECT max_cost FROM MinMax) - (SELECT min_cost FROM MinMax)) AS normalized_cost     FROM LifecycleCost ) SELECT      brand,      lifecycle_cost,      normalized_cost,     (SELECT COUNT(DISTINCT nc2.normalized_cost) FROM NormalizedCost nc2 WHERE nc2.normalized_cost <= nc.normalized_cost) AS brand_rank FROM NormalizedCost nc ORDER BY normalized_cost;	rice_cooker	2
WITH CleaningAnalysis AS (     SELECT          mr.rice_cooker_id,          mr.maintenance_date,          mr.maintenance_notes,          rci.material,          CAST(julianday(mr.maintenance_date) - julianday(LAG(mr.maintenance_date) OVER (PARTITION BY mr.rice_cooker_id ORDER BY mr.maintenance_date)) AS INTEGER) AS cleaning_interval      FROM maintenance_records mr      JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id ) SELECT      rice_cooker_id,      maintenance_date,      maintenance_notes,      material,      cleaning_interval,      CASE          WHEN cleaning_interval > 90 THEN 'Cleaning interval exceeds 3 months'          WHEN maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic') THEN 'Acidic cleaning agent used'          ELSE 'Compliant with standards'      END AS violation_status  FROM CleaningAnalysis  WHERE cleaning_interval > 90 OR (maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic'));	rice_cooker	3
SELECT pt.rice_cooker_id, pt.final_temperature, (1.05e-34) / (2 * 9.1e-31 * POWER(1e-8, 2) * 1.38e-23 * 1e-6) AS "ΔT", (1.05e-34) / (2 * 9.1e-31 * POWER(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature AS temperature_oscillation_rate, pt.energy_consumption * ((1.05e-34) / (2 * 9.1e-31 * POWER(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature) AS energy_fluctuation FROM performance_tests pt;	rice_cooker	4
SELECT ur.rice_cooker_id, rci.power_rating, rci.voltage_rating, ur.energy_consumption, ur.duration, 230 AS V_supply, rci.power_rating * (POWER(230, 2) / POWER(rci.voltage_rating, 2)) AS P_actual, (ur.energy_consumption * 1000 / (rci.power_rating * (POWER(230, 2) / POWER(rci.voltage_rating, 2)) * ur.duration / 60)) * POWER(rci.voltage_rating / 230, 2) AS η_corrected FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	1
WITH QualityDecay AS (     SELECT          rci.model,          CAST(strftime('%Y', pt.test_date) AS INTEGER) AS year,          pt.rice_quality_score,          MAX(pt.rice_quality_score) OVER(PARTITION BY rci.model) - pt.rice_quality_score AS quality_decay,          SUM(COALESCE(mr.maintenance_cost, 0)) OVER(PARTITION BY rci.model ORDER BY pt.test_date) AS cumulative_maintenance_cost,          COUNT(ur.id) OVER(PARTITION BY rci.model) AS usage_count      FROM performance_tests pt      JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id      LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id      LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id )  SELECT      model,      year,      rice_quality_score,      (LN(usage_count) * quality_decay / cumulative_maintenance_cost) AS decay_index,      DENSE_RANK() OVER(PARTITION BY year ORDER BY (LN(usage_count) * quality_decay / cumulative_maintenance_cost) DESC) AS annual_rank  FROM QualityDecay;	rice_cooker	2
WITH temp_voltage_logs AS (     SELECT          ur.id AS usage_id,          200 + ABS(RANDOM()) % 40 * 1.0 AS supply_voltage      FROM usage_records ur ), VoltageLog AS (     SELECT          ur.rice_cooker_id,          ur.id AS usage_id,          vl.supply_voltage,          rci.voltage_rating,          CASE              WHEN vl.supply_voltage < 0.9 * rci.voltage_rating OR vl.supply_voltage > 1.1 * rci.voltage_rating THEN 'Voltage anomaly'              ELSE 'Voltage normal'          END AS voltage_status,          CASE              WHEN EXISTS (                 SELECT 1                  FROM maintenance_records mr                  WHERE mr.rice_cooker_id = ur.rice_cooker_id                  AND mr.replaced_parts LIKE '%Power%'             ) THEN 'Power module replaced'              ELSE 'Power module not replaced'          END AS power_module_status      FROM usage_records ur      JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id      JOIN temp_voltage_logs vl ON ur.id = vl.usage_id )  SELECT      rice_cooker_id,      usage_id,      supply_voltage,      voltage_rating,      voltage_status,      power_module_status  FROM VoltageLog  WHERE voltage_status = 'Voltage anomaly';	rice_cooker	3
SELECT pt.rice_cooker_id, pt.rice_quality_score, pt.energy_consumption, EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS curvature_factor, pt.rice_quality_score * (1 - EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)))) AS quality_distortion, pt.energy_consumption / EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS energy_distortion FROM performance_tests pt;	rice_cooker	4
WITH EnergyAnalysis AS (     SELECT          ur.id AS usage_id,         ur.rice_cooker_id,         ur.water_quantity,         ur.energy_consumption AS E_actual,         pt.water_evaporation_rate,         -- Calculate energy saving benefit: ΔE = (water_quantity × water_evaporation_rate% × η × L)/3600         (ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600 AS delta_E,         -- Calculate potential energy consumption after recovery         ur.energy_consumption - ((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) AS potential_E,         -- Calculate energy saving percentage         (((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) / ur.energy_consumption) * 100 AS energy_saving_percentage,         CASE              WHEN (((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) / ur.energy_consumption) * 100 > 10              THEN 'High energy saving potential'             WHEN (((ur.water_quantity * (pt.water_evaporation_rate / 100.0) * 0.6 * 2260) / 3600) / ur.energy_consumption) * 100 > 5              THEN 'Medium energy saving potential'              ELSE 'Low energy saving potential'         END AS saving_potential     FROM usage_records ur     JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id     WHERE pt.water_evaporation_rate IS NOT NULL        AND ur.water_quantity > 0       AND ur.energy_consumption > 0 ) SELECT      usage_id,     rice_cooker_id,     water_quantity,     water_evaporation_rate,     ROUND(E_actual, 3) AS actual_energy_consumption,     ROUND(delta_E, 3) AS energy_saving_benefit,     ROUND(potential_E, 3) AS potential_energy_consumption,     ROUND(energy_saving_percentage, 2) AS energy_saving_percentage,     saving_potential FROM EnergyAnalysis ORDER BY energy_saving_percentage DESC;	rice_cooker	1
SELECT      rci.brand,     SUM(         0.4 * ((pt.rice_quality_score - min_rq.min_rq) / (max_rq.max_rq - min_rq.min_rq)) +         0.3 * ((avg_ec.avg_ec / avg_rq.avg_rq) - min_er.min_er) / (max_er.max_er - min_er.min_er) +         0.2 * ((COUNT(mr.id) / COUNT(ur.id)) - min_mf.min_mf) / (max_mf.max_mf - min_mf.min_mf) +         0.1 * (1 - ((rci.price - min_p.min_p) / (max_p.max_p - min_p.min_p)))     ) AS comprehensive_score FROM rice_cooker_info rci LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id CROSS JOIN (SELECT MIN(rice_quality_score) AS min_rq, MAX(rice_quality_score) AS max_rq FROM performance_tests) min_rq CROSS JOIN (SELECT AVG(energy_consumption) AS avg_ec FROM performance_tests) avg_ec CROSS JOIN (SELECT AVG(rice_quantity) AS avg_rq FROM usage_records) avg_rq CROSS JOIN (SELECT MIN(avg_ec / avg_rq) AS min_er, MAX(avg_ec / avg_rq) AS max_er FROM      (SELECT rice_cooker_id, AVG(energy_consumption) AS avg_ec, AVG(rice_quantity) AS avg_rq       FROM performance_tests pt      JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id      GROUP BY rice_cooker_id)) min_max_er CROSS JOIN (SELECT MIN(COUNT(mr.id) / COUNT(ur.id)) AS min_mf, MAX(COUNT(mr.id) / COUNT(ur.id)) AS max_mf FROM      rice_cooker_info rci     LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id     LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id     GROUP BY rci.id) min_max_mf CROSS JOIN (SELECT MIN(price) AS min_p, MAX(price) AS max_p FROM rice_cooker_info) min_p GROUP BY rci.brand ORDER BY comprehensive_score DESC;	rice_cooker	2
SELECT      pt.*,      (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) AS temperature_rise_rate,      CASE          WHEN EXISTS (             SELECT 1              FROM maintenance_records mr              WHERE mr.rice_cooker_id = pt.rice_cooker_id              AND mr.replaced_parts LIKE '%Thermistor%'         ) THEN 'Maintained'          ELSE 'Not maintained'      END AS maintenance_status  FROM performance_tests pt  JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id  WHERE (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) > 0.33  AND ABS(ur.actual_max_temperature - ur.temperature_setting) > 5;	rice_cooker	3
SELECT rci.id AS rice_cooker_id, rci.model, rci.weight, ur.duration AS heating_time, (rci.weight * ur.duration * 60) AS black_hole_mass, (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)) AS schwarzschild_radius, SQRT(1 - (2 * 6.67430e-11 * (rci.weight * ur.duration * 60)) / (POWER(299792458, 2) * (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)))) AS time_dilation_factor, (1.0545718e-34 * POWER(299792458, 3)) / (8 * 3.141592653589793 * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) AS hawking_temperature, (1.0545718e-34 * POWER(299792458, 3)) / (8 * 3.141592653589793 * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) * ur.energy_consumption AS quantum_energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE ur.temperature_setting >= 1.4e32;	rice_cooker	4
SELECT      rci.material,      AVG(ur.actual_max_temperature - ur.temperature_setting) / AVG(ur.duration) AS average_temperature_rise_rate,      AVG(rci.capacity * rci.weight) / (AVG(rci.power_rating) * 1000) AS thermal_conduction_time_constant  FROM rice_cooker_info rci  JOIN usage_records ur ON rci.id = ur.rice_cooker_id  GROUP BY rci.material;	rice_cooker	1
WITH usage_count AS (     SELECT rice_cooker_id, COUNT(*) AS usage_times     FROM usage_records     GROUP BY rice_cooker_id ), maintenance_cost_sum AS (     SELECT rice_cooker_id, SUM(maintenance_cost) AS total_maintenance_cost     FROM maintenance_records     GROUP BY rice_cooker_id ), rice_quality_variation AS (     SELECT rice_cooker_id,             (STDEV(rice_quality_score) / AVG(rice_quality_score)) AS rice_quality_cv     FROM performance_tests     GROUP BY rice_cooker_id ) SELECT      rci.id AS rice_cooker_id,      rci.model,      EXP(-mcs.total_maintenance_cost / rci.price) * (1 + LN(uc.usage_times)) * rqv.rice_quality_cv AS health_index,     CAST((strftime('%m', ur.start_time) - 1) / 3 + 1 AS INTEGER) AS quarter,      strftime('%Y', ur.start_time) AS year FROM rice_cooker_info rci JOIN usage_count uc ON rci.id = uc.rice_cooker_id JOIN maintenance_cost_sum mcs ON rci.id = mcs.rice_cooker_id JOIN rice_quality_variation rqv ON rci.id = rqv.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id GROUP BY rci.id, rci.model, mcs.total_maintenance_cost, rci.price, uc.usage_times, rqv.rice_quality_cv, quarter, year;	rice_cooker	2
WITH usage_sequence AS (     SELECT          rice_cooker_id AS device_id,          start_time,          end_time,          rice_quantity,          (julianday(start_time) - julianday(LAG(end_time) OVER(PARTITION BY rice_cooker_id ORDER BY start_time))) * 1440 AS cooling_interval      FROM usage_records ) SELECT      us.*,      CASE          WHEN EXISTS (             SELECT 1              FROM maintenance_records mr              WHERE mr.rice_cooker_id = us.device_id              AND mr.maintenance_type = 'Overheat Repair'         ) THEN 1          ELSE 0      END AS has_overheat_repair  FROM usage_sequence us  WHERE cooling_interval < 15  AND rice_quantity > 0.5  AND start_time > '2023-01-01';	rice_cooker	3
SELECT rci.model, rci.brand, ur.rice_quantity, ur.water_quantity, pt.water_evaporation_rate, pt.rice_quality_score, pt.energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id JOIN performance_tests pt ON rci.id = pt.rice_cooker_id WHERE pt.test_type = 'cooking rice' AND ur.rice_quantity > 0 AND ur.water_quantity > 0;	rice_cooker	4
SELECT rice_cooker_id, test_date, initial_temperature, final_temperature, energy_consumption, time_to_boil FROM performance_tests WHERE test_type = 'heat preservation';	rice_cooker	1
SELECT rc.model, ur.energy_consumption, ROUND(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12)),4) AS maturation_degree, ur.energy_consumption * (1/(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12))) - 1) AS energy_distortion, SQRT(1.38e-23*2e12/(1.05e-34*3e8)) * ur.duration*60 AS quantum_fluctuation FROM rice_cooker_info rc JOIN usage_records ur ON rc.id = ur.rice_cooker_id WHERE ur.duration > 0;	rice_cooker	2
SELECT rc.model, pt.final_temperature, ur.duration, (pt.final_temperature - 25) AS AS_T, ROUND((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration), 2) AS total_heat_loss_J, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600, 2) AS heat_loss_kWh, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600 / (0.1 * rc.power_rating * ur.duration / 60), 2) AS efficiency_ratio FROM rice_cooker_info rc JOIN performance_tests pt ON rc.id = pt.rice_cooker_id JOIN usage_records ur ON rc.id = ur.rice_cooker_id WHERE ur.rice_quantity > rc.capacity * 1.2;	rice_cooker	3
WITH monthly_data AS (     SELECT          rc.brand AS manufacturer,          strftime('%Y-%m', pt.test_date) AS month,          (pt.rice_quality_score - AVG(pt.rice_quality_score) OVER()) / (STDDEV_SAMP(pt.rice_quality_score) OVER()) AS z_score,          1 - (STDDEV_SAMP(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand) / AVG(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand)) AS efficiency_variation,          SUM(mr.maintenance_cost) OVER(PARTITION BY rc.brand) / rc.price AS maintenance_ratio      FROM rice_cooker_info rc      LEFT JOIN usage_records ur ON rc.id = ur.rice_cooker_id      LEFT JOIN maintenance_records mr ON rc.id = mr.rice_cooker_id      JOIN performance_tests pt ON rc.id = pt.rice_cooker_id )  SELECT      manufacturer,      month,      ROUND(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio, 2) AS quality_index,      AVG(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio) OVER(ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS trend  FROM monthly_data  ORDER BY manufacturer, month;	rice_cooker	4
SELECT ul.id AS usage_id, di.model, ul.rice_quantity, di.capacity, ul.rice_quantity / di.capacity AS overload_ratio, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records ml WHERE ml.rice_cooker_id = ul.rice_cooker_id AND ml.maintenance_notes LIKE '%inner pot deformation%') THEN 1 ELSE 0 END AS has_deformation FROM usage_records ul JOIN rice_cooker_info di ON ul.rice_cooker_id = di.id WHERE ul.rice_quantity > 1.2 * di.capacity;	rice_cooker	1
WITH cost_calculation AS (     SELECT          di.brand,         di.price AS initial_price,         mr.maintenance_cost,         mr.maintenance_date,         julianday(mr.maintenance_date) - julianday(di.production_date) AS days_since_production,         (julianday(mr.maintenance_date) - julianday(di.production_date)) / 365.25 AS years_since_production     FROM rice_cooker_info di     JOIN maintenance_records mr ON di.id = mr.rice_cooker_id ), discounted_costs AS (     SELECT          brand,         initial_price,         maintenance_cost,         years_since_production,         maintenance_cost / POWER(1.05, years_since_production) AS discounted_maintenance_cost     FROM cost_calculation ), aggregated_costs AS (     SELECT          brand,         initial_price,         SUM(discounted_maintenance_cost) AS total_discounted_maintenance     FROM discounted_costs     GROUP BY brand, initial_price ), total_present_value AS (     SELECT          brand,         initial_price + total_discounted_maintenance AS present_value     FROM aggregated_costs ) SELECT brand, present_value FROM total_present_value ORDER BY present_value;	rice_cooker	2
SELECT di.model, di.material, pt.time_to_boil AS actual_boil_time_min, ROUND(CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16.0/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END, 2) AS theoretical_diffusion_time_s, ROUND((pt.time_to_boil*60 - CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16.0/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END) / CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16.0/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END *100.0, 1) AS time_deviation_percent FROM rice_cooker_info di JOIN performance_tests pt ON di.id = pt.rice_cooker_id WHERE di.material IN ('Stainless Steel','Ceramic');	rice_cooker	3
WITH RECURSIVE numbers(n) AS (     SELECT 0     UNION ALL     SELECT n+1 FROM numbers WHERE n < 9999 ), lifetime_simulation AS (     SELECT di.id AS device_id,             ABS(RANDOM()) / 18446744073709551615.0 AS rand_value,             EXP(-SUM(0.01 * ul.rice_quantity * (JULIANDAY(ml.maintenance_date) - JULIANDAY(di.production_date)) / 365)) AS survival_probability     FROM numbers      CROSS JOIN rice_cooker_info di      LEFT JOIN maintenance_records ml ON di.id = ml.rice_cooker_id      LEFT JOIN usage_records ul ON di.id = ul.rice_cooker_id      GROUP BY di.id, numbers.n )  SELECT ls.device_id AS id,         AVG(CASE WHEN ls.rand_value > ls.survival_probability THEN (JULIANDAY('now') - JULIANDAY(di.production_date)) / 365 ELSE 999 END) AS simulated_lifetime  FROM lifetime_simulation ls  JOIN rice_cooker_info di ON ls.device_id = di.id  GROUP BY ls.device_id;	rice_cooker	4
SELECT pt.*, rci.power_rating FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE (pt.time_to_boil < 15 OR rci.power_rating > 1000) AND EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = rci.id AND mr.replaced_parts = 'electromagnetic shielding component');	rice_cooker	1
WITH normalized AS (   SELECT      rci.model,     pt.energy_consumption,     pt.time_to_boil,     pt.rice_quality_score,     (pt.energy_consumption - min_energy.min_val) / (max_energy.max_val - min_energy.min_val) AS p_energy,     (pt.time_to_boil - min_time.min_val) / (max_time.max_val - min_time.min_val) AS p_time,     (pt.rice_quality_score - min_quality.min_val) / (max_quality.max_val - min_quality.min_val) AS p_quality   FROM rice_cooker_info rci   JOIN performance_tests pt ON rci.id = pt.rice_cooker_id,   (SELECT MIN(energy_consumption) AS min_val, MAX(energy_consumption) AS max_val FROM performance_tests) AS min_energy,   (SELECT MIN(time_to_boil) AS min_val, MAX(time_to_boil) AS max_val FROM performance_tests) AS min_time,   (SELECT MIN(rice_quality_score) AS min_val, MAX(rice_quality_score) AS max_val FROM performance_tests) AS min_quality ), entropy AS (   SELECT     -SUM(p_energy * LN(p_energy)) / LN(COUNT(*)) AS e_energy,     -SUM(p_time * LN(p_time)) / LN(COUNT(*)) AS e_time,     -SUM(p_quality * LN(p_quality)) / LN(COUNT(*)) AS e_quality,     COUNT(*) AS n   FROM normalized ), weights AS (   SELECT     (1 - e_energy) / ((1 - e_energy) + (1 - e_time) + (1 - e_quality)) AS w_energy,     (1 - e_time) / ((1 - e_energy) + (1 - e_time) + (1 - e_quality)) AS w_time,     (1 - e_quality) / ((1 - e_energy) + (1 - e_time) + (1 - e_quality)) AS w_quality   FROM entropy ) SELECT   model,   p_energy,   p_time,   p_quality,   w_energy,   w_time,   w_quality,   (w_energy * p_energy + w_time * p_time + w_quality * p_quality) AS comprehensive_score FROM normalized, weights;	rice_cooker	2
SELECT rci.id, rci.material, pt.final_temperature, ur.rice_quantity, CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.141592653589793 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.141592653589793 * 0.0001)) ELSE NULL END AS t_c, (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.141592653589793 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.141592653589793 * 0.0001)) ELSE NULL END AS risk_index, CASE WHEN (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.141592653589793 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.141592653589793 * 0.0001)) ELSE NULL END < 1 THEN 'Safe' ELSE 'Dangerous' END AS safety_condition FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id;	rice_cooker	3
WITH standardized_data AS (     SELECT          rci.brand AS manufacturer,          (pt.energy_consumption - MIN(pt.energy_consumption) OVER()) / (MAX(pt.energy_consumption) OVER() - MIN(pt.energy_consumption) OVER()) AS p_energy,          (pt.time_to_boil - MIN(pt.time_to_boil) OVER()) / (MAX(pt.time_to_boil) OVER() - MIN(pt.time_to_boil) OVER()) AS p_time,          (pt.rice_quality_score - MIN(pt.rice_quality_score) OVER()) / (MAX(pt.rice_quality_score) OVER() - MIN(pt.rice_quality_score) OVER()) AS p_score      FROM rice_cooker_info rci      JOIN performance_tests pt ON rci.id = pt.rice_cooker_id ), entropy_calculation AS (     SELECT          manufacturer,          -SUM(p_energy * LN(p_energy + 1e-9)) / LN(COUNT(*)) AS e_energy,          -SUM(p_time * LN(p_time + 1e-9)) / LN(COUNT(*)) AS e_time,          -SUM(p_score * LN(p_score + 1e-9)) / LN(COUNT(*)) AS e_score      FROM standardized_data      GROUP BY manufacturer ), weights AS (     SELECT          manufacturer,          (1 - e_energy) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_energy,          (1 - e_time) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_time,          (1 - e_score) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_score      FROM entropy_calculation ) SELECT      sd.manufacturer,      SUM(w.w_energy * (1 - sd.p_energy) + w.w_time * sd.p_time + w.w_score * sd.p_score) AS comprehensive_score  FROM standardized_data sd  JOIN weights w ON sd.manufacturer = w.manufacturer  GROUP BY sd.manufacturer;	rice_cooker	4
WITH maintenance_intervals AS (     SELECT          rice_cooker_id,          maintenance_date,          LAG(maintenance_date) OVER (PARTITION BY rice_cooker_id ORDER BY maintenance_date) AS prev_date,          maintenance_type      FROM maintenance_records ) SELECT      mi.rice_cooker_id,      mi.maintenance_date,      mi.prev_date,      CAST((JULIANDAY(mi.maintenance_date) - JULIANDAY(mi.prev_date)) * 1440 AS INTEGER) AS cooling_interval,      CASE          WHEN mi.maintenance_type = 'thermal fuse reset'          AND (JULIANDAY(mi.maintenance_date) - JULIANDAY(mi.prev_date)) * 1440 < 30          AND EXISTS (             SELECT 1              FROM usage_records ul              WHERE ul.rice_cooker_id = mi.rice_cooker_id              AND ul.temperature_setting > 85         )          THEN 'violation'          ELSE 'compliance'      END AS violation_status  FROM maintenance_intervals mi;	rice_cooker	1
SELECT rci.id, rci.power_rating, rci.voltage_rating, pt.final_temperature, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) AS L, (rci.power_rating / (rci.voltage_rating * rci.voltage_rating)) AS sigma, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / (rci.voltage_rating * rci.voltage_rating)) * (pt.final_temperature + 273) AS k_quantum, CASE WHEN (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / (rci.voltage_rating * rci.voltage_rating)) * (pt.final_temperature + 273) > 5000 THEN 'abnormal' ELSE 'normal' END AS thermal_conductivity_anomaly FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id;	rice_cooker	2
WITH calibration_records AS (   SELECT 1 AS rice_cooker_id, '2023-01-15' AS calibration_date, 1.5 AS calibration_error    UNION ALL    SELECT 2, '2022-12-20', 2.5    UNION ALL    SELECT 3, '2023-03-10', 0.8 )  SELECT pt.id, pt.test_date, cr.calibration_date, ABS(cr.calibration_error) AS calibration_error,         ABS(pt.final_temperature - pt.initial_temperature) AS temperature_deviation,         CASE           WHEN julianday(pt.test_date) - julianday(cr.calibration_date) > 365 THEN 'calibration overdue'           WHEN ABS(cr.calibration_error) > 2 THEN 'error exceeds limit'           WHEN ABS(pt.final_temperature - pt.initial_temperature) > 5 THEN 'temperature deviation'           ELSE 'normal'         END AS violation_status  FROM performance_tests pt  JOIN calibration_records cr ON pt.rice_cooker_id = cr.rice_cooker_id;	rice_cooker	3
SELECT pt.id, pt.energy_consumption, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) AS P, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 AS energy_gain, CASE WHEN (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 > pt.energy_consumption * 3.6e6 THEN 'satisfied' ELSE 'not satisfied' END AS quantum_condition FROM performance_tests pt;	rice_cooker	4
SELECT pt.time_to_boil AS t_earth, (pt.time_to_boil * (75.0 / (1.0/3.0 * 240.0)) * ((2260.0 / (75.0 * 1.0)) + 1.0) / ((2260.0 / (1.0/3.0 * 240.0 * 1.0)) + 1.0)) AS t_moon FROM performance_tests pt JOIN rice_cooker_info ri ON pt.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';	rice_cooker	1
SELECT ri.brand, 1 - EXP(-POWER(5.0 / 8.0, 2.5)) AS failure_probability_5_years, 8.0 * POWER(LN(2.0), 1.0 / 2.5) AS median_lifetime FROM rice_cooker_info ri GROUP BY ri.brand;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN 'Abnormal rice-to-water ratio' WHEN (SELECT STDEV(pt.final_temperature) FROM performance_tests pt WHERE pt.rice_cooker_id = ur.rice_cooker_id) > 5 THEN 'Uneven heating' WHEN ABS(AVG(ur.actual_max_temperature) - AVG(ur.temperature_setting)) > 5 THEN 'Temperature control deviation' WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%inner coating%') THEN 'Coating peeling' ELSE 'Other reasons' END AS possible_cause FROM usage_records ur GROUP BY ur.rice_cooker_id, ur.rice_quantity, ur.water_quantity;	rice_cooker	3
SELECT EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS tunneling_probability, 1 / EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS efficiency_increase FROM rice_cooker_info;	rice_cooker	4
SELECT pt.water_evaporation_rate, ur.energy_consumption, (ur.energy_consumption * ri.power_rating * (2260e3/461.5)*(1/363 - 1/373)/ri.power_rating) / (ur.water_quantity * 4.18 * 65 + pt.water_evaporation_rate * 2260) AS efficiency_correction FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';	rice_cooker	1
WITH user_features AS (     SELECT          rice_cooker_id,          COUNT(*) AS usage_frequency,          AVG(rice_quantity) AS avg_rice_quantity,          AVG(duration) AS avg_duration      FROM usage_records      GROUP BY rice_cooker_id ) SELECT      rice_cooker_id,      usage_frequency,      avg_rice_quantity,      avg_duration,      CASE          WHEN usage_frequency > 10 AND avg_duration < 30 THEN 'Frequent Quick Cooking'          WHEN usage_frequency BETWEEN 5 AND 10 AND avg_rice_quantity > 1 THEN 'Scheduled Appointments'          WHEN avg_duration > 60 THEN 'Heat Retention Dependence'          ELSE 'Other'      END AS user_category  FROM user_features;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.water_quantity / ri.capacity > 1.2 THEN 'Water level abnormal' WHEN ur.rice_type NOT IN ('White Rice', 'Brown Rice') THEN 'Incompatible rice type' WHEN strftime('%H', ur.start_time) BETWEEN '18' AND '20' THEN 'Peak time usage' ELSE 'Other' END AS misoperation_type FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;	rice_cooker	3
SELECT LN(1 - (2.8e6 / (1e-25 * 0.9))) / LN(1 - EXP(-1/1e-6)) AS required_qubits FROM rice_cooker_info WHERE id IS NOT NULL;	rice_cooker	4
SELECT ri.power_rating, pt.initial_temperature, (0.9*5.67e-8*0.15*(POWER(373,4)-POWER(233,4)))*((25*3.5*4180)/(ri.power_rating - (0.9*5.67e-8*0.15*(POWER(373,4)-POWER(233,4))))) AS extra_energy FROM rice_cooker_info ri JOIN performance_tests pt ON ri.id = pt.rice_cooker_id WHERE pt.test_type = 'Boiling';	rice_cooker	1
WITH fuzzy_data AS (   SELECT      ur.rice_cooker_id,      COUNT(*) / 30.0 AS usage_freq,      AVG(ABS(ur.actual_max_temperature - ur.temperature_setting)) AS temp_deviation,      (JULIANDAY(MAX(mr.maintenance_date)) - JULIANDAY(MIN(mr.maintenance_date))) / 30.0 AS maintenance_interval    FROM usage_records ur    LEFT JOIN maintenance_records mr ON ur.rice_cooker_id = mr.rice_cooker_id    GROUP BY ur.rice_cooker_id ) SELECT    rice_cooker_id,    CASE      WHEN usage_freq > 0.8 AND temp_deviation > 5 THEN 'High Risk'      WHEN (usage_freq BETWEEN 0.5 AND 0.8) OR maintenance_interval > 6 THEN 'Medium Risk'      ELSE 'Low Risk'    END AS risk_level  FROM fuzzy_data;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN 'Abnormal rice-to-water ratio(Appropriate range 1:1.2-1:1.8)' WHEN (ur.rice_quantity + ur.water_quantity) > ri.capacity THEN 'Total amount exceeds capacity(Exceeds rice cooker capacity)' WHEN ri.power_rating > 1000 THEN 'Power too high(>1000W)' ELSE 'Other reasons' END AS overflow_reason FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;	rice_cooker	3
SELECT POWER(5e-3,2)/(4*0.6) AS characteristic_length, CEIL((pt.final_temperature - pt.initial_temperature)/5 * SQRT(ur.energy_consumption)) AS iterations FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE pt.test_type = 'Boiling';	rice_cooker	4
SELECT (5 * 4200 * 75) / power_rating / 60 AS theoretical_time_minutes FROM rice_cooker_info WHERE model = 'RC-2002';	rice_cooker	1
SELECT rci.model, SUM(ur.energy_consumption) AS total_energy, COUNT(*) AS usage_count FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE rci.brand = 'BrandY' AND strftime('%Y', ur.start_time) = '2023' GROUP BY rci.model ORDER BY total_energy DESC LIMIT 5;	rice_cooker	2
SELECT model, brand, price FROM rice_cooker_info WHERE capacity > 4 AND power_rating < 800;	rice_cooker	3
SELECT 5000 * (30 / 3600) AS energy_consumption_kwh;	rice_cooker	4
SELECT pt.energy_consumption / ((1.5 * 4.18 + 1.2 * 1.8) * 75) AS thermal_efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE rci.model = 'RC-3003' AND pt.final_temperature = 100 LIMIT 1;	rice_cooker	1
SELECT rci.brand, rci.model, (STDDEV_SAMP(pt.rice_quality_score) / AVG(pt.rice_quality_score)) AS cv  FROM performance_tests pt  JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id  GROUP BY rci.brand, rci.model  HAVING cv > 0.25;	rice_cooker	2
SELECT rci.model  FROM rice_cooker_info rci  JOIN usage_records ur ON rci.id = ur.rice_cooker_id  LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id AND mr.maintenance_type = 'Cleaning'  WHERE ur.start_time >= date('now', '-2 years')  GROUP BY rci.id  HAVING COUNT(ur.id) > 10 AND COUNT(mr.id) = 0;	rice_cooker	3
SELECT 30000 / 220 AS current_strength;	rice_cooker	4
SELECT (DissolvedOxygenMgL / 8.24) * 100 AS DissolvedOxygenSaturation FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, POWER(10, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 7.0 AND TemperatureCelsius = 15 AND ConductivityUsCm = 300;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 THEN 'Not suitable for fish survival' WHEN DissolvedOxygenMgL < 5 THEN 'Not suitable for fish survival' WHEN TurbidityNTU > 25 THEN 'Not suitable for fish survival' ELSE 'Suitable for fish survival' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.ConductivityUsCm, POWER(10.0, -WQD.PHValue) AS H_ion_concentration, POWER(10.0, -(14 - WQD.PHValue)) AS OH_ion_concentration, (POWER(10.0, -WQD.PHValue) * POWER(10.0, -(14 - WQD.PHValue)) * WQD.ConductivityUsCm) AS IAP FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime LIKE '2023-10-01%' AND WQD.PHValue = 15 AND WQD.DissolvedOxygenMgL = 1000 AND WQD.TurbidityNTU = 10000;	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.64 AS EstimatedTDS FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, POWER(10.0, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.8;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 OR DissolvedOxygenMgL < 5 THEN 'Not suitable for fish survival' ELSE 'Suitable for fish survival' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, CASE WHEN WQD.PHValue = 0 OR WQD.DissolvedOxygenMgL = 2000 OR WQD.TurbidityNTU = 50000 THEN 'Does not comply with conventional water quality standards' ELSE 'Complies with conventional water quality standards' END AS WaterQualityStatus FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.7 AS TDSConcentration FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) AS IonStrength, CASE WHEN 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) > 0.1 THEN 'High Ionic Strength' ELSE 'Not High Ionic Strength' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.2 AND TemperatureCelsius = 20 AND ConductivityUsCm = 450;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 8.5 THEN 'Not suitable as a drinking water source' WHEN DissolvedOxygenMgL < 5 THEN 'Not suitable as a drinking water source' WHEN TurbidityNTU > 5 THEN 'Not suitable as a drinking water source' ELSE 'Suitable as a drinking water source' END AS DrinkingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -5 OR WQD.DissolvedOxygenMgL = 50000 OR WQD.TurbidityNTU = 1000000 OR WQD.TemperatureCelsius = 200 OR WQD.ConductivityUsCm = 1000000 THEN 'Unlikely to exist in nature' ELSE 'Possible to exist in nature' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT (100 * 2) AS Alk_CO3, 200 AS Alk_HCO3, (100 * 2 + 200) AS Total_Alkalinity FROM WaterQualityData WHERE MonitorId = 1 AND date(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) AS IonStrength, CASE WHEN 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) > 0.1 THEN 'High Ionic Strength' ELSE 'Not High Ionic Strength' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 8.0 AND TemperatureCelsius = 30 AND ConductivityUsCm = 800;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.0 OR PHValue > 9.0 THEN 'Not suitable for use as industrial cooling water' WHEN DissolvedOxygenMgL < 4 THEN 'Not suitable for use as industrial cooling water' WHEN TurbidityNTU > 20 THEN 'Not suitable for use as industrial cooling water' WHEN TemperatureCelsius > 40 THEN 'Not suitable for use as industrial cooling water' ELSE 'Suitable for use as industrial cooling water' END AS CoolingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -10 OR WQD.DissolvedOxygenMgL = 100000 OR WQD.TurbidityNTU = 10000000 OR WQD.TemperatureCelsius = 500 OR WQD.ConductivityUsCm = 10000000 THEN 'Impossible to exist in nature' ELSE 'Possible to exist in nature' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT CASE WHEN DissolvedOxygenMgL >= 8.24 THEN 'has reached saturation' ELSE 'has not reached saturation' END AS SaturationStatus FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND DissolvedOxygenMgL = 8;	WaterQualityMonitor	1
SELECT AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TurbidityNTU < 5 THEN 'Suitable for direct drinking' ELSE 'Not suitable for direct drinking' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 50;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount  FROM WaterQualityData  WHERE MonitorId = 1    AND PHValue > 8.5    AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30 AND ConductivityUsCm = 2000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 4 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'Exceeds safe limit' ELSE 'Does not exceed safe limit' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2.5 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 50 AND DissolvedOxygenMgL = 2;	WaterQualityMonitor	1
WITH FilteredData AS (     SELECT PHValue      FROM WaterQualityData      WHERE MonitorId = 1      AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now')     AND PHValue BETWEEN 6.0 AND 8.0 )  SELECT      (COUNT(*) * 100.0 / (         SELECT COUNT(*)          FROM WaterQualityData          WHERE MonitorId = 1          AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now')     )) AS PercentageInRange,      AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound,      AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound  FROM FilteredData;	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN 'reasonable' ELSE 'unreasonable' END AS TDSReasonability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 2000 AND ConductivityUsCm = 3000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * (TemperatureCelsius * TemperatureCelsius) - 0.000077774 * (TemperatureCelsius * TemperatureCelsius * TemperatureCelsius)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 80 AND DissolvedOxygenMgL = 1;	WaterQualityMonitor	1
WITH LogTransformedData AS (SELECT LN(TurbidityNTU) AS LogTurbidity FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-365 days') AND datetime('now')), FilteredData AS (SELECT TurbidityNTU FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-365 days') AND datetime('now') AND TurbidityNTU > 50) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-365 days') AND datetime('now'))) AS PercentageAboveThreshold, EXP(AVG(LogTurbidity) - (2.576 * (STDDEV_SAMP(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS LowerBound, EXP(AVG(LogTurbidity) + (2.576 * (STDDEV_SAMP(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS UpperBound FROM LogTransformedData;	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'exceeds the safety limit' ELSE 'does not exceed the safety limit' END AS SafetyStatus, 'Potential sources of pollution may include agricultural runoff, industrial wastewater, or domestic sewage.' AS PotentialSources FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 10 AND NitrateNitrogenMgL = 100;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35 AND DissolvedOxygenMgL = 4;	WaterQualityMonitor	1
WITH FilteredData AS (     SELECT PHValue      FROM WaterQualityData      WHERE MonitorId = 1      AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now')      AND PHValue BETWEEN 7.0 AND 8.0 ) SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now'))) AS PercentageInRange,     AVG(PHValue) - (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound,     AVG(PHValue) + (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound  FROM FilteredData;	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN 'reasonable' ELSE 'unreasonable' END AS TDSReasonability, CASE WHEN TotalDissolvedSolidsMgL NOT BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN 'possible reasons: abnormal ions in the water body or measurement errors.' ELSE 'no abnormalities' END AS ReasonExplanation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1500 AND ConductivityUsCm = 2000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 6;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-3 days') AND datetime('now');	WaterQualityMonitor	2
SELECT ROUND((COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)), 2) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-3 days') AND datetime('now');	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 10 AND DissolvedOxygenMgL = 9;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.8 AND 7.2 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'exceeds safety limit' ELSE 'does not exceed safety limit' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.3 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT POWER(10.0, -PHValue) AS HydrogenIonConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND PHValue = 6.5;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.5 AND 7.5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 THEN 'Suitable for direct consumption, but close to the alkaline edge, long-term consumption should be cautious' ELSE 'Not suitable for direct consumption' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * (TemperatureCelsius * TemperatureCelsius) - 0.000077774 * (TemperatureCelsius * TemperatureCelsius * TemperatureCelsius)) AS SaturatedOxygen, (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * (TemperatureCelsius * TemperatureCelsius) - 0.000077774 * (TemperatureCelsius * TemperatureCelsius * TemperatureCelsius)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 8;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN DissolvedOxygenMgL > 5 THEN 'Suitable for fish survival' ELSE 'Not suitable for fish survival, dissolved oxygen concentration is close to the critical value' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND DissolvedOxygenMgL = 4;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount  FROM WaterQualityData  WHERE MonitorId = 1  AND DissolvedOxygenMgL < 5  AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT TurbidityNTU * 2.5 AS SuspendedSolidsConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 15 AND TurbidityNTU = 50;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TurbidityNTU > 40 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TurbidityNTU < 5 THEN 'Suitable for direct consumption' ELSE 'Not suitable for direct consumption' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 100;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT 1000 * 4.18 * (30 - 20) AS HeatRequired FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TemperatureCelsius > 35 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-5 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TemperatureCelsius BETWEEN 15 AND 30 THEN 'suitable for fish survival' ELSE 'not suitable for fish survival, water temperature is too high' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius > 40 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND ConductivityUsCm = 500;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN ConductivityUsCm > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN ConductivityUsCm BETWEEN 500 AND 1500 THEN 'Suitable for direct consumption, but further testing of dissolved solids is required' ELSE 'Not suitable for direct consumption' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm = 1000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN TotalDissolvedSolidsMgL = ConductivityUsCm * 0.67 THEN 'reasonable' ELSE 'unreasonable' END AS TDSValidation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 500 AND ConductivityUsCm = 750;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TotalDissolvedSolidsMgL > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-30 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN 500 AND 1000 THEN 'Suitable for direct consumption' ELSE 'Not suitable for direct consumption, TDS concentration exceeds the standard' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1200;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT AmmoniaNitrogenMgL + NitrateNitrogenMgL AS TotalNitrogen FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN (AmmoniaNitrogenMgL + NitrateNitrogenMgL) > 12 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now', '-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN 'Exceeds safe limit' ELSE 'Does not exceed safe limit' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN PHValue < 7 THEN 'Ammonia nitrogen mainly exists in the form of NH4+' ELSE 'Ammonia nitrogen mainly exists in the form of NH3' END AS AmmoniaForm, CASE WHEN NitrateNitrogenMgL > 5 THEN 'Nitrate nitrogen concentration is high, which may have a negative impact on the aquatic ecosystem' ELSE 'Nitrate nitrogen concentration is normal' END AS NitrateImpact FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 6.5 AND AmmoniaNitrogenMgL = 1.5 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue < 6.5 AND AmmoniaNitrogenMgL > 1.5 AND NitrateNitrogenMgL > 10 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageConditionMet FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN datetime('now','-7 days') AND datetime('now');	WaterQualityMonitor	2
SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 AND AmmoniaNitrogenMgL <= 0.5 AND NitrateNitrogenMgL <= 50 THEN 'Suitable for direct consumption' ELSE 'Not suitable for direct consumption, further testing required' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount  FROM WaterQualityData  WHERE MonitorId = 1    AND (PHValue < 6.5 OR PHValue > 8.5 OR AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50)    AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT POWER(10, -PHValue) AS HydrogenIonConcentration, CASE WHEN PHValue > 8.5 THEN 'The water body is strongly alkaline, which may affect the survival of aquatic organisms and water quality safety' ELSE 'The water body pH value is normal' END AS WaterQualityImpact FROM WaterQualityData WHERE PHValue > 8.5;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningRule;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = 'dissolved oxygen' AND ThresholdValue = 5 AND ConditionOperator = '<';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN datetime('now', '-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN ConductivityUsCm > 1000 THEN 'High conductivity indicates a high concentration of ions in the water body, which may affect water quality and the ecosystem' ELSE 'Normal conductivity' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN PHValue > 8.5 THEN 'The carbonate buffer system may fail, leading to increased fluctuations in water pH, affecting water quality stability' ELSE 'The carbonate buffer system is normal, water quality is stable' END AS BufferSystemImpact FROM WaterQualityData WHERE PHValue > 8.5;	WaterQualityMonitor	1
WITH FilteredData AS (SELECT SeverityLevel FROM WaterQualityWarningRule WHERE SeverityLevel > 8) SELECT      (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityWarningRule)) AS PercentageAboveThreshold,      AVG(SeverityLevel) - (1.96 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound,      AVG(SeverityLevel) + (1.96 * (STDDEV_SAMP(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound  FROM FilteredData;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = 'dissolved oxygen' AND ThresholdValue = 5 AND ConditionOperator = '<';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN datetime('now','-1 day') AND datetime('now');	WaterQualityMonitor	4
SELECT CASE WHEN ConductivityUsCm > 1000 THEN 'High conductivity indicates a high concentration of ions in the water body, which may affect the chemical balance and health of the ecosystem' ELSE 'Normal conductivity' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel BETWEEN 4 AND 7 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityWarningRule;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = 'ammonia nitrogen' AND ThresholdValue = 0.5 AND ConditionOperator = '>';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TemperatureCelsius > 40 AND CollectionTime >= datetime('now', '-1 day') AND CollectionTime <= datetime('now');	WaterQualityMonitor	4
SELECT POWER(10, -TriggerValue) AS HydrogenIonConcentration, CASE WHEN TriggerValue > 7 THEN 'The water is alkaline, which may affect the survival of aquatic organisms and water quality safety' ELSE 'The water pH value is normal' END AS WaterQualityImpact FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 8.75 AND TriggerUnit = 'pH';	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 3.80 AND SeverityLevel = 7;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 1000 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	WaterQualityMonitor	4
SELECT POWER(10.0, -TriggerValue) AS HydrogenIonConcentration FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 7.5 AND TriggerUnit = 'pH';	WaterQualityMonitor	1
SELECT AVG(SeverityLevel) AS AverageSeverity FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 5 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	WaterQualityMonitor	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND power = 10000;	waterPump	4
SELECT Pump_ID, Purchase_date, Warranty_Period, date(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date, CASE WHEN '2023-06-01' <= date(Purchase_date, '+' || Warranty_Period || ' months') THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;	waterPump	4
SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 10000;	waterPump	4
SELECT Voltage * Current / 1000.0 AS Power FROM pump_specifications WHERE Voltage = 1000000 AND Current = 10000;	waterPump	1
SELECT power * 100 * 30 * 0.5 AS Monthly_Electricity_Cost FROM pump_specifications WHERE Voltage = 1000000 AND current = 10000;	waterPump	2
SELECT DATE(Purchase_Date, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM pumps WHERE Warranty_Period = 24 AND Purchase_Date = '2023-01-15';	waterPump	3
SELECT (Power * 1000 * 3600) / (1000 * 9.81 * Flow_Rate * Head / 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;	waterPump	4
SELECT date(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2023-01-15' AND Warranty_Period = 24;	waterPump	1
SELECT (5 * 365 * 8 * 0.8) AS Total_Energy_Cost;	waterPump	2
SELECT Power FROM pump_specifications WHERE Flow_Rate = 50 AND Head = 30;	waterPump	3
SELECT 5 * 8 * 365 AS total_energy_consumption_kWh, 5 * 8 * 365 * 0.8 AS total_cost_RMB;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Purchase_date, p.Warranty_Period, p.Location, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, (p.Warranty_Period * 30 * 24) AS Warranty_Hours FROM pumps p JOIN usage_records u ON p.Pump_ID = u.Pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID HAVING Total_Usage_Hours >= Warranty_Hours;	waterPump	3
SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Power_Required FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Efficiency = 200;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, MAX(m.Maintenance_Date) AS Last_Maintenance_Date, date(p.Purchase_date, '+' || p.Warranty_Period || ' months') AS Warranty_End_Date FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID LEFT JOIN maintenance_records m ON p.Pump_ID = m.pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period HAVING (Total_Usage_Hours > 1000 OR Last_Maintenance_Date IS NULL OR julianday('now') - julianday(Last_Maintenance_Date) > 180) AND julianday('now') < julianday(Warranty_End_Date);	waterPump	1
SELECT (10000 * 1000 * 9.81) / (3600 * Efficiency) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;	waterPump	2
SELECT pumps.Pump_ID, Model_Number, Manufacturer, (Flow_Rate * Head * 9.81 * 1000) / 3600 AS Hydraulic_Power FROM pump_specifications JOIN pumps ON pump_specifications.Pump_ID = pumps.Pump_ID;	waterPump	4
SELECT Pump_ID, Power * (Efficiency / 100.0) AS Actual_Output_Power FROM pump_specifications;	waterPump	1
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, (ps.Flow_Rate * ps.Head * 9.81 / 3600) / (ps.Efficiency / 100) AS Theoretical_Power FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE ps.Flow_Rate = 200 AND ps.Head = 80 AND ps.Efficiency = 85;	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT (10000 * 1000 * 100 * (Efficiency / 100)) / 3600 AS Power_kW FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;	waterPump	4
SELECT Power * 1 AS Electricity_Consumption FROM pump_specifications WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15;	waterPump	1
SELECT (Flow_Rate * Head * 100) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 5;	waterPump	2
SELECT power FROM pump_specifications WHERE Voltage = 1000000 AND current = 5000;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 5;	waterPump	1
SELECT (1000000 * 5000) / 1000 AS Power_kW;	waterPump	2
SELECT (Voltage * Current * 0.8) / 1000 AS Actual_Power FROM pump_specifications WHERE Current = 10 AND Voltage = 220;	waterPump	3
SELECT (1000 * 10000 * 1) AS Actual_Power;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Location, ps.Current, ps.Voltage, ps.Power, mr.Maintenance_Type, mr.Description, ur.Usage_Hours, ur.Notes FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID LEFT JOIN usage_records ur ON p.Pump_ID = ur.pump_ID WHERE ps.Current >= (SELECT 2 * AVG(Current) FROM pump_specifications WHERE Pump_ID = p.Pump_ID) AND p.Status = 'active';	waterPump	1
SELECT (1000 * 10000 * 1) / 1000 AS Actual_Power;	waterPump	2
SELECT (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600 AS Output_Power_kW FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Efficiency = 200;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Power = 10 AND Voltage = 220 AND Current = 50;	waterPump	1
SELECT DATE(Purchase_Date, '+' || Warranty_Period || ' months') AS Warranty_End FROM pumps WHERE Warranty_Period = 24 AND Purchase_Date = '2020-01-01';	waterPump	3
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT datetime(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 24;	waterPump	1
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	2
SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;	waterPump	3
SELECT p.Pump_ID, p.Model_Number, SUM(mr.Cost) AS Total_Maintenance_Cost, SUM(ur.Usage_Hours) AS Total_Usage_Hours FROM pumps p JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID WHERE mr.Maintenance_Date >= date('now', '-1 year') AND ur.Start_Time >= date('now', '-1 year') GROUP BY p.Pump_ID, p.Model_Number ORDER BY Total_Maintenance_Cost DESC, Total_Usage_Hours DESC;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, COUNT(mr.Record_ID) AS Maintenance_Count, SUM(u.Usage_Hours) AS Total_Usage_Hours FROM pumps p LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' GROUP BY p.Pump_ID, p.Model_Number, p.Status HAVING Maintenance_Count > 5 OR Total_Usage_Hours > 1000;	waterPump	2
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Location, p.Status, ps.Flow_Rate, ps.Head, ps.Power, ps.Voltage, ps.Current, ps.Efficiency, mr.Maintenance_Date, mr.Maintenance_Type, mr.Description, mr.Technician, mr.Cost, ur.Start_Time, ur.End_Time, ur.Usage_Hours, ur.Notes  FROM pumps p  JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID  JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID  JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID  WHERE (julianday('now') - julianday(p.Purchase_Date) >= p.Warranty_Period * 30)     OR (SELECT SUM(Usage_Hours) FROM usage_records WHERE Pump_ID = p.Pump_ID) > 1000  ORDER BY mr.Maintenance_Date DESC;	waterPump	3
SELECT SUM(ps.power * u.Usage_Hours) AS Total_Energy_Consumption FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' AND strftime('%Y', u.Start_Time) = strftime('%Y', date('now'));	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period, SUM(u.Usage_Hours) AS Total_Usage_Hours, CASE WHEN SUM(u.Usage_Hours) > 1000 OR date(p.Purchase_date, '+' || p.Warranty_Period || ' months') < date('now') THEN 'Needs Maintenance' ELSE 'No Maintenance Required' END AS Maintenance_Status FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period;	waterPump	4
SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100.0) * Usage_Hours / 1000 AS Total_Energy_Consumption FROM usage_records JOIN pump_specifications ON usage_records.pump_ID = pump_specifications.Pump_ID WHERE usage_records.Start_Time >= ? AND usage_records.End_Time <= ?;	waterPump	1
SELECT AVG(Cost) / 12 AS Average_Monthly_Maintenance_Cost FROM maintenance_records;	waterPump	2
SELECT SUM(ps.power * u.Usage_Hours) AS Total_Energy_Consumption_kWh  FROM pumps p  JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID  JOIN usage_records u ON p.Pump_ID = u.pump_ID  WHERE u.Start_Time >= '2023-01-01 00:00:00' AND u.End_Time <= '2023-12-31 23:59:59';	waterPump	4
SELECT AVG(monthly_cost) AS average_monthly_maintenance_cost FROM (SELECT SUM(Cost) / 12 AS monthly_cost FROM maintenance_records WHERE Maintenance_Date >= date('now', '-1 year') GROUP BY strftime('%Y', Maintenance_Date), strftime('%m', Maintenance_Date)) AS monthly_costs;	waterPump	1
SELECT Pump_ID, (10000 * Head * 9.81) / (Efficiency / 100) / 3600 AS New_Power FROM pump_specifications;	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT Power * 24 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 30 AND Power = 15;	waterPump	4
SELECT Pump_ID, Model_Number, Manufacturer, Purchase_date, Warranty_Period, Location, Status, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') < datetime('now') THEN 'Out of Warranty' ELSE 'Under Warranty' END AS Warranty_Status FROM pumps WHERE Pump_ID IN (SELECT Pump_ID FROM usage_records WHERE Usage_Hours > (Warranty_Period * 30 * 24));	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT SUM(Power * Usage_Hours) AS Total_Energy_Consumption FROM usage_records JOIN pump_specifications ON usage_records.pump_ID = pump_specifications.Pump_ID WHERE pump_specifications.Flow_Rate = 200 AND pump_specifications.Head = 30 AND pump_specifications.Power = 15 AND usage_records.Usage_Hours = 8 * 365;	waterPump	1
SELECT (Flow_Rate * Head * 10 * 1000) / (Power * 3600 * 1000) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;	waterPump	3
SELECT 1000 * 100 * 365.25 * 24 AS total_energy_consumption;	waterPump	4
SELECT SUM(ps.power * 8 * 365) AS total_energy_consumption FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE p.Status = 'active';	waterPump	2
WITH avg_cost AS (     SELECT AVG(Cost) AS avg_maintenance_cost     FROM maintenance_records     WHERE Pump_ID = ? ) SELECT      avg_maintenance_cost,     avg_maintenance_cost * 5 AS total_future_cost FROM avg_cost;	waterPump	2
SELECT ps.Pump_ID, SUM(ps.power * 8 * 365) AS Total_Energy_Consumption FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE p.Status = 'active' GROUP BY ps.Pump_ID;	waterPump	3
WITH MaintenanceCosts AS (SELECT Cost FROM maintenance_records WHERE pump_ID = 'specified pump ID' ORDER BY Maintenance_Date DESC LIMIT 10) SELECT AVG(Cost) AS Average_Maintenance_Cost, AVG(Cost) * 5 * 10 AS Predicted_Total_Maintenance_Cost_Next_5_Years FROM MaintenanceCosts;	waterPump	4
SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') >= '2023-01-01' THEN 'Under warranty' ELSE 'Not under warranty' END AS Warranty_Status FROM pumps WHERE Purchase_date = '2021-01-01' AND Warranty_Period = 24;	waterPump	1
SELECT Power AS Theoretical_Output_Power, (Flow_Rate * Head * 9.81) / 3600 AS Actual_Output_Power, Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000 AND Voltage = 10000 AND Current = 1000 AND Efficiency = 200;	waterPump	2
SELECT Power * Efficiency / 100.0 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 30 AND Power = 50 AND Voltage = 220 AND Current = 200 AND Efficiency = 80;	waterPump	3
SELECT (Power * (Usage_Hours * 30) * 0.8) AS monthly_electricity_cost FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 300 AND Head = 50 AND Power = 75 AND Voltage = 400 AND Current = 120 AND Efficiency = 90 AND Usage_Hours = 10;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID WHERE ps.Flow_Rate >= 200 AND ps.Head >= 30 AND ps.Power >= 50 AND ps.Voltage = 220 AND ps.Current = 200 AND ps.Efficiency >= 80 AND p.Status = 'active';	waterPump	1
SELECT      CASE          WHEN DATE(Purchase_Date, '+' || Warranty_Period || ' months') >= '2023-06-01' THEN 'Yes'          ELSE 'No, exceeded by ' || JULIANDAY('2023-06-01') - JULIANDAY(DATE(Purchase_Date, '+' || Warranty_Period || ' months')) || ' days'      END AS warranty_status  FROM pumps  WHERE Warranty_Period = 36 AND Purchase_Date = '2020-01-01';	waterPump	2
SELECT (Power * Efficiency / 100) AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Voltage = 220 AND Current = 45 AND Efficiency = 85;	waterPump	3
SELECT Pump_ID, Purchase_date, Warranty_Period, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') >= '2023-06-01' THEN 'In warranty period' ELSE 'Out of warranty period' END AS Warranty_Status, CASE WHEN date(Purchase_date, '+' || Warranty_Period || ' months') < '2023-06-01' THEN julianday('2023-06-01') - julianday(date(Purchase_date, '+' || Warranty_Period || ' months')) ELSE 0 END AS Days_Out_of_Warranty FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 36;	waterPump	4
SELECT Pump_ID, Maintenance_Date, Maintenance_Type, Cost  FROM maintenance_records  WHERE Pump_ID = (SELECT Pump_ID FROM maintenance_records WHERE Maintenance_Date = '2023-01-01' AND Maintenance_Type = 'Replace parts' AND Cost = 5000)  ORDER BY Maintenance_Date DESC  LIMIT 1;	waterPump	1
SELECT Power * (Efficiency / 100.0) * 8 * 30 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 120 AND Head = 60 AND Power = 12 AND Voltage = 220 AND Current = 50 AND Efficiency = 90;	waterPump	2
SELECT (Power * 1000 * Usage_Hours) / Efficiency AS Actual_Energy_Consumption FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Voltage = 1000 AND Current = 1000 AND Efficiency = 100 AND Usage_Hours = 1000;	waterPump	4
SELECT (Power * 8 * 30) AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Efficiency = 80;	waterPump	1
SELECT Power * 1000 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Voltage = 1000 AND Current = 1000 AND Efficiency = 100;	waterPump	2
SELECT DATE(Purchase_Date, '+' || Warranty_Period || ' months') AS Warranty_End_Date,         CASE WHEN '2023-06-01' <= DATE(Purchase_Date, '+' || Warranty_Period || ' months') THEN 'Yes' ELSE 'No' END AS Under_Warranty FROM pumps  WHERE Warranty_Period = 24 AND Purchase_Date = '2022-01-01';	waterPump	3
SELECT (1000 * 1000 * 9.81 * 1000) / 3600 AS actual_power;	waterPump	4
SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, date(Purchase_date, '+' || Warranty_Period || ' months') AS Warranty_End_Date, CASE WHEN '2023-06-01' <= date(Purchase_date, '+' || Warranty_Period || ' months') THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;	waterPump	2
SELECT (Flow_Rate * Head * 1000 * 9.81) / 3600000 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Efficiency = 100;	waterPump	1
WITH AvgCosts AS (SELECT Pump_ID, AVG(Cost) AS AvgCost FROM maintenance_records GROUP BY Pump_ID),      AvgHours AS (SELECT Pump_ID, AVG(Usage_Hours) AS AvgHours FROM usage_records GROUP BY Pump_ID) SELECT p.Pump_ID, (ac.AvgCost / ah.AvgHours) AS CostToUsageRatio FROM pumps p JOIN AvgCosts ac ON p.Pump_ID = ac.Pump_ID JOIN AvgHours ah ON p.Pump_ID = ah.Pump_ID ORDER BY CostToUsageRatio ASC LIMIT 10;	waterPump	2
SELECT y.Model, COUNT(v.Voyage_ID) AS Voyage_Count FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID WHERE v.Wind_Speed > 30 AND v.Wave_Height > 2 GROUP BY y.Model ORDER BY Voyage_Count DESC LIMIT 1;	yacht	3
SELECT y.Yacht_ID, y.Model, 1000000.0 / (p.Fuel_Efficiency * y.Max_Speed) AS Sailing_Time FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID WHERE 1000000.0 / (p.Fuel_Efficiency * y.Max_Speed) > 1000.0;	yacht	4
SELECT Yacht_ID, Model, (Displacement * 9.81) / (Weight * 9.81) AS Buoyancy_Gravity_Ratio FROM yachts WHERE (Displacement * 9.81) / (Weight * 9.81) > 1 ORDER BY Buoyancy_Gravity_Ratio DESC LIMIT 5;	yacht	1
SELECT v.Yacht_ID, y.Model, v.Fuel_Consumed * v.Distance AS Fuel_Distance_Product FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID ORDER BY Fuel_Distance_Product DESC LIMIT 10;	yacht	2
SELECT Yacht_ID, Model, Year, Engine_Type, Price FROM yachts WHERE Year > 2015 AND Engine_Type = 'diesel' ORDER BY Price DESC;	yacht	3
SELECT Yacht_ID, Model, (5000000 / Fuel_Efficiency) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Efficiency) > 10000;	yacht	4
SELECT Yacht_ID, Model, 0.5 * (Weight * 1000) * (Max_Speed * 0.514444) * (Max_Speed * 0.514444) AS Kinetic_Energy FROM yachts ORDER BY Kinetic_Energy DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, Model, (5000000 / Fuel_Capacity) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Capacity) > 10000 ORDER BY Max_Distance ASC LIMIT 10;	yacht	2
SELECT Yacht_ID, Model, Year, Hull_Material FROM yachts WHERE Year < 2010 AND Hull_Material = 'fiberglass' ORDER BY Year ASC;	yacht	3
SELECT Yacht_ID,  (1000000 / (Fuel_Efficiency / "Range")) AS Sailing_Time_Hours FROM performance_metrics WHERE (1000000 / (Fuel_Efficiency / "Range")) > 1000 ORDER BY Sailing_Time_Hours DESC;	yacht	4
SELECT Yacht_ID, Model, 0.5 * 1025 * Drag_Coefficient * (Length * Width) * POWER(Max_Speed * 0.514444, 3) AS Drag_Power FROM yachts ORDER BY Drag_Power DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, (Total_Energy_Consumed / Distance) AS Energy_Ratio FROM voyages WHERE Distance > 0 ORDER BY Energy_Ratio DESC LIMIT 10;	yacht	2
SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Efficiency FROM yachts WHERE Year > 2015 AND Engine_Type = 'diesel' ORDER BY Fuel_Efficiency ASC;	yacht	3
SELECT Yacht_ID, Model, (10000000.0 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000.0 / Fuel_Efficiency) > 50000.0;	yacht	4
SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Capacity FROM yachts WHERE Year > 2015 AND Engine_Type = 'diesel' ORDER BY Fuel_Capacity ASC;	yacht	1
SELECT Yacht_ID, (10000000 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000 / Fuel_Efficiency) > 50000;	yacht	2
SELECT Fuel_Capacity, (1000 / Fuel_Efficiency) AS Required_Fuel FROM yachts WHERE Yacht_ID = 'specific_yacht_ID';	yacht	3
SELECT Yacht_ID, Model, (Fuel_Efficiency / "Range") AS Efficiency_Ratio FROM performance_metrics ORDER BY Efficiency_Ratio DESC LIMIT 5;	yacht	4
SELECT Model, Year, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 20 ORDER BY Price DESC;	yacht	1
SELECT y.Yacht_ID, y.Model, p.Fuel_Efficiency / y.Max_Speed AS Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID ORDER BY Fuel_Consumption_Rate ASC LIMIT 10;	yacht	2
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity / p.Fuel_Efficiency * y.Max_Speed AS Max_Range  FROM yachts y  JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID  ORDER BY Max_Range DESC  LIMIT 3;	yacht	3
SELECT 100000 / (500 * 50 * 1) AS Draft, CASE WHEN 100000 / (500 * 50 * 1) > 50 THEN 'Cannot float normally' ELSE 'Can float normally' END AS Status;	yacht	4
SELECT Hull_Material, AVG(Displacement / (Length * Width * 1)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;	yacht	1
SELECT y.Engine_Type, AVG(p.Fuel_Efficiency / y.Max_Speed) AS Avg_Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY y.Engine_Type;	yacht	2
SELECT Manufacturer_ID, AVG(Fuel_Capacity / Fuel_Efficiency * Max_Speed) AS Avg_Max_Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY Manufacturer_ID;	yacht	3
SELECT Hull_Material, AVG(1000000.0 / (1000.0 * 100.0 * 1.0)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;	yacht	4
SELECT Voyage_ID, Yacht_ID, Fuel_Consumed / Distance AS Fuel_Efficiency FROM voyages ORDER BY Fuel_Efficiency ASC LIMIT 5;	yacht	1
SELECT Yacht_ID, SUM(Fuel_Consumed) / SUM(Distance) AS Avg_Fuel_Efficiency FROM voyages GROUP BY Yacht_ID;	yacht	2
SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Fuel_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Yacht_ID, Buoyancy_Force / Displacement AS Buoyancy_Ratio FROM yachts ORDER BY Buoyancy_Ratio DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, SUM(Total_Energy_Consumed) * 1.0 / SUM(Distance) AS Avg_Energy_Efficiency FROM voyages GROUP BY Yacht_ID;	yacht	2
SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID WHERE v.Weather_Conditions IN ('strong winds', 'heavy waves') GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Energy_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT c.Charter_Type, AVG(v.Fuel_Consumed / v.Distance) AS Avg_Fuel_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY c.Charter_Type;	yacht	1
SELECT v.Yacht_ID, SUM(c.Total_Cost) * 1.0 / SUM(v.Distance) AS Avg_Charter_Cost_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY v.Yacht_ID;	yacht	2
SELECT c.Charter_Type, AVG(v.Distance) AS Avg_Distance FROM charters c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Charter_Type ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Charter_Cost_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Yacht_ID, AVG(Salary) / AVG(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;	yacht	1
SELECT Yacht_ID, SUM(Salary) * 1.0 / SUM(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;	yacht	2
SELECT Role, AVG(Salary) AS Avg_Salary FROM crew GROUP BY Role ORDER BY Avg_Salary DESC LIMIT 1;	yacht	3
SELECT 1000000 * 12 / 100 AS Salary_Efficiency, CASE WHEN 1000000 * 12 / 100 < 1000 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Yacht_ID, 0.5 * Weight * 1000 * POWER(Max_Speed * 0.5144, 2) AS Kinetic_Energy FROM yachts;	yacht	1
SELECT c.Yacht_ID, (SUM(c.Salary) / y.Price) * 100 AS Crew_Salary_Ratio FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Yacht_ID;	yacht	2
SELECT c.Role, AVG(y.Passenger_Capacity) AS Avg_Passenger_Per_Role FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Role ORDER BY Avg_Passenger_Per_Role DESC LIMIT 1;	yacht	3
SELECT 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) AS Kinetic_Energy, CASE WHEN 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) > 1e12 THEN 'Abnormal Data' ELSE 'Reasonable Data' END AS Status;	yacht	4
SELECT Displacement, Buoyancy_Force FROM yachts WHERE Yacht_ID = ?;	yacht	1
SELECT Max_Speed, Engine_Power, Fuel_Efficiency FROM yachts WHERE Yacht_ID = ?;	yacht	2
SELECT Model, Year, Hull_Material, Passenger_Capacity, Price FROM yachts WHERE Hull_Material = 'carbon fiber' AND Passenger_Capacity > 10 ORDER BY Year ASC;	yacht	3
SELECT Model, Engine_Type, Engine_Power, Fuel_Capacity, Max_Speed FROM yachts WHERE Engine_Power > 500 AND Fuel_Capacity > 5000 ORDER BY Max_Speed DESC;	yacht	4
SELECT Model, Year, Price, Hull_Material FROM yachts WHERE Year >= 2018 AND Price < 1000000 ORDER BY Price ASC;	yacht	1
SELECT Yacht_ID, (Fuel_Efficiency / "Range") AS Fuel_Consumption_Rate FROM performance_metrics ORDER BY Fuel_Consumption_Rate ASC LIMIT 3;	yacht	2
SELECT Yacht_ID, (Fuel_Efficiency / "Range") * 100 AS Total_Fuel_Consumption FROM performance_metrics ORDER BY Total_Fuel_Consumption DESC LIMIT 5;	yacht	3
SELECT Yacht_ID, (Fuel_Efficiency / "Range") AS Fuel_Consumption_per_Kilometer FROM performance_metrics ORDER BY Fuel_Consumption_per_Kilometer ASC LIMIT 3;	yacht	4
SELECT Passenger_Capacity, Water_Capacity FROM yachts WHERE Yacht_ID = 1;	yacht	1
SELECT Engine_Power, Fuel_Efficiency, Fuel_Capacity FROM yachts WHERE Yacht_ID = 2;	yacht	2
SELECT 0.5 * (Displacement * 1000) * POWER((Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts WHERE Yacht_ID = 1;	yacht	3
SELECT (Fuel_Capacity / Fuel_Efficiency) AS Actual_Range, "Range" AS Designed_Range FROM yachts JOIN performance_metrics ON yachts.Yacht_ID = performance_metrics.Yacht_ID WHERE yachts.Yacht_ID = 1;	yacht	4
SELECT Water_Capacity, Passenger_Capacity * 50 * 7 AS Total_Water_Needed FROM yachts WHERE Yacht_ID = 1;	yacht	1
SELECT (Fuel_Capacity / 1000) * 50 AS Possible_Distance, 8000 AS Required_Distance FROM yachts WHERE Yacht_ID = 1;	yacht	2
SELECT Hull_Material, AVG(Price) AS Avg_Price FROM yachts GROUP BY Hull_Material;	yacht	3
SELECT Model, Length, Max_Speed FROM yachts WHERE Length > 30;	yacht	4
SELECT Model, Length, Width FROM yachts WHERE Hull_Material = 'Fiberglass';	yacht	1
SELECT Model, Year, Hull_Material FROM yachts WHERE Year > 2020;	yacht	2
SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity;	yacht	3
SELECT y.*, y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) AS Fuel_Consumption_Time FROM yachts y WHERE y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) > 1000;	yacht	4
SELECT y.*, 0.5 * (y.Displacement * 1000) * POWER((y.Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts y ORDER BY Kinetic_Energy DESC LIMIT 5;	yacht	1
WITH Fuel_Rate AS (     SELECT          y.Yacht_ID,          y.Model,          v.Fuel_Consumed / v.Distance AS Fuel_Consumption_Rate      FROM          yachts y      JOIN          voyages v ON y.Yacht_ID = v.Yacht_ID )  SELECT * FROM (     SELECT          *,          ROW_NUMBER() OVER (PARTITION BY Yacht_ID ORDER BY Fuel_Consumption_Rate ASC) AS rn      FROM          Fuel_Rate )  WHERE rn = 1;	yacht	2
WITH Overloaded_Charters AS (SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity) SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY Charter_Type ORDER BY Total_Cost DESC) AS rn FROM Overloaded_Charters) WHERE rn = 1;	yacht	3
SELECT Model, Price, Max_Speed FROM yachts WHERE Price > 5000000;	yacht	4
SELECT Model, Engine_Power, Fuel_Capacity FROM yachts WHERE Engine_Type = 'Inboard';	yacht	1
SELECT y.Yacht_ID, y.Model, y.Passenger_Capacity, COUNT(DISTINCT c.Customer_ID) AS Customer_Count, COUNT(DISTINCT cr.Crew_ID) AS Crew_Count  FROM yachts y  JOIN charters ch ON y.Yacht_ID = ch.Yacht_ID  JOIN customers c ON ch.Customer_ID = c.Customer_ID  JOIN crew cr ON y.Yacht_ID = cr.Yacht_ID  GROUP BY y.Yacht_ID  HAVING (COUNT(DISTINCT c.Customer_ID) + COUNT(DISTINCT cr.Crew_ID)) <= y.Passenger_Capacity * 0.8;	yacht	2
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed);	yacht	3
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed) AND y.Engine_Power = 100000;	yacht	4
SELECT Displacement / (Length * Width * 1.0) AS Draft FROM yachts WHERE Yacht_ID = 'specific_yacht_ID';	yacht	1
SELECT (Total_Cost * 0.8 * 0.85) + (Total_Cost * 0.2) AS Actual_Payment FROM charters WHERE Customer_ID = 'specific customer ID' AND strftime('%Y', Start_Date) = '2023';	yacht	2
SELECT Voyage_ID, Yacht_ID, Average_Speed FROM voyages WHERE Average_Speed > (SELECT Max_Speed FROM yachts WHERE yachts.Yacht_ID = voyages.Yacht_ID);	yacht	3
SELECT (Fuel_Capacity / Fuel_Efficiency) / (24 * 365) AS Fuel_Support_Years FROM yachts WHERE Yacht_ID = 'specific_yacht_ID';	yacht	4
SELECT Model, 0.5 * (Weight * 1000) * ((Max_Speed * 0.514444) * (Max_Speed * 0.514444)) AS Kinetic_Energy FROM yachts WHERE 0.5 * (Weight * 1000) * ((Max_Speed * 0.514444) * (Max_Speed * 0.514444)) > 100000000;	yacht	1
SELECT Model, Length, Year FROM yachts WHERE Length BETWEEN 20 AND 30;	yacht	2
SELECT y.Model, y.Hull_Material, y.Engine_Type FROM yachts y JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE v.Wave_Height > 3 AND v.Wind_Speed > 30;	yacht	3
SELECT y.Model, (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 AS Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 > 1000000;	yacht	4
WITH KineticEnergy AS (     SELECT Model, Hull_Material, 0.5 * (Weight * 1000) * ((Max_Speed * 0.514444) * (Max_Speed * 0.514444)) AS Kinetic_Energy      FROM yachts ) SELECT Hull_Material, Model, MAX(Kinetic_Energy) AS Max_Kinetic_Energy  FROM KineticEnergy  GROUP BY Hull_Material;	yacht	1
SELECT Model, Max_Speed, Price FROM yachts WHERE Max_Speed > 35;	yacht	2
SELECT Model, Fuel_Capacity, Hull_Material FROM yachts WHERE Fuel_Capacity > 1000;	yacht	3
SELECT Model, Passenger_Capacity, Price FROM yachts WHERE Passenger_Capacity > 12;	yacht	4
WITH BuoyancyRatio AS (   SELECT Model, Hull_Material, Buoyancy_Force / (Weight * 1000.0 * 9.81) AS Buoyancy_Ratio    FROM yachts )  SELECT Hull_Material, Model, MIN(Buoyancy_Ratio) AS Min_Buoyancy_Ratio  FROM BuoyancyRatio  GROUP BY Hull_Material;	yacht	1
SELECT Model, Displacement, Max_Speed FROM yachts WHERE Displacement > 50;	yacht	2
SELECT Model, Buoyancy_Force, Center_of_Gravity FROM yachts WHERE Buoyancy_Force > 100000;	yacht	3
SELECT Model, Drag_Coefficient, Hull_Speed FROM yachts WHERE Drag_Coefficient < 0.5;	yacht	4
WITH KineticEnergy AS (     SELECT          y.Model,          y.Hull_Material,          0.5 * (y.Weight * 1000) * ((y.Max_Speed * 0.514444) * (y.Max_Speed * 0.514444)) AS Kinetic_Energy,          AVG(c.Salary) AS Avg_Salary      FROM yachts y      JOIN crew c ON y.Yacht_ID = c.Yacht_ID      GROUP BY y.Model, y.Hull_Material ) SELECT      Hull_Material,      Model,      MAX(Kinetic_Energy / Avg_Salary) AS Max_Ratio  FROM KineticEnergy  GROUP BY Hull_Material;	yacht	1
SELECT Model, Year, Price FROM yachts WHERE Manufacturer_ID = 1;	yacht	2
SELECT Model, Hull_Speed, Max_Speed FROM yachts WHERE Hull_Speed > 25;	yacht	3
SELECT Model, Weight, Displacement FROM yachts WHERE Weight > 100;	yacht	4
WITH KineticEnergy AS (   SELECT      y.Model,      0.5 * (y.Weight * 1000) * (y.Max_Speed * 0.514444) * (y.Max_Speed * 0.514444) AS Kinetic_Energy,      AVG(c.Salary) AS Avg_Salary    FROM yachts y    JOIN crew c ON y.Yacht_ID = c.Yacht_ID    GROUP BY y.Model )  SELECT Model, Kinetic_Energy / Avg_Salary AS Ratio  FROM KineticEnergy  ORDER BY Ratio DESC  LIMIT 5;	yacht	1
SELECT Model, Water_Capacity, Fuel_Capacity FROM yachts WHERE Water_Capacity > 500;	yacht	2
SELECT Model, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 35 ORDER BY Price DESC;	yacht	3
SELECT Model, Year, Hull_Material, Engine_Power FROM yachts WHERE Year > 2020 AND Hull_Material = 'Fiberglass' ORDER BY Engine_Power ASC;	yacht	4
SELECT (b.Voltage * b.Capacity) / m.Power AS Theoretical_Range_Time FROM Batteries b JOIN ElectricBikes eb ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.BikeID WHERE eb.Weight = 50 AND m.Power = 400 AND b.Voltage = 48 AND b.Capacity = 20;	electric_scooter	1
SELECT (b.Voltage * b.Capacity) / 0.05 AS Distance FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE b.Capacity = 15 AND b.Voltage = 36 AND m.Power = 250 AND bd.Wheel_Size = 12;	electric_scooter	2
SELECT Type, Voltage, Capacity FROM Batteries WHERE Voltage = 48 AND Capacity > 50 AND Type = 'Li-ion battery' ORDER BY Capacity DESC;	electric_scooter	3
SELECT Type, Voltage, Capacity, (SELECT SUM(Capacity) FROM Batteries WHERE Voltage IN (60, 72)) AS Total_Capacity FROM Batteries WHERE Voltage IN (60, 72);	electric_scooter	4
SELECT Type, Voltage, Capacity, SUM(Capacity) OVER () AS Total_Capacity FROM Batteries WHERE Voltage = 72 AND Capacity > 90 AND Type = 'Lithium Battery';	electric_scooter	1
SELECT (b.Voltage * b.Capacity) / 1 AS Distance, CASE WHEN b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 THEN 'Theoretically feasible, practically not feasible' ELSE 'Configuration anomaly' END AS Feasibility FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID WHERE b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 LIMIT 1;	electric_scooter	2
SELECT (bd.Length * bd.Width * bd.Height) AS Body_Volume FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 1800 AND bd.Width = 700 AND bd.Height = 1200 AND bd.Wheel_Size = 14;	electric_scooter	3
SELECT CASE WHEN 5000 <= 6000 AND 2000 <= 2500 AND 2500 <= 3000 THEN 'can be parked' ELSE 'cannot be parked' END AS Parking_Feasibility;	electric_scooter	4
SELECT DISTINCT CASE WHEN bd.Height <= 1500 THEN 'can pass through' ELSE 'cannot pass through' END AS Tunnel_Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.BikeID WHERE bd.Height = 1200 AND bd.WheelSize = 14;	electric_scooter	1
SELECT CASE WHEN bd.Length <= 6000 AND bd.Width <= 2500 AND bd.Height <= 3000 THEN 'can be parked' ELSE 'cannot be parked' END AS Parking_Feasibility, CASE WHEN bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30 THEN 'theoretically feasible, practically not feasible' ELSE 'configuration anomaly' END AS Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30;	electric_scooter	2
SELECT (cr.Energy_Used * 1000) / (220 * ((strftime('%s', cr.EndTime) - strftime('%s', cr.StartTime)))) AS Charging_Current FROM ChargingRecords cr WHERE cr.Energy_Used = 2;	electric_scooter	3
SELECT SUM(Cost) AS Total_Charging_Cost FROM ChargingRecords WHERE User_ID = 3 AND date(StartTime) = '2023-10-01';	electric_scooter	4
SELECT Energy_Used / 0.9 AS Actual_Energy_Consumed FROM ChargingRecords WHERE Energy_Used = 3 LIMIT 1;	electric_scooter	1
SELECT 1000 / (1000 * 1 * 0.5) AS Actual_Current;	electric_scooter	2
SELECT (Voltage * Capacity) / Distance AS EnergyPerKm FROM Batteries WHERE Voltage = 48 AND Capacity = 20 AND Distance = 60 LIMIT 1;	electric_scooter	3
SELECT (10000.0 / 1000.0) AS PowerToWeightRatio;	electric_scooter	4
SELECT 2.0 / 2.0 AS AveragePower;	electric_scooter	1
SELECT SUM(Energy_Used) AS TotalEnergyUsed, AVG(Energy_Used) AS AvgEnergyUsed FROM ChargingRecords WHERE User_ID = ? AND strftime('%Y-%m', StartTime) = ?;	electric_scooter	2
SELECT Energy_Used / ((strftime('%s', EndTime) - strftime('%s', StartTime)) / 3600.0) AS AveragePower FROM ChargingRecords WHERE Energy_Used = 2 AND (strftime('%s', EndTime) - strftime('%s', StartTime)) = 7200;	electric_scooter	3
SELECT SUM(Energy_Used) AS TotalEnergyUsed, AVG(Energy_Used) AS AverageEnergyPerCharge FROM ChargingRecords WHERE User_ID = 101 AND StartTime >= '2023-10-01 00:00:00' AND StartTime <= '2023-10-31 23:59:59';	electric_scooter	4
SELECT AVG(Cost) AS AverageCost FROM MaintenanceRecords WHERE Description = 'battery replacement';	electric_scooter	1
SELECT SUM(Cost) AS TotalCost, AVG(Cost) AS AverageCost FROM MaintenanceRecords;	electric_scooter	2
SELECT AVG(Cost) AS AverageCost FROM MaintenanceRecords WHERE Description = 'Replace battery' AND Bike_ID = 1;	electric_scooter	3
SELECT SUM(Cost) AS TotalMaintenanceCost, AVG(Cost) AS AverageCostPerMaintenance FROM MaintenanceRecords WHERE BikeID = 1 AND MaintenanceDate >= '2023-01-01' AND MaintenanceDate <= '2023-12-31';	electric_scooter	4
SELECT Maintenance_Date FROM MaintenanceRecords WHERE Technician = 'Master Zhang';	electric_scooter	1
SELECT SUM(Cost) AS TotalMaintenanceCost, CASE WHEN SUM(Cost) = 500 * COUNT(*) THEN 'Reasonable' ELSE 'Unreasonable' END AS IsReasonable FROM MaintenanceRecords WHERE Description = 'battery replacement' AND Bike_ID = 201 AND Maintenance_Date >= '2023-01-01' AND Maintenance_Date <= '2023-12-31';	electric_scooter	2
SELECT 7 * Available_Slots AS TotalPower FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;	electric_scooter	3
SELECT (1000 * 1000 * 24) AS TotalEnergyConsumption, (1000 * 1000 * 24 * (SELECT Cost / Energy_Used FROM ChargingRecords LIMIT 1)) AS TotalCost LIMIT 1;	electric_scooter	4
SELECT COUNT(*) FROM Users WHERE strftime('%Y-%m', CreatedAt) = '2023-10';	electric_scooter	1
SELECT COUNT(*) FROM Users u1, Users u2 WHERE ABS(JULIANDAY(u1.CreatedAt) - JULIANDAY(u2.CreatedAt)) <= 1 AND u1.User_ID < u2.User_ID;	electric_scooter	2
SELECT COUNT(DISTINCT Address) AS UserCount FROM Users WHERE date(CreatedAt) >= '2023-10-01' AND date(CreatedAt) <= '2023-10-31';	electric_scooter	3
SELECT COUNT(DISTINCT u2.User_ID) AS UserCount FROM Users u1 JOIN Users u2 ON ABS(julianday(u1.CreatedAt) - julianday(u2.CreatedAt)) <= 1 AND u1.User_ID != u2.User_ID WHERE u1.Username = 'Zhang San' AND u1.Address LIKE '%Beijing Chaoyang District%';	electric_scooter	4
SELECT COUNT(DISTINCT Address) AS DistinctRegionCount FROM Users;	electric_scooter	1
SELECT COUNT(*) AS SameRegionUserCount FROM users WHERE Address = (SELECT Address FROM users WHERE Username = 'Zhang San');	electric_scooter	2
SELECT Voltage * Capacity AS Energy FROM Batteries WHERE Voltage = 48 AND Capacity = 20;	electric_scooter	3
SELECT (1000 * 1000) AS StoredEnergy, (1000 * 1000) / 10000 AS Duration;	electric_scooter	4
SELECT (Voltage * Capacity) / 500 AS RunTime FROM Batteries WHERE Capacity = 20 AND Voltage = 48;	electric_scooter	1
SELECT COUNT(*) AS ItemCount, Manufacturer AS Supplier  FROM ElectricBikes  GROUP BY Manufacturer  ORDER BY ItemCount DESC  LIMIT 5;	electric_scooter	2
SELECT Devices.deviceId AS itemId, Devices.deviceName AS itemName, Devices.deviceType AS specification, Labs.location AS storageLocation FROM Devices JOIN Labs ON Devices.labId = Labs.labId WHERE Labs.location = 'specific area';	PhysicsLabDB	3
SELECT deviceId, (SUM(energyConsumed) / (SUM(powerUsage) * (JULIANDAY(MAX(timestamp)) - JULIANDAY(MIN(timestamp))) * 24) * 100 AS efficiency FROM EnergyConsumption GROUP BY deviceId ORDER BY efficiency ASC LIMIT 5;	EnergyManagementDB	4
SELECT deviceId, (STDDEV(energyConsumed) / AVG(energyConsumed) * 100) AS fluctuationRate FROM EnergyConsumption GROUP BY deviceId ORDER BY fluctuationRate DESC LIMIT 10;	EnergyManagementDB	1
SELECT location, COUNT(*) AS itemCount FROM EnergyDevices GROUP BY location ORDER BY itemCount ASC LIMIT 5;	EnergyManagementDB	2
SELECT d.itemName, d.specifications, s.supplierName FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE d.status = 'Under Maintenance';	PhysicsLabDB	3
SELECT d.deviceType, COUNT(d.deviceId) * 10 * 365 AS totalWarrantyExtensionDays FROM Devices d GROUP BY d.deviceType ORDER BY totalWarrantyExtensionDays DESC LIMIT 3;	PhysicsLabDB	4
SELECT d.deviceName, d.deviceType, s.supplierName FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE d.status = 'fault' ORDER BY julianday('now') - julianday(d.calibrationDate) ASC;	PhysicsLabDB	1
SELECT s.supplierName, COUNT(DISTINCT d.deviceType) AS specificationCount FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierName ORDER BY specificationCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, warrantyEndDate FROM Devices WHERE warrantyEndDate >= date('now');	PhysicsLabDB	3
SELECT s.supplierId, COUNT(d.deviceType) * 1000 AS totalMaintenanceCost FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierId ORDER BY totalMaintenanceCost DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceName, deviceType, julianday(warrantyEndDate) - julianday(purchaseDate) AS totalWarrantyDays FROM Devices ORDER BY totalWarrantyDays DESC;	PhysicsLabDB	1
SELECT m.country, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.country ORDER BY deviceCount ASC LIMIT 5;	EnergyManagementDB	2
SELECT itemName, specifications, storageLocation FROM Devices WHERE status = 'Disabled';	PhysicsLabDB	3
SELECT d.supplierId, SUM(dt.maintenanceCost) * 0.1 AS totalMaintenanceCost FROM Devices d JOIN DeviceTypes dt ON d.deviceType = dt.deviceType GROUP BY d.supplierId ORDER BY totalMaintenanceCost ASC LIMIT 3;	PhysicsLabDB	4
SELECT d.deviceName, CAST((julianday('now') - julianday(d.calibrationDate)) AS INTEGER) AS unmaintainedDays FROM Devices d WHERE d.status = 'inactive' ORDER BY unmaintainedDays DESC;	PhysicsLabDB	1
SELECT m.manufacturerName, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.manufacturerName ORDER BY deviceCount DESC LIMIT 5;	EnergyManagementDB	2
SELECT d.itemName, d.specifications, d.purchaseDate FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE s.supplierName = 'a certain supplier';	PhysicsLabDB	3
SELECT d.supplierId, SUM((julianday(d.warrantyEndDate) - julianday(d.purchaseDate)) * 0.5) AS totalWarrantyReduction FROM Devices d GROUP BY d.supplierId ORDER BY totalWarrantyReduction DESC LIMIT 3;	PhysicsLabDB	4
SELECT i.itemName, i.purchaseDate, i.energyConsumption FROM Devices i ORDER BY i.energyConsumption DESC;	PhysicsLabDB	1
SELECT dt.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumption FROM EnergyConsumption ec JOIN Devices d ON ec.deviceId = d.deviceId JOIN DeviceTypes dt ON d.deviceType = dt.deviceType GROUP BY dt.deviceType ORDER BY totalEnergyConsumption ASC LIMIT 3;	PhysicsLabDB	2
SELECT deviceName, deviceType, powerRating FROM EnergyDevices WHERE powerRating > 100 ORDER BY powerRating DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 10) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	4
SELECT deviceName, deviceType, power FROM Devices WHERE power > 100 ORDER BY power DESC;	PhysicsLabDB	1
SELECT supplierId, COUNT(*) AS deviceCount FROM Devices GROUP BY supplierId ORDER BY deviceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = 'fault';	PhysicsLabDB	3
SELECT deviceType, SUM(power * 100) AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceName, deviceType, SUM(current) AS totalCurrent FROM Devices GROUP BY deviceName, deviceType ORDER BY totalCurrent DESC;	PhysicsLabDB	1
SELECT deviceType, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY avgEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE (julianday('now') - julianday(installationDate)) > 5 * 365;	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;	PhysicsLabDB	1
SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, temperature  FROM EnergyConsumption  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  WHERE temperature > 50 OR temperature < -20  ORDER BY temperature;	EnergyManagementDB	3
SELECT deviceType, SUM(cost) * 1000 AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerRatio DESC;	EnergyManagementDB	1
SELECT manufacturerId, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY manufacturerId ORDER BY avgEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, humidity FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId WHERE humidity < 0 OR humidity > 100 ORDER BY humidity DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerDifference DESC;	EnergyManagementDB	1
SELECT deviceType, COUNT(deviceId) AS maintenanceCount FROM Devices WHERE status IN ('under maintenance', 'faulty') GROUP BY deviceType ORDER BY maintenanceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, lastMaintenanceDate FROM EnergyDevices JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId WHERE julianday('now') - julianday(lastMaintenanceDate) > 365 ORDER BY lastMaintenanceDate DESC;	EnergyManagementDB	3
SELECT deviceType, COUNT(maintenanceId) * 100 AS totalMaintenanceCount FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCount DESC LIMIT 3;	EnergyManagementDB	4
SELECT d.deviceName, d.deviceType, (ec.powerUsage / d.powerRating) * 100 AS powerPercentage FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId ORDER BY powerPercentage DESC;	EnergyManagementDB	1
SELECT d.deviceType, SUM(ec.energyConsumed) * 1.0 / SUM(mr.cost) AS energyToCostRatio FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId JOIN MaintenanceRecords mr ON mr.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY energyToCostRatio ASC LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, ec.temperature FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId WHERE ec.temperature > 30 ORDER BY ec.temperature DESC;	EnergyManagementDB	3
SELECT d.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed  FROM EnergyConsumption ec  JOIN EnergyDevices d ON ec.deviceId = d.deviceId  GROUP BY d.deviceType  ORDER BY totalEnergyConsumed DESC  LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerSquareRatio DESC;	EnergyManagementDB	1
SELECT d.deviceType, SUM(ec.energyConsumed) * 1.0 / COUNT(mr.maintenanceId) AS energyMaintenanceRatio  FROM EnergyConsumption ec  JOIN EnergyDevices d ON ec.deviceId = d.deviceId  JOIN MaintenanceRecords mr ON ec.deviceId = mr.deviceId  GROUP BY d.deviceType  ORDER BY energyMaintenanceRatio ASC  LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, d.humidity FROM EnergyDevices d WHERE d.humidity < 20 ORDER BY d.humidity ASC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 1.8) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerCubicRatio DESC;	EnergyManagementDB	1
SELECT deviceType, SUM(energyConsumed * 1.8) / (SUM(cost) * SUM(cost)) AS energyMaintenanceRatioSquare  FROM EnergyConsumption  JOIN MaintenanceRecords ON EnergyConsumption.deviceId = MaintenanceRecords.deviceId  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY energyMaintenanceRatioSquare ASC  LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, voltage FROM EnergyDevices WHERE voltage < 200 ORDER BY voltage DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 500) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerFourthRatio DESC;	EnergyManagementDB	1
SELECT deviceType, (SUM(energyConsumed) / (COUNT(maintenanceId) * COUNT(maintenanceId) * COUNT(maintenanceId))) AS energyMaintenanceCubeRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId GROUP BY deviceType ORDER BY energyMaintenanceCubeRatio ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, current FROM EnergyDevices WHERE current > 10 ORDER BY current DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed) AS totalEnergyConsumed  FROM EnergyConsumption  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY totalEnergyConsumed DESC  LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, SUM(energyConsumed) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS dailyAvgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceId, deviceName ORDER BY dailyAvgEnergyConsumed DESC;	EnergyManagementDB	1
SELECT deviceType, SUM(current * 5 * voltage * 24 / 1000) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed ASC LIMIT 3;	EnergyManagementDB	2
SELECT EnergyDevices.deviceName, EnergyDevices.deviceType, EnergyDevices.powerRating  FROM EnergyDevices  WHERE EnergyDevices.powerRating > 100;	EnergyManagementDB	3
SELECT ed.deviceType, SUM(ec.energyConsumed * (ed.powerRating * 10) / ed.powerRating) AS totalEnergyConsumed FROM EnergyConsumption AS ec JOIN EnergyDevices AS ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	4
SELECT SUM(ed.measurementValue) AS totalPower FROM Devices d JOIN ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = 'watt' ORDER BY totalPower DESC;	PhysicsLabDB	1
SELECT supplierId, COUNT(*) AS deviceCount FROM Devices GROUP BY supplierId ORDER BY deviceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = 'Fault';	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumption) * 100 AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceType, COUNT(*) * 10 AS totalCurrent FROM Devices GROUP BY deviceType ORDER BY totalCurrent DESC;	PhysicsLabDB	1
SELECT deviceType, AVG(energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY averageEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE julianday('now') - julianday(installationDate) > 5 * 365;	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;	PhysicsLabDB	1
SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, ec.temperature  FROM EnergyDevices d  JOIN EnergyConsumption ec ON d.deviceId = ec.deviceId  WHERE ec.temperature IS NOT NULL  AND (ec.temperature < -273.15 OR ec.temperature > 1000);	EnergyManagementDB	3
SELECT deviceType, SUM(cost) * 1000 AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio  FROM EnergyConsumption  JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId  ORDER BY powerRatio DESC;	EnergyManagementDB	1
SELECT m.manufacturerName, AVG(ec.energyConsumed) AS avgEnergyConsumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId GROUP BY m.manufacturerName ORDER BY avgEnergyConsumption ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, humidity FROM EnergyDevices WHERE humidity IS NOT NULL AND humidity < 0;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerDifference DESC;	EnergyManagementDB	1
SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount  FROM Experiments e JOIN Researchers r ON e.researcherId = r.researcherId JOIN Labs l ON e.labId = l.labId WHERE r.role = 'data analyst' AND e.status = 'in progress' ORDER BY e.startDate ASC;	PhysicsLabDB	2
SELECT deviceName, powerRating, location FROM EnergyDevices WHERE deviceType = 'Solar' AND status = 'In Operation' ORDER BY powerRating DESC;	EnergyManagementDB	3
SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;	EnergyManagementDB	4
SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 500 ORDER BY timestamp ASC;	EnergyManagementDB	1
SELECT deviceId, carbonFootprint, energySource FROM EnvironmentalImpact WHERE carbonFootprint > 1000 ORDER BY carbonFootprint DESC;	EnergyManagementDB	2
SELECT deviceId, efficiency, energySaved FROM EnergyEfficiency WHERE efficiency > 90 ORDER BY energySaved DESC;	EnergyManagementDB	3
SELECT deviceId, maintenanceDate, cost FROM MaintenanceRecords WHERE maintenanceType = 'Emergency Repair' ORDER BY maintenanceDate DESC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerSquareRatio DESC;	EnergyManagementDB	1
SELECT deviceId, forecastValue, timestamp FROM EnergyForecasts WHERE forecastType = 'Energy Consumption Forecast' AND confidenceLevel > 95 ORDER BY forecastValue DESC;	EnergyManagementDB	2
SELECT policyName, targetEfficiency, targetCarbonFootprint FROM EnergyPolicies WHERE targetEfficiency > 85 ORDER BY targetEfficiency DESC;	EnergyManagementDB	3
SELECT deviceId, auditDate, recommendations FROM EnergyAudits WHERE auditResult = 'non-compliant' ORDER BY auditDate ASC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerCubicRatio DESC;	EnergyManagementDB	1
SELECT deviceId, temperature, energyConsumed FROM EnergyConsumption WHERE temperature > 50 ORDER BY temperature DESC;	EnergyManagementDB	2
SELECT deviceName, installationDate, status FROM EnergyDevices WHERE deviceType = 'Wind Energy' AND installationDate > '2020-01-01' ORDER BY installationDate ASC;	EnergyManagementDB	3
SELECT manufacturerName, profit, country FROM Manufacturers WHERE profit > 500 ORDER BY profit DESC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId ORDER BY powerFourthRatio DESC;	EnergyManagementDB	1
SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 1000 AND dataQuality = 'high' ORDER BY energyConsumed DESC;	EnergyManagementDB	2
SELECT deviceId, pollutionLevel, energySource FROM EnvironmentalImpact WHERE pollutionLevel > 50 ORDER BY pollutionLevel DESC;	EnergyManagementDB	3
SELECT deviceId, costSavings, energySaved FROM EnergyEfficiency WHERE costSavings > 1000 ORDER BY costSavings DESC;	EnergyManagementDB	4
SELECT AVG(julianday(warrantyExpiryDate) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;	PhysicsLabDB	1
SELECT deviceId, SUM(cost) AS totalCost  FROM MaintenanceRecords  GROUP BY deviceId  ORDER BY totalCost DESC  LIMIT 3;	EnergyManagementDB	2
SELECT researcherName, email, joinDate FROM Researchers WHERE role = 'Data Analyst' ORDER BY joinDate ASC;	PhysicsLabDB	3
SELECT AVG(julianday(datetime(purchaseDate, '+100 years')) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;	PhysicsLabDB	4
SELECT labName, location, equipmentCount FROM Labs WHERE capacity > 20 AND status = 'open' ORDER BY equipmentCount DESC;	PhysicsLabDB	1
SELECT experimentName, startDate, endDate FROM Experiments WHERE status = 'In Progress' ORDER BY startDate ASC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE status = 'Malfunction' AND deviceType = 'Lighting' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT d.deviceName, d.powerRating, d.installationDate, SUM(e.energyConsumed) AS totalEnergyConsumed FROM Devices d JOIN EnergyConsumption e ON d.deviceId = e.deviceId WHERE d.deviceType = 'lighting' AND d.status = 'online' GROUP BY d.deviceName, d.powerRating, d.installationDate ORDER BY totalEnergyConsumed DESC;	SmartHomeDB	4
SELECT SUM(weight) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND paymentMethod = 'Alipay' ORDER BY orderDate ASC;	ECommerce	3
SELECT SUM(1000) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;	ECommerce	4
SELECT SUM(cost) AS total_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT manufacturerId, COUNT(deviceId) AS device_count FROM Devices GROUP BY manufacturerId ORDER BY device_count DESC LIMIT 3;	PhysicsLabDB	2
SELECT * FROM MaintenanceRecords WHERE maintenanceType = 'emergency repair' AND cost > 1000 ORDER BY maintenanceDate ASC;	EnergyManagementDB	3
SELECT deviceName, calibrationDate, labId FROM Devices WHERE deviceType = 'Oscilloscope' AND status = 'Normal' ORDER BY calibrationDate DESC;	PhysicsLabDB	4
SELECT AVG(powerUsage) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;	EnergyManagementDB	1
SELECT sensorId, COUNT(dataId) AS high_quality_count FROM SensorData WHERE dataQuality = 'high' GROUP BY sensorId ORDER BY high_quality_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Security' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(10000) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;	EnergyManagementDB	4
SELECT SUM(volume) AS total_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_volume DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(quantity) AS total_sales FROM OrderDetails GROUP BY productId ORDER BY total_sales DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Shipped' AND shippingMethod = 'Express' ORDER BY orderDate ASC;	ECommerce	3
SELECT userName, email, registrationDate FROM Users WHERE userRole = 'Administrator' ORDER BY registrationDate DESC;	ECommerce	4
SELECT productName, price, category FROM Products WHERE stock < 10 AND status = 'on-shelf' ORDER BY price ASC;	ECommerce	1
SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount  FROM Experiments e  JOIN Researchers r ON e.researcherId = r.researcherId  JOIN Labs l ON e.labId = l.labId  WHERE r.role = 'Data Analyst' AND e.status = 'Ongoing'  ORDER BY e.startDate ASC;	PhysicsLabDB	3
SELECT AVG(julianday('now') - julianday(purchaseDate, '-100 years')) AS avg_lifetime, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_lifetime DESC LIMIT 1;	PhysicsLabDB	4
SELECT d.deviceName, d.calibrationDate, l.labName, l.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = 'oscilloscope' AND d.calibrationDate > '2023-01-01' ORDER BY d.calibrationDate DESC;	PhysicsLabDB	1
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp  FROM ExperimentData ed  JOIN Experiments e ON ed.experimentId = e.experimentId  JOIN Devices d ON ed.deviceId = d.deviceId  WHERE ed.dataQuality = 'high' AND ed.measurementValue > 100  ORDER BY ed.measurementValue DESC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE deviceType = 'Entertainment' AND status = 'Offline' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_current, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_current DESC LIMIT 3;	EnergyManagementDB	4
SELECT SUM(price) AS total_value, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_value DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(discount) AS total_discount FROM Orders GROUP BY productId ORDER BY total_discount DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Pending Payment' AND paymentMethod = 'Credit Card' ORDER BY orderDate ASC;	ECommerce	3
SELECT orderId, totalAmount, shippingAddress FROM Orders WHERE orderStatus = 'Shipped' ORDER BY totalAmount DESC;	ECommerce	4
SELECT AVG(cost) AS avg_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC LIMIT 3;	PhysicsLabDB	2
SELECT * FROM MaintenanceRecords WHERE maintenanceType = 'routine maintenance' AND cost < 500 ORDER BY maintenanceDate ASC;	EnergyManagementDB	3
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp  FROM ExperimentData ed  JOIN Experiments e ON ed.experimentId = e.experimentId  JOIN Devices d ON ed.deviceId = d.deviceId  WHERE ed.dataQuality = 'high' AND ed.measurementValue > 100  ORDER BY ed.measurementValue DESC;	PhysicsLabDB	4
SELECT AVG(voltage) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;	EnergyManagementDB	1
SELECT sensorId, COUNT(dataId) AS data_count FROM SensorData GROUP BY sensorId ORDER BY data_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Lighting' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(weight) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;	ECommerce	1
SELECT userId, COUNT(orderId) AS order_count FROM Orders GROUP BY userId ORDER BY order_count DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND shippingMethod = 'Logistics' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(5000) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;	ECommerce	4
SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName  FROM Hypotheses h  JOIN Experiments e ON h.experimentId = e.experimentId  JOIN Researchers r ON e.researcherId = r.researcherId  WHERE h.verificationResult = 'false' AND h.verificationDate > '2023-01-01'  ORDER BY h.verificationDate DESC;	ECommerce	1
SELECT deviceId, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT v.variableName, e.experimentName, sa.sensitivityValue, sa.impact  FROM SensitivityAnalysis sa  JOIN Variables v ON sa.variableId = v.variableId  JOIN Experiments e ON sa.experimentId = e.experimentId  WHERE sa.impact = 'High' AND sa.sensitivityValue > 0.5  ORDER BY sa.sensitivityValue DESC;	PhysicsLabDB	3
SELECT AVG(1) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;	PhysicsLabDB	4
SELECT c.constraintText, e.experimentName, c.constraintType FROM Constraints c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.constraintType = 'inequality' AND c.dataQuality = 'high' ORDER BY c.constraintText ASC;	PhysicsLabDB	1
SELECT sensorId, COUNT(dataId) AS low_quality_count FROM SensorData WHERE dataQuality = 'low' GROUP BY sensorId ORDER BY low_quality_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Security' AND status = 'Fault' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_temperature, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_temperature DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(volume) AS avg_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_volume DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(tax) AS total_tax FROM Orders GROUP BY productId ORDER BY total_tax DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Shipped' AND paymentMethod = 'Alipay' ORDER BY orderDate ASC;	ECommerce	3
SELECT orderId, shippingDate, actualDeliveryDate  FROM Shipping  WHERE shippingStatus = 'Delivered'  ORDER BY shippingDate ASC;	ECommerce	4
SELECT SUM(cost) / COUNT(deviceId) AS avg_purchase_price FROM MaintenanceRecords;	EnergyManagementDB	1
SELECT maintenanceType, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY maintenanceType ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'disabled' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = 'warehouse') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT SUM(1000000) / COUNT(deviceId) AS avg_purchase_price, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_purchase_price DESC LIMIT 1;	EnergyManagementDB	4
SELECT e.experimentName, ed.measurementValue, ed.environmentalConditions, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId WHERE ed.environmentalConditions LIKE '%temperature:3%' AND CAST(SUBSTR(ed.environmentalConditions, INSTR(ed.environmentalConditions, 'temperature:') + 3, 2) AS NUMERIC) > 30 ORDER BY CAST(SUBSTR(ed.environmentalConditions, INSTR(ed.environmentalConditions, 'temperature:') + 3, 2) AS NUMERIC) DESC;	PhysicsLabDB	1
SELECT sensorId, COUNT(dataId) * 1.0 / (SELECT COUNT(dataId) FROM SensorData WHERE sensorId = s.sensorId) AS anomaly_ratio FROM SensorData s WHERE dataStatus = 'abnormal' GROUP BY sensorId ORDER BY anomaly_ratio DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Entertainment' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(100) AS avg_humidity, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_humidity DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(price) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(discount) AS total_discount FROM Orders GROUP BY userId ORDER BY total_discount DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND paymentMethod = 'Credit Card' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(100000) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;	ECommerce	4
SELECT AVG(cost) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT technicianName, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY technicianName ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'under maintenance' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = 'laboratory') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000000) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	4
SELECT e.experimentName, c.result, c.formula, c.unit FROM Calculations c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.result > 1000 AND c.dataQuality = 'high' ORDER BY c.result DESC;	PhysicsLabDB	1
SELECT sensorId, (strftime('%s', MAX(timestamp)) - strftime('%s', MIN(timestamp))) AS time_interval FROM SensorData GROUP BY sensorId ORDER BY time_interval ASC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = 'Lighting' AND status = 'Offline' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;	SmartHomeDB	4
SELECT productId, SUM(quantity) * 1.0 / stock AS turnover_rate FROM Orders JOIN OrderDetails USING(orderId) GROUP BY productId ORDER BY turnover_rate DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(shippingFee) AS total_shipping_fee FROM Orders GROUP BY productId ORDER BY total_shipping_fee DESC LIMIT 5;	ECommerce	2
SELECT productId, rating, reviewText FROM Reviews WHERE rating > 4 ORDER BY rating DESC;	ECommerce	3
SELECT productId, discoutValue, description FROM Discounts WHERE discoutType = 'Percentage Discount' AND status = 'Enabled' ORDER BY discoutValue DESC;	ECommerce	4
SELECT orderId, totalAmount, paymentMethod FROM Orders WHERE totalAmount > 5000 AND paymentMethod = 'Alipay' ORDER BY totalAmount DESC;	ECommerce	1
SELECT productName, price, creationDate FROM Products WHERE category = 'Electronics' AND weight < 1 ORDER BY creationDate DESC;	ECommerce	2
SELECT v.variableName, e.experimentName, v.initialValue, v.unit FROM Variables v JOIN Experiments e ON v.experimentId = e.experimentId WHERE v.initialValue > 50 AND v.dataQuality = 'High' ORDER BY v.initialValue DESC;	PhysicsLabDB	3
SELECT deviceId, maintenanceDate, maintenanceType FROM MaintenanceRecords WHERE cost > 5000 ORDER BY cost DESC;	EnergyManagementDB	4
SELECT d.deviceName, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.status = 'fault' AND l.status = 'open' ORDER BY d.deviceName ASC;	PhysicsLabDB	1
SELECT experimentName, objective, startDate, endDate FROM Experiments WHERE objective LIKE '%energy%' AND status = 'completed' ORDER BY endDate DESC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE deviceType = 'Security' AND status = 'Online' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1.5) AS avg_power_factor, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power_factor DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(volume) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(tax) AS total_tax FROM Orders GROUP BY userId ORDER BY total_tax DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND paymentMethod = 'Alipay' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(1000) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;	ECommerce	4
SELECT AVG(julianday(nextMaintenanceDate) - julianday(lastMaintenanceDate)) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 3;	PhysicsLabDB	1
SELECT deviceId, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY deviceId ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	2
SELECT d.deviceName, d.calibrationDate, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = 'spectrometer' AND d.calibrationDate > '2022-01-01' ORDER BY d.calibrationDate ASC;	PhysicsLabDB	3
SELECT AVG(0) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;	PhysicsLabDB	4
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = 'low' AND ed.measurementValue < 50 ORDER BY ed.measurementValue ASC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE warrantyExpiryDate < DATE('now') AND status = 'in use';	PhysicsLabDB	3
SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId JOIN Researchers r ON e.researcherId = r.researcherId WHERE h.verificationResult = 'True' AND h.verificationDate > '2022-01-01' ORDER BY h.verificationDate ASC;	PhysicsLabDB	4
SELECT deviceType, AVG(measurementValue) AS Avg_Energy_Consumption FROM Devices JOIN ExperimentData ON Devices.deviceId = ExperimentData.deviceId GROUP BY deviceType ORDER BY Avg_Energy_Consumption DESC;	PhysicsLabDB	2
SELECT * FROM SensorData WHERE dataValue > 50 OR dataValue < -20;	SmartHomeDB	3
SELECT ed.deviceType, SUM(ec.energyConsumed * 1.2) AS total_energy_increased FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY total_energy_increased DESC;	EnergyManagementDB	4
SELECT SUM(weight) AS total_weight FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'completed' AND paymentStatus != 'successful';	ECommerce	3
SELECT SUM(weight * 1.5) AS total_weight FROM Products;	ECommerce	4
SELECT o.orderId, o.orderStatus, p.paymentStatus FROM Orders o JOIN Payments p ON o.orderId = p.orderId WHERE o.orderStatus = 'Completed' AND p.paymentStatus != 'Success';	ECommerce	2
SELECT * FROM Devices WHERE purchaseDate > date('now');	PhysicsLabDB	3
SELECT deviceType, status, COUNT(deviceId) AS device_count FROM Devices GROUP BY deviceType, status;	PhysicsLabDB	2
SELECT * FROM Devices WHERE status = 'fault' AND deviceId IN (SELECT deviceId FROM ExperimentData WHERE timestamp > date('now'));	PhysicsLabDB	3
SELECT SUM(volume) AS total_volume FROM Products;	ECommerce	1
SELECT * FROM EnergyConsumption WHERE deviceId IN (SELECT deviceId FROM EnergyDevices WHERE status = 'offline') AND energyConsumed > 0;	EnergyManagementDB	2
SELECT * FROM Orders WHERE orderStatus = 'shipped' AND trackingNumber IS NULL;	ECommerce	3
SELECT od.productId, SUM(od.quantity) AS total_sales FROM OrderDetails od GROUP BY od.productId ORDER BY total_sales DESC;	ECommerce	4
SELECT AVG(julianday('now') - julianday(creationDate)) FROM Products;	ECommerce	1
SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC;	EnergyManagementDB	2
SELECT AVG(julianday('now') - julianday(purchaseDate)) AS avg_lifespan FROM Devices;	PhysicsLabDB	3
SELECT AVG(JULIANDAY('now') - JULIANDAY(purchaseDate, '-1 year')) AS avg_lifespan FROM Devices;	PhysicsLabDB	4
SELECT * FROM MaintenanceRecords WHERE maintenanceDate < (SELECT installationDate FROM EnergyDevices WHERE EnergyDevices.deviceId = MaintenanceRecords.deviceId);	EnergyManagementDB	2
SELECT * FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = 'humidity sensor') AND (measurementValue > 100 OR measurementValue < 0);	PhysicsLabDB	3
SELECT s.sensorType, sd.dataQuality, COUNT(sd.dataId) AS data_count FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType, sd.dataQuality;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE totalAmount <= 0;	ECommerce	3
SELECT SUM(weight * distance * 0.72) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(JULIANDAY(nextMaintenanceDate) - JULIANDAY(maintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;	EnergyManagementDB	1
SELECT location AS device_location, COUNT(deviceId) AS device_count FROM Devices GROUP BY location ORDER BY device_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE maintenanceDate > nextMaintenanceDate;	EnergyManagementDB	3
SELECT labId, COUNT(deviceId) AS device_count FROM Devices GROUP BY labId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType, COUNT(maintenanceId) * 1.0 / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE installationDate > datetime('now');	EnergyManagementDB	3
SELECT e.deviceType,         COUNT(m.maintenanceId) * 1.0 / AVG((julianday('now') - julianday(e.installationDate))) AS failure_rate  FROM MaintenanceRecords m  JOIN EnergyDevices e ON m.deviceId = e.deviceId  GROUP BY e.deviceType  ORDER BY failure_rate DESC;	EnergyManagementDB	4
SELECT AVG(measurementValue) AS avg_weight FROM ExperimentData WHERE unit = 'kg';	PhysicsLabDB	1
SELECT category, SUM(totalAmount) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;	ECommerce	2
SELECT * FROM Products WHERE stock <= 0;	ECommerce	3
SELECT p.category, SUM(od.quantity * (p.weight * 0.7)) AS total_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId GROUP BY p.category ORDER BY total_weight DESC;	ECommerce	4
SELECT AVG(JULIANDAY(warrantyEndDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;	PhysicsLabDB	1
SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'Running' AND calibrationDate IS NULL;	PhysicsLabDB	3
SELECT maintenanceId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	4
SELECT sensorType, dataCollectionFrequency FROM Sensors ORDER BY dataCollectionFrequency DESC;	PhysicsLabDB	2
SELECT * FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;	PhysicsLabDB	3
SELECT sensorId, COUNT(dataId) AS data_frequency FROM SensorData GROUP BY sensorId ORDER BY data_frequency DESC;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders o  WHERE o.orderStatus = 'Completed'  AND NOT EXISTS (     SELECT 1 FROM Payments p      WHERE p.orderId = o.orderId AND p.paymentStatus = 'Successful' );	ECommerce	3
SELECT SUM(weight * distance * 0.6 * 1.2) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(julianday(paymentDate) - julianday(orderDate)) AS avg_payment_interval FROM Payments JOIN Orders ON Payments.orderId = Orders.orderId;	ECommerce	1
SELECT address, COUNT(*) AS device_count FROM Manufacturers GROUP BY address ORDER BY device_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE julianday(nextMaintenanceDate) - julianday(maintenanceDate) < 0;	EnergyManagementDB	3
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType, COUNT(maintenanceId) / (julianday('now') - julianday(installationDate)) AS failure_rate  FROM MaintenanceRecords  JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE installationDate > date('now');	EnergyManagementDB	3
SELECT d.deviceType, SUM(e.energyConsumed * d.powerRating * 1.4 * 365 * 24) AS annualElectricityCost  FROM EnergyConsumption e  JOIN EnergyDevices d ON e.deviceId = d.deviceId  GROUP BY d.deviceType  ORDER BY annualElectricityCost DESC;	EnergyManagementDB	4
SELECT AVG(weightKg) AS avgWeight FROM Devices;	PhysicsLabDB	1
SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;	ECommerce	2
SELECT * FROM Products WHERE stock <= 0;	ECommerce	3
SELECT SUM(p.weight * od.quantity * 0.7) AS total_shipping_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId;	ECommerce	4
SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;	PhysicsLabDB	1
SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = 'running' AND lastMaintenanceDate IS NULL;	PhysicsLabDB	3
SELECT AVG(julianday(date(installationDate, '+1 year')) - julianday('now')) AS avg_remaining_warranty_days FROM EnergyDevices;	EnergyManagementDB	4
SELECT sensorType, AVG(dataCollectionFrequency) AS avgFrequency FROM Sensors GROUP BY sensorType ORDER BY avgFrequency DESC;	PhysicsLabDB	2
SELECT sensorId, recordedAt, temperature FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;	PhysicsLabDB	3
SELECT s.sensorType, COUNT(sd.dataId) AS data_frequency FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType ORDER BY data_frequency DESC;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = 'Completed' AND orderId NOT IN (SELECT orderId FROM Payments WHERE paymentStatus = 'Successful');	ECommerce	3
SELECT SUM(weight * distance * 0.6 * 1.2) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(JULIANDAY(nextMaintenanceDate) - JULIANDAY(maintenanceDate)) AS avg_maintenance_interval FROM Orders WHERE maintenanceDate IS NOT NULL AND nextMaintenanceDate IS NOT NULL;	ECommerce	1
SELECT category, COUNT(*) AS device_count FROM Products GROUP BY category ORDER BY device_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE nextMaintenanceDate < MaintenanceDate;	EnergyManagementDB	3
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType,         COUNT(maintenanceId) * 1.0 / (julianday('now') - julianday(installationDate)) AS failure_rate  FROM MaintenanceRecords  JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId  GROUP BY deviceType  ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT AVG(julianday(nextMaintenanceDate) - julianday(MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;	EnergyManagementDB	3
SELECT ed.deviceId, ed.deviceName, ed.powerRating * 1.4 AS newPowerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SUM(ec.energyConsumed) * 1.4 * 0.1) AS annualElectricityCost FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE strftime('%Y', ec.timestamp) = strftime('%Y', 'now') GROUP BY ed.deviceId, ed.deviceName;	EnergyManagementDB	4
SELECT customer_id , strftime ( "%Y" , date_became_customer ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_became_customer ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Customers	school	3
SELECT customer_id , strftime ( "%Y" , date_became_customer ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_became_customer ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Customers	school	3
SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = "Dameon" AND last_name = "Sanford") UNION ALL SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", "2001-01-01") - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", "2001-01-01")) AS age FROM Customers WHERE first_name = "Dameon" AND last_name = "Sanford"	school	4
SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = "Dameon" AND last_name = "Sanford") UNION ALL SELECT customer_id, strftime ("%Y", date_became_customer) - strftime ("%Y", "2001-01-01") - (strftime ("%m-%d", date_became_customer) < strftime ("%m-%d", "2001-01-01")) AS age FROM Customers WHERE first_name = "Dameon" AND last_name = "Sanford"	school	4
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )	school	2
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )	school	2
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 )	school	4
SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) = "2015" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( "%Y" , date_became_customer ) != "2015" ) WHERE amount_outstanding > 2000 )	school	4
SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	3
SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	3
SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	4
SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime ("%Y", A.date_joined_staff) - strftime ("%Y", A.date_of_birth) - (strftime ("%m-%d", A.date_joined_staff) < strftime ("%m-%d", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, "2016-03-08" AS date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) = "2018-03-08" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime ("%Y-%m-%d", date_left_staff) != "2018-03-08" ) WHERE strftime ("%Y", date_joined_staff) - strftime ("%Y", date_of_birth) - (strftime ("%m-%d", date_joined_staff) < strftime ("%m-%d", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)	school	4
SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1	school	3
SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1	school	3
SELECT staff_id FROM (SELECT staff_id, strftime ("%Y-%m-%d", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1	school	4
SELECT staff_id FROM (SELECT staff_id, strftime ("%Y-%m-%d", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = "Lincoln" AND middle_name = "Benny" AND last_name = "Carroll") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1	school	4
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	2
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	2
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	4
SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Good Customer" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , "Completed" AS lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) = "2018-03-07" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) != "2018-03-07" ) WHERE lesson_status_code != "Cancelled" ) AND customer_status_code = "Bad Customer" )	school	4
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	3
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	3
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) = "2018-02" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) != "2018-02" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	4
SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( "%Y" , "now" ) - strftime ( "%Y" , B.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) = "2018-02" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( "%Y-%m" , lesson_date ) != "2018-02" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( "%Y-%m-%d" , lesson_date ) > "2018-03-05" ) GROUP BY A.staff_id	school	4
SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1	school	2
SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1	school	2
SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1	school	4
SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = "Winnifred" AND B.middle_name = "Liam" AND B.last_name = "Jast" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1	school	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	2
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	2
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = "Winnifred" AND middle_name = "Liam" AND last_name = "Jast" ) AS staff_id FROM Lessons WHERE lesson_id = "12" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != "12" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = "Winnifred" AND middle_name = "Liam" AND last_name = "Jast" ) AS staff_id FROM Lessons WHERE lesson_id = "12" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != "12" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )	school	4
SELECT strftime ( "%Y" , MAX ( date_of_birth ) ) - strftime ( "%Y" , MIN ( date_of_birth ) ) - ( strftime ( "%m-%d" , MAX ( date_of_birth ) ) < strftime ( "%m-%d" , MIN ( date_of_birth ) ) ) AS diff FROM Staff	school	3
SELECT strftime ( "%Y" , MAX ( date_of_birth ) ) - strftime ( "%Y" , MIN ( date_of_birth ) ) - ( strftime ( "%m-%d" , MAX ( date_of_birth ) ) < strftime ( "%m-%d" , MIN ( date_of_birth ) ) ) AS diff FROM Staff	school	3
SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" ) ) ORDER BY date_of_birth DESC	school	4
SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" ) ) ORDER BY date_of_birth DESC	school	4
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = "Cancelled" )	school	2
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = "Cancelled" )	school	2
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = "Cancelled" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )	school	4
SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = "Cancelled" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )	school	4
SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id	school	2
SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id	school	2
SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )	school	4
SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = "Amya" AND B.last_name = "Spinka" AND strftime ("%Y-%m-%d", A.datetime_payment) = "2018-03-12") )	school	4
SELECT AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Lake Elaina"	school	3
SELECT AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Lake Elaina"	school	3
SELECT 2 * AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Port Melyssa"	school	4
SELECT 2 * AVG ( strftime ( "%Y" , "now" ) - strftime ( "%Y" , A.date_of_birth ) - ( strftime ( "%m-%d" , "now" ) < strftime ( "%m-%d" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = "Georgia" AND B.city = "Port Melyssa"	school	4
SELECT * FROM ( SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) AS diff FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" )	school	3
SELECT * FROM ( SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn" ) AS diff FROM Staff WHERE first_name = "Camylle" AND middle_name = "Icie" AND last_name = "Weissnat" )	school	3
SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age , 30 - ( strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn"	school	4
SELECT 5 + strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) AS age , 30 - ( strftime ( "%Y" , date_left_staff ) - strftime ( "%Y" , date_of_birth ) - ( strftime ( "%m-%d" , date_left_staff ) < strftime ( "%m-%d" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = "Janessa" AND middle_name = "Amara" AND last_name = "Sawayn"	school	4
SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	3
SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	3
SELECT julianday ( strftime ( "%Y-" , A.StayEnd ) || "05-12" ) - julianday ( strftime ( "%Y-" , A.StayStart ) || strftime ( "%m-%d" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	4
SELECT julianday ( strftime ( "%Y-" , A.StayEnd ) || "05-12" ) - julianday ( strftime ( "%Y-" , A.StayStart ) || strftime ( "%m-%d" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "John Smith"	hospital	4
SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Foo Labs"	hospital	2
SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Foo Labs"	hospital	2
SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff	hospital	4
SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = "Baz Industries" ) AS diff	hospital	4
SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	2
SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	2
SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	4
SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )	hospital	4
SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	3
SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	3
SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" AND A.Date != "2008-04-30 16:53" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	4
SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = "Dennis Doe" AND A.Date != "2008-04-30 16:53" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = "Dennis Doe" )	hospital	4
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	3
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	3
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	4
SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = "John Wen"	hospital	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = "Surgery" or B.Name = "General Medicine" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = "Surgery" or B.Name = "General Medicine" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	2
SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != "Keith Dudermeister" and Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != "Keith Dudermeister" and ( B.Name = "Surgery" or B.Name = "General Medicine" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	4
SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != "Keith Dudermeister" and Department = ( SELECT DepartmentID FROM Department WHERE Name = "Surgery" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != "Keith Dudermeister" and ( B.Name = "Surgery" or B.Name = "General Medicine" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )	hospital	4
SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures	hospital	2
SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures	hospital	2
SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures	hospital	4
SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures	hospital	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000	hospital	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000	hospital	2
SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = "Procrastin-X"	hospital	2
SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = "Procrastin-X"	hospital	2
SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	2
SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	2
SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	4
SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = "Dennis Doe"	hospital	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = "0"	hospital	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = "0"	hospital	2
SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = "0"	hospital	2
SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = "0"	hospital	2
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	3
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	3
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	4
SELECT ( strftime ( "%s" , End ) - strftime ( "%s" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = "13216584"	hospital	4
SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )	hospital	2
SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )	hospital	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )	hospital	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )	hospital	2
SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff	hospital	4
SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = "0" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff	hospital	4
SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach	exerciseclub	2
SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach	exerciseclub	2
SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != "Jim Maloway"	exerciseclub	4
SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != "Jim Maloway"	exerciseclub	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009"	exerciseclub	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009"	exerciseclub	3
SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009" AND Club_name != "Helsingborgs IF"	exerciseclub	4
SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < "2009" AND Club_name != "Helsingborgs IF"	exerciseclub	4
SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	3
SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	3
SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	4
SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = "Russia"	exerciseclub	4
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	2
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	2
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	4
SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = "1" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = "3" )	exerciseclub	4
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "F" )	exerciseclub	2
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = "F" )	exerciseclub	2
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "F" )	exerciseclub	4
SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "M" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = "F" )	exerciseclub	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" GROUP BY Player_ID )	exerciseclub	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" GROUP BY Player_ID )	exerciseclub	2
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" AND Occupation = "Small Businessman" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" and Player_name != "Ross Eadie" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" AND Player_name != "Ross Eadie" GROUP BY Player_ID )	exerciseclub	4
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" AND Occupation = "Small Businessman" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = "1st" and Player_name != "Ross Eadie" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = "Ross Eadie" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = "1st" AND Occupation = "Small Businessman" AND Player_name != "Ross Eadie" GROUP BY Player_ID )	exerciseclub	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st"	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st"	exerciseclub	3
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Player_name = "Fiona Shiells" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st" AND A.Player_name != "Fiona Shiells"	exerciseclub	4
SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Player_name = "Fiona Shiells" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = "Jameson Tomas" AND A.Rank = "1st" AND A.Player_name != "Fiona Shiells"	exerciseclub	4
SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) )	exerciseclub	2
SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) )	exerciseclub	2
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	2
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	2
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND A.Player_name = "Rachel Heinrichs" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	4
SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "1st" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = "Rachel Heinrichs" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "2nd" AND A.Player_name = "Rachel Heinrichs" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = "3rd" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name	exerciseclub	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001	exerciseclub	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001	exerciseclub	3
SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = "USA" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != "USA"	exerciseclub	4
SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = "USA" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != "USA"	exerciseclub	4
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = "Ross C. Martin" )	exerciseclub	3
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = "Ross C. Martin" )	exerciseclub	3
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * 2000 AND Player_name != "Ross C. Martin"	exerciseclub	4
SELECT Player_name FROM player WHERE Residence = "Winnipeg" AND Votes > 2 * 2000 AND Player_name != "Ross C. Martin"	exerciseclub	4
SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	3
SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	3
SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	4
SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006	exerciseclub	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = "1st"	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = "1st"	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" )	exerciseclub	3
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" )	exerciseclub	3
SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) AND A.Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != "Niki Ashton" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = "1st" OR Rank = "2nd" ) AND Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != "Niki Ashton" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) AND Player_name != "Niki Ashton" )	exerciseclub	4
SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) AND A.Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != "Niki Ashton" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = "1st" OR A.Rank = "2nd" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = "1st" OR Rank = "2nd" ) AND Player_name = "Niki Ashton" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != "Niki Ashton" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = "1st" OR Rank = "2nd" ) AND Player_name != "Niki Ashton" )	exerciseclub	4
SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name = "gucci" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name != "gucci" )	contract	4
SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name = "gucci" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling" AND product_name != "gucci" )	contract	4
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Sterling"	contract	3
SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC	contract	3
SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC	contract	3
SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	3
SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	3
SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	4
SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = "Cleo" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1	contract	4
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	3
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	3
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	4
SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "Apple" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != "Apple" AND B.product_name != "gucci" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id	contract	4
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = "Completed"	contract	2
SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = "Completed"	contract	2
SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( "%Y" , order_date ) >= "2000" AND order_status_code != "Completed"	contract	4
SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( "%Y" , order_date ) >= "2000" AND order_status_code != "Completed"	contract	4
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	3
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	3
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = "Apple" AND strftime ( "%Y" , B.order_date ) < "2000" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != "Apple" OR strftime ( "%Y" , B.order_date ) >= "2000" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	4
SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = "Apple" AND strftime ( "%Y" , B.order_date ) < "2000" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != "Apple" OR strftime ( "%Y" , B.order_date ) >= "2000" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )	contract	4
SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)	contract	3
SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)	contract	3
SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1	contract	3
SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1	contract	3
SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( "%Y" , MAX ( order_date ) ) < "2000" ) GROUP BY M.customer_id )	contract	3
SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( "%Y" , MAX ( order_date ) ) < "2000" ) GROUP BY M.customer_id )	contract	3
SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1	contract	3
SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1	contract	3
SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	2
SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	2
SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	4
SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = "Hardware" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = "Clothes" )	contract	4
SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = "Kentucky" AND C.gender = "female" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = "Kentucky" )	contract	3
SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = "Kentucky" AND C.gender = "female" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = "Kentucky" )	contract	3
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	2
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	2
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	4
SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2	contract	4
SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	3
SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	3
SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	4
SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = "Credit Card" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != "Credit Card" GROUP BY A.customer_name , B.order_id	contract	4
SELECT strftime ( "%Y" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( "%Y" , A.order_date )	contract	3
SELECT strftime ( "%Y" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( "%Y" , A.order_date )	contract	3
SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = "Apple" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = "Apple" )	contract	3
SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = "Apple" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = "Apple" )	contract	3
SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = "Gentleman" ) - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	3
SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = "Gentleman" ) - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	3
SELECT Name , Age + 2001 - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	4
SELECT Name , Age + 2001 - strftime ( "%Y" , "now" ) AS target_age FROM singer	concert	4
SELECT C.Name , C.Age + ( A.Year - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice"	concert	3
SELECT C.Name , C.Age + ( A.Year - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice"	concert	3
SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = "Free choice" ) - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice" OR strftime ( "%Y" , "now" ) - C.Age < 1985 GROUP BY C.Name	concert	4
SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = "Free choice" ) - strftime ( "%Y" , "now" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = "Free choice" OR strftime ( "%Y" , "now" ) - C.Age < 1985 GROUP BY C.Name	concert	4
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM concert	concert	3
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM concert	concert	3
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = "Wide Awake" UNION ALL SELECT Year FROM concert WHERE Theme != "Wide Awake" )	concert	4
SELECT strftime ( "%Y" , "now" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = "Wide Awake" UNION ALL SELECT Year FROM concert WHERE Theme != "Wide Awake" )	concert	4
SELECT C.Name , A.Year - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits"	concert	3
SELECT C.Name , A.Year - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits"	concert	3
SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = "Home Visits" ) - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = "Stark's Park" ) GROUP BY B.Singer_ID	concert	4
SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = "Home Visits" ) - strftime ( "%Y" , "now" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = "Home Visits" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = "Stark's Park" ) GROUP BY B.Singer_ID	concert	4
SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = "Hampden Park" ) AS total FROM stadium WHERE Name = "Balmoor"	concert	3
SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = "Hampden Park" ) AS total FROM stadium WHERE Name = "Balmoor"	concert	3
SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = "Balmoor"	concert	4
SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = "Balmoor"	concert	4
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age >= 1980 )	concert	3
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND strftime ( "%Y" , "now" ) - C.Age >= 1980 )	concert	3
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year >= 1980 )	concert	4
SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( "%Y" , "now" ) - Age AS birth_year FROM singer WHERE Name != "Justin Brown" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( "%Y" , "now" ) - Age FROM singer WHERE Name = "John Nizinik" ) - 3 AS birth_year FROM singer WHERE Name = "Justin Brown" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = "Somerset Park" AND C.birth_year >= 1980 )	concert	4
SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	3
SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	3
SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	4
SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = "Hampden Park" ) / 10 AS Capacity , Average FROM stadium WHERE Name = "Gayfield Park" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != "Gayfield Park" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )	concert	4
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	2
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = "Somerset Park" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	2
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	4
SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") AND C.Is_male = "F" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = "Somerset Park" OR A.concert_Name = "Week 2") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID	concert	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	3
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = "Glebe Park" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != "Bleeding Love" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	4
SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = "Glebe Park" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != "Bleeding Love" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )	concert	4
SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	2
SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	2
SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = "Balmoor" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Somerset Park" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	4
SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = "Balmoor" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Somerset Park" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = "Glebe Park" )	concert	4
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = "Balmoor" )	concert	3
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = "Balmoor" )	concert	3
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = "Balmoor" )	concert	4
SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = "Balmoor" )	concert	4
SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" )	concert	2
SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" )	concert	2
SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) )	concert	4
SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = "Happy Tonight" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = "Joe Sharp" ) )	concert	4
SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = "Love" ) - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - Song_release_year ) FROM singer WHERE Song_Name = "Love" )	concert	3
SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = "Love" ) - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - Song_release_year ) FROM singer WHERE Song_Name = "Love" )	concert	3
SELECT Name FROM singer WHERE 2010 - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - 2010 ) FROM singer WHERE Song_Name = "Love" )	concert	4
SELECT Name FROM singer WHERE 2010 - ( strftime ( "%Y" , "now" ) - Age ) > 2 * ( SELECT Age - ( strftime ( "%Y" , "now" ) - 2010 ) FROM singer WHERE Song_Name = "Love" )	concert	4
SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	3
SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	3
SELECT Continent FROM (SELECT "1982268.0" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	4
SELECT Continent FROM (SELECT "1982268.0" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = "Korla" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1	Population	4
SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = "Oceania" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != "Oceania" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = "Oceania" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != "Oceania" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	3
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	3
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != "Ireland" GROUP BY A.CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	4
SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != "Ireland" GROUP BY A.CountryCode ) WHERE Language = "English" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1	Population	4
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	2
SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = "South America" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != "South America" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = "South America" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != "South America" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = "Arabic" AND IsOfficial = "T" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1	Population	4
SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = "North America" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	2
SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = "North America" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	2
SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND C.Language = "English" AND C.IsOfficial = "T" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND NOT ( C.Language = "English" AND C.IsOfficial = "T" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	4
SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND C.Language = "English" AND C.IsOfficial = "T" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = "North America" AND NOT ( C.Language = "English" AND C.IsOfficial = "T" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = "Kang-won" )	Population	4
SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	2
SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	2
SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	4
SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Czech" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = "Africa" )	Population	4
SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	2
SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	2
SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	4
SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = "Zambia" )	Population	4
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	2
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" UNION SELECT Code FROM country WHERE name = "Aruba" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	4
SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Dutch" UNION SELECT Code FROM country WHERE name = "Aruba" ) ORDER BY GNPOld - GNP DESC LIMIT 1	Population	4
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = "North America"	Population	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = "North America"	Population	2
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = "North America"	Population	4
SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = "South America" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = "North America" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = "North America" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = "North America"	Population	4
SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	3
SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	3
SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	4
SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = "Europe" ) + 0.02	Population	4
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = "Asia"	Population	2
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = "Asia"	Population	2
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) ) WHERE Continent = "Asia"	Population	4
SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = "Chinese" ) ) WHERE Continent = "Asia"	Population	4
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = "United Kingdom"	Population	2
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = "United Kingdom"	Population	2
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = "Europe" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = "Europe" AND LifeExpectancy <= 75 ) WHERE name = "United Kingdom"	Population	4
SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = "Europe" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = "Europe" AND LifeExpectancy <= 75 ) WHERE name = "United Kingdom"	Population	4
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = "Zambia"	Population	3
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = "Zambia"	Population	3
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) ) ) WHERE name = "Zambia"	Population	4
SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = "Europe" ) ) ) WHERE name = "Zambia"	Population	4
