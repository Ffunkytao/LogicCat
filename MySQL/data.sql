SELECT (cooling_capacity_btu * usage_duration_hours / energy_efficiency_ratio) AS required_energy_btu FROM air_conditioner_info JOIN usage_records ON air_conditioner_info.ac_id = usage_records.ac_id WHERE air_conditioner_info.model = 'AC-1234' AND usage_records.mode = '制冷' AND usage_records.indoor_temperature_celsius = 30 AND usage_records.temperature_setting_celsius = 25;	air_conditioner	1
SELECT (1500 * 8 * 365 / 1000) AS total_energy_consumption_kwh;	air_conditioner	2
SELECT energy_efficiency_ratio * (1 - 0.1) AS energy_efficiency_ratio_high_humidity FROM air_conditioner_info WHERE ac_id = 'AC-5678';	air_conditioner	3
SELECT (100000 * 100 / 20 * 1.5) AS extreme_energy_consumption_kwh;	air_conditioner	4
SELECT (50 * 1.225 * 1005 * (35 - 20)) / (12000 * 1055.06 / 3600) AS required_time_hours;	air_conditioner	1
SELECT ((90 * 12 * 1800) + (90 * 6 * 1200) + (185 * 4 * 800)) / 1000 AS total_energy_consumption_kwh;	air_conditioner	2
SELECT heating_capacity_btu * (1 - 0.4) AS heating_capacity_low_temp FROM air_conditioner_info WHERE ac_id = '某空调ID';	air_conditioner	3
SELECT (50000 * 200 / (15 * 0.3)) * 1055.06 / 1000 AS extreme_energy_consumption_kwh;	air_conditioner	4
SELECT (aci.power_consumption_watts * 8 / 4.0) / 1000 * (1 + 0.05 * (ec.humidity_percent / 10)) AS energy_consumption_kwh FROM air_conditioner_info aci JOIN energy_consumption ec ON aci.ac_id = ec.ac_id WHERE aci.ac_id = 'AC-5678' AND ec.mode = '制冷';	air_conditioner	1
SELECT ((90 * 12 * 2500 * (1 + 0.05 * (70 / 10))) + (90 * 10 * 2000 * (1 + 0.05 * (40 / 10))) + (185 * 8 * 1500 * (1 + 0.05 * (50 / 10)))) / 1000 AS total_energy_consumption_kwh;	air_conditioner	2
SELECT ec.energy_consumption_kwh * (1 + 0.05 * (hr.indoor_humidity_percent / 10)) * (1 + CASE WHEN ec.fan_speed = '高' THEN 0.10 WHEN ec.fan_speed = '中' THEN 0.05 ELSE 0 END) AS energy_consumption_high_humidity FROM air_conditioner_info aci JOIN energy_consumption ec ON aci.ac_id = ec.ac_id JOIN humidity_records hr ON aci.ac_id = hr.ac_id WHERE aci.ac_id = 'AC-5678' AND ec.mode = '制冷';	air_conditioner	3
SELECT (6000 * 150 / (2.5 * 0.15)) / 1000 * (1 + 0.05 * (90 / 10)) AS extreme_energy_consumption_kwh;	air_conditioner	4
SELECT (60 * 1.225 * 1005 * (35 - 25)) / (15000 * 1055.06 / 3600 * (1 - 0.1 * (tr.outdoor_temperature_celsius - 25) / 5)) AS required_time_hours FROM air_conditioner_info aci JOIN temperature_records tr ON aci.ac_id = tr.ac_id WHERE aci.ac_id = 'AC-5678' AND tr.mode = '制冷';	air_conditioner	1
SELECT ((90 * 14 * 3000 * (1 + 0.1 * (35 - 25) / 5)) + (90 * 12 * 2500 * (1 + 0.1 * (5 - 25) / 5)) + (185 * 10 * 2000 * (1 + 0.1 * (20 - 25) / 5))) / 1000 AS total_energy_consumption_kwh;	air_conditioner	2
SELECT aci.heating_capacity_btu * (1 - 0.5) * (1 + CASE WHEN ec.fan_speed = '高' THEN 0.10 WHEN ec.fan_speed = '中' THEN 0.05 ELSE 0 END) AS heating_capacity_low_temp FROM air_conditioner_info aci JOIN energy_consumption ec ON aci.ac_id = ec.ac_id WHERE aci.ac_id = 'AC-5678' AND ec.mode = '制热';	air_conditioner	3
SELECT (60000 * 200 / (2.0 * 0.1)) * 1055.06 / 1000 * (1 + 0.05 * (95 / 10)) AS Extreme_energy_consumption_kwh;	air_conditioner	4
SELECT SUM((1000 * 0.001 * (hr1.indoor_humidity_percent - hr2.indoor_humidity_percent) * (101325 / (287 * (tr.indoor_temperature_celsius + 273.15))))) AS removed_water_mass FROM humidity_records hr1 JOIN humidity_records hr2 ON hr1.ac_id = hr2.ac_id AND hr1.record_date = hr2.record_date JOIN temperature_records tr ON hr1.ac_id = tr.ac_id AND hr1.record_date = tr.record_date WHERE hr1.mode = 'cooling' AND hr1.indoor_humidity_percent = 60 AND hr2.indoor_humidity_percent = 40 AND tr.indoor_temperature_celsius = 25 AND tr.mode = 'cooling' GROUP BY hr1.ac_id;	air_conditioner	1
SELECT SUM(power_consumption_watts * usage_duration_hours / 1000) AS total_energy_consumption_kwh FROM usage_records WHERE power_consumption_watts IN (800, 1200, 1500) AND usage_duration_hours IN (4, 3, 5);	air_conditioner	2
SELECT SUM(power_consumption_watts * usage_duration_hours / 1000) AS total_energy_consumption_kwh FROM usage_records WHERE mode = 'cooling' AND temperature_setting_celsius < outdoor_temperature_celsius GROUP BY temperature_setting_celsius ORDER BY temperature_setting_celsius;	air_conditioner	3
SELECT cooling_capacity_btu * ((60 - (-10)) / 20) * 1 AS theoretical_energy_consumption_btu FROM air_conditioner_info WHERE cooling_capacity_btu = 10000;	air_conditioner	4
SELECT power_consumption_watts * usage_duration_hours * 3600 AS heat_transfer_joules FROM usage_records WHERE mode = 'heating' AND power_consumption_watts = 1500 AND indoor_temperature_celsius = 10 AND temperature_setting_celsius = 20;	air_conditioner	1
SELECT SUM(power_consumption_watts * usage_duration_hours) / SUM(usage_duration_hours) AS average_power_consumption_watts FROM usage_records WHERE power_consumption_watts IN (1000, 1200, 800) AND usage_duration_hours IN (2, 3, 4);	air_conditioner	2
SELECT SUM(power_consumption_watts * usage_duration_hours / 1000) AS total_energy_consumption_kwh FROM usage_records WHERE mode = 'heating' AND temperature_setting_celsius > outdoor_temperature_celsius GROUP BY temperature_setting_celsius ORDER BY temperature_setting_celsius;	air_conditioner	3
SELECT heating_capacity_btu * ((40 - (-30)) / 20) * 1 AS theoretical_energy_consumption_btu FROM air_conditioner_info WHERE heating_capacity_btu = 12000;	air_conditioner	4
SELECT model, manufacturer, cooling_capacity_btu, power_consumption_watts, (cooling_capacity_btu / power_consumption_watts) AS cooling_efficiency FROM air_conditioner_info ORDER BY cooling_efficiency DESC LIMIT 10;	air_conditioner	1
SELECT model, manufacturer, production_year, energy_efficiency_ratio, (energy_efficiency_ratio / production_year) AS efficiency_year_ratio FROM air_conditioner_info ORDER BY efficiency_year_ratio DESC LIMIT 5;	air_conditioner	2
SELECT model, manufacturer, noise_level_db, weight_kg, (noise_level_db / weight_kg) AS noise_weight_ratio FROM air_conditioner_info WHERE weight_kg > 0 ORDER BY noise_weight_ratio ASC LIMIT 5;	air_conditioner	3
SELECT model, manufacturer, cooling_capacity_btu, power_consumption_watts, (cooling_capacity_btu / power_consumption_watts) AS cooling_power_ratio FROM air_conditioner_info WHERE cooling_capacity_btu > 20000 AND power_consumption_watts < 1000 ORDER BY cooling_power_ratio DESC LIMIT 5;	air_conditioner	4
SELECT ur.usage_id, ai.model, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption FROM usage_records ur JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id ORDER BY total_energy_consumption DESC LIMIT 10;	air_conditioner	1
SELECT ur.usage_id, ai.model, ur.usage_date, ur.temperature_setting_celsius, ur.indoor_temperature_celsius, (ur.temperature_setting_celsius - ur.indoor_temperature_celsius) AS temperature_difference FROM usage_records ur JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id ORDER BY temperature_difference DESC LIMIT 5;	air_conditioner	2
SELECT ur.usage_id, ai.model, ur.usage_date, ur.humidity_percent, ur.mode FROM usage_records ur JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id WHERE ur.mode = '除湿' ORDER BY ur.humidity_percent ASC LIMIT 5;	air_conditioner	3
SELECT ur.usage_id, ai.model, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption FROM usage_records ur JOIN air_conditioner_info ai ON ur.ac_id = ai.ac_id ORDER BY total_energy_consumption DESC LIMIT 5;	air_conditioner	4
SELECT tr.temperature_id, ai.model, tr.record_date, tr.outdoor_temperature_celsius, tr.indoor_temperature_celsius, (tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS temperature_difference FROM temperature_records tr JOIN air_conditioner_info ai ON tr.ac_id = ai.ac_id ORDER BY temperature_difference DESC LIMIT 10;	air_conditioner	1
SELECT tr.temperature_id, ai.model, tr.record_date, tr.temperature_setting_celsius, tr.indoor_temperature_celsius, ABS(tr.indoor_temperature_celsius - tr.temperature_setting_celsius) AS temperature_deviation FROM temperature_records tr JOIN air_conditioner_info ai ON tr.ac_id = ai.ac_id ORDER BY temperature_deviation DESC LIMIT 5;	air_conditioner	2
SELECT tr.temperature_id, ai.model, tr.record_date, tr.mode, tr.indoor_temperature_celsius FROM temperature_records tr JOIN air_conditioner_info ai ON tr.ac_id = ai.ac_id WHERE tr.mode = '制冷' ORDER BY tr.indoor_temperature_celsius ASC LIMIT 5;	air_conditioner	3
WITH TemperatureDifference AS ( SELECT tr.ac_id, tr.record_date, tr.indoor_temperature_celsius, tr.outdoor_temperature_celsius, (tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS temperature_difference, aci.model, aci.heating_capacity_btu FROM temperature_records tr JOIN air_conditioner_info aci ON tr.ac_id = aci.ac_id WHERE tr.outdoor_temperature_celsius = -30 AND tr.indoor_temperature_celsius = 40 ) SELECT td.ac_id, td.record_date, td.indoor_temperature_celsius, td.outdoor_temperature_celsius, td.temperature_difference, td.model, (td.heating_capacity_btu * (td.temperature_difference / 10) * ur.usage_duration_hours) AS estimated_energy_consumption FROM TemperatureDifference td JOIN usage_records ur ON td.ac_id = ur.ac_id AND td.record_date = ur.usage_date ORDER BY td.temperature_difference DESC LIMIT 5;	air_conditioner	4
WITH HumidityDifference AS ( SELECT hr.ac_id, hr.record_date, hr.indoor_humidity_percent, hr.outdoor_humidity_percent, (hr.outdoor_humidity_percent - hr.indoor_humidity_percent) AS humidity_difference, aci.model FROM humidity_records hr JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id ) SELECT hd.ac_id, hd.record_date, hd.indoor_humidity_percent, hd.outdoor_humidity_percent, hd.humidity_difference, hd.model FROM HumidityDifference hd ORDER BY hd.humidity_difference DESC LIMIT 10; 	air_conditioner	1
WITH HumidityDeviation AS ( SELECT hr.ac_id, hr.record_date, hr.temperature_setting_celsius, hr.indoor_humidity_percent, (hr.indoor_humidity_percent - 50) AS humidity_deviation, aci.model FROM humidity_records hr JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id ) SELECT hd.ac_id, hd.record_date, hd.temperature_setting_celsius, hd.indoor_humidity_percent, hd.humidity_deviation, hd.model FROM HumidityDeviation hd ORDER BY ABS(hd.humidity_deviation) DESC LIMIT 5;	air_conditioner	2
SELECT hr.ac_id, hr.record_date, hr.mode, hr.indoor_humidity_percent, aci.model FROM humidity_records hr JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id WHERE hr.mode = '除湿' ORDER BY hr.indoor_humidity_percent ASC LIMIT 5;	air_conditioner	3
WITH HumidityDifference AS ( SELECT hr.ac_id, hr.record_date, hr.indoor_humidity_percent, hr.outdoor_humidity_percent, (hr.outdoor_humidity_percent - hr.indoor_humidity_percent) AS humidity_difference, aci.model, aci.power_consumption_watts FROM humidity_records hr JOIN air_conditioner_info aci ON hr.ac_id = aci.ac_id WHERE hr.outdoor_humidity_percent = 100 AND hr.indoor_humidity_percent = 0 ) SELECT hd.ac_id, hd.record_date, hd.indoor_humidity_percent, hd.outdoor_humidity_percent, hd.humidity_difference, hd.model, (hd.power_consumption_watts * (hd.humidity_difference / 50) * ur.usage_duration_hours) AS estimated_energy_consumption FROM HumidityDifference hd JOIN usage_records ur ON hd.ac_id = ur.ac_id AND hd.record_date = ur.usage_date ORDER BY hd.humidity_difference DESC LIMIT 5;	air_conditioner	4
WITH TotalEnergyConsumption AS ( SELECT ur.ac_id, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption, aci.model FROM usage_records ur JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id ) SELECT tec.ac_id, tec.usage_date, tec.power_consumption_watts, tec.usage_duration_hours, tec.total_energy_consumption, tec.model FROM TotalEnergyConsumption tec ORDER BY tec.total_energy_consumption DESC LIMIT 10;	air_conditioner	1
WITH TemperatureDeviation AS ( SELECT ur.ac_id, ur.usage_date, ur.temperature_setting_celsius, ur.indoor_temperature_celsius, (ur.indoor_temperature_celsius - ur.temperature_setting_celsius) AS temperature_deviation, aci.model FROM usage_records ur JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id ) SELECT td.ac_id, td.usage_date, td.temperature_setting_celsius, td.indoor_temperature_celsius, td.temperature_deviation, td.model FROM TemperatureDeviation td ORDER BY ABS(td.temperature_deviation) DESC LIMIT 5;	air_conditioner	2
SELECT ur.ac_id, ur.usage_date, ur.mode, ur.usage_duration_hours, aci.model FROM usage_records ur JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id WHERE ur.mode = '制冷' ORDER BY ur.usage_duration_hours DESC LIMIT 5;	air_conditioner	3
WITH TotalEnergyConsumption AS ( SELECT ur.ac_id, ur.usage_date, ur.power_consumption_watts, ur.usage_duration_hours, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption, aci.model, aci.cooling_capacity_btu FROM usage_records ur JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id WHERE ur.outdoor_temperature_celsius = 60 AND ur.indoor_temperature_celsius = 10 ) SELECT tec.ac_id, tec.usage_date, tec.power_consumption_watts, tec.usage_duration_hours, tec.total_energy_consumption, tec.model, (tec.cooling_capacity_btu * ((60 - 10) / 10) * tec.usage_duration_hours) AS estimated_energy_consumption FROM TotalEnergyConsumption tec ORDER BY tec.total_energy_consumption DESC LIMIT 5;	air_conditioner	4
WITH CoolingEfficiency AS ( SELECT manufacturer, (cooling_capacity_btu / power_consumption_watts) AS cooling_efficiency FROM air_conditioner_info ) SELECT manufacturer, AVG(cooling_efficiency) AS average_cooling_efficiency FROM CoolingEfficiency GROUP BY manufacturer ORDER BY average_cooling_efficiency DESC LIMIT 5;	air_conditioner	1
SELECT production_year, AVG(energy_efficiency_ratio) AS average_energy_efficiency_ratio FROM air_conditioner_info GROUP BY production_year ORDER BY average_energy_efficiency_ratio DESC LIMIT 3;	air_conditioner	2
WITH ManufacturerStats AS ( SELECT manufacturer, AVG(noise_level_db) AS average_noise_level, AVG(weight_kg) AS average_weight FROM air_conditioner_info GROUP BY manufacturer ) SELECT manufacturer, average_noise_level, average_weight FROM ManufacturerStats ORDER BY average_noise_level ASC, average_weight ASC LIMIT 3;	air_conditioner	3
WITH RefrigerantStats AS ( SELECT refrigerant_type, AVG(cooling_capacity_btu) AS average_cooling_capacity, AVG(power_consumption_watts) AS average_power_consumption FROM air_conditioner_info WHERE cooling_capacity_btu > 20000 AND power_consumption_watts < 1000 GROUP BY refrigerant_type ) SELECT refrigerant_type, average_cooling_capacity, average_power_consumption FROM RefrigerantStats ORDER BY average_cooling_capacity DESC, average_power_consumption ASC LIMIT 2;	air_conditioner	4
WITH TotalEnergyConsumption AS ( SELECT aci.model, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption FROM usage_records ur JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id ) SELECT model, AVG(total_energy_consumption) AS average_total_energy_consumption FROM TotalEnergyConsumption GROUP BY model ORDER BY average_total_energy_consumption DESC LIMIT 5;	air_conditioner	1
WITH TemperatureDeviation AS ( SELECT usage_date, (indoor_temperature_celsius - temperature_setting_celsius) AS temperature_deviation FROM usage_records ) SELECT usage_date, AVG(temperature_deviation) AS average_temperature_deviation FROM TemperatureDeviation GROUP BY usage_date ORDER BY average_temperature_deviation DESC LIMIT 3;	air_conditioner	2
SELECT mode, AVG(energy_consumption_kwh) AS average_energy_consumption FROM energy_consumption GROUP BY mode ORDER BY average_energy_consumption DESC LIMIT 1;	air_conditioner	3
WITH TotalEnergyConsumption AS ( SELECT aci.model, (ur.power_consumption_watts * ur.usage_duration_hours) AS total_energy_consumption, aci.cooling_capacity_btu, ur.usage_duration_hours FROM usage_records ur JOIN air_conditioner_info aci ON ur.ac_id = aci.ac_id WHERE ur.outdoor_temperature_celsius = 60 AND ur.indoor_temperature_celsius = 10 ) SELECT model, AVG(total_energy_consumption) AS average_total_energy_consumption, AVG(cooling_capacity_btu * ((60 - 10) / 10) * usage_duration_hours) AS estimated_energy_consumption FROM TotalEnergyConsumption GROUP BY model ORDER BY average_total_energy_consumption DESC LIMIT 3;	air_conditioner	4
SELECT aci.model, AVG(tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS avg_temperature_difference FROM temperature_records tr JOIN air_conditioner_info aci ON tr.ac_id = aci.ac_id GROUP BY aci.model ORDER BY avg_temperature_difference DESC LIMIT 5;	air_conditioner	1
SELECT tr.record_date, AVG(tr.indoor_temperature_celsius - tr.temperature_setting_celsius) AS avg_temperature_deviation FROM temperature_records tr GROUP BY tr.record_date ORDER BY avg_temperature_deviation DESC LIMIT 3;	air_conditioner	2
SELECT tr.mode, AVG(tr.indoor_temperature_celsius) AS avg_indoor_temperature FROM temperature_records tr GROUP BY tr.mode ORDER BY avg_indoor_temperature ASC LIMIT 1;	air_conditioner	3
WITH ExtremeCondition AS (SELECT 'extreme' AS condition_type, -30 AS outdoor_temp, 40 AS indoor_temp), AverageTempDifference AS (SELECT aci.model, AVG(tr.outdoor_temperature_celsius - tr.indoor_temperature_celsius) AS avg_temperature_difference FROM temperature_records tr JOIN air_conditioner_info aci ON tr.ac_id = aci.ac_id GROUP BY aci.model) SELECT atd.model, atd.avg_temperature_difference, (aci.heating_capacity_btu * (70 / 10) * 1) AS estimated_energy_consumption FROM AverageTempDifference atd JOIN air_conditioner_info aci ON atd.model = aci.model CROSS JOIN ExtremeCondition ec ORDER BY atd.avg_temperature_difference DESC LIMIT 3;	air_conditioner	4
SELECT CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, SUM(ec.energy_consumption_kwh) AS total_energy_consumption FROM humidity_records hr JOIN energy_consumption ec ON hr.ac_id = ec.ac_id AND hr.record_date = ec.record_date WHERE hr.mode = '除湿' GROUP BY humidity_range;	air_conditioner	1
SELECT CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, ec.temperature_setting_celsius, SUM(ec.energy_consumption_kwh) AS total_energy_consumption FROM humidity_records hr JOIN energy_consumption ec ON hr.ac_id = ec.ac_id AND hr.record_date = ec.record_date WHERE ec.mode = '制冷' GROUP BY humidity_range, ec.temperature_setting_celsius;	air_conditioner	2
WITH NormalEnvironment AS (SELECT CASE WHEN tr.humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN tr.humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, tr.mode, AVG(ec.energy_consumption_kwh) AS normal_energy_consumption FROM temperature_records tr JOIN energy_consumption ec ON tr.ac_id = ec.ac_id AND tr.record_date = ec.record_date WHERE tr.indoor_temperature_celsius <= 30 AND tr.humidity_percent <= 60 GROUP BY humidity_range, tr.mode), HighTempHighHumidity AS (SELECT CASE WHEN tr.humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN tr.humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, tr.mode, AVG(ec.energy_consumption_kwh) AS high_energy_consumption FROM temperature_records tr JOIN energy_consumption ec ON tr.ac_id = ec.ac_id AND tr.record_date = ec.record_date WHERE tr.indoor_temperature_celsius > 30 AND tr.humidity_percent > 60 GROUP BY humidity_range, tr.mode) SELECT ne.humidity_range, ne.mode, ne.normal_energy_consumption, hthh.high_energy_consumption, ((hthh.high_energy_consumption - ne.normal_energy_consumption) / ne.normal_energy_consumption) * 100 AS energy_increase_percentage FROM NormalEnvironment ne JOIN HighTempHighHumidity hthh ON ne.humidity_range = hthh.humidity_range AND ne.mode = hthh.mode;	air_conditioner	3
SELECT CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, ec.fan_speed, SUM(ec.energy_consumption_kwh * 2.0) AS estimated_energy_consumption FROM humidity_records hr JOIN energy_consumption ec ON hr.ac_id = ec.ac_id AND hr.record_date = ec.record_date WHERE hr.indoor_humidity_percent = 200 GROUP BY humidity_range, ec.fan_speed;	air_conditioner	4
SELECT ec.temperature_setting_celsius, ec.mode, SUM(ec.energy_consumption_kwh) AS total_energy_consumption FROM energy_consumption ec GROUP BY ec.temperature_setting_celsius, ec.mode ORDER BY ec.temperature_setting_celsius, ec.mode;	air_conditioner	1
SELECT ur.fan_speed, CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, SUM(ur.usage_duration_hours) AS total_usage_duration FROM usage_records ur JOIN humidity_records hr ON ur.ac_id = hr.ac_id AND ur.usage_date = hr.record_date GROUP BY ur.fan_speed, humidity_range ORDER BY ur.fan_speed, humidity_range;	air_conditioner	2
SELECT CASE WHEN tr.outdoor_temperature_celsius < 10 THEN '<10°C' WHEN tr.outdoor_temperature_celsius BETWEEN 10 AND 25 THEN '10-25°C' ELSE '>25°C' END AS outdoor_temperature_range, ur.mode, SUM(ur.usage_duration_hours) AS total_usage_duration FROM usage_records ur JOIN temperature_records tr ON ur.ac_id = tr.ac_id AND ur.usage_date = tr.record_date GROUP BY outdoor_temperature_range, ur.mode ORDER BY outdoor_temperature_range, ur.mode;	air_conditioner	3
SELECT ur.fan_speed, CASE WHEN hr.indoor_humidity_percent BETWEEN 0 AND 30 THEN '0-30%' WHEN hr.indoor_humidity_percent BETWEEN 30 AND 60 THEN '30-60%' ELSE '60-100%' END AS humidity_range, SUM(ur.usage_duration_hours) AS total_usage_duration FROM usage_records ur JOIN humidity_records hr ON ur.ac_id = hr.ac_id AND ur.usage_date = hr.record_date JOIN temperature_records tr ON ur.ac_id = tr.ac_id AND ur.usage_date = tr.record_date WHERE tr.outdoor_temperature_celsius = 60 GROUP BY ur.fan_speed, humidity_range ORDER BY ur.fan_speed, humidity_range;	air_conditioner	4
SELECT model FROM air_conditioner_info WHERE cooling_capacity_btu > 10000 AND energy_efficiency_ratio < 10 AND production_year >= 2010;	air_conditioner	1
SELECT model FROM air_conditioner_info WHERE heating_capacity_btu > 12000 AND noise_level_db < 50 AND model NOT IN (SELECT model FROM air_conditioner_info WHERE warranty_period_months < 24);	air_conditioner	2
SELECT model FROM air_conditioner_info WHERE weight_kg > 50 AND power_consumption_watts < 1000 AND model NOT IN (SELECT model FROM air_conditioner_info WHERE manufacturer = 'Unknown');	air_conditioner	3
SELECT model FROM air_conditioner_info WHERE refrigerant_type = 'R410A' AND production_year > 2020 AND model NOT IN (SELECT model FROM air_conditioner_info WHERE cooling_capacity_btu < 5000);	air_conditioner	4
SELECT * FROM energy_consumption WHERE mode = '制冷' AND energy_consumption_kwh > (SELECT AVG(energy_consumption_kwh) FROM energy_consumption WHERE mode = '制冷') AND power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷')	air_conditioner	1
SELECT * FROM energy_consumption WHERE mode = '制热' AND ABS(temperature_setting_celsius - indoor_temperature_celsius) > 10 AND energy_consumption_kwh < (SELECT AVG(energy_consumption_kwh) FROM energy_consumption WHERE mode = '制热')	air_conditioner	2
SELECT * FROM energy_consumption WHERE mode = '除湿' AND humidity_percent > 70 AND energy_consumption_kwh < (SELECT AVG(energy_consumption_kwh) FROM energy_consumption WHERE mode = '除湿')	air_conditioner	3
SELECT * FROM energy_consumption WHERE mode = '送风' AND fan_speed = 10 AND power_consumption_watts = 0	air_conditioner	4
SELECT * FROM energy_consumption WHERE mode = '制冷' AND indoor_temperature_celsius > temperature_setting_celsius AND power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷') AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE outdoor_temperature_celsius > 40);	air_conditioner	1
SELECT * FROM energy_consumption WHERE mode = '制热' AND indoor_temperature_celsius < temperature_setting_celsius AND power_consumption_watts > (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制热') AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE humidity_percent < 30);	air_conditioner	2
SELECT * FROM energy_consumption WHERE mode = '送风' AND fan_speed = '高档' AND ABS(indoor_temperature_celsius - temperature_setting_celsius) > 5 AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE outdoor_temperature_celsius < 10);	air_conditioner	3
SELECT * FROM energy_consumption WHERE mode = '极端制冷' AND indoor_temperature_celsius < -10 AND power_consumption_watts > 10000 AND ac_id NOT IN (SELECT ac_id FROM energy_consumption WHERE outdoor_temperature_celsius < -50);	air_conditioner	4
SELECT ec.* FROM energy_consumption ec JOIN humidity_records hr ON ec.ac_id = hr.ac_id AND ec.record_date = hr.record_date WHERE ec.mode = '制冷' AND ec.humidity_percent > 70 AND ec.power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷') AND hr.outdoor_humidity_percent >= 20;	air_conditioner	1
SELECT * FROM energy_consumption WHERE mode = '除湿' AND humidity_percent > 60 AND power_consumption_watts > (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '除湿') AND temperature_setting_celsius <= 30;	air_conditioner	2
SELECT ec.* FROM energy_consumption ec JOIN humidity_records hr ON ec.ac_id = hr.ac_id AND ec.record_date = hr.record_date WHERE ec.mode = '送风' AND ec.fan_speed = '低档' AND ABS(ec.humidity_percent - hr.outdoor_humidity_percent) > 30 AND hr.outdoor_humidity_percent >= 10;	air_conditioner	3
SELECT ec.* FROM energy_consumption ec JOIN humidity_records hr ON ec.ac_id = hr.ac_id AND ec.record_date = hr.record_date WHERE ec.mode = '极端除湿' AND ec.humidity_percent < 10 AND ec.power_consumption_watts > 5000 AND hr.outdoor_humidity_percent <= 90;	air_conditioner	4
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '制冷' AND ur.usage_duration_hours > 5 AND ec.power_consumption_watts < (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制冷') AND ec.outdoor_temperature_celsius >= 10;	air_conditioner	1
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '制热' AND ur.usage_duration_hours > 3 AND ec.power_consumption_watts > (SELECT AVG(power_consumption_watts) FROM energy_consumption WHERE mode = '制热') AND ec.indoor_temperature_celsius <= 25;	air_conditioner	2
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '送风' AND ur.fan_speed = '高档' AND ur.usage_duration_hours < 1 AND ec.outdoor_temperature_celsius <= 35;	air_conditioner	3
SELECT ur.* FROM usage_records ur JOIN energy_consumption ec ON ur.ac_id = ec.ac_id AND ur.usage_date = ec.record_date WHERE ur.mode = '极端制热' AND ur.usage_duration_hours > 24 AND ur.power_consumption_watts > 10000 AND ec.outdoor_temperature_celsius <= 50;	air_conditioner	4
SELECT a.model, (a.cooling_capacity_btu / (a.power_consumption_watts * 3.412)) * (1 + (r.phase_change_heat_kj_per_kg * r.refrigerant_flow_rate_kg_per_s) / (c.air_heat_capacity_kj_per_kg_k * c.air_flow_rate_kg_per_s * 40)) AS theoretical_cop FROM air_conditioner_info a JOIN refrigerant_properties r ON a.refrigerant_type = r.refrigerant_type JOIN air_properties c ON c.temperature_celsius = 50 AND c.humidity_percent = 90 WHERE a.model = '特定型号';	air_conditioner	1
WITH monthly_energy AS (SELECT a.manufacturer, a.model, DATE_FORMAT(e.record_date, '%Y-%m') AS month, AVG(e.energy_consumption_kwh) AS avg_energy_consumption_kwh FROM energy_consumption e JOIN air_conditioner_info a ON e.ac_id = a.ac_id JOIN temperature_records t ON e.ac_id = t.ac_id AND e.record_date = t.record_date JOIN humidity_records h ON e.ac_id = h.ac_id AND e.record_date = h.record_date WHERE YEAR(e.record_date) = 2023 GROUP BY a.manufacturer, a.model, DATE_FORMAT(e.record_date, '%Y-%m')), energy_fluctuation AS (SELECT manufacturer, model, MAX(avg_energy_consumption_kwh) - MIN(avg_energy_consumption_kwh) AS energy_fluctuation_kwh FROM monthly_energy GROUP BY manufacturer, model) SELECT manufacturer, model, energy_fluctuation_kwh FROM energy_fluctuation ORDER BY energy_fluctuation_kwh DESC LIMIT 1;	air_conditioner	2
WITH low_temp_low_humidity_usage AS (SELECT u.ac_id, u.mode, SUM(u.usage_duration_hours) AS total_usage_hours, SUM(u.power_consumption_watts * u.usage_duration_hours) / 1000 AS total_energy_consumption_kwh FROM usage_records u JOIN temperature_records t ON u.ac_id = t.ac_id AND u.usage_date = t.record_date WHERE t.indoor_temperature_celsius < 10 AND t.humidity_percent < 30 GROUP BY u.ac_id, u.mode), shortest_usage_model AS (SELECT a.model, SUM(l.total_usage_hours) AS total_usage_hours FROM low_temp_low_humidity_usage l JOIN air_conditioner_info a ON l.ac_id = a.ac_id GROUP BY a.model ORDER BY total_usage_hours ASC LIMIT 1) SELECT s.model, l.mode, l.total_usage_hours, l.total_energy_consumption_kwh FROM low_temp_low_humidity_usage l JOIN air_conditioner_info a ON l.ac_id = a.ac_id JOIN shortest_usage_model s ON a.model = s.model;	air_conditioner	3
WITH theoretical_energy AS (SELECT (1000000 / 100) * 24 * 365 * 10 * POWER(1.05, 10) / 1000 AS total_energy_consumption_kwh), high_energy_models AS (SELECT a.model, (a.cooling_capacity_btu / a.energy_efficiency_ratio) * 24 * 365 * 10 * POWER(1.05, 10) / 1000 AS total_energy_consumption_kwh FROM air_conditioner_info a WHERE a.cooling_capacity_btu = 1000000 AND a.energy_efficiency_ratio = 100 AND EXISTS (SELECT 1 FROM temperature_records t WHERE t.ac_id = a.ac_id AND t.indoor_temperature_celsius - t.outdoor_temperature_celsius = 100)) SELECT model, total_energy_consumption_kwh FROM high_energy_models WHERE total_energy_consumption_kwh > 1000000;	air_conditioner	4
WITH power_consumption_variation AS (SELECT u.temperature_setting_celsius, (MAX(u.power_consumption_watts) - MIN(u.power_consumption_watts)) / AVG(u.power_consumption_watts) * 100 AS power_variation_rate FROM usage_records u JOIN air_conditioner_info a ON u.ac_id = a.ac_id WHERE a.model = '特定型号' GROUP BY u.temperature_setting_celsius) SELECT temperature_setting_celsius, power_variation_rate FROM power_consumption_variation ORDER BY power_variation_rate DESC LIMIT 1;	air_conditioner	1
WITH monthly_data AS (SELECT MONTH(u.usage_date) AS month, u.usage_duration_hours, e.energy_consumption_kwh FROM usage_records u JOIN energy_consumption e ON u.ac_id = e.ac_id AND u.usage_date = e.record_date WHERE YEAR(u.usage_date) = 2023), correlation_coefficients AS (SELECT month, (AVG(usage_duration_hours * energy_consumption_kwh) - AVG(usage_duration_hours) * AVG(energy_consumption_kwh)) / (STDDEV(usage_duration_hours) * STDDEV(energy_consumption_kwh)) AS correlation_coefficient FROM monthly_data GROUP BY month) SELECT month, correlation_coefficient FROM correlation_coefficients ORDER BY correlation_coefficient DESC LIMIT 1;	air_conditioner	2
WITH low_temp_low_humidity_usage AS (SELECT a.model, u.mode, SUM(u.usage_duration_hours) AS total_usage_hours FROM usage_records u JOIN air_conditioner_info a ON u.ac_id = a.ac_id WHERE u.indoor_temperature_celsius < 10 AND u.humidity_percent < 30 GROUP BY a.model, u.mode), shortest_usage_model AS (SELECT model, SUM(total_usage_hours) AS total_usage_hours FROM low_temp_low_humidity_usage GROUP BY model ORDER BY total_usage_hours ASC LIMIT 1) SELECT s.model, l.mode, l.total_usage_hours FROM low_temp_low_humidity_usage l JOIN shortest_usage_model s ON l.model = s.model;	air_conditioner	3
WITH extreme_usage AS (SELECT a.model, 24 * 365 * 1000 * POWER(1.02, 1000) AS total_usage_hours, (a.power_consumption_watts * 24 * 365 * 1000 * POWER(1.10, 1000)) / 1000 AS total_energy_consumption_kwh FROM air_conditioner_info a WHERE EXISTS (SELECT 1 FROM temperature_records t WHERE t.ac_id = a.ac_id AND t.indoor_temperature_celsius = 100 AND t.outdoor_temperature_celsius = -50)) SELECT model, total_usage_hours, total_energy_consumption_kwh FROM extreme_usage WHERE total_usage_hours > 10000000 AND total_energy_consumption_kwh > 100000000;	air_conditioner	4
WITH eer_by_mode AS (SELECT e.mode, AVG(a.cooling_capacity_btu / e.power_consumption_watts) AS eer FROM energy_consumption e JOIN air_conditioner_info a ON e.ac_id = a.ac_id WHERE a.model = 'Model-X' GROUP BY e.mode) SELECT mode, eer FROM eer_by_mode ORDER BY eer ASC LIMIT 1;	air_conditioner	1
WITH MonthlyData AS ( SELECT MONTH(ec.record_date) AS month, ec.energy_consumption_kwh, ec.outdoor_temperature_celsius FROM energy_consumption ec WHERE YEAR(ec.record_date) = 2023 ), CorrelationCoefficients AS ( SELECT month, (AVG(energy_consumption_kwh * outdoor_temperature_celsius) - AVG(energy_consumption_kwh) * AVG(outdoor_temperature_celsius)) / (STDDEV(energy_consumption_kwh) * STDDEV(outdoor_temperature_celsius)) AS correlation_coefficient FROM MonthlyData GROUP BY month ) SELECT month, correlation_coefficient FROM CorrelationCoefficients ORDER BY correlation_coefficient DESC LIMIT 1;	air_conditioner	2
WITH HighTempHighHumidity AS ( SELECT ec.ac_id, ec.mode, ec.energy_consumption_kwh, aci.model FROM energy_consumption ec JOIN air_conditioner_info aci ON ec.ac_id = aci.ac_id WHERE ec.outdoor_temperature_celsius > 35 AND ec.humidity_percent > 80 ), ModelModeEnergy AS ( SELECT model, mode, SUM(energy_consumption_kwh) AS total_energy_kwh FROM HighTempHighHumidity GROUP BY model, mode ), MaxEnergyModel AS ( SELECT model, SUM(total_energy_kwh) AS total_energy_kwh FROM ModelModeEnergy GROUP BY model ORDER BY total_energy_kwh DESC LIMIT 1 ) SELECT mme.model, mme.mode, mme.total_energy_kwh FROM ModelModeEnergy mme JOIN MaxEnergyModel mem ON mme.model = mem.model ORDER BY mme.model, mme.mode;	air_conditioner	3
WITH ExtremeEnergy AS ( SELECT aci.model, aci.power_consumption_watts, POWER(1.20, 1000) AS aging_factor FROM air_conditioner_info aci ), TotalEnergy AS ( SELECT model, (power_consumption_watts * 24 * 365 * 1000 * aging_factor) / 1000 AS total_energy_kwh FROM ExtremeEnergy ) SELECT model, total_energy_kwh FROM TotalEnergy WHERE total_energy_kwh > 1000000000;	air_conditioner	4
SELECT cooling_capacity_btu / (power_consumption_watts * 3.412) AS COP, cooling_capacity_btu / (1.0 * (45 - 5)) AS mass_flow_rate_kg_s FROM air_conditioner_info WHERE refrigerant_type = 'R-410A' AND cooling_capacity_btu = 18000 AND power_consumption_watts = 2000;	air_conditioner	1
SELECT air_conditioner_info.power_consumption_watts * 8 / 1000 AS total_energy_kWh, (22 - 15) * 1.005 * 1.225 * 50 / 8 * 3.412 AS heating_efficiency_BTU_h, (22 - 15) * 1.005 * 1.225 * 50 AS total_heat_change_kJ FROM usage_records JOIN air_conditioner_info ON usage_records.ac_id = air_conditioner_info.ac_id WHERE usage_records.mode = 'heating' AND usage_records.usage_duration_hours = 8 AND air_conditioner_info.power_consumption_watts = 1800;	air_conditioner	2
SELECT noise_level_db <= 55 AS is_noise_compliant, (SUBSTRING_INDEX(dimensions, 'x', 1) * SUBSTRING_INDEX(SUBSTRING_INDEX(dimensions, 'x', -2), 'x', 1) * SUBSTRING_INDEX(dimensions, 'x', -1)) * 1.5 <= (20 * 3 * 10000) AS is_space_sufficient FROM air_conditioner_info WHERE noise_level_db = 50 AND weight_kg = 30 AND dimensions = '80x20x50';	air_conditioner	3
SELECT cooling_capacity_btu / power_consumption_watts AS EER, cooling_capacity_btu / (1.5 * (10000 - (-273))) AS mass_flow_rate_kg_s, power_consumption_watts * 1 / 1000 AS total_energy_kWh FROM air_conditioner_info WHERE cooling_capacity_btu = 1000000 AND power_consumption_watts = 1000000;	air_conditioner	4
SELECT 0.5 * 1.225 * POWER(50, 2) * (Height_meters * Base_Width) * 1.2 AS Wind_Load FROM tower WHERE Name = 'Eiffel Tower';	architect	1
SELECT (Weight * 9.81) / (Base_Width * Base_Width) AS Pressure FROM tower WHERE Name = 'Eiffel Tower';	architect	2
SELECT CASE WHEN Cost_Usd = (SELECT AVG(Cost_Usd) FROM tower WHERE Height_meters = 300 AND Material = '钢') THEN '成正比' ELSE '不成正比' END AS Cost_Proportionality FROM tower WHERE Name = 'Eiffel Tower';	architect	3
SELECT CASE WHEN Vibration_Frequency = (1000 / (2 * Height_meters)) THEN '可能导致失效' ELSE '不会导致失效' END AS Failure_Risk FROM tower WHERE Name = 'Eiffel Tower';	architect	4
SELECT 0.5 * POWER(2 * PI() * Vibration_Frequency, 2) * Weight * POWER(0.1, 2) AS Energy_Consumption FROM tower WHERE Name = 'Tokyo Tower';	architect	1
SELECT Weight * 9.81 * (300 - 100) AS Potential_Energy_Change FROM tower WHERE Name = 'Tokyo Tower';	architect	2
SELECT CASE WHEN Maintenance_Cost = (SELECT AVG(Maintenance_Cost) FROM tower WHERE Height_meters = 300 AND Material = '钢') THEN '成正比' ELSE '不成正比' END AS Maintenance_Proportionality FROM tower WHERE Name = 'Tokyo Tower';	architect	3
SELECT CASE WHEN POWER(500, 2) > POWER(Wind_Resistance, 2) THEN '不足' ELSE '足够' END AS Wind_Resistance_Check FROM tower WHERE Name = 'Tokyo Tower';	architect	4
SELECT (POWER(PI(), 2) * 200e9 * (POWER(Base_Width, 4)/12)) / POWER(2 * Height_meters, 2) AS Critical_Buckling_Load FROM tower WHERE Name = 'CN Tower';	architect	1
SELECT (100000 * 2400 / 1000 * 50) AS Concrete_Cost, (100000 * 7850 / 1000 * 800) AS Steel_Cost, (100000 * 7850 / 1000 * 800) - (100000 * 2400 / 1000 * 50) AS Cost_Difference FROM tower WHERE Name = 'CN Tower';	architect	2
SELECT CASE WHEN Wind_Resistance > 40 THEN '不合理' ELSE '合理' END AS Wind_Resistance_Check FROM tower WHERE Name = 'CN Tower';	architect	3
SELECT (Weight * 9.81) / POWER(Base_Width, 2) AS Ground_Pressure FROM tower WHERE Name = 'CN Tower';	architect	4
SELECT 12e-6 * Height_meters * 50 AS Thermal_Expansion FROM tower WHERE Name = 'Burj Khalifa';	architect	1
SELECT 200e9 * 12e-6 * 40 AS Steel_Thermal_Stress, 30e9 * 10e-6 * 40 AS Concrete_Thermal_Stress FROM tower WHERE Name = 'Burj Khalifa';	architect	2
SELECT CASE WHEN (5000000 / 1200000) > 3 THEN '异常' ELSE '正常' END AS Maintenance_Status FROM tower WHERE Name = 'Burj Khalifa';	architect	3
SELECT (1e18 * 9.81) / (5515 * 9.81) AS Penetration_Depth FROM tower WHERE Name = 'Burj Khalifa';	architect	4
SELECT 0.5 * Weight * 9.81 * Base_Width AS Resist_Moment, 0.5 * 1.225 * POWER(60, 2) * (Height_meters * Base_Width) * (Height_meters / 2) AS Wind_Moment FROM tower WHERE Name = 'Shanghai Tower';	architect	1
SELECT (1e7 * 300) / (200e9 * 5) AS Steel_Deformation, (1e7 * 300) / (10e9 * 20) AS Wood_Deformation FROM tower WHERE Name = 'Shanghai Tower';	architect	2
SELECT CASE WHEN Height_meters > 150 AND Construction_year < 1880 THEN '不合理' ELSE '合理' END AS Construction_Validity FROM tower WHERE Name = 'Shanghai Tower';	architect	3
SELECT 1e25 * POWER(6.4e6 + Height_meters, 2) AS Delta_I, (8e37 / (8e37 + 1e25 * POWER(6.4e6 + Height_meters, 2))) * 7.2921159e-5 AS New_Angular_Velocity FROM tower WHERE Name = 'Shanghai Tower';	architect	4
SELECT 0.5 * 1.225 * POWER(100 * POWER(Height_meters / 10, 0.3), 2) * 0.7 AS Wind_Pressure FROM tower WHERE Name = 'CN Tower';	architect	1
SELECT Name, Height_meters, Cost_Usd, (Cost_Usd / POWER(Height_meters, 3)) AS Cost_Ratio FROM tower WHERE Name = 'CN Tower';	architect	2
SELECT Name, Height_meters, Material, Maintenance_Cost FROM tower WHERE Height_meters = 200 AND Material IN ('钢', '混凝土');	architect	3
SELECT Name, Vibration_Frequency, Maintenance_Cost, (1000 * POWER(Vibration_Frequency / 10, 3)) AS Calculated_Maintenance_Cost FROM tower WHERE Name = 'CN Tower';	architect	4
SELECT Name, Height_meters, Material, Vibration_Frequency, (1 / (2 * 3.14159)) * SQRT((200e9 * 5) / (7850 * (Base_Width * Base_Width) * POWER(Height_meters, 4))) AS Calculated_Frequency FROM tower WHERE Name = 'CN Tower';	architect	1
SELECT cpu_base_frequency_ghz + (cpu_max_frequency_ghz - cpu_base_frequency_ghz) * (cpu_usage_percent / 100) AS actual_frequency_ghz FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.cpu_base_frequency_ghz = 3.5 AND computer_info.cpu_max_frequency_ghz = 4.2 AND usage_records.cpu_usage_percent = 80;	computer	1
SELECT (ram_size_gb * ram_usage_percent / 100) / 25.6 AS actual_bandwidth_utilization FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.ram_size_gb = 16 AND computer_info.ram_type = 'DDR4' AND usage_records.ram_usage_percent = 75;	computer	2
SELECT (computer_info.battery_capacity_wh * battery_usage.battery_health_percent / 100) / battery_usage.power_consumption_watts AS runtime_hours FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE computer_info.battery_capacity_wh = 60 AND battery_usage.power_consumption_watts = 45 AND battery_usage.battery_health_percent = 90;	computer	3
SELECT cpu_cores * cpu_threads * (cpu_base_frequency_ghz + (cpu_max_frequency_ghz - cpu_base_frequency_ghz) * (cpu_usage_percent / 100)) AS total_computation_power FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.cpu_cores = 128 AND computer_info.cpu_threads = 256 AND computer_info.cpu_base_frequency_ghz = 1 AND computer_info.cpu_max_frequency_ghz = 10 AND usage_records.cpu_usage_percent = 200;	computer	4
SELECT gpu_vram_gb * (gpu_usage_percent / 100) * 448 AS data_transfer_volume_gb FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.gpu_vram_gb = 8 AND usage_records.gpu_usage_percent = 90;	computer	1
SELECT (storage_size_gb * 1024 * storage_usage_percent / 100) / 500 AS actual_bandwidth_s FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.storage_size_gb = 1024 AND computer_info.storage_type = 'SSD' AND usage_records.storage_usage_percent = 60;	computer	2
SELECT (screen_size_inches * (CAST(SUBSTRING_INDEX(screen_resolution, 'x', 1) AS UNSIGNED) * CAST(SUBSTRING_INDEX(screen_resolution, 'x', -1) AS UNSIGNED))) / (POW(SQRT(POW(CAST(SUBSTRING_INDEX(screen_resolution, 'x', 1) AS UNSIGNED), 2) + POW(CAST(SUBSTRING_INDEX(screen_resolution, 'x', -1) AS UNSIGNED), 2)) / screen_size_inches, 2)) AS actual_display_area FROM computer_info WHERE computer_info.screen_size_inches = 15.6 AND computer_info.screen_resolution = '1920x1080';	computer	3
SELECT (computer_info.battery_capacity_wh * battery_usage.battery_health_percent / 100) / battery_usage.power_consumption_watts AS runtime_hours FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE computer_info.battery_capacity_wh = 1000 AND battery_usage.power_consumption_watts = 500 AND battery_usage.battery_health_percent = 200;	computer	4
SELECT 25 + (75 * 4 * 3600 * (1 - 0.8)) / 500 AS internal_temperature_celsius FROM usage_records WHERE usage_records.power_consumption_watts = 75 AND usage_records.usage_duration_hours = 4;	computer	1
SELECT 100 * (usage_records.cpu_usage_percent / 100) AS cpu_actual_performance_gflops, 200 * (usage_records.gpu_usage_percent / 100) AS gpu_actual_performance_gflops, 50 * (usage_records.ram_usage_percent / 100) AS ram_actual_performance_gb_s, 500 * (usage_records.storage_usage_percent / 100) AS storage_actual_performance_mb_s FROM usage_records WHERE usage_records.cpu_usage_percent = 80 AND usage_records.gpu_usage_percent = 60 AND usage_records.ram_usage_percent = 50 AND usage_records.storage_usage_percent = 30;	computer	2
SELECT (60 * 90 / 100) - (50 * 3) AS remaining_battery_capacity_wh, CASE WHEN (60 * 90 / 100) - (50 * 3) <= 0 THEN '需要充电' ELSE '无需充电' END AS charging_status FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 60 AND usage_records.power_consumption_watts = 50 AND usage_records.usage_duration_hours = 3;	computer	3
SELECT 100 + (1000 * 24 * 3600 * (1 - 0.5)) / 500 AS internal_temperature_celsius, CASE WHEN 100 + (1000 * 24 * 3600 * (1 - 0.5)) / 500 > 1000 THEN '不可能实现' ELSE '可能实现' END AS feasibility_analysis FROM usage_records WHERE usage_records.cpu_usage_percent = 1000 AND usage_records.gpu_usage_percent = 800 AND usage_records.power_consumption_watts = 1000 AND usage_records.usage_duration_hours = 24;	computer	4
SELECT (30 * 1.5) / 0.9 AS actual_discharge_wh FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 60 AND usage_records.power_consumption_watts = 30 AND usage_records.usage_duration_hours = 1.5;	computer	1
SELECT (50 * 80 / 100) - (20 * 2) AS remaining_battery_capacity_wh, (50 - ((50 * 80 / 100) - (20 * 2))) / 0.85 AS required_charging_wh FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 50 AND usage_records.power_consumption_watts = 20 AND usage_records.usage_duration_hours = 2;	computer	2
SELECT 95 - ((18 * 4) / 80 * 0.1) AS remaining_battery_health_percent, CASE WHEN 95 - ((18 * 4) / 80 * 0.1) < 80 THEN '需要更换' ELSE '无需更换' END AS replacement_status FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 80 AND usage_records.power_consumption_watts = 18 AND usage_records.usage_duration_hours = 4;	computer	3
SELECT 500 - ((100 * 24) / 200 * CEIL((100 * 24) / 200) * 1) AS remaining_battery_health_percent, CASE WHEN 500 - ((100 * 24) / 200 * CEIL((100 * 24) / 200) * 1) <= 0 THEN '不可能实现' ELSE '可能实现' END AS feasibility_analysis FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.battery_capacity_wh = 200 AND usage_records.power_consumption_watts = 100 AND usage_records.usage_duration_hours = 24;	computer	4
SELECT (65 + 85) * 1 * 3600 * 0.75 AS total_heat_dissipation_joules FROM performance_tests WHERE performance_tests.cpu_score = 1200 AND performance_tests.gpu_score = 800 AND performance_tests.overall_score = 950;	computer	1
SELECT cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1 AS calculated_overall_score, CASE WHEN cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1 <> overall_score THEN '存在性能瓶颈' ELSE '无性能瓶颈' END AS performance_bottleneck_analysis FROM performance_tests WHERE cpu_score = 1500 AND gpu_score = 1000 AND ram_score = 800 AND storage_score = 600 AND overall_score = 1200;	computer	2
SELECT temperature_celsius, CASE WHEN temperature_celsius <= 85 THEN '安全范围内' ELSE '超出安全范围' END AS temperature_safety_status, CASE WHEN temperature_celsius >= 85 THEN '需要改进散热系统' ELSE '无需改进散热系统' END AS cooling_system_analysis FROM performance_tests WHERE cpu_score = 1000 AND gpu_score = 700 AND ram_score = 500 AND storage_score = 400 AND overall_score = 800 AND temperature_celsius = 80 AND power_consumption_watts = 150;	computer	3
SELECT 20000 * 1 * 3600 AS total_energy_consumption_joules, CASE WHEN 20000 * 1 * 3600 > 1e12 THEN '不可能实现可持续运行' ELSE '可能实现可持续运行' END AS sustainability_analysis FROM performance_tests WHERE cpu_score = 100000 AND gpu_score = 80000 AND ram_score = 60000 AND storage_score = 40000 AND overall_score = 90000 AND temperature_celsius = 500 AND power_consumption_watts = 20000;	computer	4
SELECT ci.computer_id, ci.manufacturer, ci.model, ci.battery_capacity_wh, pt.power_consumption_watts, (ci.battery_capacity_wh / pt.power_consumption_watts) AS theoretical_runtime_hours FROM computer_info ci JOIN performance_tests pt ON ci.computer_id = pt.computer_id ORDER BY theoretical_runtime_hours DESC LIMIT 5;	computer	1
SELECT computer_id, manufacturer, model, cpu_cores, cpu_threads, (cpu_threads / cpu_cores) AS core_thread_ratio, ABS((cpu_threads / cpu_cores) - 2) AS ratio_difference FROM computer_info ORDER BY ratio_difference ASC LIMIT 3;	computer	2
SELECT computer_id, manufacturer, model, screen_size_inches, screen_resolution, ROUND(SQRT(POW(SUBSTRING_INDEX(screen_resolution, 'x', 1), 2) + POW(SUBSTRING_INDEX(screen_resolution, 'x', -1), 2)) / screen_size_inches, 2) AS ppi FROM computer_info ORDER BY ppi DESC LIMIT 10;	computer	3
SELECT computer_id, manufacturer, model, cpu_base_frequency_ghz, (100 / cpu_base_frequency_ghz) AS performance_increase_factor FROM computer_info ORDER BY performance_increase_factor DESC LIMIT 5;	computer	4
SELECT computer_id, manufacturer, model, cpu_base_frequency_ghz, cpu_max_frequency_ghz, ROUND(((cpu_max_frequency_ghz - cpu_base_frequency_ghz) / cpu_base_frequency_ghz) * 100, 2) AS frequency_increase_percentage FROM computer_info ORDER BY frequency_increase_percentage DESC LIMIT 5;	computer	1
SELECT computer_id, manufacturer, model, ram_size_gb, storage_size_gb, (ram_size_gb / storage_size_gb) AS ram_storage_ratio, ABS((ram_size_gb / storage_size_gb) - 0.1) AS ratio_difference FROM computer_info ORDER BY ratio_difference ASC LIMIT 3;	computer	2
SELECT computer_id, manufacturer, model, weight_kg, battery_capacity_wh, (battery_capacity_wh / weight_kg) AS battery_capacity_per_kg FROM computer_info ORDER BY battery_capacity_per_kg DESC LIMIT 10;	computer	3
SELECT computer_id, manufacturer, model, gpu_vram_gb, (1024 / gpu_vram_gb) AS vram_increase_factor FROM computer_info ORDER BY vram_increase_factor DESC LIMIT 5;	computer	4
SELECT computer_id, SUM(power_consumption_watts * usage_duration_hours) AS total_energy_consumption_wh FROM usage_records GROUP BY computer_id ORDER BY total_energy_consumption_wh DESC LIMIT 5;	computer	1
SELECT computer_id, AVG(cpu_usage_percent) AS avg_cpu_usage, AVG(gpu_usage_percent) AS avg_gpu_usage, (AVG(cpu_usage_percent) - AVG(gpu_usage_percent)) AS usage_difference FROM usage_records GROUP BY computer_id ORDER BY usage_difference DESC LIMIT 3;	computer	2
SELECT computer_id, SUM(temperature_celsius * usage_duration_hours) / SUM(usage_duration_hours) AS avg_temperature FROM usage_records GROUP BY computer_id ORDER BY avg_temperature DESC LIMIT 10;	computer	3
SELECT computer_id, SUM(power_consumption_watts * 1000) AS total_energy_consumption_wh FROM usage_records GROUP BY computer_id ORDER BY total_energy_consumption_wh DESC LIMIT 5;	computer	4
SELECT computer_id, battery_capacity_wh, power_consumption_watts, (battery_capacity_wh / power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage ORDER BY theoretical_runtime_hours DESC LIMIT 5;	computer	1
SELECT computer_id, (battery_health_percent / usage_duration_hours) AS health_usage_ratio FROM battery_usage ORDER BY health_usage_ratio ASC LIMIT 3;	computer	2
SELECT computer_id, SUM(temperature_celsius * usage_duration_hours) / SUM(usage_duration_hours) AS avg_temperature FROM battery_usage GROUP BY computer_id ORDER BY avg_temperature DESC LIMIT 10;	computer	3
SELECT computer_id, (10000 / power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage ORDER BY theoretical_runtime_hours DESC LIMIT 5;	computer	4
SELECT computer_id, SUM(power_consumption_watts * 1) AS total_energy_consumption_wh, SUM(power_consumption_watts * 1) / COUNT(*) * (1 - (25 / AVG(temperature_celsius))) AS avg_cooling_power_w FROM performance_tests GROUP BY computer_id ORDER BY (total_energy_consumption_wh / avg_cooling_power_w) DESC LIMIT 5;	computer	1
SELECT computer_id, (cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1) AS weighted_score FROM performance_tests ORDER BY weighted_score DESC LIMIT 3;	computer	2
SELECT computer_id, power_consumption_watts / (temperature_celsius - 25) AS cooling_efficiency_w_per_c FROM performance_tests ORDER BY cooling_efficiency_w_per_c ASC LIMIT 10;	computer	3
SELECT computer_id, (100000 * 0.4 + 100000 * 0.3 + 100000 * 0.2 + 100000 * 0.1) / (cpu_score * 0.4 + gpu_score * 0.3 + ram_score * 0.2 + storage_score * 0.1) AS performance_increase_factor FROM performance_tests ORDER BY performance_increase_factor DESC LIMIT 5;	computer	4
SELECT manufacturer, AVG(cpu_base_frequency_ghz) AS avg_base_frequency, AVG(cpu_max_frequency_ghz) AS avg_max_frequency, (AVG(cpu_max_frequency_ghz) - AVG(cpu_base_frequency_ghz)) / AVG(cpu_base_frequency_ghz) * 100 AS frequency_increase_percentage FROM computer_info GROUP BY manufacturer ORDER BY frequency_increase_percentage DESC;	computer	1
SELECT ram_type, AVG(ram_size_gb) / AVG(storage_size_gb) AS ram_storage_ratio FROM computer_info GROUP BY ram_type ORDER BY ram_storage_ratio DESC;	computer	2
SELECT screen_size_inches, AVG(battery_capacity_wh) AS avg_battery_capacity, AVG(weight_kg) AS avg_weight, AVG(battery_capacity_wh) / AVG(weight_kg) AS battery_capacity_per_kg FROM computer_info GROUP BY screen_size_inches ORDER BY battery_capacity_per_kg DESC;	computer	3
SELECT production_year, 100 / AVG(cpu_cores) AS core_increase_factor FROM computer_info GROUP BY production_year ORDER BY core_increase_factor DESC;	computer	4
SELECT usage_type, AVG(power_consumption_watts) AS avg_power_consumption, AVG(usage_duration_hours) AS avg_usage_duration, AVG(power_consumption_watts) * AVG(usage_duration_hours) AS total_energy_consumption_wh FROM usage_records GROUP BY usage_type ORDER BY total_energy_consumption_wh DESC;	computer	1
SELECT MONTH(usage_date) AS usage_month, AVG(cpu_usage_percent) AS avg_cpu_usage, AVG(gpu_usage_percent) AS avg_gpu_usage, AVG(ram_usage_percent) AS avg_ram_usage, (AVG(cpu_usage_percent) - AVG(gpu_usage_percent)) AS usage_difference FROM usage_records GROUP BY usage_month ORDER BY usage_difference DESC;	computer	2
SELECT usage_type, AVG(temperature_celsius) AS avg_temperature, AVG(usage_duration_hours) AS avg_usage_duration, AVG(temperature_celsius) / AVG(usage_duration_hours) AS temperature_increase_per_hour FROM usage_records GROUP BY usage_type ORDER BY temperature_increase_per_hour DESC;	computer	3
SELECT usage_type, 10000 * AVG(usage_duration_hours) AS total_energy_consumption_wh FROM usage_records GROUP BY usage_type ORDER BY total_energy_consumption_wh DESC;	computer	4
SELECT YEAR(usage_date) AS usage_year, AVG(battery_health_percent) AS avg_battery_health, AVG(usage_duration_hours) AS avg_usage_duration, AVG(battery_health_percent) / AVG(usage_duration_hours) AS battery_health_decay_rate FROM battery_usage GROUP BY usage_year ORDER BY battery_health_decay_rate DESC;	computer	1
SELECT CASE WHEN battery_capacity_wh <= 50 THEN '0-50Wh' WHEN battery_capacity_wh > 50 AND battery_capacity_wh <= 100 THEN '50-100Wh' ELSE '100Wh以上' END AS capacity_range, AVG(battery_capacity_wh) AS avg_battery_capacity, AVG(power_consumption_watts) AS avg_power_consumption, AVG(usage_duration_hours) AS avg_usage_duration, AVG(battery_capacity_wh) / AVG(power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage GROUP BY capacity_range ORDER BY theoretical_runtime_hours DESC;	computer	2
SELECT MONTH(usage_date) AS usage_month, AVG(temperature_celsius) AS avg_temperature, AVG(battery_health_percent) AS avg_battery_health FROM battery_usage GROUP BY usage_month ORDER BY avg_temperature DESC;	computer	3
SELECT CASE WHEN battery_health_percent <= 50 THEN '0-50%' WHEN battery_health_percent > 50 AND battery_health_percent <= 80 THEN '50-80%' ELSE '80-100%' END AS health_range, 10000 / AVG(power_consumption_watts) AS theoretical_runtime_hours FROM battery_usage GROUP BY health_range ORDER BY theoretical_runtime_hours DESC;	computer	4
SELECT test_type, AVG(power_consumption_watts) AS avg_power_consumption, 1 AS avg_test_duration, AVG(power_consumption_watts) * 1 AS total_energy_consumption_wh FROM performance_tests GROUP BY test_type ORDER BY total_energy_consumption_wh DESC;	computer	1
SELECT YEAR(test_date) AS test_year, AVG(cpu_score) AS avg_cpu_score, AVG(gpu_score) AS avg_gpu_score, AVG(overall_score) AS avg_overall_score, ABS((AVG(cpu_score) / AVG(gpu_score)) - 1) AS cpu_gpu_score_ratio_difference FROM performance_tests GROUP BY test_year ORDER BY cpu_gpu_score_ratio_difference ASC;	computer	2
SELECT test_type, AVG(temperature_celsius) AS avg_temperature, 1 AS avg_test_duration, AVG(temperature_celsius) / 1 AS temperature_increase_per_hour FROM performance_tests GROUP BY test_type ORDER BY temperature_increase_per_hour DESC;	computer	3
SELECT test_type, (100000 * 0.4 + 100000 * 0.3 + 100000 * 0.2 + 100000 * 0.1) / (AVG(cpu_score) * 0.4 + AVG(gpu_score) * 0.3 + AVG(ram_score) * 0.2 + AVG(storage_score) * 0.1) AS performance_increase_factor FROM performance_tests GROUP BY test_type ORDER BY performance_increase_factor DESC;	computer	4
SELECT manufacturer, model, cpu_base_frequency_ghz, cpu_max_frequency_ghz FROM computer_info WHERE cpu_base_frequency_ghz > 3.0 AND cpu_max_frequency_ghz < 4.0;	computer	1
SELECT manufacturer, model, ram_size_gb, storage_size_gb FROM computer_info WHERE ram_size_gb > 16 AND storage_size_gb < 512;	computer	2
SELECT manufacturer, model, screen_size_inches, weight_kg FROM computer_info WHERE screen_size_inches > 15 AND weight_kg > 2.5;	computer	3
SELECT manufacturer, model, battery_capacity_wh, cpu_cores FROM computer_info WHERE cpu_cores < 8;	computer	4
SELECT computer_id, power_consumption_watts, usage_duration_hours, (power_consumption_watts * usage_duration_hours) AS total_energy_consumption_wh FROM usage_records WHERE power_consumption_watts > 100 AND usage_duration_hours > 2 AND (power_consumption_watts * usage_duration_hours) < 500;	computer	1
SELECT computer_id, cpu_usage_percent, gpu_usage_percent, ABS(cpu_usage_percent - gpu_usage_percent) AS usage_difference FROM usage_records WHERE cpu_usage_percent > 80 AND gpu_usage_percent > 60 AND ABS(cpu_usage_percent - gpu_usage_percent) > 20;	computer	2
SELECT computer_id, temperature_celsius, usage_duration_hours, (temperature_celsius / usage_duration_hours) AS temperature_increase_per_hour FROM usage_records WHERE temperature_celsius > 70 AND usage_duration_hours > 1 AND (temperature_celsius / usage_duration_hours) < 10;	computer	3
SELECT computer_id, 1000 AS assumed_power_consumption, usage_duration_hours, (1000 * usage_duration_hours) AS total_energy_consumption_wh, temperature_celsius FROM usage_records WHERE (1000 * usage_duration_hours) > 5000 AND temperature_celsius < 50;	computer	4
SELECT computer_id, battery_health_percent, power_consumption_watts, usage_duration_hours, (power_consumption_watts / usage_duration_hours) AS energy_consumption_per_hour FROM battery_usage WHERE battery_health_percent > 80 AND (power_consumption_watts / usage_duration_hours) > 50;	computer	1
SELECT computer_id, battery_capacity_wh, battery_health_percent, usage_duration_hours, ((100 - battery_health_percent) / usage_duration_hours) AS health_decay_rate_per_hour FROM battery_usage WHERE battery_capacity_wh > 60 AND ((100 - battery_health_percent) / usage_duration_hours) > 2;	computer	2
SELECT computer_id, temperature_celsius, usage_duration_hours FROM battery_usage WHERE temperature_celsius > 40 AND usage_duration_hours < 0.5;	computer	3
SELECT computer_id, 500 AS assumed_battery_capacity, power_consumption_watts, usage_duration_hours, (power_consumption_watts / usage_duration_hours) AS energy_consumption_per_hour, battery_health_percent FROM battery_usage WHERE (power_consumption_watts / usage_duration_hours) > 100 AND battery_health_percent < 90;	computer	4
SELECT computer_id, power_consumption_watts, 1 AS test_duration_hours, (power_consumption_watts * 1) AS total_energy_consumption_wh FROM performance_tests WHERE power_consumption_watts > 200 AND 1 > 1 AND (power_consumption_watts * 1) < 1000;	computer	1
SELECT computer_id, cpu_score, gpu_score, ram_score, storage_score, (0.4 * cpu_score + 0.3 * gpu_score + 0.2 * ram_score + 0.1 * storage_score) AS overall_score FROM performance_tests WHERE cpu_score > 8000 AND gpu_score > 9000 AND (0.4 * cpu_score + 0.3 * gpu_score + 0.2 * ram_score + 0.1 * storage_score) < 8500;	computer	2
SELECT computer_id, temperature_celsius, 1 AS test_duration_hours, (temperature_celsius / 1) AS temperature_increase_per_hour FROM performance_tests WHERE temperature_celsius > 75 AND 1 > 1 AND (temperature_celsius / 1) < 10;	computer	3
SELECT computer_id, 1000 AS assumed_power_consumption, 1 AS test_duration_hours, (1000 * 1) AS total_energy_consumption_wh, temperature_celsius, (1000 / (temperature_celsius - 25)) AS cooling_efficiency_w_per_c FROM performance_tests WHERE (1000 * 1) > 5000 AND (1000 / (temperature_celsius - 25)) < 20;	computer	4
SELECT ci.computer_id, ci.cpu_base_frequency_ghz, ci.cpu_max_frequency_ghz, ur.cpu_usage_percent, ur.power_consumption_watts, ci.cpu_base_frequency_ghz + (ci.cpu_max_frequency_ghz - ci.cpu_base_frequency_ghz) * (ur.cpu_usage_percent / 100) AS actual_frequency_ghz, ur.power_consumption_watts / (ci.cpu_base_frequency_ghz + (ci.cpu_max_frequency_ghz - ci.cpu_base_frequency_ghz) * (ur.cpu_usage_percent / 100)) AS power_frequency_ratio FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.cpu_usage_percent = 80 AND ur.power_consumption_watts = 95;	computer	1
SELECT computer_info.computer_id, ram_size_gb, ram_usage_percent, ram_type, ram_size_gb * (ram_usage_percent / 100) * 25.6 AS current_memory_bandwidth_gbs, ram_size_gb * 25.6 AS max_memory_bandwidth_gbs, (ram_size_gb * (ram_usage_percent / 100) * 25.6) / (ram_size_gb * 25.6) AS memory_bandwidth_usage_ratio FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE ram_size_gb = 16 AND ram_usage_percent = 75 AND ram_type = 'DDR4';	computer	2
SELECT computer_info.computer_id, computer_info.battery_capacity_wh, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / computer_info.battery_capacity_wh * 100 AS battery_health_percent, CASE WHEN (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / computer_info.battery_capacity_wh * 100 >= 80 THEN '正常' ELSE '不正常' END AS battery_health_status FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE computer_info.battery_capacity_wh = 56 AND battery_usage.usage_duration_hours = 4 AND battery_usage.power_consumption_watts = 14;	computer	3
SELECT computer_info.computer_id, computer_info.cpu_cores, computer_info.cpu_threads, computer_info.cpu_base_frequency_ghz, computer_info.cpu_max_frequency_ghz, usage_records.cpu_usage_percent, computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100) AS actual_frequency_ghz, usage_records.power_consumption_watts, usage_records.power_consumption_watts / (computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100)) AS power_frequency_ratio FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE computer_info.cpu_cores = 128 AND computer_info.cpu_threads = 256 AND computer_info.cpu_base_frequency_ghz = 1.0 AND computer_info.cpu_max_frequency_ghz = 10.0 AND usage_records.cpu_usage_percent = 200;	computer	4
SELECT computer_info.computer_id, computer_info.cpu_base_frequency_ghz, computer_info.cpu_max_frequency_ghz, usage_records.cpu_usage_percent, usage_records.power_consumption_watts, computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100) AS actual_frequency_ghz, SQRT(usage_records.power_consumption_watts / (1.25e-8 * (computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100)))) AS estimated_voltage FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.cpu_usage_percent = 90 AND usage_records.power_consumption_watts = 120 AND computer_info.cpu_base_frequency_ghz = 2.0 AND computer_info.cpu_max_frequency_ghz = 4.5;	computer	1
SELECT computer_info.computer_id, computer_info.ram_size_gb, usage_records.ram_usage_percent, usage_records.power_consumption_watts, computer_info.ram_size_gb * (usage_records.ram_usage_percent / 100) * 25.6 AS current_memory_bandwidth_gbs, (computer_info.ram_size_gb * (usage_records.ram_usage_percent / 100) * 25.6) / usage_records.power_consumption_watts AS memory_bandwidth_power_ratio FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.ram_usage_percent = 80 AND usage_records.power_consumption_watts = 85 AND computer_info.ram_size_gb = 32 AND computer_info.ram_type = 'DDR4';	computer	2
SELECT computer_info.computer_id, computer_info.battery_capacity_wh, usage_records.usage_duration_hours, usage_records.power_consumption_watts, (usage_records.usage_duration_hours * usage_records.power_consumption_watts) / computer_info.battery_capacity_wh * 100 AS battery_health_percent, CASE WHEN (usage_records.usage_duration_hours * usage_records.power_consumption_watts) / computer_info.battery_capacity_wh * 100 >= 80 THEN '正常' ELSE '不正常' END AS battery_health_status FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.usage_duration_hours = 8 AND usage_records.power_consumption_watts = 60 AND computer_info.battery_capacity_wh = 70;	computer	3
SELECT computer_info.computer_id, computer_info.cpu_base_frequency_ghz, computer_info.cpu_max_frequency_ghz, usage_records.cpu_usage_percent, usage_records.power_consumption_watts, computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100) AS actual_frequency_ghz, SQRT(usage_records.power_consumption_watts / (1.25e-8 * (computer_info.cpu_base_frequency_ghz + (computer_info.cpu_max_frequency_ghz - computer_info.cpu_base_frequency_ghz) * (usage_records.cpu_usage_percent / 100)))) AS estimated_voltage FROM computer_info JOIN usage_records ON computer_info.computer_id = usage_records.computer_id WHERE usage_records.cpu_usage_percent = 500 AND usage_records.power_consumption_watts = 1000 AND computer_info.cpu_base_frequency_ghz = 0.5 AND computer_info.cpu_max_frequency_ghz = 20.0;	computer	4
SELECT computer_info.computer_id, computer_info.battery_capacity_wh, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / computer_info.battery_capacity_wh * 100 AS battery_health_percent, (battery_usage.usage_duration_hours / (computer_info.battery_capacity_wh / battery_usage.power_consumption_watts)) * 100 AS discharge_efficiency_percent FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.usage_duration_hours = 10 AND battery_usage.power_consumption_watts = 50 AND computer_info.battery_capacity_wh = 60;	computer	1
SELECT computer_info.computer_id, battery_usage.battery_health_percent, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / (battery_usage.battery_health_percent / 100) AS actual_battery_capacity_wh FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.battery_health_percent = 85 AND battery_usage.usage_duration_hours = 8 AND battery_usage.power_consumption_watts = 45;	computer	2
SELECT computer_info.computer_id, battery_usage.battery_health_percent, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, computer_info.battery_capacity_wh, CASE WHEN battery_usage.battery_health_percent < 80 THEN '需要更换' ELSE '无需更换' END AS battery_replacement_status FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.battery_health_percent = 75 AND battery_usage.usage_duration_hours = 6 AND battery_usage.power_consumption_watts = 40;	computer	3
SELECT computer_info.computer_id, battery_usage.battery_health_percent, battery_usage.usage_duration_hours, battery_usage.power_consumption_watts, computer_info.battery_capacity_wh, (battery_usage.usage_duration_hours * battery_usage.power_consumption_watts) / (battery_usage.battery_health_percent / 100) AS actual_battery_capacity_wh, CASE WHEN battery_usage.battery_health_percent > 100 THEN '电池可能膨胀或过热' ELSE '电池状态正常' END AS battery_physical_status FROM computer_info JOIN battery_usage ON computer_info.computer_id = battery_usage.computer_id WHERE battery_usage.battery_health_percent = 200 AND battery_usage.usage_duration_hours = 24 AND battery_usage.power_consumption_watts = 200 AND computer_info.battery_capacity_wh = 100;	computer	4
SELECT computer_info.computer_id, performance_tests.cpu_score, performance_tests.gpu_score, performance_tests.power_consumption_watts, performance_tests.temperature_celsius, (performance_tests.cpu_score + performance_tests.gpu_score) / performance_tests.power_consumption_watts AS performance_per_watt, (performance_tests.cpu_score + performance_tests.gpu_score) / (performance_tests.power_consumption_watts * (1 + 0.02 * (performance_tests.temperature_celsius - 25))) AS performance_per_watt_with_temperature FROM computer_info JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id WHERE performance_tests.cpu_score = 1200 AND performance_tests.gpu_score = 1500 AND performance_tests.power_consumption_watts = 200 AND performance_tests.temperature_celsius = 75;	computer	1
SELECT computer_info.computer_id, performance_tests.cpu_score, performance_tests.gpu_score, performance_tests.ram_score, performance_tests.storage_score, performance_tests.overall_score, (performance_tests.cpu_score / performance_tests.overall_score) * 100 AS cpu_contribution_percent, (performance_tests.gpu_score / performance_tests.overall_score) * 100 AS gpu_contribution_percent, (performance_tests.ram_score / performance_tests.overall_score) * 100 AS ram_contribution_percent, (performance_tests.storage_score / performance_tests.overall_score) * 100 AS storage_contribution_percent FROM computer_info JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id WHERE performance_tests.cpu_score = 1000 AND performance_tests.gpu_score = 1200 AND performance_tests.ram_score = 800 AND performance_tests.storage_score = 600 AND performance_tests.overall_score = 3600;	computer	2
SELECT computer_info.computer_id, performance_tests.overall_score, performance_tests.temperature_celsius, performance_tests.power_consumption_watts, (performance_tests.power_consumption_watts / performance_tests.temperature_celsius) * 100 AS cooling_efficiency, performance_tests.overall_score * (1 - 0.01 * (performance_tests.temperature_celsius - 25)) AS adjusted_performance_score FROM computer_info JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id WHERE performance_tests.overall_score = 3000 AND performance_tests.temperature_celsius = 80 AND performance_tests.power_consumption_watts = 180;	computer	3
SELECT computer_info.computer_id, performance_tests.cpu_score, performance_tests.gpu_score, performance_tests.overall_score, performance_tests.power_consumption_watts, performance_tests.temperature_celsius, (performance_tests.cpu_score + performance_tests.gpu_score) / performance_tests.power_consumption_watts AS performance_per_watt, CASE WHEN performance_tests.temperature_celsius > 150 THEN '硬件可能熔毁或爆炸' ELSE '硬件状态正常' END AS hardware_status FROM computer_info JOIN performance_tests ON computer_info.computer_id = performance_tests.computer_id WHERE performance_tests.cpu_score = 10000 AND performance_tests.gpu_score = 15000 AND performance_tests.overall_score = 25000 AND performance_tests.power_consumption_watts = 5000 AND performance_tests.temperature_celsius = 200;	computer	4
WITH TotalPowerConsumption AS (SELECT ci.computer_id, ci.manufacturer, ci.model, SUM(ur.power_consumption_watts) AS total_power_consumption FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.cpu_usage_percent = 100 AND ur.gpu_usage_percent = 100 AND ur.ram_usage_percent = 100 AND ur.storage_usage_percent = 100 GROUP BY ci.computer_id, ci.manufacturer, ci.model) SELECT computer_id, manufacturer, model, total_power_consumption FROM TotalPowerConsumption ORDER BY total_power_consumption DESC LIMIT 5;	computer	1
WITH YearlyEnergyConsumption AS (SELECT ci.computer_id, ci.manufacturer, ci.model, SUM(ur.power_consumption_watts * ur.usage_duration_hours / 1000) AS total_energy_kwh FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.usage_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ci.computer_id, ci.manufacturer, ci.model) SELECT computer_id, manufacturer, model, total_energy_kwh FROM YearlyEnergyConsumption ORDER BY total_energy_kwh DESC LIMIT 10;	computer	2
WITH LowBatteryHealthComputers AS (SELECT bu.computer_id, ci.manufacturer, ci.model, bu.battery_health_percent, ci.battery_capacity_wh, bu.usage_duration_hours FROM battery_usage bu JOIN computer_info ci ON bu.computer_id = ci.computer_id WHERE bu.battery_health_percent < 80), AggregatedData AS (SELECT computer_id, manufacturer, model, battery_health_percent, AVG(battery_capacity_wh) OVER () AS avg_battery_capacity, AVG(usage_duration_hours) OVER () AS avg_usage_duration FROM LowBatteryHealthComputers) SELECT DISTINCT computer_id, manufacturer, model, battery_health_percent, avg_battery_capacity, avg_usage_duration FROM AggregatedData ORDER BY battery_health_percent ASC;	computer	3
WITH ExtremeUsagePower AS (SELECT ci.computer_id, ci.manufacturer, ci.model, (1000 * ci.cpu_base_frequency_ghz / 100) AS cpu_power, (500 * ci.gpu_vram_gb / 100) AS gpu_power, (200 * ci.ram_size_gb / 100) AS ram_power, (150 * ci.storage_size_gb / 100) AS storage_power, (1000 * ci.cpu_base_frequency_ghz / 100 + 500 * ci.gpu_vram_gb / 100 + 200 * ci.ram_size_gb / 100 + 150 * ci.storage_size_gb / 100) AS total_power FROM computer_info ci) SELECT computer_id, manufacturer, model, total_power FROM ExtremeUsagePower WHERE total_power > 10000 ORDER BY total_power DESC;	computer	4
WITH HeatGeneration AS (SELECT ci.computer_id, ci.manufacturer, ci.model, SUM(ur.power_consumption_watts * ur.usage_duration_hours * 3600) AS total_heat_joules FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.cpu_usage_percent = 100 AND ur.gpu_usage_percent = 100 AND ur.ram_usage_percent = 100 AND ur.storage_usage_percent = 100 GROUP BY ci.computer_id, ci.manufacturer, ci.model) SELECT computer_id, manufacturer, model, total_heat_joules FROM HeatGeneration ORDER BY total_heat_joules DESC LIMIT 5;	computer	1
WITH YearlyEnergyConsumption AS (SELECT ci.computer_id, ci.manufacturer, ci.model, SUM(ur.power_consumption_watts * ur.usage_duration_hours / 1000) AS total_energy_kwh FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.usage_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ci.computer_id, ci.manufacturer, ci.model) SELECT computer_id, manufacturer, model, total_energy_kwh / 365 AS avg_daily_energy_kwh FROM YearlyEnergyConsumption ORDER BY avg_daily_energy_kwh DESC LIMIT 10;	computer	2
WITH OldLowBatteryComputers AS (SELECT ci.computer_id, ci.manufacturer, ci.model, ci.production_year, ci.battery_capacity_wh, bu.usage_duration_hours FROM computer_info ci JOIN battery_usage bu ON ci.computer_id = bu.computer_id WHERE ci.production_year < 2018 AND bu.battery_health_percent < 70), AggregatedData AS (SELECT computer_id, manufacturer, model, production_year, AVG(battery_capacity_wh) OVER () AS avg_battery_capacity, AVG(usage_duration_hours) OVER () AS avg_usage_duration FROM OldLowBatteryComputers) SELECT DISTINCT computer_id, manufacturer, model, production_year, avg_battery_capacity, avg_usage_duration FROM AggregatedData ORDER BY production_year ASC;	computer	3
WITH TheoreticalMaxPower AS (SELECT ci.computer_id, ci.manufacturer, ci.model, (200 * ci.cpu_base_frequency_ghz) AS cpu_max_power, (ci.gpu_vram_gb * 10) AS gpu_power, (ci.ram_size_gb * 5) AS ram_power, (ci.storage_size_gb * 2) AS storage_power, (200 * ci.cpu_base_frequency_ghz + ci.gpu_vram_gb * 10 + ci.ram_size_gb * 5 + ci.storage_size_gb * 2) AS total_max_power FROM computer_info ci) SELECT computer_id, manufacturer, model, total_max_power FROM TheoreticalMaxPower WHERE total_max_power > 50000 ORDER BY total_max_power DESC;	computer	4
WITH DischargeRate AS (SELECT ci.computer_id, ci.manufacturer, ci.model, SUM(ur.power_consumption_watts * ur.usage_duration_hours) AS discharge_rate_wh FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.cpu_usage_percent = 100 AND ur.gpu_usage_percent = 100 AND ur.ram_usage_percent = 100 AND ur.storage_usage_percent = 100 GROUP BY ci.computer_id, ci.manufacturer, ci.model) SELECT computer_id, manufacturer, model, discharge_rate_wh FROM DischargeRate ORDER BY discharge_rate_wh DESC LIMIT 5;	computer	1
WITH YearlyUsage AS (SELECT ci.computer_id, ci.manufacturer, ci.model, SUM(ur.usage_duration_hours) AS total_usage_hours FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.usage_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ci.computer_id, ci.manufacturer, ci.model) SELECT computer_id, manufacturer, model, total_usage_hours FROM YearlyUsage ORDER BY total_usage_hours DESC LIMIT 10;	computer	2
WITH OldLowBatteryComputers AS (SELECT ci.computer_id, ci.manufacturer, ci.model, ci.production_year, ci.battery_capacity_wh, bu.usage_duration_hours FROM computer_info ci JOIN battery_usage bu ON ci.computer_id = bu.computer_id WHERE ci.production_year < 2018 AND bu.battery_health_percent < 70), AggregatedData AS (SELECT computer_id, manufacturer, model, production_year, AVG(battery_capacity_wh) OVER () AS avg_battery_capacity, AVG(usage_duration_hours) OVER () AS avg_usage_duration FROM OldLowBatteryComputers) SELECT DISTINCT computer_id, manufacturer, model, production_year, avg_battery_capacity, avg_usage_duration FROM AggregatedData ORDER BY production_year ASC;	computer	3
WITH TheoreticalRuntime AS (SELECT ci.computer_id, ci.manufacturer, ci.model, ci.battery_capacity_wh, ur.power_consumption_watts, (ci.battery_capacity_wh / ur.power_consumption_watts) AS theoretical_runtime_hours FROM computer_info ci JOIN usage_records ur ON ci.computer_id = ur.computer_id WHERE ur.cpu_usage_percent = 100 AND ur.gpu_usage_percent = 100 AND ur.ram_usage_percent = 100 AND ur.storage_usage_percent = 100) SELECT computer_id, manufacturer, model, theoretical_runtime_hours FROM TheoreticalRuntime WHERE theoretical_runtime_hours > 1000 ORDER BY theoretical_runtime_hours DESC;	computer	4
SELECT ((1013 - DataValue) / 1013) * 100 AS PressureChangePercentage FROM DataCollectionRecord WHERE DataType = '压力' AND CollectorId IN (SELECT Id FROM DataCollector WHERE ElevationMeters = 5000);	DataCollector	1
SELECT (COUNT(CASE WHEN DataValue BETWEEN 20 AND 30 THEN 1 END) * 100.0 / COUNT(*)) AS Probability FROM DataCollectionRecord WHERE DataType = '温度' AND DATE(CollectionTime) = CURDATE();	DataCollector	2
SELECT Id, CollectorModel, InstallationLocation, ManufactureDate, InstallationDate, Manufacturer, Status, Notes FROM DataCollector WHERE Status = '维修' AND InstallationLocation = '工厂A';	DataCollector	3
SELECT CollectorId, COUNT(*) AS TotalCollections, SUM(LENGTH(DataValue)) / 1024 AS TotalDataSizeKB, (SUM(LENGTH(DataValue)) / 1024 / 1024 / 1024) AS TotalDataSizeGB, CASE WHEN COUNT(*) > 1000000 THEN '不可行：数据量过大' ELSE '可行：数据量在可接受范围内' END AS Feasibility FROM DataCollectionRecord WHERE DATE(CollectionTime) BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE() AND CollectorId IN (SELECT Id FROM DataCollector WHERE CollectorModel = '高频采集器') GROUP BY CollectorId;	DataCollector	4
SELECT DataCollector.Id, DataCollector.InstallationLocation, DataCollector.ElevationMeters, DataCollectionRecord.DataValue AS Temperature, 1013 * POWER(1 - (0.0065 * DataCollector.ElevationMeters) / 288.15, (9.80665 * 0.0289644) / (8.3144598 * 0.0065)) AS Pressure_hPa FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.Status = '停机' AND DataCollector.ElevationMeters = 3000 AND DataCollectionRecord.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DataCollector.Id);	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 10 * 0.5 * 60 * 24 * 30 AS TotalDataSizeKB, (10 * 0.5 * 60 * 24 * 30) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE Status = '运行';	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.ManufactureDate, DataCollector.InstallationDate, DataCollector.Manufacturer, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE Status = '维修' AND InstallationLocation = '化工厂';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataSizeTB FROM DataCollector WHERE Status = '运行';	DataCollector	4
SELECT DataCollector.Id, DataCollector.Latitude, DataCollectionRecord.DataValue AS Temperature, (7.2921 * POWER(10, -5)) * 6371000 * COS(RADIANS(DataCollector.Latitude)) AS LinearVelocity_mps FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.Latitude = 60 AND DataCollectionRecord.DataType = '温度' AND DataCollectionRecord.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DataCollector.Id);	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 5 * 0.2 * 60 * 24 * 365 AS TotalDataSizeKB, (5 * 0.2 * 60 * 24 * 365) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Latitude = 45;	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Latitude, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE DataCollector.Latitude = 30 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 1 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 1 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Latitude = 90;	DataCollector	4
SELECT DataCollector.Id, DataCollector.Latitude, DataCollectionRecord.DataValue AS Temperature, DEGREES(ASIN(SIN(RADIANS(DataCollector.Latitude)) * SIN(RADIANS(23.44)) + COS(RADIANS(DataCollector.Latitude)) * COS(RADIANS(23.44)) * COS(RADIANS(0)))) AS SolarElevationAngle FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.Longitude = 0 AND DataCollectionRecord.DataType = '温度' AND DATE(DataCollectionRecord.CollectionTime) = CURDATE() ORDER BY DataCollectionRecord.CollectionTime DESC LIMIT 1;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 10 * 0.5 * 60 * 24 * 30 AS TotalDataSizeKB, (10 * 0.5 * 60 * 24 * 30) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Longitude = 120;	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Longitude, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE DataCollector.Longitude = -90 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Longitude = 180;	DataCollector	4
SELECT DataCollector.Id, DataCollector.ElevationMeters, DataCollectionRecord.DataValue AS Pressure_hPa, ((1013 - DataCollectionRecord.DataValue) / 1013) * 100 AS PressureChangePercentage FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollector.ElevationMeters = 5000 AND DataCollectionRecord.DataType = '压力' ORDER BY DataCollectionRecord.CollectionTime DESC LIMIT 1;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 5 * 0.2 * 60 * 24 * 365 AS TotalDataSizeKB, (5 * 0.2 * 60 * 24 * 365) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.ElevationMeters = 3000;	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.ElevationMeters, DataCollector.Status, DataCollector.Notes FROM DataCollector WHERE DataCollector.ElevationMeters = 1000 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.ElevationMeters = 8848;	DataCollector	4
SELECT DataCollector.Id, DataCollectionRecord.DataValue AS Temperature_Celsius, (DataCollectionRecord.DataValue * 9 / 5 + 32) AS Temperature_Fahrenheit FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollectionRecord.DataType = '温度' AND DataCollectionRecord.DataUnit = '摄氏度' AND DataCollectionRecord.DataValue = 25;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 5 * 0.2 * 60 * 24 * 365 AS TotalDataSizeKB, (5 * 0.2 * 60 * 24 * 365) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '温度' AND DataValue = 30);	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Latitude, DataCollector.Longitude, DataCollector.ElevationMeters, DataCollector.Status, DataCollector.Notes FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollectionRecord.DataType = '温度' AND DataCollectionRecord.DataValue = -10 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '温度' AND DataValue = 1000);	DataCollector	4
SELECT DataCollector.Id, DataCollectionRecord.DataValue AS RelativeHumidity, (DataCollectionRecord.DataValue / 100 * 3.169 * 1000) / (461.5 * 298.15) AS AbsoluteHumidity_gpm3 FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollectionRecord.DataType = '湿度' AND DataCollectionRecord.DataUnit = '百分比' AND DataCollectionRecord.DataValue = 80;	DataCollector	1
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 10 * 0.5 * 60 * 24 * 30 AS TotalDataSizeKB, (10 * 0.5 * 60 * 24 * 30) / 1024 AS TotalDataSizeMB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '湿度' AND DataValue = 60);	DataCollector	2
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, DataCollector.Latitude, DataCollector.Longitude, DataCollector.ElevationMeters, DataCollector.Status, DataCollector.Notes FROM DataCollector JOIN DataCollectionRecord ON DataCollector.Id = DataCollectionRecord.CollectorId WHERE DataCollectionRecord.DataType = '湿度' AND DataCollectionRecord.DataValue = 95 AND DataCollector.Status = '运行';	DataCollector	3
SELECT DataCollector.Id, DataCollector.CollectorModel, DataCollector.InstallationLocation, 100 * 10 * 60 * 60 * 24 * 365 AS TotalDataSizeKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataSizeTB FROM DataCollector WHERE DataCollector.Id IN (SELECT CollectorId FROM DataCollectionRecord WHERE DataType = '湿度' AND DataValue = 200);	DataCollector	4
SELECT dcr.Id AS RecordId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (dcr.DataValue / 1013.25) AS PressureInAtm, CASE WHEN (dcr.DataValue / 1013.25) > 1 THEN '高压环境，可能影响设备密封性和结构强度' WHEN (dcr.DataValue / 1013.25) < 1 THEN '低压环境，可能影响设备性能' ELSE '标准大气压，设备运行正常' END AS PressureImpact FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa';	DataCollector	1
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, COUNT(dcr.Id) AS TotalCollections, COUNT(dcr.Id) * 0.2 AS TotalDataKB, COUNT(dcr.Id) * 0.2 / 1024 AS TotalDataMB, COUNT(dcr.Id) * 0.2 / 1024 / 1024 AS TotalDataGB, CASE WHEN COUNT(dcr.Id) * 0.2 / 1024 / 1024 > 1000 THEN '需要大容量存储设备（如TB级硬盘）' WHEN COUNT(dcr.Id) * 0.2 / 1024 / 1024 > 100 THEN '需要中等容量存储设备（如数百GB硬盘）' ELSE '常规存储设备即可满足需求' END AS StorageRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 500 AND dcr.DataUnit = 'hPa' AND dcr.CollectionTime BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY dc.Id, dc.CollectorModel, dc.InstallationLocation, dc.Status;	DataCollector	2
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dc.ElevationMeters, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = 2000 AND dc.Status = '运行' THEN '高压环境（如深海或高压工业设备），可能导致设备密封失效或结构变形' ELSE '环境条件正常' END AS EnvironmentCondition, CASE WHEN dcr.DataValue = 2000 AND dc.Status = '运行' THEN '建议定期检查设备密封性和结构强度，确保设备正常运行' ELSE '无需特殊维护' END AS MaintenanceRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 2000 AND dcr.DataUnit = 'hPa' AND dc.Status = '运行';	DataCollector	3
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (100 * 10 * 60 * 60 * 24 * 365) AS TotalDataKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 AS TotalDataMB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 AS TotalDataGB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataTB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 AS TotalDataPB, CASE WHEN (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 > 1 THEN '数据量过大，存储和处理不可行' ELSE '数据量在可接受范围内' END AS FeasibilityAnalysis FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 100000 AND dcr.DataUnit = 'hPa';	DataCollector	4
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = -273.15 AND dcr.DataUnit = '°C' THEN '绝对零度，分子和原子热运动停止' ELSE '非绝对零度' END AS PhysicalMeaning, CASE WHEN dcr.DataValue = -273.15 AND dcr.DataUnit = '°C' THEN '极端低温可能导致设备材料脆化或电子元件失效' ELSE '温度在正常范围内，设备运行正常' END AS ImpactOnDevice FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '温度' AND dcr.DataValue = -273.15 AND dcr.DataUnit = '°C';	DataCollector	1
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, COUNT(dcr.Id) AS TotalCollections, COUNT(dcr.Id) * 0.5 AS TotalDataKB, COUNT(dcr.Id) * 0.5 / 1024 AS TotalDataMB, CASE WHEN COUNT(dcr.Id) * 0.5 / 1024 > 100 THEN '需要中等容量存储设备（如数百GB硬盘）' ELSE '常规存储设备即可满足需求' END AS StorageRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '湿度' AND dcr.DataValue = 0 AND dcr.DataUnit = '%' AND dcr.CollectionTime BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY dc.Id, dc.CollectorModel, dc.InstallationLocation, dc.Status;	DataCollector	2
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = 0 AND dcr.DataUnit = 'hPa' THEN '真空环境（如太空或实验室真空室）' ELSE '非真空环境' END AS EnvironmentCondition, CASE WHEN dcr.DataValue = 0 AND dcr.DataUnit = 'hPa' THEN '真空环境可能导致设备散热不良或材料挥发' ELSE '环境条件正常，设备运行正常' END AS ImpactOnDevice FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 0 AND dcr.DataUnit = 'hPa' AND dc.Status = '运行';	DataCollector	3
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (100 * 10 * 60 * 60 * 24 * 365) AS TotalDataKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 AS TotalDataMB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 AS TotalDataGB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataTB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 AS TotalDataPB, CASE WHEN (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 > 1 THEN '数据量过大，存储和处理不可行' ELSE '数据量在可接受范围内' END AS FeasibilityAnalysis FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '温度' AND dcr.DataValue = -1000 AND dcr.DataUnit = '°C';	DataCollector	4
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (dcr.DataValue + 273.15) AS TemperatureInKelvin, CASE WHEN dcr.DataValue = 1000 THEN '高温可能导致设备内部材料膨胀、电子元件失效或散热系统超负荷运行' ELSE '温度在正常范围内，设备运行正常' END AS ImpactOnDevice FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '温度' AND dcr.DataValue = 1000 AND dcr.DataUnit = '°C';	DataCollector	1
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, COUNT(dcr.Id) AS TotalCollections, COUNT(dcr.Id) * 0.5 AS TotalDataKB, COUNT(dcr.Id) * 0.5 / 1024 AS TotalDataMB, CASE WHEN COUNT(dcr.Id) * 0.5 / 1024 > 100 THEN '需要中等容量存储设备（如数百GB硬盘）' ELSE '常规存储设备即可满足需求' END AS StorageRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '湿度' AND dcr.DataValue = 100 AND dcr.DataUnit = '%' AND dcr.CollectionTime BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY dc.Id, dc.CollectorModel, dc.InstallationLocation, dc.Status;	DataCollector	2
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, CASE WHEN dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa' THEN '海平面环境，可能受到季节性气候变化的影响' ELSE '非海平面环境' END AS EnvironmentCondition, CASE WHEN dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa' THEN '建议定期检查设备防护措施，确保设备在极端天气下正常运行' ELSE '环境条件稳定，无需特殊维护' END AS MaintenanceRecommendation FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '压力' AND dcr.DataValue = 1013 AND dcr.DataUnit = 'hPa' AND dc.Status = '运行';	DataCollector	3
SELECT dc.Id AS CollectorId, dc.CollectorModel, dc.InstallationLocation, dc.Status, dcr.DataValue, dcr.DataUnit, (100 * 10 * 60 * 60 * 24 * 365) AS TotalDataKB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 AS TotalDataMB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 AS TotalDataGB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 AS TotalDataTB, (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 AS TotalDataPB, CASE WHEN (100 * 10 * 60 * 60 * 24 * 365) / 1024 / 1024 / 1024 / 1024 > 1 THEN '数据量过大，存储和处理不可行' ELSE '数据量在可接受范围内' END AS FeasibilityAnalysis FROM DataCollectionRecord dcr JOIN DataCollector dc ON dcr.CollectorId = dc.Id WHERE dcr.DataType = '温度' AND dcr.DataValue = 1000000 AND dcr.DataUnit = '°C';	DataCollector	4
SELECT ((T1.AverageValue - T2.AverageValue) / (DC1.ElevationMeters - DC2.ElevationMeters)) AS TemperatureLapseRate FROM DataCollector DC1 JOIN DataCollectionRecord T1 ON DC1.Id = T1.CollectorId JOIN DataCollector DC2 ON DC2.ElevationMeters = DC1.ElevationMeters - 100 JOIN DataCollectionRecord T2 ON DC2.Id = T2.CollectorId WHERE DC1.ElevationMeters = 3000 AND T1.DataType = '温度' AND T2.DataType = '温度' AND T1.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DC1.Id AND DataType = '温度') AND T2.CollectionTime = (SELECT MAX(CollectionTime) FROM DataCollectionRecord WHERE CollectorId = DC2.Id AND DataType = '温度');	DataCollector	1
SELECT SUM(DataValue) AS TotalSum, AVG(POWER(DataValue - (SELECT AVG(DataValue) FROM DataCollectionRecord WHERE DataType = '温度' AND CollectorId = DC.Id AND CollectionTime >= DATE_SUB(NOW(), INTERVAL 24 HOUR)), 2)) AS Variance FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '温度' AND DCR.CollectionTime >= DATE_SUB(NOW(), INTERVAL 24 HOUR) GROUP BY DC.Id;	DataCollector	2
SELECT DC.InstallationLocation, AVG(DCR.DataValue) AS AverageTemperature, (SELECT AVG(DCR2.DataValue) FROM DataCollectionRecord DCR2 JOIN DataCollector DC2 ON DCR2.CollectorId = DC2.Id WHERE DC2.InstallationLocation LIKE '%郊区%' AND DCR2.DataType = '温度') AS SuburbAverageTemperature FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DC.InstallationLocation LIKE '%市中心%' AND DCR.DataType = '温度' GROUP BY DC.InstallationLocation;	DataCollector	3
SELECT SUM(DCR.DataValue) AS TotalSum, CASE WHEN MAX(DCR.DataValue) >= 1500 THEN '采集器可能损坏' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '温度' AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW() GROUP BY DC.Id;	DataCollector	4
SELECT AVG(DCR.DataValue) AS AverageValue, AVG(DCR.DataValue) - (1.96 * (1 / SQRT(COUNT(DCR.DataValue)))) AS LowerBound, AVG(DCR.DataValue) + (1.96 * (1 / SQRT(COUNT(DCR.DataValue)))) AS UpperBound FROM DataCollectionRecord DCR WHERE DCR.DataType = '温度' AND DCR.DataAccuracy = 95 GROUP BY DCR.CollectorId;	DataCollector	1
SELECT SUM(DCR.DataValue) AS TotalSum, STDDEV(DCR.DataValue) / SQRT(COUNT(DCR.DataValue)) AS StandardError FROM DataCollectionRecord DCR WHERE DCR.DataType = '湿度' AND DCR.DataAccuracy = 98 AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 24 HOUR) AND NOW() GROUP BY DCR.CollectorId;	DataCollector	2
SELECT DCR.AverageValue, DC.ElevationMeters, DCR.DataAccuracy FROM DataCollectionRecord DCR JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '压力' AND DCR.DataAccuracy = 99 AND DC.ElevationMeters = 0;	DataCollector	3
SELECT SUM(DCR.DataValue) AS TotalSum, CASE WHEN MAX(DCR.DataAccuracy) > 100 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCR WHERE DCR.DataType = '湿度' AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW() GROUP BY DCR.CollectorId;	DataCollector	4
SELECT (1 - (SELECT COUNT(*) FROM DataCollectionRecord WHERE DataValue <= 100 AND DataType = '温度') / (SELECT COUNT(*) FROM DataCollectionRecord WHERE DataType = '温度')) AS ExceedProbability FROM DataCollectionRule DCR WHERE DCR.DataType = '温度' AND DCR.ThresholdValue = 100;	DataCollector	1
SELECT SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, (DCRec.DataValue - 75) / 3 AS ZScore FROM DataCollectionRecord DCRec JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '湿度' AND DCR.ThresholdValue = 80 AND DCRec.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 24 HOUR) AND NOW() GROUP BY DCRec.DataValue;	DataCollector	2
SELECT DCRec.AverageValue, DC.ElevationMeters FROM DataCollectionRecord DCRec JOIN DataCollector DC ON DCRec.CollectorId = DC.Id JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '压力' AND DCR.ThresholdValue = 110 AND DC.ElevationMeters = 500;	DataCollector	3
SELECT SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, CASE WHEN SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) > 0 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCRec JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '温度' AND DCR.ThresholdValue = 1000 AND DCRec.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW();	DataCollector	4
SELECT (1 - (SELECT COUNT(*) FROM DataCollectionRecord WHERE DataValue <= 30 AND DataType = '温度') / (SELECT COUNT(*) FROM DataCollectionRecord WHERE DataType = '温度')) AS ExceedProbability FROM DataCollectionRule DCR WHERE DCR.DataType = '温度' AND DCR.ThresholdValue = 30 AND DCR.ConditionOperator = '>';	DataCollector	1
SELECT SUM(CASE WHEN DCRec.DataValue < 60 THEN 1 ELSE 0 END) AS BelowCount, (DCRec.DataValue - 65) / 3 AS ZScore FROM DataCollectionRecord DCRec JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '湿度' AND DCR.ThresholdValue = 60 AND DCR.ConditionOperator = '<' AND DCRec.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 24 HOUR) AND NOW() GROUP BY DCRec.DataValue;	DataCollector	2
SELECT DCRec.AverageValue, DC.ElevationMeters FROM DataCollectionRecord DCRec JOIN DataCollector DC ON DCRec.CollectorId = DC.Id JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '压力' AND DCR.ThresholdValue = 101.3 AND DCR.ConditionOperator = '=' AND DC.ElevationMeters = 0;	DataCollector	3
SELECT SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, CASE WHEN SUM(CASE WHEN DCRec.DataValue > DCR.ThresholdValue THEN 1 ELSE 0 END) > 0 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCRec JOIN DataCollectionRule DCR ON DCRec.DataType = DCR.DataType WHERE DCRec.DataType = '温度' AND DCR.ThresholdValue = 1000 AND DCR.ConditionOperator = '>' AND DCRec.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW();	DataCollector	4
SELECT COUNT(*) AS TotalCount, 2 / SQRT(COUNT(*)) AS StandardError FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '温度' AND DCRule.CollectionFrequency = '每分钟' AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	DataCollector	1
SELECT SUM(DCR.DataValue) AS TotalSum, AVG(POWER(DCR.DataValue - 60, 2)) AS Variance FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '湿度' AND DCRule.CollectionFrequency = '每小时' AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW();	DataCollector	2
SELECT DCRule.CollectionFrequency, AVG(DCR.DataValue) AS AveragePressure, STDDEV(DCR.DataValue) AS StandardDeviation FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '压力' AND DCRule.CollectionFrequency = '每分钟' AND DC.ElevationMeters = 0;	DataCollector	3
SELECT SUM(DCR.DataValue) AS TotalSum, CASE WHEN DCRule.CollectionFrequency = '每秒' AND COUNT(*) > 31536000 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '温度' AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW() GROUP BY DCRule.CollectionFrequency;	DataCollector	4
SELECT AVG(DCR.DataValue) AS AverageValue, AVG(DCR.DataValue) - (1.96 * (2 / SQRT(COUNT(*)))) AS LowerBound, AVG(DCR.DataValue) + (1.96 * (2 / SQRT(COUNT(*)))) AS UpperBound, CASE WHEN MAX(DCR.DataValue) > DCRule.ThresholdValue THEN '需要发送通知' ELSE '无需发送通知' END AS NotificationStatus FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '温度' AND DCRule.ActionType = '通知' GROUP BY DCRule.ThresholdValue;	DataCollector	1
SELECT SUM(CASE WHEN DCR.DataValue > DCRule.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, (DCR.DataValue - 70) / 3 AS ZScore FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '湿度' AND DCRule.ActionType = '处理' AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 24 HOUR) AND NOW() GROUP BY DCR.DataValue;	DataCollector	2
SELECT AVG(DCR.DataValue) AS AveragePressure, DCRule.ThresholdValue, CASE WHEN AVG(DCR.DataValue) BETWEEN 101.3 - 0.5 AND 101.3 + 0.5 THEN '无需发送通知' ELSE '需要发送通知' END AS NotificationStatus FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType JOIN DataCollector DC ON DCR.CollectorId = DC.Id WHERE DCR.DataType = '压力' AND DCRule.ActionType = '通知' AND DC.ElevationMeters = 0 GROUP BY DCRule.ThresholdValue;	DataCollector	3
SELECT SUM(CASE WHEN DCR.DataValue > DCRule.ThresholdValue THEN 1 ELSE 0 END) AS ExceedCount, CASE WHEN SUM(CASE WHEN DCR.DataValue > DCRule.ThresholdValue THEN 1 ELSE 0 END) > 0 THEN '采集器可能失效' ELSE '采集器正常工作' END AS Status FROM DataCollectionRecord DCR JOIN DataCollectionRule DCRule ON DCR.DataType = DCRule.DataType WHERE DCR.DataType = '温度' AND DCRule.ActionType = '处理' AND DCR.CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 YEAR) AND NOW();	DataCollector	4
SELECT 1.225 * 50 AS Mass, 1.225 * 50 * 1.005 * (30 - 25) AS HeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '公众' AND DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '政府' AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%' AND DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '企业' AND DCNR.NotificationContent LIKE '%压力数据超出阈值110kPa%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost, CASE WHEN DCNR.RecipientCount * 10000 > 1000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '公众' AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%' AND DCNR.NotificationMethod = '广播';	DataCollector	4
SELECT DCNR.RecipientCount * (1.225 * 50 * 1.005 * (30 - 25)) AS TotalHeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType FROM DataCollectionNotificationRecord DCNR WHERE DCNR.RecipientType = '农业生产者' AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost, CASE WHEN DCNR.RecipientCount * 10000 > 1000000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '广播' AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT 1.225 * 10000 * 1.005 * (30 - 25) AS HeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '广播' AND DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '邮件' AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost, CASE WHEN DCNR.RecipientCount * 10000 > 1000000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationMethod = '广播' AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT 1.225 * 10000 * 1.005 * (30 - 25) AS HeatRequired FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationStatus = '成功' AND DCNR.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT DCNR.RecipientCount * 0.01 AS TotalCost, DCNR.RecipientCount * 0.95 AS SuccessCount FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationStatus = '失败' AND DCNR.NotificationMethod = '短信';	DataCollector	2
SELECT DCNR.NotificationContent, DCNR.RecipientType FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationStatus = '成功' AND DCNR.NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	3
SELECT DCNR.RecipientCount * 10000 AS TotalCost, CASE WHEN DCNR.RecipientCount * 10000 > 1000000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord DCNR WHERE DCNR.NotificationStatus = '失败' AND DCNR.NotificationMethod = '广播' AND DCNR.NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT TIMESTAMPDIFF(SECOND, NotificationTime, AcknowledgedTime) AS TimeDifferenceInSeconds, (1.225 * 10000) * 1.005 * (30 - 25) AS HeatRequiredInKJ FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT RecipientCount * 0.01 AS TotalCost, RecipientCount * 0.95 AS SuccessfullySentCount FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	2
SELECT NotificationContent, AcknowledgedTime FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%压力数据超出阈值110kPa%';	DataCollector	3
SELECT RecipientCount * 10000 AS TotalCost, CASE WHEN RecipientCount * 10000 > 1000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord WHERE AcknowledgedTime = '9999-12-31 23:59:59' AND NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT TIMESTAMPDIFF(SECOND, dc.CollectionTime, dcn.NotificationTime) AS TimeDifferenceInSeconds, (1.225 * 10000) * 1.005 * (30 - 25) AS HeatRequiredInKJ FROM DataCollectionNotificationRecord dcn JOIN DataCollectionRecord dc ON dcn.TriggerId = dc.Id WHERE dcn.NotificationTime = '2023-10-01 12:00:00' AND dcn.NotificationContent LIKE '%温度数据超出阈值30°C%';	DataCollector	1
SELECT RecipientCount * 0.01 AS TotalCost, RecipientCount * 0.95 AS SuccessfullySentCount FROM DataCollectionNotificationRecord WHERE NotificationTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%湿度数据超出阈值80%';	DataCollector	2
SELECT NotificationContent, NotificationTime FROM DataCollectionNotificationRecord WHERE NotificationTime = '2023-10-01 12:00:00' AND NotificationContent LIKE '%压力数据超出阈值110kPa%';	DataCollector	3
SELECT RecipientCount * 10000 AS TotalCost, CASE WHEN RecipientCount * 10000 > 1000000 THEN '系统可能无法运行' ELSE '系统正常工作' END AS SystemStatus FROM DataCollectionNotificationRecord WHERE NotificationTime = '9999-12-31 23:59:59' AND NotificationContent LIKE '%温度数据超出阈值1000°C%';	DataCollector	4
SELECT Total_Disk_Area * Max_Disk_Loading AS Lift FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	1
SELECT (Max_Gross_Weight * 1.2) / Total_Disk_Area AS New_Max_Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	2
SELECT CASE WHEN Max_Disk_Loading * Total_Disk_Area * 0.75 < Max_Gross_Weight THEN 'Not Suitable' ELSE 'Suitable' END AS Suitability FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	3
SELECT 10000 / Total_Disk_Area AS Extreme_Disk_Loading, 'The aircraft will likely stall or crash due to insufficient lift.' AS Consequence FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	4
SELECT ROUND((International_Passengers / Total_Passengers) * 100, 2) AS International_Passenger_Percentage FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Freight_Tonnes / Aircraft_Movements AS Average_Freight_Per_Movement FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	3
SELECT (Total_Passengers * 2 * 20) AS Total_Luggage_Weight, CEIL((Total_Passengers * 2 * 20) / 635) AS Required_Flights FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	4
SELECT (International_Passengers * POW(1 + 0.015, 5) + Domestic_Passengers * POW(1 + 0.02, 5) + Transit_Passengers * POW(1 - 0.005, 5)) AS Total_Passengers_After_5_Years FROM airport WHERE Airport_Name = 'London Heathrow';	AirCraft	2
SELECT CASE WHEN Age + 7 <= 30 THEN 'may maintain the same level of competitive performance' ELSE 'may not maintain the same level of competitive performance' END AS Competitive_Status FROM pilot WHERE Name = 'Prof. Zackery Collina';	AirCraft	3
SELECT Aircraft, Max_Gross_Weight, Total_Disk_Area, Max_Disk_Loading FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT Total_Passengers / (1 + Change_2019 / 100) AS Total_Passengers_2019 FROM airport WHERE Airport_Name = 'LondonHeathrow';	AirCraft	2
SELECT Domestic_Passengers / 0.80 AS Total_Passengers FROM airport;	AirCraft	3
SELECT Max_Gross_Weight / Total_Disk_Area AS Max_Disk_Loading, Max_Gross_Weight / 10000000 AS Max_Disk_Loading_New FROM aircraft WHERE Max_Gross_Weight = 1000000 AND Total_Disk_Area = 1000000;	AirCraft	4
SELECT Max_Gross_Weight / Total_Disk_Area AS Disk_Loading FROM aircraft WHERE Aircraft = 'Robinson R-22';	AirCraft	1
SELECT YEAR(CURDATE()) - (Age - 17) AS Earliest_License_Year FROM pilot WHERE Age = 23;	AirCraft	4
SELECT Aircraft, CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(Max_Gross_Weight, '(', -1), 'kg', 1) AS FLOAT) * 9.81 AS Lift_Required FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT SUM(a.Total_Disk_Area) AS Total_Disk_Area, AVG(a.Total_Disk_Area) AS Avg_Disk_Area FROM `match` m JOIN aircraft a ON m.Winning_Aircraft = a.Aircraft_ID WHERE m.Location = 'MiraZayd, Abu Dhabi';	AirCraft	2
SELECT Airport_Name, (International_Passengers / Total_Passengers) * 100 AS International_Percentage, CASE WHEN (International_Passengers / Total_Passengers) * 100 > 90 THEN 'Yes' ELSE 'No' END AS Exceeds_90_Percent FROM airport WHERE Airport_Name = 'London Heathrow';	AirCraft	3
SELECT Aircraft, (Max_Gross_Weight/Total_Disk_Area) AS Calculated_Loading, Max_Disk_Loading, CASE WHEN (Max_Gross_Weight/Total_Disk_Area) > Max_Disk_Loading THEN 'Exceeded' ELSE 'Within Limit' END FROM aircraft WHERE Aircraft = 'RobinsonR-22';	AirCraft	1
SELECT (SUM(a.Freight_Tonnes*1000)/SUM(a.Aircraft_Movements))/COUNT(DISTINCT aa.Aircraft_ID) FROM airport a JOIN airport_aircraft aa ON a.Airport_ID=aa.Airport_ID WHERE Airport_Name='LondonHeathrow';	AirCraft	2
SELECT Total_Passengers, (International_Passengers+Domestic_Passengers+Transit_Passengers) AS Sum_Passengers, CASE WHEN Total_Passengers = International_Passengers+Domestic_Passengers+Transit_Passengers THEN 'Match' ELSE 'Mismatch' END FROM airport;	AirCraft	3
SELECT (600000*9.8)/0.01/101325 AS Atmospheric_Pressure_Multiples FROM DUAL;	AirCraft	4
SELECT 0.5*(0.3*Max_Gross_Weight)*POWER(5,2)*POWER((2*PI()*300/60),2) AS Rotational_Energy FROM aircraft WHERE Aircraft='RobinsonR-22';	AirCraft	1
WITH cte AS (SELECT COUNT(*) AS total, SUM(CASE WHEN p.Age=23 THEN 1 ELSE 0 END) AS wins FROM `match` m JOIN pilot p ON m.Winning_Pilot = p.Pilot_ID WHERE YEAR(m.Date) = 2023) SELECT ROUND(wins*1.0/total,3) AS p_value, ROUND(1.96 * SQRT((wins*1.0/total) * (1 - wins*1.0/total) / total), 3) AS margin FROM cte;	AirCraft	2
SELECT Transit_Passengers/(Aircraft_Movements/365) AS Daily_Transit_Per_Movement FROM airport;	AirCraft	3
SELECT (1E15*0.5)/(5.1E14) AS Earth_Surface_Multiples FROM DUAL;	AirCraft	4
SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;	AlarmSystem	1
WITH FilteredData AS (SELECT SeverityLevel FROM WarningEvent WHERE SeverityLevel > 8) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, AVG(SeverityLevel) - (2.576 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound, AVG(SeverityLevel) + (2.576 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound FROM FilteredData;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR PopulationAffected > 1000000 OR EstimatedDamageUSD > 10000000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (RadiusKm * 1000) / 10 AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 50;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 20000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'tornado' AND SeverityLevel = 6;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 50000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 5 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'earthquake' AND RadiusKm = 100;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD > 8000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'flood' AND SeverityLevel = 8;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 0.1 AS SpreadTimeMinutes FROM WarningEvent WHERE EventType = 'fire' AND RadiusKm = 2;	AlarmSystem	1
SELECT AVG(PopulationAffected) AS AveragePopulationAffected FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'typhoon' AND SeverityLevel = 5;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (RadiusKm * 1000) / 200 AS PropagationTimeSeconds FROM WarningEvent WHERE EventType = 'tsunami' AND RadiusKm = 200;	AlarmSystem	1
SELECT (COUNT(CASE WHEN EstimatedDamageUSD BETWEEN 3000000.00 AND 7000000.00 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageWithinRange FROM WarningEvent;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'earthquake' AND SeverityLevel = 7;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 100 OR SeverityLevel > 9 OR EstimatedDamageUSD > 1000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT (20 / 0.01) * (1 - EXP(-0.01 * (500 * 1000 / 20))) AS DiffusionTimeSeconds FROM WarningEvent WHERE EventType = 'volcanic eruption' AND RadiusKm = 500;	AlarmSystem	1
WITH FilteredEvents AS (SELECT EstimatedDamageUSD FROM WarningEvent WHERE EstimatedDamageUSD > 1000000000.00) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningEvent)) AS PercentageAboveThreshold, SUM(EstimatedDamageUSD) AS TotalDamageAboveThreshold FROM FilteredEvents;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'nuclear leak' AND SeverityLevel = 10;	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningEvent WHERE (RadiusKm > 200 OR SeverityLevel > 9 OR EstimatedDamageUSD > 100000000) AND EventTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT ThresholdValue / 10 AS TimeToThresholdHours FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;	AlarmSystem	1
SELECT (COUNT(CASE WHEN ThresholdValue > 8000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningRule;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 1000 AND ActionType = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'nuclear leak' AND ThresholdValue > 100 AND ThresholdUnit = 'millisieverts') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT 100 / 5 AS PropagationTimeSeconds, POWER(10, 1.5 * ThresholdValue + 4.8) AS EarthquakeEnergy FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue = 5.0;	AlarmSystem	1
WITH FilteredRules AS (SELECT ThresholdValue FROM WarningRule WHERE ThresholdValue > 800.0) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningRule)) AS PercentageAboveThreshold, SUM(ThresholdValue) AS TotalThresholdAbove FROM FilteredRules;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'tsunami' AND ThresholdValue = 10 AND ActionType = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'volcanic eruption' AND ThresholdValue > 100 AND ThresholdUnit = 'kilometer') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT ThresholdValue AS RequiredRainfall FROM WarningRule WHERE EventType = 'flood' AND ThresholdValue = 500;	AlarmSystem	1
SELECT AVG(ThresholdValue) AS AverageThresholdValue FROM WarningRule;	AlarmSystem	2
SELECT ActionType FROM WarningRule WHERE EventType = 'fire' AND ThresholdValue = 100 AND ActionType = 'notification';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE RuleId = (SELECT Id FROM WarningRule WHERE EventType = 'earthquake' AND ThresholdValue > 9.0 AND ThresholdUnit = 'Richter scale') AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	AlarmSystem	4
SELECT TriggerValue / 50 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 1000;	AlarmSystem	1
SELECT (COUNT(CASE WHEN TriggerValue > 80000 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WarningTriggerRecord;	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-01-01 00:00:00' AND '2024-01-01 00:00:00';	AlarmSystem	4
SELECT LN(TriggerValue / 0.0001) / 0.1 AS TimeToTriggerHours FROM WarningTriggerRecord WHERE TriggerValue = 5000;	AlarmSystem	1
WITH FilteredRecords AS (SELECT TriggerValue FROM WarningTriggerRecord WHERE TriggerValue > 100000) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningTriggerRecord)) AS PercentageAboveThreshold, SUM(TriggerValue) AS TotalTriggerValueAbove FROM FilteredRecords;	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	3
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 1000 AND TriggerUnit = 'Celsius' AND ActionTaken = 'evacuation';	AlarmSystem	4
SELECT TriggerValue / 10 AS RequiredTime FROM WarningTriggerRecord WHERE TriggerValue = 100 AND TriggerUnit = 'millimeters';	AlarmSystem	1
SELECT AVG(TriggerValue) AS AverageTriggerValue FROM WarningTriggerRecord WHERE TriggerValue IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);	AlarmSystem	2
SELECT ActionTaken FROM WarningTriggerRecord WHERE TriggerValue = 50 AND TriggerUnit = 'Celsius' AND ActionTaken = 'notification';	AlarmSystem	3
SELECT COUNT(*) AS WarningCount FROM WarningTriggerRecord WHERE TriggerValue > 100 AND TriggerUnit = 'millisieverts' AND TriggerTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (100 * 1000) / POW(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 80000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'people';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (1000 * 1000) / POW(3, 8) AS PropagationTime, EXP(-0.001 * 1000) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage, SUM(RecipientCount) AS TotalRecipients FROM WarningNotificationRecord WHERE RecipientCount > 1000000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast' AND RecipientType = 'people';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';	AlarmSystem	4
SELECT (10 * 1000) / POW(3, 8) AS PropagationTime FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS';	AlarmSystem	1
SELECT AVG(RecipientCount) AS AverageRecipientCount FROM WarningNotificationRecord WHERE RecipientCount IN (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000);	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'email' AND RecipientType = 'enterprise';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 100000 AND NotificationTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (500 * 1000) / POW(3, 8) AS PropagationTime, EXP(-0.0005 * 500) AS SignalAttenuation FROM WarningNotificationRecord WHERE NotificationMethod = 'broadcast';	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WarningNotificationRecord)) AS Percentage FROM WarningNotificationRecord WHERE RecipientCount > 800000;	AlarmSystem	2
SELECT NotificationContent FROM WarningNotificationRecord WHERE NotificationMethod = 'SMS' AND RecipientType = 'government';	AlarmSystem	3
SELECT COUNT(*) AS NotificationCount FROM WarningNotificationRecord WHERE RecipientCount > 1000000 AND NotificationTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (100 * 1000) / 5 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 7;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'earthquake' AND AverageSeverity = 6 AND FalseAlarmRate = 5;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (1000 * 1000) / 200 AS PropagationTime, EXP(-0.01 * 1000) AS EnergyAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'tsunami' AND MaxSeverity = 10;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage, SUM(AverageSeverity) AS TotalAverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'nuclear leak' AND MaxSeverity = 10 AND FalseAlarmRate = 0.1;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00.000' AND '2023-12-31 23:59:59.999';	AlarmSystem	4
SELECT (500 * 1000) / 10 AS DiffusionTime, EXP(-0.005 * ((500 * 1000) / 10)) AS ConcentrationAttenuation FROM HistoricalDataAnalysis WHERE EventType = 'volcanic eruption' AND MaxSeverity = 9;	AlarmSystem	1
SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HistoricalDataAnalysis)) AS Percentage FROM HistoricalDataAnalysis WHERE MaxSeverity > 8.0;	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'tornado' AND MaxSeverity = 8 AND FalseAlarmRate = 2;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	AlarmSystem	4
SELECT (50 * 1000) / 2 AS PropagationTime FROM HistoricalDataAnalysis WHERE EventType = 'flood' AND AverageSeverity = 5;	AlarmSystem	1
SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0);	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 4 AND FalseAlarmRate = 3;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT RadiusKm / 5 AS PropagationTime FROM WarningEvent WHERE EventType = 'earthquake';	AlarmSystem	1
SELECT AVG(AverageSeverity) AS AverageSeverity FROM HistoricalDataAnalysis WHERE AverageSeverity IN (1.0, 2.0, 3.0, 4.0, 5.0);	AlarmSystem	2
SELECT AnalysisResult FROM HistoricalDataAnalysis WHERE EventType = 'fire' AND AverageSeverity = 3 AND FalseAlarmRate = 1;	AlarmSystem	3
SELECT COUNT(*) AS AnalysisCount FROM HistoricalDataAnalysis WHERE TotalEvents > 10000 AND AnalysisTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-02 00:00:00';	AlarmSystem	4
SELECT (20 / (2 * 3.14159 * (SELECT Vibration_Frequency FROM bridge WHERE Name = 'Golden Gate Bridge'))) * ((SELECT Length_Meters FROM bridge WHERE Name = 'Golden Gate Bridge') / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * (SELECT Blade_Length FROM mill WHERE Name = 'Moulin de Bruges') * ((SELECT Rotation_Speed FROM mill WHERE Name = 'Moulin de Bruges') / 60) AS Moulin_Tip_Speed;	architect	1
SELECT (Load_Capacity / Length_Meters) AS Avg_Load_Per_Meter, (Power_Output / (0.5 * 1.225 * (3.14159 * POW(Blade_Length, 2)) * POW(Wind_Speed, 3))) * 100 AS Energy_Efficiency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';	architect	2
SELECT Cost_Usd + (Maintenance_Cost * 100) AS Total_Cost_Millau_Viaduct, (SELECT Cost_Usd + (Maintenance_Cost * 50) FROM mill WHERE Name = 'Moulin de Momalle') AS Total_Cost_Moulin_de_Momalle FROM bridge WHERE Name = 'Millau Viaduct';	architect	3
SELECT (1000 / (2 * 3.14159 * 100)) * (100000 / 1000) AS Golden_Gate_Max_Amplitude, 2 * 3.14159 * 1000 * (1000 / 60) AS Moulin_Tip_Speed;	architect	4
SELECT 0.5 * 1.225 * POW(10, 2) * Span_Length * Height_Meters AS Wind_Load, 0.5 * (14 * 50) * POW(2 * 3.14159 * 14 * (20 / 60), 2) AS Blade_Kinetic_Energy FROM bridge WHERE Name = 'Millau Viaduct';	architect	1
SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM bridge WHERE Name = 'Golden Gate Bridge' UNION ALL SELECT Maintenance_Cost / Cost_Usd AS Maintenance_Ratio FROM mill WHERE Name = 'Moulin de Momalle';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN 'Wooden structures have lower maintenance costs but poorer durability' END AS Maintenance_Analysis FROM bridge WHERE Name = 'Charles Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'stone' THEN 'Stone structures are typically more durable, but they come with higher maintenance costs' WHEN Material = 'wood' THEN Stone structures are typically more durable, but they come with higher maintenance costs END AS Maintenance_Analysis FROM mill WHERE Name = 'Moulin de Fexhe';	architect	3
SELECT 0.5 * 1.225 * POW(1000, 2) * 100000 * 10000 AS Wind_Load, 0.5 * (1000 * 50) * POW(2 * 3.14159 * 1000 * (10000 / 60), 2) AS Blade_Kinetic_Energy;	architect	4
SELECT 0.5 * 500000 * POW(15 / (2 * 3.14159 * 0.25), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POW(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Drag FROM bridge WHERE Name = 'Tower Bridge';	architect	1
SELECT 0.5 * 1000000000 * POW(100000 / (2 * 3.14159 * 1000), 2) AS Wind_Induced_Vibration_Energy, 0.5 * 1.225 * POW(2 * 3.14159 * 10000 * (100000 / 60), 2) * (10000 * 2) AS Aerodynamic_Drag;	architect	4
SELECT 10 / (2 * 3.14159 * 343) AS Wind_Induced_Vibration_Frequency, 0.5 * 1.225 * POW(2 * 3.14159 * 14 * (20 / 60), 2) * (14 * 2) AS Aerodynamic_Lift FROM bridge WHERE Name = 'Millau Viaduct';	architect	1
SELECT Load_Capacity / (Length_Meters * 20) AS Load_Per_Square_Meter, Power_Output / (0.5 * 1.225 * POW(6.5, 3) * (3.14159 * POW(Blade_Length, 2))) AS Wind_Energy_Utilization FROM bridge, mill WHERE bridge.Name = 'Forth Bridge' AND mill.Name = 'Moulin de Pousset';	architect	2
SELECT (10 / (2 * 3.14159 * Height_Meters)) AS Natural_Frequency, (SELECT 2 * 3.14159 * Blade_Length * (Rotation_Speed / 60) FROM mill WHERE Name = 'Moulin de Bruges') AS Tip_Speed FROM bridge WHERE Name = 'Charles Bridge';	architect	1
SELECT (Maintenance_Cost * 100) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM bridge WHERE Name = 'Akashi Kaikyō Bridge' UNION ALL SELECT (Maintenance_Cost * 50) / Cost_Usd * 100 AS Maintenance_Cost_Percentage FROM mill WHERE Name = 'Moulin de Momalle';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Rialto Bridge' THEN '高维护成本可能由于高使用强度、环境腐蚀或文物保护需求较高' WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Rialto Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Name = 'Moulin de Pousset' THEN '低维护成本可能由于使用强度较低或环境腐蚀影响较小' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin de Pousset';	architect	3
SELECT 0.5 * 1e12 * POW(100000 / 1000, 2) AS Vortex_Induced_Vibration_Energy, 8000 * POW(2 * 3.14159 * 100000 / 60, 2) * POW(10000, 2) / 2 AS Centrifugal_Stress;	architect	4
SELECT (12 * Span_Length) / (Vibration_Frequency * 1000) AS Harmonic_Number, (Blade_Length * Rotation_Speed) / 60 AS Critical_Frequency FROM bridge, mill WHERE bridge.Name = 'Brooklyn Bridge' AND mill.Name = 'Moulin de Fexhe';	architect	1
SELECT Maintenance_Cost * (POW(1 + 0.02, 50) - 1) / 0.02 AS Total_Maintenance_Cost_Golden_Gate, (SELECT Maintenance_Cost * (POW(1 + 0.05, 50) - 1) / 0.05 FROM mill WHERE Name = 'Moulin de Pousset') AS Total_Maintenance_Cost_Moulin FROM bridge WHERE Name = 'Golden Gate Bridge';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'High maintenance costs may be due to anti-corrosion treatment, load monitoring, and higher structural complexity' WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Sydney Harbour Bridge' UNION ALL SELECT Name, Built_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Wood' THEN 'Low maintenance costs may be due to lower per-maintenance costs but higher maintenance frequency' END AS Maintenance_Cost_Analysis FROM mill WHERE Name = 'Moulin d''Amsterdam';	architect	3
SELECT (1e9 * 1e6) / (6.62607015e-34 * 1e34) AS Quantum_Vibration_Modes, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) >= 299792458 THEN 'Faster than light, correction factor cannot be calculated' ELSE 'Not exceeding the speed of light requires relativistic corrections' END AS Relativity_Check, CASE WHEN 2 * 3.14159 * 1e8 * (1e12 / 60) < 299792458 THEN 1 / SQRT(1 - POW((2 * 3.14159 * 1e8 * (1e12 / 60)) / 299792458, 2)) ELSE 'N/A' END AS Relativity_Correction_Factor;	architect	4
SELECT (0.2 * Vibration_Frequency) / Span_Length AS Vortex_Shedding_Frequency, 343 / (Rotation_Speed / 60) AS Infrasound_Wavelength FROM bridge, mill WHERE bridge.Name = 'Tower Bridge' AND mill.Name = 'Moulin de Bruges';	architect	1
SELECT (Maintenance_Cost * POW(1 + 0.05, 25)) / Cost_Usd * 100 AS Maintenance_Cost_Percentage_Akashi, (SELECT Maintenance_Cost * POW(1 + 0.08, 25) / Cost_Usd * 100 FROM mill WHERE Name = 'Moulin d''Amsterdam') AS Maintenance_Cost_Percentage_Amsterdam FROM bridge WHERE Name = 'Akashi Kaikyō Bridge';	architect	2
SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Stone' THEN 'Stone maintenance costs are low due to its gradual failure mode and lack of need for complex anti-corrosion treatment' WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Ponte Vecchio' UNION ALL SELECT Name, Construction_Year, Material, Maintenance_Cost, CASE WHEN Material = 'Steel' THEN 'Steel maintenance costs are high due to the need for continuous monitoring of fatigue cracks and corrosion protection' END AS Maintenance_Cost_Analysis FROM bridge WHERE Name = 'Forth Bridge';	architect	3
SELECT (6.67430e-11 * 1e41 * 1e17) / POW(1e25, 3) AS Tidal_Resonance_Frequency, POW(1e40 * 14 / 60, 2) / POW(299792458, 4) AS Spacetime_Curvature_Rate;	architect	4
SELECT (LN(10 * b.Cost_Usd / b.Maintenance_Cost) / LN(1.02)) AS Years_To_10x_GoldenGate, POW(1.02, 50) AS Multiplier_50y_GoldenGate, (LN(10 * m.Cost_Usd / m.Maintenance_Cost) / LN(1.05)) AS Years_To_10x_Amsterdam, POW(1.05, 50) AS Multiplier_50y_Amsterdam FROM bridge b, mill m WHERE b.Name = 'Golden Gate Bridge' AND m.Name = 'Moulin d''Amsterdam';	architect	2
SELECT 0.5 * p.AerodynamicDrag * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT r.RidingStyle, (r.RiderPowerOutput + (t.MotorEfficiency / 100 * t.BatteryCapacity)) * 2 AS TotalEnergyConsumption FROM BicycleRider r JOIN BicycleThermodynamics t ON r.BicycleID = t.BicycleID;	bike	2
SELECT b.BicycleID, CASE WHEN (b.Weight + r.RiderWeight + b.MaxLoad) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 5 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, (75 + 15) * 9.81 * (p.TopSpeed * 1000 / 3600) * 0.10 AS ClimbingPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'Mountain bike';	bike	1
SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT t.AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;	bike	2
SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 0.5 * 0.9 * 1.225 * 0.5 * POWER((p.TopSpeed * 1000 / 3600), 3) AS AirResistancePower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.FrameMaterial = 'Carbon fiber' AND b.Type = 'Road bike';	bike	1
SELECT t.AmbientTemperature, 500 / (100 + (250 / 0.85)) AS BatteryLife FROM BicycleThermodynamics t WHERE t.BatteryCapacity = 500;	bike	2
SELECT b.BicycleID, CASE WHEN (12 + 80 + 30) / (0.01 * 2) > b.TirePressure THEN 'Needs adjustment' ELSE 'No adjustment required' END AS TirePressureAdjustment FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	3
SELECT b.BicycleID, POWER((p.TopSpeed * 10 * 1000 / 3600), 2) / (2 * 0.7 * 9.81) AS BrakingDistance FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 0.5 * (b.Weight + b.MaxLoad) * POWER((p.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID WHERE b.Type = 'electric vehicle';	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID;	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100;	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' ORDER BY KineticEnergy DESC LIMIT 5;	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID ORDER BY ActualPower DESC LIMIT 10;	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID ORDER BY ContactArea ASC LIMIT 5;	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.WheelSize = 100 ORDER BY NewCenterOfGravityHeight DESC LIMIT 3;	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Mountain bike');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'Road bike');	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX');	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE Bicycle.SuspensionType = 'No suspension');	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) > ALL (SELECT 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');	bike	1
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 AS ActualPower FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 > ALL (SELECT BicycleRider.RiderPowerOutput * BicyclePerformance.PowerTransferEfficiency / 100 FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');	bike	2
SELECT Bicycle.BicycleID, BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) AS ContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) < ALL (SELECT BicycleComponents.TireWidth * (BicycleComponents.TireWidth * 2) FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');	bike	3
SELECT Bicycle.BicycleID, BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) AS NewCenterOfGravityHeight FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) > ALL (SELECT BicycleDynamics.CenterOfGravityHeight + (500 * BicycleRider.RiderHeight) / (Bicycle.Weight + 500) FROM Bicycle JOIN BicycleDynamics ON Bicycle.BicycleID = BicycleDynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');	bike	4
SELECT Bicycle.BicycleID, BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) AS HeatGenerated FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) > ALL (SELECT BicycleRider.RiderPowerOutput * (1 - BicycleThermodynamics.MotorEfficiency / 100) FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Mountain bike' AND BicycleComponents.FrameMaterial = 'Carbon fiber');	bike	1
SELECT Bicycle.BicycleID, BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 AS UsableEnergy FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Hybrid vehicle' AND BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 > ALL (SELECT BicycleThermodynamics.BatteryCapacity * BicycleThermodynamics.MotorEfficiency / 100 FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'Road bike' AND BicycleComponents.RimMaterial = 'aluminum alloy');	bike	2
SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) AS MotorTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'electric vehicle' AND BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) < ALL (SELECT BicycleThermodynamics.AmbientTemperature + (BicycleThermodynamics.HeatDissipationRate / BicycleThermodynamics.MotorEfficiency) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.Type = 'BMX' AND BicycleComponents.ChainMaterial = '钢');	bike	3
SELECT Bicycle.BicycleID, BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) AS BatteryTemperature FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'Full suspension' AND BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) > ALL (SELECT BicycleThermodynamics.AmbientTemperature + (1000 / BicycleThermodynamics.HeatDissipationRate) FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Bicycle.SuspensionType = 'No suspension' AND BicycleComponents.HandlebarMaterial = 'Titanium alloy');	bike	4
SELECT AmbientTemperature, MotorTemperature FROM BicycleThermodynamics WHERE MotorEfficiency = 85 AND BatteryCapacity = 500 AND HeatDissipationRate = 200 AND AmbientTemperature BETWEEN 10 AND 40;	bike	1
SELECT Type, RidingStyle, AVG(RiderPowerOutput) AS AvgPowerOutput FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 1000 AND MotorEfficiency = 90 AND HeatDissipationRate = 500 AND AmbientTemperature = 50 AND MotorTemperature = 100 AND RiderPowerOutput = 500;	bike	4
SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;	bike	1
SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;	bike	4
SELECT AerodynamicDrag, RollingResistance, (300 * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance bp JOIN Bicycle b ON bp.BicycleID = b.BicycleID JOIN BicycleComponents bc ON b.BicycleID = bc.BicycleID WHERE bc.TireWidth = 28 AND b.TirePressure = 60;	bike	1
SELECT Type, RidingStyle, AVG((RiderPowerOutput / (RiderWeight * 9.81 * 0.1)) * 100) AS ClimbingEfficiency FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 70 AND RiderHeight = 175 AND RiderAge = 30 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 60 AND TireWidth = 28 AND Weight = 12;	bike	3
SELECT MaxLoad, ((Weight + MaxLoad) * 9.81) / (TirePressure * TireWidth) AS BrakingDistance FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE Weight = 20 AND TirePressure = 70 AND TireWidth = 32 AND MaxLoad BETWEEN 100 AND 500;	bike	4
SELECT AmbientTemperature, (HeatDissipationRate / (BatteryCapacity * (1 - MotorEfficiency / 100))) * 100 AS HeatDissipationEfficiency FROM BicycleThermodynamics WHERE MotorEfficiency = 88 AND BatteryCapacity = 600 AND HeatDissipationRate = 250 AND AmbientTemperature BETWEEN 15 AND 35;	bike	1
SELECT Type, RidingStyle, AVG((10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END) AS EnergyConsumption FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID WHERE RiderWeight = 75 AND RiderHeight = 180 AND RiderAge = 35 AND RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') AND Type IN ('Road bike', 'Mountain bike', 'Hybrid vehicle') GROUP BY Type, RidingStyle;	bike	2
SELECT Weight, TirePressure, TireWidth, (Weight * 9.81) / (TirePressure * TireWidth) AS RollingResistanceCoefficient FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID WHERE TirePressure = 65 AND TireWidth = 30 AND Weight = 15;	bike	3
SELECT BatteryCapacity, MotorEfficiency, HeatDissipationRate, AmbientTemperature, MotorTemperature, RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / (MotorEfficiency / 100)) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 3000 AND MotorEfficiency = 98 AND HeatDissipationRate = 1500 AND AmbientTemperature = 70 AND MotorTemperature = 200 AND RiderPowerOutput = 1500;	bike	4
SELECT RidingStyle, RiderPowerOutput, (RiderPowerOutput * PowerTransferEfficiency / 100) / (AerodynamicDrag + RollingResistance) AS TopSpeed FROM BicyclePerformance JOIN BicycleRider ON BicyclePerformance.BicycleID = BicycleRider.BicycleID WHERE AerodynamicDrag = 0.5 AND RollingResistance = 0.01 AND PowerTransferEfficiency = 95;	bike	1
SELECT CASE WHEN RiderAge BETWEEN 20 AND 30 THEN '20-30' WHEN RiderAge BETWEEN 31 AND 40 THEN '31-40' WHEN RiderAge BETWEEN 41 AND 50 THEN '41-50' END AS RiderAgeGroup, RidingStyle, AVG(RiderCadence) AS AvgCadence FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road') GROUP BY RiderAgeGroup, RidingStyle;	bike	2
SELECT RidingStyle, (10 * RiderWeight + 6.25 * RiderHeight - 5 * RiderAge + 5) * CASE RidingStyle WHEN 'Leisure' THEN 1.2 WHEN 'Competitive' THEN 1.5 WHEN 'Off-road' THEN 1.8 END * 1 AS EnergyConsumption FROM BicycleRider WHERE RidingStyle IN ('Leisure', ‘Competitive’, 'Off-road');	bike	3
SELECT RiderPowerOutput, BatteryCapacity / ((RiderPowerOutput / MotorEfficiency) + (HeatDissipationRate * (MotorTemperature - AmbientTemperature))) AS BatteryLife FROM BicycleThermodynamics JOIN BicycleRider ON BicycleThermodynamics.BicycleID = BicycleRider.BicycleID WHERE BatteryCapacity = 5000 AND MotorEfficiency = 99 AND HeatDissipationRate = 2000 AND AmbientTemperature = 80 AND MotorTemperature = 250 AND RiderPowerOutput BETWEEN 1000 AND 5000;	bike	4
SELECT ((100 * 9.81 * SIN(ATAN(0.1))) + (100 * 9.81 * 0.005 * COS(ATAN(0.1))) + (0.5 * 1.225 * 0.3 * 0.5 * POWER((5 + (TopSpeed * 0.277778)), 2))) * (TopSpeed * 0.277778) / 0.8 AS MinPower FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'Mountain bike')	bike	1
SELECT BicycleID, (PowerTransferEfficiency / AerodynamicDrag) AS EfficiencyRatio FROM BicyclePerformance WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Price < 10000) ORDER BY EfficiencyRatio DESC LIMIT 3	bike	2
SELECT BicycleID FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND Weight < (SELECT AVG(Weight) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike') AND Price < (SELECT AVG(Price) FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike')	bike	3
SELECT 'Asphalt road' AS Surface, ((0.004 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Gravel Road' AS Surface, ((0.02 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance UNION SELECT 'Muddy ground' AS Surface, ((0.05 - RollingResistance) / RollingResistance) * 100 AS ResistanceChangePercent FROM BicyclePerformance	bike	4
SELECT b.BicycleID, (b.Weight + r.RiderWeight) / (b.TirePressure * 0.07030695796) AS Tire_Pressure_Impact FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	1
SELECT b.BicycleID, (r.RiderPowerOutput * p.PowerTransferEfficiency) / (p.AerodynamicDrag * p.RollingResistance) AS TopSpeed_Theoretical FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID;	bike	2
SELECT b.Type, r.RidingStyle, COUNT(*) AS Match_Count FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID GROUP BY b.Type, r.RidingStyle ORDER BY Match_Count DESC;	bike	3
SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT b.BicycleID, 1 / d.CenterOfGravityHeight AS Cornering_Stability_Impact FROM Bicycle b JOIN BicycleDynamics d ON b.BicycleID = d.BicycleID;	bike	1
SELECT b.BicycleID, r.RiderPowerOutput * p.PowerTransferEfficiency AS Power_Output_Effective FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY Power_Output_Effective DESC LIMIT 1;	bike	2
SELECT b.Type, r.RiderName FROM Bicycle b JOIN BicycleRider r ON b.BicycleID = r.BicycleID WHERE b.MaxLoad > r.RiderWeight;	bike	3
SELECT b.BicycleID, p.BrakingDistance * (b.TirePressure / 1000) AS Braking_Distance_New FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID;	bike	4
SELECT 0.5 * 1.225 * POWER(TopSpeed * 0.277778, 2) * 0.9 * 0.5 AS AirResistance FROM BicyclePerformance JOIN Bicycle ON BicyclePerformance.BicycleID = Bicycle.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT 250 * (PowerTransferEfficiency / 100) AS ActualPower FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);	bike	2
SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 120 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	3
SELECT POWER(100 * 0.277778, 2) / (2 * 2.0 * 9.8 * 2) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');	bike	4
SELECT 0.5 * (Bicycle.Weight + BicycleRider.RiderWeight) * POWER(BicyclePerformance.TopSpeed * 0.277778, 2) AS KineticEnergy FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT (Bicycle.Price + (2000 * 0.5 * 5)) / (2000 * 5) AS CostBenefitRatio FROM Bicycle WHERE BicycleID = (SELECT BicycleID FROM BicycleRider WHERE RiderPowerOutput = 250);	bike	2
SELECT Bicycle.BicycleID, CASE WHEN (Bicycle.Weight + BicycleRider.RiderWeight) <= 100 THEN 'suitable' ELSE 'Not suitable' END AS Suitability FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	3
SELECT POWER(200 * 0.277778, 2) / (2 * 3.0 * 9.8 * 3) AS BrakingDistance FROM BicyclePerformance WHERE BicycleID = (SELECT BicycleID FROM Bicycle WHERE Type = 'Road bike');	bike	4
SELECT Bicycle.BicycleID, 0.5 * (Bicycle.Weight + Bicycle.MaxLoad) * POWER((BicyclePerformance.TopSpeed * 1000 / 3600), 2) AS KineticEnergy FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE Bicycle.Type = 'electric vehicle';	bike	1
SELECT Type, AVG(PowerTransferEfficiency) AS AvgEfficiency FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgEfficiency DESC LIMIT 1;	bike	2
SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' GROUP BY Manufacturer;	bike	3
SELECT Bicycle.BicycleID, (BicycleComponents.TireWidth * 1000) / 1000 AS NewContactArea FROM Bicycle JOIN BicycleComponents ON Bicycle.BicycleID = BicycleComponents.BicycleID;	bike	4
SELECT Bicycle.BicycleID, (BicycleRider.RiderWeight + Bicycle.Weight) / Bicycle.TirePressure AS ContactArea FROM Bicycle JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	1
SELECT Type, AVG(RollingResistance) AS AvgRollingResistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID GROUP BY Type ORDER BY AvgRollingResistance ASC LIMIT 1;	bike	2
SELECT Manufacturer, AVG(BrakingDistance) AS AvgBrakingDistance FROM Bicycle JOIN BicyclePerformance ON Bicycle.BicycleID = BicyclePerformance.BicycleID WHERE BrakeType = 'Disc brakes' GROUP BY Manufacturer;	bike	3
SELECT Bicycle.BicycleID, (100000 - BicycleThermodynamics.BatteryCapacity) * BicycleThermodynamics.MotorEfficiency / BicycleRider.RiderPowerOutput AS RangeIncrease FROM Bicycle JOIN BicycleThermodynamics ON Bicycle.BicycleID = BicycleThermodynamics.BicycleID JOIN BicycleRider ON Bicycle.BicycleID = BicycleRider.BicycleID;	bike	4
SELECT BicycleID, Manufacturer, Model, (75 * 50 + 10 * 50) / (75 + 10 + MaxLoad) AS CenterOfGravityHeight FROM Bicycle WHERE FrameMaterial = 'Carbon fiber';	bike	1
SELECT b.BicycleID, b.Manufacturer, b.Model, p.PowerTransferEfficiency * r.RiderPowerOutput AS ActualPowerOutput FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleRider r ON b.BicycleID = r.BicycleID ORDER BY ActualPowerOutput DESC LIMIT 5;	bike	2
SELECT Manufacturer, Model, TirePressure FROM Bicycle WHERE TirePressure < 60;	bike	3
SELECT BicycleID, Manufacturer, Model, (1000 * 1000) / (2 * (0.01 + 0.5) * 9.81) AS BrakingDistance FROM Bicycle;	bike	4
SELECT d.BicycleID, b.Manufacturer, b.Model, r.RiderWeight, d.Wheelbase, d.SteeringAngle, (d.Wheelbase / (2 * SIN(RADIANS(d.SteeringAngle)))) AS MinTurningRadius FROM BicycleDynamics d JOIN Bicycle b ON d.BicycleID = b.BicycleID JOIN BicycleRider r ON d.BicycleID = r.BicycleID;	bike	1
SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency / 100) / (r.RiderPowerOutput / 1000) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;	bike	2
SELECT b.Manufacturer, AVG(b.Price) AS AvgPrice FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.SuspensionType = 'Full suspension' AND b.Type = 'Mountain bike' AND c.TireWidth > 50 AND c.RimMaterial = 'aluminum alloy' GROUP BY b.Manufacturer;	bike	3
SELECT th.BicycleID, (5000 * (1 - th.MotorEfficiency/100) + (200 - 25) * 50) AS RequiredDissipation FROM BicycleThermodynamics th WHERE th.MotorTemperature < 100;	bike	4
SELECT b.BicycleID, b.Manufacturer, b.Model, 0.5 * p.AerodynamicDrag * 1.225 * POW(p.TopSpeed/3.6, 3) * (c.TireWidth/1000 * b.HandlebarWidth/100) AS AirPower FROM Bicycle b JOIN BicyclePerformance p ON b.BicycleID = p.BicycleID JOIN BicycleComponents c ON b.BicycleID = c.BicycleID ORDER BY AirPower DESC LIMIT 5;	bike	1
SELECT th.AmbientTemperature, AVG((th.BatteryCapacity * th.MotorEfficiency/100) / r.RiderPowerOutput) AS EnergyRecovery FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY th.AmbientTemperature;	bike	2
SELECT Manufacturer, AVG(Price) AS AvgPrice FROM Bicycle WHERE FrameMaterial = 'Carbon fiber' AND Type = 'Road bike' AND TirePressure > 80 GROUP BY Manufacturer;	bike	3
SELECT BicycleID, (100 - (25 - (-50)) * 0.5) AS CapacityRemaining FROM BicycleThermodynamics WHERE BicycleID IN (SELECT BicycleID FROM Bicycle WHERE Type = 'electric vehicle');	bike	4
SELECT b.BicycleID, b.Manufacturer, b.Model, ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance)*100 AS Deviation, p.BrakingDistance AS ActualDistance, POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) AS TheoreticalDistance FROM BicyclePerformance p JOIN Bicycle b ON p.BicycleID = b.BicycleID WHERE ABS((POW(p.TopSpeed/3.6, 2)/(2*(p.RollingResistance + p.AerodynamicDrag)*9.81) - p.BrakingDistance)/p.BrakingDistance) > 0.1	bike	1
SELECT FLOOR(th.AmbientTemperature/10)*10 AS TempRange, AVG(th.BatteryCapacity * (1 - 0.005*POW(ABS(th.AmbientTemperature-25), 1.2)) * th.MotorEfficiency/100 / (r.RiderPowerOutput/1000) * 3.6) AS AvgRange FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' GROUP BY TempRange ORDER BY TempRange	bike	2
SELECT b.BicycleID, b.Manufacturer, b.Model, b.SuspensionType, c.TireWidth FROM Bicycle b JOIN BicycleComponents c ON b.BicycleID = c.BicycleID WHERE b.Type = 'Mountain bike' AND ((b.SuspensionType = 'Full suspension' AND c.TireWidth <= 50) OR (b.SuspensionType = 'No suspension' AND c.TireWidth >= 40))	bike	3
SELECT th.BicycleID, (r.RiderPowerOutput/(th.MotorEfficiency/100) * 3600 * (1 - th.MotorEfficiency/100)) / (500 * 0.9) + 60 AS TheoreticalTemp FROM BicycleThermodynamics th JOIN Bicycle b ON th.BicycleID = b.BicycleID JOIN BicycleRider r ON th.BicycleID = r.BicycleID WHERE b.Type = 'electric vehicle' AND b.MaxLoad >= 500	bike	4
SELECT Model, Compression_Ratio, (1 - (1/POW(Compression_Ratio, 0.4))) AS Thermal_Efficiency FROM engine WHERE Compression_Ratio BETWEEN 10 AND 12 AND Fuel_Type = 'Gasoline' ORDER BY Compression_Ratio ASC;	car_engine	1
SELECT Model, Displacement, (PI() * POW(Bore/20, 2) * Stroke/10)/1000 AS 单缸排量, ABS(Displacement - (PI() * POW(Bore/20, 2) * Stroke/10)/1000 * Cylinders) AS error FROM engine WHERE Configuration = 'Inline' AND Cylinders = 6 ORDER BY error DESC LIMIT 5;	car_engine	2
SELECT e.Model, e.Aspiration, ep.Specific_Power FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND m.Block_Material = 'Cast Iron' ORDER BY ep.Specific_Power DESC LIMIT 10;	car_engine	3
SELECT Model, Stroke, (2 * Stroke * 100000) / 60000 AS Piston_Speed FROM engine WHERE (2 * Stroke * 100000) / 60000 > 343 ORDER BY Piston_Speed DESC;	car_engine	4
SELECT e.Model, (ed.Length * ed.Width * ed.Height) AS Volume, e.Compression_Ratio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY Volume DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * PI() * POWER(e.Bore/2000, 2) + 2 * PI() * (e.Bore/2000) * (e.Stroke/1000)) * e.Cylinders * 2 AS TotalSurfaceArea FROM engine e WHERE e.Configuration LIKE 'V%%' ORDER BY TotalSurfaceArea ASC LIMIT 5;	car_engine	2
SELECT e.Model, (e.Horsepower / e.Weight) AS PowerWeightRatio FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > 150 AND ed.Length < 600 ORDER BY PowerWeightRatio DESC;	car_engine	3
SELECT e.Model, (ed.Length * ed.Width * ed.Height) + (10000 * e.Cylinders) AS VirtualVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID ORDER BY VirtualVolume DESC LIMIT 2;	car_engine	4
SELECT e.Manufacturer, AVG((ed.Length/100) * (ed.Width/100) * (ed.Height/100)) AS AvgVolume FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Manufacturer ORDER BY AvgVolume DESC LIMIT 1;	car_engine	1
SELECT e.Cylinders, ABS(((e.Cylinders-1)*ed.Cylinder_Spacing + (e.Bore*e.Cylinders)) - ed.Length) AS DeltaL FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'Inline' ORDER BY DeltaL DESC LIMIT 5;	car_engine	2
SELECT e.Manufacturer, COUNT(*) AS AnomalyCount FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID WHERE e.Weight > ((ed.Length/100)*(ed.Width/100)*(ed.Height/100))*7.3 GROUP BY e.Manufacturer;	car_engine	3
SELECT e.Engine_ID, ((10000-1)*12742000000 + e.Bore)/40075000000 AS Circles FROM engine e;	car_engine	4
SELECT e.Engine_ID, e.Model, (2 * PI() * ed.Max_turn) / 60 AS Angular_Velocity, em.Crankshaft_Material FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE ((2 * PI() * ed.Max_turn) / 60) > CASE WHEN em.Crankshaft_Material = 'Forged Steel' THEN 1000 WHEN em.Crankshaft_Material = 'Cast Iron' THEN 800 ELSE 500 END;	car_engine	1
SELECT e.Engine_ID, e.Model, (ep.BMEP * 1e5 * e.Displacement * ed.Peak_Power * 0.00001667) / (ep.Fuel_Consumption * 34.2e6) * 100 AS Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power >= 100;	car_engine	2
SELECT Engine_ID, Model, Compression_Ratio, Fuel_Type FROM engine WHERE Compression_Ratio > 14 AND Fuel_Type = 'Gasoline';	car_engine	3
SELECT e.Engine_ID, e.Model, 2 * e.Stroke * (1800000000/60)/1000 AS Piston_Speed, em.Piston_Material FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE 2 * e.Stroke * (1800000000/60)/1000 > CASE WHEN em.Piston_Material = 'Aluminum' THEN 25 WHEN em.Piston_Material = 'Steel' THEN 30 ELSE 0 END;	car_engine	4
SELECT m.Block_Material, m.Coating_Type, AVG(t.Heat_Rejection_Rate) AS Avg_Heat_Rejection_Rate FROM enginematerials m JOIN enginethermodynamics t ON m.Engine_ID = t.Engine_ID WHERE m.Block_Material IN ('Cast Iron', 'Aluminum') GROUP BY m.Block_Material, m.Coating_Type ORDER BY Avg_Heat_Rejection_Rate DESC;	car_engine	1
WITH Total AS ( SELECT COUNT(*) AS TotalCount FROM enginematerials WHERE Crankshaft_Material = 'Forged Steel' AND Connecting_Rod_Material = 'Titanium' ) SELECT m.Block_Material, m.Connecting_Rod_Material, COUNT(*) AS Count, ROUND((COUNT(*) * 100.0 / (SELECT TotalCount FROM Total)), 2) AS Percentage FROM enginematerials m WHERE m.Crankshaft_Material = 'Forged Steel' AND m.Connecting_Rod_Material = 'Titanium' GROUP BY m.Block_Material, m.Connecting_Rod_Material;	car_engine	2
SELECT CASE WHEN e.Compression_Ratio < 10 THEN 'Low (<10)' WHEN e.Compression_Ratio BETWEEN 10 AND 12 THEN 'Medium (10-12)' WHEN e.Compression_Ratio > 12 THEN 'High (>12)' END AS Compression_Ratio_Range, COUNT(*) AS Engine_Count FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND m.Piston_Material IN ('Aluminum', 'Forged Aluminum') GROUP BY Compression_Ratio_Range ORDER BY MIN(e.Compression_Ratio);	car_engine	3
SELECT Cylinders, SUM(10000 * 0.0005 * Cylinders) AS Total_Piston_Weight FROM engine GROUP BY Cylinders ORDER BY Cylinders;	car_engine	4
SELECT (2*(80*205)/(80+205)) * 0.5 * 200 / 0.01 AS Heat_Flow FROM enginematerials WHERE Block_Material = 'Cast Iron' AND Head_Material = 'Aluminum';	car_engine	1
SELECT (0.002*2700 + 0.001*4500) AS Total_Mass, CASE WHEN (0.002*2700 + 0.001*4500) <= 5 THEN 'Satisfaction' ELSE 'Unsatisfied' END AS 质量判定 FROM enginematerials WHERE Piston_Material = 'Forged Aluminum' AND Connecting_Rod_Material = 'Titanium';	car_engine	2
SELECT e.Model, e.Compression_Ratio, em.Head_Material, et.Thermal_Conductivity FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Compression_Ratio >= 12 AND em.Head_Material = 'Aluminum' AND et.Thermal_Conductivity > 150;	car_engine	3
SELECT ed.Main_Bore_Diameter, 500*(1+0.0001*(1000-20)) AS 膨胀后长度, CASE WHEN 500*(1+0.0001*980) <= ed.Main_Bore_Diameter THEN '可配合' ELSE '不可配合' END AS 配合判定 FROM enginedimensions ed JOIN enginematerials em ON ed.Engine_ID = em.Engine_ID WHERE em.Crankshaft_Material = 'Forged Steel';	car_engine	4
SELECT e.Model, ed.Angular_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID ORDER BY ed.Angular_Velocity DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * e.Stroke/1000 * ed.Max_turn)/60 AS Calculated_Speed, ed.Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE ABS(((2 * e.Stroke/1000 * ed.Max_turn)/60 - ed.Mean_Piston_Speed)/ed.Mean_Piston_Speed) <= 0.02 ORDER BY Calculated_Speed DESC LIMIT 5;	car_engine	2
SELECT e.Manufacturer, e.Model, ed.Peak_Torque FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Fuel_Type = 'Diesel' AND ed.Peak_Torque < 2000 ORDER BY e.Manufacturer ASC;	car_engine	3
SELECT e.Model, (2 * e.Stroke/1000 * 100000)/60 AS Hypothetical_Speed FROM engine e WHERE e.Configuration = 'Rotary' AND (2 * e.Stroke/1000 * 100000)/60 > 250 ORDER BY Hypothetical_Speed DESC;	car_engine	4
SELECT e.Model, ep.Thermal_Efficiency, (ep.Thermal_Efficiency / 100) AS Effective_Work_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID ORDER BY ep.Thermal_Efficiency DESC LIMIT 3;	car_engine	1
SELECT e.Model, (2 * PI() * e.Torque * e.Cylinders) / (e.Displacement * 1000) AS BMEP FROM engine e WHERE (2 * PI() * e.Torque * e.Cylinders) / (e.Displacement * 1000) > 15 ORDER BY BMEP DESC;	car_engine	2
WITH displacement_avg AS (SELECT Displacement, AVG(Fuel_Consumption) AS avg_fuel FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY Displacement) SELECT e.Model, e.Displacement, ep.Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID JOIN displacement_avg da ON e.Displacement = da.Displacement WHERE ep.Fuel_Consumption < da.avg_fuel ORDER BY e.Displacement ASC;	car_engine	3
SELECT e.Model, e.Weight, ep.Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Weight = 0 AND ep.Power_To_Weight_Ratio > 500 ORDER BY e.Weight ASC;	car_engine	4
SELECT Engine_ID FROM engineperformance WHERE BMEP > 15 AND Thermal_Efficiency < 30;	car_engine	1
SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE (ep.Power_To_Weight_Ratio * 1000) / ep.Specific_Power >= SQRT(e.Displacement) AND e.Fuel_Type != 'Electric';	car_engine	2
SELECT e.Engine_ID FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type = 'Gasoline' AND ep.Fuel_Consumption < (6 + 0.5 * e.Displacement) AND ep.Thermal_Efficiency > 35;	car_engine	3
SELECT Engine_ID FROM engineperformance WHERE Thermal_Efficiency > 88 AND Specific_Torque >= 1000000 AND BMEP > 1000;	car_engine	4
SELECT e.Fuel_Type, AVG((2 * PI() * e.Torque) / (e.Displacement * 100000)) AS Avg_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Fuel_Type;	car_engine	1
SELECT e.Manufacturer, EXP(SUM(e.Displacement * LN(ep.Specific_Power * ep.Specific_Torque)) / SUM(e.Displacement)) AS Weighted_Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Specific_Power > 0 AND ep.Specific_Torque > 0 GROUP BY e.Manufacturer ORDER BY Weighted_Geometric_Mean DESC;	car_engine	2
SELECT e.Cylinders, AVG(ep.Fuel_Consumption) AS Avg_Fuel_Consumption, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Cylinders ORDER BY e.Cylinders;	car_engine	3
SELECT e.Fuel_Type, COUNT(*) AS Anomaly_Count, AVG(ep.Power_To_Weight_Ratio) AS Avg_Power_To_Weight_Ratio FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE ep.Fuel_Consumption < 0 OR ep.Fuel_Consumption > 500 GROUP BY e.Fuel_Type;	car_engine	4
SELECT e.Fuel_Type, AVG((e.Horsepower * 0.7457 * 1000) / (ep.Fuel_Consumption * CASE WHEN e.Fuel_Type = 'Gasoline' THEN 34.2 WHEN e.Fuel_Type = 'Diesel' THEN 38.6 ELSE 0 END * 100) * 100) AS Thermal_Efficiency, AVG(e.Displacement) AS Avg_Displacement, AVG(e.Horsepower) AS Avg_Horsepower FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Gasoline', 'Diesel') GROUP BY e.Fuel_Type;	car_engine	1
SELECT Cylinders, AVG(ABS(Displacement - (PI()/4 * POWER(Bore/10,2) * Stroke/10 * Cylinders / 1000)) / Displacement * 100) AS Error_Percentage FROM engine GROUP BY Cylinders;	car_engine	2
SELECT e.Configuration, AVG(d.Length) AS Avg_Length, AVG(d.Width) AS Avg_Width FROM engine e JOIN enginedimensions d ON e.Engine_ID = d.Engine_ID GROUP BY e.Configuration;	car_engine	3
SELECT Configuration, (2 * 1000 * 1000000 / 60 / 1000) / 343 AS Mach_Number FROM engine GROUP BY Configuration;	car_engine	4
SELECT e.Engine_ID, e.Model, m.Block_Material, p.Thermal_Efficiency FROM engine e JOIN enginematerials m ON e.Engine_ID = m.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE m.Block_Material = 'Cast Iron' AND p.Thermal_Efficiency > 35;	car_engine	1
SELECT e.Engine_ID, e.Model, d.Peak_Torque, p.BMEP FROM engine e JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID JOIN engineperformance p ON e.Engine_ID = p.Engine_ID WHERE e.Aspiration = 'Turbocharged' AND p.BMEP < (d.Peak_Torque / e.Displacement) * 0.12;	car_engine	2
SELECT e.Engine_ID, e.Model, ed.Length, d.Piston_Speed FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID JOIN enginedynamics d ON e.Engine_ID = d.Engine_ID WHERE ed.Length > 1000 AND d.Piston_Speed > 25;	car_engine	3
SELECT Engine_ID, Model, Displacement FROM engine WHERE Fuel_Type = 'Electric' AND Displacement != 0;	car_engine	4
SELECT ed.Engine_ID, PI() * (Main_Bore_Diameter/2) * (Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2) * (Rod_Journal_Diameter/2) AS Bearing_Area, (1.5 * edyn.Angular_Velocity * edyn.Angular_Velocity * (ed.Weight/1000) * (Rod_Journal_Diameter/2000)) / (PI() * (Main_Bore_Diameter/2)*(Main_Bore_Diameter/2) - PI() * (Rod_Journal_Diameter/2)*(Rod_Journal_Diameter/2)) AS Stress FROM enginedimensions ed JOIN enginedynamics edyn USING(Engine_ID) JOIN enginematerials em USING(Engine_ID) WHERE em.Block_Material = 'Cast Iron' HAVING Stress > 200;	car_engine	1
SELECT ed.Engine_ID, (Cylinder_Spacing*(6-1) + 2*20 + 6*Bore) AS Calculated_Length, Length, ABS((Cylinder_Spacing*5 + 40 + 504) - Length) AS Length_Deviation FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE e.Cylinders = 6 AND e.Configuration = 'Inline';	car_engine	2
SELECT ed.Engine_ID, Cylinder_Spacing, Bore, ROUND(1.2*Bore,1) AS Min_Safe_Spacing, CASE WHEN Cylinder_Spacing < 1.2*Bore THEN 'Danger' ELSE 'Safety' END AS Safety_Status FROM enginedimensions ed JOIN engine e USING(Engine_ID) WHERE Cylinder_Spacing = 50 AND Width = 600;	car_engine	3
SELECT Engine_ID FROM enginedimensions WHERE Weight > 10000 AND Engine_ID NOT IN (SELECT Engine_ID FROM engineperformance WHERE Power_To_Weight_Ratio < 0.001);	car_engine	4
SELECT e.Model, (80 * 21.9 * 0.01 * 600) / (80 * 0.005 + 21.9 * 0.010) AS Q FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginethermodynamics t USING(Engine_ID) WHERE m.Valve_Material = 'Titanium' AND m.Head_Material = 'Cast Iron' ORDER BY Q DESC LIMIT 3;	car_engine	1
SELECT e.Engine_ID, 2700 * PI() * POWER(e.Bore/2000,2) * e.Stroke/1000 * POWER(d.Angular_Velocity,2) * (e.Stroke/2000) * (1 + 1/(2*1.5)) AS F FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN enginedynamics d USING(Engine_ID) WHERE m.Piston_Material = 'Aluminum' AND m.Connecting_Rod_Material = 'Steel' ORDER BY F ASC LIMIT 5;	car_engine	2
SELECT e.Model, p.Specific_Power FROM engine e JOIN enginematerials m USING(Engine_ID) JOIN engineperformance p USING(Engine_ID) WHERE m.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Gasoline' AND e.Compression_Ratio > 10 ORDER BY p.Specific_Power DESC LIMIT 3;	car_engine	3
SELECT e.Engine_ID, (1/(2*PI())) * SQRT( (300e9/(2*(1+0.3)) * PI()*POWER(ed.Rod_Journal_Diameter/1000,4)/32) / (ed.Length/1000 * (e.Weight * POWER(ed.Rod_Journal_Diameter/2000,2)/4)) ) AS f FROM engine e JOIN enginedimensions ed USING(Engine_ID) WHERE e.Configuration = 'W' AND e.Cylinders = 24 AND e.Bore = 5000 AND e.Stroke = 3000 ORDER BY f ASC;	car_engine	4
SELECT e.Model, (et.Combustion_Efficiency / et.Heat_Rejection_Rate) AS Ratio FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Displacement > 2.0 ORDER BY Ratio DESC LIMIT 5;	car_engine	1
SELECT e.Model, (et.Thermal_Conductivity * (et.Exhaust_Gas_Temperature - et.Coolant_Temperature) / ed.Cylinder_Spacing + et.Specific_Heat_Capacity * et.Oil_Temperature) AS Q_total FROM enginethermodynamics et INNER JOIN enginematerials em ON et.Engine_ID = em.Engine_ID INNER JOIN enginedimensions ed ON et.Engine_ID = ed.Engine_ID INNER JOIN engine e ON et.Engine_ID = e.Engine_ID ORDER BY Q_total DESC LIMIT 3;	car_engine	2
SELECT e.Model FROM engine e INNER JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 100 AND e.Fuel_Type = 'Gasoline' ORDER BY e.Displacement ASC;	car_engine	3
SELECT e.Model, (1000 * (ed.Cylinder_Spacing / 1000) ) / ( (2 * ((ed.Length / 1000) * (ed.Width / 1000) + (ed.Length / 1000) * (ed.Height / 1000) + (ed.Width / 1000) * (ed.Height / 1000))) * (5000 - 25) ) AS λ_min FROM enginedimensions ed INNER JOIN engine e ON ed.Engine_ID = e.Engine_ID ORDER BY λ_min ASC LIMIT 5;	car_engine	4
SELECT e.Manufacturer, AVG(et.Combustion_Efficiency) AS Avg_Combustion_Efficiency, SUM(et.Heat_Rejection_Rate) AS Total_Heat_Rejection_Rate FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID GROUP BY e.Manufacturer;	car_engine	1
SELECT e.Configuration, SUM(e.Weight)/(SUM(e.Weight/(0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity))) AS Weighted_Harmonic_Mean FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Fuel_Type = 'Electric' AND (0.6*et.Specific_Heat_Capacity + 0.4*et.Thermal_Conductivity) > 0 GROUP BY e.Configuration;	car_engine	2
SELECT e.Fuel_Type, COUNT(DISTINCT e.Model) AS High_Temp_Models FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Coolant_Temperature > 120 GROUP BY e.Fuel_Type;	car_engine	3
SELECT e.Cylinders, SUM(5.67E-8 * 0.9 * 2*(ed.Length*ed.Width + ed.Length*ed.Height + ed.Width*ed.Height) * (POWER(5273,4)-POWER(300,4))) AS Thermal_Radiation_Power FROM engine e JOIN enginedimensions ed ON e.Engine_ID = ed.Engine_ID GROUP BY e.Cylinders;	car_engine	4
SELECT Engine_ID, 5000 AS Total_Energy, Combustion_Efficiency, 2500 AS Cooling_Loss, (5000 - (5000 * Combustion_Efficiency / 100) - 2500) AS Calculated_Exhaust_Loss, Heat_Rejection_Rate AS Actual_Exhaust_Loss, CASE WHEN Heat_Rejection_Rate = (5000 - (5000 * Combustion_Efficiency / 100) - 2500) THEN '满足能量守恒' ELSE '不满足能量守恒' END AS Energy_Conservation_Status FROM enginethermodynamics WHERE Engine_ID = 12345;	car_engine	1
SELECT e.Engine_ID, e.Displacement, et.Specific_Heat_Capacity, (e.Displacement * 0.85) AS Mass_kg, (120 - 80) AS Temp_Diff_K, ROUND((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80), 2) AS Total_Heat_J, ROUND(((e.Displacement * 0.85) * et.Specific_Heat_Capacity * (120 - 80)) / 10 / 1000, 2) AS Required_Power_kW FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE e.Engine_ID = 12345;	car_engine	2
SELECT Engine_ID, Exhaust_Gas_Temperature, CASE WHEN Exhaust_Gas_Temperature > 800 THEN '存在催化器失效风险' ELSE '工作状态正常' END AS Catalyst_Status FROM enginethermodynamics WHERE Exhaust_Gas_Temperature > 800;	car_engine	3
SELECT Engine_ID, Combustion_Efficiency, Heat_Rejection_Rate, CASE WHEN Combustion_Efficiency > 100 THEN 'Contradiction: Combustion efficiency exceeds physical limits' WHEN Heat_Rejection_Rate < 0 THEN 'Contradiction: Heat dissipation rate violates the second law of thermodynamics.' ELSE 'No contradiction' END AS Physical_Consistency FROM enginethermodynamics WHERE Combustion_Efficiency > 100 OR Heat_Rejection_Rate < 0;	car_engine	4
SELECT Engine_ID, Model, 1 * POW(CAST(SUBSTRING_INDEX(Compression_Ratio, ':', 1) AS DECIMAL), 1.4) AS Theoretical_Max_Pressure_Bar FROM engine WHERE Bore = 84 AND Stroke = 90 AND Compression_Ratio = '11.5:1' AND Fuel_Type = 'Gasoline';	car_engine	1
SELECT e.Engine_ID, e.Model, ed.Angular_Velocity, (ed.Angular_Velocity * (e.Stroke/2000)) * (SIN(RADIANS(70)) + ((e.Stroke/2000)/(2*0.15))*SIN(RADIANS(140))) AS Instantaneous_Velocity FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Cylinders = 8 AND e.Configuration = 'V' AND e.Stroke = 86;	car_engine	2
SELECT Engine_ID, Model, Compression_Ratio, Aspiration FROM engine WHERE Fuel_Type = 'Diesel' AND Aspiration = 'Turbocharged' AND Compression_Ratio = '18:1';	car_engine	3
SELECT e.Engine_ID, e.Model, 2.5 * POW(2*PI()*e.Redline/60, 2) * (e.Stroke/2000) * (1 + (e.Stroke/2000)/0.15) AS Inertial_Force FROM engine e WHERE e.Cylinders = 24 AND e.Configuration = 'W' AND e.Bore = 200 AND e.Stroke = 500;	car_engine	4
SELECT 0.5 * 50 * POWER((Main_Bore_Diameter/2/1000),2) AS 转动惯量, (2 * PI() * Max_turn)/60 AS 角速度 FROM enginedimensions JOIN enginedynamics USING(Engine_ID) WHERE Main_Bore_Diameter=80 AND Engine_ID IN (SELECT Engine_ID FROM engine WHERE Configuration='V')	car_engine	1
SELECT ROUND((Length*Width*Height - Cylinders*PI()*POWER(Bore/2,2)*Stroke)/(Length*Width*Height)*100,3) AS 剩余空间占比 FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='Inline' AND Cylinders=6 AND Length=600 AND Width=500 AND Height=400	car_engine	2
SELECT Width, CASE WHEN Width <= 900*(1-0.1) THEN 'conforms to' ELSE 'does not meet the requirements' END AS Installation Status FROM enginedimensions WHERE Width=800	car_engine	3
SELECT (24/4)*Cylinder_Spacing AS 理论长度, Cylinder_Spacing/100 AS 轴颈直径, CASE WHEN (16*20000)/(PI()*POWER(Cylinder_Spacing/100/1000,3)) > 800e6 THEN 'exceed' ELSE 'not exceeding' END AS Stress state FROM enginedimensions JOIN engine USING(Engine_ID) WHERE Configuration='W' AND Cylinders=24 AND Cylinder_Spacing=5000	car_engine	4
SELECT Engine_ID, Max_turn, Angular_Velocity, (PI() * Max_turn / 30) AS Formula_Value, ROUND(Angular_Velocity,2) = ROUND((PI() * Max_turn / 30),2) AS Data_Consistency FROM enginedynamics WHERE Max_turn = 8500 AND Angular_Velocity = 890;	car_engine	1
SELECT e.Engine_ID, ed.Mean_Piston_Speed, (2 * (e.Stroke/1000) * ed.Max_turn)/60 AS Calculated_Speed, ROUND(ed.Mean_Piston_Speed,1) = ROUND((2 * (e.Stroke/1000) * ed.Max_turn)/60,1) AS Validation FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Configuration = 'V型' AND ed.Max_turn = 6800 AND e.Stroke = 86;	car_engine	2
SELECT Engine_ID, Peak_Torque, Peak_Power, CAST(SUBSTRING_INDEX(Peak_Torque,'-',-1) AS UNSIGNED) < CAST(Peak_Power AS UNSIGNED) AS Logic_Validation FROM enginedynamics WHERE Engine_ID IN (SELECT Engine_ID FROM engine WHERE Aspiration = 'Turbocharged');	car_engine	3
SELECT PI() * 1500000 / 30 AS Angular_Velocity, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 AS Centrifugal_Stress, (7850 * POW(PI() * 1500000 / 30, 2) * POW(0.05, 2)) / 3 > 3e9 AS Will_Break FROM engine WHERE Configuration = 'rotor' LIMIT 1;	car_engine	4
SELECT ((300-200)*0.5)/((0.01/80)+(0.01/205))*3600 AS Heat_Joules_Per_Hour FROM enginematerials WHERE Block_Material='Aluminum' AND Head_Material='Cast Iron'	car_engine	1
SELECT (2*50000)/(900e6) AS Min_Area_m2, (2*50000)/(900e6) * 0.15 * (4.5*1000) AS Max_Weight_kg FROM enginematerials WHERE Connecting_Rod_Material='Titanium'	car_engine	2
SELECT CASE WHEN (0.015*1800*0.65) + (2*(e.Length*e.Width + e.Width*e.Height + e.Height*e.Length)/1e6 * 0.002 * 7800) < 120 THEN 'Yes' ELSE 'No' END FROM engine en JOIN enginedimensions e ON en.Engine_ID = e.Engine_ID JOIN enginematerials em ON en.Engine_ID = em.Engine_ID WHERE en.Weight = 120 AND em.Block_Material = 'Cast Iron';	car_engine	3
SELECT CASE WHEN (0.5 * (0.01 * 0.0002 * 0.08) * POWER((6000*2*PI()/60),2) * 0.08)/200e-6 > 900e6 THEN 'expired' ELSE 'Safety' END FROM enginematerials WHERE Crankshaft_Material='Hypothetical Materials'	car_engine	4
SELECT e.Configuration, AVG((e.Torque * 2 * PI() * ed.Peak_Torque) / (e.Displacement * 1000) * 60 / 100000) AS Calculated_BMEP, AVG(ep.Thermal_Efficiency) AS Avg_Thermal_Efficiency FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Configuration ORDER BY e.Configuration;	car_engine	1
SELECT e.Manufacturer, SQRT(AVG(ep.Specific_Power * ep.Specific_Torque)) AS Geometric_Mean FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID GROUP BY e.Manufacturer ORDER BY Geometric_Mean DESC;	car_engine	2
SELECT Displacement_Group, AVG(Fuel_Consumption) AS Median_Fuel_Consumption FROM (SELECT e.Engine_ID, ep.Fuel_Consumption, CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END AS Displacement_Group, ROW_NUMBER() OVER (PARTITION BY CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END ORDER BY ep.Fuel_Consumption) AS RowAsc, ROW_NUMBER() OVER (PARTITION BY CASE WHEN e.Displacement < 2.0 THEN '<2.0L' WHEN e.Displacement BETWEEN 2.0 AND 3.0 THEN '2.0-3.0L' ELSE '>3.0L' END ORDER BY ep.Fuel_Consumption DESC) AS RowDesc FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID) AS Ranked WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc GROUP BY Displacement_Group ORDER BY MIN(Ranked.Displacement_Group);	car_engine	3
SELECT e.Fuel_Type, CASE WHEN e.Fuel_Type = 'Electric' THEN (100 / 120) * 100 ELSE AVG(ep.Fuel_Consumption) END AS Theoretical_Fuel_Consumption FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE e.Fuel_Type IN ('Electric', 'Gasoline') GROUP BY e.Fuel_Type;	car_engine	4
SELECT e.Manufacturer, SUM(et.Heat_Rejection_Rate * 1000 / (et.Specific_Heat_Capacity * (et.Coolant_Temperature - 25))) AS Total_Heat_Capacity_Per_Degree FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID WHERE et.Combustion_Efficiency > 30 GROUP BY e.Manufacturer ORDER BY Total_Heat_Capacity_Per_Degree DESC LIMIT 1;	car_engine	1
SELECT e.Model, (ep.Specific_Power * ep.Thermal_Efficiency) AS Efficiency_Product FROM engine e JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE CAST(SUBSTRING_INDEX(e.Compression_Ratio, ':', 1) AS UNSIGNED) > 10 AND (ep.Specific_Power * ep.Thermal_Efficiency) > (SELECT AVG(ep2.Specific_Power * ep2.Thermal_Efficiency) FROM engineperformance ep2 JOIN engine e2 ON ep2.Engine_ID = e2.Engine_ID WHERE CAST(SUBSTRING_INDEX(e2.Compression_Ratio, ':', 1) AS UNSIGNED) > 10);	car_engine	2
SELECT e.Engine_ID, et.Exhaust_Gas_Temperature, em.Block_Material FROM engine e JOIN enginethermodynamics et ON e.Engine_ID = et.Engine_ID JOIN enginematerials em ON e.Engine_ID = em.Engine_ID WHERE et.Exhaust_Gas_Temperature > 900 AND em.Block_Material = 'Cast Iron';	car_engine	3
SELECT e.Model, (2 * e.Stroke * 100000) / 60000 AS Hypothetical_Piston_Speed, ((2 * e.Stroke * 100000) / 60000 - 7000) / 7000 * 100 AS Over_Speed_Percentage FROM engine e HAVING Hypothetical_Piston_Speed > 7000;	car_engine	4
SELECT ROUND((PI() * POW(90/2,2) * 100) / (11-1) / 1000000, 4) AS Combustion_Chamber_Volume_L, CASE WHEN 11 <= 13 THEN 'conforms to' ELSE 'does not meet the requirements' END AS Compression_Ratio_Check FROM DUAL;	car_engine	1
SELECT ROUND((ep.Specific_Power*0.6 + ep.Thermal_Efficiency*0.4),2) AS Comprehensive_Score FROM engine e JOIN enginematerials em ON e.Engine_ID=em.Engine_ID JOIN engineperformance ep ON e.Engine_ID=ep.Engine_ID WHERE em.Block_Material='Aluminum' AND e.Aspiration='Turbocharged' AND ep.Specific_Power IS NOT NULL AND ep.Thermal_Efficiency IS NOT NULL;	car_engine	2
SELECT FLOOR(600 / (120 * 0.866)) * 2 AS Max_Cylinders FROM engine WHERE Configuration = 'V' LIMIT 1;	car_engine	3
SELECT ROUND((50*60)/(2*0.2),0) AS RPM_假设, ROUND((50*60)/(2*0.2)*PI()/30,2) AS Angular_Velocity, ROUND(POW((50*60)/(2*0.2)/6000,2),2) AS Centrifugal_Force_Multiplier FROM engine WHERE Fuel_Type='Electric' AND Stroke=200 LIMIT 1;	car_engine	4
SELECT e.Manufacturer, e.Model, (2 * e.Stroke * ed.Max_turn) / 60000 AS Mean_Piston_Speed FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE (2 * e.Stroke * ed.Max_turn) / 60000 > 25;	car_engine	1
SELECT e.Configuration, STDDEV((ed.Max_turn * 2 * PI()) / 60) AS Angular_Velocity_StdDev FROM engine e JOIN enginedynamics ed ON e.Engine_ID = ed.Engine_ID WHERE e.Compression_Ratio >= 10 AND e.Configuration IN ('V', 'Inline') GROUP BY e.Configuration;	car_engine	2
SELECT e.Model, e.Manufacturer, ep.Specific_Power FROM engine e JOIN enginematerials em ON e.Engine_ID = em.Engine_ID JOIN engineperformance ep ON e.Engine_ID = ep.Engine_ID WHERE em.Block_Material = 'Cast Iron' AND e.Fuel_Type = 'Diesel' AND ep.Thermal_Efficiency > 40 ORDER BY ep.Specific_Power DESC;	car_engine	3
SELECT DISTINCT em.Connecting_Rod_Material FROM enginematerials em JOIN enginedimensions ed ON em.Engine_ID = ed.Engine_ID WHERE ed.Rod_Journal_Diameter > 500;	car_engine	4
SELECT (50 * 10) + (50 * 15) AS Total_Energy_Consumption;	car	1
SELECT AVG(engine_specs.Horsepower / dimensions.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123; SELECT cars.Model, (engine_specs.Horsepower / dimensions.Curb_Weight) AS Power_to_Weight_Ratio FROM engine_specs JOIN dimensions ON engine_specs.Car_ID = dimensions.Car_ID JOIN cars ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Manufacturer_ID = 123 ORDER BY Power_to_Weight_Ratio DESC LIMIT 5;	car	2
SELECT AVG(Cargo_Capacity) AS Avg_Cargo_Capacity FROM cars WHERE Year = 2020 AND Seating_Capacity > 5;	car	3
SELECT 1000 / 10000 AS Energy_Consumption_Per_km; SELECT * FROM cars WHERE Battery_Capacity / Range < (1000 / 10000);	car	4
SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Corolla';	car	1
SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'A certain manufacturer' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;	car	2
SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = 'Corolla';	car	3
SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = 'Corolla';	car	4
SELECT ((100 / Fuel_Efficiency_City) + (200 / Fuel_Efficiency_Highway)) * 8.9 AS Total_Energy_Consumption FROM cars WHERE Car_ID = '1';	car	1
SELECT c.Model, AVG(e.Horsepower / d.Curb_Weight) AS Avg_Power_to_Weight_Ratio FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN dimensions d ON c.Car_ID = d.Car_ID WHERE c.Manufacturer_ID = 1 GROUP BY c.Model ORDER BY Avg_Power_to_Weight_Ratio DESC LIMIT 5;	car	2
SELECT Model FROM cars WHERE Year = 2020 AND Fuel_Tank_Capacity > 50 AND Fuel_Efficiency_City < 10 ORDER BY Production_Volume DESC	car	3
SELECT (1000 / 0.1) AS Fuel_Consumption, (1000 / 0.1) * 2.31 AS CO2_Emissions	car	4
SELECT Model, ((Fuel_Efficiency_City * 0.9 - Fuel_Efficiency_City) / Fuel_Efficiency_City) * 100 AS City_Efficiency_Change_Percent, ((Fuel_Efficiency_Highway * 0.9 - Fuel_Efficiency_Highway) / Fuel_Efficiency_Highway) * 100 AS Highway_Efficiency_Change_Percent FROM cars;	car	1
SELECT Model FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer') AND Production_Volume > (SELECT AVG(Production_Volume) FROM cars WHERE Manufacturer_ID = (SELECT Manufacturer_ID FROM manufacturers WHERE Name = 'A certain manufacturer'));	car	2
SELECT m.Name, c.Model FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity < (e.Fuel_Consumption_City * 10);	car	3
SELECT c.Model, (p.Braking_Distance * POWER(1000, 2) / POWER(p.Top_Speed, 2)) AS Hypothetical_Braking_Distance FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID;	car	4
SELECT 0.5 * Weight * POWER((100 * 1000 / 3600), 2) AS Kinetic_Energy FROM cars WHERE Car_ID = 1;	car	1
SELECT Model, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2) AS Avg_Fuel_Efficiency FROM cars WHERE Manufacturer_ID = 1 GROUP BY Model ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;	car	2
SELECT Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Car_ID = 1;	car	3
SELECT Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs WHERE Car_ID = 1;	car	4
SELECT Model, 0.5 * Weight * POWER((Top_Speed * 1000 / 3600), 2) AS Kinetic_Energy FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID ORDER BY Kinetic_Energy DESC LIMIT 1;	car	1
SELECT manufacturers.Name, AVG((Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2) AS Avg_Fuel_Efficiency FROM cars JOIN manufacturers ON cars.Manufacturer_ID = manufacturers.Manufacturer_ID GROUP BY manufacturers.Name ORDER BY Avg_Fuel_Efficiency DESC LIMIT 1;	car	2
SELECT c.Model, c.Fuel_Tank_Capacity / e.Fuel_Consumption_City * 100 AS City_Range, c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway * 100 AS Highway_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID ORDER BY City_Range DESC, Highway_Range DESC LIMIT 1;	car	3
SELECT cars.Model, Max_RPM * 60 * 0.1 AS Fuel_Consumption FROM engine_specs JOIN cars ON engine_specs.Car_ID = cars.Car_ID ORDER BY Fuel_Consumption DESC LIMIT 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE Weight = 1500;	car	1
SELECT Fuel_Efficiency_City, Fuel_Tank_Capacity FROM cars WHERE Fuel_Efficiency_City = 10 AND Fuel_Tank_Capacity = 50;	car	2
SELECT Cargo_Capacity FROM cars WHERE Cargo_Capacity = 500;	car	3
SELECT Max_RPM, Horsepower FROM engine_specs WHERE Max_RPM = 10000;	car	4
SELECT Weight, Acceleration_0_to_100 FROM performance_metrics JOIN cars ON performance_metrics.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE cars.Car_ID = 1;	car	2
SELECT (dimensions.Cargo_Capacity + dimensions.Trunk_Capacity) / 50 AS Max_Cargo_Items FROM dimensions JOIN cars ON dimensions.Car_ID = cars.Car_ID WHERE cars.Car_ID = 1;	car	3
SELECT `Range` * (1000 / `Battery_Capacity`) AS New_Range FROM cars WHERE Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue FROM manufacturers WHERE Manufacturer_ID = 1;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT cars.Car_ID, (cars.Battery_Capacity * 1000) / (500 * performance_metrics.Top_Speed) AS Max_Speed_Range_Time FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT Annual_Sales, Profit_Margin, Average_Price FROM manufacturers WHERE Name = 'Tesla';	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT c.Battery_Capacity, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;	car	4
SELECT (100 * 1000 / 3600) / 8 AS average_acceleration FROM cars WHERE Weight = 1500;	car	1
SELECT (Fuel_Tank_Capacity * Fuel_Efficiency_City * 0.5) + (Fuel_Tank_Capacity * Fuel_Efficiency_Highway * 0.5) AS total_range FROM cars WHERE Car_ID = 1;	car	2
SELECT Maintenance_Cost * 5 AS total_maintenance_cost, Base_Price * POWER(1 - Depreciation_Rate, 5) AS depreciated_value FROM prices WHERE Car_ID = 1;	car	3
SELECT (100000 / Battery_Capacity) * `Range` AS extended_range FROM cars WHERE Car_ID = 1;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Car_ID = 1;	car	1
SELECT SUM(Annual_Sales * Average_Price) AS Total_Revenue, SUM(Annual_Sales) AS Total_Sales, SUM(Annual_Sales * Average_Price) / SUM(Annual_Sales) AS Average_Price_Per_Car FROM manufacturers WHERE Manufacturer_ID = 1;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Car_ID = 1;	car	3
SELECT Max_RPM, Cylinder_Count FROM engine_specs WHERE Car_ID = 1;	car	4
SELECT (0.5 * Weight * POWER(27.78, 2)) / Acceleration_0_to_100 AS Average_Power FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;	car	1
SELECT cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_City / 100) AS City_Distance, cars.Fuel_Tank_Capacity / (engine_specs.Fuel_Consumption_Highway / 100) AS Highway_Distance FROM cars JOIN engine_specs ON cars.Car_ID = engine_specs.Car_ID WHERE cars.Car_ID = 1;	car	2
SELECT Cargo_Capacity * 1 AS Max_Cargo_Weight FROM dimensions WHERE Cargo_Capacity = 500 AND Trunk_Capacity = 300;	car	3
SELECT Max_RPM / 2 * Cylinder_Count AS Combustion_Per_Minute FROM engine_specs WHERE Displacement = 2.0 AND Max_RPM = 8000 AND Cylinder_Count = 4 AND Compression_Ratio = 10;	car	4
SELECT c.Weight, pm.Braking_Distance, sf.Brake_Assist_Response_Time, es.Torque FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID JOIN safety_features sf ON c.Car_ID = sf.Car_ID JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Car_ID = 1;	car	1
SELECT c.Fuel_Tank_Capacity, c.Battery_Capacity, pm.Range_Hybrid, pm.Range_Electric FROM cars c JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Car_ID = 1;	car	2
SELECT c.Seating_Capacity, d.Trunk_Capacity, d.Cargo_Capacity FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID WHERE c.Car_ID = 1;	car	3
SELECT es.Max_RPM, es.Cylinder_Count, c.Fuel_Tank_Capacity, es.Fuel_Consumption_Highway FROM engine_specs es JOIN cars c ON es.Car_ID=c.Car_ID JOIN performance_metrics pm ON c.Car_ID=pm.Car_ID WHERE c.Car_ID=123;	car	4
SELECT e.Horsepower, p.Top_Speed, d.Length, d.Width, d.Curb_Weight FROM engine_specs e JOIN performance_metrics p ON e.Car_ID = p.Car_ID JOIN dimensions d ON e.Car_ID = d.Car_ID WHERE e.Car_ID = 123;	car	1
SELECT c.Model, c.Production_Volume, p.Total_Price, m.Profit_Margin FROM cars c JOIN prices p ON c.Car_ID = p.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Manufacturer_ID = 123 ORDER BY c.Production_Volume DESC LIMIT 5;	car	2
SELECT c.Fuel_Tank_Capacity, c.Fuel_Efficiency_Highway FROM cars c WHERE c.Car_ID = 123;	car	3
SELECT s.Airbag_Count, d.Curb_Weight, p.Braking_Distance FROM safety_features s JOIN dimensions d ON s.Car_ID = d.Car_ID JOIN performance_metrics p ON s.Car_ID = p.Car_ID WHERE s.Car_ID = 123;	car	4
SELECT Weight, Acceleration_0_to_100 FROM cars JOIN performance_metrics ON cars.Car_ID = performance_metrics.Car_ID WHERE cars.Weight = 1500 AND performance_metrics.Acceleration_0_to_100 = 8;	car	1
SELECT Production_Volume_Total, Annual_Sales, `R&D_Spending`, Profit_Margin FROM manufacturers WHERE Production_Volume_Total = 500000 AND Annual_Sales = 450000 AND `R&D_Spending` = 200000000 AND Profit_Margin = 8;	car	2
SELECT Fuel_Tank_Capacity, Fuel_Efficiency_City, Fuel_Efficiency_Highway FROM cars WHERE Fuel_Tank_Capacity = 60 AND Fuel_Efficiency_City = 10 AND Fuel_Efficiency_Highway = 15;	car	3
SELECT Max_RPM, Torque FROM engine_specs WHERE Max_RPM = 10000 AND Torque = 500;	car	4
SELECT ROUND(0.5 * d.Curb_Weight * POWER(p.Top_Speed/3.6, 2)) AS KineticEnergy_J FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID WHERE p.Top_Speed = 240 AND d.Curb_Weight = 1800;	car	1
SELECT (m.Production_Volume_Total * m.Average_Price * 0.85 * m.Profit_Margin/100) AS NetProfit FROM manufacturers m WHERE m.Name = '某制造商' AND m.Production_Volume_Total = 100000 AND m.Average_Price = 35000;	car	2
SELECT s.ABS_Effectiveness, p.Braking_Distance, ROUND((p.Braking_Distance/(s.ABS_Effectiveness/100) * 1.3) - p.Braking_Distance, 1) AS RainIncrease_m FROM safety_features s JOIN performance_metrics p USING(Car_ID) WHERE s.ABS_Effectiveness = 95 AND p.Braking_Distance = 40;	car	3
SELECT e.Displacement, e.Cylinder_Count, (e.Displacement * e.Max_RPM * e.Cylinder_Count * 1.2 * 60)/1000 AS TheoreticalFuel_L_h FROM engine_specs e WHERE e.Displacement = 100 AND e.Cylinder_Count = 16 AND e.Max_RPM = 6000;	car	4
SELECT  (0.5 * 1.225 * pm.Drag_Coefficient * 2.3 * POWER((pm.Top_Speed*1000/3600),3)) AS Air_Power FROM performance_metrics pm JOIN dimensions d ON pm.Car_ID = d.Car_ID WHERE pm.Top_Speed = 210 AND d.Curb_Weight = 1500 AND pm.Drag_Coefficient = 0.28 LIMIT 1;	car	1
SELECT   ( (1800*9.8*0.015 + 0.5*1.225*0.3*2.5*POWER(120/3.6,2)) * 100000 ) * 500 AS Total_Energy FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = '某制造商' GROUP BY m.Name LIMIT 1;	car	2
SELECT  (c.Fuel_Tank_Capacity*0.15 / es.Fuel_Consumption_Highway)*100 AS Remaining_Range FROM cars c JOIN engine_specs es ON c.Car_ID = es.Car_ID WHERE c.Fuel_Tank_Capacity = 60 AND es.Fuel_Consumption_Highway = 6.5 AND c.Battery_Capacity IS NULL LIMIT 1;	car	3
SELECT  (99999/(15/100))/40075 AS Theoretical_Laps FROM cars c JOIN dimensions d ON c.Car_ID = d.Car_ID JOIN performance_metrics pm ON c.Car_ID = pm.Car_ID WHERE c.Battery_Capacity IS NOT NULL AND d.Curb_Weight = 2000 AND pm.Drag_Coefficient = 0.21 LIMIT 1;	car	4
SELECT d.Curb_Weight, p.Top_Speed, 0.5 * d.Curb_Weight * POWER((p.Top_Speed/3.6),2) AS Kinetic_Energy_J FROM dimensions d JOIN performance_metrics p ON d.Car_ID = p.Car_ID JOIN engine_specs e ON d.Car_ID = e.Car_ID WHERE e.Displacement > 0 AND e.Fuel_Consumption_Highway > 0;	car	1
SELECT pr.Base_Price, pr.Maintenance_Cost, pr.Depreciation_Rate, pr.Insurance_Cost, pr.Tax_Rate, (pr.Total_Price*(1+pr.Tax_Rate/100)) + (pr.Maintenance_Cost*5) + (pr.Base_Price*(1-POWER(1-pr.Depreciation_Rate/100,5))) - pr.Insurance_Cost AS Total_5yr_Cost FROM prices pr JOIN cars c ON pr.Car_ID = c.Car_ID WHERE c.Range IS NOT NULL;	car	2
SELECT c.Model, c.Fuel_Tank_Capacity, e.Fuel_Consumption_City, (c.Fuel_Tank_Capacity * (100 / e.Fuel_Consumption_City)) AS City_Range FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Fuel_Tank_Capacity > 0 AND e.Fuel_Consumption_City > 0;	car	3
SELECT c.Model, e.Displacement, c.Fuel_Tank_Capacity, e.Fuel_Consumption_Highway, (c.Fuel_Tank_Capacity / e.Fuel_Consumption_Highway) * 100000 AS Absurd_Range_m FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE e.Displacement >= 20 AND c.Fuel_Tank_Capacity <= 2 AND e.Fuel_Consumption_Highway >= 50;	car	4
SELECT (e.Torque * (s.ESC_Effectiveness / 100)) / (d.Curb_Weight * 0.3) AS Acceleration FROM engine_specs e JOIN dimensions d ON e.Car_ID = d.Car_ID JOIN safety_features s ON e.Car_ID = s.Car_ID WHERE e.Torque = 450 AND d.Curb_Weight = 1500 AND s.ESC_Effectiveness = 95	car	1
SELECT (8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1))) AS Combined_Fuel, 60 / ((8*(0.6 + (4.5/5)*0.1) + 6*(1 - (0.6 + (4.5/5)*0.1)))/100) AS `Range`;	car	2
SELECT (SUM(Airbag_Count * Crash_Test_Rating) - (SUM(Airbag_Count) * SUM(Crash_Test_Rating)) / COUNT(*)) / (COUNT(*) * (SUM(Airbag_Count * Airbag_Count) - POW(SUM(Airbag_Count),2)/COUNT(*))) AS Correlation FROM safety_features	car	3
SELECT e.Horsepower / d.Curb_Weight AS Power_Ratio, (100/3.6) / ((e.Horsepower / d.Curb_Weight) * 745.7 / (100/3.6)) AS Acceleration_Time FROM engine_specs e JOIN dimensions d USING(Car_ID) WHERE e.Horsepower = 100000 AND d.Curb_Weight = 1	car	4
SELECT    p.Top_Speed,   d.Width,   d.Height,   0.5 * 1.225 * p.Drag_Coefficient * (d.Width * d.Height) * POWER(p.Top_Speed/3.6, 2) AS Air_Resistance_Newtons FROM performance_metrics p JOIN dimensions d ON p.Car_ID = d.Car_ID JOIN cars c ON p.Car_ID = c.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' AND c.Model = 'Tesla Model S'	car	1
SELECT    SUM(e.CO2_Emissions * m.Annual_Sales * 15000 / 1000000) AS Total_CO2_Tonnes FROM manufacturers m JOIN cars c ON m.Manufacturer_ID = c.Manufacturer_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE m.Name = 'Tesla'	car	2
SELECT    d.Curb_Weight,   d.Cargo_Capacity,   (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) AS Total_Weight,   CASE WHEN (d.Curb_Weight + 350 + (d.Cargo_Capacity * 0.7)) <= 2500 THEN '安全' ELSE 'overweight' END AS Safety_Status FROM dimensions d JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S'	car	3
SELECT    p.Power_to_Weight_Ratio,   c.Weight,   (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) AS G_Force,   CASE WHEN (p.Power_to_Weight_Ratio * 10 * 745.7) / (9.8 * c.Weight) > 3 THEN '超过' ELSE '未超过' END AS Comparison FROM performance_metrics p JOIN cars c USING(Car_ID) WHERE c.Model = 'Tesla Model S'	car	4
SELECT c.Model, e.Horsepower, (0.5 * 1.225 * POWER(p.Top_Speed / 3.6, 2) * 0.3 * 2.5) AS Air_Resistance FROM cars c JOIN performance_metrics p ON c.Car_ID = p.Car_ID JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = 'Tesla Model S';	car	1
SELECT c.Model, (c.Fuel_Efficiency_City + c.Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars c JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' ORDER BY Avg_Fuel_Efficiency DESC LIMIT 3;	car	2
SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 1.2 AS City_Cost_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 1.2 AS Highway_Cost_Per_KM FROM cars c WHERE c.Model = '某款汽车';	car	3
SELECT c.Model, 1000 / 0.2 AS Theoretical_Range FROM cars c WHERE c.Model = '某款汽车';	car	4
SELECT c.Model, e.Torque, (0.015 * c.Weight * 9.81) AS Rolling_Resistance FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID WHERE c.Model = '某款汽车';	car	1
SELECT c.Model, AVG(e.CO2_Emissions) AS Avg_CO2_Emissions FROM cars c JOIN engine_specs e ON c.Car_ID = e.Car_ID JOIN manufacturers m ON c.Manufacturer_ID = m.Manufacturer_ID WHERE m.Name = 'Tesla' GROUP BY c.Model ORDER BY Avg_CO2_Emissions ASC LIMIT 3;	car	2
SELECT c.Model, (1 / c.Fuel_Efficiency_City) * 2.31 AS City_CO2_Per_KM, (1 / c.Fuel_Efficiency_Highway) * 2.31 AS Highway_CO2_Per_KM FROM cars c WHERE c.Model = '某款汽车';	car	3
SELECT c.Model, 5000 / 0.1 AS Theoretical_Range FROM cars c WHERE c.Model = '某款汽车';	car	4
SELECT Car_ID, Model, (100 / Fuel_Efficiency_City) + (100 / Fuel_Efficiency_Highway) AS Total_Fuel_Consumption FROM cars;	car	1
SELECT d.Car_ID, c.Model, d.Gross_Weight / d.Curb_Weight AS Weight_Ratio FROM dimensions d JOIN cars c ON d.Car_ID = c.Car_ID ORDER BY Weight_Ratio DESC LIMIT 5;	car	2
SELECT Car_ID, Model, (Fuel_Efficiency_City + Fuel_Efficiency_Highway) / 2 AS Avg_Fuel_Efficiency FROM cars WHERE Year = 2020 ORDER BY Avg_Fuel_Efficiency DESC LIMIT 10;	car	3
SELECT Car_ID, Model, 10000 / 1 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 1;	car	4
SELECT p.Car_ID, c.Model, p.Power_to_Weight_Ratio FROM performance_metrics p JOIN cars c ON p.Car_ID = c.Car_ID ORDER BY p.Power_to_Weight_Ratio DESC LIMIT 5;	car	1
SELECT e.Car_ID, c.Model, (e.Fuel_Consumption_City * 100 / 100) * e.CO2_Emissions + (e.Fuel_Consumption_Highway * 100 / 100) * e.CO2_Emissions AS Total_CO2_Emissions FROM engine_specs e JOIN cars c ON e.Car_ID = c.Car_ID;	car	2
SELECT s.Car_ID, c.Model, s.Airbag_Count FROM safety_features s JOIN cars c ON s.Car_ID = c.Car_ID WHERE c.Year = 2020 ORDER BY s.Airbag_Count DESC LIMIT 10;	car	3
SELECT Car_ID, Model, 10000 / 0.5 AS Required_Fuel FROM cars WHERE Fuel_Tank_Capacity = 1000 AND Fuel_Efficiency_City = 0.5;	car	4
SELECT deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = solar ORDER BY deviceName ASC;	EnergyManagementDB	1
SELECT deviceId, SUM(energySaved) AS totalEnergySaved FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId ORDER BY totalEnergySaved DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceId, deviceName, lastMaintenanceDate FROM EnergyDevices WHERE status = 'operating' AND lastMaintenanceDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) ORDER BY deviceName ASC;	EnergyManagementDB	3
SELECT deviceId, deviceName, (powerRating * 24 * 365) AS totalEnergySaved FROM EnergyDevices ORDER BY totalEnergySaved DESC LIMIT 10;	EnergyManagementDB	4
SELECT SUM(ed.powerRating * ed.efficiency / 100 * ec.energyConsumed) AS totalEnergyGenerated FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE m.manufacturerName = '制造商A' AND ed.deviceType = 'solar';	EnergyManagementDB	1
WITH ManufacturerB_Consumption AS (SELECT AVG(ec.energyConsumed) AS avg_energy_consumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'B' AND ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)), ManufacturerC_Consumption AS (SELECT AVG(ec.energyConsumed) AS avg_energy_consumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'C' AND ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)) SELECT (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) AS avg_energy_consumed_B, (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS avg_energy_consumed_C, (SELECT avg_energy_consumed FROM ManufacturerB_Consumption) - (SELECT avg_energy_consumed FROM ManufacturerC_Consumption) AS energy_consumption_difference;	EnergyManagementDB	2
SELECT winter.avg_winter_consumption AS Winter_Avg_Consumption, summer.avg_summer_consumption AS Summer_Avg_Consumption, (winter.avg_winter_consumption - summer.avg_summer_consumption) AS Consumption_Difference FROM (SELECT AVG(ec.energyConsumed) AS avg_winter_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND MONTH(ec.timestamp) IN (12, 1, 2)) AS winter, (SELECT AVG(ec.energyConsumed) AS avg_summer_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'D' AND ed.deviceType = 'fossil fuel' AND MONTH(ec.timestamp) IN (6, 7, 8)) AS summer;	EnergyManagementDB	3
WITH CurrentProfitMargin AS (SELECT (profit / revenue) * 100 AS profitMargin FROM Manufacturers WHERE manufacturerName = '制造商E'), FutureProfit AS (SELECT 1000000 * (profitMargin / 100) AS futureProfit FROM CurrentProfitMargin) SELECT futureProfit FROM FutureProfit;	EnergyManagementDB	4
WITH DeviceConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.powerUsage) AS avgPowerUsage, AVG(ec.voltage) AS avgVoltage, AVG(ec.current) AS avgCurrent FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT dc.deviceId, dc.totalEnergyConsumed, dc.avgPowerUsage, dc.avgVoltage, dc.avgCurrent, (dc.avgPowerUsage / (dc.avgVoltage * dc.avgCurrent)) AS powerFactor FROM DeviceConsumption dc WHERE dc.deviceId = '1';	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	2
SELECT hc.deviceId, ed.deviceName, hc.highHumidityEnergy, hc.lowHumidityEnergy, (hc.highHumidityEnergy - hc.lowHumidityEnergy) / hc.lowHumidityEnergy * 100 AS energyChangeRate FROM (SELECT deviceId, MAX(CASE WHEN humidity = (SELECT MAX(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS highHumidityEnergy, MAX(CASE WHEN humidity = (SELECT MIN(humidity) FROM EnergyConsumption WHERE deviceId = he.deviceId) THEN avgEnergyConsumed END) AS lowHumidityEnergy FROM (SELECT deviceId, humidity, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption GROUP BY deviceId, humidity) AS he GROUP BY deviceId) AS hc JOIN EnergyDevices ed ON hc.deviceId = ed.deviceId;	EnergyManagementDB	3
WITH ExtremePower AS (SELECT deviceId, deviceName, powerRating * 10 AS extremePower, powerRating FROM EnergyDevices WHERE deviceId = 11), ExtremeEnergyConsumption AS (SELECT ep.deviceId, ep.deviceName, ep.extremePower, ep.powerRating, ec.timestamp, ec.energyConsumed, ec.powerUsage, ec.voltage, ec.current, ec.temperature, ec.humidity, ec.dataQuality, ep.extremePower * (ec.timestamp - LAG(ec.timestamp) OVER (PARTITION BY ec.deviceId ORDER BY ec.timestamp)) / 3600 AS extremeEnergyConsumed FROM EnergyConsumption ec JOIN ExtremePower ep ON ec.deviceId = ep.deviceId) SELECT eec.deviceId, eec.deviceName, eec.extremePower, eec.powerRating, eec.timestamp, eec.energyConsumed, eec.powerUsage, eec.voltage, eec.current, eec.temperature, eec.humidity, eec.dataQuality, eec.extremeEnergyConsumed, eec.extremeEnergyConsumed / 100 AS gridImpact FROM ExtremeEnergyConsumption eec;	EnergyManagementDB	4
WITH DeviceCarbonFootprint AS (SELECT ec.deviceId, SUM(ec.energyConsumed * ef.carbonFootprint) AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ef ON ec.deviceId = ef.deviceId AND ec.timestamp = ef.timestamp WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT dcf.deviceId, ed.deviceName, dcf.totalCarbonEmission FROM DeviceCarbonFootprint dcf JOIN EnergyDevices ed ON dcf.deviceId = ed.deviceId ORDER BY dcf.totalCarbonEmission DESC LIMIT 1;	EnergyManagementDB	1
SELECT ae.deviceId, ae.avgEfficiency FROM (SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId) AS ae JOIN (SELECT AVG(efficiency) AS overallAvgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)) AS oa WHERE ae.avgEfficiency < oa.overallAvgEfficiency;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.powerRating, ed.efficiency, ed.installationDate, ed.status, ed.location, ed.manufacturerId, ed.lastMaintenanceDate, ed.nextMaintenanceDate FROM EnergyDevices ed WHERE ed.deviceId NOT IN (SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR))	EnergyManagementDB	3
DROP TEMPORARY TABLE IF EXISTS NormalImpact; DROP TEMPORARY TABLE IF EXISTS ExtremeImpact; CREATE TEMPORARY TABLE NormalImpact AS SELECT deviceId, AVG(carbonFootprint) AS avgCarbonFootprint, AVG(pollutionLevel) AS avgPollutionLevel, AVG(waterUsage) AS avgWaterUsage, AVG(landUsage) AS avgLandUsage FROM EnvironmentalImpact GROUP BY deviceId; CREATE TEMPORARY TABLE ExtremeImpact AS SELECT deviceId, avgCarbonFootprint * 100 AS extremeCarbonFootprint, avgPollutionLevel * 100 AS extremePollutionLevel, avgWaterUsage * 100 AS extremeWaterUsage, avgLandUsage * 100 AS extremeLandUsage FROM NormalImpact; SELECT deviceId, CASE WHEN extremeCarbonFootprint = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'carbonFootprint' WHEN extremePollutionLevel = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'pollutionLevel' WHEN extremeWaterUsage = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'waterUsage' WHEN extremeLandUsage = GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) THEN 'landUsage' END AS maxImpactIndicator, GREATEST(extremeCarbonFootprint, extremePollutionLevel, extremeWaterUsage, extremeLandUsage) AS maxImpactValue FROM ExtremeImpact; DROP TEMPORARY TABLE IF EXISTS NormalImpact; DROP TEMPORARY TABLE IF EXISTS ExtremeImpact;	EnergyManagementDB	4
SELECT deviceId, deviceName, powerRating * efficiency / 100 AS P_actual FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY P_actual DESC LIMIT 5;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ee.energySaved) * 0.5 AS total_cost_savings FROM EnergyEfficiency ee JOIN EnergyDevices ed ON ee.deviceId = ed.deviceId WHERE ee.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceName ORDER BY total_cost_savings DESC LIMIT 10;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency FROM EnergyDevices ed JOIN EnergyPolicies ep ON ed.efficiency < ep.targetEfficiency ORDER BY ed.efficiency ASC LIMIT 10;	EnergyManagementDB	3
SELECT deviceId, deviceName, powerRating * 1.0 AS P_actual FROM EnergyDevices ORDER BY P_actual DESC LIMIT 5;	EnergyManagementDB	4
SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY TotalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed, AVG(ec.energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= NOW() - INTERVAL 1 YEAR GROUP BY ed.deviceType;	EnergyManagementDB	2
WITH MaintenanceCosts AS (SELECT deviceId, SUM(cost) AS totalMaintenanceCost, COUNT(*) AS maintenanceFrequency, GROUP_CONCAT(partsReplaced SEPARATOR ', ') AS partsReplacedList FROM MaintenanceRecords GROUP BY deviceId) SELECT ED.deviceId, ED.deviceName, ED.deviceType, MC.totalMaintenanceCost, MC.maintenanceFrequency, MC.partsReplacedList FROM EnergyDevices ED JOIN MaintenanceCosts MC ON ED.deviceId = MC.deviceId ORDER BY MC.totalMaintenanceCost DESC LIMIT 1;	EnergyManagementDB	3
WITH DeviceEnergy AS (  SELECT     deviceId,    1000000 AS powerRating,    8760 AS hoursInYear,    1000000 * 8760 AS totalEnergyConsumed  FROM     EnergyDevices  WHERE     deviceId = 12345 ), EnvironmentalImpactAnalysis AS (  SELECT     deviceId,    totalEnergyConsumed,    totalEnergyConsumed * 0.85 AS carbonFootprint,    totalEnergyConsumed * 0.001 AS waterUsage,    totalEnergyConsumed * 0.0001 AS landUsage  FROM     DeviceEnergy ) SELECT   DE.deviceId,  DE.powerRating,  DE.totalEnergyConsumed,  EIA.carbonFootprint,  EIA.waterUsage,  EIA.landUsage FROM   DeviceEnergy DE JOIN   EnvironmentalImpactAnalysis EIA ON   DE.deviceId = EIA.deviceId;	EnergyManagementDB	4
SELECT ec.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
WITH DeviceEfficiency AS (SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY deviceId), OverallAverageEfficiency AS (SELECT AVG(avgEfficiency) AS overallAvgEfficiency FROM DeviceEfficiency) SELECT de.deviceId, de.avgEfficiency FROM DeviceEfficiency de, OverallAverageEfficiency oae WHERE de.avgEfficiency < oae.overallAvgEfficiency;	EnergyManagementDB	2
SELECT SUM(ec.energyConsumed) AS TotalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.temperature > 30;	EnergyManagementDB	3
WITH DeviceEnergy AS (SELECT deviceId, 1000000 AS powerRating, 8760 AS hoursInYear FROM EnergyDevices WHERE deviceId = 123) SELECT de.deviceId, de.powerRating * de.hoursInYear AS totalEnergyConsumed, ei.carbonFootprint, ei.pollutionLevel, ei.waterUsage, ei.landUsage FROM DeviceEnergy de JOIN EnvironmentalImpact ei ON de.deviceId = ei.deviceId WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = de.deviceId);	EnergyManagementDB	4
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) / (TIMESTAMPDIFF(HOUR, MIN(ec.timestamp), MAX(ec.timestamp))) AS averagePowerOutput FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY averagePowerOutput DESC LIMIT 1;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ef.forecastValue) AS totalEnergyGenerated, (SUM(ec.energyConsumed) / SUM(ef.forecastValue)) AS energyConsumptionToGenerationRatio FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyForecasts ef ON ed.deviceId = ef.deviceId WHERE ed.deviceType = 'wind' AND ef.forecastType = '5000000.00' GROUP BY ed.deviceId, ed.deviceName ORDER BY energyConsumptionToGenerationRatio ASC;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.efficiency, ep.targetEfficiency FROM EnergyDevices ed JOIN EnergyPolicies ep ON ed.installationDate >= '2022-01-01' AND ed.installationDate <= '2022-12-31' WHERE ed.efficiency < ep.targetEfficiency ORDER BY ed.efficiency DESC;	EnergyManagementDB	3
WITH DeviceEfficiency AS (SELECT deviceId, 100 AS efficiency FROM EnergyDevices), TotalEnergy AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed / (de.efficiency / 100.0)) AS totalEnergyGenerated FROM EnergyConsumption ec JOIN DeviceEfficiency de ON ec.deviceId = de.deviceId GROUP BY ec.deviceId) SELECT te.deviceId, (te.totalEnergyConsumed / te.totalEnergyGenerated) AS energyRatio FROM TotalEnergy te ORDER BY energyRatio ASC;	EnergyManagementDB	4
WITH SolarDeviceEfficiency AS (SELECT deviceId, efficiency FROM EnergyDevices WHERE deviceType = 'solar') SELECT AVG(efficiency) AS average_efficiency, (SELECT deviceId FROM SolarDeviceEfficiency ORDER BY efficiency DESC LIMIT 1) AS most_efficient_device FROM SolarDeviceEfficiency;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ed.powerRating * ed.efficiency * ec.energyConsumed) AS totalEnergySaved FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergySaved DESC;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.powerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE YEAR(ed.installationDate) = 2022 GROUP BY ed.deviceId, ed.deviceName, ed.powerRating;	EnergyManagementDB	3
WITH DeviceEnergySavings AS (SELECT ed.deviceId, ed.deviceName, ed.powerRating * (100 - ed.efficiency) / 100 * 365 * 24 AS energySaved FROM EnergyDevices ed) SELECT des.deviceId, des.deviceName, des.energySaved FROM DeviceEnergySavings des ORDER BY des.energySaved DESC LIMIT 1;	EnergyManagementDB	4
SELECT deviceId, deviceName, powerRating * efficiency / 100 AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceId ASC;	EnergyManagementDB	1
SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption WHERE timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY deviceId ORDER BY totalEnergyConsumed DESC LIMIT 5	EnergyManagementDB	2
SELECT deviceId, COUNT(maintenanceId) AS maintenanceCount FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenanceCount DESC;	EnergyManagementDB	3
SELECT deviceId, SUM(energySaved * (100 / efficiency)) AS totalEnergySaved FROM EnergyEfficiency WHERE efficiency < 100 GROUP BY deviceId ORDER BY totalEnergySaved DESC;	EnergyManagementDB	4
SELECT (1000 * 2 * 0.20 * 24) / 1000 AS daily_energy_output_kWh;	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(12, 3) * 0.4 / 1000 AS output_power_kw;	EnergyManagementDB	2
SELECT deviceId, deviceName, powerRating * 8 * 30 AS totalEnergyConsumed, powerRating * 8 * 30 * 0.5 AS totalCost FROM EnergyDevices;	EnergyManagementDB	3
SELECT 0.5 * 1.225 * PI() * POWER(1000, 2) * POWER(50, 3) * 0.4 / 1000 AS output_power_kw;	EnergyManagementDB	4
WITH ManufacturerDevices AS (SELECT ed.deviceId, ed.efficiency FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), AverageEfficiency AS (SELECT AVG(efficiency) AS avgEfficiency FROM ManufacturerDevices) SELECT md.deviceId, md.efficiency FROM ManufacturerDevices md, AverageEfficiency ae WHERE md.efficiency < ae.avgEfficiency;	EnergyManagementDB	1
WITH ManufacturerDevices AS (SELECT ed.deviceId FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), TotalEnergyConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec WHERE ec.deviceId IN (SELECT deviceId FROM ManufacturerDevices) GROUP BY ec.deviceId) SELECT tec.deviceId, tec.totalEnergyConsumed FROM TotalEnergyConsumption tec ORDER BY tec.totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	2
WITH ManufacturerDevices AS (SELECT ed.deviceId, ed.deviceName, ed.manufacturerId FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech'), AverageMaintenanceCost AS (SELECT AVG(mr.cost) AS avgCost FROM MaintenanceRecords mr JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId) SELECT md.deviceId, md.deviceName, mr.cost FROM MaintenanceRecords mr JOIN ManufacturerDevices md ON mr.deviceId = md.deviceId CROSS JOIN AverageMaintenanceCost amc WHERE mr.cost > amc.avgCost;	EnergyManagementDB	3
WITH IncreasedPower AS (SELECT deviceId, powerRating * 1000 AS increasedPowerRating FROM EnergyDevices WHERE manufacturerId = '1') SELECT ec.deviceId, SUM(ec.energyConsumed * ip.increasedPowerRating) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN IncreasedPower ip ON ec.deviceId = ip.deviceId GROUP BY ec.deviceId ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, SUM(ec.energyConsumed) / (MAX(ec.timestamp) - MIN(ec.timestamp)) AS averagePowerUsage FROM EnergyConsumption ec WHERE ec.deviceId = '特定设备的deviceId' AND ec.timestamp BETWEEN '开始时间' AND '结束时间' GROUP BY ec.deviceId;	EnergyManagementDB	1
SELECT ed.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	2
SELECT CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END AS humidity_level, SUM(energyConsumed) AS total_energy_consumed FROM EnergyConsumption GROUP BY CASE WHEN humidity > 60 THEN 'high humidity' ELSE 'low humidity' END;	EnergyManagementDB	3
WITH TimeDifferences AS ( SELECT deviceId, timestamp, powerUsage, TIMESTAMPDIFF(SECOND, timestamp, LEAD(timestamp) OVER (PARTITION BY deviceId ORDER BY timestamp)) AS timeDiff FROM EnergyConsumption ), ExtremeEnergyConsumption AS ( SELECT deviceId, SUM(powerUsage * 10 * (timeDiff / 3600)) AS extremeEnergyConsumed FROM TimeDifferences WHERE timeDiff IS NOT NULL GROUP BY deviceId ), EnvironmentalImpactAnalysis AS ( SELECT ei.deviceId, SUM(ei.carbonFootprint) AS totalCarbonFootprint FROM EnvironmentalImpact ei JOIN EnergyConsumption ec ON ei.deviceId = ec.deviceId GROUP BY ei.deviceId ) SELECT eec.deviceId, eec.extremeEnergyConsumed, eia.totalCarbonFootprint FROM ExtremeEnergyConsumption eec JOIN EnvironmentalImpactAnalysis eia ON eec.deviceId = eia.deviceId;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, ei.carbonFootprint AS carbonFootprintCoefficient, SUM(ec.energyConsumed) * ei.carbonFootprint AS totalCarbonEmission FROM EnergyConsumption ec JOIN EnvironmentalImpact ei ON ec.deviceId = ei.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' AND ec.deviceId = '特定设备的deviceId' GROUP BY ec.deviceId, ei.carbonFootprint;	EnergyManagementDB	1
WITH DeviceEfficiency AS ( SELECT ed.deviceId, ed.deviceType, AVG(ee.efficiency) AS avgEfficiency FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId WHERE ee.timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY ed.deviceId, ed.deviceType ) SELECT deviceType, AVG(avgEfficiency) AS avgEfficiencyByType FROM DeviceEfficiency GROUP BY deviceType;	EnergyManagementDB	2
SELECT ec.deviceId, AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) AS high_humidity_energy, AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END) AS low_humidity_energy, (AVG(CASE WHEN ec.humidity > 70 THEN ec.energyConsumed END) - AVG(CASE WHEN ec.humidity < 30 THEN ec.energyConsumed END)) AS energy_change FROM EnergyConsumption ec WHERE ec.deviceId = '1' GROUP BY ec.deviceId;	EnergyManagementDB	3
WITH AnnualEnergyConsumption AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec WHERE ec.timestamp >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY ec.deviceId), CarbonFootprintAnalysis AS (SELECT aec.deviceId, aec.totalEnergyConsumed, aec.totalEnergyConsumed * (ei.carbonFootprint * 100) AS totalCarbonEmission, ei.pollutionLevel, ei.waterUsage, ei.landUsage FROM AnnualEnergyConsumption aec JOIN EnvironmentalImpact ei ON aec.deviceId = ei.deviceId WHERE ei.timestamp = (SELECT MAX(timestamp) FROM EnvironmentalImpact WHERE deviceId = aec.deviceId)) SELECT cfa.deviceId, cfa.totalEnergyConsumed, cfa.totalCarbonEmission, cfa.pollutionLevel, cfa.waterUsage, cfa.landUsage, CASE WHEN cfa.totalCarbonEmission > (SELECT AVG(totalCarbonEmission) FROM CarbonFootprintAnalysis) THEN 'High Impact' ELSE 'Normal Impact' END AS environmentalImpact FROM CarbonFootprintAnalysis cfa;	EnergyManagementDB	4
SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-12-31 23:59:59') - (SELECT efficiency FROM EnergyEfficiency WHERE deviceId = ec.deviceId AND timestamp = '2023-01-01 00:00:00') AS efficiencyChange FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId;	EnergyManagementDB	1
SELECT deviceType, SUM(energySaved) AS totalEnergySaved, SUM(costSavings) AS totalCostSavings FROM EnergyEfficiency JOIN EnergyDevices ON EnergyEfficiency.deviceId = EnergyDevices.deviceId WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceType;	EnergyManagementDB	2
SELECT MR.deviceId, COUNT(MR.maintenanceDate) AS maintenanceFrequency, AVG(EE.efficiency) AS averageEfficiency FROM MaintenanceRecords MR JOIN EnergyEfficiency EE ON MR.deviceId = EE.deviceId GROUP BY MR.deviceId ORDER BY maintenanceFrequency, averageEfficiency;	EnergyManagementDB	3
SELECT ed.deviceId, ed.deviceName, ed.deviceType, (ee.energySaved * 10) AS annualEnergySaved, (ee.costSavings * 10) AS annualCostSavings, env.carbonFootprint, env.pollutionLevel FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId JOIN EnvironmentalImpact env ON ed.deviceId = env.deviceId WHERE ed.deviceId = 123;	EnergyManagementDB	4
WITH DeviceEnergy AS (SELECT ec.deviceId, SUM(ec.energyConsumed) AS totalEnergyConsumed, MIN(ee.efficiency) AS efficiency_start, MAX(ee.efficiency) AS efficiency_end FROM EnergyConsumption ec JOIN EnergyEfficiency ee ON ec.deviceId = ee.deviceId WHERE ec.timestamp BETWEEN '2023-01-01' AND '2023-12-31' AND ee.timestamp BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY ec.deviceId) SELECT de.deviceId, de.totalEnergyConsumed, (de.efficiency_end - de.efficiency_start) / de.efficiency_start * 100 AS efficiency_change_percentage FROM DeviceEnergy de;	EnergyManagementDB	1
SELECT ed.deviceType, AVG(mr.cost) AS avgMaintenanceCost FROM MaintenanceRecords mr JOIN EnergyDevices ed ON mr.deviceId = ed.deviceId JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'SolarTech' GROUP BY ed.deviceType;	EnergyManagementDB	2
SELECT humidity_range, AVG(energyConsumed) AS avg_energy_consumed FROM (SELECT CASE WHEN humidity BETWEEN 0 AND 30 THEN '0-30%' WHEN humidity BETWEEN 31 AND 60 THEN '31-60%' WHEN humidity BETWEEN 61 AND 90 THEN '61-90%' ELSE '91-100%' END AS humidity_range, energyConsumed FROM EnergyConsumption WHERE deviceId = '1') AS subquery GROUP BY humidity_range ORDER BY humidity_range;	EnergyManagementDB	3
WITH DevicePower AS (SELECT 1000000 AS powerRating), TotalEnergyConsumed AS (SELECT powerRating * 24 * 365 AS totalEnergyConsumed FROM DevicePower), EnvironmentalImpact AS (SELECT totalEnergyConsumed * (SELECT AVG(carbonFootprint) FROM EnvironmentalImpact WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE powerRating = 1000000)) AS carbonFootprint FROM TotalEnergyConsumed) SELECT totalEnergyConsumed, carbonFootprint FROM TotalEnergyConsumed, EnvironmentalImpact;	EnergyManagementDB	4
SELECT (800 * 2 * 0.20 * (TIMESTAMPDIFF(HOUR, '2023-10-01 00:00:00', '2023-10-01 12:00:00'))) / 1000 AS total_energy_output FROM EnergyDevices WHERE deviceType = 'solar';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;	EnergyManagementDB	2
SELECT 0.5 * 100000 AS total_carbon_footprint;	EnergyManagementDB	3
SELECT (2000 * 1000 * 1 * 24) / 1000 AS total_energy_output_kWh;	EnergyManagementDB	4
SELECT SUM((1000 * 2 * 20 * TIMESTAMPDIFF(HOUR, '2023-10-01 00:00:00', '2023-10-31 23:59:59')) / 1000) AS total_energy_generated FROM EnergyConsumption WHERE deviceId = (SELECT deviceId FROM EnergyDevices WHERE deviceName = 'Solar Panel') AND timestamp BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(80 / 2, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output;	EnergyManagementDB	2
SELECT powerRating * 8 * 365 AS totalEnergyConsumption FROM EnergyDevices WHERE deviceId = '1';	EnergyManagementDB	3
SELECT (powerRating * efficiency * 24 * 365 / 100) AS totalEnergyOutput FROM EnergyDevices WHERE deviceId = '6';	EnergyManagementDB	4
SELECT SUM((ed.powerRating * ed.efficiency * 1000 * TIMESTAMPDIFF(HOUR, ec.timestamp, ec_end.timestamp)) / 1000) AS totalEnergyGenerated FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId JOIN EnergyConsumption ec_end ON ec.deviceId = ec_end.deviceId WHERE ed.deviceType = 'solar' AND ec.timestamp >= '2023-01-01 00:00:00' AND ec_end.timestamp <= '2023-01-31 23:59:59' GROUP BY ed.deviceId;	EnergyManagementDB	1
WITH PowerData AS (SELECT deviceId, timestamp, powerUsage FROM EnergyConsumption WHERE deviceId = '指定风力发电机的deviceId' AND timestamp >= '2022-01-01' AND timestamp < '2023-01-01'), EnergyCalculation AS (SELECT deviceId, SUM(powerUsage * 1) AS totalEnergyGenerated FROM PowerData GROUP BY deviceId) SELECT deviceId, totalEnergyGenerated FROM EnergyCalculation;	EnergyManagementDB	2
SELECT ed.deviceId, ed.deviceName, ed.deviceType, ed.nextMaintenanceDate, ec.temperature, CASE WHEN ec.temperature > 30 THEN '需要增加维护频率' ELSE '无需增加维护频率' END AS maintenanceFrequencyRecommendation FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ec.timestamp = (SELECT MAX(timestamp) FROM EnergyConsumption WHERE deviceId = ed.deviceId);	EnergyManagementDB	3
SELECT 10000000 AS power_kw, 10000000 * 24 * 365 AS total_energy_consumption_kwh FROM dual;	EnergyManagementDB	4
SELECT (efficiency * powerRating * 800 * TIMESTAMPDIFF(HOUR, '2023-01-01 00:00:00', '2023-01-01 12:00:00')) / 1000 AS totalEnergyGenerated FROM EnergyDevices WHERE deviceName = 'Solar Panel';	EnergyManagementDB	1
WITH DeviceInfo AS (SELECT deviceId, powerRating, efficiency FROM EnergyDevices WHERE deviceType = 'wind' AND deviceName = 'FutureDeviceA'), EnergyData AS (SELECT deviceId, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption WHERE deviceId = (SELECT deviceId FROM DeviceInfo) AND timestamp >= DATE_SUB(NOW(), INTERVAL 1 YEAR) GROUP BY deviceId) SELECT d.deviceId, d.powerRating * d.efficiency / 100 * 8760 AS estimatedTotalEnergyOutput FROM DeviceInfo d;	EnergyManagementDB	2
SELECT deviceId, deviceName, 12 / 6 AS maintenanceCount, 12 / 6 * 5000 AS estimatedMaintenanceCost FROM EnergyDevices;	EnergyManagementDB	3
SELECT powerRating * 24 * 365 AS maxEnergyOutput FROM EnergyDevices WHERE deviceId = '1';	EnergyManagementDB	4
SELECT deviceName, powerRating * efficiency AS theoreticalMaxOutput FROM EnergyDevices WHERE deviceType = 'solar' ORDER BY deviceName ASC;	EnergyManagementDB	1
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE ed.deviceType = 'wind' AND ec.timestamp BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	2
SELECT status, COUNT(*) AS device_count FROM EnergyDevices WHERE nextMaintenanceDate BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status;	EnergyManagementDB	3
SELECT deviceId, deviceName, (100 - efficiency) * powerRating * 8760 AS energySaved FROM EnergyDevices ORDER BY energySaved DESC LIMIT 10;	EnergyManagementDB	4
WITH GreenTechDevices AS (SELECT ed.deviceId, ed.efficiency FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar') SELECT AVG(efficiency) AS average_efficiency FROM GreenTechDevices; WITH GreenTechDevices AS (SELECT ed.deviceId, ed.efficiency FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'GreenTech' AND ed.deviceType = 'solar') SELECT deviceId, efficiency FROM GreenTechDevices ORDER BY efficiency DESC LIMIT 5;	EnergyManagementDB	1
SELECT SUM(ed.powerRating) AS total_power, ed.deviceId, ed.powerRating FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'EcoPower' AND ed.deviceType = 'wind' GROUP BY ed.deviceId, ed.powerRating ORDER BY ed.powerRating DESC LIMIT 3;	EnergyManagementDB	2
SELECT AVG(mr.cost) AS average_maintenance_cost FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId JOIN MaintenanceRecords mr ON ed.deviceId = mr.deviceId WHERE m.manufacturerName = 'SunEnergy' AND ed.installationDate < '2020-01-01';	EnergyManagementDB	3
WITH IncreasedPower AS (SELECT ed.deviceId, ed.powerRating * 1000 AS increasedPowerRating FROM EnergyDevices ed JOIN Manufacturers m ON ed.manufacturerId = m.manufacturerId WHERE m.manufacturerName = 'FutureEnergy') SELECT deviceId, increasedPowerRating AS powerRating FROM IncreasedPower ORDER BY increasedPowerRating DESC LIMIT 10;	EnergyManagementDB	4
SELECT ed.deviceId, ed.deviceName, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ed.deviceId, ed.deviceName ORDER BY totalEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	1
WITH AverageEfficiency AS (SELECT AVG(efficiency) AS avg_efficiency FROM EnergyEfficiency) SELECT ed.deviceId, ed.deviceName, ed.efficiency FROM EnergyDevices ed JOIN EnergyEfficiency ee ON ed.deviceId = ee.deviceId CROSS JOIN AverageEfficiency WHERE ee.efficiency < AverageEfficiency.avg_efficiency;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE lastMaintenanceDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) OR lastMaintenanceDate IS NULL;	EnergyManagementDB	3
WITH AbnormalPowerUsage AS (SELECT deviceId, timestamp, powerUsage, energyConsumed, temperature, humidity FROM EnergyConsumption WHERE powerUsage >= 10000) SELECT AP.deviceId, AP.timestamp, AP.powerUsage, AP.energyConsumed, AP.temperature, AP.humidity, ED.deviceName, ED.deviceType, ED.powerRating, ED.efficiency, ED.status, ED.location, MR.maintenanceType, MR.maintenanceDescription, MR.nextMaintenanceDate FROM AbnormalPowerUsage AP JOIN EnergyDevices ED ON AP.deviceId = ED.deviceId LEFT JOIN MaintenanceRecords MR ON AP.deviceId = MR.deviceId ORDER BY AP.timestamp DESC;	EnergyManagementDB	4
SELECT SUM((800 * 2 * 20 * TIMESTAMPDIFF(HOUR, '2023-01-01 00:00:00', '2023-01-31 23:59:59')) / 1000) AS total_energy_generated FROM EnergyDevices WHERE deviceType = 'solar';	EnergyManagementDB	1
SELECT 0.5 * 1.225 * PI() * POWER(30, 2) * POWER(10, 3) * 0.40 * 8760 / 1000 AS total_energy_output_kWh;	EnergyManagementDB	2
WITH MaxEnergyConsumption AS (SELECT deviceId, MAX(energyConsumed) AS maxEnergyConsumed FROM EnergyConsumption GROUP BY deviceId) SELECT ec.deviceId, ed.deviceName, mec.maxEnergyConsumed, (mec.maxEnergyConsumed * 0.5) AS hourlyCost FROM EnergyConsumption ec JOIN MaxEnergyConsumption mec ON ec.deviceId = mec.deviceId AND ec.energyConsumed = mec.maxEnergyConsumed JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId ORDER BY mec.maxEnergyConsumed DESC LIMIT 1;	EnergyManagementDB	3
WITH EfficiencyData AS (SELECT 20 AS originalEfficiency, 1000 AS newEfficiency, 100000 AS annualEnergyConsumption, 0.5 AS electricityPrice) SELECT annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency AS energySaved, annualEnergyConsumption * (newEfficiency - originalEfficiency) / originalEfficiency * electricityPrice AS costSavings FROM EfficiencyData;	EnergyManagementDB	4
WITH DeviceEnergy AS (SELECT ec.deviceId, SUM(ec.powerUsage * TIMESTAMPDIFF(SECOND, ec.timestamp, (SELECT MIN(ec2.timestamp) FROM EnergyConsumption ec2 WHERE ec2.deviceId = ec.deviceId AND ec2.timestamp > ec.timestamp))) / 3600 AS totalEnergyConsumption FROM EnergyConsumption ec WHERE ec.timestamp BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY ec.deviceId) SELECT de.deviceId, ed.deviceName, de.totalEnergyConsumption FROM DeviceEnergy de JOIN EnergyDevices ed ON de.deviceId = ed.deviceId ORDER BY de.totalEnergyConsumption DESC LIMIT 1;	EnergyManagementDB	1
WITH DeviceYearlyEfficiency AS ( SELECT deviceId, AVG(efficiency) AS avgEfficiency FROM EnergyEfficiency WHERE timestamp >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY deviceId ), OverallAverageEfficiency AS ( SELECT AVG(avgEfficiency) AS overallAvgEfficiency FROM DeviceYearlyEfficiency ) SELECT ed.deviceId, ed.deviceName, ed.deviceType, dye.avgEfficiency FROM DeviceYearlyEfficiency dye JOIN EnergyDevices ed ON dye.deviceId = ed.deviceId JOIN OverallAverageEfficiency oae ON dye.avgEfficiency < oae.overallAvgEfficiency;	EnergyManagementDB	2
SELECT ed.deviceName, ed.location FROM EnergyDevices ed WHERE ed.deviceId NOT IN (SELECT mr.deviceId FROM MaintenanceRecords mr WHERE mr.maintenanceDate >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR));	EnergyManagementDB	3
WITH DeviceEnergy AS (SELECT deviceId, powerRating * 24 * 365 AS totalEnergyConsumption FROM EnergyDevices WHERE deviceId = '1'), AllDevicesEnergy AS (SELECT SUM(powerRating * 24 * 365) AS totalEnergyConsumptionAll FROM EnergyDevices) SELECT DE.totalEnergyConsumption AS SpecificDeviceEnergy, ADE.totalEnergyConsumptionAll AS AllDevicesEnergy, DE.totalEnergyConsumption - ADE.totalEnergyConsumptionAll AS EnergyDifference FROM DeviceEnergy DE, AllDevicesEnergy ADE;	EnergyManagementDB	4
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Fuel_Type = 'gasoline' AND Stock_Liters = 10000;	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Profits, (Sales * Net_Profit_Margin / 100) * (Debt_Equity_Ratio + 1) AS Assets FROM company WHERE Sales = 500;	gas	2
SELECT (Minimum_Stock_Liters - Stock_Liters) / 1000 AS Days_Until_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	3
SELECT gs.Capacity_Liters * (g.Price_Liter + g.Tax_per_Liter) AS Total_Revenue FROM gas_station gs JOIN gas g ON gs.Station_ID = g.Station_ID WHERE gs.Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	4
SELECT 50000 * 0.85 AS TotalMass;	gas	1
SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales, Sales * (1 + Revenue_Growth_Rate / 100) * Net_Profit_Margin / 100 AS Projected_Profit FROM company WHERE Company = 'BP China';	gas	2
SELECT CASE WHEN (Stock_Liters - Minimum_Stock_Liters) / 2000 <= 0 THEN 'need to immediately refuel' ELSE 'no need to immediately refuel' END AS RefuelNeeded FROM gas WHERE Station_ID = '1';	gas	3
SELECT 100000 * (5 + 1) AS DailyRevenue, 100000 * 2.5 AS TotalCarbonEmission;	gas	4
SELECT Stock_Liters * Sulfur_Content * 0.001 AS Total_Sulfur_Content_Grams FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	1
SELECT Sales * (1 + Revenue_Growth_Rate / 100) AS Projected_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT CASE WHEN Stock_Liters - ((Stock_Liters - Minimum_Stock_Liters) / 3 * 3) < Minimum_Stock_Liters THEN 'need to replenish in advance' ELSE 'no need to replenish in advance' END AS Need_Replenishment FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	3
SELECT Capacity_Liters * 2.31 AS Total_Carbon_Emission_Grams, (Capacity_Liters * 2.31) / 1000 / 4000 AS Equivalent_Car_Emissions FROM gas_station WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Location = 'test location');	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000) AND Stock_Liters = 80000;	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Current_Profits, (Sales * Net_Profit_Margin / 100) / 0.20 AS Required_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Remaining_Days FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Minimum_Stock_Liters = 10000) AND Stock_Liters = 9500;	gas	3
SELECT (Stock_Liters - Minimum_Stock_Liters) / 1 AS Required_Time_Seconds FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;	gas	4
SELECT 5000 * Sulfur_Content * 0.001 AS Sulfur_Total_Grams FROM gas WHERE Fuel_Type = 'diesel';	gas	1
SELECT Sales * POWER(1 + Revenue_Growth_Rate / 100, 5) AS Future_Sales FROM company WHERE Company = 'BP China';	gas	2
SELECT Stock_Liters - Minimum_Stock_Liters AS Max_Sellable_Liters FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 20000 AND gas.Stock_Liters = 5000 AND gas.Minimum_Stock_Liters = 1000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas JOIN gas_station ON gas.Station_ID = gas_station.Station_ID WHERE gas_station.Capacity_Liters = 20000;	gas	4
SELECT Stock_Liters * 35.8 AS Total_Energy_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000 LIMIT 1);	gas	1
SELECT (Debt_Equity_Ratio * (Sales * Net_Profit_Margin / 100)) - (0.5 * (Sales * Net_Profit_Margin / 100)) AS Debt_Repayment FROM company WHERE Sales = 300 AND Net_Profit_Margin = 12 AND Debt_Equity_Ratio = 0.8;	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Days_Remaining FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 20000 LIMIT 1);	gas	3
SELECT (Stock_Liters * Carbon_Emission) AS Single_Station_Emissions, (Stock_Liters * Carbon_Emission * 1000000) AS Global_Emissions FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000 LIMIT 1);	gas	4
SELECT (50000 * 0.45) AS total_mass_kg, (50000 * 0.45 * 50) AS total_energy_MJ, (50000 * 0.45 * 50 * 0.4) AS electrical_energy_MJ FROM gas WHERE Fuel_Type = 'liquefied natural gas' AND Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters >= 50000);	gas	1
SELECT (Assets * (2 / 3)) AS Debt, (Assets * (1 / 3)) AS Equity, (Assets * (2 / 3) - (Assets / 2)) AS Debt_Repayment FROM company WHERE Assets = 800;	gas	2
WITH daily_consumption AS (SELECT 1500 AS daily_sales, 20000 AS replenishment_amount, 3 AS replenishment_interval), inventory_trend AS (SELECT 30000 AS current_stock, 10000 AS minimum_stock, (1500 - (20000 / 3)) AS net_daily_consumption, (30000 - 10000 + (20000 * (FLOOR((30000 - 10000) / (1500 - (20000 / 3))) / 3))) AS inventory_change FROM daily_consumption) SELECT CASE WHEN inventory_change < 0 THEN 'Yes' ELSE 'No' END AS shortage_occurrence, CASE WHEN inventory_change < 0 THEN ABS(inventory_change) / net_daily_consumption ELSE 0 END AS shortage_duration_days FROM inventory_trend;	gas	3
WITH carbon_data AS (SELECT 50000000 AS daily_sales_liters, 2.31 AS carbon_emission_per_liter_kg, 20 AS carbon_absorption_per_tree_kg, 10 AS land_area_per_tree_sqm), total_emission AS (SELECT (daily_sales_liters * carbon_emission_per_liter_kg * 365) AS total_carbon_emission_kg FROM carbon_data), trees_needed AS (SELECT (total_carbon_emission_kg / carbon_absorption_per_tree_kg) AS trees_required FROM total_emission, carbon_data), land_required AS (SELECT (trees_required * land_area_per_tree_sqm / 1000000) AS land_area_sqkm FROM trees_needed, carbon_data) SELECT trees_required, land_area_sqkm FROM trees_needed, land_required;	gas	4
SELECT Capacity_Liters * 0.75 AS Total_Mass_Kg, (Capacity_Liters * 0.75) * 45 AS Total_Energy_MJ FROM gas_station WHERE Station_ID = '1';	gas	1
SELECT (5000 * 5000 * 365 * 0.5) * (1 - 0.3) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';	gas	2
SELECT (2000 * 7) + (5000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';	gas	3
SELECT (1000000 * 2.31 * 10000 * 365) AS Total_Carbon_Emission_Kg, ((1000000 * 2.31 * 10000 * 365) / 10000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';	gas	4
SELECT Stock_Liters * 0.8 AS Total_Mass_Kg, (Stock_Liters * 0.8) * 42 AS Total_Energy_MJ FROM gas WHERE Station_ID = '1';	gas	1
SELECT (8000 * 4000 * 365 * 0.4) * (1 - 0.2) AS Annual_Net_Profit FROM company WHERE Company_ID = '104';	gas	2
SELECT (3000 * 5) + (10000 - Stock_Liters) AS Required_Refill_Liters FROM gas WHERE Station_ID = '1';	gas	3
SELECT (2000000 * 2.5 * 20000 * 365) AS Total_Carbon_Emission_Kg, ((2000000 * 2.5 * 20000 * 365) / 20000000000) * 100 AS Carbon_Emission_Percentage FROM company WHERE Company_ID = '104';	gas	4
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 50000 AND Carbon_Emission = 2.5;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, 50 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 500 AND Net_Profit_Margin = 8;	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Operational_Days FROM gas WHERE Stock_Liters = 15000 AND Minimum_Stock_Liters = 10000;	gas	3
SELECT LEAST(1000000, Stock_Liters) AS Available_Stock FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1000000) AND Stock_Liters = 999999;	gas	4
SELECT Stock_Liters * 0.85 * 45 AS Total_Energy FROM gas WHERE Stock_Liters = 80000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, 100 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 750 AND Net_Profit_Margin = 12 AND Assets = 2000;	gas	2
SELECT CASE WHEN (Stock_Liters - (3000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning FROM gas WHERE Stock_Liters = 25000 AND Minimum_Stock_Liters = 15000;	gas	3
SELECT CASE WHEN 1500001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete, LEAST(1500001, Stock_Liters) AS Max_Sellable FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 1500000) AND Stock_Liters = 1499999;	gas	4
SELECT Stock_Liters * 35 * 0.85 AS Available_Energy FROM gas WHERE Stock_Liters = 120000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 150 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 900 AND Net_Profit_Margin = 15 AND Assets = 3000 AND Debt_Equity_Ratio = 1200;	gas	2
SELECT CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (5000 * 6)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 5000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 40000 AND Minimum_Stock_Liters = 25000;	gas	3
SELECT CASE WHEN 3000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(3000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 5000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 3000000) AND Stock_Liters = 2999999;	gas	4
SELECT Stock_Liters * 38 * 0.9 AS Available_Energy FROM gas WHERE Stock_Liters = 200000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 300 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 1500 AND Net_Profit_Margin = 20 AND Assets = 5000 AND Debt_Equity_Ratio = 2000;	gas	2
SELECT CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (6000 * 7)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 6000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 50000 AND Minimum_Stock_Liters = 30000;	gas	3
SELECT CASE WHEN 5000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(5000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 10000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 5000000) AND Stock_Liters = 4999999;	gas	4
SELECT Stock_Liters * 42 * 0.88 AS Available_Energy FROM gas WHERE Stock_Liters = 300000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, 500 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 2000 AND Net_Profit_Margin = 25 AND Assets = 6000 AND Debt_Equity_Ratio = 2500;	gas	2
SELECT CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (8000 * 10)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 8000 ELSE 0 END AS Days_To_Advance FROM gas WHERE Stock_Liters = 70000 AND Minimum_Stock_Liters = 40000;	gas	3
SELECT CASE WHEN 10000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(10000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 20000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2 FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 10000000) AND Stock_Liters = 9999999;	gas	4
SELECT Stock_Liters * 46 * 0.92 AS Available_Energy, Stock_Liters * 2.8 AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 500000;	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit, (Sales * (Net_Profit_Margin / 100)) / Assets AS ROA, (Sales * (Net_Profit_Margin / 100)) / (Assets - (Assets * Debt_Equity_Ratio / (Debt_Equity_Ratio + 1))) AS ROE, Debt_Equity_Ratio AS Debt_to_Equity_Ratio, 1200 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Sales = 4000 AND Net_Profit_Margin = 28 AND Assets = 10000 AND Debt_Equity_Ratio = 4000;	gas	2
SELECT CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN (Stock_Liters - (15000 * 12)) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 15000 ELSE 0 END AS Days_To_Advance, CASE WHEN (Stock_Liters - (20000 * 12)) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_New_Sales FROM gas WHERE Stock_Liters = 150000 AND Minimum_Stock_Liters = 80000;	gas	3
SELECT CASE WHEN 20000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_1, LEAST(20000001, Stock_Liters) AS Max_Sellable_1, CASE WHEN 50000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_2, 50000000 * 10 AS Order_Total_Amount FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 20000000) AND Stock_Liters = 19999999;	gas	4
SELECT Stock_Liters * 0.83 * 47 AS Total_Energy, Stock_Liters * 50 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 550) AS ROE, 550 / (Assets - 550) AS Debt_to_Equity_Ratio, 1800 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (20000 * 15) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 20000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (25000 * 15) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 30000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, LEAST(30000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 60000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 60000000 * 12 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.85 * 45 AS Total_Energy, Stock_Liters * 40 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 600) AS ROE, 600 / (Assets - 600) AS Debt_to_Equity_Ratio, 2000 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (25000 * 20) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 25000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (30000 * 20) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 50000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, LEAST(50000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 100000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 100000000 * 15 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.86 * 49 AS Total_Energy, Stock_Liters * 60 AS Total_Sulfur_Content FROM gas WHERE Station_ID = '2001';	gas	1
SELECT Sales * Net_Profit_Margin / 100 AS Net_Profit, (Sales * Net_Profit_Margin / 100) / Assets AS ROA, (Sales * Net_Profit_Margin / 100) / (Assets - 900) AS ROE, 900 / (Assets - 900) AS Debt_to_Equity_Ratio, 3500 / (Net_Profit_Margin / 100) AS Required_Sales FROM company WHERE Company_ID = '105';	gas	2
SELECT CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning, CASE WHEN Stock_Liters - (24000 * 21) < Minimum_Stock_Liters THEN (Stock_Liters - Minimum_Stock_Liters) / 24000 ELSE 0 END AS Days_To_Advance, CASE WHEN Stock_Liters - (29000 * 21) < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Trigger_Warning_Increase FROM gas WHERE Station_ID = '2001';	gas	3
SELECT CASE WHEN 80000001 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Transaction, LEAST(80000001, Stock_Liters) AS Max_Sellable_Liters, CASE WHEN 160000000 <= Stock_Liters THEN 'Yes' ELSE 'No' END AS Can_Complete_Large_Transaction, 160000000 * 25 AS Total_Order_Amount FROM gas WHERE Station_ID = '2001';	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_Kg FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 100000 AND Stock_Liters = 80000);	gas	1
SELECT Sales * (Net_Profit_Margin / 100) AS Net_Profit FROM company WHERE Sales = 500 AND Net_Profit_Margin = 15;	gas	2
SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters AND Next_Delivery_Date > DATE_ADD(CURDATE(), INTERVAL 7 DAY));	gas	3
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 1000000000 AND Carbon_Emission = 2.5;	gas	4
SELECT Stock_Liters * 35 AS Total_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 150000 AND Stock_Liters = 120000);	gas	1
SELECT Assets * (Debt_Equity_Ratio / (1 + Debt_Equity_Ratio)) AS Total_Liabilities FROM company WHERE Assets = 1500 AND Debt_Equity_Ratio = 0.6;	gas	2
SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters * 1.1 AND Next_Delivery_Date = DATE_ADD(CURDATE(), INTERVAL 5 DAY));	gas	3
SELECT Stock_Liters * Sulfur_Content AS Total_Sulfur_Content FROM gas WHERE Stock_Liters = 50000000000 AND Sulfur_Content = 50;	gas	4
SELECT Stock_Liters * 40 * 0.85 AS Effective_Energy_MJ FROM gas WHERE Station_ID = (SELECT Station_ID FROM gas_station WHERE Capacity_Liters = 200000 AND Stock_Liters = 180000);	gas	1
SELECT (5 * 500) / Sales * 100 AS Target_Net_Profit_Margin FROM company WHERE Sales = 1200;	gas	2
SELECT Station_ID, Manager_Name FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM gas WHERE Stock_Liters < Minimum_Stock_Liters * 1.1 AND Next_Delivery_Date = DATE_ADD(CURDATE(), INTERVAL 3 DAY));	gas	3
SELECT Stock_Liters * Carbon_Emission AS Total_Carbon_Emission FROM gas WHERE Stock_Liters = 100000000000 AND Carbon_Emission = 5;	gas	4
SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT (c.Sales * 10) / g.Price_Liter * 35 AS Total_Heat FROM company c JOIN station_company sc ON c.Company_ID = sc.Company_ID JOIN gas g ON sc.Station_ID = g.Station_ID WHERE c.Sales = 500 AND c.Net_Profit_Margin = 5;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT Capacity_Liters * Carbon_Emission * 365 AS Annual_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	1
SELECT 500 * (2 / 3) AS New_Debt, 500 * (1 / 3) AS New_Equity FROM company WHERE Assets = 1000 AND Debt_Equity_Ratio = 2;	gas	2
SELECT Capacity_Liters - (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) AS Available_Capacity FROM gas_station WHERE Capacity_Liters = 100000 AND (SELECT Stock_Liters FROM gas WHERE Station_ID = gas_station.Station_ID) = 80000;	gas	3
SELECT 1000000 * Carbon_Emission AS Total_Carbon_Emission FROM gas_station JOIN gas ON gas_station.Station_ID = gas.Station_ID WHERE gas_station.Capacity_Liters = 100000;	gas	4
SELECT Stock_Liters * 0.85 AS Total_Mass_kg, (Stock_Liters * 0.85) * 45.5 AS Total_Heat_MJ FROM gas WHERE Fuel_Type = 'diesel' AND Station_ID = '1';	gas	1
SELECT Sales * 1.08 AS Projected_Sales, (Sales * 1.08) * 0.12 AS Projected_Profits FROM company WHERE Company_ID = '104';	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2000 AS Days_Remaining FROM gas WHERE Station_ID = '1';	gas	3
SELECT 5000000 * 2.31 * 365 AS Annual_Carbon_Emission, 5000000 * 2.31 * 365 * 1000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';	gas	4
SELECT Stock_Liters * 0.75 AS Total_Mass_kg, (Stock_Liters * 0.75) * 42 AS Total_Heat_MJ FROM gas WHERE Station_ID = '1';	gas	1
SELECT Sales * 1.10 AS Projected_Sales, (Sales * 1.10) * 0.15 AS Projected_Profits, ((Sales * 1.10) * 0.15) * 1.5 AS Total_Debt FROM company WHERE Company_ID = '104';	gas	2
SELECT (Stock_Liters - Minimum_Stock_Liters) / 2500 AS Days_Remaining, CASE WHEN Stock_Liters < Minimum_Stock_Liters THEN 'Yes' ELSE 'No' END AS Need_Refill FROM gas WHERE Station_ID = '1';	gas	3
SELECT 10000000 * 2.5 * 365 AS Annual_Carbon_Emission, 10000000 * 2.5 * 365 * 2000000 AS Global_Annual_Carbon_Emission FROM gas WHERE Station_ID = '1';	gas	4
SELECT (950.0 / 1050.0) * 100 AS Efficiency FROM generators WHERE GeneratorID = 1001;	generators	1
SELECT SUM(RatedPower) AS TotalPower FROM generators WHERE ManufacturerID = 2001;	generators	2
SELECT GeneratorID, GeneratorName, CASE WHEN ContinualTime > 1000 AND Status = 1 THEN 'need maintenance' ELSE 'no need maintenance' END AS MaintenanceStatus FROM generators WHERE GeneratorID = 1002;	generators	3
SELECT GeneratorID, GeneratorName, CASE WHEN 10000 > RatedRotationSpeed * 1.2 THEN  'exceeds safe range' ELSE 'within safe range' END AS RotationSafetyStatus FROM generators WHERE GeneratorID = 1003;	generators	4
SELECT RatedPower / (RatedVoltage * 1500) AS PowerFactor FROM generators WHERE GeneratorID = 1001;	generators	1
SELECT c.Customer_ID, c.Name, CASE WHEN l.Power_Source = 'Gasoline' THEN (l.Engine_Power * 745.7 * 3600 / 1000) + (pm.Fuel_Consumption * 34.2 * 1000) WHEN l.Power_Source IN ('Electric', 'Battery') THEN (l.Battery_Capacity * 12 * 3.6 * 60) / NULLIF(l.Run_Time, 0) ELSE 0 END AS Total_Energy_kJh FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN performance_metrics pm ON l.Mower_ID = pm.Mower_ID ORDER BY pm.Energy_Efficiency DESC LIMIT 5;	lawnmower	1
SELECT Customer_ID, Name, Purchase_Power_Index FROM (SELECT c.Customer_ID, c.Name, LOG10(c.Annual_Purchase_Volume / AVG(c.Annual_Purchase_Volume) OVER (PARTITION BY c.State)) AS Purchase_Power_Index FROM customers c) AS sub WHERE Purchase_Power_Index > 1.5 ORDER BY Purchase_Power_Index DESC;	lawnmower	2
SELECT DISTINCT c.Customer_ID, c.Name, c.Annual_Purchase_Volume FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID WHERE c.Annual_Purchase_Volume > 500000 AND l.Power_Source = 'Manual' ORDER BY c.Annual_Purchase_Volume DESC;	lawnmower	3
SELECT m.Name AS Manufacturer_Name, (SUM(s.Quantity) * 100.0 / m.Production_Volume_Total) AS Percentage FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN lawn_mowers l ON s.Mower_ID = l.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID WHERE c.Annual_Purchase_Volume = 999000000 GROUP BY m.Manufacturer_ID, m.Production_Volume_Total ORDER BY Percentage DESC LIMIT 3;	lawnmower	4
SELECT Country, (SUM(Annual_Purchase_Volume) / 100) * 0.001 AS Total_Mass_kg FROM customers GROUP BY Country;	lawnmower	1
WITH StateTotal AS (SELECT State, SUM(Annual_Purchase_Volume) AS State_Total FROM customers GROUP BY State) SELECT c.State, c.Customer_Type, (SUM(c.Annual_Purchase_Volume) / st.State_Total) * 100 AS Percentage FROM customers c JOIN StateTotal st ON c.State = st.State GROUP BY c.State, c.Customer_Type HAVING Percentage > 50;	lawnmower	2
SELECT YEAR(Registration_Date) AS Reg_Year, COUNT(Customer_ID) AS New_Customers FROM customers GROUP BY Reg_Year ORDER BY New_Customers DESC;	lawnmower	3
SELECT Country, AVG(Annual_Purchase_Volume) AS Avg_Purchase FROM customers GROUP BY Country ORDER BY Avg_Purchase DESC;	lawnmower	4
SELECT c.Customer_ID, c.Name FROM customers c WHERE EXISTS (SELECT 1 FROM lawn_mowers lm INNER JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Torque * (c.Annual_Purchase_Volume / lm.Price) > 1000);	lawnmower	1
SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Individual' AND c.Annual_Purchase_Volume > 3 * (SELECT AVG(Annual_Purchase_Volume) FROM customers WHERE Customer_Type = 'Business') AND (SELECT COUNT(*) FROM customers c2 WHERE c2.State = c.State) < 50;	lawnmower	2
SELECT c.Customer_ID, c.Name FROM customers c WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume < (SELECT AVG(Annual_Purchase_Volume) FROM customers c2 WHERE c2.Customer_Type = 'Individual' AND c2.Country = c.Country);	lawnmower	3
SELECT Customer_ID, Name FROM lawnmower.customers WHERE Annual_Purchase_Volume > (SELECT 10 * SUM(Annual_Purchase_Volume) FROM lawnmower.customers) AND Registration_Date < DATE_SUB(CURRENT_DATE, INTERVAL 100 YEAR);	lawnmower	4
SELECT (c.Annual_Purchase_Volume/lm.Price)*lm.Weight*9.8*2 AS Total_Work_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price=2000 AND lm.Weight=50 WHERE c.Customer_Type='Business' AND c.Annual_Purchase_Volume=1000000;	lawnmower	1
WITH SalesCTE AS (SELECT EXTRACT(YEAR FROM Sale_Date) AS yr, SUM(Total_Price) AS vol FROM sales WHERE Customer_ID='2' AND EXTRACT(YEAR FROM Sale_Date) BETWEEN 2020 AND 2022 GROUP BY 1), CAGRData AS (SELECT (MAX(CASE WHEN yr=2022 THEN vol END)/MAX(CASE WHEN yr=2020 THEN vol END))^(1/2.0)-1 AS cagr, MAX(CASE WHEN yr=2022 THEN vol END) AS end_val FROM SalesCTE) SELECT cagr*100||'%' AS CAGR, end_val*POWER(1+cagr,3) AS Projection_2025 FROM CAGRData;	lawnmower	2
SELECT lm.Power_Source, COUNT(*) AS purchase_count FROM sales s JOIN customers c USING(Customer_ID) JOIN lawn_mowers lm USING(Mower_ID) WHERE c.State='AK' GROUP BY 1 ORDER BY 2 DESC LIMIT 1;	lawnmower	3
SELECT 0.5*(c.Annual_Purchase_Volume/lm.Price)*lm.Weight*POWER(11186,2) AS Energy_Joules FROM customers c JOIN lawn_mowers lm ON lm.Price=1 AND lm.Weight=1000000 WHERE c.Annual_Purchase_Volume=1000000000000;	lawnmower	4
SELECT lm.Model, ROUND(lm.Engine_Power / (pm.Blade_Speed * PI()/30), 2) AS Torque FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' ORDER BY Torque DESC LIMIT 3;	lawnmower	1
SELECT c.Customer_ID, c.Name, ROUND((s.Total_Price + s.Shipping_Cost - (s.Total_Price * s.Discount/100) + (s.Total_Price * s.Tax_Rate/100)), 2) AS Total_Cost FROM sales s JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE c.Customer_Type = 'Business' ORDER BY c.Annual_Purchase_Volume ASC LIMIT 5;	lawnmower	2
SELECT mt.Maintenance_Type, ROUND(AVG(mt.Cost), 2) AS Avg_Cost FROM lawnmower.maintenance mt JOIN lawnmower.lawn_mowers m ON mt.Mower_ID = m.Mower_ID WHERE m.Power_Source = 'Manual' GROUP BY mt.Maintenance_Type ORDER BY Avg_Cost ASC;	lawnmower	3
SELECT lm.Model, pm.Cutting_Efficiency * (lm.Run_Time/60) AS Coverage_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 1 AND pm.Cutting_Efficiency * (lm.Run_Time/60) >= 7140 ORDER BY Coverage_Area DESC LIMIT 1;	lawnmower	4
SELECT Battery_Capacity*12*3600 AS Total_Energy_J, (Battery_Capacity*12*3600)/(Run_Time*60) AS Avg_Power_W FROM lawn_mowers WHERE Power_Source IN ('Electric','Battery') AND Battery_Capacity=5 AND Run_Time=60;	lawnmower	1
SELECT (Engine_Power*745.7)/Weight AS Power_Density, (Engine_Power*745.7*3600)/1e6 AS Total_Work_MJ FROM lawn_mowers WHERE Power_Source='Gasoline' AND Engine_Power=5 AND Weight=50;	lawnmower	2
SELECT lm.Wheel_Size, AVG(pm.Slope_Handling) AS Avg_Slope_Handling FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID=pm.Mower_ID WHERE lm.Wheel_Size IN (6,10) GROUP BY lm.Wheel_Size ORDER BY Wheel_Size DESC;	lawnmower	3
SELECT 0.5*(0.5*lm.Blade_Weight*POW(lm.Blade_Length/200,2))*POW(2*PI()*pm.Blade_Speed/60,2) AS Rotational_Energy_J, (0.5*(0.5*lm.Blade_Weight*POW(lm.Blade_Length/200,2))*POW(2*PI()*pm.Blade_Speed/60,2))/4184 AS TNT_Equivalent_g FROM lawnmower.lawn_mowers lm JOIN lawnmower.performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight=2000 AND pm.Blade_Speed=100000;	lawnmower	4
SELECT Power_Source, AVG(Engine_Power * 745.7 * 3600 / 1000000) AS Avg_Energy_Consumption_MJ FROM lawn_mowers WHERE Power_Source = 'Gasoline' GROUP BY Power_Source;	lawnmower	1
SELECT lm.Model, SUM(pm.Cutting_Efficiency * (lm.Run_Time / 60) * pm.Battery_Life) AS Total_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Electric' GROUP BY lm.Model;	lawnmower	2
SELECT lm.Power_Source, MAX(pm.Cutting_Efficiency * (lm.Run_Time / 60)) AS Max_Area FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID GROUP BY lm.Power_Source ORDER BY Max_Area DESC LIMIT 1;	lawnmower	3
SELECT 'Electric' AS Power_Source, (1000 * 10000 / 60 / 1000000) AS Area_km2;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, (lm.Battery_Capacity * 24 * 3600) / (0.5 * 0.5 * lm.Blade_Weight * POWER(lm.Blade_Length/200, 2) * POWER(2 * PI() * pm.Blade_Speed/60, 2) * 60) AS Theoretical_Run_Time_Minutes FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery');	lawnmower	1
SELECT lm.Mower_ID, lm.Model, 2 * 365 * pm.Fuel_Consumption * 3.5 AS Annual_Fuel_Cost FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline';	lawnmower	2
SELECT lm.Mower_ID, lm.Model, lm.Run_Time AS Recorded_Run_Time, (lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) AS Theoretical_Run_Time FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ABS((lm.Battery_Capacity * 24 * 0.8) / (pm.Torque * pm.Blade_Speed / 9549 * 0.001) - lm.Run_Time) / lm.Run_Time > 0.5;	lawnmower	3
SELECT Mower_ID, Model, Weight, Power_Source, Turning_Radius, Blade_Length FROM lawn_mowers WHERE (Power_Source = 'Manual' AND Weight > 1000) OR (Turning_Radius < Blade_Length / 200);	lawnmower	4
SELECT 2.5 * 9.8 * (AVG(Ground_Clearance)/100) AS Work_Joules FROM lawn_mowers;	lawnmower	1
SELECT ROUND((SELECT SUM(Parts_Cost) FROM maintenance WHERE Maintenance_Type='Replacement') / SUM(Parts_Cost) * 100, 2) AS Cost_Percentage FROM maintenance;	lawnmower	2
SELECT CASE WHEN (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Routine') < (SELECT AVG(Cost) FROM maintenance WHERE Maintenance_Type='Repair') THEN 'conforms to common sense' ELSE 'abnormal' END AS Cost_Comparison;	lawnmower	3
SELECT CASE WHEN 1000000*(50000+1000000) > (SELECT MAX(Revenue)*10 FROM manufacturers) THEN '是' ELSE '否' END AS Is_Exceed;	lawnmower	4
SELECT Maintenance_ID, (Labor_Cost + Parts_Cost) / DATEDIFF(Next_Maintenance_Date, Maintenance_Date) AS Daily_Cost FROM maintenance WHERE Next_Maintenance_Date IS NOT NULL ORDER BY Daily_Cost DESC LIMIT 5;	lawnmower	1
SELECT Maintenance_Type, AVG(Parts_Cost / (Labor_Cost + Parts_Cost) * 100) AS Avg_Parts_Percentage FROM maintenance GROUP BY Maintenance_Type ORDER BY Avg_Parts_Percentage DESC;	lawnmower	2
SELECT * FROM maintenance WHERE Maintenance_Type = 'Replacement' ORDER BY (Labor_Cost + Parts_Cost) DESC LIMIT 5;	lawnmower	3
SELECT * FROM maintenance WHERE Cost > 1000000 ORDER BY Cost DESC LIMIT 3;	lawnmower	4
SELECT m.Service_Center, AVG((1 - POWER(0.8, 2)) * 100) AS Avg_Energy_Reduction_Percent FROM maintenance m JOIN performance_metrics pm ON m.Mower_ID = pm.Mower_ID GROUP BY m.Service_Center	lawnmower	1
SELECT Service_Center, Maintenance_Type, SUM(Labor_Cost)/NULLIF(SUM(Parts_Cost),0) AS Labor_Parts_Ratio FROM maintenance GROUP BY Service_Center, Maintenance_Type HAVING SUM(Labor_Cost)/NULLIF(SUM(Parts_Cost),0) > 2	lawnmower	2
SELECT c.Customer_Type, COUNT(*) AS Overpriced_Count FROM maintenance m JOIN lawn_mowers lm ON m.Mower_ID = lm.Mower_ID JOIN sales s ON m.Mower_ID = s.Mower_ID JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE m.Cost > 0.5 * lm.Price GROUP BY c.Customer_Type	lawnmower	3
SELECT Maintenance_Type, 100*(POWER(1.1,100)-1)/0.1 AS Cumulative_Cost FROM maintenance GROUP BY Maintenance_Type	lawnmower	4
SELECT m_new.Maintenance_ID, m_new.Mower_ID, (1.0/6) * lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * PI() / 30), 2) AS new_kinetic, (1.0/6) * lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * PI() / 30), 2) AS old_kinetic, (1.0/6) * (lm_new.Blade_Weight * POWER(lm_new.Blade_Length, 2) * POWER((pm.Blade_Speed * PI() / 30), 2) - lm_prev.Blade_Weight * POWER(lm_prev.Blade_Length, 2) * POWER((pm_prev.Blade_Speed * PI() / 30), 2)) AS energy_diff FROM lawnmower.maintenance m_new JOIN lawnmower.maintenance m_prev ON m_new.Mower_ID = m_prev.Mower_ID AND m_prev.Maintenance_Date = (SELECT MAX(Maintenance_Date) FROM lawnmower.maintenance WHERE Mower_ID = m_new.Mower_ID AND Maintenance_Date < m_new.Maintenance_Date) JOIN lawnmower.lawn_mowers lm_new ON m_new.Mower_ID = lm_new.Mower_ID JOIN lawnmower.lawn_mowers lm_prev ON m_prev.Mower_ID = lm_prev.Mower_ID JOIN lawnmower.performance_metrics pm ON m_new.Mower_ID = pm.Mower_ID JOIN lawnmower.performance_metrics pm_prev ON m_prev.Mower_ID = pm_prev.Mower_ID WHERE m_new.Maintenance_Type = 'Replacement';	lawnmower	1
WITH Stats AS (SELECT AVG((Cost - Parts_Cost)/Cost*100) AS avg_ratio, STDDEV((Cost - Parts_Cost)/Cost*100) AS std_ratio FROM maintenance WHERE Maintenance_Type = 'Repair') SELECT Service_Center, Maintenance_ID, (Cost - Parts_Cost)/Cost*100 AS cost_ratio FROM maintenance CROSS JOIN Stats WHERE Maintenance_Type = 'Repair' AND (Cost - Parts_Cost)/Cost*100 > (avg_ratio + 3 * std_ratio);	lawnmower	2
SELECT Maintenance_ID, Mower_ID, Maintenance_Date, Next_Maintenance_Date FROM maintenance WHERE Maintenance_Type = 'Replacement' AND TIMESTAMPDIFF(MONTH, Maintenance_Date, Next_Maintenance_Date) < 6;	lawnmower	3
SELECT m1.Maintenance_ID, m1.Mower_ID, m1.Labor_Cost FROM maintenance m1 WHERE m1.Labor_Cost > 10 * (SELECT AVG(Cost) * COUNT(*) * 1000 FROM maintenance m2 WHERE m2.Mower_ID = m1.Mower_ID);	lawnmower	4
SELECT (lm.Engine_Power * 5252) / pm.Torque AS Blade_Speed_RPM FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND lm.Engine_Power = 5 AND pm.Torque = 10;	lawnmower	1
SELECT ((m.Revenue * (m.Profit_Margin / 100)) - m.`R&D_Spending`) / m.Employee_Count AS Net_Profit_Per_Employee FROM manufacturers m WHERE m.Revenue = 1000000000 AND m.Profit_Margin = 5 AND m.`R&D_Spending` = 50000000 AND m.Employee_Count = 5000;	lawnmower	2
SELECT CASE WHEN m.Production_Volume_Total > 500000 AND (YEAR(CURDATE()) - m.Founded_Year) = 1 THEN 'unreasonable' ELSE  'reasonable'  END AS Production_Feasibility FROM manufacturers m WHERE m.Production_Volume_Total = 1000000 AND (YEAR(CURDATE()) - m.Founded_Year) = 1;	lawnmower	3
SELECT (m.Revenue * (m.Profit_Margin / 100)) - m.`R&D_Spending` AS New_Net_Profit FROM manufacturers m WHERE m.Revenue = 100000000 AND m.Profit_Margin = 10000 AND m.`R&D_Spending` = 100000000;	lawnmower	4
SELECT Name, (Production_Volume_Total / `R&D_Spending`) AS RD_Efficiency FROM manufacturers WHERE `R&D_Spending` > 0 ORDER BY RD_Efficiency DESC LIMIT 5;	lawnmower	1
SELECT Name, (Revenue / NULLIF(Employee_Count, 0)) AS Per_Capita_Output FROM manufacturers WHERE Employee_Count > 0 ORDER BY Per_Capita_Output DESC LIMIT 5;	lawnmower	2
SELECT Country, AVG(2024 - Founded_Year) AS Avg_Years FROM manufacturers GROUP BY Country ORDER BY Avg_Years DESC LIMIT 3;	lawnmower	3
SELECT Name, `R&D_Spending`, Revenue FROM manufacturers WHERE `R&D_Spending` > Revenue * 100 ORDER BY `R&D_Spending` DESC LIMIT 5;	lawnmower	4
SELECT Country, SUM(`R&D_Spending`) / SUM(Employee_Count) AS R_D_Density FROM manufacturers GROUP BY Country ORDER BY R_D_Density DESC;	lawnmower	1
SELECT ROIRatio, COUNT(Country) AS CountryCount FROM (SELECT Country, SUM(Revenue * Profit_Margin / 100) / SUM(`R&D_Spending`) AS ROIRatio FROM manufacturers GROUP BY Country) AS SubQuery GROUP BY ROIRatio;	lawnmower	2
SELECT Country, AVG(Founded_Year) AS AvgFoundedYear, AVG(Employee_Count) AS AvgEmployeeCount FROM manufacturers GROUP BY Country;	lawnmower	3
SELECT Country, AVG((1 - `R&D_Spending` / Revenue) * 100) AS AvgProfitMargin FROM manufacturers WHERE `R&D_Spending` = Revenue * 1000 GROUP BY Country;	lawnmower	4
SELECT Manufacturer_ID, Name FROM manufacturers WHERE ((Revenue * Profit_Margin / 100) / (2023 - Founded_Year)) / 31536000 BETWEEN 1 AND 10;	lawnmower	1
SELECT Manufacturer_ID, Name FROM manufacturers WHERE (`R&D_Spending` / Revenue * 100) > 5 AND (Revenue / Employee_Count) > 1000000;	lawnmower	2
SELECT Manufacturer_ID, Name FROM manufacturers WHERE Founded_Year <= 1993 AND Profit_Margin < 15;	lawnmower	3
SELECT Manufacturer_ID, Name FROM manufacturers WHERE `R&D_Spending` > Market_Cap * 10;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, (pm.Torque * (2 * PI() * pm.Blade_Speed / 60) / 745.7) AS Engine_Power_HP, pm.Cutting_Efficiency FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND pm.Cutting_Efficiency = 500;	lawnmower	1
SELECT lm.Mower_ID, lm.Model, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) AS Actual_Energy_Wh, (24 * lm.Battery_Capacity * pm.Energy_Efficiency / 100) / (lm.Run_Time / 60) AS Avg_Power_W, ROUND(pm.Battery_Life / ((2 * 60) / lm.Run_Time) / 365, 1) AS Battery_Life_Years FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND lm.Battery_Capacity = 5 AND pm.Energy_Efficiency = 85 AND lm.Run_Time = 60;	lawnmower	2
SELECT lm.Mower_ID, lm.Model, pm.Noise_Level, CASE WHEN pm.Noise_Level BETWEEN 55 AND 65 THEN '符合' ELSE '不符合' END AS Compliance_Status FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND pm.Noise_Level = 95;	lawnmower	3
SELECT lm.Mower_ID, lm.Model, '∞' AS Min_Friction_Coefficient, (lm.Wheel_Size * 0.0254 / 2) * lm.Weight * (9.8 + pm.Acceleration) AS Required_Torque_Nm FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE pm.Slope_Handling = 90 AND lm.Weight = 50 AND lm.Ground_Clearance = 20 AND pm.Acceleration = 10;	lawnmower	4
SELECT pm.Mower_ID, (pm.Torque / (lm.Weight * 0.2)) AS Torque_Acceleration_Ratio FROM performance_metrics pm JOIN lawn_mowers lm ON pm.Mower_ID = lm.Mower_ID ORDER BY Torque_Acceleration_Ratio DESC LIMIT 5;	lawnmower	1
SELECT lm.Mower_ID, (pm.Battery_Life * lm.Run_Time * pm.Energy_Efficiency) / (60 * 100) AS Total_Hours FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') ORDER BY Total_Hours DESC LIMIT 3;	lawnmower	2
SELECT Mower_ID, Noise_Level, Cutting_Efficiency FROM performance_metrics WHERE Noise_Level < 75 AND Cutting_Efficiency > 200 ORDER BY Noise_Level ASC LIMIT 5;	lawnmower	3
SELECT Mower_ID, Acceleration, Deceleration FROM performance_metrics WHERE Acceleration >= 98 AND Deceleration >= 98 ORDER BY Acceleration DESC LIMIT 3;	lawnmower	4
SELECT m.Name AS Manufacturer, MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) AS Max_Velocity, CASE WHEN MAX((2 * 3.1416 * (l.Blade_Length / 100) * p.Blade_Speed) / 60) > 300 THEN 'Yes' ELSE 'No' END AS Safety_Status FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID JOIN manufacturers m ON l.Manufacturer_ID = m.Manufacturer_ID GROUP BY m.Name;	lawnmower	1
SELECT p.Fuel_Consumption, SUM(p.Fuel_Consumption * 8 * 0.74 * 44 * 1000000 * 0.22) AS Total_Energy_J FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE l.Power_Source = 'Gasoline' GROUP BY p.Fuel_Consumption;	lawnmower	2
SELECT l.Power_Source, COUNT(*) AS Machine_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID WHERE p.Noise_Level > 75 AND p.Mulching_Capability = 1 GROUP BY l.Power_Source;	lawnmower	3
SELECT CASE WHEN p.Acceleration <= 500 THEN '0-500 m/s²' WHEN p.Acceleration <= 1000 THEN '501-1000 m/s²' ELSE '>1000 m/s²' END AS Acceleration_Range, CASE WHEN (l.Blade_Weight * p.Acceleration) / (5 * 0.0001) > 880000000 THEN 'Exceeded' ELSE 'Safe' END AS Strength_Status, COUNT(*) AS Case_Count FROM lawn_mowers l JOIN performance_metrics p ON l.Mower_ID = p.Mower_ID GROUP BY Acceleration_Range, Strength_Status;	lawnmower	4
SELECT lm.Mower_ID, lm.Model, 0.5 * lm.Blade_Weight * POW((lm.Blade_Length/100 * PI() * pm.Blade_Speed/60), 2) AS Kinetic_Energy FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND 0.5 * lm.Blade_Weight * POW((lm.Blade_Length/100 * PI() * pm.Blade_Speed/60), 2) > 1000 AND pm.Energy_Efficiency < 80;	lawnmower	1
SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source IN ('Electric', 'Battery') AND ((pm.Battery_Life * lm.Battery_Capacity * lm.Run_Time / 60 * 48 / 1000) * (pm.Energy_Efficiency / 100) > (SELECT MAX(pm_gas.Fuel_Consumption * 10 * 200 * 34.2 * 0.3) FROM performance_metrics pm_gas JOIN lawn_mowers lm_gas ON pm_gas.Mower_ID = lm_gas.Mower_ID WHERE lm_gas.Power_Source = 'Gasoline'));	lawnmower	2
SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE pm.Noise_Level <= 55 AND pm.Vibration_Level < 2.5;	lawnmower	3
SELECT lm.Mower_ID, lm.Model FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Power_Source = 'Battery' AND pm.Battery_Life >= 109500 AND lm.Run_Time >= 1000000 AND lm.Battery_Capacity >= 2500 AND pm.Energy_Efficiency >= 100;	lawnmower	4
SELECT SUM(s.Quantity * lm.Weight) * 9.8 * 1000 AS Total_Work FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID;	lawnmower	1
SELECT ROUND( ( (SELECT SUM(lm.Price * 500 * 0.85) FROM lawn_mowers lm) * 1.085 ) + (50 * 500), 2 ) AS Total_Payment FROM DUAL;	lawnmower	2
SELECT ROUND( (500 * 3 * 0.9 * 1.06), 2 ) AS Actual_Payment FROM DUAL;	lawnmower	3
SELECT ( ( (SELECT lm.Price FROM lawn_mowers lm LIMIT 1) * 1000000 * (1 - 120/100) ) * (1 + 250/100) ) + (0.01 * 1000000) AS Theoretical_Total_Price FROM DUAL;	lawnmower	4
SELECT s.Sale_ID, 0.5 * 0.5 * lm.Blade_Weight * POWER((lm.Blade_Length/200),2) * POWER(2*PI()*pm.Blade_Speed/60,2) * s.Quantity AS Kinetic_Energy FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID ORDER BY Kinetic_Energy DESC LIMIT 5	lawnmower	1
SELECT Customer_ID, SUM( (Sale_Price * Quantity * (1 - Discount/100) * (1 + Tax_Rate/100)) + Shipping_Cost ) AS Total_Payment FROM sales GROUP BY Customer_ID ORDER BY Total_Payment DESC LIMIT 10	lawnmower	2
WITH Manufacturer_Avg AS ( SELECT Manufacturer_ID, AVG(Price) * 0.8 AS Threshold FROM lawn_mowers GROUP BY Manufacturer_ID ) SELECT lm.Model, SUM(s.Quantity) AS Total_Sales, CASE WHEN lm.Price < ma.Threshold THEN '符合' ELSE '不符合' END AS Price_Status FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN Manufacturer_Avg ma ON lm.Manufacturer_ID = ma.Manufacturer_ID GROUP BY lm.Model, lm.Price, ma.Threshold ORDER BY Total_Sales DESC LIMIT 3	lawnmower	3
SELECT s.Sale_ID, s.Shipping_Cost * 10000 AS Scaled_Shipping, m.Market_Cap FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers m ON lm.Manufacturer_ID = m.Manufacturer_ID WHERE s.Shipping_Cost * 10000 > m.Market_Cap ORDER BY Scaled_Shipping DESC LIMIT 5	lawnmower	4
SELECT s.Customer_ID, SUM(s.Quantity * lm.Weight) * 9.8 * 1 AS Work_Joules FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID GROUP BY s.Customer_ID	lawnmower	1
SELECT Payment_Method, (SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) - SUM(sale_price * quantity * 0.6)) / SUM(sale_price * quantity * (1 - discount/100) * (1 + tax_rate/100)) * 100 AS Gross_Profit_Margin FROM sales GROUP BY Payment_Method	lawnmower	2
SELECT Customer_ID, COUNT(Sale_ID) AS Abnormal_Transactions FROM sales WHERE shipping_cost > (sale_price * quantity * 0.1) GROUP BY Customer_ID	lawnmower	3
SELECT Sale_Price * 2147483647 * (1 + Tax_Rate/100) AS Total_Price_Validation FROM sales WHERE Customer_ID IN (SELECT Customer_ID FROM customers WHERE Customer_Type = 'Business') LIMIT 1	lawnmower	4
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID WHERE lm.Power_Source = 'Gasoline' AND (lm.Engine_Power * 745.7) * (lm.Run_Time * 60) >= 1000 AND NOT EXISTS (SELECT 1 FROM performance_metrics pm WHERE pm.Mower_ID = lm.Mower_ID AND pm.Vibration_Level > 5);	lawnmower	1
SELECT c.Customer_ID, (SUM(m.Cost)/SUM(s.Total_Price))*100 AS maintenance_percentage FROM customers c JOIN sales s ON c.Customer_ID = s.Customer_ID JOIN maintenance m ON s.Mower_ID = m.Mower_ID WHERE c.Customer_Type = 'Business' AND c.Annual_Purchase_Volume > 50000 AND m.Maintenance_Date BETWEEN s.Sale_Date AND DATE_ADD(s.Sale_Date, INTERVAL s.Warranty_Period MONTH) GROUP BY c.Customer_ID HAVING maintenance_percentage < 15;	lawnmower	2
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN customers c ON s.Customer_ID = c.Customer_ID WHERE lm.Power_Source = 'Manual' AND lm.Blade_Angle > 35 AND lm.Cutting_Height_Adjustment = 'Mechanical' AND c.City = 'Seattle';	lawnmower	3
SELECT s.* FROM sales s JOIN lawn_mowers lm ON s.Mower_ID = lm.Mower_ID JOIN manufacturers mf ON lm.Manufacturer_ID = mf.Manufacturer_ID WHERE s.Quantity > mf.Production_Volume_Total *5 AND s.Shipping_Cost < lm.Price *0.001;	lawnmower	4
SELECT CEIL( (pm.Torque * pm.Blade_Speed * 3) / ((pm.Energy_Efficiency / 100) * 9549) / (lm.Battery_Capacity * 12) ) AS Batteries_Needed FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Battery_Capacity = 10 AND pm.Energy_Efficiency = 85 AND pm.Blade_Speed = 3000 AND pm.Torque = 15;	lawnmower	1
SELECT m.Manufacturer_ID, m.Name, SUM(s.Total_Price * (m.Profit_Margin / 100)) / SUM(s.Total_Price) AS Avg_Profit_Margin FROM manufacturers m JOIN lawn_mowers lm ON m.Manufacturer_ID = lm.Manufacturer_ID JOIN sales s ON lm.Mower_ID = s.Mower_ID WHERE m.`R&D_Spending`/ m.Revenue > 0.05 AND m.Revenue > 100000000 AND YEAR(s.Sale_Date) = 2023 GROUP BY m.Manufacturer_ID, m.Name;	lawnmower	2
SELECT CASE WHEN (1.5 * 2 * 4 * 13 * 1.2) > 200 THEN 'Yes' ELSE 'No' END AS Exceeds_200;	lawnmower	3
SELECT CASE WHEN (lm.Weight * 9.8) / (4 * PI() * POWER((lm.Wheel_Size * 0.0254 / 2), 2)) > 200000 THEN 'Yes' ELSE 'No' END AS Exceeds_Pressure FROM lawn_mowers lm JOIN performance_metrics pm ON lm.Mower_ID = pm.Mower_ID WHERE lm.Weight = 1000 AND lm.Wheel_Size = 2 AND pm.Slope_Handling >= 30;	lawnmower	4
SELECT m.Model FROM mice m JOIN (SELECT Mouse_ID, SUM(Distance_Moved_Meters) AS total_dist, SUM(Energy_Consumed_Joules) AS total_energy FROM usage_records GROUP BY Mouse_ID) u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND (u.total_dist * m.Weight_Grams)/(u.total_energy/1000) < 5 AND m.Weight_Grams > 100;	mouse	1
WITH CalibrationData AS (SELECT Sensor_Id, Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date FROM sensor_data) SELECT m.Model, ma.Market_Share_Percent FROM CalibrationData cd JOIN sensor_data sd ON cd.Sensor_Id = sd.Sensor_Id JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE DATEDIFF(cd.Last_Calibration_Date, cd.prev_date) < 30 GROUP BY m.Model, ma.Market_Share_Percent HAVING COUNT(*) > 5;	mouse	2
SELECT u.User_ID, m.Weight_Grams FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id WHERE u.Max_Dpi > 16000 AND u.Usage_Duration_Minutes > 120;	mouse	3
SELECT 0.62 * (Weight_Grams/1000) * (24.79 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'G502 HERO';	mouse	4
WITH EfficiencyData AS (SELECT m.Mouse_Id, m.Model, m.Weight_Grams, AVG((u.Distance_Moved_Meters * m.Weight_Grams)/(u.Energy_Consumed_Joules/1000)) AS normal_efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND m.Acceleration_G < 10 GROUP BY m.Mouse_Id, m.Model, m.Weight_Grams), ExtremeEfficiency AS (SELECT m.Mouse_Id, (u.Distance_Moved_Meters * m.Weight_Grams)/(u.Energy_Consumed_Joules/1000) AS extreme_efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND m.Acceleration_G > 50) SELECT e.Model FROM EfficiencyData e JOIN ExtremeEfficiency ex ON e.Mouse_Id = ex.Mouse_Id WHERE (e.normal_efficiency - ex.extreme_efficiency) / e.normal_efficiency * 100 > 30 AND e.Weight_Grams > 100;	mouse	1
WITH ClickFrequency AS (SELECT User_ID, Mouse_ID, Clicks, Usage_Duration_Minutes, Clicks / (Usage_Duration_Minutes / 60) AS click_freq, SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_clicks, SUM(Usage_Duration_Minutes) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_duration FROM usage_records) SELECT DISTINCT cf.User_ID, m.Model FROM ClickFrequency cf JOIN mice m ON cf.Mouse_ID = m.Mouse_Id WHERE cf.click_freq > 600 AND cf.total_duration > 5;	mouse	2
WITH CalibrationIntervals AS (SELECT Sensor_Id, Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date FROM sensor_data) SELECT m.Model, ma.Profit_Usd FROM CalibrationIntervals ci JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE DATEDIFF(ci.Last_Calibration_Date, ci.prev_date) < 7;	mouse	3
SELECT 0.0001 * (Weight_Grams/1000) * (274 + (Acceleration_G * 9.81)) AS Force_Newtons FROM mice WHERE Model = 'DeathAdder V2';	mouse	4
SELECT m.Model FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Tracking_Speed_Ips > 400 AND m.Polling_Rate_Hz > 1000 AND (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules * 100 < 60;	mouse	1
WITH ClickFrequency AS (SELECT User_ID, Mouse_ID, Start_Time, Clicks, SUM(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) / 5 AS window_freq FROM usage_records), ConsecutiveHighFreq AS (SELECT User_ID, Mouse_ID, window_freq, LAG(window_freq, 1) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq1, LAG(window_freq, 2) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_freq2 FROM ClickFrequency WHERE window_freq > 1200) SELECT DISTINCT chf.User_ID, m.Acceleration_G FROM ConsecutiveHighFreq chf JOIN mice m ON chf.Mouse_ID = m.Mouse_Id WHERE chf.window_freq > 1200 AND chf.prev_freq1 > 1200 AND chf.prev_freq2 > 1200;	mouse	2
SELECT m.Model, ma.Founded_year FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE sd.Lift_Off_Distance_Mm < 1.5 AND sd.Max_Dpi > 18000;	mouse	3
SELECT (2.3e-5 * 10 * 600) / SQRT(10 * 5) * 100 AS precision_error FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	4
SELECT m.Model FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE ( (u.Distance_Moved_Meters * m.Weight_Grams * POWER((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Distance_Moved_Meters / 1000) ) / (u.Usage_Duration_Minutes * 60) > 10 AND (u.Distance_Moved_Meters * m.Weight_Grams * POWER((m.Tracking_Speed_Ips * 0.0254), 2)) / (u.Energy_Consumed_Joules * 1000) * 100 < 40;	mouse	1
WITH ClickPatterns AS (SELECT User_ID, Mouse_ID, Clicks, (LOG2(Clicks)) AS log2_clicks FROM usage_records WHERE Clicks > 0 AND MOD(LOG2(Clicks), 1) = 0) SELECT cp.User_ID, m.Polling_Rate_Hz FROM ClickPatterns cp JOIN mice m ON cp.Mouse_ID = m.Mouse_Id;	mouse	2
SELECT u.User_ID, ma.Market_Share_Percent FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE m.Weight_Grams > 150 AND (u.Usage_Duration_Minutes / 60) / 7 > 8;	mouse	3
SELECT (6.626e-34 / (2 * (Weight_Grams/1000) * SQRT(2 * (Weight_Grams/1000) * 1.6e-19))) * (Weight_Grams/1000) * 9.8e12 * 0.001 AS Energy_Joules FROM mice WHERE Is_Wireless = 1;	mouse	4
SELECT m.Model FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Acceleration_G > 80 AND ( (m.Weight_Grams / 1000) * (m.Tracking_Speed_Ips * 0.0254) * m.Polling_Rate_Hz ) > 1;	mouse	1
WITH ClickSequences AS (SELECT User_ID, Mouse_ID, Start_Time, Clicks, LAG(Clicks) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_clicks FROM usage_records), TransitionMatrix AS (SELECT User_ID, Mouse_ID, COUNT(*) AS total_transitions, SUM(CASE WHEN Clicks = prev_clicks THEN 1 ELSE 0 END) AS same_state_count FROM ClickSequences GROUP BY User_ID, Mouse_ID) SELECT tm.User_ID, sd.Sensor_Life_Hours FROM TransitionMatrix tm JOIN sensor_data sd ON tm.Mouse_ID = sd.Mouse_Id WHERE (same_state_count / total_transitions) > 0.5;	mouse	2
WITH CalibrationIntervals AS (SELECT Sensor_Id, Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date) AS prev_date FROM sensor_data) SELECT m.Model, ma.Founded_year FROM CalibrationIntervals ci JOIN sensor_data sd ON ci.Sensor_Id = sd.Sensor_Id JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE DATEDIFF(ci.Last_Calibration_Date, ci.prev_date) < 3;	mouse	3
SELECT (2 * 1e8 * 0.01) AS Photon_Force_N FROM mice WHERE Is_Wireless = 1;	mouse	4
WITH EnergyAnalysis AS (SELECT m.Mouse_Id, m.Model, m.Acceleration_G, m.Weight_Grams, u.Energy_Consumed_Joules, u.Distance_Moved_Meters FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE ABS(u.Max_Dpi - u.Average_Dpi) > 8000) SELECT ea.Model FROM EnergyAnalysis ea WHERE (1 - ( (ea.Distance_Moved_Meters * ea.Weight_Grams * 9.8) / ea.Energy_Consumed_Joules )) * 100 > 25 AND ea.Acceleration_G > 50;	mouse	1
WITH ClickIntervals AS (SELECT User_ID, Mouse_ID, Start_Time, LAG(Start_Time) OVER (PARTITION BY User_ID, Mouse_ID ORDER BY Start_Time) AS prev_time FROM usage_records), RS_Analysis AS (SELECT User_ID, Mouse_ID, LOG(MAX(Start_Time) - MIN(Start_Time)) / LOG(COUNT(*)) AS Hurst_Index FROM ClickIntervals GROUP BY User_ID, Mouse_ID) SELECT rs.User_ID, ma.Market_Share_Percent FROM RS_Analysis rs JOIN mice m ON rs.Mouse_ID = m.Mouse_Id JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE rs.Hurst_Index > 0.8;	mouse	2
SELECT m.Model, ma.Founded_year FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE (u.Usage_Duration_Minutes / 60) / m.Battery_Life_Hours < 0.5 AND m.Is_Wireless = 1;	mouse	3
SELECT ( (20 * LOG10(160 / 1e6) + 50) - 10 * LOG10(1.6e6 / (2 * PI() * 160 * 1e-4)) ) / (4 * PI() * SQRT(PI() * 160 * 1e-4 * 1.6e6)) AS Shield_Thickness_m FROM mice WHERE Sensor_Type = 'Laser';	mouse	4
SELECT 0.5 * 0.133 * POWER((40 * 9.8 * 7200), 2) AS Kinetic_Energy_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
SELECT ma.Manufacturer_Name, AVG(CASE WHEN m.Is_Wireless = 1 THEN m.Price_Usd END) / AVG(CASE WHEN m.Is_Wireless = 0 THEN m.Price_Usd END) AS Wireless_Wired_Ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name ORDER BY Wireless_Wired_Ratio DESC LIMIT 5;	mouse	2
SELECT DISTINCT m.Model, 'High Risk' AS Risk_Level FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Tracking_Speed_Ips > 0.9 * sd.Tracking_Speed_Ips;	mouse	3
SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT m.Weight_Grams / 1000 * (50 * 9.8) * (50 * 9.8 * 150 * 60) AS Power_W FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'DeathAdder V2' AND u.User_ID = 102;	mouse	1
SELECT m.Model, (m.Price_Usd / m.Dpi) AS Usd_Per_Dpi FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id WHERE ma.Revenue_Usd > 1000000000 AND ma.Market_Share_Percent > 10 ORDER BY Usd_Per_Dpi ASC LIMIT 3;	mouse	2
SELECT m.Model, (u.Usage_Duration_Minutes - m.Battery_Life_Hours * 60) / u.Usage_Duration_Minutes AS Shortage_Ratio FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 AND u.Usage_Duration_Minutes > m.Battery_Life_Hours * 60;	mouse	3
SELECT 1000 * m.Dpi * (100 * 365 * 8 * 3600) AS Total_DPI_Data FROM mice m WHERE m.Model = 'Dark Core RGB Pro';	mouse	4
SELECT (m.Weight_Grams / 1000) * (m.Acceleration_G * 9.8) * u.Distance_Moved_Meters AS Mechanical_Work_J FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103;	mouse	1
WITH MarketShare AS (SELECT Country, SUM(Market_Share_Percent) AS Total_Market_Share FROM manufacturers GROUP BY Country ORDER BY Total_Market_Share DESC LIMIT 3), TopManufacturers AS (SELECT ma.Manufacturer_Id, ma.Manufacturer_Name FROM manufacturers ma JOIN MarketShare ms ON ma.Country = ms.Country ORDER BY (ma.Profit_Usd / ma.Employees) DESC LIMIT 1) SELECT m.Model, POWER(m.Dpi, 2)/m.Price_Usd AS Dpi2_Per_Usd FROM mice m JOIN TopManufacturers tm ON m.Manufacturer_Id = tm.Manufacturer_Id;	mouse	2
WITH CalibrationIntervals AS (SELECT Sensor_Id, DATEDIFF(Last_Calibration_Date, LAG(Last_Calibration_Date) OVER (PARTITION BY Sensor_Id ORDER BY Last_Calibration_Date)) AS Calibration_Interval FROM sensor_data), ClickStats AS (SELECT Mouse_ID, AVG(Clicks / DATEDIFF(End_Time, Start_Time)) AS Avg_Clicks_Per_Day, STDDEV(Clicks / DATEDIFF(End_Time, Start_Time)) AS Std_Clicks_Per_Day FROM usage_records GROUP BY Mouse_ID) SELECT m.Model FROM mice m JOIN CalibrationIntervals ci ON m.Mouse_Id = ci.Sensor_Id JOIN ClickStats cs ON m.Mouse_Id = cs.Mouse_ID WHERE ci.Calibration_Interval > 30 AND (cs.Avg_Clicks_Per_Day > (SELECT AVG(Avg_Clicks_Per_Day) + 2 * STDDEV(Avg_Clicks_Per_Day) FROM ClickStats));	mouse	3
SELECT Tracking_Speed_Ips * Polling_Rate_Hz AS Interrupts_Per_Second FROM mice WHERE Model = 'G502 HERO';	mouse	4
SELECT ((m.Weight_Grams / 1000) * m.Acceleration_G * 9.8 * u.Distance_Moved_Meters) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
SELECT Manufacturer_Name, Market_Share_Percent * (Profit_Usd / Employees) AS Composite_Index FROM manufacturers WHERE Market_Share_Percent * (Profit_Usd / Employees) > 100 AND Founded_year < YEAR(CURDATE()) - 20 ORDER BY Composite_Index DESC LIMIT 5;	mouse	2
SELECT m.Model, ROUND(m.Battery_Life_Hours / (AVG(u.Usage_Duration_Minutes) / 60), 2) AS Max_Usage_Days FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Battery_Life_Hours HAVING m.Battery_Life_Hours < AVG(u.Usage_Duration_Minutes) / 60;	mouse	3
SELECT Polling_Rate_Hz * Acceleration_G AS Packets_Per_Second FROM mice WHERE Polling_Rate_Hz = 2000 AND Acceleration_G = 50;	mouse	4
SELECT (u.Distance_Moved_Meters / (sd.Lift_Off_Distance_Mm / 1000)) * 0.5 * POWER(10, -3) AS Total_Energy_Loss_J FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
WITH ManufacturerStats AS (SELECT ma.Manufacturer_Id, STDDEV(m.Price_Usd) / AVG(m.Price_Usd) AS Price_CV, ma.Market_Share_Percent FROM manufacturers ma JOIN mice m ON ma.Manufacturer_Id = m.Manufacturer_Id WHERE YEAR(CURDATE()) - ma.Founded_year > 25 AND m.Is_Wireless = 1 GROUP BY ma.Manufacturer_Id, ma.Market_Share_Percent) SELECT Manufacturer_Id, (SUM(Price_CV * Market_Share_Percent) - SUM(Price_CV) * SUM(Market_Share_Percent) / COUNT(*)) / COUNT(*) AS Covariance FROM ManufacturerStats GROUP BY Manufacturer_Id ORDER BY ABS(Covariance) DESC;	mouse	2
SELECT m.Model, SUM(u.Clicks) / SUM(u.Usage_Duration_Minutes) AS Click_Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 0 AND m.Weight_Grams > 100 AND m.Cable_Length_Meters < 1.5 GROUP BY m.Model;	mouse	3
SELECT (1 / 5.39e-44) * (18000 / 25.4) * 8 / POWER(10, 24) AS Data_Volume_YB FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	4
SELECT (u.Distance_Moved_Meters * m.Weight_Grams * 9.8) / u.Energy_Consumed_Joules AS Efficiency FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Model = 'G502 HERO' AND u.User_ID = 101;	mouse	1
SELECT ma.Manufacturer_Name, AVG(m.Dpi/m.Price_Usd) AS Dpi_Per_Usd FROM manufacturers ma JOIN mice m ON ma.Manufacturer_Id = m.Manufacturer_Id WHERE 2023 - ma.Founded_year > 20 AND (ma.Profit_Usd/ma.Employees) > 200000 GROUP BY ma.Manufacturer_Name;	mouse	2
SELECT m.Model, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS Daily_Clicks, CASE WHEN SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) > 8000 AND m.Weight_Grams > 120 THEN '高危' ELSE '正常' END AS Risk_Level FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_ID WHERE m.Is_Wireless = 1 GROUP BY m.Model, m.Weight_Grams;	mouse	3
SELECT sd.Tracking_Speed_Ips * sd.Max_Dpi AS Data_Points_Per_Second FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro';	mouse	4
SELECT (m.Weight_Grams/1000.0) * POWER(2 * PI() * sd.Polling_Rate_Hz, 2) * (sd.Acceleration_G * 9.8 / SQRT(2)) AS Inertial_Force FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Model = 'G502 HERO' AND ur.User_ID = 101 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');	mouse	1
WITH Market_HHI AS (SELECT SUM(POWER(Market_Share_Percent, 2)) AS HHI FROM manufacturers), Manufacturer_DPI AS (SELECT Manufacturer_Id, Dpi, COUNT(*) / SUM(COUNT(*)) OVER(PARTITION BY Manufacturer_Id) AS ratio FROM mice GROUP BY Manufacturer_Id, Dpi), Entropy_Calc AS (SELECT Manufacturer_Id, -SUM(ratio * LN(ratio)) AS entropy FROM Manufacturer_DPI GROUP BY Manufacturer_Id) SELECT (AVG(mh.HHI * ec.entropy) - AVG(mh.HHI) * AVG(ec.entropy)) / (STDDEV(mh.HHI) * STDDEV(ec.entropy)) AS Pearson_Correlation FROM Market_HHI mh, Entropy_Calc ec;	mouse	2
WITH Efficiency_Data AS (SELECT m.Model, ur.Clicks/ur.Usage_Duration_Minutes AS current_efficiency, MAX(ur.Clicks/ur.Usage_Duration_Minutes) OVER() AS max_efficiency FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Weight_Grams > 100 AND m.Buttons < 6) SELECT Model, ROUND(max_efficiency - current_efficiency, 4) AS efficiency_decay FROM Efficiency_Data;	mouse	3
WITH constants AS ( SELECT 6.67430e-11 AS G, 1.989e30 AS M, 299792458 AS c, 0.9 AS factor ),sqrt_part AS ( SELECT SQRT( POWER( M, 2 ) - POWER( factor * M, 2 )) AS sqrt_value FROM constants ),numerator AS (SELECT 1 - SQRT(1 - ( 2 * G * M ) / (POWER( c, 2 ) * ( M + sqrt_value )))AS num FROM constants,sqrt_part ),denominator AS (SELECT 1 + (factor * c * POWER( M + sqrt_value, 3 )) / POWER( c, 3 ) AS denom FROM constants,sqrt_part ) SELECT m.Dpi * ( num / denom ) AS DPI_Error FROM mice m,numerator,denominator WHERE m.Model = 'DeathAdder V2'  AND m.Manufacturer_Id = ( SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer' );	mouse	4
SELECT (ur.Clicks * 0.0002) + (m.Weight_Grams/1000 * 9.8 * 0.003 * ur.Clicks) AS Total_Energy_J FROM usage_records ur JOIN mice m ON ur.Mouse_Id = m.Mouse_Id JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Model = 'DeathAdder V2' AND ur.User_ID = 102 AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');	mouse	1
WITH YearSeries AS (SELECT 0 AS year UNION SELECT 1 UNION SELECT 2), MarketData AS ( SELECT m.Manufacturer_Id, YEAR(CURDATE()) - ys.year AS Year, COALESCE(m.Market_Share_Percent,0) AS Share FROM manufacturers m CROSS JOIN YearSeries ys WHERE m.Founded_year <= YEAR(CURDATE()) - ys.year ), TransProb AS ( SELECT curr.Manufacturer_Id, (curr.Share - prev.Share)/NULLIF(prev.Share,0) AS Prob FROM MarketData curr JOIN MarketData prev ON curr.Manufacturer_Id = prev.Manufacturer_Id AND curr.Year = prev.Year + 1 ), Entropy AS ( SELECT Manufacturer_Id, -SUM((cnt/total)*LN(NULLIF(cnt/total,0))) AS entropy FROM ( SELECT Manufacturer_Id, Dpi, COUNT(*) AS cnt, SUM(COUNT(*)) OVER (PARTITION BY Manufacturer_Id) AS total FROM mice GROUP BY Manufacturer_Id, Dpi ) t GROUP BY Manufacturer_Id ) SELECT t.Manufacturer_Id, SUM(t.Prob * LN(NULLIF(t.Prob/e.entropy,0))) AS KL_Divergence FROM TransProb t JOIN Entropy e ON t.Manufacturer_Id = e.Manufacturer_Id GROUP BY t.Manufacturer_Id;	mouse	2
SELECT m.Model, (ur.Scrolls/ur.Usage_Duration_Minutes) * POW(m.Weight_Grams/1000,2)/NULLIF(m.Cable_Length_Meters,0) AS Fatigue_Factor FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Cable_Length_Meters < 1 AND m.Weight_Grams > 150;	mouse	3
SELECT m.Dpi * (1.0 * 1e43*1e-43)/1.32934 AS Effective_DPI FROM mice m WHERE m.Model = 'G502 HERO' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Logitech');	mouse	4
SELECT (m.Weight_Grams/1000 * POWER(sd.Acceleration_G * 9.8, 2)) / 3000 * (m.Cable_Length_Meters / (0.2 * PI() * POWER(0.001, 2))) AS Thermal_Power_W FROM sensor_data sd JOIN mice m ON sd.Mouse_Id = m.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Corsair');	mouse	1
WITH Market_Share_Data AS (SELECT Manufacturer_Id, Market_Share_Percent, ROW_NUMBER() OVER (PARTITION BY Manufacturer_Id ORDER BY Founded_year) AS rn FROM manufacturers), GM_Model AS (SELECT Manufacturer_Id, (FIRST_VALUE(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id ORDER BY rn) - (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) / COUNT(*) OVER (PARTITION BY Manufacturer_Id))) * EXP(-0.5 * (rn-1)) + (SUM(Market_Share_Percent) OVER (PARTITION BY Manufacturer_Id) / COUNT(*) OVER (PARTITION BY Manufacturer_Id)) AS Predicted_Share FROM Market_Share_Data), Mouse_Matrix AS (SELECT Manufacturer_Id, AVG(Dpi) AS avg_dpi, AVG(Price_Usd) AS avg_price, AVG(Weight_Grams) AS avg_weight FROM mice GROUP BY Manufacturer_Id), SVD_Decomp AS (SELECT Manufacturer_Id, avg_dpi/SQRT(POWER(avg_dpi,2)+POWER(avg_price,2)+POWER(avg_weight,2)) AS u1, avg_price/SQRT(POWER(avg_dpi,2)+POWER(avg_price,2)+POWER(avg_weight,2)) AS u2, avg_weight/SQRT(POWER(avg_dpi,2)+POWER(avg_price,2)+POWER(avg_weight,2)) AS u3 FROM Mouse_Matrix), Covariance_Matrix AS (SELECT gm.Manufacturer_Id, gm.Predicted_Share * svd.u1 AS cov1, gm.Predicted_Share * svd.u2 AS cov2, gm.Predicted_Share * svd.u3 AS cov3 FROM GM_Model gm JOIN SVD_Decomp svd ON gm.Manufacturer_Id = svd.Manufacturer_Id) SELECT AVG(cov1)/SQRT(AVG(POWER(gm.Predicted_Share,2)) * AVG(POWER(svd.u1,2))) AS rho1, AVG(cov2)/SQRT(AVG(POWER(gm.Predicted_Share,2)) * AVG(POWER(svd.u2,2))) AS rho2, AVG(cov3)/SQRT(AVG(POWER(gm.Predicted_Share,2)) * AVG(POWER(svd.u3,2))) AS rho3 FROM Covariance_Matrix cm JOIN GM_Model gm ON cm.Manufacturer_Id = gm.Manufacturer_Id JOIN SVD_Decomp svd ON cm.Manufacturer_Id = svd.Manufacturer_Id;	mouse	2
SELECT m.Model, (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 AS Efficiency_Percent FROM mice m WHERE m.Is_Wireless = 1 AND EXISTS (SELECT 1 FROM sensor_data sd WHERE sd.Mouse_Id = m.Mouse_Id AND sd.Max_Dpi > 16000) AND (m.Battery_Life_Hours * 3.7) / (m.Price_Usd * 0.8) * 100 < 80;	mouse	3
SELECT m.Dpi * (1 + 1100) / (70 * 4.4e26 / 3.086e19) * LN(1.6e-35/1.6e-35) AS Effective_DPI FROM mice m WHERE m.Model = 'DeathAdder V2' AND m.Manufacturer_Id = (SELECT Manufacturer_Id FROM manufacturers WHERE Manufacturer_Name = 'Razer');	mouse	4
SELECT 20*(LOG(10, 4*PI()*1*(2.4e9/3e8)))/LOG(10) - 2 - 2 AS Path_Loss_dB FROM mice m JOIN sensor_data sd ON m.Mouse_Id = sd.Mouse_Id WHERE m.Is_Wireless = 1;	mouse	1
CREATE TEMPORARY TABLE BaseData AS SELECT mf.Market_Share_Percent AS Y, md.Dpi AS X1, md.Price_Usd AS X2 FROM mice md JOIN manufacturers mf ON md.Manufacturer_Id = mf.Manufacturer_Id; CREATE TEMPORARY TABLE Stats AS SELECT AVG(Y) AS y_bar, AVG(X1) AS x1_bar, AVG(X2) AS x2_bar, AVG(Y * X1) - AVG(Y) * AVG(X1) AS cov_yx1, AVG(Y * X2) - AVG(Y) * AVG(X2) AS cov_yx2, AVG(X1 * X1) - AVG(X1) * AVG(X1) AS var_x1, AVG(X2 * X2) - AVG(X2) * AVG(X2) AS var_x2, AVG(X1 * X2) - AVG(X1) * AVG(X2) AS cov_x1x2 FROM BaseData; CREATE TEMPORARY TABLE Coefficients AS SELECT (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) AS beta1, (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) AS beta2, y_bar - ( (cov_yx1 * var_x2 - cov_yx2 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) ) * x1_bar - ( (cov_yx2 * var_x1 - cov_yx1 * cov_x1x2) / (var_x1 * var_x2 - POWER(cov_x1x2, 2)) ) * x2_bar AS beta0 FROM Stats; CREATE TEMPORARY TABLE Predicted AS SELECT b.Y, c.beta0 + c.beta1 * b.X1 + c.beta2 * b.X2 AS Y_hat FROM BaseData b CROSS JOIN Coefficients c; SELECT 1 - SUM(POWER(Y - Y_hat, 2)) / SUM(POWER(Y - (SELECT y_bar FROM Stats), 2)) AS R_squared FROM Predicted;	mouse	2
SELECT m.Model, (ur.Energy_Consumed_Joules/(3600*1000)) * 18 * 365 * 0.85 AS Annual_CO2_kg FROM mice m JOIN usage_records ur ON m.Mouse_Id = ur.Mouse_Id WHERE m.Is_Wireless = 1 AND (ur.Energy_Consumed_Joules/(3600*ur.Usage_Duration_Minutes*60)) > 0.5;	mouse	3
SELECT m.Dpi * POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000 * 100))/(1e-6), 2) * LN(1e-4/(PI()*POWER(SQRT(1.0545718e-34/(m.Weight_Grams/1000 * 100)),2))) AS DPI_Error FROM mice m WHERE m.Model = 'G502 HERO';	mouse	4
SELECT ROUND( (0.5 * (m.Weight_Grams / 1000) * POWER(s.Tracking_Speed_Ips * 0.0254, 2) - 0.2 * (m.Weight_Grams / 1000) * 9.8 * u.Distance_Moved_Meters * SIN(RADIANS(15))) / (u.Usage_Duration_Minutes * 60), 6 ) AS Kinetic_Energy_Change FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Model = 'Dark Core RGB Pro' AND u.User_ID = 103	mouse	1
WITH PriceWeightRatio AS ( SELECT man.Manufacturer_Name, m.Price_Usd / m.Weight_Grams AS Ratio, man.Market_Share_Percent FROM mice m JOIN manufacturers man ON m.Manufacturer_Id = man.Manufacturer_Id ), Stats AS ( SELECT Manufacturer_Name, STDDEV(Ratio) AS StdDev, AVG(Ratio) AS Mean, Market_Share_Percent FROM PriceWeightRatio GROUP BY Manufacturer_Name, Market_Share_Percent ) SELECT Manufacturer_Name, ROUND(StdDev / Mean, 4) AS CV, CASE WHEN Market_Share_Percent > 25 THEN 1 ELSE 0 END AS Segment FROM Stats ORDER BY CV DESC	mouse	2
SELECT DISTINCT m.Model FROM usage_records u JOIN mice m ON u.Mouse_ID = m.Mouse_Id JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE (u.Usage_Duration_Minutes / 60) / 8 / s.Sensor_Life_Hours > 0.9	mouse	3
SELECT ROUND(0.5 * (1e-12 * 2 * 10 / (m.Weight_Grams / 1000)) * POWER(1 / 1000, 2), 12) AS Trajectory_Offset FROM mice m WHERE m.Model = 'G502 HERO'	mouse	4
SELECT (0.3 * (m.Weight_Grams/1000) * 9.81 * u.Distance_Moved_Meters + 0.5 * (m.Weight_Grams/1000) * POW(u.Distance_Moved_Meters/(u.Usage_Duration_Minutes*60), 2)) / (u.Usage_Duration_Minutes*60) * 1000 AS power_mw FROM usage_records u JOIN mice m ON u.Mouse_Id = m.Mouse_Id WHERE m.Model = 'G502 HERO' AND DATE(u.Start_Time) = '2023-10-01';	mouse	1
WITH IndexCalc AS (SELECT m.Model, (AVG(s.Sensor_Life_Hours) * m.Dpi) / (m.Price_Usd * m.Weight_Grams) AS efficacy_index FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id GROUP BY m.Model, m.Dpi, m.Price_Usd, m.Weight_Grams) SELECT Model, efficacy_index FROM IndexCalc ORDER BY efficacy_index DESC LIMIT 3;	mouse	2
SELECT m.Model, MAX(s.Lift_Off_Distance_Mm) AS current_lift, SUM(u.Clicks)/COUNT(DISTINCT DATE(u.Start_Time)) AS daily_clicks, DATEDIFF(CURDATE(), MAX(s.Last_Calibration_Date)) AS days_since_calib FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id GROUP BY m.Model HAVING current_lift < 2 AND daily_clicks > 1000 AND days_since_calib > 90;	mouse	3
SELECT (6.626e-34 * 3e8) / (500e-9 * POWER(1e6/m.Dpi, 2)) AS photons_per_pixel, CASE WHEN (1e6/m.Dpi) < (6.626e-34/(2*PI())) THEN '突破海森堡极限' ELSE '理论可行' END AS quantum_status FROM mice m CROSS JOIN (SELECT 1e6 AS target_dpi) params WHERE m.Is_Wireless = 1;	mouse	4
SELECT 0.5 * (Weight_Grams / 1000.0) * POWER((400 * 0.0254), 2) AS Kinetic_Energy_Joules FROM mice WHERE Model = 'Dark Core RGB Pro';	mouse	1
WITH FilteredData AS (SELECT Country, Market_Share_Percent, Profit_Usd / Employees AS Profit_Per_Employee FROM manufacturers WHERE Founded_year > 1993) SELECT Country, VARIANCE(Market_Share_Percent) AS Market_Share_Variance, (AVG(Market_Share_Percent * Profit_Per_Employee) - AVG(Market_Share_Percent) * AVG(Profit_Per_Employee)) AS Covariance FROM FilteredData GROUP BY Country ORDER BY Covariance DESC;	mouse	2
SELECT Model, Battery_Life_Hours, Price_Usd, Battery_Life_Hours / Price_Usd AS Value_Per_USD FROM mice WHERE Is_Wireless = 1 AND Battery_Life_Hours > Price_Usd;	mouse	3
SELECT (2997924.58 / 0.0254) * 16000 / 1e6 AS Packets_Per_Second;	mouse	4
SELECT Energy_Consumed_Joules / (Usage_Duration_Minutes * 60) AS power_watts FROM usage_records WHERE User_Id = 101 AND Mouse_Id = (SELECT Mouse_Id FROM mice WHERE Model = 'G502 HERO') AND Distance_Moved_Meters = 1500.5 AND Energy_Consumed_Joules = 5000 AND Usage_Duration_Minutes = 120;	mouse	1
SELECT Manufacturer_Name, ROUND((Revenue_Usd*0.3 + Profit_Usd*0.4 + Market_Share_Percent*2 + Employees*0.1)/1000, 3) AS composite_score FROM manufacturers ORDER BY composite_score DESC;	mouse	2
SELECT m.Model, m.Battery_Life_Hours, (SELECT MAX(u.Usage_Duration_Minutes)/60 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id) AS max_usage_hours FROM mice m WHERE m.Is_Wireless = 1 AND m.Battery_Life_Hours < (SELECT MAX(u.Usage_Duration_Minutes)/60 FROM usage_records u WHERE u.Mouse_Id = m.Mouse_Id);	mouse	3
SELECT (3 * 9.461e15) / (450 * 0.0254) / (365*24*3600) AS time_years FROM dual;	mouse	4
SELECT (m.Weight_Grams/1000) * (50 * 9.8) AS force_newton FROM mice m WHERE m.Model = 'DeathAdder V2';	mouse	1
SELECT ma.Manufacturer_Name, (MAX(m.Dpi)/m.Price_Usd)*1000 AS dpi_ratio FROM mice m JOIN manufacturers ma ON m.Manufacturer_Id = ma.Manufacturer_Id GROUP BY ma.Manufacturer_Name, m.Price_Usd ORDER BY dpi_ratio DESC LIMIT 3;	mouse	2
SELECT m.Model, s.Lift_Off_Distance_Mm, m.Cable_Length_Meters FROM mice m JOIN sensor_data s ON m.Mouse_Id = s.Mouse_Id WHERE m.Is_Wireless = 0 AND s.Lift_Off_Distance_Mm > 2 AND m.Cable_Length_Meters < 1.5;	mouse	3
SELECT (299792458 / 0.0254) * 8 / 1e15 AS data_pb FROM dual;	mouse	4
SELECT 0.5 * (m.Weight_Grams/1000) * POWER(0.8, 2) AS kinetic_energy_joules FROM mice m JOIN usage_records u ON m.Mouse_Id = u.Mouse_Id WHERE m.Model = 'G502 HERO' AND u.User_Id = 101 AND u.Distance_Moved_Meters = 1500.5;	mouse	1
SELECT Manufacturer_Name, ROUND((Profit_Usd/Employees)/(SELECT AVG(Profit_Usd/Employees) FROM manufacturers), 2) AS profit_ratio FROM manufacturers ORDER BY profit_ratio DESC;	mouse	2
SELECT s.*, t.total_hours FROM sensor_data s JOIN (SELECT Mouse_Id, SUM(Usage_Duration_Minutes)/60 AS total_hours FROM usage_records GROUP BY Mouse_Id) t ON s.Mouse_Id = t.Mouse_Id WHERE s.Sensor_Life_Hours < t.total_hours;	mouse	3
SELECT (0.9*3e8) / (20000*9.8) / 3.15e7 AS time_years FROM dual;	mouse	4
SELECT ROUND((0.121 * 40 * 9.8) * (1500.5 / (120 * 60)), 4) AS Instantaneous_Power FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Logitech' AND mc.Model = 'G502 HERO' AND ur.User_ID = 101;	mouse	1
SELECT mf.Manufacturer_Name, ROUND((MAX(mc.Price_Usd) - MIN(mc.Price_Usd)) / AVG(mc.Price_Usd), 3) AS price_dispersion, mf.Market_Share_Percent FROM manufacturers mf JOIN mice mc ON mf.Manufacturer_Id = mc.Manufacturer_Id GROUP BY mf.Manufacturer_Id ORDER BY price_dispersion DESC, mf.Market_Share_Percent DESC;	mouse	2
SELECT * FROM sensor_data WHERE Calibration_Count > (Sensor_Life_Hours / 100);	mouse	3
SELECT (8.8e26 / (0.0254 / 1e18)) AS movement_times, ROUND(( (8.8e26 / (0.0254 / 1e18)) * 1 * 1000 * 3.154e7 * 1000 ) / 1e24, 3) AS data_yb;	mouse	4
SELECT ROUND((82/1000) * (450*0.0254), 4) AS Momentum_Change FROM manufacturers m JOIN mice mc ON m.Manufacturer_Id = mc.Manufacturer_Id JOIN usage_records ur ON mc.Mouse_Id = ur.Mouse_ID WHERE m.Manufacturer_Name = 'Razer' AND mc.Model = 'DeathAdder V2';	mouse	1
SELECT Manufacturer_Name, ROUND((POWER(Profit_Usd, 1/(2023-Founded_year)) -1)*100, 2) AS CAGR FROM manufacturers ORDER BY CAGR DESC;	mouse	2
SELECT * FROM mice WHERE (Is_Wireless=1 AND Battery_Life_Hours IS NULL) OR (Is_Wireless=0 AND Battery_Life_Hours IS NOT NULL);	mouse	3
SELECT (0.0254/1e6) AS Min_Movement_Distance, ROUND((30720*17280*10*6*3600*365*8 / 1e8), 2) AS Annual_Data_Volume_EB;	mouse	4
SELECT (1000.25 / (120 * 60)) / 0.0254 AS Actual_IPS, CASE WHEN (1000.25 / (120 * 60)) / 0.0254 > 400 THEN 'Exceeds Max Tracking Speed' ELSE 'Within Max Tracking Speed' END AS Speed_Status FROM usage_records ur JOIN mice mc ON ur.Mouse_ID = mc.Mouse_Id JOIN manufacturers mf ON mc.Manufacturer_Id = mf.Manufacturer_Id WHERE mf.Manufacturer_Name = 'Corsair' AND mc.Model = 'Dark Core RGB Pro' AND ur.User_ID = 103;	mouse	1
SELECT Manufacturer_Name, ROUND((Market_Share_Percent / 100) * (Profit_Usd / Employees), 4) AS efficiency_index FROM manufacturers ORDER BY efficiency_index DESC;	mouse	2
SELECT * FROM sensor_data WHERE Max_Dpi > 15000 AND Polling_Rate_Hz < 1000;	mouse	3
SELECT (7680 * 4320 * 10 * 6 * 31536000 * 10) / 1e30 AS Data_Volume_BB;	mouse	4
SELECT v.Vehicle_Id, v.Model, ROUND(dr.Distance_Km / dr.Energy_Consumed_Kwh, 2) AS energy_efficiency, dr.Average_Speed_Kmh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Average_Speed_Kmh > 60 HAVING energy_efficiency < 4 ORDER BY energy_efficiency ASC;	new_energy_vehicles	1
SELECT cs.Station_Name, ROUND(SUM(cr.Cost_Usd) / GREATEST(DATEDIFF(MAX(cr.End_Time), MIN(cr.Start_Time)), 1), 2) AS daily_revenue, cs.Number_Of_Chargers FROM charging_stations cs JOIN charging_records cr ON cs.Station_Id = cr.Station_Id GROUP BY cs.Station_Id HAVING daily_revenue > 500 AND cs.Number_Of_Chargers > 5 ORDER BY daily_revenue DESC LIMIT 3;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Model, (SELECT MAX(cr.End_Time) FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id) AS last_charge_date, (SELECT cr.Charging_Type FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id ORDER BY cr.End_Time DESC LIMIT 1) AS last_charge_type FROM vehicles v WHERE v.Battery_Capacity_Kwh > 100 AND EXISTS (SELECT 1 FROM charging_records cr WHERE cr.Vehicle_Id = v.Vehicle_Id AND cr.Energy_Consumed_Kwh < 20);	new_energy_vehicles	3
WITH RECURSIVE charging_sim AS (SELECT 10.0 AS soc, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time, 1 AS phase UNION ALL SELECT CASE phase WHEN 1 THEN LEAST(soc + 5.0, 50.0) ELSE LEAST(soc + 0.5, 80.0) END, elapsed_time + (100 * CASE phase WHEN 1 THEN 5.0 ELSE 0.5 END) / GREATEST(600 - 0.2 * POW((-60 + 273), 3), 1), CASE WHEN soc >= 50.0 THEN 2 ELSE phase END FROM charging_sim WHERE soc < 80.0 ) SELECT MAX(elapsed_time) AS total_hours, CONCAT(FLOOR(MAX(elapsed_time)), '小时', ROUND((MAX(elapsed_time)%1)*60) , '分钟') AS formatted_time FROM charging_sim;	new_energy_vehicles	4
SELECT cs.Station_Name, cr.Charging_Type, ROUND(AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * TIME_TO_SEC(TIMEDIFF(cr.End_Time, cr.Start_Time))/3600)) * 100, 2) AS efficiency_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, cr.Charging_Type HAVING efficiency_rate < 85 AND charge_count > 10 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
SELECT v.Manufacturer, ROUND(SUM(dr.Distance_Km) / COUNT(DISTINCT DATE(dr.Start_Time)), 2) AS daily_avg_km, COUNT(DISTINCT v.Vehicle_Id) AS vehicle_count FROM vehicles v JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id GROUP BY v.Manufacturer HAVING daily_avg_km > 150 AND vehicle_count >= 3 ORDER BY daily_avg_km DESC;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Model, MAX(cr.End_Time) AS last_charge_date, v.Battery_Health FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE cr.Temperature_Celsius > 30 AND cr.Charging_Type = 'Ultra-Fast' AND v.Battery_Health < 90 GROUP BY v.Vehicle_Id;	new_energy_vehicles	3
WITH RECURSIVE polar_charging AS (SELECT 0 AS soc, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time, 120 * 0.2 * 0.6 AS actual_power, 0.2 * 5 * POW(-50 + 50, 2) AS heat_loss UNION ALL SELECT soc + 5, elapsed_time + (100 * 5) / GREATEST(actual_power - (heat_loss / 1000), 1), actual_power, 0.2 * 5 * POW((-50 + (soc/100)*130) + 50, 2) FROM polar_charging WHERE soc < 100 ) SELECT MAX(elapsed_time) AS total_hours, CONCAT(FLOOR(MAX(elapsed_time)), '小时', ROUND((MAX(elapsed_time) - FLOOR(MAX(elapsed_time))) * 60), '分钟') AS formatted_time FROM polar_charging;	new_energy_vehicles	4
WITH normal_efficiency AS (SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS normal_eff FROM driving_records dr WHERE dr.Weather_Conditions IN ('Sunny', 'Cloudy') GROUP BY dr.Vehicle_Id), extreme_efficiency AS (SELECT dr.Vehicle_Id, AVG(dr.Distance_Km / dr.Energy_Consumed_Kwh) AS extreme_eff FROM driving_records dr WHERE dr.Weather_Conditions IN ('Snow', 'Heatwave') GROUP BY dr.Vehicle_Id) SELECT v.Model, ROUND((ne.normal_eff - ee.extreme_eff) / ne.normal_eff * 100, 2) AS efficiency_decay_rate FROM vehicles v JOIN normal_efficiency ne ON v.Vehicle_Id = ne.Vehicle_Id JOIN extreme_efficiency ee ON v.Vehicle_Id = ee.Vehicle_Id WHERE (ne.normal_eff - ee.extreme_eff) / ne.normal_eff * 100 > 15 ORDER BY efficiency_decay_rate DESC;	new_energy_vehicles	1
WITH weekly_utilization AS (SELECT cs.Station_Id, WEEK(cr.Start_Time) AS week_num, SUM(TIME_TO_SEC(TIMEDIFF(cr.End_Time, cr.Start_Time))) / (cs.Number_Of_Chargers * CASE WHEN cs.Is_24_Hours = 1 THEN 604800 ELSE TIME_TO_SEC(TIMEDIFF(cs.Opening_Hours, '00:00:00')) * 7 END) AS utilization_rate FROM charging_stations cs JOIN charging_records cr ON cs.Station_Id = cr.Station_Id GROUP BY cs.Station_Id, week_num), consecutive_weeks AS (SELECT Station_Id, week_num, utilization_rate, LAG(utilization_rate) OVER (PARTITION BY Station_Id ORDER BY week_num) AS prev_week_rate FROM weekly_utilization) SELECT DISTINCT cs.Station_Name FROM consecutive_weeks cw JOIN charging_stations cs ON cw.Station_Id = cs.Station_Id WHERE cw.utilization_rate > 0.8 AND cw.prev_week_rate > 0.8;	new_energy_vehicles	2
SELECT dr.Record_Id, CONCAT('起点海拔变化:', dr.Elevation_Gain_M, '米; 终点海拔变化:', dr.Elevation_Loss_M, '米') AS elevation_change, dr.Weather_Conditions, v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100 AS theoretical_energy, dr.Energy_Consumed_Kwh AS actual_energy FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE (dr.Elevation_Gain_M + dr.Elevation_Loss_M) > 500 AND dr.Energy_Consumed_Kwh > 1.2 * (v.Battery_Capacity_Kwh * (dr.End_Battery_Percentage - dr.Start_Battery_Percentage) / 100);	new_energy_vehicles	3
WITH RECURSIVE poisson_cdf AS (SELECT 0 AS k, EXP(-5) * POWER(5, 0) / 1 AS prob, EXP(-5) * POWER(5, 0) / 1 AS cdf UNION ALL SELECT k + 1, EXP(-5) * POWER(5, k + 1) / (k + 1), cdf + EXP(-5) * POWER(5, k + 1) / (k + 1) FROM poisson_cdf WHERE k < 7 ) SELECT ROUND(1 - MAX(cdf), 3) AS probability_at_least_8_hours FROM poisson_cdf;	new_energy_vehicles	4
SELECT dr.Record_Id, v.Model, ROUND(v.Weight_Kg * 9.8 * dr.Elevation_Loss_M, 2) AS theoretical_energy, ROUND(dr.Energy_Consumed_Kwh * 0.9 * 3.6e6, 2) AS recovered_energy, ROUND((dr.Energy_Consumed_Kwh * 0.9 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS efficiency_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Elevation_Loss_M > 200 AND (dr.Energy_Consumed_Kwh * 0.9 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 50 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
WITH hourly_usage AS (SELECT cs.Station_Id, HOUR(cr.Start_Time) AS hour_slot, COUNT(*) / cs.Number_Of_Chargers AS utilization_rate, DATE(cr.Start_Time) AS date FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, date, hour_slot HAVING utilization_rate > 0.9), peak_groups AS (SELECT *, hour_slot - ROW_NUMBER() OVER (PARTITION BY Station_Id, date ORDER BY hour_slot) AS grp FROM hourly_usage) SELECT cs.Station_Name, MIN(date) AS start_date, MAX(date) AS end_date FROM peak_groups pg JOIN charging_stations cs ON pg.Station_Id = cs.Station_Id GROUP BY pg.Station_Id, pg.grp HAVING COUNT(*) >= 3 AND MAX(hour_slot) - MIN(hour_slot) < 5;	new_energy_vehicles	2
WITH health_change AS (SELECT cr.Vehicle_Id, cr.End_Time, v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY cr.Vehicle_Id ORDER BY cr.End_Time) AS health_drop FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Temperature_Celsius < 5 AND cr.Charging_Type = 'Ultra-Fast') SELECT v.Model, cs.Operator, hc.health_drop, cr.End_Time AS charge_time FROM health_change hc JOIN charging_records cr ON hc.Vehicle_Id = cr.Vehicle_Id AND hc.End_Time = cr.End_Time JOIN vehicles v ON hc.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE hc.health_drop > 2;	new_energy_vehicles	3
SELECT 0.95 * 5.67e-8 * 3 * (POW(60+273, 4) - POW(3, 4)) / 0.9 AS max_power_kw;	new_energy_vehicles	4
SELECT cr.Record_Id, v.Model, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Charging_Type IN ('Fast', 'Ultra-Fast') AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 90 ORDER BY efficiency_rate ASC;	new_energy_vehicles	1
WITH hourly_peak AS (SELECT cs.Station_Id, DATE(cr.Start_Time) AS date, HOUR(cr.Start_Time) AS hour_slot, COUNT(*) / cs.Number_Of_Chargers AS utilization_rate FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, date, hour_slot HAVING utilization_rate > 0.95), peak_dates AS (SELECT date, COUNT(DISTINCT Station_Id) AS peak_station_count FROM hourly_peak GROUP BY date HAVING COUNT(DISTINCT Station_Id) >= 3) SELECT date, peak_station_count FROM peak_dates ORDER BY date DESC;	new_energy_vehicles	2
SELECT cs.Operator, cs.Location, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast' AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 85;	new_energy_vehicles	3
WITH RECURSIVE monte_carlo AS (SELECT 1 AS iter, ROUND(70 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1 + (RAND() - 0.5) * 1)), 2) AS charge_time UNION ALL SELECT iter + 1, ROUND(70 / ((SELECT AVG(Charging_Speed_Kw) FROM charging_stations) * (1 + (RAND() - 0.5) * 1)), 2) FROM monte_carlo WHERE iter < 1000) SELECT COUNT(*) * 100.0 / 1000 AS probability_over_1_5t FROM monte_carlo WHERE charge_time > 1.5 * (70 / (SELECT AVG(Charging_Speed_Kw) FROM charging_stations));	new_energy_vehicles	4
SELECT dr.Record_Id, v.Model, ROUND((dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100, 2) AS recovery_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Elevation_Loss_M > 300 AND (dr.Energy_Consumed_Kwh * 0.93 * 3.6e6) / (v.Weight_Kg * 9.8 * dr.Elevation_Loss_M) * 100 < 45 ORDER BY recovery_rate ASC;	new_energy_vehicles	1
WITH daily_charge AS (SELECT cr.Vehicle_Id, DATE(cr.Start_Time) AS charge_date, SUM(cr.Energy_Consumed_Kwh) AS daily_energy, MAX(cs.Station_Id) AS last_station_id FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cr.Vehicle_Id, charge_date), growth_trend AS (SELECT Vehicle_Id, charge_date, daily_energy, last_station_id, LAG(daily_energy, 2) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n, LAG(daily_energy, 1) OVER (PARTITION BY Vehicle_Id ORDER BY charge_date) AS day_n_plus_1, daily_energy AS day_n_plus_2 FROM daily_charge), valid_growth AS (SELECT Vehicle_Id, MAX(last_station_id) AS last_station_id, (MAX(day_n_plus_2) - MIN(day_n)) / 2 AS slope FROM growth_trend WHERE day_n < day_n_plus_1 AND day_n_plus_1 < day_n_plus_2 GROUP BY Vehicle_Id) SELECT v.Model, cs.Location AS last_location, vg.slope FROM valid_growth vg JOIN vehicles v ON vg.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON vg.last_station_id = cs.Station_Id;	new_energy_vehicles	2
SELECT cs.Station_Name, cs.Opening_Hours, cs.Is_Covered, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 AND cr.Charging_Type = 'Ultra-Fast' AND (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 80;	new_energy_vehicles	3
SELECT ROUND((0.85 * 5.67e-8 * 2.5 * (POW(283, 4) - POW(35, 4))) / 0.9, 2) AS max_power_kw;	new_energy_vehicles	4
SELECT cs.Station_Name, ROUND((1 - AVG(cr.Energy_Consumed_Kwh / (cs.Charging_Speed_Kw * TIME_TO_SEC(TIMEDIFF(cr.End_Time, cr.Start_Time)) / 3600))) * 100, 2) AS loss_rate, COUNT(*) AS charge_count FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Temperature_Celsius > 35 GROUP BY cs.Station_Id HAVING loss_rate > 20 AND charge_count > 5 ORDER BY loss_rate DESC;	new_energy_vehicles	1
WITH low_efficiency_records AS (SELECT cr.Station_Id, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100, 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 75) SELECT cs.Operator, cs.Is_Covered, COUNT(*) AS record_count FROM charging_stations cs JOIN low_efficiency_records ler ON cs.Station_Id = ler.Station_Id WHERE cs.Location IN (SELECT Location FROM charging_stations WHERE ST_Y(Location) > 2000) GROUP BY cs.Operator, cs.Is_Covered;	new_energy_vehicles	2
WITH high_altitude_stations AS (SELECT cs.Station_Id, cs.Operator, cs.Is_Covered FROM charging_stations cs WHERE EXISTS (SELECT 1 FROM (SELECT ST_GeomFromText('POINT(0 0)') AS Location, 2500 AS Altitude UNION ALL SELECT ST_GeomFromText('POINT(1 1)') AS Location, 1500 AS Altitude) AS ad WHERE ST_Distance_Sphere(cs.Location, ad.Location) < 1000 AND ad.Altitude > 2000 AND ST_Y(cs.Location) BETWEEN -90 AND 90 AND ST_X(cs.Location) BETWEEN -180 AND 180)), low_efficiency_records AS (SELECT cr.Station_Id, ROUND((v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100 / cr.Energy_Consumed_Kwh * 100), 2) AS efficiency_rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE (v.Battery_Capacity_Kwh * (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) / cr.Energy_Consumed_Kwh * 100 < 75) SELECT has.Operator, has.Is_Covered, COUNT(*) AS record_count FROM high_altitude_stations has JOIN low_efficiency_records ler ON has.Station_Id = ler.Station_Id GROUP BY has.Operator, has.Is_Covered	new_energy_vehicles	3
SELECT ROUND(0.2 * 3 * POW(50 - 4, 1.5), 2) AS max_power_kw;	new_energy_vehicles	4
WITH health_change AS (SELECT dr.Vehicle_Id, dr.End_Time, v.Battery_Health - LAG(v.Battery_Health) OVER (PARTITION BY dr.Vehicle_Id ORDER BY dr.End_Time) AS health_drop FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id) SELECT dr.Record_Id, v.Model, ROUND(dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600), 2) AS energy_density, hc.health_drop FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN health_change hc ON dr.Vehicle_Id = hc.Vehicle_Id AND dr.End_Time = hc.End_Time WHERE v.Acceleration_0_To_100_Sec < 2 AND dr.Energy_Consumed_Kwh / (v.Acceleration_0_To_100_Sec / 3600) > 500 AND hc.health_drop > 5;	new_energy_vehicles	1
WITH abnormal_charge AS (SELECT cr.Vehicle_Id, DATE(cr.Start_Time) AS charge_date, cr.Energy_Consumed_Kwh FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE cr.Energy_Consumed_Kwh > 3 * v.Battery_Capacity_Kwh), no_driving_records AS (SELECT ac.Vehicle_Id, ac.charge_date FROM abnormal_charge ac LEFT JOIN driving_records dr ON ac.Vehicle_Id = dr.Vehicle_Id AND DATE(dr.Start_Time) = ac.charge_date WHERE dr.Record_Id IS NULL) SELECT Vehicle_Id, charge_date FROM no_driving_records;	new_energy_vehicles	2
SELECT v.Manufacturer, cs.Is_Covered, COUNT(*) AS record_count FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE dr.Weather_Conditions = 'Blizzard' AND v.Is_Autonomous = 1 AND dr.Average_Speed_Kmh > 100 GROUP BY v.Manufacturer, cs.Is_Covered;	new_energy_vehicles	3
SELECT v.Model, v.Charging_Time_Hours / 707 AS subjective_time_hours, v.Charging_Time_Hours AS earth_time_hours FROM vehicles v WHERE v.Model = 'Model S';	new_energy_vehicles	4
SELECT ROUND((v.Battery_Capacity_Kwh * (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) * (1 - 0.05)) / NULLIF(c.Energy_Consumed_Kwh, 0) * 100, 2) AS Charging_Efficiency FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Record_Id = 1 AND v.Model = 'Model S' AND c.Final_Battery_Percentage IS NOT NULL AND c.Initial_Battery_Percentage IS NOT NULL AND c.Energy_Consumed_Kwh IS NOT NULL;	new_energy_vehicles	1
WITH StationStats AS ( SELECT Cost_Per_Kwh, Charging_Speed_Kw, (Cost_Per_Kwh - AVG(Cost_Per_Kwh) OVER ()) * (Charging_Speed_Kw - AVG(Charging_Speed_Kw) OVER ()) AS Covariance, POWER(Cost_Per_Kwh - AVG(Cost_Per_Kwh) OVER (), 2) AS VarX, POWER(Charging_Speed_Kw - AVG(Charging_Speed_Kw) OVER (), 2) AS VarY FROM charging_stations ) SELECT ROUND(SUM(Covariance) / (SQRT(SUM(VarX)) * SQRT(SUM(VarY))), 4) AS Pearson_Correlation FROM StationStats ORDER BY ABS(Pearson_Correlation) DESC	new_energy_vehicles	2
SELECT Station_Id, ROUND(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 8, 2) AS Daily_Revenue FROM charging_stations WHERE Cost_Per_Kwh > 0.25 AND Charging_Speed_Kw < 100	new_energy_vehicles	3
SELECT Station_Id, ROUND(Charging_Speed_Kw * 6 * 0.2 * 0.9, 2) AS Max_Charging_Capacity FROM charging_stations	new_energy_vehicles	4
SELECT ROUND(d.Distance_Km / (d.Energy_Consumed_Kwh + (d.Elevation_Gain_M/100*0.5)), 2) AS Energy_Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 2 AND v.Model = 'ET7'	new_energy_vehicles	1
WITH Efficiency AS ( SELECT Operator, SUM(Cost_Per_Kwh * Charging_Speed_Kw * Number_Of_Chargers * 24)/SUM(Number_Of_Chargers) AS Operational_Efficiency, AVG(Charging_Speed_Kw) AS Avg_Charging_Speed FROM charging_stations GROUP BY Operator ) SELECT Operator, STDDEV(Operational_Efficiency) OVER() AS Std_Efficiency, Operational_Efficiency, POWER(Operational_Efficiency, 2) AS Efficiency_Squared, Avg_Charging_Speed, POWER(Avg_Charging_Speed, 2) AS Speed_Squared FROM Efficiency ORDER BY Operator;	new_energy_vehicles	2
SELECT c.Record_Id, ROUND(c.Energy_Consumed_Kwh * c.Temperature_Celsius / 100, 2) AS Risk_Factor FROM charging_records c JOIN charging_stations s ON c.Station_Id = s.Station_Id WHERE s.Is_24_Hours = 0 AND s.Is_Covered = 0 AND c.Weather_Conditions = 'Rainy' AND c.Energy_Consumed_Kwh > 50	new_energy_vehicles	3
SELECT Station_Id, ROUND(1000 * Number_Of_Chargers * 0.8 / 0.9, 2) AS Grid_Impact FROM charging_stations	new_energy_vehicles	4
SELECT ROUND( ( (0.5 * v.Weight_Kg * POWER((d.Distance_Km/(TIMESTAMPDIFF(HOUR, d.Start_Time, d.End_Time))/3.6), 2)) + (v.Weight_Kg * 9.8 * d.Elevation_Gain_M/1000) ) / (d.Energy_Consumed_Kwh * 3600000) * 100, 2 ) AS Efficiency FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Record_Id = 3 AND v.Manufacturer = 'BYD' AND v.Model = 'Han EV'	new_energy_vehicles	1
WITH ranked_data AS ( SELECT Operator, Number_Of_Chargers, Charging_Speed_Kw, RANK() OVER (PARTITION BY Operator ORDER BY Number_Of_Chargers) AS rank_chargers, RANK() OVER (PARTITION BY Operator ORDER BY Charging_Speed_Kw) AS rank_speed FROM charging_stations WHERE Number_Of_Chargers IS NOT NULL AND Charging_Speed_Kw IS NOT NULL ), diff_data AS ( SELECT Operator, POWER(rank_chargers - rank_speed, 2) AS d_squared FROM ranked_data ), correlation_data AS ( SELECT Operator, 1 - (6 * SUM(d_squared)) / (COUNT(*) * (POWER(COUNT(*), 2) - 1)) AS spearman_correlation FROM diff_data GROUP BY Operator ) SELECT Operator, spearman_correlation FROM correlation_data ORDER BY ABS(spearman_correlation) DESC;	new_energy_vehicles	2
SELECT c.Record_Id, ROUND( ((c.Final_Battery_Percentage - c.Initial_Battery_Percentage)/100 * v.Battery_Capacity_Kwh * c.Temperature_Celsius) / v.Battery_Capacity_Kwh, 2 ) AS Risk_Index FROM charging_records c JOIN vehicles v ON c.Vehicle_Id = v.Vehicle_Id WHERE c.Charging_Type = 'Fast' AND c.Temperature_Celsius > 40 AND (c.Final_Battery_Percentage - c.Initial_Battery_Percentage) > 80	new_energy_vehicles	3
SELECT v.Vehicle_Id, ROUND( (v.Range_Km + (1000*0.95*1)/(d.Energy_Consumed_Kwh/d.Distance_Km)) / v.Range_Km, 2 ) AS Range_Boost FROM vehicles v JOIN driving_records d ON v.Vehicle_Id = d.Vehicle_Id WHERE d.Record_Id = 3	new_energy_vehicles	4
SELECT cr.Vehicle_Id, ROUND(cr.Energy_Consumed_Kwh / TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time), 2) AS P_avg_kW, ROUND((cr.Energy_Consumed_Kwh * 3600000) / (POWER(400,2) * TIMESTAMPDIFF(SECOND, cr.Start_Time, cr.End_Time) * 0.05*(25/cr.Temperature_Celsius)/3600), 4) AS Efficiency_Rate FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE v.Manufacturer = 'Tesla' AND cr.Charging_Type = 'Fast';	new_energy_vehicles	1
WITH CostBenefit AS (SELECT v.Manufacturer, v.Model, SUM(dr.Distance_Km * v.Range_Km) / SUM(cr.Energy_Consumed_Kwh * cr.Cost_Usd) AS Benefit_Ratio FROM driving_records dr JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id WHERE dr.Weather_Conditions = 'Sunny' GROUP BY v.Manufacturer, v.Model) SELECT * FROM (SELECT *, RANK() OVER(ORDER BY Benefit_Ratio DESC) AS Ranking FROM CostBenefit) sub WHERE Ranking <= 3;	new_energy_vehicles	2
SELECT cr.Record_Id, cs.Station_Name, cs.Opening_Hours, cr.Start_Time FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cs.Opening_Hours != '00:00-23:59' AND (TIME(cr.Start_Time) < STR_TO_DATE(SUBSTRING_INDEX(cs.Opening_Hours, '-', 1), '%H:%i') OR TIME(cr.End_Time) > STR_TO_DATE(SUBSTRING_INDEX(cs.Opening_Hours, '-', -1), '%H:%i'));	new_energy_vehicles	3
SELECT ROUND((0.5 * 50000 * POW(29979245.8,2)) / (10000000), 2) AS Time_Seconds, ROUND((0.5 * 50000 * POW(29979245.8,2)) / (50000 * POW(299792458,2)), 12) AS MassEnergy_Ratio FROM DUAL;	new_energy_vehicles	4
WITH RainyDrives AS ( SELECT dr.Record_Id, v.Weight_Kg, dr.Elevation_Gain_M - dr.Elevation_Loss_M AS elevation_diff_m, dr.Energy_Consumed_Kwh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Weather_Conditions = 'Rainy' ) SELECT Record_Id, ROUND( (Weight_Kg * 9.8 * elevation_diff_m / 1000) / (Energy_Consumed_Kwh * 3600000) * 100, 2 ) AS efficiency_percent FROM RainyDrives WHERE Energy_Consumed_Kwh > 0;	new_energy_vehicles	1
WITH PeakHours AS ( SELECT cs.Operator, cs.Number_Of_Chargers, SUM(cr.Energy_Consumed_Kwh * cs.Cost_Per_Kwh) AS total_revenue, SUM(TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time)) AS total_hours FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Charging_Type = 'Fast' AND HOUR(cr.Start_Time) BETWEEN 18 AND 22 GROUP BY cs.Operator, cs.Number_Of_Chargers ) SELECT Operator, ROUND(total_revenue / (Number_Of_Chargers * total_hours), 2) AS efficiency_ratio, RANK() OVER(ORDER BY (total_revenue / (Number_Of_Chargers * total_hours)) DESC) AS efficiency_rank FROM PeakHours;	new_energy_vehicles	2
WITH RangeAnalysis AS ( SELECT v.Vehicle_Id, v.Manufacturer, v.Model, v.Battery_Capacity_Kwh, v.Range_Km, dr.End_Battery_Percentage FROM vehicles v LEFT JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id WHERE v.Range_Km < v.Battery_Capacity_Kwh * 5 ) SELECT Vehicle_Id, Manufacturer, Model, Battery_Capacity_Kwh, Range_Km, ROUND(Range_Km / Battery_Capacity_Kwh, 2) AS actual_range_factor, End_Battery_Percentage FROM RangeAnalysis;	new_energy_vehicles	3
WITH PhysicsConstants AS ( SELECT 1.225 AS air_density, 2.5 AS frontal_area, 900 / 3.6 AS speed_mps ), VehicleEnergy AS ( SELECT Battery_Capacity_Kwh * 1000 AS battery_joules FROM vehicles WHERE Model = 'Model S' LIMIT 1 ), AirResistance AS ( SELECT 0.5 * air_density * frontal_area * POWER(speed_mps, 3) AS power_watts FROM PhysicsConstants ) SELECT power_watts, battery_joules / (power_watts * 3600) AS endurance_hours, CASE WHEN battery_joules / (power_watts * 3600) < 1 THEN '突破' ELSE '安全' END AS status FROM AirResistance, VehicleEnergy;	new_energy_vehicles	4
WITH SnowDrives AS ( SELECT dr.Record_Id, v.Weight_Kg, dr.Elevation_Gain_M, dr.Average_Speed_Kmh, 0.6 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.9 AS torque_front, 0.4 * v.Weight_Kg * 9.8 * 0.3 * 0.3 / 0.85 AS torque_rear FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE v.Drivetrain = 'AWD' AND dr.Weather_Conditions = 'Snow' ) SELECT Record_Id, ROUND(torque_front / torque_rear, 2) AS torque_ratio FROM SnowDrives;	new_energy_vehicles	1
WITH ServiceEfficiency AS ( SELECT cs.Station_Id, cs.Number_Of_Chargers, cs.Parking_Fee_Usd, cs.Is_Solar_Powered, QUARTER(cr.Start_Time) AS quarter, SUM(cr.Energy_Consumed_Kwh * IF(cs.Is_Solar_Powered, 1.2, 1)) AS adjusted_energy FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id, cs.Number_Of_Chargers, cs.Parking_Fee_Usd, cs.Is_Solar_Powered, quarter ) SELECT Station_Id, quarter, ROUND(adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd), 2) AS efficiency_ratio, RANK() OVER(PARTITION BY quarter ORDER BY adjusted_energy / (Number_Of_Chargers * Parking_Fee_Usd) DESC) AS efficiency_rank FROM ServiceEfficiency;	new_energy_vehicles	2
WITH FastChargeAnalysis AS ( SELECT cr.Record_Id, cr.Temperature_Celsius, (cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time) AS soc_rate FROM charging_records cr WHERE cr.Charging_Type = 'Fast' ) SELECT Record_Id, soc_rate, Temperature_Celsius, CASE WHEN soc_rate > 70 OR Temperature_Celsius > 40 THEN '异常' ELSE '正常' END AS health_status FROM FastChargeAnalysis;	new_energy_vehicles	3
WITH QuantumConstants AS ( SELECT 1.0545718e-34 AS h_bar, 1e-9 AS barrier_thickness, 5 * 1.6e-19 AS barrier_energy ), TunnelingProbability AS ( SELECT EXP(-2 * barrier_thickness * SQRT(2 * 9.11e-31 * barrier_energy) / h_bar) AS p_tunnel FROM QuantumConstants ), EnergyLoss AS ( SELECT cr.Record_Id, cr.Energy_Consumed_Kwh * 1000 * p_tunnel AS energy_loss_joules FROM charging_records cr, TunnelingProbability ) SELECT Record_Id, energy_loss_joules, CASE WHEN energy_loss_joules > 100 THEN '超过量子极限' ELSE '安全' END AS quantum_status FROM EnergyLoss;	new_energy_vehicles	4
WITH ChargingPhysics AS (SELECT cr.Record_Id, cr.Energy_Consumed_Kwh, cs.Charging_Speed_Kw, cr.Temperature_Celsius, (cs.Charging_Speed_Kw * 1000 / 400) AS I, (1.68e-8 * 5) / (PI() * POW(0.005, 2)) AS R, (POW(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (PI() * POW(0.005, 2)) * TIMESTAMPDIFF(SECOND, cr.Start_Time, cr.End_Time)) / 3.6e6 AS Q, ((POW(cs.Charging_Speed_Kw * 1000 / 400, 2) * (1.68e-8 * 5) / (PI() * POW(0.005, 2)) * TIMESTAMPDIFF(SECOND, cr.Start_Time, cr.End_Time)) / 3.6e6 * 3.6e6) / (100 * 385) AS ΔT FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Charging_Type = 'fast') SELECT Record_Id, ΔT AS Temperature_Rise, (Energy_Consumed_Kwh - Q) / Energy_Consumed_Kwh * 100 AS Efficiency_Loss_Percent FROM ChargingPhysics	new_energy_vehicles	1
WITH RangeAnalysis AS (SELECT dr.Vehicle_Id, v.Manufacturer, dr.Distance_Km / (v.Range_Km * (dr.Start_Battery_Percentage - dr.End_Battery_Percentage) / 100) AS Range_Ratio FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Weather_Conditions IN ('Rainy','Snow')) SELECT Manufacturer, STDDEV(Range_Ratio) / AVG(Range_Ratio) AS Volatility_Rate FROM RangeAnalysis GROUP BY Manufacturer HAVING STDDEV(Range_Ratio) / AVG(Range_Ratio) > 0.2	new_energy_vehicles	2
WITH StationSessions AS (SELECT Station_Id, Start_Time, End_Time, TIMESTAMPDIFF(HOUR, LAG(End_Time) OVER (PARTITION BY Station_Id ORDER BY Start_Time), Start_Time) AS Rest_Hours FROM charging_records) SELECT Station_Id, SUM(TIMESTAMPDIFF(HOUR, Start_Time, End_Time)) AS Total_Operating_Hours FROM StationSessions WHERE Rest_Hours > 24 AND Station_Id NOT IN (SELECT Station_Id FROM charging_stations WHERE Is_24_Hours = 1) GROUP BY Station_Id HAVING SUM(TIMESTAMPDIFF(HOUR, Start_Time, End_Time)) > 72	new_energy_vehicles	3
SELECT SQRT(1.625 / 2) AS ω_min_rads, SQRT(1.625 / 2) * 60 / (2 * PI()) AS Critical_RPM, (1200 * (1.625 / 2) * POW(2, 3)) / 3 AS Material_Stress, CASE WHEN (1200 * (1.625 / 2) * POW(2, 3)) / 3 > 500e6 THEN '超限' ELSE '安全' END AS Safety_Status	new_energy_vehicles	4
SELECT Energy_Consumed_Kwh / (100 * (Final_Battery_Percentage - Initial_Battery_Percentage) / 100) AS efficiency FROM charging_records WHERE Vehicle_Id = 1 AND DATE(Start_Time) = '2023-10-01';	new_energy_vehicles	1
SELECT cs.Station_Name, SUM(cr.Energy_Consumed_Kwh) / SUM(TIMESTAMPDIFF(HOUR, cr.Start_Time, cr.End_Time)) AS efficiency FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id ORDER BY efficiency DESC LIMIT 5;	new_energy_vehicles	2
SELECT cr.Vehicle_Id, cs.Station_Name FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE cr.Weather_Conditions = 'Rainy' AND cr.Charging_Type = 'Fast';	new_energy_vehicles	3
SELECT 1000 * 1000 / 400 AS current_strength;	new_energy_vehicles	4
SELECT (0.7 * (2300 * 9.81 * 30) / 3600000) AS regenerative_energy_kwh, Energy_Consumed_Kwh, CASE WHEN (0.7 * (2300 * 9.81 * 30) / 3600000) > Energy_Consumed_Kwh * 0.15 THEN 1 ELSE 0 END AS is_over_15percent FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 5 AND DATE(dr.Start_Time) = '2023-10-05';	new_energy_vehicles	1
SELECT Operator, (SUM(Energy_Consumed_Kwh)/MAX(Number_Of_Chargers)) * (1 + SUM(CASE WHEN HOUR(Start_Time) >=20 OR HOUR(Start_Time) <6 THEN Energy_Consumed_Kwh ELSE 0 END)/SUM(Energy_Consumed_Kwh)) AS efficiency_index FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY Operator ORDER BY efficiency_index DESC LIMIT 3;	new_energy_vehicles	2
SELECT v.Model, MAX(cs.Is_Covered) AS has_covered FROM vehicles v JOIN driving_records dr ON v.Vehicle_Id = dr.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE v.Range_Km > 500 AND v.Drivetrain = 'AWD' AND v.Is_Autonomous = 1 AND dr.Weather_Conditions IN ('Rainy','Cloudy') GROUP BY v.Model HAVING AVG(dr.Average_Speed_Kmh) > 80;	new_energy_vehicles	3
SELECT (100 * 200 * 3600) / 180 - (100 * 200 * 2.1 * 50) AS required_cooling_kj	new_energy_vehicles	4
SELECT (0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) AS regenerated_kwh, dr.Energy_Consumed_Kwh, cr.Energy_Consumed_Kwh AS charged_kwh, ((0.65 * (2200 * POWER(60/3.6, 2) / 2) / 3600) / dr.Energy_Consumed_Kwh) * 100 AS contribution_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id AND DATE(cr.Start_Time) = '2023-10-02' WHERE dr.Vehicle_Id = 2 AND dr.Road_Type = 'City' AND DATE(dr.Start_Time) = '2023-10-02';	new_energy_vehicles	1
WITH peak_energy AS (SELECT Station_Id, SUM(CASE WHEN HOUR(Start_Time) BETWEEN 7 AND 9 OR HOUR(Start_Time) BETWEEN 17 AND 19 THEN Energy_Consumed_Kwh ELSE 0 END) AS peak_energy, SUM(Energy_Consumed_Kwh) AS total_energy, SUM(Cost_Usd) AS total_revenue, SUM(TIMESTAMPDIFF(HOUR, Start_Time, End_Time)) AS total_hours FROM charging_records GROUP BY Station_Id) SELECT cs.Station_Name, (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) AS health_index FROM peak_energy pe JOIN charging_stations cs ON pe.Station_Id = cs.Station_Id WHERE (peak_energy/total_energy*0.4 + (total_revenue/total_hours)*0.6) > 0.7;	new_energy_vehicles	2
WITH charge_cycles AS (SELECT Vehicle_Id, SUM((Final_Battery_Percentage - Initial_Battery_Percentage)/100) AS cycles FROM charging_records GROUP BY Vehicle_Id), fast_charge_stats AS (SELECT Vehicle_Id, COUNT(CASE WHEN Charging_Type = 'Fast' THEN 1 END)*1.0/COUNT(*) AS fast_ratio FROM charging_records GROUP BY Vehicle_Id), high_temp_records AS (SELECT DISTINCT Vehicle_Id FROM charging_records WHERE Temperature_Celsius > 35) SELECT v.Vehicle_Id, v.Model FROM vehicles v JOIN charge_cycles cc ON v.Vehicle_Id = cc.Vehicle_Id JOIN fast_charge_stats fcs ON v.Vehicle_Id = fcs.Vehicle_Id JOIN high_temp_records htr ON v.Vehicle_Id = htr.Vehicle_Id WHERE cc.cycles > 500 AND fcs.fast_ratio > 0.7;	new_energy_vehicles	3
SELECT 500000/(4*PI()*POWER(0.1,2)) AS radiation_intensity, CASE WHEN 500000/(4*PI()*POWER(0.1,2)) > 100*87 THEN '需讨论热效应' ELSE '安全' END AS safety_status;	new_energy_vehicles	4
SELECT dr.Record_Id, 0.5 * (1.225 - 1.204) * 0.28 * 2.5 * POWER((dr.Average_Speed_Kmh / 3.6), 3) * (dr.Distance_Km / (dr.Average_Speed_Kmh / 3.6)) / 3600 AS energy_difference_kwh FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id JOIN charging_records cr ON dr.Vehicle_Id = cr.Vehicle_Id JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE v.Model = 'Model S' AND YEAR(dr.Start_Time) = 2023 AND MONTH(dr.Start_Time) = 10;	new_energy_vehicles	1
WITH charge_cycles AS (SELECT cr.Vehicle_Id, SUM((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100) AS cycles, AVG(v.Battery_Capacity_Kwh - (cr.Energy_Consumed_Kwh / ((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage) / 100))) AS capacity FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id GROUP BY cr.Vehicle_Id) SELECT Vehicle_Id, cycles, capacity FROM charge_cycles WHERE capacity > 0.05;	new_energy_vehicles	2
SELECT DISTINCT dr.Vehicle_Id FROM driving_records dr WHERE dr.Weather_Conditions LIKE '%snow%';	new_energy_vehicles	3
SELECT '零电阻下理论涡流损耗为0，但地磁场变化可能导致超导体失超。' AS analysis_result;	new_energy_vehicles	4
SELECT dr.Energy_Consumed_Kwh, (0.6*0.4*2000*9.81*dr.Distance_Km/3600) AS theoretical_loss, (dr.Energy_Consumed_Kwh - (0.6*0.4*2000*9.81*dr.Distance_Km/3600))/dr.Energy_Consumed_Kwh*100 AS deviation_rate FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE dr.Vehicle_Id = 3 AND DATE(dr.Start_Time) = '2023-10-03' AND dr.Weather_Conditions = 'Rainy';	new_energy_vehicles	1
WITH risk_data AS (SELECT cs.Station_Id, COUNT(CASE WHEN cr.Temperature_Celsius >25 THEN 1 END)*1.0/COUNT(*)*0.4 + COUNT(CASE WHEN HOUR(cr.Start_Time) BETWEEN 18 AND 23 THEN 1 END)*1.0/COUNT(*)*0.6 AS risk_score FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id GROUP BY cs.Station_Id) SELECT Station_Id, risk_score FROM risk_data WHERE risk_score > 0.4;	new_energy_vehicles	2
WITH battery_health AS (SELECT cr.Vehicle_Id, (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh/((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage +1)/100)))/v.Battery_Capacity_Kwh*100 AS health FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id GROUP BY cr.Vehicle_Id, v.Battery_Capacity_Kwh) SELECT bh.Vehicle_Id FROM battery_health bh JOIN (SELECT Vehicle_Id, AVG(Average_Speed_Kmh) AS avg_speed FROM driving_records GROUP BY Vehicle_Id HAVING avg_speed > 80) dr ON bh.Vehicle_Id = dr.Vehicle_Id WHERE bh.health < 80;	new_energy_vehicles	3
SELECT (5E-3 * POWER(5E3,2) * 10 * 3600) / NULLIF(2000E3,0) AS energy_loss_rate;	new_energy_vehicles	4
SELECT dr.Record_Id, 0.5 * 1.225 * 0.24 * 2.34 * (POWER(dr.Average_Speed_Kmh/3.6, 3) - POWER(100/3.6, 3)) * (dr.Distance_Km/(dr.Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records dr JOIN vehicles v ON dr.Vehicle_Id = v.Vehicle_Id WHERE v.Model = 'Model S' AND dr.Road_Type = 'Highway' AND YEAR(dr.Start_Time) = 2023 AND MONTH(dr.Start_Time) = 10;	new_energy_vehicles	1
WITH temp_effect AS (SELECT Vehicle_Id, AVG(1.1*POWER(1.05,(Temperature_Celsius-25)/10)) AS temp_factor FROM charging_records WHERE Temperature_Celsius IS NOT NULL GROUP BY Vehicle_Id) SELECT v.Vehicle_Id, (v.Battery_Capacity_Kwh - AVG(cr.Energy_Consumed_Kwh/((cr.Final_Battery_Percentage - cr.Initial_Battery_Percentage)/100)))/v.Battery_Capacity_Kwh*100 AS capacity_loss FROM charging_records cr JOIN vehicles v ON cr.Vehicle_Id = v.Vehicle_Id JOIN temp_effect te ON v.Vehicle_Id = te.Vehicle_Id GROUP BY v.Vehicle_Id, v.Battery_Capacity_Kwh HAVING capacity_loss > 20;	new_energy_vehicles	2
WITH deep_charge AS (SELECT Vehicle_Id FROM charging_records WHERE Final_Battery_Percentage > 90 AND Start_Time >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) GROUP BY Vehicle_Id HAVING COUNT(*) > 10) SELECT v.Vehicle_Id FROM vehicles v JOIN deep_charge dc ON v.Vehicle_Id = dc.Vehicle_Id WHERE v.Drivetrain = 'PHEV';	new_energy_vehicles	3
SELECT 1E6 * 7.8E3 / 3E8 * COS(RADIANS(45)) * SQRT((1 + 7.8E3/3E8)/(1 - 7.8E3/3E8)) AS doppler_shift;	new_energy_vehicles	4
SELECT 0.5 * (1.225*(1+0.12*1.5) - 1.225) * 0.28 * 2.5 * POWER(Average_Speed_Kmh/3.6, 3) * (Distance_Km/(Average_Speed_Kmh/3.6))/3600 AS energy_impact FROM driving_records WHERE Vehicle_Id = 2 AND DATE(Start_Time) = '2023-10-02' AND Weather_Conditions LIKE '%Rain%';	new_energy_vehicles	1
WITH heat_data AS (SELECT Vehicle_Id, COUNT(CASE WHEN Temperature_Celsius >35 THEN 1 END) AS heat_count, SUM(Elevation_Gain_M)/1000 AS total_elevation FROM charging_records JOIN driving_records USING (Vehicle_Id) GROUP BY Vehicle_Id) SELECT Vehicle_Id, heat_count / (total_elevation*0.1 + 1) AS thermal_index FROM heat_data WHERE heat_count / (total_elevation*0.1 + 1) < 2.5;	new_energy_vehicles	2
SELECT Vehicle_Id, (0.3*(Temperature_Celsius-25)*TIME_TO_SEC(TIMEDIFF(End_Time, Start_Time))/3600 - 2.1e-4*(Temperature_Celsius-25)*50) AS evaporation_mm FROM charging_records JOIN vehicles USING (Vehicle_Id) WHERE Model = 'Model S' AND Temperature_Celsius >35 AND TIMEDIFF(End_Time, Start_Time) > 0;	new_energy_vehicles	3
SELECT 24e-6 * 200e9 * (ABS(-180 - 100)) * SQRT(PI()*0.01) AS crack_growth_rate;	new_energy_vehicles	4
WITH RegenerativeEnergy AS (SELECT 80 * 0.5 * v.Weight_Kg * POWER((d.Average_Speed_Kmh / 3.6), 2) * 0.65 / 3600 AS Regenerated_Energy_Kwh FROM driving_records d JOIN vehicles v ON d.Vehicle_Id = v.Vehicle_Id WHERE d.Vehicle_Id = 2 AND DATE(d.Start_Time) = '2023-10-02'), ChargingEnergy AS (SELECT SUM(c.Energy_Consumed_Kwh) AS Charged_Energy_Kwh FROM charging_records c WHERE c.Vehicle_Id = 2 AND DATE(c.Start_Time) = '2023-10-02') SELECT r.Regenerated_Energy_Kwh, c.Charged_Energy_Kwh, (r.Regenerated_Energy_Kwh - c.Charged_Energy_Kwh)/r.Regenerated_Energy_Kwh*100 AS Deviation_Percent FROM RegenerativeEnergy r, ChargingEnergy c;	new_energy_vehicles	1
WITH PeakPowerUtil AS (SELECT cs.Station_Id, SUM(cr.Energy_Consumed_Kwh)/(cs.Charging_Speed_Kw*3) AS Utilization FROM charging_records cr JOIN charging_stations cs ON cr.Station_Id = cs.Station_Id WHERE TIME(cr.Start_Time) BETWEEN '18:00:00' AND '21:00:00' GROUP BY cs.Station_Id) SELECT cs.Station_Id, (ppu.Utilization*0.7) AS Performance_Index, cs.Is_Solar_Powered FROM charging_stations cs JOIN PeakPowerUtil ppu ON cs.Station_Id = ppu.Station_Id WHERE (ppu.Utilization*0.7) > 0.8;	new_energy_vehicles	2
SELECT v.Vehicle_Id, v.Production_Year, AVG(cr.Temperature_Celsius) AS Avg_Temp FROM vehicles v JOIN charging_records cr ON v.Vehicle_Id = cr.Vehicle_Id WHERE (YEAR(CURDATE()) - v.Production_Year) > 3 AND cr.Charging_Type = 'Standard' GROUP BY v.Vehicle_Id, v.Production_Year HAVING AVG(cr.Temperature_Celsius) < 5;	new_energy_vehicles	3
 SELECT v.Vehicle_Id, (POWER(5,2)*0.01)/(2*4*PI()*POWER(10,-7)) AS Lorentz_Force FROM vehicles v WHERE v.Weight_Kg > 0;	new_energy_vehicles	4
SELECT dr.Distance_Km, dr.Elevation_Gain_M, (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000) / 3600 AS theory_energy, dr.Energy_Consumed_Kwh AS actual_energy, (dr.Energy_Consumed_Kwh - (v.Weight_Kg * 9.81 * (0.02 + 0.015) * dr.Distance_Km * 1000)/3600) AS deviation FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE dr.Vehicle_Id = 5 AND dr.Start_Time >= '2023-10-05' AND dr.End_Time < '2023-10-06' AND dr.Road_Type = 'Rural';	new_energy_vehicles	1
WITH station_stats AS (SELECT v.Manufacturer, cs.Station_Id, AVG(cr.Energy_Consumed_Kwh/(cs.Charging_Speed_Kw * (UNIX_TIMESTAMP(cr.End_Time)-UNIX_TIMESTAMP(cr.Start_Time))/3600)) AS efficiency FROM charging_records cr JOIN vehicles v USING(Vehicle_Id) JOIN charging_stations cs USING(Station_Id) WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31' GROUP BY v.Manufacturer, cs.Station_Id) SELECT Manufacturer, STDDEV(efficiency)/AVG(efficiency) AS anomaly_index FROM station_stats GROUP BY Manufacturer HAVING anomaly_index > 0.15;	new_energy_vehicles	2
SELECT cr.Vehicle_Id, COUNT(CASE WHEN cr.Charging_Type = 'Fast' THEN 1 END)/COUNT(*) AS fast_charge_ratio, AVG(cr.Temperature_Celsius) AS avg_temp FROM charging_records cr WHERE cr.Start_Time BETWEEN '2023-07-01' AND '2023-10-31' GROUP BY cr.Vehicle_Id HAVING fast_charge_ratio > 0.5 AND avg_temp > 30;	new_energy_vehicles	3
SELECT CASE WHEN dr.Weather_Conditions = 'Snowstorm' THEN 1 ELSE 0 END AS is_snow, AVG(cr.Energy_Consumed_Kwh/(cs.Charging_Speed_Kw * (UNIX_TIMESTAMP(cr.End_Time)-UNIX_TIMESTAMP(cr.Start_Time))/3600)) AS efficiency FROM charging_records cr JOIN charging_stations cs USING(Station_Id) JOIN driving_records dr USING(Vehicle_Id) WHERE cr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31' GROUP BY is_snow;	new_energy_vehicles	4
SELECT dr.Vehicle_Id, (( (dr.End_Battery_Percentage - dr.Start_Battery_Percentage)/100 * v.Battery_Capacity_Kwh + dr.Energy_Consumed_Kwh ) / (v.Weight_Kg * 9.81 * (dr.Elevation_Loss_M - dr.Elevation_Gain_M))) * 100 AS efficiency, v.Battery_Capacity_Kwh FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE (dr.Elevation_Loss_M - dr.Elevation_Gain_M) >= 500 AND dr.Start_Time BETWEEN '2023-10-01' AND '2023-10-31 23:59:59' ORDER BY efficiency ASC LIMIT 3;	new_energy_vehicles	1
WITH Stats AS (SELECT v.Manufacturer, STDDEV_POP(dr.Energy_Consumed_Kwh/dr.Distance_Km)/AVG(dr.Energy_Consumed_Kwh/dr.Distance_Km) AS cv, COUNT(*) AS cnt FROM driving_records dr JOIN vehicles v USING(Vehicle_Id) WHERE dr.Road_Type = 'Highway' AND dr.Distance_Km > 0 GROUP BY v.Manufacturer HAVING cv > 0.25 AND cnt >= 5) SELECT s.Manufacturer, MAX(cs.Charging_Speed_Kw) AS max_power, AVG(cs.Charging_Speed_Kw) AS avg_power FROM Stats s JOIN vehicles v USING(Manufacturer) JOIN charging_records cr USING(Vehicle_Id) JOIN charging_stations cs USING(Station_Id) GROUP BY s.Manufacturer;	new_energy_vehicles	2
SELECT v.Vehicle_Id, COUNT(DISTINCT CASE WHEN cr.Charging_Type IN ('Fast','Ultra-Fast') THEN cr.Record_Id END)*1.0 / COUNT(DISTINCT cr.Record_Id) AS fast_ratio, COUNT(DISTINCT CASE WHEN dr.Weather_Conditions = 'Rainy' THEN dr.Record_Id END) AS rainy_count FROM vehicles v LEFT JOIN charging_records cr USING(Vehicle_Id) LEFT JOIN driving_records dr USING(Vehicle_Id) GROUP BY v.Vehicle_Id HAVING fast_ratio > 0.5 AND rainy_count >= 1;	new_energy_vehicles	3
SELECT cs.Station_Id, POWER(500000/5, 3) AS power_factor, (2 * PI() * SQRT(POW((1.0003-1)*100000,2) + 2*100000*6371000)) / (300000000/(SELECT MAX(Charging_Speed_Kw)*1000 FROM charging_stations)) AS phase_jitter, CASE WHEN EXISTS(SELECT 1 FROM vehicles v JOIN charging_records cr USING(Vehicle_Id) WHERE v.Motor_Power_Kw > 500 AND cr.Station_Id = cs.Station_Id ) THEN 'Quantum' ELSE 'Classic' END AS qec_type FROM charging_stations cs WHERE EXISTS(SELECT 1 FROM charging_records WHERE Station_Id = cs.Station_Id AND Weather_Conditions = 'Magnetic_Storm' AND DAY(Start_Time) BETWEEN 20 AND 25 ) GROUP BY cs.Station_Id HAVING phase_jitter > PI()/2;	new_energy_vehicles	4
WITH ScreenArea AS ( SELECT phone_id, (screen_resolution_width / pixel_density_ppi) * (screen_resolution_height / pixel_density_ppi) AS screen_area_sq_inches FROM phones ) SELECT p.phone_id, sa.screen_area_sq_inches FROM phones p JOIN ScreenArea sa ON p.phone_id = sa.phone_id ORDER BY sa.screen_area_sq_inches DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7) / (p.weight_grams / 1000) AS energy_density_wh_per_kg FROM phones p ORDER BY energy_density_wh_per_kg DESC LIMIT 3;	phone	2
SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND thickness_mm < 8 ORDER BY battery_capacity_mAh DESC;	phone	3
SELECT phone_id, (battery_capacity_mAh * 3.7) / (0.5 * 1000) AS battery_life_hours FROM phones WHERE (battery_capacity_mAh * 3.7) / (0.5 * 1000) > 1000;	phone	4
WITH ScreenArea AS ( SELECT phone_id, (screen_size_inches * screen_resolution_width / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) * (screen_size_inches * screen_resolution_height / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) AS screen_area_sq_inches FROM phones ) SELECT sa.phone_id, sa.screen_area_sq_inches FROM ScreenArea sa ORDER BY sa.screen_area_sq_inches DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;	phone	2
SELECT AVG(battery_life_hours) AS average_battery_life FROM (SELECT battery_life_hours FROM hardware_specs ORDER BY battery_life_hours DESC LIMIT 5) AS top_5_battery_life;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3.6) > (1000000 * 3.7 * 3.6);	phone	4
WITH ScreenDimensions AS ( SELECT phone_id, screen_size_inches * (screen_resolution_width / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) AS screen_width_inches, screen_size_inches * (screen_resolution_height / SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2))) AS screen_height_inches FROM phones ) SELECT p.phone_id, p.screen_size_inches, sd.screen_width_inches * sd.screen_height_inches AS screen_area_square_inches FROM phones p JOIN ScreenDimensions sd ON p.phone_id = sd.phone_id ORDER BY screen_area_square_inches DESC LIMIT 5;	phone	1
SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, p.price_usd, pm.battery_life_video_playback_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.battery_capacity_mAh > 4000 AND p.price_usd < 500 ORDER BY pm.battery_life_video_playback_hours DESC LIMIT 10;	phone	3
WITH hypothetical_phone AS ( SELECT (100000 * 3.7) / (screen_size_inches * screen_resolution_width * screen_resolution_height * 0.1) AS hypothetical_battery_life FROM phones WHERE battery_capacity_mAh = 100000 ) SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id CROSS JOIN hypothetical_phone hp WHERE p.battery_capacity_mAh < 100000 AND pm.battery_life_video_playback_hours > hp.hypothetical_battery_life;	phone	4
SELECT p.phone_id AS model, (p.battery_capacity_mAh * 3.7 * 3.6) AS battery_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022 ORDER BY battery_energy_joules DESC LIMIT 1;	phone	1
SELECT p.phone_id, (p.price_usd / s.units_sold) * s.customer_satisfaction_score AS product_value FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 ORDER BY product_value DESC LIMIT 5;	phone	2
WITH AvgReturnRate AS (SELECT AVG(return_rate_percentage) AS avg_return_rate FROM sales_data WHERE sale_year = 2020) SELECT p.phone_id, p.phone_id AS model, sd.return_rate_percentage, sd.sale_year FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id CROSS JOIN AvgReturnRate arr WHERE sd.sale_year = 2020 AND sd.return_rate_percentage > arr.avg_return_rate ORDER BY sd.return_rate_percentage DESC;	phone	3
SELECT p.phone_id, (1000000 * 3.7 * 3.6) AS battery_energy_joules, ((1000000 / sd.units_sold) * sd.customer_satisfaction_score) AS unit_price_satisfaction_product FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id WHERE p.battery_capacity_mAh = 1000000 AND p.price_usd = 1000000 ORDER BY battery_energy_joules DESC;	phone	4
SELECT p.phone_id, np.download_speed_mbps, np.signal_strength_dbm FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id WHERE np.download_speed_mbps > 2000000 ORDER BY np.download_speed_mbps DESC LIMIT 5;	phone	1
SELECT p.phone_id, (p.battery_capacity_mAh / 1000 / hs.battery_life_hours) AS efficiency_ratio FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.release_year = 2022 ORDER BY efficiency_ratio DESC LIMIT 3;	phone	2
SELECT p.phone_id AS model, SUM(s.units_sold) AS total_units_sold FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2021 AND s.customer_satisfaction_score > 8 AND s.return_rate_percentage < 5 GROUP BY p.phone_id ORDER BY total_units_sold DESC;	phone	3
SELECT (1000000 * 1 / 8 / 1000) AS download_data_gb FROM network_performance WHERE signal_strength_dbm = -30;	phone	4
SELECT phone_id, weight_grams, battery_capacity_mAh, (battery_capacity_mAh / weight_grams) AS energy_density FROM phones ORDER BY energy_density ASC, weight_grams ASC LIMIT 1;	phone	1
SELECT phone_id, screen_size_inches, pixel_density_ppi, (PI() * POWER(screen_size_inches / 2, 2)) * pixel_density_ppi AS product FROM phones ORDER BY product DESC LIMIT 5;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.battery_capacity_mAh, (h.battery_life_hours / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY efficiency_ratio DESC, h.battery_life_hours DESC;	phone	3
SELECT p.phone_id, p.weight_grams * 1000 AS new_weight_grams, p.battery_capacity_mAh, (p.battery_capacity_mAh / (p.weight_grams * 1000)) AS energy_density FROM phones p ORDER BY energy_density ASC, new_weight_grams ASC LIMIT 1;	phone	4
WITH ScreenArea AS (SELECT phone_id, screen_size_inches, (screen_size_inches * COS(ATAN(9.0/16.0))) * (screen_size_inches * SIN(ATAN(9.0/16.0))) AS screen_area_sq_inches FROM phones WHERE screen_size_inches > 6) SELECT phone_id, screen_size_inches, screen_area_sq_inches FROM ScreenArea ORDER BY screen_area_sq_inches ASC LIMIT 5;	phone	1
SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 10;	phone	2
SELECT phone_id FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh ASC LIMIT 3;	phone	3
WITH HypotheticalScreen AS (SELECT 100 * COS(ATAN(9.0/16.0)) AS screen_width, 100 * SIN(ATAN(9.0/16.0)) AS screen_height), HypotheticalArea AS (SELECT screen_width * screen_height AS screen_area FROM HypotheticalScreen), PhoneScreenAreas AS (SELECT p.phone_id, p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_width, p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width)) AS screen_height, (p.screen_size_inches * COS(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) * (p.screen_size_inches * SIN(ATAN(p.screen_resolution_height * 1.0 / p.screen_resolution_width))) AS screen_area FROM phones p) SELECT p.phone_id, p.screen_area FROM PhoneScreenAreas p, HypotheticalArea h WHERE p.screen_area < h.screen_area ORDER BY p.screen_area DESC LIMIT 5;	phone	4
SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones WHERE screen_resolution_width > 1080 ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, h.battery_life_hours, (h.battery_life_hours / p.battery_capacity_mAh) AS efficiency_ratio FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh > 4000 ORDER BY efficiency_ratio ASC LIMIT 10;	phone	2
SELECT p.phone_id, p.screen_size_inches, p.price_usd, p.pixel_density_ppi FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500 ORDER BY p.screen_size_inches ASC; SELECT AVG(p.pixel_density_ppi) AS average_pixel_density FROM phones p WHERE p.screen_size_inches > 6 AND p.price_usd < 500;	phone	3
SELECT phone_id, screen_resolution_width, screen_resolution_height, screen_size_inches, pixel_density_ppi FROM phones WHERE pixel_density_ppi > 10000 ORDER BY pixel_density_ppi DESC;	phone	4
SELECT (battery_capacity_mAh * 3.7) / (5 * 1000) AS discharge_time_hours FROM phones WHERE battery_capacity_mAh = 5000;	phone	1
SELECT AVG(hs.battery_life_hours) AS average_battery_life_hours FROM (SELECT p.phone_id, p.battery_capacity_mAh FROM phones p WHERE p.release_year = 2022 ORDER BY p.battery_capacity_mAh DESC LIMIT 5) AS top_phones JOIN hardware_specs hs ON top_phones.phone_id = hs.phone_id ORDER BY average_battery_life_hours DESC;	phone	2
SELECT * FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches < 6 ORDER BY battery_capacity_mAh DESC;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh < 10000 AND hs.charging_speed_watts > 50;	phone	4
SELECT phone_id, (battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones ORDER BY battery_energy_joules DESC LIMIT 5;	phone	1
SELECT phone_id, (screen_resolution_width * screen_resolution_height) AS pixel_count FROM phones ORDER BY pixel_count DESC LIMIT 10;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, (p.battery_capacity_mAh * 3.7 * 3600) / 1000 AS battery_energy_joules FROM phones p WHERE (p.battery_capacity_mAh * 3.7 * 3600) / 1000 > (1000000 * 3.7 * 3600) / 1000;	phone	4
WITH PixelDensity AS (SELECT phone_id, screen_resolution_width, screen_resolution_height, screen_size_inches, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS PPI FROM phones) SELECT p.phone_id, p.screen_resolution_width, p.screen_resolution_height, p.screen_size_inches, pd.PPI, (25.4 / pd.PPI) * 1000 AS pixel_size_micrometers FROM phones p JOIN PixelDensity pd ON p.phone_id = pd.phone_id ORDER BY pd.PPI DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, (p.battery_capacity_mAh / hs.battery_life_hours) AS hourly_consumption_mAh_per_hour FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY (p.battery_capacity_mAh / hs.battery_life_hours) DESC LIMIT 10;	phone	2
SELECT * FROM phones WHERE screen_size_inches > 6 AND weight_grams < 150 ORDER BY screen_size_inches ASC;	phone	3
SELECT (25.4 / pixel_density_ppi) * 1000000 AS pixel_size_nm FROM phones WHERE pixel_density_ppi = 10000 AND screen_size_inches = 10;	phone	4
SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC LIMIT 5;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 AS battery_energy_joules FROM phones p ORDER BY battery_energy_joules DESC LIMIT 5;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY hs.battery_life_hours DESC;	phone	3
WITH AdjustedScores AS (SELECT p.phone_id, (100 / hs.cpu_clock_speed_ghz) * pm.geekbench_multi_core_score AS adjusted_geekbench_multi_core_score FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id JOIN performance_metrics pm ON p.phone_id = pm.phone_id) SELECT phone_id, adjusted_geekbench_multi_core_score FROM AdjustedScores ORDER BY adjusted_geekbench_multi_core_score DESC LIMIT 5;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh, h.cpu_clock_speed_ghz, h.ram_gb, (h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) AS total_power_watts, (p.battery_capacity_mAh / ((h.cpu_clock_speed_ghz * 2.5 + h.ram_gb * 0.5) * 1000 / 3.7)) AS battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.cpu_clock_speed_ghz = 2.5 AND h.ram_gb = 8 AND p.battery_capacity_mAh = 4000;	phone	1
SELECT ((storage_read_speed_mbps + storage_write_speed_mbps) * 3600 / 1024) AS max_data_volume_gb FROM hardware_specs WHERE ram_gb = 12 AND storage_read_speed_mbps = 500 AND storage_write_speed_mbps = 300;	phone	2
SELECT (5000 / ((6.5 * 1080 * 2340 * 0.000001) * 1000 / 3.7)) AS battery_life_hours FROM phones WHERE screen_size_inches = 6.5 AND screen_resolution_width = 1080 AND screen_resolution_height = 2340 AND battery_capacity_mAh = 5000;	phone	3
WITH max_data AS (SELECT (storage_read_speed_mbps / 1000 + storage_write_speed_mbps / 1000) * 1 AS max_data_processed_tb FROM hardware_specs WHERE ram_gb = 1024) SELECT max_data_processed_tb, (battery_capacity_mAh / (cpu_clock_speed_ghz * 10 + ram_gb * 0.1 + storage_gb * 0.05) * 1000 / 3.7) AS battery_life_hours FROM max_data, hardware_specs JOIN phones ON hardware_specs.phone_id = phones.phone_id WHERE hardware_specs.ram_gb = 1024;	phone	4
SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id ORDER BY charging_time_hours ASC LIMIT 5;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;	phone	2
SELECT phone_id, battery_capacity_mAh, price_usd FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh DESC LIMIT 10;	phone	3
SELECT p.phone_id, (p.battery_capacity_mAh * 3.7) / (hs.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh = 100000 AND hs.charging_speed_watts = 1000;	phone	4
SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_WhL FROM phones WHERE battery_capacity_mAh > 4000 AND screen_size_inches > 6 ORDER BY energy_density_WhL DESC LIMIT 5;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels FROM phones ORDER BY total_pixels DESC LIMIT 3;	phone	2
SELECT p.phone_id, h.battery_life_hours, p.price_usd FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE h.battery_life_hours > 24 AND p.price_usd < 500 ORDER BY h.battery_life_hours DESC LIMIT 10;	phone	3
WITH phone_energy_density AS (SELECT phone_id, (battery_capacity_mAh * 3.7) / (thickness_mm * width_mm * height_mm * 0.001) AS energy_density_wh_per_l FROM phones), average_energy_density AS (SELECT AVG(energy_density_wh_per_l) AS avg_energy_density FROM phone_energy_density) SELECT CASE WHEN (100000 * 3.7) / (100 * 200 * 300 * 0.001) > (SELECT avg_energy_density FROM average_energy_density) * 10 THEN 'Yes' ELSE 'No' END AS is_10x_higher FROM dual;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh, pm.battery_life_video_playback_hours, (p.battery_capacity_mAh * 3.7 * 3.6) / (pm.battery_life_video_playback_hours * 3600) AS average_power_consumption_watts FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;	phone	1
SELECT phone_id, (battery_capacity_mAh / weight_grams) AS battery_density_mAh_g FROM phones ORDER BY battery_density_mAh_g ASC LIMIT 5;	phone	2
SELECT p.phone_id, pm.battery_life_video_playback_hours, p.price_usd FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE pm.battery_life_video_playback_hours > 20 AND p.price_usd < 500 ORDER BY pm.battery_life_video_playback_hours DESC;	phone	3
SELECT (1000000 * 3.7 * 3.6) / (1000 * 3600) AS average_power_consumption_watts FROM phones WHERE battery_capacity_mAh = 1000000 AND EXISTS (SELECT 1 FROM performance_metrics WHERE performance_metrics.phone_id = phones.phone_id AND battery_life_video_playback_hours = 1000);	phone	4
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / pm.gfxbench_fps AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = '1';	phone	1
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 * 3.6 / (pm.gfxbench_fps * pm.gfxbench_fps) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id WHERE p.phone_id = 'specific_phone_id';	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000 / 5)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
SELECT p.battery_capacity_mAh / (h.charging_speed_watts * 1000) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.battery_capacity_mAh = 100000;	phone	4
SELECT (2 * (500 / 250)) AS max_power_consumption_watts FROM phones WHERE phone_id = '1';	phone	1
SELECT (battery_capacity_mAh * 3.7) / 1000 AS total_energy_Wh, ((battery_capacity_mAh * 3.7) / 1000) / 10 AS avg_power_consumption_W FROM phones WHERE phone_id = '1';	phone	2
SELECT phone_id, battery_capacity_mAh FROM phones WHERE battery_capacity_mAh > 4000 AND price_usd < 500 ORDER BY battery_capacity_mAh ASC;	phone	3
SELECT pm.phone_id, (pm.thermal_throttling_percentage - 100) AS performance_loss_percentage FROM performance_metrics pm WHERE pm.thermal_throttling_percentage > 150;	phone	4
SELECT (MAX(p.battery_capacity_mAh) / 1000) * 3.7 * 3600 AS total_energy_joules FROM phones p JOIN sales_data s ON p.phone_id = s.phone_id WHERE s.sale_year = 2022;	phone	1
WITH yearly_revenue AS (SELECT p.phone_id, sd.sale_year, SUM(sd.revenue_usd) AS total_revenue FROM phones p JOIN sales_data sd ON p.phone_id = sd.phone_id WHERE sd.sale_year IN (2021, 2022) GROUP BY p.phone_id, sd.sale_year), max_revenue_per_year AS (SELECT sale_year, MAX(total_revenue) AS max_revenue FROM yearly_revenue GROUP BY sale_year), top_phones AS (SELECT yr.phone_id, yr.sale_year, yr.total_revenue FROM yearly_revenue yr JOIN max_revenue_per_year mrpy ON yr.sale_year = mrpy.sale_year AND yr.total_revenue = mrpy.max_revenue) SELECT tp2021.phone_id AS top_phone_2021, tp2021.total_revenue AS revenue_2021, tp2022.phone_id AS top_phone_2022, tp2022.total_revenue AS revenue_2022, ((tp2022.total_revenue - tp2021.total_revenue) / tp2021.total_revenue) * 100 AS growth_rate_percentage FROM top_phones tp2021 JOIN top_phones tp2022 ON tp2021.sale_year = 2021 AND tp2022.sale_year = 2022;	phone	2
WITH top_selling_phone_2022 AS (SELECT sd.phone_id, SUM(sd.units_sold) AS total_units_sold FROM sales_data sd WHERE sd.sale_year = 2022 GROUP BY sd.phone_id ORDER BY total_units_sold DESC LIMIT 1) SELECT p.phone_id, hs.battery_life_hours, AVG(sd.customer_satisfaction_score) AS avg_customer_satisfaction_score FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id JOIN sales_data sd ON p.phone_id = sd.phone_id JOIN top_selling_phone_2022 tsp ON p.phone_id = tsp.phone_id GROUP BY p.phone_id, hs.battery_life_hours;	phone	3
SELECT (battery_capacity_mAh / 1000) * 3.7 / 5 AS video_playback_hours FROM phones WHERE battery_capacity_mAh = 100000;	phone	4
SELECT (10 * 1024) / (download_speed_mbps * 8) AS download_time_seconds FROM network_performance WHERE phone_id =2;	phone	1
SELECT n.phone_id, ((n.download_speed_mbps + n.upload_speed_mbps) * 3600 * 24 * 365 / 8 / 1024) AS total_data_gb FROM network_performance n;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, np.download_speed_mbps, (p.battery_capacity_mAh * 3.7) / (np.download_speed_mbps * 0.1) AS battery_life_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;	phone	3
SELECT (1000000 * 3600 * 24 * 365 / 8 / 1024 / 1024 / 1024) AS total_download_data_eb FROM dual;	phone	4
SELECT phone_id, screen_size_inches, screen_resolution_width, screen_resolution_height, pixel_density_ppi, (POWER(screen_size_inches, 2) / (1 + POWER(screen_resolution_height / screen_resolution_width, 2)) * (screen_resolution_width / screen_resolution_height)) AS screen_area_square_inches, (25.4 / pixel_density_ppi) AS pixel_width_mm, (25.4 / pixel_density_ppi) AS pixel_height_mm FROM phones;	phone	1
SELECT p.phone_id, p.battery_capacity_mAh, hs.battery_life_hours, hs.charging_speed_watts, (p.battery_capacity_mAh * 3.7 * 3600 / 1000) AS battery_energy_joules, ((p.battery_capacity_mAh * 3.7 * 3600 / 1000) / (hs.battery_life_hours * 3600)) AS average_power_consumption_watts, ((p.battery_capacity_mAh / (hs.charging_speed_watts * 1000 / 3.7)) * 100) AS charging_efficiency_percentage FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id;	phone	2
SELECT phone_id, weight_grams, width_mm, thickness_mm, CASE WHEN weight_grams < 200 AND width_mm < 75 AND thickness_mm < 10 THEN '适合' ELSE '不适合' END AS 单手操作适合性 FROM phones;	phone	3
SELECT phones.phone_id, battery_capacity_mAh, charging_speed_watts, (battery_capacity_mAh * 3.7) / (charging_speed_watts * 1000) AS charge_time_hours, IF(battery_life_hours > 100 * 365 * 24, '是', '否') AS is_permanent_device FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 1000000 AND charging_speed_watts = 100;	phone	4
WITH PixelDensity AS (SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS ppi FROM phones) SELECT phone_id, ppi FROM PixelDensity WHERE ppi = (SELECT MAX(ppi) FROM PixelDensity);	phone	1
SELECT p.phone_id, (h.storage_read_speed_mbps + h.storage_write_speed_mbps) AS total_storage_bandwidth_mbps FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY total_storage_bandwidth_mbps DESC LIMIT 1;	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id ORDER BY p.battery_capacity_mAh DESC, h.charging_speed_watts DESC LIMIT 1;	phone	3
SELECT p.phone_id, p.battery_capacity_mAh, hs.charging_speed_watts, (p.battery_capacity_mAh / hs.charging_speed_watts) AS charging_time_hours FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id WHERE p.battery_capacity_mAh > 100000 AND hs.charging_speed_watts > 1000;	phone	4
SELECT (p.battery_capacity_mAh * 3.7) / (4 * 1000) AS battery_life_hours FROM phones p WHERE p.phone_id = 1;	phone	1
SELECT p.phone_id, (h.cpu_clock_speed_ghz * 2.5 + h.gpu_cores * 1.2 + (p.screen_size_inches * 0.1) + 0.5) * h.battery_life_hours AS total_energy_consumption_wh FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id WHERE p.phone_id = 'specific_phone_id';	phone	2
SELECT p.phone_id, p.battery_capacity_mAh, h.charging_speed_watts, (p.battery_capacity_mAh / (h.charging_speed_watts * 1000)) AS charging_time_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
SELECT (battery_capacity_mAh / (charging_speed_watts * 1000)) AS charging_time_hours FROM phones JOIN hardware_specs ON phones.phone_id = hardware_specs.phone_id WHERE battery_capacity_mAh = 100000 AND charging_speed_watts = 1000;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh / (pm.battery_life_video_playback_hours * 1000) AS theoretical_battery_life_hours FROM phones p JOIN performance_metrics pm ON p.phone_id = pm.phone_id;	phone	1
WITH MonthlySales AS (SELECT phone_id, sale_year, sale_month, SUM(units_sold) AS total_units_sold FROM sales_data WHERE phone_id = '1' AND sale_year = '2022' GROUP BY phone_id, sale_year, sale_month), GrowthRates AS (SELECT ms1.phone_id, ms1.sale_year, ms1.sale_month, ms1.total_units_sold AS current_month_sales, ms2.total_units_sold AS previous_month_sales, ((ms1.total_units_sold - ms2.total_units_sold) / ms2.total_units_sold) * 100 AS growth_rate FROM MonthlySales ms1 LEFT JOIN MonthlySales ms2 ON ms1.phone_id = ms2.phone_id AND ms1.sale_year = ms2.sale_year AND ms1.sale_month = ms2.sale_month + 1) SELECT sale_month, growth_rate FROM GrowthRates WHERE growth_rate IS NOT NULL ORDER BY growth_rate DESC LIMIT 1;	phone	2
SELECT phone_id, SQRT(POWER(screen_resolution_width, 2) + POWER(screen_resolution_height, 2)) / screen_size_inches AS pixel_density_ppi FROM phones;	phone	3
SELECT 100000 / (10000 / 1000) AS battery_life_hours;	phone	4
SELECT p.phone_id, p.battery_capacity_mAh * 3.7 / 1000 AS battery_energy_Wh, np.download_speed_mbps * 0.1 AS download_power_W, (p.battery_capacity_mAh * 3.7 / 1000) / (np.download_speed_mbps * 0.1) AS discharge_time_hours FROM phones p JOIN network_performance np ON p.phone_id = np.phone_id;	phone	1
SELECT phone_id, screen_resolution_width * screen_resolution_height AS total_pixels, (screen_resolution_width * screen_resolution_height) / (screen_size_inches * screen_size_inches) AS pixel_density_ppi FROM phones ORDER BY pixel_density_ppi DESC;	phone	2
SELECT p.phone_id, p.screen_size_inches, h.cpu_clock_speed_ghz, p.battery_capacity_mAh, h.battery_life_hours, (p.battery_capacity_mAh / (p.screen_size_inches * h.cpu_clock_speed_ghz * 0.1)) AS calculated_battery_life_hours FROM phones p JOIN hardware_specs h ON p.phone_id = h.phone_id;	phone	3
WITH phone_data AS (SELECT p.phone_id, p.battery_capacity_mAh, np.download_speed_mbps, hs.battery_life_hours, hs.charging_speed_watts FROM phones p JOIN hardware_specs hs ON p.phone_id = hs.phone_id JOIN network_performance np ON p.phone_id = np.phone_id WHERE np.download_speed_mbps = 1000) SELECT phone_id, (download_speed_mbps * 30 * 24 * 60 * 60) / (8 * 1024 * 1024) AS total_data_tb, (charging_speed_watts * 30 * 24) / (battery_capacity_mAh * 3.7 / 1000) * 100 AS battery_loss_percentage FROM phone_data;	phone	4
SELECT r.researcherName, COUNT(e.experimentId) AS experimentCount FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '光谱仪' GROUP BY r.researcherId ORDER BY experimentCount DESC LIMIT 5;	PhysicsLabDB	1
WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount ORDER BY equipmentCount DESC;	PhysicsLabDB	2
SELECT researcherName, joinDate FROM Researchers WHERE YEAR(joinDate) = 2023 ORDER BY joinDate ASC LIMIT 10;	PhysicsLabDB	3
SELECT SUM(capacity) + (COUNT(labId) * 1000) AS new_total_capacity FROM Labs;	PhysicsLabDB	4
SELECT labName, equipmentCount, (equipmentCount * 500) AS totalPower FROM Labs WHERE equipmentCount = (SELECT MAX(equipmentCount) FROM Labs);	PhysicsLabDB	1
WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData ORDER BY measurementValue DESC LIMIT 10) SELECT AVG(measurementValue) AS average_value, VARIANCE(measurementValue) AS variance_value, STDDEV(measurementValue) AS stddev_value FROM TopMeasurements;	PhysicsLabDB	2
SELECT L.labName, L.location, E.experimentName FROM Labs L JOIN Experiments E ON L.labId = E.labId WHERE L.capacity > 100 AND E.status = '进行中';	PhysicsLabDB	3
SELECT e.experimentId, e.experimentName, AVG(ed.measurementValue) AS averageMeasurementValue FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.status = '进行中' GROUP BY e.experimentId, e.experimentName ORDER BY averageMeasurementValue ASC;	PhysicsLabDB	1
SELECT result FROM Calculations WHERE experimentId IN (SELECT experimentId FROM Experiments WHERE status = '已完成') ORDER BY result DESC LIMIT 5;	PhysicsLabDB	2
SELECT labId, labName, capacity, equipmentCount, (equipmentCount / capacity) AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC;	PhysicsLabDB	3
WITH ExaggeratedMeasurements AS (SELECT experimentId, AVG(measurementValue * 1000) AS exaggeratedAvg FROM ExperimentData GROUP BY experimentId ORDER BY exaggeratedAvg ASC) SELECT * FROM ExaggeratedMeasurements WHERE exaggeratedAvg NOT IN (SELECT exaggeratedAvg FROM ExaggeratedMeasurements);	PhysicsLabDB	4
SELECT deviceId, deviceName, calibrationDate, DATEDIFF(CURDATE(), calibrationDate) AS calibrationIntervalDays FROM Devices ORDER BY calibrationIntervalDays ASC LIMIT 5;	PhysicsLabDB	1
SELECT labId, labName, equipmentCount / capacity AS densityRatio FROM Labs ORDER BY densityRatio DESC LIMIT 3;	PhysicsLabDB	2
SELECT deviceType, COUNT(*) AS faultCount FROM Devices WHERE status = '故障' GROUP BY deviceType;	PhysicsLabDB	3
SELECT deviceId, deviceName, calibrationDate, DATE_ADD(calibrationDate, INTERVAL 100 YEAR) AS extendedCalibrationDate FROM Devices ORDER BY extendedCalibrationDate DESC LIMIT 10;	PhysicsLabDB	4
WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') ORDER BY measurementValue DESC LIMIT 5) SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM TopMeasurements;	PhysicsLabDB	1
WITH LogTransformedData AS (SELECT LOG10(measurementValue) AS logValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '示波器') AND unit = 'V') SELECT AVG(logValue) AS logAverage, SQRT(AVG(logValue * logValue) - AVG(logValue) * AVG(logValue)) AS logStandardDeviation FROM LogTransformedData;	PhysicsLabDB	2
SELECT AVG(measurementValue) AS mean, SQRT(AVG(POW(measurementValue - (SELECT AVG(measurementValue) FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '温度计')), 2))) AS stddev FROM ExperimentData WHERE unit = '℃' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '温度计');	PhysicsLabDB	3
SELECT AVG(measurementValue) AS average_value, STDDEV(measurementValue) AS standard_deviation FROM ExperimentData WHERE measurementValue > 1000000 AND unit = 'lm' AND deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪');	PhysicsLabDB	4
SELECT (3 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') AND measurementValue = 500 AND unit = '纳米';	PhysicsLabDB	1
WITH RECURSIVE VariableCalculation AS (SELECT variableId, variableName, initialValue AS currentValue, unit, dataQuality FROM Variables WHERE experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = '某个实验') UNION ALL SELECT v.variableId, v.variableName, CASE WHEN v.variableName = 'A' THEN SQRT(vc.currentValue) WHEN v.variableName = 'B' THEN 2 * vc.currentValue END AS currentValue, v.unit, v.dataQuality FROM Variables v JOIN VariableCalculation vc ON v.experimentId = (SELECT experimentId FROM Experiments WHERE experimentName = '某个实验') WHERE (v.variableName = 'A' AND vc.variableName = 'B') OR (v.variableName = 'B' AND vc.variableName = 'A')) SELECT * FROM VariableCalculation;	PhysicsLabDB	2
SELECT deviceId, deviceName, deviceType, calibrationDate, status, labId FROM Devices WHERE calibrationDate < DATE_SUB(CURDATE(), INTERVAL 1 YEAR) ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT * FROM Calculations WHERE result > 1e300 ORDER BY result DESC;	PhysicsLabDB	4
WITH SpectralData AS (SELECT ed.dataId, ed.experimentId, ed.deviceId, ed.timestamp, ed.measurementValue AS lightIntensity, ed.unit, ed.dataQuality, ed.environmentalConditions FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '光谱仪' AND ed.experimentId = '特定实验ID'), EnergyCalculations AS (SELECT sd.dataId, sd.experimentId, sd.deviceId, sd.timestamp, sd.lightIntensity, sd.unit, sd.dataQuality, sd.environmentalConditions, (6.62607015e-34 * 299792458 / sd.lightIntensity) AS energy FROM SpectralData sd) SELECT ec.dataId, ec.experimentId, ec.deviceId, ec.timestamp, ec.lightIntensity, ec.energy, ec.unit, ec.dataQuality, ec.environmentalConditions FROM EnergyCalculations ec ORDER BY ec.energy ASC LIMIT 10;	PhysicsLabDB	1
SELECT e.experimentId, e.experimentName, AVG(sa.sensitivityValue) AS avgSensitivityValue FROM Experiments e JOIN SensitivityAnalysis sa ON e.experimentId = sa.experimentId WHERE sa.impact = '高' GROUP BY e.experimentId, e.experimentName;	PhysicsLabDB	2
SELECT d.deviceType, COUNT(ed.deviceId) AS usageCount FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId JOIN Experiments e ON ed.experimentId = e.experimentId WHERE e.status = '已完成' GROUP BY d.deviceType ORDER BY usageCount DESC;	PhysicsLabDB	3
SELECT labId, labName, (10000 / equipmentCount) AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS average_wavelength FROM (SELECT measurementValue FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') AND unit = '纳米' ORDER BY measurementValue DESC LIMIT 5) AS top_measurements;	PhysicsLabDB	1
SELECT * FROM Calculations WHERE result > 1000 ORDER BY result DESC LIMIT 10;	PhysicsLabDB	2
SELECT labId, labName, location, capacity, equipmentCount, status FROM Labs WHERE capacity > 50 ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 10000 ORDER BY initialValue DESC LIMIT 5;	PhysicsLabDB	4
SELECT deviceId, AVG(measurementValue) AS averageMeasurementValue FROM ExperimentData GROUP BY deviceId ORDER BY averageMeasurementValue ASC;	PhysicsLabDB	1
WITH TopMeasurements AS (SELECT measurementValue FROM ExperimentData ORDER BY measurementValue DESC LIMIT 5) SELECT AVG(measurementValue) AS average_value, SQRT(AVG(measurementValue * measurementValue) - AVG(measurementValue) * AVG(measurementValue)) AS standard_deviation FROM TopMeasurements;	PhysicsLabDB	2
SELECT deviceType, GROUP_CONCAT(deviceName SEPARATOR ', ') AS deviceNames, GROUP_CONCAT(calibrationDate SEPARATOR ', ') AS calibrationDates FROM Devices WHERE DATEDIFF(CURDATE(), calibrationDate) > 365 GROUP BY deviceType;	PhysicsLabDB	3
SELECT h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult FROM Hypotheses h JOIN ExperimentData ed ON h.experimentId = ed.experimentId WHERE h.verificationResult = '假' AND ed.measurementValue > (SELECT initialValue FROM Variables WHERE experimentId = h.experimentId AND variableName = '正常值') * 100 GROUP BY h.experimentId, h.hypothesisId, h.hypothesisText, h.verificationResult;	PhysicsLabDB	4
SELECT e.experimentId, AVG(ed.measurementValue) AS average_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '光谱仪' GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	1
WITH OscilloscopeExperiments AS (SELECT ed.experimentId, ed.measurementValue FROM ExperimentData ed JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType = '示波器'), ExperimentStats AS (SELECT experimentId, AVG(measurementValue) AS avg_value, COUNT(measurementValue) AS count_value FROM OscilloscopeExperiments GROUP BY experimentId) SELECT oe.experimentId, SQRT(SUM(POWER(oe.measurementValue - es.avg_value, 2)) / es.count_value) AS std_deviation FROM OscilloscopeExperiments oe JOIN ExperimentStats es ON oe.experimentId = es.experimentId GROUP BY oe.experimentId ORDER BY oe.experimentId ASC;	PhysicsLabDB	2
SELECT e.experimentId, SUM(ed.measurementValue) AS total_measurement_value FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE d.deviceType NOT IN ('光谱仪', '示波器') GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	3
SELECT e.experimentId, MAX(ed.measurementValue) AS max_measurement_value FROM Experiments e JOIN Labs l ON e.labId = l.labId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE l.equipmentCount > 1000 GROUP BY e.experimentId ORDER BY e.experimentId ASC;	PhysicsLabDB	4
SELECT L.labId, L.labName, L.location, L.capacity, COUNT(R.researcherId) AS currentResearchers, (L.capacity >= COUNT(R.researcherId)) AS isCapacitySufficient FROM Labs L JOIN Experiments E ON L.labId = E.labId JOIN Researchers R ON E.researcherId = R.researcherId WHERE E.status = '进行中' GROUP BY L.labId, L.labName, L.location, L.capacity;	PhysicsLabDB	1
SELECT labId, labName, equipmentCount / capacity AS equipmentDensity FROM Labs ORDER BY equipmentDensity DESC LIMIT 1;	PhysicsLabDB	2
SELECT AVG(DATEDIFF(CURDATE(), e.startDate)) AS averageVerificationTime FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId WHERE h.status = '未验证';	PhysicsLabDB	3
SELECT labId, labName, (capacity / 0.1) AS maxResearchers FROM Labs;	PhysicsLabDB	4
SELECT SUM(POWER(equipmentCount, 2) * 10) AS total_power_consumption FROM Labs;	PhysicsLabDB	1
WITH ExperimentDurations AS (SELECT experimentId, experimentName, (endDate - startDate) AS duration FROM Experiments WHERE status = '已完成') SELECT AVG(duration) AS average_duration, MAX(duration) AS max_duration FROM ExperimentDurations;	PhysicsLabDB	2
SELECT      (COUNT(CASE WHEN status = '故障' THEN 1 END) * 100.0 / COUNT(*)) AS fault_percentage FROM Devices;	PhysicsLabDB	3
SELECT 10000 / 1000 AS lab_density;	PhysicsLabDB	4
SELECT e.experimentName AS 实验名称, e.startDate AS 实验开始时间, e.endDate AS 实验结束时间, AVG(ed.measurementValue) AS 平均重力加速度 FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = '测量重力加速度' GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	1
SELECT e.experimentName, e.startDate, e.endDate, AVG(ed1.measurementValue / ed2.measurementValue) AS averageResistance FROM Experiments e JOIN ExperimentData ed1 ON e.experimentId = ed1.experimentId AND ed1.unit = 'V' JOIN ExperimentData ed2 ON e.experimentId = ed2.experimentId AND ed2.unit = 'A' AND ed1.timestamp = ed2.timestamp GROUP BY e.experimentId, e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	2
SELECT e.experimentName, e.startDate, e.endDate, MAX(ed.measurementValue) AS maxTemperature, MIN(ed.measurementValue) AS minTemperature FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = 'Celsius' OR ed.unit = 'Fahrenheit' GROUP BY e.experimentId;	PhysicsLabDB	3
SELECT e.experimentName, e.startDate, e.endDate, AVG(ed.measurementValue) AS averageSpeed FROM Experiments e JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE e.experimentName = '测量光速实验' AND ed.measurementValue > 1000000000 GROUP BY e.experimentName, e.startDate, e.endDate;	PhysicsLabDB	4
SELECT SUM(500 * 8) AS total_energy_consumption_kWh FROM Devices WHERE deviceType = '光谱仪';	PhysicsLabDB	1
SELECT AVG(DATEDIFF('2023-10-01', calibrationDate)) AS average_calibration_interval FROM Devices;	PhysicsLabDB	2
SELECT deviceName, calibrationDate FROM Devices WHERE status = '故障';	PhysicsLabDB	3
WITH DevicePower AS (SELECT deviceId, deviceName, CASE WHEN deviceType = '示波器' THEN 500 WHEN deviceType = '光谱仪' THEN 700 ELSE 300 END AS basePower FROM Devices WHERE labId = (SELECT labId FROM Labs WHERE labName = '目标实验室名称')), MaxPower AS (SELECT deviceId, deviceName, basePower * 1000 AS maxPower FROM DevicePower), TotalEnergy AS (SELECT SUM(maxPower * 24) AS totalEnergy FROM MaxPower) SELECT CASE WHEN totalEnergy > 1000 THEN '超过电网承载能力' ELSE '未超过电网承载能力' END AS result FROM TotalEnergy;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS averageLightIntensity FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '光谱仪') AND unit = 'Lux';	PhysicsLabDB	1
WITH HighTempData AS (SELECT measurementValue FROM ExperimentData WHERE environmentalConditions = '高温' AND unit = '°C'), AverageValue AS (SELECT AVG(measurementValue) AS avgValue FROM HighTempData) SELECT SQRT(SUM(POWER(measurementValue - avgValue, 2)) / COUNT(*)) AS standardDeviation FROM HighTempData, AverageValue;	PhysicsLabDB	2
SELECT SUM(measurementValue) AS totalCurrent FROM ExperimentData WHERE dataQuality = '高' AND unit = 'A';	PhysicsLabDB	3
SELECT SUM(measurementValue * 1000) * 1000 AS totalVoltage FROM ExperimentData WHERE unit = 'V';	PhysicsLabDB	4
SELECT experimentId, experimentName, (3.00 * POWER(10, 8)) / (5.00 * POWER(10, 14)) AS wavelength, 'm' AS unit FROM Experiments WHERE experimentName = '光谱仪测量实验';	PhysicsLabDB	1
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES ((SELECT experimentId FROM Experiments WHERE experimentName = '复杂电路实验'), '1/Req = 1/R1 + 1/R2 + 1/R3 + 1/R4 + 1/R5', 'R1=10Ω, R2=20Ω, R3=30Ω, R4=40Ω, R5=50Ω', 1 / (1/10 + 1/20 + 1/30 + 1/40 + 1/50), 'Ω', '高');	PhysicsLabDB	2
WITH DevicePower AS (SELECT 10 * 500 AS total_power), DailyEnergy AS (SELECT total_power * 8 / 1000 AS daily_energy FROM DevicePower), MonthlyCost AS (SELECT daily_energy * 30 * 0.5 AS monthly_cost FROM DailyEnergy) SELECT monthly_cost FROM MonthlyCost;	PhysicsLabDB	3
WITH DevicePower AS (SELECT SUM(10000) AS total_power FROM Devices WHERE labId = (SELECT labId FROM Labs WHERE labName = '超大型实验室')), DailyEnergy AS (SELECT total_power * 24 AS daily_energy FROM DevicePower), AnnualCost AS (SELECT daily_energy * 365 * 0.1 AS annual_cost FROM DailyEnergy) SELECT annual_cost FROM AnnualCost;	PhysicsLabDB	4
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) SELECT experimentId, 'P = V * I', CONCAT('V=', measurementValue, ', I=2'), measurementValue * 2, 'Watt', '高' FROM ExperimentData WHERE unit = 'V' AND environmentalConditions = '25°C';	PhysicsLabDB	1
INSERT INTO Calculations (experimentId, formula, inputData, result, unit, dataQuality) VALUES (1, 'F = m * a', 'm=5kg, a=9.8m/s²', 49, 'N', '高');	PhysicsLabDB	2
SELECT equipmentCount / capacity AS avg_equipment_per_researcher FROM Labs WHERE capacity = 50 AND equipmentCount = 100;	PhysicsLabDB	3
SELECT hypothesisId, hypothesisText, verificationResult, verificationDate, CASE WHEN DATE_ADD(verificationDate, INTERVAL 10000 YEAR) > NOW() THEN '有效' ELSE '无效' END AS validity FROM Hypotheses WHERE verificationResult = '真' AND verificationDate = '2023-10-01';	PhysicsLabDB	4
SELECT AVG(measurementValue) AS averageVoltage, experimentId FROM ExperimentData WHERE unit = 'V' GROUP BY experimentId HAVING MAX(measurementValue) > 10000;	PhysicsLabDB	1
SELECT SUM(initialValue) AS totalInitialValue, variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 1000;	PhysicsLabDB	2
SELECT labId, labName, equipmentCount / capacity AS equipmentPerPerson FROM Labs WHERE equipmentCount / capacity < 2;	PhysicsLabDB	3
SELECT SUM(initialValue) AS totalInitialValue, variableId, variableName, initialValue, unit FROM Variables WHERE initialValue > 1000 GROUP BY variableId, variableName, initialValue, unit;	PhysicsLabDB	4
WITH EnvironmentalCoefficients AS (SELECT 0.01 AS temperature_coefficient, 0.005 AS humidity_coefficient), StandardConditions AS (SELECT 20 AS standard_temperature, 40 AS standard_humidity), ExperimentData AS (SELECT measurementValue, environmentalConditions FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5 AND environmentalConditions LIKE '%25°C%' AND environmentalConditions LIKE '%50%') SELECT measurementValue * ((SELECT temperature_coefficient FROM EnvironmentalCoefficients) * (25 - (SELECT standard_temperature FROM StandardConditions)) + (SELECT humidity_coefficient FROM EnvironmentalCoefficients) * (50 - (SELECT standard_humidity FROM StandardConditions))) AS error_range FROM ExperimentData;	PhysicsLabDB	1
SELECT SUM(s.sensitivityValue * v.initialValue) AS totalImpact FROM SensitivityAnalysis s JOIN Variables v ON s.variableId = v.variableId WHERE v.variableName IN ('A', 'B', 'C');	PhysicsLabDB	2
SELECT deviceId, deviceName, calibrationDate, CASE WHEN DATE_ADD(calibrationDate, INTERVAL 1 YEAR) < '2023-05-01' THEN '需要重新校准' ELSE '不需要重新校准' END AS recalibrationStatus FROM Devices WHERE calibrationDate = '2022-01-01';	PhysicsLabDB	3
SELECT 10000 / 10 AS max_equipment_capacity;	PhysicsLabDB	4
SELECT AVG(measurementValue) AS average_voltage FROM ExperimentData WHERE environmentalConditions = 'temperature:25°C, humidity:60%' AND unit = 'V';	PhysicsLabDB	1
WITH TemperatureData AS (SELECT measurementValue FROM ExperimentData WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31' AND unit = 'Celsius') SELECT SQRT(AVG(POWER(measurementValue - (SELECT AVG(measurementValue) FROM TemperatureData), 2))) AS standard_deviation FROM TemperatureData;	PhysicsLabDB	2
SELECT MAX(measurementValue) AS max_humidity FROM ExperimentData WHERE timestamp BETWEEN '2023-01-01' AND '2023-01-31' AND unit = '%';	PhysicsLabDB	3
SELECT AVG(measurementValue) AS average_pressure FROM ExperimentData WHERE environmentalConditions LIKE '%temperature=1000°C%' AND environmentalConditions LIKE '%humidity=100%' AND unit = 'Pa';	PhysicsLabDB	4
SELECT r.researcherName, e.experimentName FROM Researchers r JOIN Experiments e ON r.researcherId = e.researcherId JOIN ExperimentData ed ON e.experimentId = ed.experimentId WHERE ed.unit = '伏特(V)' AND e.startDate > '2022-01-01' ORDER BY r.researcherName ASC;	PhysicsLabDB	1
SELECT labId, labName, equipmentCount / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 5;	PhysicsLabDB	2
SELECT e.experimentId, e.experimentName, e.startDate, e.endDate, e.status, h.verificationResult FROM Experiments e JOIN Hypotheses h ON e.experimentId = h.experimentId WHERE e.status = '已完成' AND h.verificationResult = '真' AND e.endDate <= '2021-12-31' ORDER BY e.experimentName ASC;	PhysicsLabDB	3
SELECT labId, labName, equipmentCount / capacity AS ratio FROM Labs ORDER BY ratio DESC LIMIT 10;	PhysicsLabDB	4
SELECT labName, equipmentCount FROM Labs ORDER BY equipmentCount DESC LIMIT 1;	PhysicsLabDB	1
SELECT labName, AVG(equipmentCount) AS avgEquipmentCount FROM Labs GROUP BY labName HAVING AVG(equipmentCount) > (SELECT AVG(equipmentCount) FROM Labs);	PhysicsLabDB	2
SELECT labName, capacity FROM Labs WHERE status = '开放' ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT labName, capacity FROM Labs WHERE capacity > 1000 ORDER BY capacity DESC;	PhysicsLabDB	4
SELECT deviceType, deviceName, MIN(calibrationDate) AS earliestCalibrationDate FROM Devices GROUP BY deviceType;	PhysicsLabDB	1
WITH LabEquipmentAvg AS (SELECT AVG(equipmentCount) AS avgEquipmentCount FROM Labs) SELECT labName, equipmentCount FROM Labs, LabEquipmentAvg WHERE equipmentCount > avgEquipmentCount;	PhysicsLabDB	2
SELECT deviceType, deviceName, MIN(calibrationDate) AS earliestCalibrationDate FROM Devices GROUP BY deviceType, deviceName;	PhysicsLabDB	3
SELECT labName, equipmentCount FROM Labs WHERE equipmentCount > 1000 ORDER BY equipmentCount DESC;	PhysicsLabDB	4
SELECT * FROM ExperimentData WHERE measurementValue > 1000 AND dataQuality = '高' ORDER BY measurementValue ASC LIMIT 10;	PhysicsLabDB	1
SELECT experimentId, AVG(measurementValue) AS averageValue FROM ExperimentData GROUP BY experimentId HAVING AVG(measurementValue) > 500 ORDER BY averageValue DESC;	PhysicsLabDB	2
SELECT labName, location FROM Labs WHERE capacity > 50 AND equipmentCount > 100 ORDER BY capacity ASC;	PhysicsLabDB	3
SELECT labName, location FROM Labs WHERE capacity > 1000000 ORDER BY capacity DESC LIMIT 5;	PhysicsLabDB	4
SELECT (3.00 * POWER(10, 8)) / (500 * POWER(10, -9)) AS frequency FROM Experiments e JOIN Devices d ON e.labId = d.labId WHERE d.deviceType = '光谱仪' AND e.status = '进行中';	PhysicsLabDB	1
SELECT measurementValue / 10 AS current FROM ExperimentData WHERE unit = 'V' AND measurementValue = 5;	PhysicsLabDB	2
SELECT deviceId, deviceName, calibrationDate, CASE WHEN DATE_ADD(calibrationDate, INTERVAL 1 YEAR) < '2023-01-01' THEN '需要重新校准' ELSE '不需要重新校准' END AS calibrationStatus FROM Devices WHERE calibrationDate = '2020-01-01';	PhysicsLabDB	3
SELECT variableId, variableName, initialValue * 100 AS maximumValue, unit FROM Variables WHERE variableId IN (SELECT variableId FROM SensitivityAnalysis WHERE sensitivityValue = 1000 AND impact = '高') AND initialValue = 1000 AND unit = '米(m)';	PhysicsLabDB	4
SELECT (p.Power_Consumption * (j.Page_Count / p.Print_Speed) / 60) AS Total_Energy_Wh FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE j.Color_Usage = 'Monochrome' AND j.Page_Count = 150 AND p.Power_Consumption = 500 AND p.Print_Speed = 30;	printer	1
SELECT (Revenue * Profit_Margin / 100) - (Revenue * R&D_Spending / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND R&D_Spending = 8;	printer	2
SELECT CASE WHEN (Capacity * (Current_Level / 100)) >= 800 THEN 'No' ELSE 'Yes' END AS Need_Replacement FROM consumables WHERE Type = 'Toner' AND Capacity = 5000 AND Current_Level = 5;	printer	3
SELECT (Revenue * Profit_Margin / 100) - (Revenue * `R&D_Spending` / 100) AS Net_Profit_RD_Difference FROM manufacturers WHERE Revenue = 5000000000 AND Profit_Margin = 15 AND `R&D_Spending` = 8;	printer	4
SELECT Consumable_ID, (Capacity * 0.3 * 5) / 1000 AS Total_Weight_KG FROM consumables WHERE Type = 'Paper' ORDER BY Total_Weight_KG DESC LIMIT 5;	printer	1
SELECT Printer_ID, SUM(CASE WHEN Type IN ('Toner', 'Ink') THEN Capacity * (Current_Level / 100) ELSE Capacity - (Capacity * (Current_Level / 100)) END) AS Total_Remaining_Pages FROM consumables GROUP BY Printer_ID ORDER BY Total_Remaining_Pages DESC LIMIT 3;	printer	2
SELECT Consumable_ID, (100 - Current_Level) / DATEDIFF(Next_Replacement_Date, CURDATE()) AS Daily_Usage_Percent FROM consumables WHERE DATEDIFF(Next_Replacement_Date, CURDATE()) > 0 HAVING Daily_Usage_Percent > 1 ORDER BY Daily_Usage_Percent ASC LIMIT 10;	printer	3
SELECT Consumable_ID, Capacity * (Current_Level / 100) AS Theoretical_Pages FROM consumables WHERE Current_Level > 100 ORDER BY Theoretical_Pages DESC;	printer	4
SELECT c.Type, (c.Capacity * (c.Current_Level / 100) / (p.Print_Speed * 60)) AS 耗尽时间_小时 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Toner' GROUP BY c.Type;	printer	1
SELECT c.Printer_ID, SUM(c.Capacity) / SUM(c.Cost) AS 总成本效率 FROM consumables c WHERE c.Type IN ('Ink', 'Drum') GROUP BY c.Printer_ID ORDER BY 总成本效率 DESC;	printer	2
SELECT c.Type, MAX(c.Capacity * (c.Current_Level / 100) / (p.Print_Speed * 60)) AS 耗尽时间_小时 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Toner' GROUP BY c.Type;	printer	3
SELECT p.Type, CASE WHEN (1000000 * 0.0001) > p.Tray_Capacity THEN 1 ELSE 0 END AS 矛盾检测 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Drum' AND c.Capacity = 1000000 AND c.Current_Level = 0.01 GROUP BY p.Type;	printer	4
SELECT c.* FROM consumables c INNER JOIN printers p ON c.Printer_ID = p.Printer_ID LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement' WHERE c.Type = 'Toner' AND c.Current_Level < 30 AND p.Power_Consumption > 1000 AND ml.Maintenance_ID IS NULL;	printer	1
SELECT p.Type, CASE WHEN (1000000 * 0.0001) > p.Tray_Capacity THEN 1 ELSE 0 END AS 矛盾检测 FROM consumables c JOIN printers p ON c.Printer_ID = p.Printer_ID WHERE c.Type = 'Drum' AND c.Capacity = 1000000 AND c.Current_Level = 0.01 GROUP BY p.Type, p.Tray_Capacity;	printer	2
SELECT c.* FROM consumables c INNER JOIN printers p ON c.Printer_ID = p.Printer_ID LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID AND ml.Maintenance_Type = 'Replacement' WHERE c.Type = 'Fuser' AND c.Current_Level < 15 AND p.Installation_Date < NOW() - INTERVAL 3 YEAR AND ml.Maintenance_ID IS NULL;	printer	3
SELECT c.* FROM consumables c LEFT JOIN maintenance_logs ml ON c.Printer_ID = ml.Printer_ID WHERE (c.Capacity > 100000000 OR c.Current_Level > 200) AND ml.Maintenance_ID IS NULL GROUP BY c.Consumable_ID HAVING COUNT(ml.Maintenance_ID) = 0;	printer	4
SELECT (1500 * 8 * 30) / 1000 AS Total_Energy_kWh, (1500 * 8 * 30) / 1000 * 0.92 AS CO2_Emissions_kg FROM printers WHERE Printer_ID = '特定打印机ID';	printer	1
WITH Theoretical AS (SELECT (0.6*200/5000) + (0.4*150/10000) AS TheoreticalCost), Actual AS (SELECT (3*200 + 2*150) / (3*5000 + 2*10000) AS ActualCost) SELECT ((ActualCost - TheoreticalCost) / TheoreticalCost) * 100 AS DifferenceRate FROM Theoretical, Actual;	printer	2
SELECT Printer_ID, '故障原因：维护间隔过长导致机械部件磨损' AS RootCause, '建议：立即执行预防性维护，更换磨损部件，恢复推荐维护周期' AS Recommendation FROM (SELECT Printer_ID, AVG(DATEDIFF(Maintenance_Date, LAG(Maintenance_Date) OVER (ORDER BY Maintenance_Date))) AS AvgInterval FROM maintenance_logs GROUP BY Printer_ID HAVING COUNT(*) >= 3) t WHERE AvgInterval > 推荐周期 * 1.5;	printer	3
SELECT 9.9E15 / 2999 AS NumberOfPrinters FROM dual;	printer	4
SELECT Printer_ID, '故障原因：维护间隔过长导致机械部件磨损' AS RootCause, '建议：立即执行预防性维护，更换磨损部件，恢复推荐维护周期' AS Recommendation FROM (SELECT Printer_ID, AVG(DATEDIFF(Maintenance_Date, Prev_Maintenance_Date)) AS AvgInterval FROM (SELECT Printer_ID, Maintenance_Date, LAG(Maintenance_Date) OVER (PARTITION BY Printer_ID ORDER BY Maintenance_Date) AS Prev_Maintenance_Date FROM maintenance_logs) t1 GROUP BY Printer_ID HAVING COUNT(*) >= 3 ) t2;	printer	1
WITH months AS ( SELECT generate_series(1,12) AS month ), monthly_cost AS ( SELECT months.month, COALESCE(SUM(ml.Cost),0) AS total_cost FROM months LEFT JOIN maintenance_logs ml ON EXTRACT(YEAR FROM ml.Maintenance_Date) = 2023 AND EXTRACT(MONTH FROM ml.Maintenance_Date) = months.month GROUP BY months.month ) SELECT current_month, CASE WHEN previous_month_cost = 0 THEN 0 ELSE ROUND(((current_month_cost - previous_month_cost) / previous_month_cost * 100)::numeric, 2) END AS growth_rate FROM ( SELECT month AS current_month, total_cost AS current_month_cost, LAG(total_cost,1,0) OVER (ORDER BY month) AS previous_month_cost FROM monthly_cost ) t ORDER BY growth_rate ASC;	printer	2
WITH global_avg AS ( SELECT AVG(Cost) AS avg_cost FROM maintenance_logs ) SELECT Printer_ID, COUNT(*) AS maintenance_count FROM maintenance_logs WHERE Cost < (SELECT avg_cost FROM global_avg) GROUP BY Printer_ID HAVING COUNT(*) > 3 ORDER BY maintenance_count DESC LIMIT 10;	printer	3
WITH months AS (SELECT 1 AS month UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10 UNION SELECT 11 UNION SELECT 12), monthly_cost AS (SELECT months.month, COALESCE(SUM(ml.Cost),0) AS total_cost FROM months LEFT JOIN maintenance_logs ml ON YEAR(ml.Maintenance_Date) = 2023 AND MONTH(ml.Maintenance_Date) = months.month GROUP BY months.month) SELECT current_month, CASE WHEN previous_month_cost = 0 THEN 0 ELSE ROUND(((current_month_cost - previous_month_cost) / previous_month_cost * 100), 2) END AS growth_rate FROM (SELECT month AS current_month, total_cost AS current_month_cost, LAG(total_cost,1,0) OVER (ORDER BY month) AS previous_month_cost FROM monthly_cost) t ORDER BY growth_rate ASC;	printer	4
SELECT m.Printer_ID, SUM(DATEDIFF(m.Next_Maintenance_Date, m.Maintenance_Date) * 24 * (p.Power_Consumption * 0.2) / 1000) AS Total_Standby_Energy_kWh FROM maintenance_logs m JOIN printers p ON m.Printer_ID = p.Printer_ID GROUP BY m.Printer_ID;	printer	1
WITH total_cost AS (SELECT SUM(Cost) AS total FROM maintenance_logs) SELECT Maintenance_ID, Cost, ROUND((Cost * 100.0 / (SELECT total FROM total_cost)), 4) AS cost_percentage FROM maintenance_logs WHERE Cost >= 100000 ORDER BY Cost DESC LIMIT 5;	printer	2
SELECT QUARTER(Maintenance_Date) AS Quarter, Maintenance_Type, COUNT(*) AS Frequency, (SUM(CASE WHEN Maintenance_Type = 'Routine' THEN 1 ELSE 0 END)/COUNT(*))*100 AS Preventive_Ratio FROM maintenance_logs WHERE Maintenance_Type IN ('Routine','Repair') GROUP BY Quarter, Maintenance_Type ORDER BY Quarter;	printer	3
SELECT Technician, MAX(Cost) AS Actual_Max_Cost, (SELECT SUM(Cost)*0.95 FROM maintenance_logs) AS Theoretical_Max_Cost FROM maintenance_logs GROUP BY Technician;	printer	4
SELECT 850 * 3 * 3600 AS Total_Energy_Joules;	printer	1
SELECT ROUND( (COUNT(CASE WHEN Cost > (SELECT AVG(Cost) FROM maintenance_logs WHERE Maintenance_Type = 'Repair') THEN 1 END) * 100.0 / COUNT(*)), 2 ) AS Repair_Proportion FROM maintenance_logs WHERE Maintenance_Type = 'Repair';	printer	2
SELECT ml.* FROM maintenance_logs ml JOIN printers p ON ml.Printer_ID = p.Printer_ID WHERE ml.Maintenance_Date < p.Installation_Date;	printer	3
SELECT * FROM maintenance_logs WHERE Cost > 1e18 AND Next_Maintenance_Date > '3000-01-01';	printer	4
SELECT (400 * 18 * 365 / 1000) * Production_Volume_Total AS Total_Power_Consumption_kWh FROM manufacturers WHERE Manufacturer_ID = 'MAN001';	printer	1
SELECT R&D_Spending / Employee_Count AS Per_Capita_RD, (R&D_Spending / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND R&D_Spending = 800000000 AND Employee_Count = 10000;	printer	2
SELECT Founded_Year, R&D_Spending, CASE WHEN Founded_Year < 1900 AND R&D_Spending > 500000000 THEN '不合理' ELSE '合理' END AS Validity FROM manufacturers WHERE Founded_Year = 1700 AND R&D_Spending = 500000000;	printer	3
SELECT `R&D_Spending` / Employee_Count AS Per_Capita_RD, (`R&D_Spending` / Revenue) * 100 AS RD_Percentage FROM manufacturers WHERE Revenue = 5000000000 AND `R&D_Spending` = 800000000 AND Employee_Count = 10000;	printer	4
SELECT Founded_Year, 'R&D_Spending', CASE WHEN Founded_Year < 1900 AND 'R&D_Spending' > 500000000 THEN '不合理' ELSE '合理' END AS Validity FROM manufacturers WHERE Founded_Year = 1700 AND 'R&D_Spending' = 500000000;	printer	1
SELECT Name, (`R&D_Spending` / Revenue) * 100 AS R_D_Percent FROM manufacturers ORDER BY R_D_Percent DESC LIMIT 5;	printer	2
SELECT Name, Founded_Year, Profit_Margin FROM manufacturers WHERE Founded_Year < 1950 AND Profit_Margin > 15 ORDER BY Founded_Year ASC;	printer	3
SELECT Name, (Revenue / Employee_Count) AS Per_Capita_Output FROM manufacturers UNION ALL SELECT 'Hypothetical Manufacturer' AS Name, 1000000000000 / 1 AS Per_Capita_Output ORDER BY Per_Capita_Output DESC;	printer	4
SELECT Country, SUM(Production_Volume_Total * 50 * 0.5) AS Total_Carbon_Emission FROM manufacturers GROUP BY Country;	printer	1
SELECT (R&D_Spending / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY Comprehensive_Index;	printer	2
SELECT Country, COUNT(*) AS Abnormal_Company_Count FROM manufacturers WHERE Founded_Year <= 1973 AND Market_Cap < (Revenue * 2) GROUP BY Country;	printer	3
SELECT ('R&D_Spending' / Revenue) * (Profit_Margin / 100) AS Comprehensive_Index, COUNT(*) AS Manufacturer_Count FROM manufacturers GROUP BY Comprehensive_Index;	printer	4
SELECT m.Name, (m.Production_Volume_Total * 300 * 8 * 365 / 1000) AS Total_Annual_Power_Consumption_kWh FROM manufacturers m GROUP BY m.Manufacturer_ID;	printer	1
SELECT m.Name, ABS((m.RD_Spending / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m HAVING Difference_Percentage > 10;	printer	2
SELECT Name, Founded_Year, Employee_Count FROM manufacturers WHERE (YEAR(CURDATE()) - Founded_Year) > 50 AND Employee_Count < 1000;	printer	3
SELECT m.Name, ABS(('m.RD_Spending' / m.Revenue * 100) - m.Profit_Margin) AS Difference_Percentage FROM manufacturers m HAVING Difference_Percentage > 10;	printer	4
SELECT (Power_Consumption * (500 / (Print_Speed * 60)) / 1000) AS Total_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome' AND Power_Consumption = 800 AND Print_Speed = 30;	printer	1
SELECT IF((2000*0.05 + 5000*0.02) <= (Capacity * (Current_Level/100)), '足够', '不足够') AS 是否足够 FROM consumables WHERE Type = 'Ink' AND Capacity = 100 AND Current_Level = 60;	printer	2
SELECT CEIL(7 / 2) AS Actual_Sheets FROM print_jobs WHERE Duplex = 1 AND Page_Count = 7;	printer	3
SELECT (POWER(10, 18) * 0.1 / 1000) / (500 * 0.1 / 1000 * 24 * 365) AS Years FROM printers WHERE Type = '3D' AND Tray_Capacity = 500;	printer	3
SELECT p.Model, SUM((j.Page_Count / CAST(SUBSTRING_INDEX(p.Print_Speed, 'ppm', 1) AS UNSIGNED)) * 60 * p.Power_Consumption * 1000) AS Total_Energy FROM printers p JOIN print_jobs j ON p.Printer_ID = j.Printer_ID WHERE p.Type = 'Laser' GROUP BY p.Model ORDER BY Total_Energy DESC LIMIT 5;	printer	1
SELECT c.Model, (SUM(CASE WHEN j.Color_Usage = 'Color' THEN j.Page_Count * 3 * (c.Cost/c.Capacity) ELSE 0 END) / SUM(CASE WHEN j.Color_Usage = 'Monochrome' THEN j.Page_Count * (c.Cost/c.Capacity) ELSE 0 END)) AS Cost_Ratio FROM consumables c JOIN print_jobs j ON c.Printer_ID = j.Printer_ID WHERE c.Type = 'Ink' GROUP BY c.Model HAVING Cost_Ratio IS NOT NULL ORDER BY Cost_Ratio DESC LIMIT 3;	printer	2
SELECT u.Name, SUM(j.Page_Count * 0.5) AS Saved_Paper FROM users u JOIN print_jobs j ON u.User_ID = j.User_ID WHERE j.Duplex = 1 GROUP BY u.User_ID ORDER BY Saved_Paper DESC LIMIT 10;	printer	3
SELECT Model, (1000000000 / CAST(SUBSTRING_INDEX(Print_Speed, 'ppm', 1) AS UNSIGNED)) / 525600 AS Years FROM printers ORDER BY Years DESC LIMIT 5;	printer	4
SELECT Paper_Size, SUM(Page_Count * 80 * 0.06237 * (CASE WHEN Duplex=1 THEN 0.5 ELSE 1 END)) / 1000 AS Total_Mass_Kg FROM print_jobs GROUP BY Paper_Size;	printer	1
SELECT Duplex, SUM(Page_Count) - SUM(CEIL(Page_Count/(CASE WHEN Duplex=1 THEN 2 ELSE 1 END))) AS Saved_Pages FROM print_jobs GROUP BY Duplex;	printer	2
SELECT Color_Usage, SUM(Page_Count * (CASE WHEN Color_Usage='Color' THEN 3 ELSE 1 END)) AS Consumption_Ratio FROM print_jobs GROUP BY Color_Usage;	printer	3
SELECT Duplex, CASE WHEN CEIL(100000000/(CASE WHEN Duplex=1 THEN 2 ELSE 1 END)) > 2147483647 THEN 1 ELSE 0 END AS Crash_Condition FROM (SELECT 0 AS Duplex UNION SELECT 1) AS modes;	printer	4
SELECT pj.* FROM print_jobs pj JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pj.Paper_Size = 'A4' AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(REGEXP_REPLACE(pr.Print_Speed, '^0-9', '', 'g') AS INTEGER), 0))) > (pr.Power_Consumption * 0.1);	printer	1
SELECT pj.Job_ID, pj.Page_Count * 0.05 * (c.Cost / 250) AS Total_Ink_Cost FROM print_jobs pj JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE pj.Color_Usage = 'Color' AND c.Type = 'Ink';	printer	2
SELECT pj.* FROM print_jobs pj JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pj.Paper_Size = 'A4' AND ((pj.Page_Count * 4.9896 * POWER(2, pj.Duplex) * 9.8 * 0.1) / (pj.Page_Count / NULLIF(CAST(REGEXP_SUBSTR(pr.Print_Speed, '[0-9]+') AS UNSIGNED), 0))) > (pr.Power_Consumption * 0.1);	printer	3
SELECT * FROM print_jobs WHERE Page_Count > 8848000000 / (0.1 * 0.001);	printer	4
SELECT ((800 * 4 + 50 * 20) * 30) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser' LIMIT 1;	printer	1
SELECT ((5000 * 0.3 - (1200 * 1 + (800 * 0.4 * 2.5 + 800 * 0.6 * 1) + (500 * 0.5))) / 5000 * 100) AS Remaining_Percent FROM consumables WHERE Type = 'Toner' AND Model = '某型号';	printer	2
WITH drum_cost AS (SELECT Cost FROM consumables WHERE Type = 'Drum' LIMIT 1), fuser_cost AS (SELECT Cost FROM consumables WHERE Type = 'Fuser' LIMIT 1) SELECT (200 * 48 + 500 * 16) AS Annual_Budget FROM drum_cost, fuser_cost;	printer	3
SELECT (100 * 365 * 24 * 60 / 5) AS Max_Tasks, (100 * 365 * 24 / 1000) * 1500 AS Maintenance_Cost, (100 * 365 * 24 * 60 / 5) * 0.2 AS Total_Weight FROM printers WHERE Type = '3D' LIMIT 1;	printer	4
SELECT Printer_ID, Model, (Power_Consumption * DATEDIFF(CURRENT_DATE, Installation_Date) * 24) / 1000 AS Total_kWh FROM printers WHERE Type = 'Laser' AND Installation_Date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) ORDER BY Total_kWh DESC LIMIT 3;	printer	1
SELECT m.Name, m.Profit_Margin FROM manufacturers m WHERE m.Profit_Margin < 15 AND m.Employee_Count > 10000 ORDER BY m.Profit_Margin ASC;	printer	2
SELECT Consumable_ID, Printer_ID, Current_Level, Last_Replacement_Date FROM consumables WHERE Type = 'Toner' AND Current_Level < 20 AND DATEDIFF(CURRENT_DATE, Last_Replacement_Date) > 90 ORDER BY Current_Level ASC;	printer	3
SELECT (100000000 / 2) AS Saved_Pages, ((100000000 / 2) * 4.5) / 1000000 AS Saved_Weight_Tons ORDER BY Saved_Weight_Tons DESC;	printer	4
SELECT Printer_ID, (Power_Consumption * 24 * 0.65 / 1000) AS Total_Energy_kWh FROM printers WHERE Type = '激光' GROUP BY Printer_ID;	printer	1
SELECT c.Model, (c.Capacity * (c.Current_Level / 100) / 3) / (SUM(p.Page_Count * 3) / 30) AS Remaining_Days FROM consumables c JOIN printers pr ON c.Printer_ID = pr.Printer_ID JOIN print_jobs p ON pr.Printer_ID = p.Printer_ID WHERE c.Type = '碳粉' AND p.Job_Date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY) GROUP BY c.Model;	printer	2
SELECT u.Department, SUM(p.Page_Count - CEIL(p.Page_Count / 2)) AS Saved_Papers FROM print_jobs p JOIN users u ON p.User_ID = u.User_ID WHERE u.Department = '销售部' AND p.Duplex = 1 AND YEAR(p.Job_Date) = 2023 AND QUARTER(p.Job_Date) = 4 GROUP BY u.Department;	printer	3
SELECT c.Model, (c.Capacity * (c.Current_Level / 100) / 3) / (SUM(p.Page_Count * 3) / 30) AS Remaining_Days FROM consumables c JOIN printers pr ON c.Printer_ID = pr.Printer_ID JOIN print_jobs p ON pr.Printer_ID = p.Printer_ID WHERE c.Type = '碳粉' AND p.Job_Date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY) GROUP BY c.Model, c.Capacity, c.Current_Level;	printer	4
SELECT Printer_ID, ((Power_Consumption * (86400 - 5) + Power_Consumption * 1.2 * 5) / 1000) AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Power_Consumption = 800;	printer	1
SELECT p.Printer_ID, (p.Weight + (p.Tray_Capacity * 365 * 0.0045)) * (YEAR(CURDATE()) - p.Year) AS Composite_Value FROM printers p WHERE p.Printer_ID IN (SELECT DISTINCT j.Printer_ID FROM print_jobs j JOIN users u ON j.User_ID = u.User_ID WHERE u.Department = '某部门');	printer	2
SELECT p.Printer_ID, p.Location FROM printers p WHERE NOT EXISTS (SELECT 1 FROM print_jobs j JOIN users u ON j.User_ID = u.User_ID WHERE j.Printer_ID = p.Printer_ID AND LOCATE(LOWER(u.Department), LOWER(p.Location)) > 0);	printer	3
SELECT ((1e8 * 100 * 365 * 24 * 3600) / (POWER(3e8, 2))) / 7.342e22 AS Equivalent_Moon_Masses;	printer	4
SELECT (Power_Consumption * 23.75 + 200 * 0.25) / 1000 AS Total_Energy_KWh FROM printers WHERE Type = 'Laser' AND Max_Resolution = '最大分辨率值';	printer	1
SELECT Name, ROUND((SUM(RD_Spending) / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;	printer	2
SELECT CASE WHEN (SUM(Page_Count * 2 - Page_Count) / SUM(Page_Count * 2) * 100) BETWEEN 45 AND 47.5 THEN '符合' ELSE '不符合' END AS Compliance FROM print_jobs WHERE Duplex = 1 AND Paper_Size = 'A4';	printer	3
SELECT Name, ROUND((SUM('RD_Spending') / SUM(Revenue)) * 100, 4) AS RD_Intensity FROM manufacturers WHERE Founded_Year < 2019 GROUP BY Manufacturer_ID ORDER BY Production_Volume_Total DESC LIMIT 3;	printer	4
SELECT users.User_ID, SUM(printers.Power_Consumption / 1000 * 24) AS total_energy_kWh FROM users JOIN print_jobs ON users.User_ID = print_jobs.User_ID JOIN printers ON print_jobs.Printer_ID = printers.Printer_ID WHERE users.Role = 'Admin' AND printers.Type = 'Laser' GROUP BY users.User_ID ORDER BY total_energy_kWh DESC LIMIT 3;	printer	1
SELECT u.Department, (SUM(CASE WHEN pj.Color_Usage = 'Monochrome' THEN pj.Page_Count ELSE 0 END) * 1.0 / SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END)) AS ratio FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Color_Usage IN ('Monochrome', 'Color') GROUP BY u.Department HAVING SUM(CASE WHEN pj.Color_Usage = 'Color' THEN pj.Page_Count ELSE 0 END) > 0 ORDER BY ratio ASC LIMIT 5;	printer	2
SELECT u.*, pj.* FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE u.Role = 'Guest' AND pj.Page_Count > 50 ORDER BY pj.Page_Count DESC LIMIT 10;	printer	3
SELECT u.Department, SUM(pj.Page_Count) AS total_pages FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID WHERE pj.Page_Count >= 1000000 GROUP BY u.Department ORDER BY total_pages DESC LIMIT 5;	printer	4
SELECT u.Department, SUM((p.Page_Count / (1 + p.Duplex) / pr.Print_Speed / 60) * (pr.Power_Consumption / 1000)) AS Total_Energy_kWh FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Department;	printer	1
SELECT u.Role, SUM(p.Page_Count * (CASE WHEN p.Color_Usage = 'Color' THEN 1.2 ELSE 1 END) / pr.Print_Speed * 60) / SUM(p.Page_Count) AS Avg_Time_Per_Page FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID JOIN printers pr ON p.Printer_ID = pr.Printer_ID GROUP BY u.Role ORDER BY Avg_Time_Per_Page;	printer	2
SELECT u.Department, p.Paper_Size, COUNT(*) AS Usage_Count FROM users u JOIN print_jobs p ON u.User_ID = p.User_ID GROUP BY u.Department, p.Paper_Size ORDER BY u.Department, Usage_Count DESC;	printer	3
SELECT 10000000 * 0.05 * 2 AS Total_Ink_ml, CEIL((10000000 * 0.05 * 2) / 500) AS Replacement_Count;	printer	4
SELECT u.User_ID, u.Name FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pr.Power_Consumption * 1.2 * SUM(pj.Page_Count) / pr.Print_Speed > pr.Power_Consumption * 10 AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = pr.Printer_ID) GROUP BY u.User_ID, u.Name HAVING SUM(pj.Page_Count) > 0;	printer	1
WITH DeptCost AS (SELECT u.Department, SUM(c.Cost / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE c.Type IN ('Toner', 'Ink') GROUP BY u.Department) SELECT u.User_ID, u.Name FROM users u JOIN DeptCost dc ON u.Department = dc.Department WHERE (c.Cost / c.Capacity) < dc.DeptAvg AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = c.Printer_ID AND ml.Maintenance_Type = 'Replacement');	printer	2
SELECT u.User_ID, u.Name FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN printers pr ON pj.Printer_ID = pr.Printer_ID WHERE pr.Power_Consumption * 1.2 / pr.Print_Speed > pr.Power_Consumption * 10 AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = pr.Printer_ID) GROUP BY u.User_ID, u.Name HAVING SUM(pj.Page_Count) > 0;	printer	3
WITH DeptCost AS (SELECT u.Department, SUM(c.Cost / c.Capacity * pj.Page_Count) / SUM(pj.Page_Count) AS DeptAvg FROM users u JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE c.Type IN ('Toner', 'Ink') GROUP BY u.Department) SELECT u.User_ID, u.Name FROM users u JOIN DeptCost dc ON u.Department = dc.Department JOIN print_jobs pj ON u.User_ID = pj.User_ID JOIN consumables c ON pj.Printer_ID = c.Printer_ID WHERE (c.Cost / c.Capacity) < dc.DeptAvg AND NOT EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.Printer_ID = c.Printer_ID AND ml.Maintenance_Type = 'Replacement');	printer	4
SELECT Printer_ID, Model, (1000 / CAST(SUBSTRING(Print_Speed, 1, LEN(Print_Speed)-3) AS FLOAT)) * Power_Consumption / 1000 / 60 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';	printer	1
SELECT m.Manufacturer_ID, m.Name, ((m.Revenue - (COALESCE(c.TotalConsumableCost,0) + COALESCE(ml.TotalMaintenanceCost,0))) / m.Revenue * 100) AS Profit_Margin_Percent FROM manufacturers m LEFT JOIN (SELECT p.Manufacturer_ID, SUM(c.Cost) AS TotalConsumableCost FROM printers p JOIN consumables c ON p.Printer_ID = c.Printer_ID GROUP BY p.Manufacturer_ID) c ON m.Manufacturer_ID = c.Manufacturer_ID LEFT JOIN (SELECT p.Manufacturer_ID, SUM(ml.Cost) AS TotalMaintenanceCost FROM printers p JOIN maintenance_logs ml ON p.Printer_ID = ml.Printer_ID GROUP BY p.Manufacturer_ID) ml ON m.Manufacturer_ID = ml.Manufacturer_ID;	printer	2
SELECT Printer_ID, Model, (1000 / CAST(SUBSTRING(Print_Speed, 1, LENGTH(Print_Speed)-3) AS FLOAT)) * Power_Consumption / 1000 / 60 AS Total_Energy_kWh FROM printers WHERE Type = 'Laser' AND Color_Support = 'Monochrome';	printer	3
WITH RECURSIVE YearlyCost (Year, Annual_Cost) AS (SELECT 1, 1000.0 UNION ALL SELECT Year+1, Annual_Cost*3 FROM YearlyCost WHERE Year < 100) SELECT Annual_Cost AS Year_100_Cost FROM YearlyCost WHERE Year = 100;	printer	4
SELECT c.Consumable_ID, (c.Capacity - SUM(pj.Page_Count)) / (AVG(pj.Page_Count / NULLIF(DATEDIFF((SELECT MAX(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID), (SELECT MIN(Job_Date) FROM print_jobs WHERE Printer_ID = c.Printer_ID)), 0)) * (1 + AVG(pj.Duplex)*0.5)) AS Remaining_Days FROM consumables c JOIN print_jobs pj ON c.Printer_ID = pj.Printer_ID WHERE c.Type = 'Drum' AND c.Model = 'X-DrumUltra' GROUP BY c.Consumable_ID, c.Capacity;	printer	1
WITH RECURSIVE YearlyCost (Year, Annual_Cost) AS (SELECT 1, CAST(1000.0 AS DECIMAL(65,2)) UNION ALL SELECT Year+1, Annual_Cost*3 FROM YearlyCost WHERE Year < 100) SELECT Annual_Cost AS Year_100_Cost FROM YearlyCost WHERE Year = 100;	printer	2
SELECT u.Department, (SUM(CASE WHEN pj.Paper_Size = 'A4' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.7 + SUM(CASE WHEN pj.Paper_Size = 'Letter' THEN pj.Page_Count / (1 + pj.Duplex) ELSE 0 END) * 0.3) AS Predicted_Sheets FROM print_jobs pj JOIN users u ON pj.User_ID = u.User_ID WHERE u.Department = 'Sales' GROUP BY u.Department;	printer	3
WITH YearlyData AS (SELECT Manufacturer_ID, Founded_Year, `R&D_Spending`, Employee_Count, Production_Volume_Total, LAG(Production_Volume_Total) OVER (PARTITION BY Manufacturer_ID ORDER BY Founded_Year) AS Prev_Production FROM manufacturers) SELECT m.Name, ((yd.Production_Volume_Total - yd.Prev_Production) / yd.`R&D_Spending`) * (1.0 / yd.Employee_Count) AS `R&D_Efficiency` FROM YearlyData yd JOIN manufacturers m ON yd.Manufacturer_ID = m.Manufacturer_ID WHERE yd.Prev_Production IS NOT NULL;	printer	4
SELECT 1, SUM(RainfallMm) AS TotalRainfallMm FROM RainfallData WHERE CollectionTime BETWEEN '2023-10-01 00:00:00' AND '2023-10-31 23:59:59' GROUP BY 1;	RainGauge	1
SELECT 1, AnalysisTime, DataStartTime, DataEndTime, (AverageRainfallIntensityMmH / MaxRainfallIntensityMmH) AS IntensityRatio, AnalysisResult FROM HistoricalRainfallAnalysis WHERE DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59' ORDER BY AnalysisTime;	RainGauge	2
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 2 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN '极端天气事件' ELSE '非极端天气事件' END AS WeatherEventType FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN TotalRainfallMm >= 10000 THEN '可能导致洪水、土壤侵蚀等环境影响' ELSE '环境影响较小' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND TotalRainfallMm >= 10000;	RainGauge	4
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, (TotalRainfallMm * 1 * 1000 / 1000) AS WaterMassKg FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	1
SELECT t1.GaugeId, t1.CollectionTime AS Time1, t2.CollectionTime AS Time2, t1.RainfallIntensityMmH AS Intensity1, t2.RainfallIntensityMmH AS Intensity2, (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) / (UNIX_TIMESTAMP(t2.CollectionTime) - UNIX_TIMESTAMP(t1.CollectionTime)) * 3600 AS ChangeRate FROM RainfallData t1 JOIN RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime WHERE t1.GaugeId = 1 AND t1.CollectionTime >= '2023-01-01 00:00:00' AND t2.CollectionTime <= '2023-12-31 23:59:59' ORDER BY t1.CollectionTime;	RainGauge	2
SELECT GaugeId, DataStartTime, DataEndTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT AVG(TotalRainfallMm) * 3 FROM HistoricalRainfallAnalysis WHERE GaugeId = 1) THEN '可能导致洪水' ELSE '洪水风险较低' END AS FloodRisk FROM HistoricalRainfallAnalysis WHERE GaugeId = 1 AND DataStartTime >= '2023-01-01 00:00:00' AND DataEndTime <= '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, DataStartTime, DataEndTime, MaxRainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN MaxRainfallIntensityMmH >= 1000 THEN '可能导致洪水、土壤侵蚀等环境影响' ELSE '环境影响较小' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis WHERE GaugeId = 2 AND MaxRainfallIntensityMmH >= 1000;	RainGauge	4
SELECT RG.Id, RG.ElevationMeters, 1013.25 * EXP(-RG.ElevationMeters / 8400) AS CalculatedPressure, RD.AtmosphericPressureHpa FROM RainGauge RG JOIN RainfallData RD ON RG.Id = RD.GaugeId WHERE RG.Id = 1;	RainGauge	1
WITH Data AS (SELECT TemperatureCelsius AS X, RainfallMm AS Y FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(X) AS X_avg, AVG(Y) AS Y_avg, SUM((X - (SELECT AVG(X) FROM Data)) * (Y - (SELECT AVG(Y) FROM Data))) / SUM((X - (SELECT AVG(X) FROM Data)) * (X - (SELECT AVG(X) FROM Data))) AS slope, AVG(Y) - (SUM((X - (SELECT AVG(X) FROM Data)) * (Y - (SELECT AVG(Y) FROM Data))) / SUM((X - (SELECT AVG(X) FROM Data)) * (X - (SELECT AVG(X) FROM Data)))) * AVG(X) AS intercept FROM Data) SELECT slope, intercept, slope * 25 + intercept AS PredictedRainfall FROM Stats;	RainGauge	2
SELECT Id, GaugeModel, ManufactureDate, InstallationDate, DATEDIFF(CURDATE(), ManufactureDate) / 365 AS UsageYears, CASE WHEN DATEDIFF(CURDATE(), ManufactureDate) / 365 > 10 THEN '可能因老化影响数据准确性' ELSE '未达到老化影响年限' END AS AgingImpact FROM RainGauge;	RainGauge	3
SELECT Id, GaugeModel, ElevationMeters, 1013.25 * EXP(-10000 / 8400) AS CalculatedPressure, CASE WHEN 1013.25 * EXP(-10000 / 8400) < 300 THEN '可能导致数据失真或设备故障' ELSE '影响较小' END AS ImpactAnalysis FROM RainGauge WHERE Id = 2;	RainGauge	4
SELECT Id, ElevationMeters, 1013.25 * EXP(-ElevationMeters / 8400) AS AtmosphericPressureHpa FROM RainGauge WHERE Id = 2;	RainGauge	1
WITH RainfallLatitude AS (SELECT rg.Latitude AS Latitude, rd.RainfallMm AS Rainfall FROM RainGauge rg JOIN RainfallData rd ON rg.Id = rd.GaugeId WHERE rg.Id = 2 AND rd.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(Latitude) AS AvgLatitude, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N FROM RainfallLatitude), Slope AS (SELECT SUM((Latitude - AvgLatitude) * (Rainfall - AvgRainfall)) / SUM((Latitude - AvgLatitude) * (Latitude - AvgLatitude)) AS Slope FROM RainfallLatitude, Stats), Intercept AS (SELECT AvgRainfall - Slope * AvgLatitude AS Intercept FROM Stats, Slope) SELECT Slope, Intercept FROM Slope, Intercept;	RainGauge	2
SELECT Id, ElevationMeters, CASE WHEN ElevationMeters >= 0 AND ElevationMeters <= 5000 THEN '适合安装' ELSE '不适合安装' END AS InstallationSuitability FROM RainGauge WHERE Id = 2;	RainGauge	3
SELECT GaugeId, CollectionTime, TemperatureCelsius, HumidityPercent, CASE WHEN TemperatureCelsius >= 100 AND HumidityPercent >= 200 THEN '可能导致设备传感器损坏、数据失真或完全不可用' ELSE '数据采集正常' END AS ImpactAnalysis FROM RainfallData WHERE TemperatureCelsius >= 100 AND HumidityPercent >= 200;	RainGauge	4
SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, (SUM(RainfallMm) * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	1
WITH RainfallTemperature AS (SELECT TemperatureCelsius AS Temperature, RainfallMm AS Rainfall FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59'), Stats AS (SELECT AVG(Temperature) AS AvgTemperature, AVG(Rainfall) AS AvgRainfall, COUNT(*) AS N FROM RainfallTemperature), Slope AS (SELECT SUM((Temperature - AvgTemperature) * (Rainfall - AvgRainfall)) / SUM((Temperature - AvgTemperature) * (Temperature - AvgTemperature)) AS Slope FROM RainfallTemperature, Stats), Intercept AS (SELECT AvgRainfall - Slope * AvgTemperature AS Intercept FROM Stats, Slope) SELECT Slope, Intercept FROM Slope, Intercept;	RainGauge	2
SELECT GaugeId, SUM(RainfallMm) AS TotalRainfallMm, CASE WHEN SUM(RainfallMm) > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨量' AND ConditionOperator = '>' AND IsActive = TRUE) THEN '可能引发洪水' ELSE '洪水风险较低' END AS FloodRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	3
SELECT GaugeId, CollectionTime, RainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN RainfallMm >= 10000 THEN '可能导致洪水、土壤侵蚀等环境影响' ELSE '环境影响较小' END AS EnvironmentalImpact FROM RainfallData WHERE GaugeId = 2 AND RainfallMm >= 10000;	RainGauge	4
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (RainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
WITH RainfallIntensityChange AS (SELECT t1.CollectionTime AS Time1, t2.CollectionTime AS Time2, t1.RainfallIntensityMmH AS Intensity1, t2.RainfallIntensityMmH AS Intensity2, (t2.RainfallIntensityMmH - t1.RainfallIntensityMmH) / (UNIX_TIMESTAMP(t2.CollectionTime) - UNIX_TIMESTAMP(t1.CollectionTime)) * 3600 AS ChangeRate FROM RainfallData t1 JOIN RainfallData t2 ON t1.GaugeId = t2.GaugeId AND t2.CollectionTime > t1.CollectionTime WHERE t1.GaugeId = 3 AND t1.CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59') SELECT Time1, Time2, Intensity1, Intensity2, ChangeRate FROM RainfallIntensityChange ORDER BY Time1;	RainGauge	2
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, CASE WHEN RainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨强度' AND ConditionOperator = '>' AND IsActive = TRUE) THEN '可能引发山洪' ELSE '山洪风险较低' END AS FloodRisk FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, RainfallIntensityMmH, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM RainfallData WHERE GaugeId = 3 AND RainfallIntensityMmH = 1000;	RainGauge	4
SELECT GaugeId, CollectionTime, TemperatureCelsius, (TemperatureCelsius + 273.15) * 287 * 1.225 / 0.02896 AS AtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(TemperatureCelsius) AS AvgTemperature, COUNT(*) AS N FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT GaugeId, CollectionTime, TemperatureCelsius, CASE WHEN TemperatureCelsius >= -20 AND TemperatureCelsius <= 50 THEN '正常运行' ELSE '可能影响运行' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, TemperatureCelsius, (73.15 * 287 * 1.225 / 0.02896) AS AtmosphericPressureHpa, CASE WHEN TemperatureCelsius <= -200 THEN '可能导致设备冻结、数据失真' ELSE '数据采集正常' END AS ImpactAnalysis FROM RainfallData WHERE GaugeId = 2 AND TemperatureCelsius <= -200;	RainGauge	4
SELECT GaugeId, CollectionTime, HumidityPercent, (HumidityPercent * 0.01 * 23.76) + (AtmosphericPressureHpa - (HumidityPercent * 0.01 * 23.76)) AS AdjustedAtmosphericPressureHpa FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(HumidityPercent) AS AvgHumidity, MIN(HumidityPercent) AS MinHumidity, MAX(HumidityPercent) AS MaxHumidity FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT GaugeId, CollectionTime, HumidityPercent, CASE WHEN HumidityPercent >= 0 AND HumidityPercent <= 90 THEN '正常运行' ELSE '可能引发故障' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, HumidityPercent, AtmosphericPressureHpa, (200 * AtmosphericPressureHpa * 0.01) + (AtmosphericPressureHpa * 0.99) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(WindSpeedMps) AS AvgWindSpeed, MIN(WindSpeedMps) AS MinWindSpeed, MAX(WindSpeedMps) AS MaxWindSpeed FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, WindSpeedMps, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '风速在正常范围内' END AS FaultRisk FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT CollectionTime, RainfallMm, 100 AS AssumedWindSpeedMps, RainfallMm * (1 + 100 / 10) AS AdjustedRainfallMm, CASE WHEN 100 > 20 THEN '可能引发设备故障或数据失真' ELSE '风速在正常范围内' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 2 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, WindDirectionDegrees, RainfallMm * (1 + WindDirectionDegrees / 360) AS AdjustedRainfallDistribution FROM RainfallData WHERE GaugeId = 4 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT AVG(WindDirectionDegrees) AS AverageWindDirection, COUNT(*) AS DataPoints FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	2
SELECT GaugeId, CollectionTime, WindDirectionDegrees, CASE WHEN WindDirectionDegrees >= 0 AND WindDirectionDegrees <= 360 THEN '正常运行' ELSE '可能影响运行' END AS DeviceStatus FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, WindDirectionDegrees, RainfallMm, (RainfallMm * (1 + 720 / 360)) AS EstimatedRainfallDistribution, CASE WHEN WindDirectionDegrees = 720 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData WHERE GaugeId = 3 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - AtmosphericPressureHpa) / 1013.25) AS AdjustedRainfallMm FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, AVG(AtmosphericPressureHpa) AS AvgPressure, MIN(AtmosphericPressureHpa) AS MinPressure, MAX(AtmosphericPressureHpa) AS MaxPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能引发设备故障' ELSE '大气压力在正常范围内' END AS FaultRisk FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT CollectionTime, RainfallMm, 2000 AS AssumedAtmosphericPressureHpa, RainfallMm * (1 + (1013.25 - 2000) / 1013.25) AS AdjustedRainfallMm, CASE WHEN 2000 < 800 OR 2000 > 1100 THEN '可能引发设备故障或数据失真' ELSE '大气压力在正常范围内' END AS PotentialImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT CollectionTime, TemperatureCelsius, AtmosphericPressureHpa, TemperatureCelsius * (1 + AtmosphericPressureHpa / 1013.25) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	1
SELECT GaugeId, MAX(AtmosphericPressureHpa) AS MaxPressure, MIN(AtmosphericPressureHpa) AS MinPressure FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59' GROUP BY GaugeId;	RainGauge	2
SELECT CollectionTime, AtmosphericPressureHpa, CASE WHEN AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能影响设备正常运行' ELSE '大气压力在正常范围内' END AS OperationalImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	3
SELECT GaugeId, CollectionTime, AtmosphericPressureHpa, TemperatureCelsius, (TemperatureCelsius * (1 + 3000 / 1013.25)) AS EstimatedTemperature, CASE WHEN AtmosphericPressureHpa = 3000 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData WHERE GaugeId = 1 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-12-31 23:59:59';	RainGauge	4
SELECT RuleName, ThresholdValue, RainfallMm, (RainfallMm * (1 + ThresholdValue / 100)) AS EstimatedRainfall FROM RainfallWarningRule JOIN RainfallData ON RainfallWarningRule.ParameterType = '降雨量' AND RainfallData.RainfallMm > RainfallWarningRule.ThresholdValue WHERE RainfallWarningRule.RuleName = 'Heavy Rainfall Alert';	RainGauge	1
WITH ThresholdData AS (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = '降雨量'), IntensityData AS (SELECT RainfallIntensityMmH FROM RainfallData) SELECT (SUM((ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData)) * (RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData))) / (SQRT(SUM(POWER(ThresholdValue - (SELECT AVG(ThresholdValue) FROM ThresholdData), 2)) * SUM(POWER(RainfallIntensityMmH - (SELECT AVG(RainfallIntensityMmH) FROM IntensityData), 2))))) AS PearsonCorrelation FROM ThresholdData, IntensityData;	RainGauge	2
SELECT RuleName, ThresholdValue, CASE WHEN ThresholdValue >= 0 AND ThresholdValue <= 1000 THEN '正常运行' ELSE '可能引发设备故障' END AS DeviceStatus FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert';	RainGauge	3
SELECT CollectionTime, RainfallMm, 10000 AS AssumedThresholdValue, RainfallMm * (1 + 10000 / 100) AS AdjustedRainfallMm, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Heavy Rainfall Alert' AND ParameterType = '降雨量') THEN '可能引发设备故障或数据失真' ELSE '降雨量阈值在正常范围内' END AS PotentialImpact FROM RainfallData;	RainGauge	4
SELECT RuleName, TotalRainfallMm, (TotalRainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Low Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(TotalRainfallMm - (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');	RainGauge	2
SELECT AnalysisTime, TotalRainfallMm, CASE WHEN TotalRainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = '洪水预警' AND ParameterType = '降雨量') THEN '可能引发洪水' ELSE '总降雨量在安全范围内' END AS FloodRisk FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, TotalRainfallMm, -1000 AS AssumedTotalRainfallMm, (-1000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Low Rainfall Alert' AND ParameterType = '降雨量') THEN '可能导致干旱或土壤干裂' ELSE '降雨量在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, AverageRainfallIntensityMmH, (AverageRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Extreme Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(AverageRainfallIntensityMmH - (SELECT AVG(AverageRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');	RainGauge	2
SELECT AnalysisTime, AverageRainfallIntensityMmH, CASE WHEN AverageRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能引发城市内涝' ELSE '降雨强度在安全范围内' END AS FloodRisk FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, AverageRainfallIntensityMmH, 1000 AS AssumedRainfallIntensity, (1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 1000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Extreme Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能引发洪水或土壤侵蚀' ELSE '降雨强度在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, MaxRainfallIntensityMmH, (MaxRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Light Rainfall Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(MaxRainfallIntensityMmH - (SELECT AVG(MaxRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');	RainGauge	2
SELECT AnalysisTime, MaxRainfallIntensityMmH, CASE WHEN MaxRainfallIntensityMmH > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能影响户外活动' ELSE '降雨强度在安全范围内' END AS OutdoorActivityImpact FROM HistoricalRainfallAnalysis;	RainGauge	3
SELECT AnalysisTime, MaxRainfallIntensityMmH, 10000 AS AssumedMaxRainfallIntensity, (10000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Light Rainfall Alert' AND ParameterType = '降雨强度') THEN '可能引发洪水或土壤侵蚀' ELSE '降雨强度在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT RuleName, MinRainfallIntensityMmH, (MinRainfallIntensityMmH * 1 * 1000 * 9.81 / 3600) AS ImpactForceN FROM HistoricalRainfallAnalysis JOIN RainfallWarningRule ON HistoricalRainfallAnalysis.GaugeId = RainfallWarningRule.Id WHERE RainfallWarningRule.RuleName = 'Moderate Rainfall Intensity Alert';	RainGauge	1
SELECT SQRT(SUM(POWER(MinRainfallIntensityMmH - (SELECT AVG(MinRainfallIntensityMmH) FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行')), 2)) / COUNT(*)) AS StandardDeviation FROM HistoricalRainfallAnalysis WHERE GaugeId IN (SELECT Id FROM RainGauge WHERE Status = '运行');	RainGauge	2
SELECT HRA.AnalysisResult FROM HistoricalRainfallAnalysis HRA JOIN RainfallWarningRule RWR ON HRA.GaugeId = RWR.Id WHERE RWR.RuleName = 'Moderate Rainfall Intensity Alert' AND HRA.MinRainfallIntensityMmH < 5;	RainGauge	3
SELECT AnalysisTime, MinRainfallIntensityMmH, -1000 AS AssumedMinRainfallIntensity, (-1000 * 1 * 1000 * 9.81 / 3600) AS ImpactForceN, CASE WHEN -1000 < (SELECT ThresholdValue FROM RainfallWarningRule WHERE RuleName = 'Moderate Rainfall Intensity Alert' AND ParameterType = '降雨强度') THEN '可能导致干旱或土壤干裂' ELSE '降雨强度在正常范围内' END AS EnvironmentalImpact FROM HistoricalRainfallAnalysis;	RainGauge	4
SELECT CollectionTime, RainfallMm, (RainfallMm * 1000 * 9.81 / 1000) AS PressurePa FROM RainfallData;	RainGauge	1
WITH RainfallStats AS (SELECT RainfallMm AS X, RainfallIntensityMmH AS Y, AVG(RainfallMm) OVER () AS X_avg, AVG(RainfallIntensityMmH) OVER () AS Y_avg FROM RainfallData) SELECT (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM(POWER(X - X_avg, 2)) * SUM(POWER(Y - Y_avg, 2))))) AS PearsonCorrelation FROM RainfallStats;	RainGauge	2
SELECT CollectionTime, RainfallMm, CASE WHEN RainfallMm > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨量' AND RuleName = '洪水预警') THEN '可能引发洪水' ELSE '洪水风险较低' END AS FloodRisk FROM RainfallData;	RainGauge	3
SELECT CollectionTime, RainfallMm, (10000 * 1000 * 9.81 / 1000) AS PressurePa, CASE WHEN 10000 > (SELECT ThresholdValue FROM RainfallWarningRule WHERE ParameterType = '降雨量' AND ConditionOperator = '>' AND IsActive = TRUE) THEN '可能导致洪水或土壤侵蚀' ELSE '降雨量在正常范围内' END AS EnvironmentalImpact FROM RainfallData WHERE RainfallMm >= 10000;	RainGauge	4
SELECT CollectionTime, HumidityPercent, AtmosphericPressureHpa, (HumidityPercent * 0.01 * AtmosphericPressureHpa) + ((1 - HumidityPercent * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa FROM RainfallData;	RainGauge	1
WITH HumidityWindStats AS (SELECT HumidityPercent AS X, WindSpeedMps AS Y, AVG(HumidityPercent) OVER () AS X_avg, AVG(WindSpeedMps) OVER () AS Y_avg FROM RainfallData) SELECT (SUM((X - X_avg) * (Y - Y_avg)) / (SQRT(SUM(POWER(X - X_avg, 2)) * SUM(POWER(Y - Y_avg, 2))))) AS PearsonCorrelation FROM HumidityWindStats;	RainGauge	2
SELECT GaugeId, CollectionTime, HumidityPercent, WindSpeedMps, CASE WHEN HumidityPercent > 90 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '设备工作正常' END AS FaultRisk FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, WindSpeedMps, AtmosphericPressureHpa, (200 * 0.01 * AtmosphericPressureHpa) + ((1 - 200 * 0.01) * AtmosphericPressureHpa) AS EstimatedPressureHpa, CASE WHEN HumidityPercent = 200 OR WindSpeedMps = 100 THEN '可能影响数据采集' ELSE '数据采集正常' END AS DataImpact FROM RainfallData;	RainGauge	4
SELECT RainfallMm, WindSpeedMps, RainfallMm * (1 + WindSpeedMps / 10) AS AdjustedRainfall FROM RainfallData WHERE GaugeId = '特定雨量计ID';	RainGauge	1
WITH WindSpeedStats AS (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints FROM RainfallData), WindSpeedTrend AS (SELECT CollectionTime, WindSpeedMps, AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats, WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, WindSpeedMps, WindDirectionDegrees, CASE WHEN WindSpeedMps < 0 OR WindSpeedMps > 20 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, RainfallMm, (RainfallMm * (1 + 100 / 10)) AS AdjustedRainfallMm, CASE WHEN WindSpeedMps >= 100 OR WindDirectionDegrees >= 720 THEN '可能导致设备损坏或数据失真' ELSE '风速和风向在正常范围内' END AS DataImpact FROM RainfallData WHERE WindSpeedMps >= 100 OR WindDirectionDegrees >= 720;	RainGauge	4
SELECT WindDirectionDegrees, AtmosphericPressureHpa, AtmosphericPressureHpa * (1 + WindDirectionDegrees / 360) AS AdjustedPressure FROM RainfallData WHERE GaugeId = '特定雨量计ID';	RainGauge	1
WITH WindDirectionStats AS (SELECT AVG(WindDirectionDegrees) AS AvgWindDirection, COUNT(*) AS DataPoints FROM RainfallData), WindDirectionTrend AS (SELECT CollectionTime, WindDirectionDegrees, AVG(WindDirectionDegrees) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindDirection, MovingAvg FROM WindDirectionStats, WindDirectionTrend;	RainGauge	2
SELECT CollectionTime, WindDirectionDegrees, AtmosphericPressureHpa, CASE WHEN WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa * (1 + 720 / 360)) AS AdjustedAtmosphericPressureHpa, CASE WHEN WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000 THEN '可能导致设备损坏或数据失真' ELSE '风向和大气压力在正常范围内' END AS DataImpact FROM RainfallData WHERE WindDirectionDegrees >= 720 OR AtmosphericPressureHpa >= 2000;	RainGauge	4
SELECT RainfallMm, TemperatureCelsius, TemperatureCelsius - (RainfallMm / 10) AS AdjustedTemperature FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH RainfallStats AS (SELECT AVG(RainfallMm) AS AvgRainfall, COUNT(*) AS DataPoints FROM RainfallData), RainfallTrend AS (SELECT CollectionTime, RainfallMm, AVG(RainfallMm) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgRainfall, MovingAvg FROM RainfallStats, RainfallTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, TemperatureCelsius, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR TemperatureCelsius < -20 OR TemperatureCelsius > 50 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, TemperatureCelsius, (TemperatureCelsius - (10000 / 10)) AS AdjustedTemperatureCelsius, CASE WHEN RainfallMm >= 10000 OR TemperatureCelsius >= 1000 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和温度在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR TemperatureCelsius >= 1000;	RainGauge	4
SELECT RainfallMm, HumidityPercent, HumidityPercent + (RainfallMm / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH HumidityStats AS (SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints FROM RainfallData), HumidityTrend AS (SELECT CollectionTime, HumidityPercent, AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgHumidity, MovingAvg FROM HumidityStats, HumidityTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, HumidityPercent, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, (HumidityPercent + (10000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallMm >= 10000 OR HumidityPercent >= 200 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和湿度在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR HumidityPercent >= 200;	RainGauge	4
SELECT RainfallMm, WindSpeedMps, WindSpeedMps + (RainfallMm / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH WindSpeedStats AS (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints FROM RainfallData), WindSpeedTrend AS (SELECT CollectionTime, WindSpeedMps, AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats, WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, WindSpeedMps, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (10000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallMm >= 10000 OR WindSpeedMps >= 100 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和风速在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindSpeedMps >= 100;	RainGauge	4
SELECT RainfallMm, WindDirectionDegrees, WindDirectionDegrees + (RainfallMm / 10) AS AdjustedWindDirection FROM RainfallData WHERE GaugeId = '1';	RainGauge	1
WITH RainfallTotal AS (SELECT SUM(RainfallMm) AS TotalRainfall FROM RainfallData), RainfallTrend AS (SELECT CollectionTime, RainfallMm, SUM(RainfallMm) OVER (ORDER BY CollectionTime ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CumulativeRainfall FROM RainfallData) SELECT TotalRainfall, CumulativeRainfall FROM RainfallTotal, RainfallTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, WindDirectionDegrees, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR WindDirectionDegrees < 0 OR WindDirectionDegrees > 360 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindDirectionDegrees, (WindDirectionDegrees + (10000 / 10)) AS AdjustedWindDirectionDegrees, CASE WHEN RainfallMm >= 10000 OR WindDirectionDegrees >= 720 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和风向在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR WindDirectionDegrees >= 720;	RainGauge	4
SELECT RainfallMm, AtmosphericPressureHpa, AtmosphericPressureHpa - (RainfallMm / 10) AS AdjustedPressure FROM RainfallData WHERE GaugeId = '特定雨量计ID';	RainGauge	1
WITH PressureStats AS (SELECT AVG(AtmosphericPressureHpa) AS AvgPressure, COUNT(*) AS DataPoints FROM RainfallData), PressureTrend AS (SELECT CollectionTime, AtmosphericPressureHpa, AVG(AtmosphericPressureHpa) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgPressure, MovingAvg FROM PressureStats, PressureTrend;	RainGauge	2
SELECT CollectionTime, RainfallMm, AtmosphericPressureHpa, CASE WHEN RainfallMm < 0 OR RainfallMm > 1000 OR AtmosphericPressureHpa < 800 OR AtmosphericPressureHpa > 1100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, AtmosphericPressureHpa, (AtmosphericPressureHpa - (10000 / 10)) AS AdjustedAtmosphericPressureHpa, CASE WHEN RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000 THEN '可能导致设备损坏或数据失真' ELSE '降雨量和大气压力在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallMm >= 10000 OR AtmosphericPressureHpa >= 2000;	RainGauge	4
SELECT RainfallIntensityMmH, HumidityPercent, HumidityPercent + (RainfallIntensityMmH / 10) AS AdjustedHumidity FROM RainfallData WHERE GaugeId = '2';	RainGauge	1
WITH HumidityStats AS (SELECT AVG(HumidityPercent) AS AvgHumidity, COUNT(*) AS DataPoints FROM RainfallData), HumidityTrend AS (SELECT CollectionTime, HumidityPercent, AVG(HumidityPercent) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgHumidity, MovingAvg FROM HumidityStats, HumidityTrend;	RainGauge	2
SELECT CollectionTime, RainfallIntensityMmH, HumidityPercent, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR HumidityPercent < 0 OR HumidityPercent > 100 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, HumidityPercent, (HumidityPercent + (1000 / 10)) AS AdjustedHumidityPercent, CASE WHEN RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200 THEN '可能导致设备损坏或数据失真' ELSE '降雨强度和湿度在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR HumidityPercent >= 200;	RainGauge	4
SELECT RainfallIntensityMmH, WindSpeedMps, WindSpeedMps + (RainfallIntensityMmH / 10) AS AdjustedWindSpeed FROM RainfallData WHERE GaugeId = '2';	RainGauge	1
WITH WindSpeedStats AS (SELECT AVG(WindSpeedMps) AS AvgWindSpeed, COUNT(*) AS DataPoints FROM RainfallData), WindSpeedTrend AS (SELECT CollectionTime, WindSpeedMps, AVG(WindSpeedMps) OVER (ORDER BY CollectionTime ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS MovingAvg FROM RainfallData) SELECT AvgWindSpeed, MovingAvg FROM WindSpeedStats, WindSpeedTrend;	RainGauge	2
SELECT CollectionTime, RainfallIntensityMmH, WindSpeedMps, CASE WHEN RainfallIntensityMmH < 0 OR RainfallIntensityMmH > 100 OR WindSpeedMps < 0 OR WindSpeedMps > 20 THEN '可能引发设备故障' ELSE '设备运行正常' END AS DeviceStatus FROM RainfallData;	RainGauge	3
SELECT CollectionTime, WindSpeedMps, (WindSpeedMps + (1000 / 10)) AS AdjustedWindSpeedMps, CASE WHEN RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100 THEN '可能导致设备损坏或数据失真' ELSE '降雨强度和风速在正常范围内' END AS DataImpact FROM RainfallData WHERE RainfallIntensityMmH >= 1000 OR WindSpeedMps >= 100;	RainGauge	4
SELECT RainfallMm, RainfallIntensityMmH, ThresholdValue FROM RainfallData JOIN RainfallWarningRule ON RainfallData.GaugeId = '3' AND RainfallWarningRule.ParameterType = '降雨量' WHERE RainfallMm > ThresholdValue AND RainfallIntensityMmH = 100;	RainGauge	1
WITH RainfallData AS (SELECT 50 AS RainfallMm UNION ALL SELECT 60 UNION ALL SELECT 70 UNION ALL SELECT 80 UNION ALL SELECT 90) SELECT AVG(RainfallMm) AS AvgRainfallIntensity, SUM(RainfallMm) AS TotalRainfall FROM RainfallData;	RainGauge	2
SELECT InstallationLocation, ElevationMeters, (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) AS AvgAnnualRainfall, CASE WHEN ElevationMeters = 1000 AND (SELECT AVG(TotalRainfallMm) FROM HistoricalRainfallAnalysis WHERE GaugeId = RainGauge.Id) >= 1500 THEN '适合长期监测' ELSE '不适合长期监测' END AS Suitability FROM RainGauge WHERE ElevationMeters = 1000;	RainGauge	3
SELECT RuleName, ThresholdValue, CASE WHEN 1000 > ThresholdValue THEN '阈值无法有效判断，需调整预警规则' ELSE '阈值仍可有效判断' END AS WarningEffectiveness FROM RainfallWarningRule WHERE ParameterType = '降雨强度' AND IsActive = TRUE;	RainGauge	4
SELECT id, model, brand, power_rating, voltage_rating, (power_rating / voltage_rating) AS current_strength FROM rice_cooker_info;	rice_cooker	1
WITH avg_energy_consumption AS (SELECT rice_cooker_id, AVG(energy_consumption) AS avg_energy FROM performance_tests GROUP BY rice_cooker_id) SELECT rci.model, aec.avg_energy FROM rice_cooker_info rci JOIN avg_energy_consumption aec ON rci.id = aec.rice_cooker_id ORDER BY aec.avg_energy ASC LIMIT 1;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, rci.capacity, ur.rice_quantity, ur.water_quantity, (ur.rice_quantity + ur.water_quantity) AS total_quantity, CASE WHEN (ur.rice_quantity + ur.water_quantity) <= rci.capacity THEN 'No' ELSE 'Yes' END AS exceeded_capacity FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id;	rice_cooker	3
SELECT model, (10 * power_rating * 24) / 1000000 AS daily_energy_mwh FROM rice_cooker_info WHERE (10 * power_rating * 24) / 1000000 > 1;	rice_cooker	4
WITH energy_efficiency AS (SELECT rci.model, pt.time_to_boil, (pt.water_evaporation_rate / 100 * 1.5) AS water_quantity, (pt.water_evaporation_rate / 100 * 1.5 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / (rci.power_rating * pt.time_to_boil / 60) * 100 AS efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, efficiency FROM energy_efficiency WHERE efficiency < 60 AND time_to_boil > 15 ORDER BY efficiency ASC;	rice_cooker	1
WITH usage_counts AS (SELECT rice_cooker_id, COUNT(id) AS total_usage FROM usage_records GROUP BY rice_cooker_id), maintenance_costs AS (SELECT rice_cooker_id, SUM(maintenance_cost) AS total_cost FROM maintenance_records GROUP BY rice_cooker_id), cost_benefit AS (SELECT rci.model, uc.total_usage, mc.total_cost, CASE WHEN mc.total_cost = 0 THEN NULL ELSE uc.total_usage / mc.total_cost END AS cost_benefit_ratio FROM rice_cooker_info rci JOIN usage_counts uc ON rci.id = uc.rice_cooker_id JOIN maintenance_costs mc ON rci.id = mc.rice_cooker_id), percentile_rank AS (SELECT *, NTILE(2) OVER (ORDER BY cost_benefit_ratio DESC) AS percentile FROM cost_benefit) SELECT model, total_usage, total_cost, cost_benefit_ratio FROM percentile_rank WHERE percentile = 1;	rice_cooker	2
WITH defect_models AS (SELECT rice_cooker_id FROM performance_tests WHERE final_temperature < 0.9 * 100 AND rice_quality_score < 8 GROUP BY rice_cooker_id HAVING COUNT(*) >= 3), repaired_models AS (SELECT DISTINCT rice_cooker_id FROM maintenance_records WHERE maintenance_type = 'Repair') SELECT rci.model FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id WHERE dm.rice_cooker_id NOT IN (SELECT rice_cooker_id FROM repaired_models);	rice_cooker	3
SELECT model, power_rating, CASE WHEN power_rating > (50 * 0.12 * 150) THEN (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 ELSE NULL END AS boil_time_hours FROM rice_cooker_info WHERE (power_rating - (50 * 0.12 * 150)) > 0 AND (1.8 * 4186 * 150) / (power_rating - (50 * 0.12 * 150)) / 60 > 24;	rice_cooker	4
SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;	rice_cooker	1
SELECT brand, ROUND((total_incidents / observation_years * 5 * 100), 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;	rice_cooker	2
WITH defect_models AS (SELECT pt.rice_cooker_id FROM performance_tests pt WHERE pt.water_evaporation_rate > 15 AND pt.rice_quality_score < 8) SELECT rci.model, rci.production_date, CASE WHEN DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH) > '2023-12-01' THEN '在保' ELSE '过保' END AS warranty_status FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;	rice_cooker	4
SELECT (6 * 4186 * 78) / (900 * 18 * 60) * 100 AS thermal_efficiency;	rice_cooker	1
SELECT brand, ROUND((total_incidents / observation_years * 5 * 100), 1) AS expected_repairs_per_100_units FROM (SELECT 'BrandB' AS brand, 3 AS total_incidents, 2.0 AS observation_years UNION ALL SELECT 'BrandC' AS brand, 2 AS total_incidents, 1.5 AS observation_years) AS maintenance_data;	rice_cooker	2
WITH defect_models AS (SELECT pt.rice_cooker_id FROM performance_tests pt WHERE pt.water_evaporation_rate > 15 AND pt.rice_quality_score < 8) SELECT rci.model, rci.production_date, CASE WHEN DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH) > '2023-12-01' THEN '在保' ELSE '过保' END AS warranty_status FROM defect_models dm JOIN rice_cooker_info rci ON dm.rice_cooker_id = rci.id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 20 * 0.12 * (85 - (-15)) AS heat_loss), boil_time_calc AS (SELECT (2 * 4186 * (85 - (-15))) / (0.8 * 900 - (SELECT heat_loss FROM heat_loss_calc)) / 60 AS boil_time_minutes) SELECT boil_time_minutes FROM boil_time_calc;	rice_cooker	4
WITH heat_efficiency AS (SELECT rci.model, 2 AS water_quantity, pt.final_temperature, pt.initial_temperature, pt.energy_consumption, pt.water_evaporation_rate, (2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / pt.energy_consumption * 100 AS efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, efficiency FROM heat_efficiency WHERE efficiency < 65 AND water_evaporation_rate > 10 ORDER BY efficiency ASC;	rice_cooker	1
WITH maintenance_summary AS (SELECT rci.id, rci.model, rci.production_date, SUM(mr.maintenance_cost) AS total_cost, MAX(mr.maintenance_date) AS last_maintenance_date FROM rice_cooker_info rci JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id GROUP BY rci.id, rci.model, rci.production_date HAVING last_maintenance_date IS NOT NULL) SELECT model, total_cost, ROUND(DATEDIFF(last_maintenance_date, production_date)/30.0, 1) AS service_months, ROUND(total_cost / (DATEDIFF(last_maintenance_date, production_date)/30.0), 2) AS cost_rate FROM maintenance_summary WHERE DATEDIFF(last_maintenance_date, production_date)/30.0 > 12 AND total_cost / (DATEDIFF(last_maintenance_date, production_date)/30.0) > 5 ORDER BY cost_rate DESC LIMIT 3;	rice_cooker	2
WITH qualified_models AS (SELECT rci.id, rci.brand, rci.model FROM rice_cooker_info rci WHERE rci.capacity < 4 AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.rice_quantity >= 1.5) AND NOT EXISTS (SELECT 1 FROM usage_records ur2 WHERE ur2.rice_cooker_id = rci.id AND ur2.rice_quantity >= 1.5 AND ur2.water_quantity < 2.25)) SELECT qm.brand, qm.model, MAX(ur.end_time) AS last_usage_date FROM qualified_models qm JOIN usage_records ur ON qm.id = ur.rice_cooker_id GROUP BY qm.brand, qm.model;	rice_cooker	3
SELECT (2 * (4186 * (100 - 20) + 2260000)) / (0.5 * 700 * 0.1) AS total_seconds, ROUND((2 * (4186 * 80 + 2260000)) / (0.5 * 700 * 0.1) / 3600, 1) AS hours;	rice_cooker	4
WITH efficiency_calc AS (SELECT rci.model, pt.initial_temperature, pt.energy_consumption, pt.time_to_boil, pt.water_evaporation_rate, (2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) AS eta_max, pt.energy_consumption AS eta_real, ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000) - pt.energy_consumption) / ((2 * 4186 * (100 - pt.initial_temperature)) / (rci.power_rating * pt.time_to_boil / 60 * 1000)) * 100 AS deviation FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, deviation, water_evaporation_rate FROM efficiency_calc WHERE deviation > 15 AND water_evaporation_rate > 12 ORDER BY deviation DESC;	rice_cooker	1
WITH model_maintenance AS (SELECT rci.brand, rci.model, COUNT(*) AS maintenance_count FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id GROUP BY rci.brand, rci.model), brand_recurrence AS (SELECT brand, SUM(CASE WHEN maintenance_count > 1 THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS recurrence_rate, SUM(maintenance_count) AS total_maintenance FROM model_maintenance GROUP BY brand HAVING SUM(maintenance_count) >= 2) SELECT brand, ROUND(recurrence_rate * 100, 2) AS recurrence_rate_percent, total_maintenance FROM brand_recurrence WHERE recurrence_rate > 0.3 ORDER BY recurrence_rate DESC LIMIT 3;	rice_cooker	2
WITH qualified_models AS (SELECT rci.id, rci.model FROM rice_cooker_info rci WHERE rci.capacity >= 5 AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.rice_quantity < 0.5)), recent_scores AS (SELECT qm.model, pt.rice_quality_score, ROW_NUMBER() OVER (PARTITION BY qm.id ORDER BY pt.test_date DESC) AS rn FROM qualified_models qm JOIN performance_tests pt ON qm.id = pt.rice_cooker_id) SELECT model, ROUND(AVG(rice_quality_score), 2) AS avg_rice_quality FROM recent_scores WHERE rn <= 3 GROUP BY model;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 0.08 * 0.2 * POWER(280 - 2, 4) AS max_heat_loss), boil_time_calc AS (SELECT (3 * 4186 * (280 - 5)) / (1.5 * 900 - (SELECT max_heat_loss FROM heat_loss_calc)) / 3600 AS boil_time_hours) SELECT boil_time_hours FROM boil_time_calc;	rice_cooker	4
WITH efficiency_calc AS (SELECT rci.model, pt.final_temperature, pt.initial_temperature, pt.energy_consumption, pt.water_evaporation_rate, (2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / pt.energy_consumption AS eta_actual, 1 - (298.15 / (pt.final_temperature + 273.15)) AS eta_theoretical, ((2 * 4186 * (pt.final_temperature - pt.initial_temperature) / 3.6e6) / pt.energy_consumption - (1 - (298.15 / (pt.final_temperature + 273.15)))) * 100 AS efficiency_diff FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE pt.test_type = 'Boiling') SELECT model, efficiency_diff, water_evaporation_rate FROM efficiency_calc WHERE efficiency_diff > 10 AND water_evaporation_rate > 8 ORDER BY efficiency_diff DESC;	rice_cooker	1
WITH cost_benefit AS (SELECT rci.model, SUM(ur.rice_quantity) AS total_rice, SUM(pt.energy_consumption) AS total_energy, COUNT(*) AS usage_count, SUM(ur.rice_quantity) / SUM(pt.energy_consumption) AS benefit_ratio FROM usage_records ur JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id GROUP BY rci.model HAVING COUNT(*) > 5) SELECT model, ROUND(benefit_ratio, 2) AS benefit_ratio FROM cost_benefit WHERE benefit_ratio < 0.8 ORDER BY benefit_ratio ASC LIMIT 2;	rice_cooker	2
WITH repaired_in_warranty AS (SELECT rci.id, rci.model, mr.technician_name, DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH) AS warranty_end_date, mr.maintenance_date FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id WHERE mr.maintenance_type = 'Repair' AND mr.maintenance_date <= DATE_ADD(rci.production_date, INTERVAL rci.warranty_period MONTH)), last_usage AS (SELECT ur.rice_cooker_id, MAX(ur.end_time) AS last_usage_date FROM usage_records ur GROUP BY ur.rice_cooker_id) SELECT riw.model, riw.technician_name, lu.last_usage_date FROM repaired_in_warranty riw JOIN last_usage lu ON riw.id = lu.rice_cooker_id;	rice_cooker	3
WITH heat_loss_calc AS (SELECT 0.2 * 0.3 AS heat_loss_coeff), boil_time_calc AS (SELECT (5 * (4186 * (500 - 300) + 2260000 * (1 + 400/500))) / (5 * 800 - (SELECT heat_loss_coeff * (POWER(500,4) - POWER(300,4)) FROM heat_loss_calc)) / 3600 AS boil_time_hours) SELECT boil_time_hours FROM boil_time_calc;	rice_cooker	4
SELECT rci.model, ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 AS thermal_efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id AND DATE(pt.test_date) = DATE(ur.start_time) WHERE pt.test_type = 'Boiling' AND pt.time_to_boil > 18 AND ((ur.water_quantity * 4186 * (pt.final_temperature - pt.initial_temperature) / 3600000) / pt.energy_consumption) * 100 < 50 ORDER BY thermal_efficiency ASC;	rice_cooker	1
SELECT rci.brand, DATEDIFF(MAX(ur.end_time), MIN(rci.production_date))/30 AS total_service_months, COUNT(DISTINCT mr.maintenance_date) AS total_faults, (DATEDIFF(MAX(ur.end_time), MIN(rci.production_date))/30) / COUNT(DISTINCT mr.maintenance_date) AS fault_interval FROM rice_cooker_info rci LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id GROUP BY rci.brand HAVING total_faults > 0 ORDER BY fault_interval ASC LIMIT 3;	rice_cooker	2
SELECT rci.model, COUNT(mr.id) AS maintenance_count, (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id = rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_maintenance_type FROM rice_cooker_info rci LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id WHERE rci.capacity > 4 AND EXISTS (SELECT 1 FROM usage_records ur WHERE ur.rice_cooker_id = rci.id AND ur.water_quantity < 1) GROUP BY rci.id;	rice_cooker	3
WITH RECURSIVE heating_time AS (SELECT 300 AS start_temp, 300 + 50 AS end_temp, CAST(0.0 AS DECIMAL(30,3)) AS elapsed_time UNION ALL SELECT end_temp, LEAST(end_temp + CASE WHEN end_temp < 4000 THEN 50 WHEN end_temp < 4900 THEN 10 ELSE 1 END, 5000), CAST(elapsed_time AS DECIMAL(30,3)) + CAST( (10 * 4186 * (end_temp - start_temp)) / GREATEST(7000 - 10 * POWER((start_temp + end_temp)/2 - 5000, 3), 1) AS DECIMAL(30,3)) FROM heating_time WHERE end_temp < 5000 ) SELECT MAX(elapsed_time) AS total_seconds FROM heating_time;	rice_cooker	4
SELECT rci.model, ROUND(((ur.water_quantity*4186*(pt.final_temperature-pt.initial_temperature))/(pt.time_to_boil*60*rci.power_rating))*100,2) AS efficiency_rate FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id=rci.id JOIN usage_records ur ON pt.rice_cooker_id=ur.rice_cooker_id WHERE ur.temperature_setting-ur.actual_max_temperature>5 HAVING efficiency_rate<40 ORDER BY efficiency_rate ASC;	rice_cooker	1
SELECT rci.brand, ROUND(SUM(COALESCE(pt.energy_consumption,0)+COALESCE(ur.energy_consumption,0))*0.6/GREATEST(DATEDIFF(MAX(ur.end_time),MIN(ur.start_time)),1),2) AS daily_cost FROM rice_cooker_info rci LEFT JOIN performance_tests pt ON rci.id=pt.rice_cooker_id LEFT JOIN usage_records ur ON rci.id=ur.rice_cooker_id GROUP BY rci.brand HAVING daily_cost>2 AND DATEDIFF(MAX(ur.end_time),MIN(ur.start_time))>30 ORDER BY daily_cost DESC LIMIT 2;	rice_cooker	2
SELECT rci.model, (SELECT MAX(maintenance_date) FROM maintenance_records WHERE rice_cooker_id=rci.id) AS last_date, (SELECT maintenance_type FROM maintenance_records WHERE rice_cooker_id=rci.id ORDER BY maintenance_date DESC LIMIT 1) AS last_type FROM rice_cooker_info rci WHERE warranty_period>18 AND TIMESTAMPDIFF(YEAR,production_date,CURDATE())>3 AND EXISTS(SELECT 1 FROM maintenance_records WHERE rice_cooker_id=rci.id);	rice_cooker	3
SET SESSION cte_max_recursion_depth = 1000000; WITH RECURSIVE heating_sim AS (SELECT -273.0 AS current_temp, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time UNION ALL SELECT LEAST(current_temp + CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END, 100), elapsed_time + (10*4186*(CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END)) / GREATEST(2700 - 0.5*POWER((current_temp + 273),4), 1) FROM heating_sim WHERE current_temp < 100 ) SELECT MAX(elapsed_time) AS total_seconds, MAX(elapsed_time)/3600 AS total_hours FROM heating_sim;	rice_cooker	4
SELECT ur.rice_cooker_id, rci.model, ur.rice_quantity, ur.water_quantity, ur.energy_consumption AS E_actual, (ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600 AS E_theory, ((ur.rice_quantity * 4.18 * (ur.actual_max_temperature - 25) + ur.water_quantity * 2260) / 3600) / ur.energy_consumption * 100 AS efficiency_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id	rice_cooker	1
SET SESSION cte_max_recursion_depth = 1000000; WITH RECURSIVE heating_sim AS (SELECT -273.0 AS current_temp, CAST(0.0 AS DECIMAL(30,6)) AS elapsed_time UNION ALL SELECT LEAST(current_temp + CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END, 100), elapsed_time + (10*4186*(CASE WHEN current_temp < -173 THEN 10 WHEN current_temp < 0 THEN 1 ELSE 0.1 END)) / GREATEST(2700 - 0.5*POWER((current_temp + 273),4), 1) FROM heating_sim WHERE current_temp < 100 ) SELECT MAX(elapsed_time) AS total_seconds, MAX(elapsed_time)/3600 AS total_hours FROM heating_sim;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.temperature_setting, ur.actual_max_temperature, ABS(ur.actual_max_temperature - ur.temperature_setting) AS temperature_deviation, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Heating%') THEN '加热元件已更换' ELSE '加热元件未更换' END AS heating_element_status FROM usage_records ur WHERE ABS(ur.actual_max_temperature - ur.temperature_setting) > 5	rice_cooker	3
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.time_to_boil * (373 / 344) AS mount_everest_time, (pt.time_to_boil * (373 / 344)) / pt.time_to_boil - 1 AS time_increase_ratio, pt.energy_consumption * (373 / 344 - 1) AS energy_loss FROM performance_tests pt	rice_cooker	4
SELECT rci.id AS rice_cooker_id, rci.model, rci.material, rci.power_rating, ur.temperature_setting, ur.actual_max_temperature, CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END AS k, (CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002 AS ΔQ, ((CASE rci.material WHEN 'Non-stick' THEN 50 WHEN 'Ceramic' THEN 1.5 WHEN 'Stainless Steel' THEN 16 END * 0.1 * (ur.temperature_setting - ur.actual_max_temperature)) / 0.002) / rci.power_rating * 100 AS heat_loss_rate_percent FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id	rice_cooker	1
WITH MaintenanceAnalysis AS ( SELECT rci.model, YEAR(mr.maintenance_date) AS year, rci.warranty_period, AVG(pt.rice_quality_score) AS avg_quality_score, SUM(mr.maintenance_cost) AS total_maintenance_cost, COUNT(ur.id) AS usage_count FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id GROUP BY rci.model, YEAR(mr.maintenance_date), rci.warranty_period ) SELECT model, year, (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) AS cost_benefit_ratio, RANK() OVER(PARTITION BY year ORDER BY (warranty_period * avg_quality_score) / (total_maintenance_cost * usage_count) DESC) AS annual_rank FROM MaintenanceAnalysis;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.energy_consumption, ur.rice_quantity, ur.energy_consumption / ur.rice_quantity AS energy_per_kg, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN '米饭质量低于平均水平' ELSE '米饭质量正常' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.energy_consumption / ur.rice_quantity > 0.8	rice_cooker	3
SELECT pt.rice_cooker_id, pt.time_to_boil AS earth_time, SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) AS v_earth, SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) AS v_space, pt.time_to_boil * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01))) AS space_time, (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) * 100 AS time_increase_percent, pt.energy_consumption * (SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26)) / SQRT((8 * 1.38e-23 * 373) / (PI() * 2.99e-26 * 0.01)) - 1) AS energy_loss FROM performance_tests pt	rice_cooker	4
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373 / 363 - 1) AS energy_increase, (373 / 363 - 1) * 100 AS efficiency_loss_percent FROM performance_tests pt	rice_cooker	1
WITH MaintenanceAnalysis AS (SELECT rci.brand, QUARTER(mr.maintenance_date) AS quarter, COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) / COUNT(*) AS failure_rate, SUM(mr.maintenance_cost) / COUNT(*) AS avg_maintenance_cost FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id GROUP BY rci.brand, QUARTER(mr.maintenance_date)), CorrelationCalculation AS (SELECT brand, quarter, failure_rate, avg_maintenance_cost, AVG(failure_rate) OVER(PARTITION BY brand) AS mean_failure_rate, AVG(avg_maintenance_cost) OVER(PARTITION BY brand) AS mean_avg_maintenance_cost, (failure_rate - AVG(failure_rate) OVER(PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand)) AS covariance_term, POW(failure_rate - AVG(failure_rate) OVER(PARTITION BY brand), 2) AS variance_failure_rate, POW(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand), 2) AS variance_avg_maintenance_cost FROM MaintenanceAnalysis) SELECT brand, quarter, failure_rate, avg_maintenance_cost, SUM(covariance_term) OVER(PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER(PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER(PARTITION BY brand))) AS correlation_coefficient FROM CorrelationCalculation GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN '米饭质量低于平均水平' ELSE '米饭质量正常' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8	rice_cooker	3
SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt	rice_cooker	4
SELECT pt.rice_cooker_id, pt.time_to_boil AS sea_level_time, pt.energy_consumption AS sea_level_energy, pt.energy_consumption * (373 / 363 - 1) AS energy_increase, (373 / 363 - 1) * 100 AS efficiency_loss_percent FROM performance_tests pt	rice_cooker	1
WITH MaintenanceAnalysis AS (SELECT rci.brand, QUARTER(mr.maintenance_date) AS quarter, COUNT(CASE WHEN mr.maintenance_type = 'Repair' THEN 1 END) / COUNT(*) AS failure_rate, SUM(mr.maintenance_cost) / COUNT(*) AS avg_maintenance_cost FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id GROUP BY rci.brand, QUARTER(mr.maintenance_date)), CorrelationCalculation AS (SELECT brand, quarter, failure_rate, avg_maintenance_cost, AVG(failure_rate) OVER(PARTITION BY brand) AS mean_failure_rate, AVG(avg_maintenance_cost) OVER(PARTITION BY brand) AS mean_avg_maintenance_cost, (failure_rate - AVG(failure_rate) OVER(PARTITION BY brand)) * (avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand)) AS covariance_term, POW(failure_rate - AVG(failure_rate) OVER(PARTITION BY brand), 2) AS variance_failure_rate, POW(avg_maintenance_cost - AVG(avg_maintenance_cost) OVER(PARTITION BY brand), 2) AS variance_avg_maintenance_cost FROM MaintenanceAnalysis) SELECT brand, quarter, failure_rate, avg_maintenance_cost, SUM(covariance_term) OVER(PARTITION BY brand) / (SQRT(SUM(variance_failure_rate) OVER(PARTITION BY brand)) * SQRT(SUM(variance_avg_maintenance_cost) OVER(PARTITION BY brand))) AS correlation_coefficient FROM CorrelationCalculation GROUP BY brand, quarter, failure_rate, avg_maintenance_cost;	rice_cooker	2
SELECT ur.id AS usage_id, ur.rice_cooker_id, ur.water_quantity, ur.rice_quantity, ur.water_quantity / ur.rice_quantity AS water_rice_ratio, pt.rice_quality_score, CASE WHEN pt.rice_quality_score < (SELECT AVG(rice_quality_score) FROM performance_tests) THEN '米饭质量低于平均水平' ELSE '米饭质量正常' END AS rice_quality_status FROM usage_records ur LEFT JOIN performance_tests pt ON ur.rice_cooker_id = pt.rice_cooker_id WHERE ur.water_quantity / ur.rice_quantity NOT BETWEEN 1.2 AND 1.8	rice_cooker	3
SELECT pt.rice_cooker_id, pt.energy_consumption, EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) AS tunneling_probability, pt.energy_consumption * EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.0545718e-34) * 1e3 AS energy_loss FROM performance_tests pt	rice_cooker	4
SELECT rci.id AS rice_cooker_id, rci.model, rci.material, pt.final_temperature, CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END AS thermal_stress, CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END AS tensile_strength, CASE WHEN CASE rci.material WHEN 'Stainless Steel' THEN 17.3e-6 * 200e9 * (pt.final_temperature - 25) WHEN 'Ceramic' THEN 4.5e-6 * 350e9 * (pt.final_temperature - 25) WHEN 'Non-stick' THEN 23e-6 * 0.5e9 * (pt.final_temperature - 25) END < CASE rci.material WHEN 'Stainless Steel' THEN 520e6 WHEN 'Ceramic' THEN 40e6 WHEN 'Non-stick' THEN 25e6 END THEN '安全' ELSE '不安全' END AS safety_status FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id	rice_cooker	1
WITH LifecycleCost AS (SELECT rci.brand, rci.price + SUM(mr.maintenance_cost) AS total_cost, COUNT(ur.id) AS usage_count, AVG(pt.rice_quality_score) AS avg_quality_score FROM rice_cooker_info rci LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN performance_tests pt ON rci.id = pt.rice_cooker_id GROUP BY rci.brand, rci.price), NormalizedCost AS (SELECT brand, total_cost / POWER(usage_count * avg_quality_score, 0.5) AS lifecycle_cost, (total_cost / POWER(usage_count * avg_quality_score, 0.5) - MIN(total_cost / POWER(usage_count * avg_quality_score, 0.5)) OVER ()) / (MAX(total_cost / POWER(usage_count * avg_quality_score, 0.5)) OVER () - MIN(total_cost / POWER(usage_count * avg_quality_score, 0.5)) OVER ()) AS normalized_cost FROM LifecycleCost) SELECT brand, lifecycle_cost, normalized_cost, DENSE_RANK() OVER (ORDER BY normalized_cost) AS brand_rank FROM NormalizedCost	rice_cooker	2
WITH CleaningAnalysis AS (SELECT mr.rice_cooker_id, mr.maintenance_date, mr.maintenance_notes, rci.material, DATEDIFF(mr.maintenance_date, LAG(mr.maintenance_date) OVER (PARTITION BY mr.rice_cooker_id ORDER BY mr.maintenance_date)) AS cleaning_interval FROM maintenance_records mr JOIN rice_cooker_info rci ON mr.rice_cooker_id = rci.id) SELECT rice_cooker_id, maintenance_date, maintenance_notes, material, cleaning_interval, CASE WHEN cleaning_interval > 90 THEN '清洁间隔超过3个月' WHEN maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic') THEN '使用酸性清洁剂' ELSE '符合规范' END AS violation_status FROM CleaningAnalysis WHERE cleaning_interval > 90 OR (maintenance_notes LIKE '%acid%' AND material IN ('Stainless Steel', 'Ceramic'))	rice_cooker	3
SELECT pt.rice_cooker_id, pt.final_temperature, (1.05e-34) / (2 * 9.1e-31 * POW(1e-8, 2) * 1.38e-23 * 1e-6) AS ΔT, (1.05e-34) / (2 * 9.1e-31 * POW(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature AS temperature_oscillation_rate, pt.energy_consumption * ((1.05e-34) / (2 * 9.1e-31 * POW(1e-8, 2) * 1.38e-23 * 1e-6) / pt.final_temperature) AS energy_fluctuation FROM performance_tests pt	rice_cooker	4
SELECT ur.rice_cooker_id, rci.power_rating, rci.voltage_rating, ur.energy_consumption, ur.duration, 230 AS V_supply, rci.power_rating * (POW(230, 2) / POW(rci.voltage_rating, 2)) AS P_actual, (ur.energy_consumption * 1000 / (rci.power_rating * (POW(230, 2) / POW(rci.voltage_rating, 2)) * ur.duration / 60)) * POW(rci.voltage_rating / 230, 2) AS η_corrected FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id	rice_cooker	1
WITH QualityDecay AS (SELECT rci.model, YEAR(pt.test_date) AS year, pt.rice_quality_score, MAX(pt.rice_quality_score) OVER(PARTITION BY rci.model) - pt.rice_quality_score AS quality_decay, SUM(mr.maintenance_cost) OVER(PARTITION BY rci.model ORDER BY pt.test_date) AS cumulative_maintenance_cost, COUNT(ur.id) OVER(PARTITION BY rci.model) AS usage_count FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id LEFT JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id) SELECT model, year, rice_quality_score, LN(usage_count) * quality_decay / cumulative_maintenance_cost AS decay_index, DENSE_RANK() OVER(PARTITION BY year ORDER BY LN(usage_count) * quality_decay / cumulative_maintenance_cost DESC) AS annual_rank FROM QualityDecay	rice_cooker	2
CREATE TEMPORARY TABLE temp_voltage_logs (usage_id INT, supply_voltage DECIMAL(5, 2)); INSERT INTO temp_voltage_logs (usage_id, supply_voltage) SELECT ur.id AS usage_id, 200 + RAND() * 40 AS supply_voltage FROM usage_records ur; WITH VoltageLog AS (SELECT ur.rice_cooker_id, ur.id AS usage_id, vl.supply_voltage, rci.voltage_rating, CASE WHEN vl.supply_voltage < 0.9 * rci.voltage_rating OR vl.supply_voltage > 1.1 * rci.voltage_rating THEN '电压异常' ELSE '电压正常' END AS voltage_status, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Power%') THEN '电源模块已更换' ELSE '电源模块未更换' END AS power_module_status FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id JOIN temp_voltage_logs vl ON ur.id = vl.usage_id) SELECT rice_cooker_id, usage_id, supply_voltage, voltage_rating, voltage_status, power_module_status FROM VoltageLog WHERE voltage_status = '电压异常';	rice_cooker	3
SELECT pt.rice_cooker_id, pt.rice_quality_score, pt.energy_consumption, EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)) AS curvature_factor, pt.rice_quality_score * (1 - EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)))) AS quality_distortion, pt.energy_consumption / EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS energy_distortion FROM performance_tests pt	rice_cooker	4
CREATE TEMPORARY TABLE temp_voltage_logs (usage_id INT, supply_voltage DECIMAL(5, 2)); INSERT INTO temp_voltage_logs (usage_id, supply_voltage) SELECT ur.id AS usage_id, 200 + RAND() * 40 AS supply_voltage FROM usage_records ur; WITH VoltageLog AS (SELECT ur.rice_cooker_id, ur.id AS usage_id, vl.supply_voltage, rci.voltage_rating, CASE WHEN vl.supply_voltage < 0.9 * rci.voltage_rating OR vl.supply_voltage > 1.1 * rci.voltage_rating THEN '电压异常' ELSE '电压正常' END AS voltage_status, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%Power%') THEN '电源模块已更换' ELSE '电源模块未更换' END AS power_module_status FROM usage_records ur JOIN rice_cooker_info rci ON ur.rice_cooker_id = rci.id JOIN temp_voltage_logs vl ON ur.id = vl.usage_id) SELECT rice_cooker_id, usage_id, supply_voltage, voltage_rating, voltage_status, power_module_status FROM VoltageLog WHERE voltage_status = '电压异常';	rice_cooker	1
SELECT pt.rice_cooker_id, pt.rice_quality_score, pt.energy_consumption, EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS curvature_factor, pt.rice_quality_score * (1 - EXP(-POWER(0.2, 2) / (8 * POWER(1, 2)))) AS quality_distortion, pt.energy_consumption / EXP(-POWER(0.2, 2) / (8 * POWER(1, 2))) AS energy_distortion FROM performance_tests pt;	rice_cooker	2
SELECT pt.*, (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) AS 温升速率, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = pt.rice_cooker_id AND mr.replaced_parts LIKE '%Thermistor%') THEN '已维护' ELSE '未维护' END AS 维护状态 FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE (pt.final_temperature - pt.initial_temperature) / (pt.time_to_boil * 60) > 0.33 AND ABS(ur.actual_max_temperature - ur.temperature_setting) > 5;	rice_cooker	3
SELECT rci.id AS rice_cooker_id, rci.model, rci.weight, ur.duration AS heating_time, (rci.weight * ur.duration * 60) AS black_hole_mass, (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)) AS schwarzschild_radius, SQRT(1 - (2 * 6.67430e-11 * (rci.weight * ur.duration * 60)) / (POWER(299792458, 2) * (2 * 6.67430e-11 * (rci.weight * ur.duration * 60) / POWER(299792458, 2)))) AS time_dilation_factor, (1.0545718e-34 * POWER(299792458, 3)) / (8 * PI() * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) AS hawking_temperature, (1.0545718e-34 * POWER(299792458, 3)) / (8 * PI() * 6.67430e-11 * (rci.weight * ur.duration * 60) * 1.380649e-23) * ur.energy_consumption AS quantum_energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE ur.temperature_setting >= 1.4e32;	rice_cooker	4
SELECT rci.material, AVG(ur.actual_max_temperature - ur.temperature_setting) / AVG(ur.duration) AS 平均温升速率, AVG(rci.capacity * rci.weight) / (AVG(rci.power_rating) * 1000) AS 热传导时间常数 FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id GROUP BY rci.material;	rice_cooker	1
WITH usage_count AS (SELECT rice_cooker_id, COUNT(*) AS usage_times FROM usage_records GROUP BY rice_cooker_id), maintenance_cost_sum AS (SELECT rice_cooker_id, SUM(maintenance_cost) AS total_maintenance_cost FROM maintenance_records GROUP BY rice_cooker_id), rice_quality_variation AS (SELECT rice_cooker_id, STDDEV(rice_quality_score) / AVG(rice_quality_score) AS rice_quality_cv FROM performance_tests GROUP BY rice_cooker_id) SELECT rci.id AS rice_cooker_id, rci.model, EXP(-mcs.total_maintenance_cost / rci.price) * (1 + LN(uc.usage_times)) * rqv.rice_quality_cv AS health_index, QUARTER(ur.start_time) AS quarter, YEAR(ur.start_time) AS year FROM rice_cooker_info rci JOIN usage_count uc ON rci.id = uc.rice_cooker_id JOIN maintenance_cost_sum mcs ON rci.id = mcs.rice_cooker_id JOIN rice_quality_variation rqv ON rci.id = rqv.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id GROUP BY rci.id, rci.model, mcs.total_maintenance_cost, rci.price, uc.usage_times, rqv.rice_quality_cv, QUARTER(ur.start_time), YEAR(ur.start_time);	rice_cooker	2
WITH usage_sequence AS (SELECT device_id, start_time, end_time, rice_quantity, (julianday(start_time) - julianday(LAG(end_time) OVER(PARTITION BY device_id ORDER BY start_time))) * 1440 AS cooling_interval FROM usage_logs) SELECT us.*, CASE WHEN EXISTS (SELECT 1 FROM maintenance_logs ml WHERE ml.device_id = us.device_id AND ml.maintenance_type = 'Overheat Repair') THEN 1 ELSE 0 END AS has_overheat_repair FROM usage_sequence us WHERE cooling_interval < 15 AND rice_quantity > 0.5 AND start_time > '2023-01-01';	rice_cooker	3
SELECT rci.model, rci.brand, ur.rice_quantity, ur.water_quantity, pt.water_evaporation_rate, pt.rice_quality_score, pt.energy_consumption FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id JOIN performance_tests pt ON rci.id = pt.rice_cooker_id WHERE pt.test_type = '煮饭' AND ur.rice_quantity > 0 AND ur.water_quantity > 0;	rice_cooker	4
SELECT rice_cooker_id, test_date, initial_temperature, final_temperature, energy_consumption, time_to_boil FROM performance_tests WHERE test_type = '保温';	rice_cooker	1
SELECT rc.model, ur.energy_consumption, ROUND(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12)),4) AS maturation_degree, ur.energy_consumption * (1/(1 - EXP(-(POWER(1e9*1.6e-19,2)*POWER(1e-16,3)*1e-23)/(1.38e-23*2e12))) - 1) AS energy_distortion, SQRT(1.38e-23*2e12/(1.05e-34*3e8)) * ur.duration*60 AS quantum_fluctuation FROM rice_cooker_info rc JOIN usage_records ur ON rc.id = ur.rice_cooker_id WHERE ur.duration > 0;	rice_cooker	2
SELECT rc.model, pt.final_temperature, ur.duration, (pt.final_temperature - 25) AS_T, ROUND((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration), 2) AS total_heat_loss_J, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600, 2) AS heat_loss_kWh, ROUND(((0.9 * 5.67e-8 * 0.18 * (POWER(pt.final_temperature + 273, 4) - POWER(298, 4)) * ur.duration) + (12 * 0.18 * (pt.final_temperature - 25) * ur.duration)) / 3600 / (0.1 * rc.power_rating * ur.duration / 60), 2) AS efficiency_ratio FROM rice_cooker_info rc JOIN performance_tests pt ON rc.id = pt.rice_cooker_id JOIN usage_records ur ON rc.id = ur.rice_cooker_id;	rice_cooker	3
WITH monthly_data AS (SELECT rc.brand AS manufacturer, DATE_FORMAT(pt.test_date, '%Y-%m') AS month, (pt.rice_quality_score - AVG(pt.rice_quality_score) OVER()) / (STDDEV(pt.rice_quality_score) OVER()) AS z_score, 1 - (STDDEV(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand) / AVG(ur.energy_consumption / ur.rice_quantity) OVER(PARTITION BY rc.brand)) AS efficiency_variation, SUM(mr.maintenance_cost) OVER(PARTITION BY rc.brand) / rc.price AS maintenance_ratio FROM rice_cooker_info rc LEFT JOIN usage_records ur ON rc.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rc.id = mr.rice_cooker_id JOIN performance_tests pt ON rc.id = pt.rice_cooker_id) SELECT manufacturer, month, ROUND(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio, 2) AS quality_index, AVG(0.5 * z_score + 0.3 * efficiency_variation - 0.2 * maintenance_ratio) OVER(ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS trend FROM monthly_data ORDER BY manufacturer, month;	rice_cooker	4
SELECT ul.id AS usage_id, di.model, ul.rice_quantity, di.capacity, ul.rice_quantity / di.capacity AS overload_ratio, CASE WHEN EXISTS (SELECT 1 FROM maintenance_records ml WHERE ml.rice_cooker_id = ul.rice_cooker_id AND ml.maintenance_notes LIKE '%内胆变形%') THEN 1 ELSE 0 END AS has_deformation FROM usage_records ul JOIN rice_cooker_info di ON ul.rice_cooker_id = di.id WHERE ul.rice_quantity > 1.2 * di.capacity	rice_cooker	1
SELECT di.model, pt.time_to_boil, ul.energy_consumption, ROUND(1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27, 30) AS k_quantum, ROUND(SQRT((1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27) / 0.6), 2) AS time_compression_ratio, ROUND(ul.energy_consumption / SQRT((1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27) / 0.6), 2) AS energy_gain, CASE WHEN ul.energy_consumption < (di.power_rating * pt.time_to_boil / 60 / SQRT((1 * 1e10 * POWER(1.05e-34, 2) / 6.64e-27) / 0.6)) THEN '安全' ELSE '超限' END AS quantum_limit FROM rice_cooker_info di JOIN performance_tests pt ON di.id = pt.rice_cooker_id JOIN usage_records ul ON di.id = ul.rice_cooker_id	rice_cooker	2
SELECT di.model, di.material, pt.time_to_boil AS 实际煮沸时间_min, ROUND(CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END, 2) AS 理论扩散时间_s, ROUND((pt.time_to_boil*60 - CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END) / CASE di.material WHEN 'Stainless Steel' THEN (0.02*0.02)/(4*(16/(7900*500))) WHEN 'Ceramic' THEN (0.02*0.02)/(4*(1.5/(2500*800))) END *100, 1) AS 时间偏差率_percent FROM rice_cooker_info di JOIN performance_tests pt ON di.id = pt.rice_cooker_id WHERE di.material IN ('Stainless Steel','Ceramic')	rice_cooker	3
WITH numbers AS (SELECT (a.n + b.n * 10 + c.n * 100 + d.n * 1000) AS n FROM (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) a CROSS JOIN (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) b CROSS JOIN (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) c CROSS JOIN (SELECT 0 AS n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) d WHERE (a.n + b.n * 10 + c.n * 100 + d.n * 1000) BETWEEN 1 AND 10000), lifetime_simulation AS (SELECT di.id AS device_id, RAND() AS rand_value, EXP(-SUM(0.01 * ul.rice_quantity * (DATEDIFF(ml.maintenance_date, di.production_date)) / 365)) AS survival_probability FROM numbers CROSS JOIN rice_cooker_info di LEFT JOIN maintenance_records ml ON di.id = ml.rice_cooker_id LEFT JOIN usage_records ul ON di.id = ul.rice_cooker_id GROUP BY di.id, numbers.n) SELECT ls.device_id AS id, AVG(CASE WHEN ls.rand_value > ls.survival_probability THEN (DATEDIFF(CURDATE(), di.production_date)) / 365 ELSE 999 END) AS simulated_lifetime FROM lifetime_simulation ls JOIN rice_cooker_info di ON ls.device_id = di.id GROUP BY ls.device_id;	rice_cooker	4
SELECT pt.*, rci.power_rating FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE (pt.time_to_boil < 15 OR rci.power_rating > 1000) AND EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = rci.id AND mr.replaced_parts = '电磁屏蔽组件');	rice_cooker	1
SELECT rci.model, ur.energy_consumption, ROUND(ABS( (POWER(3e8,4)/(8*PI()*6.67e-11)) * POWER(1/3,2) ) / 9.9e-27, 2) AS 能量密度比, CASE WHEN (ur.energy_consumption*3.6e6 / (0.005*0.18)) < ABS( (POWER(3e8,4)/(8*PI()*6.67e-11)) * POWER(1/3,2) ) THEN '满足曲率条件' ELSE '能量不足' END AS 验证结果 FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id JOIN performance_tests pt ON rci.id = pt.rice_cooker_id;	rice_cooker	2
SELECT rci.id, rci.material, pt.final_temperature, ur.rice_quantity, CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.1415926 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.1415926 * 0.0001)) ELSE NULL END AS_t_c, (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.1415926 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.1415926 * 0.0001)) ELSE NULL END AS risk_index, CASE WHEN (pt.final_temperature - 25) / CASE WHEN rci.material = 'Ceramic' THEN (3e6 * (1 - 0.25)) / (4.5e-6 * 350e9 * SQRT(3.1415926 * 0.0001)) WHEN rci.material = 'Stainless Steel' THEN (100e6 * (1 - 0.25)) / (17.3e-6 * 200e9 * SQRT(3.1415926 * 0.0001)) ELSE NULL END < 1 THEN '安全' ELSE '危险' END AS safety_condition FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id JOIN usage_records ur ON rci.id = ur.rice_cooker_id;	rice_cooker	3
WITH standardized_data AS (SELECT rci.brand AS manufacturer, (pt.energy_consumption - MIN(pt.energy_consumption) OVER()) / (MAX(pt.energy_consumption) OVER() - MIN(pt.energy_consumption) OVER()) AS p_energy, (pt.time_to_boil - MIN(pt.time_to_boil) OVER()) / (MAX(pt.time_to_boil) OVER() - MIN(pt.time_to_boil) OVER()) AS p_time, (pt.rice_quality_score - MIN(pt.rice_quality_score) OVER()) / (MAX(pt.rice_quality_score) OVER() - MIN(pt.rice_quality_score) OVER()) AS p_score FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id), entropy_calculation AS (SELECT manufacturer, -SUM(p_energy * LN(p_energy + 1e-9)) / LN(COUNT(*)) AS e_energy, -SUM(p_time * LN(p_time + 1e-9)) / LN(COUNT(*)) AS e_time, -SUM(p_score * LN(p_score + 1e-9)) / LN(COUNT(*)) AS e_score FROM standardized_data GROUP BY manufacturer), weights AS (SELECT manufacturer, (1 - e_energy) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_energy, (1 - e_time) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_time, (1 - e_score) / SUM(1 - e_energy + 1 - e_time + 1 - e_score) OVER() AS w_score FROM entropy_calculation) SELECT sd.manufacturer, SUM(w.w_energy * (1 - sd.p_energy) + w.w_time * sd.p_time + w.w_score * sd.p_score) AS comprehensive_score FROM standardized_data sd JOIN weights w ON sd.manufacturer = w.manufacturer GROUP BY sd.manufacturer;	rice_cooker	4
WITH maintenance_intervals AS (SELECT rice_cooker_id, maintenance_date, LAG(maintenance_date) OVER (PARTITION BY rice_cooker_id ORDER BY maintenance_date) AS prev_date, maintenance_type FROM maintenance_records) SELECT mi.rice_cooker_id, mi.maintenance_date, mi.prev_date, TIMESTAMPDIFF(MINUTE, mi.prev_date, mi.maintenance_date) AS cooling_interval, CASE WHEN mi.maintenance_type = '热熔断复位' AND TIMESTAMPDIFF(MINUTE, mi.prev_date, mi.maintenance_date) < 30 AND EXISTS (SELECT 1 FROM usage_records ul WHERE ul.rice_cooker_id = mi.rice_cooker_id AND ul.temperature_setting > 85) THEN '违规' ELSE '合规' END AS violation_status FROM maintenance_intervals mi;	rice_cooker	1
SELECT rci.id, rci.power_rating, rci.voltage_rating, pt.final_temperature, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) AS L, (rci.power_rating / POWER(rci.voltage_rating, 2)) AS sigma, (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / POWER(rci.voltage_rating, 2)) * (pt.final_temperature + 273) AS k_quantum, CASE WHEN (1.38e-23 * 1.38e-23 / (1.6e-19 * 1.6e-19)) * (3.1415926 * 3.1415926 / 3) * POWER(1e7 * 0.0001 * 10, 2) * (rci.power_rating / POWER(rci.voltage_rating, 2)) * (pt.final_temperature + 273) > 5000 THEN '异常' ELSE '正常' END AS thermal_conductivity_anomaly FROM rice_cooker_info rci JOIN performance_tests pt ON rci.id = pt.rice_cooker_id;	rice_cooker	2
WITH calibration_records AS (SELECT 1 AS rice_cooker_id, '2023-01-15' AS calibration_date, 1.5 AS calibration_error UNION ALL SELECT 2, '2022-12-20', 2.5 UNION ALL SELECT 3, '2023-03-10', 0.8) SELECT pt.id, pt.test_date, cr.calibration_date, ABS(cr.calibration_error) AS calibration_error, ABS(pt.final_temperature - pt.initial_temperature) AS temperature_deviation, CASE WHEN DATEDIFF(pt.test_date, cr.calibration_date) > 365 THEN '校准超期' WHEN ABS(cr.calibration_error) > 2 THEN '误差超标' WHEN ABS(pt.final_temperature - pt.initial_temperature) > 5 THEN '温度偏差' ELSE '正常' END AS violation_status FROM performance_tests pt JOIN calibration_records cr ON pt.rice_cooker_id = cr.rice_cooker_id;	rice_cooker	3
SELECT pt.id, pt.energy_consumption, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) AS P, (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 AS energy_gain, CASE WHEN (9.87 * 1.05e-34 * 3e8) / (240 * POWER(1e-9, 4)) * 0.01 * 3600 > pt.energy_consumption * 3.6e6 THEN '满足' ELSE '不满足' END AS quantum_condition FROM performance_tests pt;	rice_cooker	4
SELECT pt.time_to_boil AS t_earth, (pt.time_to_boil * (75 / (1/3 * 240)) * ((2260 / (75 * 1)) + 1) / ((2260 / (1/3 * 240 * 1)) + 1)) AS t_moon FROM performance_tests pt JOIN rice_cooker_info ri ON pt.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';	rice_cooker	1
SELECT ri.brand, 1 - EXP(-POWER(5 / 8, 2.5)) AS failure_probability_5_years, 8 * POWER(LN(2), 1 / 2.5) AS median_lifetime FROM rice_cooker_info ri GROUP BY ri.brand;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN '米水比异常' WHEN (SELECT STDDEV(pt.final_temperature) FROM performance_tests pt WHERE pt.rice_cooker_id = ur.rice_cooker_id) > 5 THEN '加热不均' WHEN ABS(AVG(ur.actual_max_temperature) - AVG(ur.temperature_setting)) > 5 THEN '温控偏差' WHEN EXISTS (SELECT 1 FROM maintenance_records mr WHERE mr.rice_cooker_id = ur.rice_cooker_id AND mr.replaced_parts LIKE '%内胆涂层%') THEN '涂层脱落' ELSE '其他原因' END AS possible_cause FROM usage_records ur GROUP BY ur.rice_cooker_id, ur.rice_quantity, ur.water_quantity;	rice_cooker	3
SELECT EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS tunneling_probability, 1 / EXP(-2 * 1e-9 * SQRT(2 * 9.11e-31 * 5 * 1.6e-19) / 1.05e-34) AS efficiency_increase FROM rice_cooker_info;	rice_cooker	4
SELECT pt.water_evaporation_rate, ur.energy_consumption, (ur.energy_consumption * ri.power_rating * (2260e3/461.5)*(1/363 - 1/373)/ri.power_rating) / (ur.water_quantity * 4.18 * 65 + pt.water_evaporation_rate * 2260) AS efficiency_correction FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id WHERE pt.test_type = 'Boiling';	rice_cooker	1
WITH user_features AS (SELECT rice_cooker_id, COUNT(*) AS usage_frequency, AVG(rice_quantity) AS avg_rice_quantity, AVG(duration) AS avg_duration FROM usage_records GROUP BY rice_cooker_id) SELECT rice_cooker_id, usage_frequency, avg_rice_quantity, avg_duration, CASE WHEN usage_frequency > 10 AND avg_duration < 30 THEN '频繁快煮' WHEN usage_frequency BETWEEN 5 AND 10 AND avg_rice_quantity > 1 THEN '定时预约' WHEN avg_duration > 60 THEN '保温依赖' ELSE '其他' END AS user_category FROM user_features;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.water_quantity / ri.capacity > 1.2 THEN '水位异常' WHEN ur.rice_type NOT IN ('White Rice', 'Brown Rice') THEN '米种不适配' WHEN HOUR(ur.start_time) BETWEEN 18 AND 20 THEN '高峰时段使用' ELSE '其他' END AS misoperation_type FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;	rice_cooker	3
SELECT LN(1 - (2.8e6 / (1e-25 * 0.9))) / LN(1 - EXP(-1/1e-6)) AS required_qubits FROM rice_cooker_info WHERE id IS NOT NULL;	rice_cooker	4
SELECT ri.power_rating, pt.initial_temperature, (0.9*5.67e-8*0.15*(POW(373,4)-POW(233,4)))*((25*3.5*4180)/(ri.power_rating - (0.9*5.67e-8*0.15*(POW(373,4)-POW(233,4))))) AS extra_energy FROM rice_cooker_info ri JOIN performance_tests pt ON ri.id = pt.rice_cooker_id WHERE pt.test_type = 'Boiling';	rice_cooker	1
WITH fuzzy_data AS ( SELECT ur.rice_cooker_id, COUNT(*)/30.0 AS usage_freq, AVG(ABS(ur.actual_max_temperature - ur.temperature_setting)) AS temp_deviation, DATEDIFF(MAX(mr.maintenance_date), MIN(mr.maintenance_date))/30.0 AS maintenance_interval FROM usage_records ur LEFT JOIN maintenance_records mr ON ur.rice_cooker_id = mr.rice_cooker_id GROUP BY ur.rice_cooker_id ) SELECT rice_cooker_id, CASE WHEN usage_freq > 0.8 AND temp_deviation > 5 THEN '高风险' WHEN usage_freq BETWEEN 0.5 AND 0.8 OR maintenance_interval > 6 THEN '中风险' ELSE '低风险' END AS risk_level FROM fuzzy_data;	rice_cooker	2
SELECT ur.rice_cooker_id, CASE WHEN ur.rice_quantity / ur.water_quantity NOT BETWEEN 0.56 AND 0.83 THEN '米水比异常(合理范围1:1.2-1:1.8)' WHEN (ur.rice_quantity + ur.water_quantity) > ri.capacity THEN '总量超容(超过电饭煲容量)' WHEN ri.power_rating > 1000 THEN '功率过高(>1000W)' ELSE '其他原因' END AS overflow_reason FROM usage_records ur JOIN rice_cooker_info ri ON ur.rice_cooker_id = ri.id;	rice_cooker	3
SELECT POWER(5e-3,2)/(4*0.6) AS characteristic_length, CEIL((pt.final_temperature - pt.initial_temperature)/5 * SQRT(ur.energy_consumption)) AS iterations FROM performance_tests pt JOIN usage_records ur ON pt.rice_cooker_id = ur.rice_cooker_id WHERE pt.test_type = 'Boiling';	rice_cooker	4
SELECT (5 * 4200 * 75) / (power_rating) / 60 AS theoretical_time_minutes FROM rice_cooker_info WHERE model = 'RC-2002';	rice_cooker	1
SELECT rci.model, SUM(ur.energy_consumption) AS total_energy, COUNT(*) AS usage_count FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id WHERE rci.brand = 'BrandY' AND YEAR(ur.start_time) = 2023 GROUP BY rci.model ORDER BY total_energy DESC LIMIT 5;	rice_cooker	2
SELECT model, brand, price FROM rice_cooker_info WHERE capacity > 4 AND power_rating < 800;	rice_cooker	3
SELECT 5000 * (30 / 3600) AS energy_consumption_kwh;	rice_cooker	4
SELECT pt.energy_consumption / ((1.5 * 4.18 + 1.2 * 1.8) * 75) AS thermal_efficiency FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id WHERE rci.model = 'RC-3003' AND pt.final_temperature = 100 LIMIT 1;	rice_cooker	1
SELECT rci.brand, rci.model, STDDEV(pt.rice_quality_score)/AVG(pt.rice_quality_score) AS cv FROM performance_tests pt JOIN rice_cooker_info rci ON pt.rice_cooker_id = rci.id GROUP BY rci.brand, rci.model HAVING cv > 0.25;	rice_cooker	2
SELECT rci.model FROM rice_cooker_info rci JOIN usage_records ur ON rci.id = ur.rice_cooker_id LEFT JOIN maintenance_records mr ON rci.id = mr.rice_cooker_id AND mr.maintenance_type = 'Cleaning' WHERE ur.start_time >= DATE_SUB(CURDATE(), INTERVAL 2 YEAR) GROUP BY rci.id HAVING COUNT(ur.id) > 10 AND COUNT(mr.id) = 0;	rice_cooker	3
SELECT 30000 / 220 AS current_strength;	rice_cooker	4
SELECT (DissolvedOxygenMgL / 8.24) * 100 AS DissolvedOxygenSaturation FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, POWER(10, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 7.0 AND TemperatureCelsius = 15 AND ConductivityUsCm = 300;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 THEN '不适合鱼类生存' WHEN DissolvedOxygenMgL < 5 THEN '不适合鱼类生存' WHEN TurbidityNTU > 25 THEN '不适合鱼类生存' ELSE '适合鱼类生存' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.ConductivityUsCm, POWER(10, -WQD.PHValue) AS H_ion_concentration, POWER(10, -(14 - WQD.PHValue)) AS OH_ion_concentration, (POWER(10, -WQD.PHValue) * POWER(10, -(14 - WQD.PHValue)) * WQD.ConductivityUsCm) AS IAP FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01' AND WQD.PHValue = 15 AND WQD.DissolvedOxygenMgL = 1000 AND WQD.TurbidityNTU = 10000;	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.64 AS EstimatedTDS FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, POWER(10, -PHValue) AS H_Concentration FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.8;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 9.0 THEN '不适合鱼类生存' WHEN DissolvedOxygenMgL < 5 THEN '不适合鱼类生存' ELSE '适合鱼类生存' END AS WaterQualityStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, CASE WHEN WQD.PHValue = 0 OR WQD.DissolvedOxygenMgL = 2000 OR WQD.TurbidityNTU = 50000 THEN '不符合常规水质标准' ELSE '符合常规水质标准' END AS WaterQualityStatus FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.7 AS TDSConcentration FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) AS IonStrength, CASE WHEN 0.5 * ((1 * POWER(1, 2)) + (1.5 * POWER(-1, 2))) > 0.1 THEN '高离子强度' ELSE '非高离子强度' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 6.2 AND TemperatureCelsius = 20 AND ConductivityUsCm = 450;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.5 OR PHValue > 8.5 THEN '不适合作为饮用水源' WHEN DissolvedOxygenMgL < 5 THEN '不适合作为饮用水源' WHEN TurbidityNTU > 5 THEN '不适合作为饮用水源' ELSE '适合作为饮用水源' END AS DrinkingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -5 OR WQD.DissolvedOxygenMgL = 50000 OR WQD.TurbidityNTU = 1000000 OR WQD.TemperatureCelsius = 200 OR WQD.ConductivityUsCm = 1000000 THEN '不可能存在于自然界中' ELSE '可能存在于自然界中' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT (100 * 2) AS Alk_CO3, 200 AS Alk_HCO3, (100 * 2 + 200) AS Total_Alkalinity FROM WaterQualityData WHERE MonitorId = 1 AND DATE(CollectionTime) = '2023-10-01';	WaterQualityMonitor	1
SELECT PHValue, TemperatureCelsius, ConductivityUsCm, 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) AS IonStrength, CASE WHEN 0.5 * ((50 * POWER(1, 2)) + (20 * POWER(1, 2)) + (100 * POWER(2, 2)) + (50 * POWER(2, 2)) + (150 * POWER(-1, 2)) + (200 * POWER(-2, 2))) > 0.1 THEN '高离子强度' ELSE '非高离子强度' END AS IonStrengthCategory FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = '2023-10-01 00:00:00' AND PHValue = 8.0 AND TemperatureCelsius = 30 AND ConductivityUsCm = 800;	WaterQualityMonitor	2
SELECT CASE WHEN PHValue < 6.0 OR PHValue > 9.0 THEN '不适合作为工业冷却水' WHEN DissolvedOxygenMgL < 4 THEN '不适合作为工业冷却水' WHEN TurbidityNTU > 20 THEN '不适合作为工业冷却水' WHEN TemperatureCelsius > 40 THEN '不适合作为工业冷却水' ELSE '适合作为工业冷却水' END AS CoolingWaterStatus FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime = (SELECT MAX(CollectionTime) FROM WaterQualityData WHERE MonitorId = 1);	WaterQualityMonitor	3
SELECT WQD.Id, WQD.CollectionTime, WQD.PHValue, WQD.DissolvedOxygenMgL, WQD.TurbidityNTU, WQD.TemperatureCelsius, WQD.ConductivityUsCm, CASE WHEN WQD.PHValue = -10 OR WQD.DissolvedOxygenMgL = 100000 OR WQD.TurbidityNTU = 10000000 OR WQD.TemperatureCelsius = 500 OR WQD.ConductivityUsCm = 10000000 THEN '不可能存在于自然界中' ELSE '可能存在于自然界中' END AS NaturalPossibility FROM WaterQualityData WQD WHERE WQD.MonitorId = 1 AND WQD.CollectionTime = '2023-10-01';	WaterQualityMonitor	4
SELECT CASE WHEN DissolvedOxygenMgL >= 8.24 THEN '已达到饱和状态' ELSE '未达到饱和状态' END AS SaturationStatus FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND DissolvedOxygenMgL = 8;	WaterQualityMonitor	1
SELECT AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN TurbidityNTU < 5 THEN '适合直接饮用' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 50;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND PHValue > 8.5 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30 AND ConductivityUsCm = 2000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 4 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2.5 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 50 AND DissolvedOxygenMgL = 2;	WaterQualityMonitor	1
WITH FilteredData AS (SELECT PHValue FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW() AND PHValue BETWEEN 6.0 AND 8.0) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW())) AS PercentageInRange, AVG(PHValue) - (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.96 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM FilteredData;	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN '合理' ELSE '不合理' END AS TDSReasonability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 2000 AND ConductivityUsCm = 3000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * POWER(TemperatureCelsius, 2) - 0.000077774 * POWER(TemperatureCelsius, 3)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 80 AND DissolvedOxygenMgL = 1;	WaterQualityMonitor	1
WITH LogTransformedData AS (SELECT LN(TurbidityNTU) AS LogTurbidity FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 365 DAY) AND NOW()), FilteredData AS (SELECT TurbidityNTU FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 365 DAY) AND NOW() AND TurbidityNTU > 50) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 365 DAY) AND NOW())) AS PercentageAboveThreshold, EXP(AVG(LogTurbidity) - (2.576 * (STDDEV(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS LowerBound, EXP(AVG(LogTurbidity) + (2.576 * (STDDEV(LogTurbidity) / SQRT(COUNT(LogTurbidity))))) AS UpperBound FROM LogTransformedData;	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus, '潜在污染来源可能包括农业 runoff、工业废水或生活污水。' AS PotentialSources FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 10 AND NitrateNitrogenMgL = 100;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35 AND DissolvedOxygenMgL = 4;	WaterQualityMonitor	1
WITH FilteredData AS (SELECT PHValue FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW() AND PHValue BETWEEN 7.0 AND 8.0) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW())) AS PercentageInRange, AVG(PHValue) - (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS LowerBound, AVG(PHValue) + (1.645 * (STDDEV(PHValue) / SQRT(COUNT(PHValue)))) AS UpperBound FROM FilteredData;	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN '合理' ELSE '不合理' END AS TDSReasonability, CASE WHEN TotalDissolvedSolidsMgL NOT BETWEEN ConductivityUsCm * 0.5 AND ConductivityUsCm * 0.8 THEN '可能原因：水体中存在异常离子或测量误差。' ELSE '无异常' END AS ReasonExplanation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1500 AND ConductivityUsCm = 2000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 6;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 3 DAY) AND NOW();	WaterQualityMonitor	2
SELECT ROUND((COUNT(CASE WHEN TurbidityNTU > 20 THEN 1 END) * 100.0 / COUNT(*)), 2) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 3 DAY) AND NOW();	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT (EXP(7.7117 - 1.31403 * LN(TemperatureCelsius + 45.93)) - DissolvedOxygenMgL) AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 10 AND DissolvedOxygenMgL = 9;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.8 AND 7.2 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.3 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT POWER(10, -PHValue) AS HydrogenIonConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND PHValue = 6.5;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue BETWEEN 6.5 AND 7.5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 THEN '适合直接饮用，但接近碱性边缘，长期饮用需谨慎' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * POWER(TemperatureCelsius, 2) - 0.000077774 * POWER(TemperatureCelsius, 3)) AS SaturatedOxygen, (14.652 - 0.41022 * TemperatureCelsius + 0.007991 * POWER(TemperatureCelsius, 2) - 0.000077774 * POWER(TemperatureCelsius, 3)) - DissolvedOxygenMgL AS OxygenDeficit FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 20 AND DissolvedOxygenMgL = 8;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN DissolvedOxygenMgL < 5 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageBelowThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN DissolvedOxygenMgL > 5 THEN '适合鱼类生存' ELSE '不适合鱼类生存，溶解氧浓度接近临界值' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND DissolvedOxygenMgL = 4;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND DissolvedOxygenMgL < 5 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT TurbidityNTU * 2.5 AS SuspendedSolidsConcentration FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 15 AND TurbidityNTU = 50;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TurbidityNTU > 40 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN TurbidityNTU < 5 THEN '适合直接饮用' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU = 100;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TurbidityNTU > 10 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT 1000 * 4.18 * (30 - 20) AS HeatRequired FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 30;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TemperatureCelsius > 35 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 5 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN TemperatureCelsius BETWEEN 15 AND 30 THEN '适合鱼类生存' ELSE '不适合鱼类生存，水温过高' END AS FishSurvivalSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 35;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius > 40 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT ConductivityUsCm * 0.67 AS EstimatedTDSMgL FROM WaterQualityData WHERE MonitorId = 1 AND TemperatureCelsius = 25 AND ConductivityUsCm = 500;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN ConductivityUsCm > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN ConductivityUsCm BETWEEN 500 AND 1500 THEN '适合直接饮用，但需进一步检测溶解固体含量' ELSE '不适合直接饮用' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm = 1000;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND ConductivityUsCm > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT CASE WHEN TotalDissolvedSolidsMgL = ConductivityUsCm * 0.67 THEN '合理' ELSE '不合理' END AS TDSValidation FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 500 AND ConductivityUsCm = 750;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN TotalDissolvedSolidsMgL > 600 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN TotalDissolvedSolidsMgL BETWEEN 500 AND 1000 THEN '适合直接饮用' ELSE '不适合直接饮用，TDS浓度超出标准' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL = 1200;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND TotalDissolvedSolidsMgL > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT AmmoniaNitrogenMgL + NitrateNitrogenMgL AS TotalNitrogen FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 2 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN (AmmoniaNitrogenMgL + NitrateNitrogenMgL) > 12 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50 THEN '超过安全限值' ELSE '未超过安全限值' END AS SafetyStatus FROM WaterQualityData WHERE MonitorId = 1 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT CASE WHEN PHValue < 7 THEN '氨氮主要以NH4+形式存在' ELSE '氨氮主要以NH3形式存在' END AS AmmoniaForm, CASE WHEN NitrateNitrogenMgL > 5 THEN '硝酸盐氮浓度较高，可能对水体生态系统造成负面影响' ELSE '硝酸盐氮浓度正常' END AS NitrateImpact FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 6.5 AND AmmoniaNitrogenMgL = 1.5 AND NitrateNitrogenMgL = 10;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN PHValue < 6.5 AND AmmoniaNitrogenMgL > 1.5 AND NitrateNitrogenMgL > 10 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageConditionMet FROM WaterQualityData WHERE MonitorId = 1 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 7 DAY) AND NOW();	WaterQualityMonitor	2
SELECT CASE WHEN PHValue BETWEEN 6.5 AND 8.5 AND AmmoniaNitrogenMgL <= 0.5 AND NitrateNitrogenMgL <= 50 THEN '适合直接饮用' ELSE '不适合直接饮用，需进一步检测' END AS DrinkingSuitability FROM WaterQualityData WHERE MonitorId = 1 AND PHValue = 8.5 AND AmmoniaNitrogenMgL = 0.8 AND NitrateNitrogenMgL = 20;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = 1 AND (PHValue < 6.5 OR PHValue > 8.5 OR AmmoniaNitrogenMgL > 0.5 OR NitrateNitrogenMgL > 50) AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT POWER(10, -PHValue) AS HydrogenIonConcentration, CASE WHEN PHValue > 8.5 THEN '水体呈强碱性，可能影响水生生物生存和水质安全' ELSE '水体pH值正常' END AS WaterQualityImpact FROM WaterQualityData WHERE PHValue > 8.5;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningRule;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = '溶解氧' AND ThresholdValue = 5 AND ConditionOperator = '<';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT CASE WHEN ConductivityUsCm > 1000 THEN '电导率过高，表明水体中离子浓度较高，可能影响水质和生态系统' ELSE '电导率正常' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT CASE WHEN PHValue > 8.5 THEN '碳酸盐缓冲系统可能失效，导致水体pH值波动加剧，影响水质稳定性' ELSE '碳酸盐缓冲系统正常，水质稳定' END AS BufferSystemImpact FROM WaterQualityData WHERE PHValue > 8.5;	WaterQualityMonitor	1
WITH FilteredData AS (SELECT SeverityLevel FROM WaterQualityWarningRule WHERE SeverityLevel > 8) SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM WaterQualityWarningRule)) AS PercentageAboveThreshold, AVG(SeverityLevel) - (1.96 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS LowerBound, AVG(SeverityLevel) + (1.96 * (STDDEV(SeverityLevel) / SQRT(COUNT(SeverityLevel)))) AS UpperBound FROM FilteredData;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = '溶解氧' AND ThresholdValue = 5 AND ConditionOperator = '<';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TurbidityNTU > 1000 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT CASE WHEN ConductivityUsCm > 1000 THEN '电导率过高，表明水体中离子浓度较高，可能影响水质的化学平衡和生态系统的健康' ELSE '电导率正常' END AS ConductivityImpact FROM WaterQualityData WHERE ConductivityUsCm > 1000;	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel BETWEEN 4 AND 7 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageInRange FROM WaterQualityWarningRule;	WaterQualityMonitor	2
SELECT RuleName, ParameterType, ThresholdValue, ConditionOperator, RuleDescription FROM WaterQualityWarningRule WHERE ParameterType = '氨氮' AND ThresholdValue = 0.5 AND ConditionOperator = '>';	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE TemperatureCelsius > 40 AND CollectionTime BETWEEN DATE_SUB(NOW(), INTERVAL 1 DAY) AND NOW();	WaterQualityMonitor	4
SELECT POWER(10, -TriggerValue) AS HydrogenIonConcentration, CASE WHEN TriggerValue > 7 THEN '水体呈碱性，可能影响水生生物生存和水质安全' ELSE '水体pH值正常' END AS WaterQualityImpact FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 8.75 AND TriggerUnit = 'pH';	WaterQualityMonitor	1
SELECT (COUNT(CASE WHEN SeverityLevel > 8 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageAboveThreshold FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 3.80 AND SeverityLevel = 7;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 1000 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	WaterQualityMonitor	4
SELECT POWER(10, -TriggerValue) AS HydrogenIonConcentration FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 7.5 AND TriggerUnit = 'pH';	WaterQualityMonitor	1
SELECT AVG(SeverityLevel) AS AverageSeverity FROM WaterQualityWarningTriggerRecord;	WaterQualityMonitor	2
SELECT TriggerValue, SeverityLevel, ActionTaken, TriggerDescription FROM WaterQualityWarningTriggerRecord WHERE TriggerValue = 0.60 AND SeverityLevel = 9;	WaterQualityMonitor	3
SELECT COUNT(*) AS WarningCount FROM WaterQualityData WHERE MonitorId = (SELECT Id FROM WaterQualityMonitor WHERE MonitorModel = 'YourMonitorModel') AND TurbidityNTU > 5 AND CollectionTime BETWEEN '2023-01-01 00:00:00' AND '2023-01-02 00:00:00';	WaterQualityMonitor	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT Power, (Power * 10 * 30 * 0.5) AS Monthly_Cost FROM pump_specifications WHERE Voltage = 220 AND Current = 5;	waterPump	4
SELECT Pump_ID, Purchase_date, Warranty_Period, DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date, CASE WHEN '2023-06-01' <= DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;	waterPump	4
SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 10000;	waterPump	4
SELECT Voltage * Current / 1000 AS Power FROM pump_specifications WHERE Voltage = 1000000 AND Current = 10000;	waterPump	1
SELECT Power * 100 * 30 * 0.5 AS Monthly_Electricity_Cost FROM pump_specifications WHERE Voltage = 1000000 AND Current = 10000;	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT Power * Usage_Hours AS Total_Energy_Consumption FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15 AND Voltage = 220 AND Current = 30;	waterPump	4
SELECT DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2023-01-15' AND Warranty_Period = 24;	waterPump	1
SELECT (Flow_Rate * Head * 9.81 * 1000) / (Power * 3600 * 1000) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;	waterPump	2
SELECT Power FROM pump_specifications WHERE Flow_Rate = 50 AND Head = 30;	waterPump	3
SELECT 5 * 8 * 365 AS total_energy_consumption_kWh, 5 * 8 * 365 * 0.8 AS total_cost_RMB;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Purchase_date, p.Warranty_Period, p.Location, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, (p.Warranty_Period * 30 * 24) AS Warranty_Hours FROM pumps p JOIN usage_records u ON p.Pump_ID = u.Pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID HAVING Total_Usage_Hours >= Warranty_Hours;	waterPump	3
SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Power_Required FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Efficiency = 200;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, SUM(u.Usage_Hours) AS Total_Usage_Hours, MAX(m.Maintenance_Date) AS Last_Maintenance_Date, DATE_ADD(p.Purchase_date, INTERVAL p.Warranty_Period MONTH) AS Warranty_End_Date FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID LEFT JOIN maintenance_records m ON p.Pump_ID = m.pump_ID WHERE p.Status = 'active' GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period HAVING (Total_Usage_Hours > 1000 OR Last_Maintenance_Date IS NULL OR DATEDIFF(CURDATE(), Last_Maintenance_Date) > 180) AND CURDATE() < Warranty_End_Date;	waterPump	1
SELECT (10000 * 1000 * 9.81) / (3600 * Efficiency) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;	waterPump	2
SELECT pumps.Pump_ID, Model_Number, Manufacturer, (Flow_Rate * Head * 9.81 * 1000) / 3600 AS Hydraulic_Power FROM pump_specifications JOIN pumps ON pump_specifications.Pump_ID = pumps.Pump_ID;	waterPump	4
SELECT Pump_ID, Power * (Efficiency / 100) AS Actual_Output_Power FROM pump_specifications;	waterPump	1
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, (ps.Flow_Rate * ps.Head * 9.81 / 3600) / (ps.Efficiency / 100) AS Theoretical_Power FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE ps.Flow_Rate = 10000 AND ps.Head = 1000;	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT (Flow_Rate * Head * 9.81 * (Efficiency / 100)) / 3600 AS Power_kW FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 80 AND Efficiency = 85;	waterPump	4
SELECT Power * 1 AS Electricity_Consumption FROM pump_specifications WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15;	waterPump	1
SELECT (Flow_Rate * Head * 100) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 10000;	waterPump	2
SELECT Power FROM pump_specifications WHERE Voltage = 220 AND Current = 10;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 5;	waterPump	1
SELECT (1000000 * 5000) / 1000 AS Power_kW;	waterPump	2
SELECT (Voltage * Current * 0.8) / 1000 AS Actual_Power FROM pump_specifications WHERE Current = 10 AND Voltage = 220;	waterPump	3
SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Theoretical_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Efficiency = 80;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Location, ps.Current, ps.Voltage, ps.Power, mr.Maintenance_Type, mr.Description, ur.Usage_Hours, ur.Notes FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.pump_ID LEFT JOIN usage_records ur ON p.Pump_ID = ur.pump_ID WHERE ps.Current >= (SELECT 2 * AVG(Current) FROM pump_specifications WHERE Pump_ID = p.Pump_ID) AND p.Status = 'active';	waterPump	1
SELECT (1000 * 10000 * 1) / 1000 AS Actual_Power;	waterPump	2
SELECT (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600 AS Output_Power_kW FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Efficiency = 85;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Power = 10 AND Voltage = 220 AND Current = 50;	waterPump	1
SELECT (Flow_Rate * Head * 9.81 * (Efficiency / 100)) / 3600 AS Output_Power FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Efficiency = 200;	waterPump	3
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	4
SELECT DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 24;	waterPump	1
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	2
SELECT (Flow_Rate * Head * 9.81) / (Power * 3600) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000000 AND Head = 10000 AND Power = 1000000;	waterPump	3
SELECT p.Pump_ID, p.Model_Number, SUM(mr.Cost) AS Total_Maintenance_Cost, SUM(ur.Usage_Hours) AS Total_Usage_Hours FROM pumps p JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID WHERE mr.Maintenance_Date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND ur.Start_Time >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY p.Pump_ID, p.Model_Number ORDER BY Total_Maintenance_Cost DESC, Total_Usage_Hours DESC;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, COUNT(mr.record_ID) AS Maintenance_Count, SUM(u.Usage_Hours) AS Total_Usage_Hours FROM pumps p LEFT JOIN maintenance_records mr ON p.Pump_ID = mr.pump_ID LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' GROUP BY p.Pump_ID, p.Model_Number, p.Status HAVING Maintenance_Count > 5 OR Total_Usage_Hours > 1000;	waterPump	2
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer, p.Location, p.Status, ps.Flow_Rate, ps.Head, ps.Power, ps.Voltage, ps.Current, ps.Efficiency, mr.Maintenance_Date, mr.Maintenance_Type, mr.Description, mr.Technician, mr.Cost, ur.Start_Time, ur.End_Time, ur.Usage_Hours, ur.Notes FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN maintenance_records mr ON p.Pump_ID = mr.Pump_ID JOIN usage_records ur ON p.Pump_ID = ur.Pump_ID WHERE mr.Cost > (SELECT AVG(Cost) * 100 FROM maintenance_records WHERE Pump_ID = p.Pump_ID) ORDER BY mr.Maintenance_Date DESC;	waterPump	3
SELECT SUM(ps.Power * u.Usage_Hours) AS Total_Energy_Consumption FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE p.Pump_ID = '11' AND YEAR(u.Start_Time) = YEAR(CURDATE());	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period, SUM(u.Usage_Hours) AS Total_Usage_Hours, CASE WHEN SUM(u.Usage_Hours) > 1000 OR DATE_ADD(p.Purchase_date, INTERVAL p.Warranty_Period MONTH) < CURDATE() THEN '需要维护' ELSE '无需维护' END AS Maintenance_Status FROM pumps p LEFT JOIN usage_records u ON p.Pump_ID = u.pump_ID GROUP BY p.Pump_ID, p.Model_Number, p.Status, p.Purchase_date, p.Warranty_Period;	waterPump	4
SELECT (Flow_Rate * Head * 9.81) / (Efficiency / 100) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;	waterPump	1
SELECT (10000 * 1000 * 9.81) / (3600 * Efficiency) AS Required_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000;	waterPump	2
SELECT SUM(ps.Power * u.Usage_Hours) AS Total_Energy_Consumption_kWh FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID JOIN usage_records u ON p.Pump_ID = u.pump_ID WHERE u.Start_Time >= '2023-01-01 00:00:00' AND u.End_Time <= '2023-12-31 23:59:59';	waterPump	4
SELECT AVG(monthly_cost) AS average_monthly_maintenance_cost FROM (SELECT SUM(Cost) / 12 AS monthly_cost FROM maintenance_records WHERE Maintenance_Date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY YEAR(Maintenance_Date), MONTH(Maintenance_Date)) AS monthly_costs;	waterPump	1
SELECT Pump_ID, (10000 * Head * 9.81) / (Efficiency / 100) / 3600 AS New_Power FROM pump_specifications;	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10;	waterPump	3
SELECT Power * 24 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 200 AND Head = 30 AND Power = 15;	waterPump	4
SELECT Pump_ID, Model_Number, Manufacturer, Purchase_date, Warranty_Period, Location, Status, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) < NOW() THEN 'Out of Warranty' ELSE 'Under Warranty' END AS Warranty_Status FROM pumps WHERE Pump_ID IN (SELECT Pump_ID FROM usage_records WHERE Usage_Hours > (Warranty_Period * 30 * 24));	waterPump	2
SELECT Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;	waterPump	4
SELECT SUM(Power * Usage_Hours) AS Total_Energy_Consumption FROM usage_records JOIN pump_specifications ON usage_records.pump_ID = pump_specifications.Pump_ID WHERE pump_specifications.Flow_Rate = 200 AND pump_specifications.Head = 30 AND pump_specifications.Power = 15 AND usage_records.Usage_Hours = 8 * 365;	waterPump	1
SELECT (Flow_Rate * Head * 10 * 1000) / (Power * 3600 * 1000) * 100 AS Efficiency FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000;	waterPump	3
	waterPump	4
	waterPump	2
SELECT 1000 * 24 * 365 * 100 AS Total_Energy_Consumption;	waterPump	2
SELECT ps.Pump_ID, SUM(ps.Power * 8 * 365) AS Total_Energy_Consumption FROM pump_specifications ps JOIN pumps p ON ps.Pump_ID = p.Pump_ID WHERE p.Status = 'active' GROUP BY ps.Pump_ID;	waterPump	3
WITH MaintenanceCosts AS (SELECT Cost FROM maintenance_records WHERE pump_ID = '指定的水泵ID' ORDER BY Maintenance_Date DESC LIMIT 10) SELECT AVG(Cost) AS Average_Maintenance_Cost, AVG(Cost) * 5 * 10 AS Predicted_Total_Maintenance_Cost_Next_5_Years FROM MaintenanceCosts;	waterPump	4
SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) >= '2023-01-01' THEN '在保修期内' ELSE '不在保修期内' END AS Warranty_Status FROM pumps WHERE Purchase_date = '2021-01-01' AND Warranty_Period = 24;	waterPump	1
SELECT Power AS Theoretical_Output_Power, (Flow_Rate * Head * 9.81) / 3600 AS Actual_Output_Power, Efficiency FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000 AND Voltage = 10000 AND Current = 1000 AND Efficiency = 200;	waterPump	2
SELECT Power * Efficiency / 100 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 500 AND Head = 80 AND Power = 100 AND Voltage = 380 AND Current = 150 AND Efficiency = 85;	waterPump	3
SELECT (Power * (Usage_Hours * 30) * 0.8) AS monthly_electricity_cost FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 300 AND Head = 50 AND Power = 75 AND Voltage = 400 AND Current = 120 AND Efficiency = 90 AND Usage_Hours = 10;	waterPump	4
SELECT p.Pump_ID, p.Model_Number, p.Manufacturer FROM pumps p JOIN pump_specifications ps ON p.Pump_ID = ps.Pump_ID WHERE ps.Flow_Rate >= 200 AND ps.Head >= 30 AND ps.Power >= 50 AND ps.Voltage = 220 AND ps.Current = 200 AND ps.Efficiency >= 80 AND p.Status = 'active';	waterPump	1
SELECT CEIL(100000000000 / (Flow_Rate * 3600)) AS required_pumps FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 5000 AND Voltage = 10000 AND Current = 500 AND Efficiency = 95;	waterPump	2
SELECT (Power * Efficiency / 100) AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Voltage = 220 AND Current = 45 AND Efficiency = 85;	waterPump	3
SELECT Pump_ID, Purchase_date, Warranty_Period, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) >= '2023-06-01' THEN '在保修期内' ELSE '不在保修期内' END AS Warranty_Status, CASE WHEN DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) < '2023-06-01' THEN DATEDIFF('2023-06-01', DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH)) ELSE 0 END AS Days_Out_of_Warranty FROM pumps WHERE Purchase_date = '2020-01-01' AND Warranty_Period = 36;	waterPump	4
SELECT Pump_ID, Maintenance_Date, Maintenance_Type, Cost FROM maintenance_records WHERE Pump_ID = (SELECT Pump_ID FROM maintenance_records WHERE Maintenance_Date = '2023-01-01' AND Maintenance_Type = '更换零件' AND Cost = 5000) ORDER BY Maintenance_Date DESC LIMIT 1;	waterPump	1
SELECT Power * (Efficiency / 100) AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 10000 AND Head = 1000 AND Power = 1000 AND Voltage = 10000 AND Current = 1000 AND Efficiency = 200;	waterPump	2
SELECT (Power * 1000 * Usage_Hours) / Efficiency AS Actual_Energy_Consumption FROM pump_specifications JOIN usage_records ON pump_specifications.Pump_ID = usage_records.pump_ID WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Voltage = 220 AND Current = 45 AND Efficiency = 85 AND Usage_Hours = 1;	waterPump	4
SELECT (Power * 8 * 30) AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 120 AND Head = 60 AND Power = 12 AND Voltage = 220 AND Current = 50 AND Efficiency = 90;	waterPump	1
SELECT Power * 1000 AS Total_Energy_Consumed FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Voltage = 1000 AND Current = 1000 AND Efficiency = 100;	waterPump	2
SELECT (Flow_Rate * Head * 9.81 * Efficiency / 100) / 3600 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 100 AND Head = 50 AND Power = 10 AND Efficiency = 80;	waterPump	3
SELECT (15 * 8 * 365) / 0.85 AS total_energy_consumption FROM pump_specifications WHERE Flow_Rate = 150 AND Head = 60 AND Power = 15 AND Efficiency = 85;	waterPump	4
SELECT Pump_ID, Model_Number, Purchase_date, Warranty_Period, DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) AS Warranty_End_Date, CASE WHEN '2023-06-01' <= DATE_ADD(Purchase_date, INTERVAL Warranty_Period MONTH) THEN 'Yes' ELSE 'No' END AS Is_Under_Warranty FROM pumps WHERE Purchase_date = '2022-01-01' AND Warranty_Period = 24;	waterPump	2
SELECT (Flow_Rate * Head * 1000 * 9.81) / 3600000 AS Actual_Output_Power FROM pump_specifications WHERE Flow_Rate = 1000 AND Head = 1000 AND Power = 1000 AND Efficiency = 100;	waterPump	1
WITH MaintenanceCosts AS (SELECT AVG(Cost) AS AvgCost FROM maintenance_records), UsageHours AS (SELECT AVG(Usage_Hours) AS AvgHours FROM usage_records) SELECT AvgCost / AvgHours AS CostToUsageRatio FROM MaintenanceCosts, UsageHours;	waterPump	2
SELECT y.Model, COUNT(v.Voyage_ID) AS Voyage_Count FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID WHERE v.Wind_Speed > 30 AND v.Wave_Height > 2 GROUP BY y.Model ORDER BY Voyage_Count DESC LIMIT 1;	yacht	3
SELECT y.Yacht_ID, y.Model, 1000000 / (p.Fuel_Efficiency * y.Max_Speed) AS Sailing_Time FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID WHERE 1000000 / (p.Fuel_Efficiency * y.Max_Speed) > 1000;	yacht	4
SELECT Yacht_ID, Model, (Displacement * 9.81) / (Weight * 9.81) AS Buoyancy_Gravity_Ratio FROM yachts WHERE (Displacement * 9.81) / (Weight * 9.81) > 1 ORDER BY Buoyancy_Gravity_Ratio DESC LIMIT 5;	yacht	1
SELECT v.Yacht_ID, y.Model, v.Fuel_Consumed * v.Distance AS Fuel_Distance_Product FROM voyages v JOIN yachts y ON v.Yacht_ID = y.Yacht_ID ORDER BY Fuel_Distance_Product DESC LIMIT 10;	yacht	2
SELECT Yacht_ID, Model, Year, Engine_Type, Price FROM yachts WHERE Year > 2015 AND Engine_Type = '柴油' ORDER BY Price DESC;	yacht	3
SELECT Yacht_ID, Model, (5000000 / Fuel_Efficiency) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Efficiency) > 10000;	yacht	4
SELECT Yacht_ID, Model, 0.5 * (Weight * 1000) * POWER(Max_Speed * 0.514444, 2) AS Kinetic_Energy FROM yachts ORDER BY Kinetic_Energy DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, Model, (5000000 / Fuel_Capacity) AS Max_Distance FROM yachts WHERE (5000000 / Fuel_Capacity) > 10000;	yacht	2
SELECT Yacht_ID, Model, Year, Hull_Material FROM yachts WHERE Year < 2010 AND Hull_Material = '玻璃钢' ORDER BY Year ASC;	yacht	3
SELECT Yacht_ID,  (1000000 / (Fuel_Efficiency / `Range`)) AS Sailing_Time_Hours FROM performance_metrics WHERE (1000000 / (Fuel_Efficiency / `Range`)) > 1000 ORDER BY Sailing_Time_Hours DESC;	yacht	4
SELECT Yacht_ID, Model, 0.5 * 1025 * Drag_Coefficient * (Length * Width) * POWER(Max_Speed * 0.514444, 3) AS Drag_Power FROM yachts ORDER BY Drag_Power DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, (1000000 / Fuel_Efficiency) AS Max_Sailing_Time FROM performance_metrics WHERE (1000000 / Fuel_Efficiency) > 1000;	yacht	2
SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Efficiency FROM yachts WHERE Year > 2015 AND Engine_Type = '柴油' ORDER BY Fuel_Efficiency ASC;	yacht	3
SELECT Yacht_ID, Model, (10000000 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000 / Fuel_Efficiency) > 50000;	yacht	4
SELECT Yacht_ID, Model, Year, Engine_Type, Fuel_Capacity FROM yachts WHERE Year > 2015 AND Engine_Type = '柴油' ORDER BY Fuel_Capacity ASC;	yacht	1
SELECT Yacht_ID, (10000000 / Fuel_Efficiency) AS Max_Distance FROM performance_metrics WHERE (10000000 / Fuel_Efficiency) > 50000;	yacht	2
SELECT Fuel_Capacity, (1000 / Fuel_Efficiency) AS Required_Fuel FROM yachts WHERE Yacht_ID = '特定游艇ID';	yacht	3
SELECT Yacht_ID, Model, (Fuel_Efficiency / `Range`) AS Efficiency_Ratio FROM performance_metrics ORDER BY Efficiency_Ratio DESC LIMIT 5;	yacht	4
SELECT Model, Year, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 20 ORDER BY Price DESC;	yacht	1
SELECT y.Yacht_ID, y.Model, p.Fuel_Efficiency / y.Max_Speed AS Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID ORDER BY Fuel_Consumption_Rate ASC LIMIT 10;	yacht	2
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity / p.Fuel_Efficiency * y.Max_Speed AS Max_Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID ORDER BY Max_Range DESC LIMIT 3;	yacht	3
SELECT 100000 / (500 * 50 * 1) AS Draft, CASE WHEN 100000 / (500 * 50 * 1) > 50 THEN '无法正常浮起' ELSE '可以正常浮起' END AS Status;	yacht	4
SELECT Hull_Material, AVG(Displacement / (Length * Width * 1)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;	yacht	1
SELECT y.Engine_Type, AVG(p.Fuel_Efficiency / y.Max_Speed) AS Avg_Fuel_Consumption_Rate FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY y.Engine_Type;	yacht	2
SELECT Manufacturer_ID, AVG(Fuel_Capacity / Fuel_Efficiency * Max_Speed) AS Avg_Max_Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID GROUP BY Manufacturer_ID;	yacht	3
SELECT Hull_Material, AVG(1000000 / (1000 * 100 * 1)) AS Avg_Draft FROM yachts GROUP BY Hull_Material;	yacht	4
SELECT Voyage_ID, Yacht_ID, Fuel_Consumed / Distance AS Fuel_Efficiency FROM voyages ORDER BY Fuel_Efficiency DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, SUM(Fuel_Consumed) / SUM(Distance) AS Avg_Fuel_Efficiency FROM voyages GROUP BY Yacht_ID;	yacht	2
SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Fuel_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN '异常数据' ELSE '合理数据' END AS Status;	yacht	4
SELECT Yacht_ID, Buoyancy_Force / Displacement AS Buoyancy_Ratio FROM yachts ORDER BY Buoyancy_Ratio DESC LIMIT 5;	yacht	1
SELECT Yacht_ID, SUM(Total_Energy_Consumed) / SUM(Distance) AS Avg_Energy_Efficiency FROM voyages GROUP BY Yacht_ID;	yacht	2
SELECT c.Role, AVG(v.Distance) AS Avg_Distance FROM crew c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID WHERE v.Weather_Conditions IN ('大风', '大浪') GROUP BY c.Role ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Energy_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN '异常数据' ELSE '合理数据' END AS Status;	yacht	4
SELECT c.Charter_Type, AVG(v.Fuel_Consumed / v.Distance) AS Avg_Fuel_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY c.Charter_Type;	yacht	1
SELECT v.Yacht_ID, SUM(c.Total_Cost) / SUM(v.Distance) AS Avg_Charter_Cost_Efficiency FROM voyages v JOIN charters c ON v.Yacht_ID = c.Yacht_ID GROUP BY v.Yacht_ID;	yacht	2
SELECT c.Charter_Type, AVG(v.Distance) AS Avg_Distance FROM charters c JOIN voyages v ON c.Yacht_ID = v.Yacht_ID GROUP BY c.Charter_Type ORDER BY Avg_Distance DESC LIMIT 1;	yacht	3
SELECT 1000000 / 1000000 AS Charter_Cost_Efficiency, CASE WHEN 1000000 / 1000000 < 0.01 THEN '异常数据' ELSE '合理数据' END AS Status;	yacht	4
SELECT Yacht_ID, AVG(Salary) / AVG(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;	yacht	1
SELECT Yacht_ID, SUM(Salary) / SUM(Experience_Years) AS Salary_Efficiency FROM crew GROUP BY Yacht_ID;	yacht	2
SELECT Role, AVG(Salary) AS Avg_Salary FROM crew GROUP BY Role ORDER BY Avg_Salary DESC LIMIT 1;	yacht	3
SELECT 1000000 * 12 / 100 AS Salary_Efficiency, CASE WHEN 1000000 * 12 / 100 < 1000 THEN '异常数据' ELSE '合理数据' END AS Status;	yacht	4
SELECT Yacht_ID, 0.5 * Weight * 1000 * POWER(Max_Speed * 0.5144, 2) AS Kinetic_Energy FROM yachts;	yacht	1
SELECT c.Yacht_ID, (SUM(c.Salary) / y.Price) * 100 AS Crew_Salary_Ratio FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Yacht_ID;	yacht	2
SELECT c.Role, AVG(y.Passenger_Capacity) AS Avg_Passenger_Per_Role FROM crew c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID GROUP BY c.Role ORDER BY Avg_Passenger_Per_Role DESC LIMIT 1;	yacht	3
SELECT 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) AS Kinetic_Energy, CASE WHEN 0.5 * 1000000 * 1000 * POWER(1000 * 0.5144, 2) > 1e12 THEN '异常数据' ELSE '合理数据' END AS Status;	yacht	4
SELECT Displacement, Buoyancy_Force FROM yachts WHERE Yacht_ID = ?;	yacht	1
SELECT Max_Speed, Engine_Power, Fuel_Efficiency FROM yachts WHERE Yacht_ID = ?;	yacht	2
SELECT Model, Year, Hull_Material, Passenger_Capacity, Price FROM yachts WHERE Hull_Material = '碳纤维' AND Passenger_Capacity > 10 ORDER BY Year ASC;	yacht	3
SELECT Model, Engine_Type, Engine_Power, Fuel_Capacity, Max_Speed FROM yachts WHERE Engine_Power > 500 AND Fuel_Capacity > 5000 ORDER BY Max_Speed DESC;	yacht	4
SELECT Model, Year, Price, Hull_Material FROM yachts WHERE Year >= 2018 AND Price < 1000000 ORDER BY Price ASC;	yacht	1
SELECT Yacht_ID, (Fuel_Efficiency / `Range`) AS Fuel_Consumption_Rate FROM performance_metrics ORDER BY Fuel_Consumption_Rate ASC LIMIT 3;	yacht	2
SELECT Yacht_ID, (Fuel_Efficiency / `Range`) * 100 AS Total_Fuel_Consumption FROM performance_metrics ORDER BY Total_Fuel_Consumption DESC LIMIT 5;	yacht	3
SELECT Yacht_ID,  (Fuel_Efficiency / `Range`) AS Fuel_Consumption_per_Kilometer FROM performance_metrics ORDER BY Fuel_Consumption_per_Kilometer ASC LIMIT 3;	yacht	4
SELECT Passenger_Capacity, Water_Capacity FROM yachts WHERE Yacht_ID = 1;	yacht	1
SELECT Engine_Power, Fuel_Efficiency, Fuel_Capacity FROM yachts WHERE Yacht_ID = 2;	yacht	2
SELECT 0.5 * (Displacement * 1000) * POWER((Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts WHERE Yacht_ID = 1;	yacht	3
SELECT (Fuel_Capacity / Fuel_Efficiency) AS Actual_Range, `Range` AS Designed_Range FROM yachts JOIN performance_metrics ON yachts.Yacht_ID = performance_metrics.Yacht_ID WHERE yachts.Yacht_ID = 1;	yacht	4
SELECT Water_Capacity, Passenger_Capacity * 50 * 7 AS Total_Water_Needed FROM yachts WHERE Yacht_ID = 1;	yacht	1
SELECT (Fuel_Capacity / 1000) * 50 AS Possible_Distance, 8000 AS Required_Distance FROM yachts WHERE Yacht_ID = 1;	yacht	2
SELECT Hull_Material, AVG(Price) AS Avg_Price FROM yachts GROUP BY Hull_Material;	yacht	3
SELECT Model, Length, Max_Speed FROM yachts WHERE Length > 30;	yacht	4
SELECT Model, Length, Width FROM yachts WHERE Hull_Material = 'Fiberglass';	yacht	1
SELECT Model, Year, Hull_Material FROM yachts WHERE Year > 2020;	yacht	2
SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity;	yacht	3
SELECT y.*, y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) AS Fuel_Consumption_Time FROM yachts y WHERE y.Fuel_Capacity / (SELECT MAX(p.Fuel_Efficiency) FROM performance_metrics p WHERE p.Yacht_ID = y.Yacht_ID) > 1000;	yacht	4
SELECT y.*, 0.5 * (y.Displacement * 1000) * POWER((y.Max_Speed * 0.5144), 2) AS Kinetic_Energy FROM yachts y ORDER BY Kinetic_Energy DESC LIMIT 5;	yacht	1
WITH Fuel_Rate AS (SELECT y.Yacht_ID, y.Model, v.Fuel_Consumed / v.Distance AS Fuel_Consumption_Rate FROM yachts y JOIN voyages v ON y.Yacht_ID = v.Yacht_ID) SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY Yacht_ID ORDER BY Fuel_Consumption_Rate ASC) AS rn FROM Fuel_Rate) WHERE rn = 1;	yacht	2
WITH Overloaded_Charters AS (SELECT c.* FROM charters c JOIN yachts y ON c.Yacht_ID = y.Yacht_ID WHERE c.Passenger_Count > y.Passenger_Capacity) SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY Charter_Type ORDER BY Total_Cost DESC) AS rn FROM Overloaded_Charters) WHERE rn = 1;	yacht	3
SELECT Model, Price, Max_Speed FROM yachts WHERE Price > 5000000;	yacht	4
SELECT Model, Engine_Power, Fuel_Capacity FROM yachts WHERE Engine_Type = 'Inboard';	yacht	1
SELECT y.Yacht_ID, y.Model, y.Passenger_Capacity, COUNT(c.Customer_ID) AS Customer_Count, COUNT(cr.Crew_ID) AS Crew_Count FROM yachts y JOIN charters ch ON y.Yacht_ID = ch.Yacht_ID JOIN customers c ON ch.Customer_ID = c.Customer_ID JOIN crew cr ON y.Yacht_ID = cr.Yacht_ID GROUP BY y.Yacht_ID HAVING (COUNT(c.Customer_ID) + COUNT(cr.Crew_ID)) <= y.Passenger_Capacity * 0.8;	yacht	2
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed);	yacht	3
SELECT y.Yacht_ID, y.Model, y.Fuel_Capacity, p.Fuel_Efficiency, v.Distance, v.Average_Speed FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE y.Fuel_Capacity >= p.Fuel_Efficiency * (v.Distance / v.Average_Speed) AND y.Engine_Power = 100000;	yacht	4
SELECT Displacement / (Length * Width * 1) AS Draft FROM yachts WHERE Yacht_ID = '特定游艇ID';	yacht	1
SELECT (Total_Cost * 0.8 * 0.85) + (Total_Cost * 0.2) AS Actual_Payment FROM charters WHERE Customer_ID = '特定客户ID' AND YEAR(Start_Date) = 2023;	yacht	2
SELECT Voyage_ID, Yacht_ID, Average_Speed FROM voyages WHERE Average_Speed > (SELECT Max_Speed FROM yachts WHERE yachts.Yacht_ID = voyages.Yacht_ID);	yacht	3
SELECT (Fuel_Capacity / Fuel_Efficiency) / (24 * 365) AS Fuel_Support_Years FROM yachts WHERE Yacht_ID = '特定游艇ID';	yacht	4
SELECT Model, 0.5 * (Weight * 1000) * POWER((Max_Speed * 0.514444), 2) AS Kinetic_Energy FROM yachts WHERE 0.5 * (Weight * 1000) * POWER((Max_Speed * 0.514444), 2) > 100000000;	yacht	1
SELECT Model, Length, Year FROM yachts WHERE Length BETWEEN 20 AND 30;	yacht	2
SELECT y.Model, y.Hull_Material, y.Engine_Type FROM yachts y JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE v.Wave_Height > 3 AND v.Wind_Speed > 30;	yacht	3
SELECT y.Model, (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 AS Range FROM yachts y JOIN performance_metrics p ON y.Yacht_ID = p.Yacht_ID JOIN voyages v ON y.Yacht_ID = v.Yacht_ID WHERE (1000000 / p.Fuel_Efficiency) * v.Average_Speed * 0.514444 / 1.852 > 1000000;	yacht	4
WITH KineticEnergy AS (SELECT Model, Hull_Material, 0.5 * (Weight * 1000) * POWER((Max_Speed * 0.514444), 2) AS Kinetic_Energy FROM yachts) SELECT Hull_Material, Model, MAX(Kinetic_Energy) AS Max_Kinetic_Energy FROM KineticEnergy GROUP BY Hull_Material;	yacht	1
SELECT Model, Max_Speed, Price FROM yachts WHERE Max_Speed > 35;	yacht	2
SELECT Model, Fuel_Capacity, Hull_Material FROM yachts WHERE Fuel_Capacity > 1000;	yacht	3
SELECT Model, Passenger_Capacity, Price FROM yachts WHERE Passenger_Capacity > 12;	yacht	4
WITH BuoyancyRatio AS (SELECT Model, Hull_Material, Buoyancy_Force / (Weight * 1000 * 9.81) AS Buoyancy_Ratio FROM yachts) SELECT Hull_Material, Model, MIN(Buoyancy_Ratio) AS Min_Buoyancy_Ratio FROM BuoyancyRatio GROUP BY Hull_Material;	yacht	1
SELECT Model, Displacement, Max_Speed FROM yachts WHERE Displacement > 50;	yacht	2
SELECT Model, Buoyancy_Force, Center_of_Gravity FROM yachts WHERE Buoyancy_Force > 100000;	yacht	3
SELECT Model, Drag_Coefficient, Hull_Speed FROM yachts WHERE Drag_Coefficient < 0.5;	yacht	4
WITH KineticEnergy AS (SELECT y.Model, y.Hull_Material, 0.5 * (y.Weight * 1000) * POWER((y.Max_Speed * 0.514444), 2) AS Kinetic_Energy, AVG(c.Salary) AS Avg_Salary FROM yachts y JOIN crew c ON y.Yacht_ID = c.Yacht_ID GROUP BY y.Model, y.Hull_Material) SELECT Hull_Material, Model, MAX(Kinetic_Energy / Avg_Salary) AS Max_Ratio FROM KineticEnergy GROUP BY Hull_Material;	yacht	1
SELECT Model, Year, Price FROM yachts WHERE Manufacturer_ID = 1;	yacht	2
SELECT Model, Hull_Speed, Max_Speed FROM yachts WHERE Hull_Speed > 25;	yacht	3
SELECT Model, Weight, Displacement FROM yachts WHERE Weight > 100;	yacht	4
WITH KineticEnergy AS (SELECT y.Model, 0.5 * (y.Weight * 1000) * POWER((y.Max_Speed * 0.514444), 2) AS Kinetic_Energy, AVG(c.Salary) AS Avg_Salary FROM yachts y JOIN crew c ON y.Yacht_ID = c.Yacht_ID GROUP BY y.Model) SELECT Model, Kinetic_Energy / Avg_Salary AS Ratio FROM KineticEnergy ORDER BY Ratio DESC LIMIT 5;	yacht	1
SELECT Model, Water_Capacity, Fuel_Capacity FROM yachts WHERE Water_Capacity > 500;	yacht	2
SELECT Model, Length, Max_Speed, Price FROM yachts WHERE Length > 30 AND Max_Speed > 35 ORDER BY Price DESC;	yacht	3
SELECT Model, Year, Hull_Material, Engine_Power FROM yachts WHERE Year > 2020 AND Hull_Material = 'Fiberglass' ORDER BY Engine_Power ASC;	yacht	4
SELECT (b.Voltage * b.Capacity) / m.Power AS Theoretical_Range_Time FROM Batteries b JOIN ElectricBikes eb ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID WHERE eb.Weight = 50 AND m.Power = 400 AND b.Voltage = 48 AND b.Capacity = 20;	electric_scooter	1
SELECT (b.Voltage * b.Capacity) / 0.05 AS Distance FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE b.Capacity = 15 AND b.Voltage = 36 AND m.Power = 250 AND bd.Wheel_Size = 12;	electric_scooter	2
SELECT Type, Voltage, Capacity FROM Batteries WHERE Voltage = 48 AND Capacity > 50 AND Type = '锂电池' ORDER BY Capacity DESC;	electric_scooter	3
SELECT  Type, Voltage, Capacity, SUM(Capacity) OVER () AS Total_Capacity FROM Batteries WHERE Voltage IN (60, 72);	electric_scooter	4
SELECT Type, Voltage, Capacity, SUM(Capacity) OVER () AS Total_Capacity FROM Batteries WHERE Voltage = 72 AND Capacity > 90 AND Type = '锂电池';	electric_scooter	1
SELECT (b.Voltage * b.Capacity) / 1 AS Distance, CASE WHEN b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 THEN '理论可行，实际不可行' ELSE '配置异常' END AS Feasibility FROM ElectricBikes eb JOIN Batteries b ON eb.Bike_ID = b.Bike_ID JOIN Motors m ON eb.Bike_ID = m.Bike_ID WHERE b.Voltage = 1000 AND b.Capacity = 1000 AND m.Power = 10000 LIMIT 1;	electric_scooter	2
SELECT (bd.Length * bd.Width * bd.Height) AS Body_Volume FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 1800 AND bd.Width = 700 AND bd.Height = 1200 AND bd.Wheel_Size = 14;	electric_scooter	3
SELECT CASE WHEN bd.Length <= 2500 AND bd.Width <= 1000 AND bd.Height <= 1500 THEN '可以停放' ELSE '无法停放' END AS Parking_Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 2000 AND bd.Width = 750 AND bd.Height = 1100 AND bd.Wheel_Size = 16 LIMIT 1;	electric_scooter	4
SELECT DISTINCT CASE WHEN bd.Height <= 1500 THEN '可以通过' ELSE '无法通过' END AS Tunnel_Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Height = 1200 AND bd.Wheel_Size = 14;	electric_scooter	1
SELECT CASE WHEN bd.Length <= 6000 AND bd.Width <= 2500 AND bd.Height <= 3000 THEN '可以停放' ELSE '无法停放' END AS Parking_Feasibility, CASE WHEN bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30 THEN '理论可行，实际不可行' ELSE '配置异常' END AS Feasibility FROM ElectricBikes eb JOIN BodyDimensions bd ON eb.Bike_ID = bd.Bike_ID WHERE bd.Length = 5000 AND bd.Width = 2000 AND bd.Height = 2500 AND bd.Wheel_Size = 30;	electric_scooter	2
SELECT (cr.Energy_Used * 1000) / (220 * ((HOUR(TIMEDIFF(cr.EndTime, cr.StartTime)) * 3600) + (MINUTE(TIMEDIFF(cr.EndTime, cr.StartTime)) * 60) + SECOND(TIMEDIFF(cr.EndTime, cr.StartTime)))) AS Charging_Current FROM ChargingRecords cr WHERE cr.Energy_Used = 2;	electric_scooter	3
SELECT SUM( Cost) AS Total_Charging_Cost FROM ChargingRecords WHERE User_ID = 3 AND DATE(StartTime) = '2023-10-01';	electric_scooter	4
SELECT Energy_Used / 0.9 AS Actual_Energy_Consumed FROM ChargingRecords WHERE Energy_Used = 3 Limit 1;	electric_scooter	1
SELECT 1000 / (1000 * 1 * 0.5) AS Actual_Current;	electric_scooter	2
SELECT Voltage * Capacity AS Energy FROM Batteries WHERE Voltage = 48 AND Capacity = 20 LIMIT 1;	electric_scooter	3
SELECT m.Power / e.Weight AS PowerToWeightRatio FROM ElectricBikes e JOIN Motors m ON e.Bike_ID = m.Bike_ID JOIN Batteries b ON e.Bike_ID = b.Bike_ID WHERE e.Weight = 30 AND m.Power = 500 AND b.Capacity = 20 AND b.Voltage = 48;	electric_scooter	4
SELECT (b.Voltage * b.Capacity) / b.Distance AS EnergyPerKm FROM Batteries b WHERE b.Distance = 60 AND b.Capacity = 20 AND b.Voltage = 48 LIMIT 1;	electric_scooter	1
SELECT (b.Voltage * b.Capacity) / m.Power AS WorkingTime, m.Power / e.Weight AS PowerToWeightRatio FROM ElectricBikes e JOIN Motors m ON e.Bike_ID = m.Bike_ID JOIN Batteries b ON e.Bike_ID = b.Bike_ID WHERE b.Capacity = 1000 AND b.Voltage = 1000 AND m.Power = 10000 AND e.Weight = 1000;	electric_scooter	2
SELECT Energy_Used / ((UNIX_TIMESTAMP(EndTime) - UNIX_TIMESTAMP(StartTime)) / 3600) AS AveragePower FROM ChargingRecords WHERE Energy_Used = 2 AND (UNIX_TIMESTAMP(EndTime) - UNIX_TIMESTAMP(StartTime)) = 7200;	electric_scooter	3
SELECT SUM(Energy_Used) AS TotalEnergyUsed, AVG(Energy_Used) AS AverageEnergyPerCharge FROM ChargingRecords WHERE User_ID = 101 AND StartTime >= '2023-10-01 00:00:00' AND StartTime <= '2023-10-31 23:59:59';	electric_scooter	4
SELECT Cost / Energy_Used AS CostPerKWh FROM ChargingRecords WHERE Cost = 10 AND Energy_Used = 5;	electric_scooter	1
SELECT SUM(Energy_Used) AS TotalEnergyUsed, SUM(Cost) AS TotalCost, CASE WHEN SUM(Cost) = SUM(Energy_Used) * 1 THEN '合理' ELSE '不合理' END AS IsReasonable FROM ChargingRecords WHERE User_ID = 101 AND StartTime >= '2023-10-01 00:00:00' AND StartTime <= '2023-10-31 23:59:59';	electric_scooter	2
SELECT AVG(Cost) AS AverageCost FROM MaintenanceRecords WHERE Description = '更换电池' AND Bike_ID = 1;	electric_scooter	3
SELECT SUM(Cost) AS TotalMaintenanceCost, AVG(Cost) AS AverageCostPerMaintenance FROM MaintenanceRecords WHERE Bike_ID = 1 AND Maintenance_Date >= '2023-01-01' AND Maintenance_Date <= '2023-12-31';	electric_scooter	4
SELECT Maintenance_Date FROM MaintenanceRecords WHERE Technician = '张师傅';	electric_scooter	1
SELECT SUM(Cost) AS TotalMaintenanceCost, CASE WHEN SUM(Cost) = 500 * COUNT(*) THEN '合理' ELSE '不合理' END AS IsReasonable FROM MaintenanceRecords WHERE Description = '更换电池' AND Bike_ID = 201 AND Maintenance_Date >= '2023-01-01' AND Maintenance_Date <= '2023-12-31';	electric_scooter	2
SELECT 7 * Available_Slots AS TotalPower FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;	electric_scooter	3
SELECT (7 * 8) * Available_Slots AS TotalEnergyConsumption FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;	electric_scooter	4
SELECT (7 * Available_Slots) / Available_Slots AS AverageChargingPower FROM ChargingStations WHERE Available_Slots = 10 LIMIT 1;	electric_scooter	1
SELECT (1000 * 24) * Available_Slots AS TotalEnergyConsumption, SUM(Cost) AS TotalCost FROM ChargingStations cs JOIN ChargingRecords cr ON cs.Station_ID = cr.Station_ID WHERE cs.Available_Slots = 1000 AND DATE(cr.StartTime) = '2023-10-01';	electric_scooter	2
SELECT COUNT(*) AS UserCount FROM users WHERE DATE(CreatedAt) >= '2023-10-01' AND DATE(CreatedAt) <= '2023-10-31';	electric_scooter	3
SELECT COUNT(DISTINCT u1.User_ID) AS UserCount FROM users u1 JOIN users u2 ON ABS(TIMESTAMPDIFF(DAY, u1.CreatedAt, u2.CreatedAt)) <= 1 AND u1.User_ID != u2.User_ID;	electric_scooter	4
SELECT COUNT(DISTINCT Address) AS DistinctRegionCount FROM users;	electric_scooter	1
SELECT COUNT(*) AS SameRegionUserCount FROM users WHERE Address = (SELECT Address FROM users WHERE Username = '张三');	electric_scooter	2
SELECT Voltage * Capacity AS Energy FROM Batteries WHERE Voltage = 48 AND Capacity = 20;	electric_scooter	3
SELECT (Voltage * Capacity) / Distance AS EnergyPerKm FROM Batteries WHERE Capacity = 20 AND Voltage = 48 AND Distance = 60;	electric_scooter	4
SELECT (Voltage * Capacity) / 500 AS RunTime FROM Batteries WHERE Capacity = 20 AND Voltage = 48;	electric_scooter	1
SELECT Voltage * Capacity AS Energy, (Voltage * Capacity) / 10000 AS RunTime FROM Batteries WHERE Capacity = 1000 AND Voltage = 1000;	electric_scooter	2
SELECT Devices.deviceId AS itemId, Devices.deviceName AS itemName, Devices.deviceType AS specification, Labs.location AS storageLocation FROM Devices JOIN Labs ON Devices.labId = Labs.labId WHERE Labs.location = '特定区域';	PhysicsLabDB	3
SELECT deviceId, (SUM(energyConsumed) / (SUM(powerUsage) * (MAX(julianday(timestamp)) - MIN(julianday(timestamp))) * 24) * 100 AS efficiency FROM EnergyConsumption GROUP BY deviceId ORDER BY efficiency ASC LIMIT 5;	EnergyManagementDB	4
SELECT deviceId, (STDDEV(energyConsumed) / AVG(energyConsumed) * 100 AS fluctuationRate FROM EnergyConsumption GROUP BY deviceId ORDER BY fluctuationRate DESC LIMIT 10;	EnergyManagementDB	1
SELECT location, COUNT(*) AS itemCount FROM EnergyManagementDB.EnergyDevices GROUP BY location ORDER BY itemCount ASC LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, l.labName FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.status = '维护中';	PhysicsLabDB	3
SELECT d.deviceType, COUNT(d.deviceId) * 10 * 365 AS totalWarrantyExtensionDays FROM Devices d GROUP BY d.deviceType ORDER BY totalWarrantyExtensionDays DESC LIMIT 3;	PhysicsLabDB	4
SELECT d.deviceName, d.deviceType, s.supplierName FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE d.status = '故障' ORDER BY DATEDIFF(NOW(), d.calibrationDate) ASC;	PhysicsLabDB	1
SELECT s.supplierName, COUNT(DISTINCT d.deviceType) AS specificationCount FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierName ORDER BY specificationCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, warrantyEndDate FROM Devices WHERE warrantyEndDate >= CURDATE();	PhysicsLabDB	3
SELECT s.supplierId, COUNT(d.deviceType) * 1000 AS totalMaintenanceCost FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId GROUP BY s.supplierId ORDER BY totalMaintenanceCost DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceName, deviceType, DATEDIFF(warrantyEndDate, purchaseDate) AS totalWarrantyDays FROM Devices ORDER BY totalWarrantyDays DESC;	PhysicsLabDB	1
SELECT m.country, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.country ORDER BY deviceCount ASC LIMIT 5;	EnergyManagementDB	2
SELECT itemName, specifications, storageLocation FROM Devices WHERE status = '停用';	PhysicsLabDB	3
SELECT d.supplierId, SUM(dt.maintenanceCost) * 0.1 AS totalMaintenanceCost FROM Devices d JOIN DeviceTypes dt ON d.deviceType = dt.deviceType GROUP BY d.supplierId ORDER BY totalMaintenanceCost ASC LIMIT 3;	PhysicsLabDB	4
SELECT d.deviceName, DATEDIFF(CURDATE(), d.calibrationDate) AS unmaintainedDays FROM Devices d WHERE d.status = '停用' ORDER BY unmaintainedDays DESC;	PhysicsLabDB	1
SELECT m.manufacturerName, COUNT(e.deviceId) AS deviceCount FROM EnergyDevices e JOIN Manufacturers m ON e.manufacturerId = m.manufacturerId GROUP BY m.manufacturerName ORDER BY deviceCount DESC LIMIT 5;	EnergyManagementDB	2
SELECT d.itemName, d.purchaseDate FROM Devices d JOIN Suppliers s ON d.supplierId = s.supplierId WHERE s.supplierName = '某供应商';	PhysicsLabDB	3
SELECT d.supplierId, SUM(DATEDIFF(d.warrantyEndDate, d.purchaseDate) * 0.5) AS totalWarrantyReduction FROM Devices d GROUP BY d.supplierId ORDER BY totalWarrantyReduction DESC LIMIT 3;	PhysicsLabDB	4
SELECT i.itemName, i.purchaseDate, i.energyConsumption FROM Devices i ORDER BY i.energyConsumption DESC;	PhysicsLabDB	1
SELECT s.supplierName, SUM((i.warrantyPeriod * 0.5)) AS totalShortenedDays FROM Devices i JOIN Suppliers s ON i.supplierId = s.supplierId GROUP BY s.supplierName ORDER BY totalShortenedDays DESC LIMIT 3;	PhysicsLabDB	2
SELECT deviceName, deviceType, powerRating FROM EnergyDevices WHERE powerRating > 100 ORDER BY powerRating DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	4
SELECT deviceName, deviceType, power FROM Devices WHERE power > 100 ORDER BY power DESC;	PhysicsLabDB	1
SELECT supplierId, COUNT(*) AS deviceCount FROM Devices GROUP BY supplierId ORDER BY deviceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = '故障';	PhysicsLabDB	3
SELECT deviceType, SUM(power * 100) AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceName, deviceType, SUM(current) AS totalCurrent FROM Devices GROUP BY deviceName, deviceType ORDER BY totalCurrent DESC;	PhysicsLabDB	1
SELECT deviceType, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY avgEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE DATEDIFF(CURRENT_DATE, installationDate) > 5 * 365;	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;	PhysicsLabDB	1
SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, temperature FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId WHERE temperature > 50 OR temperature < -20 ORDER BY temperature;	EnergyManagementDB	3
SELECT deviceType, SUM(cost * 1000) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerRatio DESC;	EnergyManagementDB	1
SELECT manufacturerId, AVG(energyConsumed) AS avgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY manufacturerId ORDER BY avgEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, humidity FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId WHERE humidity < 0 OR humidity > 100 ORDER BY humidity DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerDifference DESC;	EnergyManagementDB	1
SELECT deviceType, COUNT(deviceId) AS maintenanceCount FROM Devices WHERE status IN ('维护中', '故障') GROUP BY deviceType ORDER BY maintenanceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, lastMaintenanceDate FROM EnergyDevices JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId WHERE DATEDIFF(CURRENT_DATE, lastMaintenanceDate) > 365 ORDER BY lastMaintenanceDate DESC;	EnergyManagementDB	3
SELECT deviceType, COUNT(maintenanceId) * 100 AS totalMaintenanceCount FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCount DESC LIMIT 3;	EnergyManagementDB	4
SELECT d.deviceName, d.deviceType, (ec.powerUsage / d.powerRating) * 100 AS powerPercentage FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId ORDER BY powerPercentage DESC;	EnergyManagementDB	1
SELECT d.deviceType, SUM(ec.energyConsumed) / SUM(mr.cost) AS energyToCostRatio FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId JOIN MaintenanceRecords mr ON mr.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY energyToCostRatio ASC LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, ec.temperature FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId WHERE ec.temperature > 30 ORDER BY ec.temperature DESC;	EnergyManagementDB	3
SELECT d.deviceType, SUM(ec.energyConsumed) AS totalEnergyConsumed FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerSquareRatio DESC;	EnergyManagementDB	1
SELECT d.deviceType, SUM(ec.energyConsumed) / COUNT(mr.maintenanceId) AS energyMaintenanceRatio FROM EnergyConsumption ec JOIN EnergyDevices d ON ec.deviceId = d.deviceId JOIN MaintenanceRecords mr ON ec.deviceId = mr.deviceId GROUP BY d.deviceType ORDER BY energyMaintenanceRatio ASC LIMIT 5;	EnergyManagementDB	2
SELECT d.deviceName, d.deviceType, d.humidity FROM EnergyDevices d WHERE d.humidity < 20 ORDER BY d.humidity ASC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * (1 + 0.8)) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerCubicRatio DESC;	EnergyManagementDB	1
SELECT deviceType, SUM(energyConsumed * 1.8) / POWER(SUM(cost), 2) AS energyMaintenanceRatioSquare FROM EnergyConsumption JOIN MaintenanceRecords ON EnergyConsumption.deviceId = MaintenanceRecords.deviceId JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY energyMaintenanceRatioSquare ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, voltage FROM EnergyDevices WHERE voltage < 200 ORDER BY voltage DESC;	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 500) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerFourthRatio DESC;	EnergyManagementDB	1
SELECT deviceType, (SUM(energyConsumed) / POW(COUNT(maintenanceId), 3)) AS energyMaintenanceCubeRatio FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId JOIN MaintenanceRecords ON EnergyDevices.deviceId = MaintenanceRecords.deviceId GROUP BY deviceType ORDER BY energyMaintenanceCubeRatio ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, current FROM EnergyDevices WHERE current > 10 ORDER BY current DESC;	EnergyManagementDB	3
SELECT deviceType, POWER(SUM(energyConsumed) / COUNT(maintenanceId), 3) AS energyMaintenanceCubicRatio FROM EnergyConsumption JOIN MaintenanceRecords ON EnergyConsumption.deviceId = MaintenanceRecords.deviceId JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY energyMaintenanceCubicRatio DESC LIMIT 5;	EnergyManagementDB	4
SELECT deviceId, deviceName, SUM(energyConsumed) / DATEDIFF(CURRENT_DATE, installationDate) AS dailyAvgEnergyConsumed FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId GROUP BY deviceId, deviceName ORDER BY dailyAvgEnergyConsumed DESC;	EnergyManagementDB	1
SELECT deviceType, SUM(current * 5 * voltage * 24 / 1000) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed ASC LIMIT 3;	EnergyManagementDB	2
SELECT EnergyDevices.deviceId, EnergyDevices.deviceName, SUM(EnergyConsumption.energyConsumed) / DATEDIFF(CURRENT_DATE, EnergyDevices.installationDate) AS dailyAvgEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY EnergyDevices.deviceId, EnergyDevices.deviceName ORDER BY dailyAvgEnergyConsumed DESC;	EnergyManagementDB	3
SELECT ed.deviceType, SUM(ec.energyConsumed * (ed.powerRating * 10) / ed.powerRating) AS totalEnergyConsumed FROM EnergyConsumption AS ec JOIN EnergyDevices AS ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY totalEnergyConsumed DESC LIMIT 5;	EnergyManagementDB	4
SELECT SUM(ed.measurementValue) AS totalPower FROM Devices d JOIN ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = '瓦特';	PhysicsLabDB	1
SELECT deviceType, COUNT(*) AS deviceCount FROM Devices GROUP BY deviceType ORDER BY deviceCount DESC LIMIT 5;	PhysicsLabDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE status = '故障';	PhysicsLabDB	3
SELECT deviceType, COUNT(*) * 100 AS totalEnergyConsumed FROM Devices GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	PhysicsLabDB	4
SELECT deviceType, COUNT(*) * 10 AS totalCurrent FROM Devices GROUP BY deviceType ORDER BY totalCurrent DESC;	PhysicsLabDB	1
SELECT deviceType, AVG(energyConsumed) AS averageEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY averageEnergyConsumed ASC LIMIT 5;	EnergyManagementDB	2
SELECT deviceName, deviceType, installationDate FROM Devices WHERE DATEDIFF(CURRENT_DATE, installationDate) > 5 * 365;	PhysicsLabDB	3
SELECT deviceType, SUM(energyConsumed * 5) AS totalEnergyConsumed FROM EnergyConsumption JOIN EnergyDevices ON EnergyConsumption.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceName, deviceType, 0.8 AS powerFactor FROM Devices ORDER BY powerFactor ASC;	PhysicsLabDB	1
SELECT deviceType, SUM(cost) AS totalMaintenanceCost FROM MaintenanceRecords JOIN EnergyDevices ON MaintenanceRecords.deviceId = EnergyDevices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 5;	EnergyManagementDB	2
SELECT SUM(ed.measurementValue) AS totalPower FROM PhysicsLabDB.Devices d JOIN PhysicsLabDB.ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = '瓦特';	EnergyManagementDB	3
SELECT deviceType, SUM(cost) * 1000 AS totalMaintenanceCost FROM EnergyManagementDB.MaintenanceRecords JOIN PhysicsLabDB.Devices ON MaintenanceRecords.deviceId = Devices.deviceId GROUP BY deviceType ORDER BY totalMaintenanceCost DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage / powerRating) AS powerRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerRatio DESC;	EnergyManagementDB	1
SELECT deviceType, AVG(energyConsumption) AS avgEnergyConsumption FROM EnergyManagementDB.MaintenanceRecords JOIN PhysicsLabDB.Devices ON MaintenanceRecords.deviceId = Devices.deviceId GROUP BY deviceType ORDER BY avgEnergyConsumption ASC LIMIT 5;	EnergyManagementDB	2
SELECT SUM(ed.measurementValue) AS totalPower FROM PhysicsLabDB.Devices d JOIN PhysicsLabDB.ExperimentData ed ON d.deviceId = ed.deviceId WHERE ed.unit = '瓦特';	EnergyManagementDB	3
SELECT deviceType, SUM(energyConsumed * 0.1) AS totalEnergyConsumed FROM EnergyManagementDB.EnergyConsumption JOIN PhysicsLabDB.Devices ON EnergyConsumption.deviceId = Devices.deviceId GROUP BY deviceType ORDER BY totalEnergyConsumed DESC LIMIT 3;	EnergyManagementDB	4
SELECT deviceId, deviceName, (powerUsage - powerRating) AS powerDifference FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerDifference DESC;	EnergyManagementDB	1
SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount FROM Experiments eJOIN Researchers r ON e.researcherId = r.researcherIdJOIN Labs l ON e.labId = l.labIdWHERE r.role = '数据分析师' AND e.status = '进行中'ORDER BY e.startDate ASC;	PhysicsLabDB	2
SELECT deviceName, powerRating, location FROM EnergyDevices WHERE deviceType = '太阳能' AND status = '运行中' ORDER BY powerRating DESC;	EnergyManagementDB	3
SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;	EnergyManagementDB	4
SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 500 ORDER BY timestamp ASC;	EnergyManagementDB	1
SELECT deviceId, carbonFootprint, energySource FROM EnvironmentalImpact WHERE carbonFootprint > 1000 ORDER BY carbonFootprint DESC;	EnergyManagementDB	2
SELECT deviceId, efficiency, energySaved FROM EnergyEfficiency WHERE efficiency > 90 ORDER BY energySaved DESC;	EnergyManagementDB	3
SELECT deviceId, maintenanceDate, cost FROM MaintenanceRecords WHERE maintenanceType = '紧急维修' ORDER BY maintenanceDate DESC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 2) AS powerSquareRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerSquareRatio DESC;	EnergyManagementDB	1
SELECT deviceId, forecastValue, timestamp FROM EnergyForecasts WHERE forecastType = '能耗预测' AND confidenceLevel > 95 ORDER BY forecastValue DESC;	EnergyManagementDB	2
SELECT policyName, targetEfficiency, targetCarbonFootprint FROM EnergyPolicies WHERE targetEfficiency > 85 ORDER BY targetEfficiency DESC;	EnergyManagementDB	3
SELECT deviceId, auditDate, recommendations FROM EnergyAudits WHERE auditResult = '不合规' ORDER BY auditDate ASC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 3) AS powerCubicRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerCubicRatio DESC;	EnergyManagementDB	1
SELECT deviceId, temperature, energyConsumed FROM EnergyConsumption WHERE temperature > 50 ORDER BY temperature DESC;	EnergyManagementDB	2
SELECT deviceName, installationDate, status FROM EnergyDevices WHERE deviceType = '风能' AND installationDate > '2020-01-01' ORDER BY installationDate ASC;	EnergyManagementDB	3
SELECT manufacturerName, profit, country FROM Manufacturers WHERE profit > 500 ORDER BY profit DESC;	EnergyManagementDB	4
SELECT deviceId, deviceName, POWER(powerUsage / powerRating, 4) AS powerFourthRatio FROM EnergyConsumption JOIN Devices ON EnergyConsumption.deviceId = Devices.deviceId ORDER BY powerFourthRatio DESC;	EnergyManagementDB	1
SELECT deviceId, energyConsumed, timestamp FROM EnergyConsumption WHERE energyConsumed > 1000 AND dataQuality = '高' ORDER BY energyConsumed DESC;	EnergyManagementDB	2
SELECT deviceId, pollutionLevel, energySource FROM EnvironmentalImpact WHERE pollutionLevel > 50 ORDER BY pollutionLevel DESC;	EnergyManagementDB	3
SELECT deviceId, costSavings, energySaved FROM EnergyEfficiency WHERE costSavings > 1000 ORDER BY costSavings DESC;	EnergyManagementDB	4
SELECT AVG(julianday(warrantyExpiryDate) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;	PhysicsLabDB	1
SELECT deviceId, maintenanceDate, maintenanceType FROM MaintenanceRecords WHERE cost > 5000 ORDER BY cost DESC;	EnergyManagementDB	2
SELECT researcherName, email, joinDate FROM Researchers WHERE role = '数据分析师' ORDER BY joinDate ASC;	PhysicsLabDB	3
SELECT AVG(julianday(datetime(purchaseDate, '+100 years')) - julianday(purchaseDate)) AS avg_warranty, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_warranty DESC LIMIT 1;	PhysicsLabDB	4
SELECT labName, location, equipmentCount FROM Labs WHERE capacity > 20 AND status = '开放' ORDER BY equipmentCount DESC;	PhysicsLabDB	1
SELECT experimentName, startDate, endDate FROM Experiments WHERE status = '进行中' ORDER BY startDate ASC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE status = '故障' AND deviceType = '照明' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT d.deviceName, d.powerRating, d.installationDate, SUM(e.energyConsumed) AS totalEnergyConsumed FROM Devices d JOIN EnergyConsumption e ON d.deviceId = e.deviceId WHERE d.deviceType = '照明' AND d.status = '在线' GROUP BY d.deviceName, d.powerRating, d.installationDate ORDER BY totalEnergyConsumed DESC;	SmartHomeDB	4
SELECT SUM(weight) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentMethod = '支付宝' ORDER BY orderDate ASC;	ECommerce	3
SELECT SUM(1000) AS total_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_weight DESC LIMIT 3;	ECommerce	4
SELECT SUM(cost) AS total_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT manufacturerId, COUNT(deviceId) AS device_count FROM Devices GROUP BY manufacturerId ORDER BY device_count DESC LIMIT 3;	PhysicsLabDB	2
SELECT * FROM MaintenanceRecords WHERE maintenanceType = '紧急维修' AND cost > 1000 ORDER BY maintenanceDate ASC;	EnergyManagementDB	3
SELECT deviceName, calibrationDate, labId FROM Devices WHERE deviceType = '示波器' AND status = '正常' ORDER BY calibrationDate DESC;	PhysicsLabDB	4
SELECT AVG(powerUsage) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;	EnergyManagementDB	1
SELECT sensorId, COUNT(dataId) AS high_quality_count FROM SensorData WHERE dataQuality = '高' GROUP BY sensorId ORDER BY high_quality_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = '安防' AND status = '在线' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(10000) AS avg_power, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power DESC LIMIT 3;	EnergyManagementDB	4
SELECT SUM(volume) AS total_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_volume DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(quantity) AS total_sales FROM Orders GROUP BY productId ORDER BY total_sales DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已发货' AND shippingMethod = '快递' ORDER BY orderDate ASC;	ECommerce	3
SELECT userName, email, registrationDate FROM Users WHERE userRole = '管理员' ORDER BY registrationDate DESC;	ECommerce	4
SELECT productName, price, category FROM Products WHERE stock < 10 AND status = '上架' ORDER BY price ASC;	ECommerce	1
SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT e.experimentName, e.description, r.researcherName, l.labName, l.equipmentCount FROM Experiments e JOIN Researchers r ON e.researcherId = r.researcherId JOIN Labs l ON e.labId = l.labId WHERE r.role = '数据分析师' AND e.status = '进行中' ORDER BY e.startDate ASC;	PhysicsLabDB	3
SELECT AVG(julianday('now') - julianday(date('now', '-100 years'))) AS avg_lifetime, deviceId, deviceName FROM Devices GROUP BY deviceId, deviceName ORDER BY avg_lifetime DESC LIMIT 1;	PhysicsLabDB	4
SELECT d.deviceName, d.calibrationDate, l.labName, l.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = '示波器' AND d.calibrationDate > '2023-01-01' ORDER BY d.calibrationDate DESC;	PhysicsLabDB	1
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = '高' AND ed.measurementValue > 100 ORDER BY ed.measurementValue DESC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE deviceType = '娱乐' AND status = '离线' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_current, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_current DESC LIMIT 3;	EnergyManagementDB	4
SELECT SUM(price) AS total_value, productId, productName FROM Products GROUP BY productId, productName ORDER BY total_value DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(discount) AS total_discount FROM Orders GROUP BY productId ORDER BY total_discount DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '待支付' AND paymentMethod = '信用卡' ORDER BY orderDate ASC;	ECommerce	3
SELECT orderId, totalAmount, shippingAddress FROM Orders WHERE orderStatus = '已发货' ORDER BY totalAmount DESC;	ECommerce	4
SELECT AVG(cost) AS avg_cost, maintenanceId FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC LIMIT 3;	PhysicsLabDB	2
SELECT * FROM MaintenanceRecords WHERE maintenanceType = '定期维护' AND cost < 500 ORDER BY maintenanceDate ASC;	EnergyManagementDB	3
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = '高' AND ed.measurementValue > 100 ORDER BY ed.measurementValue DESC;	PhysicsLabDB	4
SELECT AVG(voltage) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;	EnergyManagementDB	1
SELECT sensorId, COUNT(dataId) AS data_count FROM SensorData GROUP BY sensorId ORDER BY data_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = '照明' AND status = '在线' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_voltage, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_voltage DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(weight) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;	ECommerce	1
SELECT userId, COUNT(orderId) AS order_count FROM Orders GROUP BY userId ORDER BY order_count DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已完成' AND shippingMethod = '物流' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(5000) AS avg_weight, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_weight DESC LIMIT 3;	ECommerce	4
SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId JOIN Researchers r ON e.researcherId = r.researcherId WHERE h.verificationResult = '假' AND h.verificationDate > '2023-01-01' ORDER BY h.verificationDate DESC;	ECommerce	1
SELECT deviceId, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY deviceId ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT v.variableName, e.experimentName, sa.sensitivityValue, sa.impact FROM SensitivityAnalysis sa JOIN Variables v ON sa.variableId = v.variableId JOIN Experiments e ON sa.experimentId = e.experimentId WHERE sa.impact = '高' AND sa.sensitivityValue > 0.5 ORDER BY sa.sensitivityValue DESC;	PhysicsLabDB	3
SELECT AVG(1) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;	PhysicsLabDB	4
SELECT c.constraintText, e.experimentName, c.constraintType FROM Constraints c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.constraintType = '不等式' AND c.dataQuality = '高' ORDER BY c.constraintText ASC;	PhysicsLabDB	1
SELECT sensorId, COUNT(dataId) AS low_quality_count FROM SensorData WHERE dataQuality = '低' GROUP BY sensorId ORDER BY low_quality_count DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = '安防' AND status = '故障' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000) AS avg_temperature, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_temperature DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(volume) AS avg_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_volume DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(tax) AS total_tax FROM Orders GROUP BY productId ORDER BY total_tax DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已发货' AND paymentMethod = '支付宝' ORDER BY orderDate ASC;	ECommerce	3
SELECT orderId, shippingDate, actualDeliveryDate FROM Shipping WHERE shippingStatus = '已签收' ORDER BY shippingDate ASC;	ECommerce	4
SELECT SUM(cost) / COUNT(deviceId) AS avg_purchase_price FROM MaintenanceRecords;	EnergyManagementDB	1
SELECT maintenanceType, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY maintenanceType ORDER BY maintenance_count DESC LIMIT 3;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = '停用' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = '仓库') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT SUM(1000000) / COUNT(deviceId) AS avg_purchase_price, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_purchase_price DESC LIMIT 1;	EnergyManagementDB	4
SELECT e.experimentName, ed.measurementValue, ed.environmentalConditions, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId WHERE ed.environmentalConditions LIKE '%温度:3%' ORDER BY ed.environmentalConditions DESC;	PhysicsLabDB	1
SELECT sensorId, COUNT(dataId) * 1.0 / (SELECT COUNT(dataId) FROM SensorData WHERE sensorId = s.sensorId) AS anomaly_ratio FROM SensorData s WHERE dataStatus = '异常' GROUP BY sensorId ORDER BY anomaly_ratio DESC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = '娱乐' AND status = '在线' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(100) AS avg_humidity, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_humidity DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(price) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(discount) AS total_discount FROM Orders GROUP BY userId ORDER BY total_discount DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentMethod = '信用卡' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(100000) AS avg_price, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_price DESC LIMIT 3;	ECommerce	4
SELECT AVG(cost) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	1
SELECT technicianName, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY technicianName ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = '维修中' AND locationId IN (SELECT locationId FROM Locations WHERE locationName = '实验室') ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1000000) AS avg_cost, deviceId FROM MaintenanceRecords GROUP BY deviceId ORDER BY avg_cost DESC LIMIT 3;	EnergyManagementDB	4
SELECT e.experimentName, c.result, c.formula, c.unit FROM Calculations c JOIN Experiments e ON c.experimentId = e.experimentId WHERE c.result > 1000 AND c.dataQuality = '高' ORDER BY c.result DESC;	PhysicsLabDB	1
SELECT sensorId, (strftime('%s', MAX(timestamp)) - strftime('%s', MIN(timestamp))) AS time_interval FROM SensorData GROUP BY sensorId ORDER BY time_interval ASC LIMIT 3;	SmartHomeDB	2
SELECT * FROM Devices WHERE deviceType = '照明' AND status = '离线' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT manufacturerName, contactPerson, city FROM Manufacturers WHERE revenue > 1000 ORDER BY revenue DESC;	SmartHomeDB	4
SELECT productId, SUM(quantity) / stock AS turnover_rate FROM Orders GROUP BY productId ORDER BY turnover_rate DESC LIMIT 3;	ECommerce	1
SELECT productId, SUM(shippingFee) AS total_shipping_fee FROM Orders GROUP BY productId ORDER BY total_shipping_fee DESC LIMIT 5;	ECommerce	2
SELECT productId, rating, reviewText FROM Reviews WHERE rating > 4 ORDER BY rating DESC;	ECommerce	3
SELECT productId, discoutValue, description FROM Discounts WHERE discoutType = '百分比折扣' AND status = '启用' ORDER BY discoutValue DESC;	ECommerce	4
SELECT orderId, totalAmount, paymentMethod FROM Orders WHERE totalAmount > 5000 AND paymentMethod = '支付宝' ORDER BY totalAmount DESC;	ECommerce	1
SELECT productName, price, creationDate FROM Products WHERE category = '电子产品' AND weight < 1 ORDER BY creationDate DESC;	ECommerce	2
SELECT v.variableName, e.experimentName, v.initialValue, v.unit FROM Variables v JOIN Experiments e ON v.experimentId = e.experimentId WHERE v.initialValue > 50 AND v.dataQuality = '高' ORDER BY v.initialValue DESC;	PhysicsLabDB	3
SELECT deviceId, maintenanceDate, maintenanceType FROM MaintenanceRecords WHERE cost > 5000 ORDER BY cost DESC;	EnergyManagementDB	4
SELECT d.deviceName, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.status = '故障' AND l.status = '开放' ORDER BY d.deviceName ASC;	PhysicsLabDB	1
SELECT experimentName, objective, startDate, endDate FROM Experiments WHERE objective LIKE '%energy%' AND status = '已完成' ORDER BY endDate DESC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE deviceType = '安防' AND status = '在线' ORDER BY deviceName ASC;	PhysicsLabDB	3
SELECT AVG(1.5) AS avg_power_factor, deviceId FROM EnergyConsumption GROUP BY deviceId ORDER BY avg_power_factor DESC LIMIT 3;	EnergyManagementDB	4
SELECT AVG(volume) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;	ECommerce	1
SELECT userId, SUM(tax) AS total_tax FROM Orders GROUP BY userId ORDER BY total_tax DESC LIMIT 5;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentMethod = '支付宝' ORDER BY orderDate ASC;	ECommerce	3
SELECT AVG(1000) AS avg_shipping_volume, productId, productName FROM Products GROUP BY productId, productName ORDER BY avg_shipping_volume DESC LIMIT 3;	ECommerce	4
SELECT AVG(julianday(nextMaintenanceDate) - julianday(lastMaintenanceDate)) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 3;	PhysicsLabDB	1
SELECT deviceId, SUM(cost) AS total_cost FROM MaintenanceRecords GROUP BY deviceId ORDER BY total_cost DESC LIMIT 3;	EnergyManagementDB	2
SELECT d.deviceName, d.calibrationDate, l.labName, d.status FROM Devices d JOIN Labs l ON d.labId = l.labId WHERE d.deviceType = '光谱仪' AND d.calibrationDate > '2022-01-01' ORDER BY d.calibrationDate ASC;	PhysicsLabDB	3
SELECT AVG(0) AS avg_interval, deviceId FROM Devices GROUP BY deviceId ORDER BY avg_interval ASC LIMIT 1;	PhysicsLabDB	4
SELECT e.experimentName, ed.measurementValue, d.deviceName, ed.timestamp FROM ExperimentData ed JOIN Experiments e ON ed.experimentId = e.experimentId JOIN Devices d ON ed.deviceId = d.deviceId WHERE ed.dataQuality = '低' AND ed.measurementValue < 50 ORDER BY ed.measurementValue ASC;	PhysicsLabDB	2
SELECT * FROM Devices WHERE warrantyExpiryDate < DATE('now') AND status = '运行中';	PhysicsLabDB	3
SELECT h.hypothesisText, e.experimentName, h.verificationDate, r.researcherName FROM Hypotheses h JOIN Experiments e ON h.experimentId = e.experimentId JOIN Researchers r ON e.researcherId = r.researcherId WHERE h.verificationResult = '真' AND h.verificationDate > '2022-01-01' ORDER BY h.verificationDate ASC;	PhysicsLabDB	4
SELECT deviceType, AVG(measurementValue) AS Avg_Energy_Consumption FROM Devices JOIN ExperimentData ON Devices.deviceId = ExperimentData.deviceId GROUP BY deviceType ORDER BY Avg_Energy_Consumption DESC;	PhysicsLabDB	2
SELECT * FROM SensorData WHERE dataValue > 50 OR dataValue < -20;	SmartHomeDB	3
SELECT ed.deviceType, AVG(ec.energyConsumed) AS avg_energy_consumption FROM EnergyConsumption ec JOIN EnergyDevices ed ON ec.deviceId = ed.deviceId GROUP BY ed.deviceType ORDER BY avg_energy_consumption DESC;	EnergyManagementDB	4
SELECT SUM(weight) AS total_weight FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已完成' AND paymentStatus != '成功';	ECommerce	3
SELECT SUM(weight * 1.5) AS total_weight FROM Products;	ECommerce	4
SELECT o.orderId, o.orderStatus, p.paymentStatus FROM Orders o JOIN Payments p ON o.orderId = p.orderId WHERE o.orderStatus = '已完成' AND p.paymentStatus != '成功';	ECommerce	2
SELECT * FROM Devices WHERE purchaseDate > DATE('now');	PhysicsLabDB	3
SELECT deviceType, status, COUNT(deviceId) AS device_count FROM Devices GROUP BY deviceType, status;	PhysicsLabDB	2
SELECT * FROM Devices WHERE status = '故障' AND deviceId IN (SELECT deviceId FROM ExperimentData WHERE timestamp > DATE('now'));	PhysicsLabDB	3
SELECT SUM(volume) AS total_volume FROM Products;	ECommerce	1
SELECT * FROM EnergyConsumption WHERE deviceId IN (SELECT deviceId FROM EnergyDevices WHERE status = '离线') AND energyConsumed > 0;	EnergyManagementDB	2
SELECT * FROM Orders WHERE orderStatus = '已发货' AND trackingNumber IS NULL;	ECommerce	3
SELECT od.productId, SUM(od.quantity) AS total_sales FROM OrderDetails od GROUP BY od.productId ORDER BY total_sales DESC;	ECommerce	4
SELECT * FROM Orders o JOIN Shipping s ON o.orderId = s.orderId WHERE o.orderStatus = '已发货' AND s.trackingNumber IS NULL;	ECommerce	1
SELECT technicianName, COUNT(maintenanceId) AS maintenance_count FROM MaintenanceRecords GROUP BY technicianName ORDER BY maintenance_count DESC;	EnergyManagementDB	2
SELECT AVG(DATEDIFF(NOW(), purchaseDate)) AS avg_lifespan FROM Devices;	PhysicsLabDB	3
SELECT AVG(JULIANDAY('now') - JULIANDAY(purchaseDate, '-1 year')) AS avg_lifespan FROM Devices;	PhysicsLabDB	4
SELECT * FROM MaintenanceRecords WHERE maintenanceDate < (SELECT installationDate FROM EnergyDevices WHERE EnergyDevices.deviceId = MaintenanceRecords.deviceId);	EnergyManagementDB	2
SELECT * FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '湿度传感器') AND (measurementValue > 100 OR measurementValue < 0);	PhysicsLabDB	3
SELECT s.sensorType, sd.dataQuality, COUNT(sd.dataId) AS data_count FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType, sd.dataQuality;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT SUM(p.weight * s.shippingFee * 0.5) AS total_shipping_cost FROM Products p JOIN Shipping s ON p.productId = s.orderId;	ECommerce	3
SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(JULIANDAY(nextMaintenanceDate) - JULIANDAY(lastMaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;	EnergyManagementDB	1
SELECT category AS product_category, COUNT(productId) AS product_count FROM Products GROUP BY category ORDER BY product_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE maintenanceDate > nextMaintenanceDate;	EnergyManagementDB	3
SELECT labId, COUNT(deviceId) AS device_count FROM Devices GROUP BY labId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE installationDate > NOW();	EnergyManagementDB	3
SELECT e.deviceType, COUNT(m.maintenanceId) / AVG(DATEDIFF(NOW(), e.installationDate)) AS failure_rate FROM MaintenanceRecords m JOIN EnergyDevices e ON m.deviceId = e.deviceId GROUP BY e.deviceType ORDER BY failure_rate DESC;	EnergyManagementDB	4
SELECT AVG(measurementValue) AS avg_weight FROM ExperimentData WHERE unit = 'kg';	PhysicsLabDB	1
SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;	ECommerce	2
SELECT * FROM Products WHERE stock <= 0;	ECommerce	3
SELECT p.category, SUM(od.quantity * p.weight) AS total_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId GROUP BY p.category ORDER BY total_weight DESC;	ECommerce	4
SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;	PhysicsLabDB	1
SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = '运行中' AND calibrationDate IS NULL;	PhysicsLabDB	3
SELECT maintenanceId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	4
SELECT * FROM Devices WHERE status = '运行中' AND lastMaintenanceDate IS NULL;	PhysicsLabDB	2
SELECT * FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;	PhysicsLabDB	3
SELECT sensorId, COUNT(dataId) AS data_frequency FROM SensorData GROUP BY sensorId ORDER BY data_frequency DESC;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT SUM(weight * price * 0.5) AS total_shipping_cost FROM Products;	ECommerce	3
SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(DATEDIFF(paymentDate, orderDate)) AS avg_payment_interval FROM Payments JOIN Orders ON Payments.orderId = Orders.orderId;	ECommerce	1
SELECT address, COUNT(*) AS device_count FROM Manufacturers GROUP BY address ORDER BY device_count DESC;	ECommerce	2
SELECT * FROM MaintenanceRecords WHERE DATEDIFF(nextMaintenanceDate, maintenanceDate) < 0;	EnergyManagementDB	3
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT * FROM EnergyDevices WHERE installationDate > CURRENT_DATE;	EnergyManagementDB	3
SELECT d.deviceType, SUM(e.energyConsumed * d.powerRating * 1.4 * 365 * 24) AS annualElectricityCost FROM EnergyConsumption e JOIN EnergyDevices d ON e.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY annualElectricityCost DESC;	EnergyManagementDB	4
SELECT AVG(weightKg) AS avgWeight FROM Devices;	PhysicsLabDB	1
SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;	ECommerce	2
SELECT * FROM Products WHERE stock <= 0;	ECommerce	3
SELECT SUM(p.weight * od.quantity * 0.7) AS total_shipping_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId;	ECommerce	4
SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;	PhysicsLabDB	1
SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;	EnergyManagementDB	2
SELECT * FROM Devices WHERE status = '运行中' AND lastMaintenanceDate IS NULL;	PhysicsLabDB	3
SELECT deviceId, DATEDIFF(DATE_ADD(installationDate, INTERVAL 1 YEAR), CURRENT_DATE) AS remaining_warranty_days FROM EnergyDevices;	EnergyManagementDB	4
SELECT sensorType, AVG(dataCollectionFrequency) AS avgFrequency FROM Sensors GROUP BY sensorType ORDER BY avgFrequency DESC;	PhysicsLabDB	2
SELECT sensorId, recordedAt, temperature FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;	PhysicsLabDB	3
SELECT s.sensorType, COUNT(sd.dataId) AS data_frequency FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType ORDER BY data_frequency DESC;	SmartHomeDB	4
SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;	ECommerce	1
SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;	ECommerce	2
SELECT * FROM Orders WHERE orderStatus = '已完成' AND orderId NOT IN (SELECT orderId FROM Payments WHERE paymentStatus = '成功');	ECommerce	3
SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;	ECommerce	4
SELECT AVG(DATEDIFF(nextMaintenanceDate, maintenanceDate)) AS avg_maintenance_interval FROM Orders WHERE maintenanceDate IS NOT NULL AND nextMaintenanceDate IS NOT NULL;	ECommerce	1
SELECT category, COUNT(*) AS device_count FROM Products GROUP BY category ORDER BY device_count DESC;	ECommerce	2
SELECT AVG(DATEDIFF(nextMaintenanceDate, MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;	EnergyManagementDB	3
SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;	PhysicsLabDB	4
SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;	EnergyManagementDB	2
SELECT AVG(DATEDIFF(nextMaintenanceDate, MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;	EnergyManagementDB	3
SELECT ed.deviceId, ed.deviceName, ed.powerRating * 1.4 AS newPowerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SUM(ec.energyConsumed) * 1.4 * 0.1) AS annualElectricityCost FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE YEAR(ec.timestamp) = YEAR(CURDATE()) GROUP BY ed.deviceId, ed.deviceName;	EnergyManagementDB	4
